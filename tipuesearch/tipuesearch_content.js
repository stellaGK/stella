var tipuesearch = {"pages":[{"title":" stella ","text":"stella stella solves the gyrokinetic-Poisson system of equations in the local limit\nusing an operator-split, implicit-explicit numerical scheme. It is capable of\nevolving electrostatic fluctuations with fully kinetic electrons and an\narbitrary number of ion species in general magnetic geometry, including\nstellarators. Developer Info The stella team stella has been developed by many developers\nSee the citation\nfile for a complete list","tags":"home","loc":"index.html"},{"title":"stella_io.fpp â€“ stella","text":"Contents Modules stella_io Source Code stella_io.fpp Source Code # include \"define.inc\" module stella_io # ifdef NETCDF use netcdf , only : nf90_noerr use netcdf_utils , only : netcdf_error , kind_nf # endif implicit none private public :: init_stella_io , finish_stella_io public :: write_time_nc public :: write_phi2_nc public :: write_phi_nc public :: write_gvmus_nc public :: write_gzvs_nc public :: write_kspectra_nc public :: write_omega_nc public :: write_moments_nc public :: write_radial_fluxes_nc public :: write_radial_moments_nc public :: write_fluxes_kxkyz_nc public :: get_nout public :: sync_nc # ifdef NETCDF integer ( kind_nf ) :: ncid integer ( kind_nf ) :: naky_dim , nttot_dim , nmu_dim , nvtot_dim , nspec_dim integer ( kind_nf ) :: nakx_dim , ntubes_dim , radgridvar_dim integer ( kind_nf ) :: time_dim , char10_dim , char200_dim , ri_dim , nlines_dim , nheat_dim integer ( kind_nf ) :: nalpha_dim integer , dimension ( 7 ) :: moment_dim integer , dimension ( 6 ) :: field_dim integer , dimension ( 5 ) :: zvs_dim integer , dimension ( 4 ) :: om_dim , vmus_dim , kykxaz_dim integer , dimension ( 6 ) :: flx_dim integer , dimension ( 3 ) :: mode_dim , heat_dim , kykxz_dim , flux_x_dim integer , dimension ( 2 ) :: kx_dim , ky_dim , flux_dim , nin_dim , fmode_dim integer , dimension ( 2 ) :: flux_surface_dim , rad_grid_dim integer :: nakx_id , ntubes_id integer :: naky_id , nttot_id , akx_id , aky_id , zed_id , nspec_id integer :: nmu_id , nvtot_id , mu_id , vpa_id integer :: time_id , phi2_id , theta0_id , nproc_id , nmesh_id integer :: phi_vs_t_id , phi2_vs_kxky_id integer :: dens_x_id , upar_x_id , temp_x_id integer :: pflux_x_id , vflux_x_id , qflux_x_id integer :: pflx_kxkyz_id , vflx_kxkyz_id , qflx_kxkyz_id integer :: density_id , upar_id , temperature_id , spitzer2_id integer :: omega_id integer :: gvmus_id , gzvs_id integer :: input_id integer :: charge_id , mass_id , dens_id , temp_id , tprim_id , fprim_id integer :: vnew_id , spec_type_id integer :: bmag_id , gradpar_id , gbdrift_id , gbdrift0_id , b_dot_grad_z_id integer :: cvdrift_id , cvdrift0_id , gds2_id , gds21_id , gds22_id integer :: kperp2_id , rad_grid_id integer :: grho_id , jacob_id , djacdrho_id , shat_id , drhodpsi_id , q_id , jtwist_id integer :: d2qdr2_id , d2psidr2_id integer :: beta_id integer :: code_id # endif real :: zero !  include 'netcdf.inc' contains !============================================== !============ INITIATE STELLA IO ============== !============================================== subroutine init_stella_io ( restart , write_phi_vs_t , write_kspectra , write_gvmus , & write_gzvs , write_moments , write_omega , write_radial_fluxes , write_radial_moments , write_fluxes_kxky ) use mp , only : proc0 use file_utils , only : run_name # ifdef NETCDF use netcdf , only : nf90_create , nf90_open , nf90_redef use netcdf , only : nf90_clobber , nf90_noclobber , nf90_write use netcdf_utils , only : get_netcdf_code_precision , netcdf_real # endif implicit none logical , intent ( in ) :: restart logical , intent ( in ) :: write_phi_vs_t , write_kspectra , write_gvmus , write_gzvs logical , intent ( in ) :: write_moments , write_omega , write_radial_fluxes , write_radial_moments !, write_symmetry logical , intent ( in ) :: write_fluxes_kxky # ifdef NETCDF character ( 300 ) :: filename integer :: status zero = epsilon ( 0.0 ) if ( netcdf_real == 0 ) netcdf_real = get_netcdf_code_precision () status = nf90_noerr ! The netcdf file has the extension \".out.nc\" filename = trim ( trim ( run_name ) // '.out.nc' ) ! Only the first processor (proc0) opens the file if ( proc0 ) then if ( restart ) then status = nf90_create ( trim ( filename ), nf90_noclobber , ncid ) if ( status /= nf90_noerr ) then status = nf90_open ( trim ( filename ), nf90_write , ncid ) if ( status /= nf90_noerr ) call netcdf_error ( status , file = filename ) status = nf90_redef ( ncid ) end if else status = nf90_create ( trim ( filename ), nf90_clobber , ncid ) end if if ( status /= nf90_noerr ) call netcdf_error ( status , file = filename ) call define_dims call define_vars ( write_phi_vs_t , write_kspectra , write_gvmus , write_gzvs , & write_moments , write_omega , write_radial_fluxes , write_radial_moments , & write_fluxes_kxky ) call nc_grids call nc_species call nc_geo end if # endif end subroutine init_stella_io subroutine define_dims use file_utils , only : num_input_lines use kt_grids , only : naky , nakx , nalpha use zgrid , only : nzgrid , ntubes use vpamu_grids , only : nvpa , nmu use species , only : nspec use physics_flags , only : radial_variation # ifdef NETCDF use netcdf , only : nf90_unlimited use netcdf , only : nf90_def_dim , nf90_inq_dimid # endif # ifdef NETCDF integer :: status ! Associate the grid variables, e.g. ky, kx, with their size, e.g. naky, nakx, ! and a variable which is later used to store these sizes in the NetCDF file, e.g. naky_dim, nakx_dim status = nf90_inq_dimid ( ncid , 'ky' , naky_dim ) if ( status /= nf90_noerr ) then status = nf90_def_dim ( ncid , 'ky' , naky , naky_dim ) if ( status /= nf90_noerr ) call netcdf_error ( status , dim = 'ky' ) end if status = nf90_inq_dimid ( ncid , 'kx' , nakx_dim ) if ( status /= nf90_noerr ) then status = nf90_def_dim ( ncid , 'kx' , nakx , nakx_dim ) if ( status /= nf90_noerr ) call netcdf_error ( status , dim = 'kx' ) end if status = nf90_inq_dimid ( ncid , 'tube' , ntubes_dim ) if ( status /= nf90_noerr ) then status = nf90_def_dim ( ncid , 'tube' , ntubes , ntubes_dim ) if ( status /= nf90_noerr ) call netcdf_error ( status , dim = 'tube' ) end if status = nf90_inq_dimid ( ncid , 'zed' , nttot_dim ) if ( status /= nf90_noerr ) then status = nf90_def_dim ( ncid , 'zed' , 2 * nzgrid + 1 , nttot_dim ) if ( status /= nf90_noerr ) call netcdf_error ( status , dim = 'zed' ) end if status = nf90_inq_dimid ( ncid , 'alpha' , nalpha_dim ) if ( status /= nf90_noerr ) then status = nf90_def_dim ( ncid , 'alpha' , nalpha , nalpha_dim ) if ( status /= nf90_noerr ) call netcdf_error ( status , dim = 'alpha' ) end if status = nf90_inq_dimid ( ncid , 'vpa' , nvtot_dim ) if ( status /= nf90_noerr ) then status = nf90_def_dim ( ncid , 'vpa' , nvpa , nvtot_dim ) if ( status /= nf90_noerr ) call netcdf_error ( status , dim = 'vpa' ) end if status = nf90_inq_dimid ( ncid , 'mu' , nmu_dim ) if ( status /= nf90_noerr ) then status = nf90_def_dim ( ncid , 'mu' , nmu , nmu_dim ) if ( status /= nf90_noerr ) call netcdf_error ( status , dim = 'mu' ) end if status = nf90_inq_dimid ( ncid , 'species' , nspec_dim ) if ( status /= nf90_noerr ) then status = nf90_def_dim ( ncid , 'species' , nspec , nspec_dim ) if ( status /= nf90_noerr ) call netcdf_error ( status , dim = 'species' ) end if status = nf90_inq_dimid ( ncid , 't' , time_dim ) if ( status /= nf90_noerr ) then status = nf90_def_dim ( ncid , 't' , nf90_unlimited , time_dim ) if ( status /= nf90_noerr ) call netcdf_error ( status , dim = 't' ) end if status = nf90_inq_dimid ( ncid , 'char10' , char10_dim ) if ( status /= nf90_noerr ) then status = nf90_def_dim ( ncid , 'char10' , 10 , char10_dim ) if ( status /= nf90_noerr ) call netcdf_error ( status , dim = 'char10' ) end if status = nf90_inq_dimid ( ncid , 'char200' , char200_dim ) if ( status /= nf90_noerr ) then status = nf90_def_dim ( ncid , 'char200' , 200 , char200_dim ) if ( status /= nf90_noerr ) call netcdf_error ( status , dim = 'char200' ) end if status = nf90_inq_dimid ( ncid , 'nlines' , nlines_dim ) if ( status /= nf90_noerr ) then status = nf90_def_dim ( ncid , 'nlines' , num_input_lines , nlines_dim ) if ( status /= nf90_noerr ) call netcdf_error ( status , dim = 'nlines' ) end if status = nf90_inq_dimid ( ncid , 'ri' , ri_dim ) if ( status /= nf90_noerr ) then status = nf90_def_dim ( ncid , 'ri' , 2 , ri_dim ) if ( status /= nf90_noerr ) call netcdf_error ( status , dim = 'ri' ) end if if ( radial_variation ) then status = nf90_inq_dimid ( ncid , 'radgridvar' , radgridvar_dim ) if ( status /= nf90_noerr ) then ! size 3: x, q/psi, rho status = nf90_def_dim ( ncid , 'radgridvar' , 3 , radgridvar_dim ) if ( status /= nf90_noerr ) call netcdf_error ( status , dim = 'radgridvar' ) end if end if # endif end subroutine define_dims subroutine finish_stella_io use mp , only : proc0 # ifdef NETCDF use netcdf , only : nf90_close use netcdf_utils , only : netcdf_error integer :: status if ( proc0 ) then call save_input status = nf90_close ( ncid ) if ( status /= nf90_noerr ) call netcdf_error ( status ) end if # endif end subroutine finish_stella_io subroutine save_input !<doc> Save the input file in the NetCDF file </doc> # ifdef NETCDF use file_utils , only : num_input_lines , get_input_unit use netcdf , only : nf90_put_var character ( 200 ) line integer , dimension ( 2 ) :: nin_start , nin_count integer :: status , n , unit nin_start ( 1 ) = 1 nin_start ( 2 ) = 1 nin_count ( 2 ) = 1 call get_input_unit ( unit ) rewind ( unit = unit ) do n = 1 , num_input_lines read ( unit = unit , fmt = \"(a)\" ) line nin_count ( 1 ) = len ( trim ( line )) !       status = nf_put_vara_text (ncid, input_id, nin_start, nin_count, line) status = nf90_put_var ( ncid , input_id , line , start = nin_start , count = nin_count ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , input_id ) nin_start ( 2 ) = nin_start ( 2 ) + 1 end do # endif end subroutine save_input subroutine define_vars ( write_phi_vs_t , write_kspectra , write_gvmus , & !       write_gzvs, write_symmetry, write_moments) write_gzvs , write_moments , write_omega , write_radial_fluxes , & write_radial_moments , write_fluxes_kxky ) use mp , only : nproc use run_parameters , only : fphi !, fapar, fbpar use physics_flags , only : radial_variation # ifdef NETCDF use netcdf , only : nf90_char , nf90_int , nf90_global use netcdf , only : nf90_def_var , nf90_inq_varid , nf90_put_att , nf90_enddef , nf90_put_var use netcdf , only : nf90_inq_libvers use netcdf_utils , only : netcdf_real # endif implicit none logical , intent ( in ) :: write_phi_vs_t , write_kspectra , write_gvmus , write_gzvs !, write_symmetry logical , intent ( in ) :: write_moments , write_omega , write_radial_fluxes , write_radial_moments logical , intent ( in ) :: write_fluxes_kxky # ifdef NETCDF character ( 5 ) :: ci character ( 20 ) :: datestamp , timestamp , timezone integer :: status flux_surface_dim ( 1 ) = nalpha_dim flux_surface_dim ( 2 ) = nttot_dim fmode_dim ( 1 ) = naky_dim fmode_dim ( 2 ) = nakx_dim mode_dim ( 1 ) = naky_dim mode_dim ( 2 ) = nakx_dim mode_dim ( 3 ) = time_dim flx_dim ( 1 ) = naky_dim flx_dim ( 2 ) = nakx_dim flx_dim ( 3 ) = nttot_dim flx_dim ( 4 ) = ntubes_dim flx_dim ( 5 ) = nspec_dim flx_dim ( 6 ) = time_dim kx_dim ( 1 ) = nakx_dim kx_dim ( 2 ) = time_dim ky_dim ( 1 ) = naky_dim ky_dim ( 2 ) = time_dim om_dim ( 1 ) = ri_dim om_dim ( 2 ) = naky_dim om_dim ( 3 ) = nakx_dim om_dim ( 4 ) = time_dim nin_dim ( 1 ) = char200_dim nin_dim ( 2 ) = nlines_dim flux_dim ( 1 ) = nspec_dim flux_dim ( 2 ) = time_dim flux_x_dim ( 1 ) = nakx_dim flux_x_dim ( 2 ) = nspec_dim flux_x_dim ( 3 ) = time_dim rad_grid_dim ( 1 ) = radgridvar_dim rad_grid_dim ( 2 ) = nakx_dim heat_dim ( 1 ) = nspec_dim heat_dim ( 2 ) = nheat_dim heat_dim ( 3 ) = time_dim field_dim ( 1 ) = ri_dim field_dim ( 2 ) = naky_dim field_dim ( 3 ) = nakx_dim field_dim ( 4 ) = nttot_dim field_dim ( 5 ) = ntubes_dim field_dim ( 6 ) = time_dim moment_dim ( 1 ) = ri_dim moment_dim ( 2 ) = naky_dim moment_dim ( 3 ) = nakx_dim moment_dim ( 4 ) = nttot_dim moment_dim ( 5 ) = ntubes_dim moment_dim ( 6 ) = nspec_dim moment_dim ( 7 ) = time_dim vmus_dim ( 1 ) = nvtot_dim vmus_dim ( 2 ) = nmu_dim vmus_dim ( 3 ) = nspec_dim vmus_dim ( 4 ) = time_dim zvs_dim ( 1 ) = ntubes_dim zvs_dim ( 2 ) = nttot_dim zvs_dim ( 3 ) = nvtot_dim zvs_dim ( 4 ) = nspec_dim zvs_dim ( 5 ) = time_dim kykxz_dim ( 1 ) = naky_dim kykxz_dim ( 2 ) = nakx_dim kykxz_dim ( 3 ) = nttot_dim kykxaz_dim ( 1 ) = naky_dim kykxaz_dim ( 2 ) = nakx_dim kykxaz_dim ( 3 ) = nalpha_dim kykxaz_dim ( 4 ) = nttot_dim ! Write some useful general information such as the website, ! date and time into the NetCDF file status = nf90_put_att ( ncid , nf90_global , 'title' , 'stella simulation data' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , nf90_global , att = 'title' ) datestamp (:) = ' ' timestamp (:) = ' ' timezone (:) = ' ' call date_and_time ( datestamp , timestamp , timezone ) status = nf90_inq_varid ( ncid , 'code_info' , code_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'code_info' , nf90_char , char10_dim , code_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'code_info' ) end if status = nf90_put_att ( ncid , code_id , 'long_name' , 'stella' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , code_id , att = 'long_name' ) ci = 'c1' status = nf90_put_att ( ncid , code_id , trim ( ci ), 'Date: ' // trim ( datestamp )) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , code_id , att = ci ) ci = 'c2' status = nf90_put_att ( ncid , code_id , trim ( ci ), & 'Time: ' // trim ( timestamp ) // ' ' // trim ( timezone )) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , code_id , att = ci ) ci = 'c3' status = nf90_put_att ( ncid , code_id , trim ( ci ), & 'netCDF version ' // trim ( nf90_inq_libvers ())) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , code_id , att = ci ) ci = 'c4' status = nf90_put_att ( ncid , code_id , trim ( ci ), & 'Units are determined with respect to reference temperature (T_ref),' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , code_id , att = ci ) ci = 'c5' status = nf90_put_att ( ncid , code_id , trim ( ci ), & 'reference charge (q_ref), reference mass (mass_ref),' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , code_id , att = ci ) ci = 'c6' status = nf90_put_att ( ncid , code_id , trim ( ci ), & 'reference field (B_ref), and reference length (a_ref)' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , code_id , att = ci ) ci = 'c7' status = nf90_put_att ( ncid , code_id , trim ( ci ), & 'from which one may construct rho_ref and vt_ref/a,' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , code_id , att = ci ) ci = 'c8' status = nf90_put_att ( ncid , code_id , trim ( ci ), & 'which are the basic units of perpendicular length and time.' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , code_id , att = ci ) ci = 'c9' status = nf90_put_att ( ncid , code_id , trim ( ci ), & 'Macroscopic lengths are normalized to the minor radius.' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , code_id , att = ci ) ci = 'c10' status = nf90_put_att ( ncid , code_id , trim ( ci ), & 'The difference between rho (normalized minor radius) and rho (gyroradius)' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , code_id , att = ci ) ci = 'c11' status = nf90_put_att ( ncid , code_id , trim ( ci ), & 'should be clear from the context in which they appear below.' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , code_id , att = ci ) ! Write lots of input variables (e.g. nproc, nkx, nky) ! into the NetCDF file status = nf90_inq_varid ( ncid , 'nproc' , nproc_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'nproc' , nf90_int , nproc_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'nproc' ) end if status = nf90_put_att ( ncid , nproc_id , 'long_name' , 'Number of processors' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , nproc_id , att = 'long_name' ) status = nf90_inq_varid ( ncid , 'nmesh' , nmesh_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'nmesh' , netcdf_real , nmesh_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'nmesh' ) end if status = nf90_put_att ( ncid , nmesh_id , 'long_name' , 'Number of meshpoints' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , nmesh_id , att = 'long_name' ) status = nf90_inq_varid ( ncid , 'ntubes' , ntubes_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'ntubes' , nf90_int , ntubes_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'ntubes' ) end if status = nf90_inq_varid ( ncid , 'nkx' , nakx_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'nkx' , nf90_int , nakx_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'nkx' ) end if status = nf90_inq_varid ( ncid , 'nky' , naky_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'nky' , nf90_int , naky_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'nky' ) end if status = nf90_inq_varid ( ncid , 'nzed_tot' , nttot_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'nzed_tot' , nf90_int , nttot_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'nzed_tot' ) end if status = nf90_inq_varid ( ncid , 'nspecies' , nspec_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'nspecies' , nf90_int , nspec_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'nspecies' ) end if status = nf90_inq_varid ( ncid , 'nmu' , nmu_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'nmu' , nf90_int , nmu_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'nmu' ) end if status = nf90_inq_varid ( ncid , 'nvpa_tot' , nvtot_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'nvpa_tot' , nf90_int , nvtot_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'nvpa_tot' ) end if status = nf90_inq_varid ( ncid , 't' , time_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 't' , netcdf_real , time_dim , time_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 't' ) end if status = nf90_put_att ( ncid , time_id , 'long_name' , 'Time' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , time_id , att = 'long_name' ) status = nf90_put_att ( ncid , time_id , 'units' , 'L/vt' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , time_id , att = 'units' ) status = nf90_inq_varid ( ncid , 'charge' , charge_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'charge' , nf90_int , nspec_dim , charge_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'charge' ) end if status = nf90_put_att ( ncid , charge_id , 'long_name' , 'Charge' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , charge_id , att = 'long_name' ) status = nf90_put_att ( ncid , charge_id , 'units' , 'q' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , charge_id , att = 'units' ) status = nf90_inq_varid ( ncid , 'mass' , mass_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'mass' , netcdf_real , nspec_dim , mass_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'mass' ) end if status = nf90_put_att ( ncid , mass_id , 'long_name' , 'Atomic mass' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , mass_id , att = 'long_name' ) status = nf90_put_att ( ncid , mass_id , 'units' , 'm' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , mass_id , att = 'units' ) status = nf90_inq_varid ( ncid , 'dens' , dens_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'dens' , netcdf_real , nspec_dim , dens_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'dens' ) end if status = nf90_put_att ( ncid , dens_id , 'long_name' , 'Density' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , dens_id , att = 'long_name' ) status = nf90_put_att ( ncid , dens_id , 'units' , 'n_e' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , dens_id , att = 'units' ) status = nf90_inq_varid ( ncid , 'temp' , temp_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'temp' , netcdf_real , nspec_dim , temp_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'temp' ) end if status = nf90_put_att ( ncid , temp_id , 'long_name' , 'Temperature' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , temp_id , att = 'long_name' ) status = nf90_put_att ( ncid , temp_id , 'units' , 'T' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , temp_id , att = 'units' ) status = nf90_inq_varid ( ncid , 'tprim' , tprim_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'tprim' , netcdf_real , nspec_dim , tprim_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'tprim' ) end if status = nf90_put_att ( ncid , tprim_id , 'long_name' , '-1/rho dT/drho' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , tprim_id , att = 'long_name' ) status = nf90_inq_varid ( ncid , 'fprim' , fprim_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'fprim' , netcdf_real , nspec_dim , fprim_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'fprim' ) end if status = nf90_put_att ( ncid , fprim_id , 'long_name' , '-1/rho dn/drho' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , fprim_id , att = 'long_name' ) status = nf90_inq_varid ( ncid , 'vnew' , vnew_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'vnew' , netcdf_real , nspec_dim , vnew_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'vnew' ) end if status = nf90_put_att ( ncid , vnew_id , 'long_name' , 'Collisionality' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , vnew_id , att = 'long_name' ) status = nf90_put_att ( ncid , vnew_id , 'units' , 'v_t/L' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , vnew_id , att = 'units' ) status = nf90_inq_varid ( ncid , 'type_of_species' , spec_type_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'type_of_species' , nf90_int , nspec_dim , spec_type_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'type_of_species' ) end if status = nf90_inq_varid ( ncid , 'theta0' , theta0_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'theta0' , netcdf_real , fmode_dim , theta0_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'theta0' ) end if status = nf90_put_att ( ncid , theta0_id , 'long_name' , 'Theta_0' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , theta0_id , att = 'long_name' ) status = nf90_inq_varid ( ncid , 'kx' , akx_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'kx' , netcdf_real , nakx_dim , akx_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'kx' ) end if status = nf90_put_att ( ncid , akx_id , 'long_name' , 'kx rho' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , akx_id , att = 'long_name' ) if ( radial_variation ) then status = nf90_inq_varid ( ncid , 'rad_grid' , rad_grid_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'rad_grid' , netcdf_real , rad_grid_dim , rad_grid_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'rad_grid' ) end if status = nf90_put_att ( ncid , rad_grid_id , 'long_name' , 'x, q/psi, rho' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , rad_grid_id , att = 'long_name' ) end if status = nf90_inq_varid ( ncid , 'ky' , aky_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'ky' , netcdf_real , naky_dim , aky_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'ky' ) end if status = nf90_put_att ( ncid , aky_id , 'long_name' , 'ky rho' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , aky_id , att = 'long_name' ) status = nf90_inq_varid ( ncid , 'mu' , mu_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'mu' , netcdf_real , nmu_dim , mu_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'mu' ) end if status = nf90_inq_varid ( ncid , 'vpa' , vpa_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'vpa' , netcdf_real , nvtot_dim , vpa_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'vpa' ) end if status = nf90_inq_varid ( ncid , 'zed' , zed_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'zed' , netcdf_real , nttot_dim , zed_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'zed' ) end if status = nf90_inq_varid ( ncid , 'bmag' , bmag_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'bmag' , netcdf_real , flux_surface_dim , bmag_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'bmag' ) end if status = nf90_put_att ( ncid , bmag_id , 'long_name' , '|B|(alpha,zed)' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , bmag_id , att = 'long_name' ) status = nf90_put_att ( ncid , bmag_id , 'units' , 'B_0' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , bmag_id , att = 'units' ) status = nf90_inq_varid ( ncid , 'b_dot_grad_z' , b_dot_grad_z_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'b_dot_grad_z' , netcdf_real , flux_surface_dim , b_dot_grad_z_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'b_dot_grad_z' ) end if status = nf90_put_att ( ncid , b_dot_grad_z_id , 'long_name' , 'b . grad z(alpha,zed)' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , b_dot_grad_z_id , att = 'long_name' ) status = nf90_put_att ( ncid , b_dot_grad_z_id , 'units' , 'dimensionless' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , b_dot_grad_z_id , att = 'units' ) status = nf90_inq_varid ( ncid , 'gradpar' , gradpar_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'gradpar' , netcdf_real , nttot_dim , gradpar_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'gradpar' ) end if status = nf90_inq_varid ( ncid , 'gbdrift' , gbdrift_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'gbdrift' , netcdf_real , flux_surface_dim , gbdrift_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'gbdrift' ) end if status = nf90_inq_varid ( ncid , 'gbdrift0' , gbdrift0_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'gbdrift0' , netcdf_real , flux_surface_dim , gbdrift0_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'gbdrift0' ) end if status = nf90_inq_varid ( ncid , 'cvdrift' , cvdrift_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'cvdrift' , netcdf_real , flux_surface_dim , cvdrift_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'cvdrift' ) end if status = nf90_inq_varid ( ncid , 'cvdrift0' , cvdrift0_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'cvdrift0' , netcdf_real , flux_surface_dim , cvdrift0_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'cvdrift0' ) end if status = nf90_inq_varid ( ncid , 'kperp2' , kperp2_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'kperp2' , netcdf_real , kykxaz_dim , kperp2_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'kperp2' ) end if status = nf90_inq_varid ( ncid , 'gds2' , gds2_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'gds2' , netcdf_real , flux_surface_dim , gds2_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'gds2' ) end if status = nf90_inq_varid ( ncid , 'gds21' , gds21_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'gds21' , netcdf_real , flux_surface_dim , gds21_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'gds21' ) end if status = nf90_inq_varid ( ncid , 'gds22' , gds22_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'gds22' , netcdf_real , flux_surface_dim , gds22_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'gds22' ) end if status = nf90_inq_varid ( ncid , 'grho' , grho_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'grho' , netcdf_real , flux_surface_dim , grho_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'grho' ) end if status = nf90_inq_varid ( ncid , 'jacob' , jacob_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'jacob' , netcdf_real , flux_surface_dim , jacob_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'jacob' ) end if status = nf90_inq_varid ( ncid , 'djacdrho' , djacdrho_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'djacdrho' , netcdf_real , flux_surface_dim , djacdrho_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'djacdrho' ) end if status = nf90_inq_varid ( ncid , 'q' , q_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'q' , netcdf_real , q_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'q' ) end if status = nf90_put_att ( ncid , q_id , 'long_name' , 'local safety factor' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , q_id , att = 'long_name' ) status = nf90_inq_varid ( ncid , 'beta' , beta_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'beta' , netcdf_real , beta_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'beta' ) end if status = nf90_put_att ( ncid , beta_id , 'long_name' , 'reference beta' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , beta_id , att = 'long_name' ) status = nf90_inq_varid ( ncid , 'shat' , shat_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'shat' , netcdf_real , shat_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'shat' ) end if status = nf90_put_att ( ncid , shat_id , 'long_name' , '(rho/q) dq/drho' ) status = nf90_inq_varid ( ncid , 'd2qdr2' , d2qdr2_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'd2qdr2' , netcdf_real , d2qdr2_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'd2qdr2' ) end if if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , shat_id , att = 'long_name' ) status = nf90_inq_varid ( ncid , 'jtwist' , jtwist_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'jtwist' , netcdf_real , jtwist_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'jtwist' ) end if status = nf90_put_att ( ncid , jtwist_id , 'long_name' , '2*pi*shat*dky/dkx' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , jtwist_id , att = 'long_name' ) status = nf90_inq_varid ( ncid , 'drhodpsi' , drhodpsi_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'drhodpsi' , netcdf_real , drhodpsi_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'drhodpsi' ) end if status = nf90_put_att ( ncid , drhodpsi_id , 'long_name' , 'drho/dPsi' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , drhodpsi_id , att = 'long_name' ) status = nf90_inq_varid ( ncid , 'd2psidr2' , d2psidr2_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'd2psidr2' , netcdf_real , d2psidr2_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'd2psidr2' ) end if if ( write_omega ) then status = nf90_inq_varid ( ncid , 'omega' , omega_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'omega' , netcdf_real , om_dim , omega_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'omega' ) end if end if if ( fphi > zero ) then status = nf90_inq_varid ( ncid , 'phi2' , phi2_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'phi2' , netcdf_real , time_dim , phi2_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'phi2' ) end if status = nf90_put_att ( ncid , phi2_id , 'long_name' , '|Potential**2|' ) if ( status /= nf90_noerr ) & call netcdf_error ( status , ncid , phi2_id , att = 'long_name' ) status = nf90_put_att ( ncid , phi2_id , 'units' , '(T/q rho/L)**2' ) if ( status /= nf90_noerr ) & call netcdf_error ( status , ncid , phi2_id , att = 'units' ) !        status = nf90_def_var & !             (ncid, 'phi2_by_mode', netcdf_real, mode_dim, phi2_by_mode_id) !        if (status /= nf90_noerr) call netcdf_error (status, var='phi2_by_mode') !        if (nakx > 1) then !           status = nf90_def_var & !                (ncid, 'phi2_by_kx', netcdf_real, kx_dim, phi2_by_kx_id) !           if (status /= nf90_noerr) & !                call netcdf_error (status, var='phi2_by_kx') !        end if !        if (naky > 1) then !           status = nf90_def_var & !                (ncid, 'phi2_by_ky', netcdf_real, ky_dim, phi2_by_ky_id) !           if (status /= nf90_noerr) & !                call netcdf_error (status, var='phi2_by_ky') !        end if if ( write_phi_vs_t ) then status = nf90_inq_varid ( ncid , 'phi_vs_t' , phi_vs_t_id ) if ( status /= nf90_noerr ) then status = nf90_def_var & ( ncid , 'phi_vs_t' , netcdf_real , field_dim , phi_vs_t_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'phi_vs_t' ) end if status = nf90_put_att ( ncid , phi_vs_t_id , 'long_name' , 'Electrostatic Potential vs time' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , phi_vs_t_id , att = 'long_name' ) end if if ( write_radial_moments ) then status = nf90_inq_varid ( ncid , 'dens_x' , dens_x_id ) if ( status /= nf90_noerr ) then status = nf90_def_var & ( ncid , 'dens_x' , netcdf_real , flux_x_dim , dens_x_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'dens_x' ) end if status = nf90_inq_varid ( ncid , 'upar_x' , upar_x_id ) if ( status /= nf90_noerr ) then status = nf90_def_var & ( ncid , 'upar_x' , netcdf_real , flux_x_dim , upar_x_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'upar_x' ) end if status = nf90_inq_varid ( ncid , 'temp_x' , temp_x_id ) if ( status /= nf90_noerr ) then status = nf90_def_var & ( ncid , 'temp_x' , netcdf_real , flux_x_dim , temp_x_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'temp_x' ) end if end if if ( write_radial_fluxes ) then status = nf90_inq_varid ( ncid , 'pflux_x' , pflux_x_id ) if ( status /= nf90_noerr ) then status = nf90_def_var & ( ncid , 'pflux_x' , netcdf_real , flux_x_dim , pflux_x_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'pflux_x' ) end if status = nf90_inq_varid ( ncid , 'vflux_x' , vflux_x_id ) if ( status /= nf90_noerr ) then status = nf90_def_var & ( ncid , 'vflux_x' , netcdf_real , flux_x_dim , vflux_x_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'vflux_x' ) end if status = nf90_inq_varid ( ncid , 'qflux_x' , qflux_x_id ) if ( status /= nf90_noerr ) then status = nf90_def_var & ( ncid , 'qflux_x' , netcdf_real , flux_x_dim , qflux_x_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'qflux_x' ) end if end if if ( write_kspectra ) then status = nf90_inq_varid ( ncid , 'phi2_vs_kxky' , phi2_vs_kxky_id ) if ( status /= nf90_noerr ) then status = nf90_def_var & ( ncid , 'phi2_vs_kxky' , netcdf_real , mode_dim , phi2_vs_kxky_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'phi2_vs_kxky' ) end if status = nf90_put_att ( ncid , phi2_vs_kxky_id , 'long_name' , 'Electrostatic Potential vs (ky,kx,t)' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , phi2_vs_kxky_id , att = 'long_name' ) end if end if ! ! ! if ( write_fluxes_kxky ) then status = nf90_inq_varid ( ncid , 'pflx_kxky' , pflx_kxkyz_id ) if ( status /= nf90_noerr ) then status = nf90_def_var & ( ncid , 'pflx_kxky' , netcdf_real , flx_dim , pflx_kxkyz_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'pflx_kxky' ) end if status = nf90_put_att ( ncid , pflx_kxkyz_id , 'long_name' , 'Particle flux vs (ky,kx,spec,t)' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , pflx_kxkyz_id , att = 'long_name' ) ! status = nf90_inq_varid ( ncid , 'vflx_kxky' , vflx_kxkyz_id ) if ( status /= nf90_noerr ) then status = nf90_def_var & ( ncid , 'vflx_kxky' , netcdf_real , flx_dim , vflx_kxkyz_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'vflx_kxky' ) end if status = nf90_put_att ( ncid , vflx_kxkyz_id , 'long_name' , 'Momentum flux vs (ky,kx,spec,t)' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , vflx_kxkyz_id , att = 'long_name' ) ! status = nf90_inq_varid ( ncid , 'qflx_kxky' , qflx_kxkyz_id ) if ( status /= nf90_noerr ) then status = nf90_def_var & ( ncid , 'qflx_kxky' , netcdf_real , flx_dim , qflx_kxkyz_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'qflx_kxky' ) end if status = nf90_put_att ( ncid , qflx_kxkyz_id , 'long_name' , 'Heat flux vs (ky,kx,spec,t)' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , qflx_kxkyz_id , att = 'long_name' ) end if ! ! ! if ( write_moments ) then status = nf90_inq_varid ( ncid , 'density' , density_id ) if ( status /= nf90_noerr ) then status = nf90_def_var & ( ncid , 'density' , netcdf_real , moment_dim , density_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'density' ) end if status = nf90_put_att ( ncid , density_id , 'long_name' , 'perturbed density vs (ky,kx,z,t)' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , density_id , att = 'long_name' ) status = nf90_inq_varid ( ncid , 'upar' , upar_id ) if ( status /= nf90_noerr ) then status = nf90_def_var & ( ncid , 'upar' , netcdf_real , moment_dim , upar_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'upar' ) end if status = nf90_put_att ( ncid , upar_id , 'long_name' , 'perturbed parallel flow vs (ky,kx,z,t)' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , upar_id , att = 'long_name' ) status = nf90_inq_varid ( ncid , 'temperature' , temperature_id ) if ( status /= nf90_noerr ) then status = nf90_def_var & ( ncid , 'temperature' , netcdf_real , moment_dim , temperature_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'temperature' ) end if status = nf90_put_att ( ncid , temperature_id , 'long_name' , 'perturbed temperature vs (ky,kx,z,t)' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , temperature_id , att = 'long_name' ) status = nf90_inq_varid ( ncid , 'spitzer2' , spitzer2_id ) if ( status /= nf90_noerr ) then status = nf90_def_var & ( ncid , 'spitzer2' , netcdf_real , moment_dim , spitzer2_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'spitzer2' ) end if status = nf90_put_att ( ncid , spitzer2_id , 'long_name' , 'integral req. for 2. Spitzer coeff' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , spitzer2_id , att = 'long_name' ) end if if ( write_gvmus ) then status = nf90_inq_varid ( ncid , 'gvmus' , gvmus_id ) if ( status /= nf90_noerr ) then status = nf90_def_var & ( ncid , 'gvmus' , netcdf_real , vmus_dim , gvmus_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'gvmus' ) end if status = nf90_put_att ( ncid , gvmus_id , 'long_name' , & 'guiding center distribution function averaged over real space' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , gvmus_id , att = 'long_name' ) end if if ( write_gzvs ) then status = nf90_inq_varid ( ncid , 'gzvs' , gzvs_id ) if ( status /= nf90_noerr ) then status = nf90_def_var & ( ncid , 'gzvs' , netcdf_real , zvs_dim , gzvs_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'gzvs' ) end if status = nf90_put_att ( ncid , gvmus_id , 'long_name' , & 'guiding center distribution function averaged over (kx,ky,mu)' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , gzvs_id , att = 'long_name' ) end if !    if (write_symmetry) then !        status = nf90_def_var & !             (ncid, 'pflx_zvpa', netcdf_real, zvs_dim, gzvs_id) !        if (status /= nf90_noerr) call netcdf_error (status, var='gzvs') !        status = nf90_put_att (ncid, gvmus_id, 'long_name', & !             'guiding center distribution function averaged over (kx,ky,mu)') !        if (status /= nf90_noerr) call netcdf_error (status, ncid, gzvs_id, att='long_name') !    end if status = nf90_inq_varid ( ncid , 'input_file' , input_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'input_file' , nf90_char , nin_dim , input_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'input_file' ) end if status = nf90_put_att ( ncid , input_id , 'long_name' , 'Input file' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , input_id , att = 'long_name' ) status = nf90_enddef ( ncid ) ! out of definition mode if ( status /= nf90_noerr ) call netcdf_error ( status ) status = nf90_put_var ( ncid , nproc_id , nproc ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , nproc_id ) # endif end subroutine define_vars subroutine write_time_nc ( nout , time ) # ifdef NETCDF use netcdf , only : nf90_put_var , nf90_sync # endif implicit none integer , intent ( in ) :: nout real , intent ( in ) :: time # ifdef NETCDF integer :: status status = nf90_put_var ( ncid , time_id , time , start = ( / nout / )) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , time_id ) !   The two lines below are added to flush buffers to disk status = NF90_SYNC ( ncid ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , time_id ) # endif end subroutine write_time_nc subroutine write_phi2_nc ( nout , phi2 ) # ifdef NETCDF use netcdf , only : nf90_put_var # endif implicit none integer , intent ( in ) :: nout real , intent ( in ) :: phi2 # ifdef NETCDF integer :: status status = nf90_put_var ( ncid , phi2_id , phi2 , start = ( / nout / )) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , phi2_id ) # endif end subroutine write_phi2_nc subroutine write_phi_nc ( nout , phi ) use convert , only : c2r use zgrid , only : nzgrid , ntubes use kt_grids , only : nakx , naky # ifdef NETCDF use netcdf , only : nf90_put_var , nf90_sync # endif implicit none integer , intent ( in ) :: nout complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: phi # ifdef NETCDF integer :: status integer , dimension ( 6 ) :: start , count real , dimension (:, :, :, :, :), allocatable :: phi_ri start = 1 start ( 6 ) = nout count ( 1 ) = 2 count ( 2 ) = naky count ( 3 ) = nakx count ( 4 ) = 2 * nzgrid + 1 count ( 5 ) = ntubes count ( 6 ) = 1 allocate ( phi_ri ( 2 , naky , nakx , 2 * nzgrid + 1 , ntubes )) call c2r ( phi , phi_ri ) status = nf90_put_var ( ncid , phi_vs_t_id , phi_ri , start = start , count = count ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , phi_vs_t_id ) !   Buffers to disk status = NF90_SYNC ( ncid ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , phi_vs_t_id ) deallocate ( phi_ri ) # endif end subroutine write_phi_nc subroutine write_omega_nc ( nout , omega ) # ifdef NETCDF use netcdf , only : nf90_put_var # endif implicit none integer , intent ( in ) :: nout complex , dimension (:, :), intent ( in ) :: omega # ifdef NETCDF integer :: status status = nf90_put_var ( ncid , omega_id , [ real ( omega ), aimag ( omega )], start = [ 1 , 1 , 1 , nout ]) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , omega_id ) # endif end subroutine write_omega_nc subroutine write_radial_fluxes_nc ( nout , pflux , vflux , qflux ) use kt_grids , only : nakx use species , only : nspec # ifdef NETCDF use netcdf , only : nf90_put_var # endif implicit none integer , intent ( in ) :: nout real , dimension (:, :), intent ( in ) :: pflux , vflux , qflux # ifdef NETCDF integer :: status integer , dimension ( 3 ) :: start , count start = 1 start ( 3 ) = nout count ( 1 ) = nakx count ( 2 ) = nspec count ( 3 ) = 1 status = nf90_put_var ( ncid , pflux_x_id , pflux , start = start , count = count ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , pflux_x_id ) status = nf90_put_var ( ncid , vflux_x_id , vflux , start = start , count = count ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , vflux_x_id ) status = nf90_put_var ( ncid , qflux_x_id , qflux , start = start , count = count ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , qflux_x_id ) # endif end subroutine write_radial_fluxes_nc subroutine write_radial_moments_nc ( nout , dens_x , upar_x , temp_x ) use kt_grids , only : nakx use species , only : nspec # ifdef NETCDF use netcdf , only : nf90_put_var # endif implicit none integer , intent ( in ) :: nout real , dimension (:, :), intent ( in ) :: dens_x , upar_x , temp_x # ifdef NETCDF integer :: status integer , dimension ( 3 ) :: start , count start = 1 start ( 3 ) = nout count ( 1 ) = nakx count ( 2 ) = nspec count ( 3 ) = 1 status = nf90_put_var ( ncid , dens_x_id , dens_x , start = start , count = count ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , dens_x_id ) status = nf90_put_var ( ncid , upar_x_id , upar_x , start = start , count = count ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , upar_x_id ) status = nf90_put_var ( ncid , temp_x_id , temp_x , start = start , count = count ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , temp_x_id ) # endif end subroutine write_radial_moments_nc subroutine write_kspectra_nc ( nout , phi2_vs_kxky ) use kt_grids , only : nakx , naky # ifdef NETCDF use netcdf , only : nf90_put_var , nf90_sync # endif implicit none integer , intent ( in ) :: nout real , dimension (:, :), intent ( in ) :: phi2_vs_kxky # ifdef NETCDF integer :: status integer , dimension ( 3 ) :: start , count start = 1 start ( 3 ) = nout count ( 1 ) = naky count ( 2 ) = nakx count ( 3 ) = 1 status = nf90_put_var ( ncid , phi2_vs_kxky_id , phi2_vs_kxky , start = start , count = count ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , phi2_vs_kxky_id ) !   Buffers to disk status = NF90_SYNC ( ncid ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , phi2_vs_kxky_id ) # endif end subroutine write_kspectra_nc ! ! ! subroutine write_fluxes_kxkyz_nc ( nout , pflx_kxkyz , vflx_kxkyz , qflx_kxkyz ) use kt_grids , only : nakx , naky use zgrid , only : nztot , ntubes use species , only : nspec # ifdef NETCDF use netcdf , only : nf90_put_var , nf90_sync # endif implicit none integer , intent ( in ) :: nout real , dimension (:, :, :, :, :), intent ( in ) :: pflx_kxkyz , vflx_kxkyz , qflx_kxkyz # ifdef NETCDF integer :: status integer , dimension ( 6 ) :: start , count start = 1 start ( 6 ) = nout count ( 1 ) = naky count ( 2 ) = nakx count ( 3 ) = nztot count ( 4 ) = ntubes count ( 5 ) = nspec count ( 6 ) = 1 ! status = nf90_put_var ( ncid , pflx_kxkyz_id , pflx_kxkyz , start = start , count = count ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , pflx_kxkyz_id ) ! status = nf90_put_var ( ncid , vflx_kxkyz_id , vflx_kxkyz , start = start , count = count ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , vflx_kxkyz_id ) ! status = nf90_put_var ( ncid , qflx_kxkyz_id , qflx_kxkyz , start = start , count = count ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , qflx_kxkyz_id ) ! !   Buffers to disk ! status = NF90_SYNC ( ncid ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , pflx_kxkyz_id ) ! status = NF90_SYNC ( ncid ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , vflx_kxkyz_id ) ! status = NF90_SYNC ( ncid ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , qflx_kxkyz_id ) # endif end subroutine write_fluxes_kxkyz_nc ! subroutine write_moments_nc ( nout , density , upar , temperature , spitzer2 ) use convert , only : c2r use zgrid , only : nztot , ntubes use kt_grids , only : nakx , naky use species , only : nspec # ifdef NETCDF use netcdf , only : nf90_put_var , nf90_sync # endif implicit none integer , intent ( in ) :: nout complex , dimension (:, :, :, :, :), intent ( in ) :: density , upar , temperature , spitzer2 # ifdef NETCDF integer :: status integer , dimension ( 7 ) :: start , count real , dimension (:, :, :, :, :, :), allocatable :: mom_ri start = 1 start ( 7 ) = nout count ( 1 ) = 2 count ( 2 ) = naky count ( 3 ) = nakx count ( 4 ) = nztot count ( 5 ) = ntubes count ( 6 ) = nspec count ( 7 ) = 1 allocate ( mom_ri ( 2 , naky , nakx , nztot , ntubes , nspec )) call c2r ( density , mom_ri ) status = nf90_put_var ( ncid , density_id , mom_ri , start = start , count = count ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , density_id ) !   Buffers to disk status = NF90_SYNC ( ncid ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , density_id ) call c2r ( upar , mom_ri ) status = nf90_put_var ( ncid , upar_id , mom_ri , start = start , count = count ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , upar_id ) !   Buffers to disk status = NF90_SYNC ( ncid ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , upar_id ) call c2r ( temperature , mom_ri ) status = nf90_put_var ( ncid , temperature_id , mom_ri , start = start , count = count ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , temperature_id ) !   Buffers to disk status = NF90_SYNC ( ncid ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , temperature_id ) ! AVB: added: (move this to a separate diagnostic in the future) call c2r ( spitzer2 , mom_ri ) status = nf90_put_var ( ncid , spitzer2_id , mom_ri , start = start , count = count ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , spitzer2_id ) !   Buffers to disk status = NF90_SYNC ( ncid ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , spitzer2_id ) deallocate ( mom_ri ) # endif end subroutine write_moments_nc subroutine write_gvmus_nc ( nout , g ) use vpamu_grids , only : nvpa , nmu use species , only : nspec # ifdef NETCDF use netcdf , only : nf90_put_var , nf90_sync # endif implicit none integer , intent ( in ) :: nout real , dimension (:, :, :), intent ( in ) :: g # ifdef NETCDF integer :: status integer , dimension ( 4 ) :: start , count start ( 1 ) = 1 start ( 2 : 3 ) = 1 start ( 4 ) = nout count ( 1 ) = nvpa count ( 2 ) = nmu count ( 3 ) = nspec count ( 4 ) = 1 status = nf90_put_var ( ncid , gvmus_id , g , start = start , count = count ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , gvmus_id ) !   Buffers to disk status = NF90_SYNC ( ncid ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , gvmus_id ) # endif end subroutine write_gvmus_nc subroutine write_gzvs_nc ( nout , g ) use zgrid , only : nzgrid , ntubes use vpamu_grids , only : nvpa use species , only : nspec # ifdef NETCDF use netcdf , only : nf90_put_var , nf90_sync # endif implicit none integer , intent ( in ) :: nout real , dimension (:, :, :, :), intent ( in ) :: g # ifdef NETCDF integer :: status integer , dimension ( 5 ) :: start , count start = 1 start ( 5 ) = nout count ( 1 ) = ntubes count ( 2 ) = 2 * nzgrid + 1 count ( 3 ) = nvpa count ( 4 ) = nspec count ( 5 ) = 1 status = nf90_put_var ( ncid , gzvs_id , g , start = start , count = count ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , gzvs_id ) !   Buffers to disk status = NF90_SYNC ( ncid ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , gzvs_id ) # endif end subroutine write_gzvs_nc subroutine nc_grids use zgrid , only : nzgrid , zed , ntubes use stella_geometry , only : geo_surf , dxdXcoord , q_as_x use kt_grids , only : naky , nakx , x_d , rho_d use kt_grids , only : theta0 , akx , aky use species , only : nspec use vpamu_grids , only : nvpa , nmu , vpa , mu use physics_flags , only : radial_variation use physics_parameters , only : rhostar !    use nonlinear_terms, only: nonlin # ifdef NETCDF use netcdf , only : nf90_put_var use constants , only : pi integer :: status , ix real :: nmesh real , dimension (:, :), allocatable :: rg ! Store the size of the grid dimensions (as defined in def_dims), in the NetCDF file status = nf90_put_var ( ncid , nttot_id , 2 * nzgrid + 1 ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , nttot_id ) status = nf90_put_var ( ncid , naky_id , naky ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , ntubes_id ) status = nf90_put_var ( ncid , ntubes_id , ntubes ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , naky_id ) status = nf90_put_var ( ncid , nakx_id , nakx ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , nakx_id ) status = nf90_put_var ( ncid , nspec_id , nspec ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , nspec_id ) status = nf90_put_var ( ncid , nmu_id , nmu ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , nmu_id ) status = nf90_put_var ( ncid , nvtot_id , nvpa ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , nvtot_id ) status = nf90_put_var ( ncid , akx_id , akx ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , akx_id ) status = nf90_put_var ( ncid , aky_id , aky ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , aky_id ) status = nf90_put_var ( ncid , zed_id , zed ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , zed_id ) status = nf90_put_var ( ncid , theta0_id , theta0 ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , theta0_id ) status = nf90_put_var ( ncid , mu_id , mu ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , mu_id ) status = nf90_put_var ( ncid , vpa_id , vpa ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , vpa_id ) if ( radial_variation ) then allocate ( rg ( 3 , nakx )) if ( q_as_x ) then do ix = 1 , nakx rg ( 1 , ix ) = x_d ( ix ) rg ( 2 , ix ) = rhostar * x_d ( ix ) / dxdXcoord + geo_surf % qinp rg ( 3 , ix ) = rho_d ( ix ) + geo_surf % rhoc end do else do ix = 1 , nakx rg ( 1 , ix ) = x_d ( ix ) rg ( 2 , ix ) = rhostar * x_d ( ix ) / dxdXcoord rg ( 3 , ix ) = rho_d ( ix ) + geo_surf % rhoc end do end if status = nf90_put_var ( ncid , rad_grid_id , rg ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , rad_grid_id ) deallocate ( rg ) end if !    if (nonlin) then !       nmesh = (2*nzgrid+1)*(2*nvgrid+1)*nmu*nx*ny*nspec !    else nmesh = ( 2 * nzgrid + 1 ) * ntubes * nvpa * nmu * nakx * naky * nspec !    end if status = nf90_put_var ( ncid , nmesh_id , nmesh ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , nmesh_id ) # endif end subroutine nc_grids subroutine nc_species use species , only : spec , nspec # ifdef NETCDF use netcdf , only : nf90_put_var integer :: status integer :: is ! FLAG - ignoring cross-species collisions for now real , dimension ( nspec ) :: vnew do is = 1 , nspec vnew ( is ) = spec ( is )% vnew ( is ) end do status = nf90_put_var ( ncid , charge_id , spec % z ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , charge_id ) status = nf90_put_var ( ncid , mass_id , spec % mass ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , mass_id ) status = nf90_put_var ( ncid , dens_id , spec % dens ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , dens_id ) status = nf90_put_var ( ncid , temp_id , spec % temp ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , temp_id ) status = nf90_put_var ( ncid , tprim_id , spec % tprim ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , tprim_id ) status = nf90_put_var ( ncid , fprim_id , spec % fprim ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , fprim_id ) status = nf90_put_var ( ncid , vnew_id , vnew ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , vnew_id ) status = nf90_put_var ( ncid , spec_type_id , spec % type ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , spec_type_id ) # endif end subroutine nc_species subroutine nc_geo use stella_geometry , only : bmag , gradpar , gbdrift , gbdrift0 , & cvdrift , cvdrift0 , gds2 , gds21 , gds22 , grho , jacob , & drhodpsi , djacdrho , b_dot_grad_z use stella_geometry , only : geo_surf use zgrid , only : nzgrid use physics_parameters , only : beta use dist_fn_arrays , only : kperp2 use kt_grids , only : naky , nakx , nalpha , jtwist # ifdef NETCDF use netcdf , only : nf90_put_var implicit none integer :: status integer , dimension ( 2 ) :: start , count integer , dimension ( 4 ) :: start2 , count2 start = 1 count ( 1 ) = nalpha count ( 2 ) = 2 * nzgrid + 1 start2 = 1 count2 ( 1 ) = naky count2 ( 2 ) = nakx count2 ( 3 ) = nalpha count2 ( 4 ) = 2 * nzgrid + 1 status = nf90_put_var ( ncid , bmag_id , bmag , start = start , count = count ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , bmag_id ) status = nf90_put_var ( ncid , b_dot_grad_z_id , b_dot_grad_z , start = start , count = count ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , b_dot_grad_z_id ) status = nf90_put_var ( ncid , gradpar_id , gradpar ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , gradpar_id ) status = nf90_put_var ( ncid , gbdrift_id , gbdrift , start = start , count = count ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , gbdrift_id ) status = nf90_put_var ( ncid , gbdrift0_id , gbdrift0 , start = start , count = count ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , gbdrift0_id ) status = nf90_put_var ( ncid , cvdrift_id , cvdrift , start = start , count = count ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , cvdrift_id ) status = nf90_put_var ( ncid , cvdrift0_id , cvdrift0 , start = start , count = count ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , cvdrift0_id ) status = nf90_put_var ( ncid , kperp2_id , kperp2 , start = start2 , count = count2 ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , kperp2_id ) status = nf90_put_var ( ncid , gds2_id , gds2 , start = start , count = count ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , gds2_id ) status = nf90_put_var ( ncid , gds21_id , gds21 , start = start , count = count ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , gds21_id ) status = nf90_put_var ( ncid , gds22_id , gds22 , start = start , count = count ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , gds22_id ) status = nf90_put_var ( ncid , grho_id , grho , start = start , count = count ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , grho_id ) status = nf90_put_var ( ncid , jacob_id , jacob , start = start , count = count ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , jacob_id ) status = nf90_put_var ( ncid , djacdrho_id , djacdrho , start = start , count = count ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , djacdrho_id ) status = nf90_put_var ( ncid , beta_id , beta ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , beta_id ) status = nf90_put_var ( ncid , q_id , geo_surf % qinp ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , q_id ) status = nf90_put_var ( ncid , shat_id , geo_surf % shat ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , shat_id ) status = nf90_put_var ( ncid , d2qdr2_id , geo_surf % d2qdr2 ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , d2qdr2_id ) status = nf90_put_var ( ncid , drhodpsi_id , drhodpsi ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , drhodpsi_id ) status = nf90_put_var ( ncid , d2psidr2_id , geo_surf % d2psidr2 ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , d2psidr2_id ) status = nf90_put_var ( ncid , jtwist_id , jtwist ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , jtwist_id ) # endif end subroutine nc_geo !> Get the index of the time dimension in the netCDF file that corresponds to !> a time no larger than `tstart` subroutine get_nout ( tstart , nout ) use netcdf , only : nf90_inquire_dimension , nf90_get_var implicit none !> Simulation time to find real , intent ( in ) :: tstart !> Index of time dimension integer , intent ( out ) :: nout real , dimension (:), allocatable :: times integer :: i , length , status nout = 1 status = nf90_inquire_dimension ( ncid , time_dim , len = length ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , dimid = time_dim ) if ( length > 0 ) then allocate ( times ( length )) status = nf90_get_var ( ncid , time_id , times ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , dimid = time_dim ) i = length do while ( times ( i ) > tstart . and . i > 0 ) i = i - 1 end do nout = i + 1 deallocate ( times ) end if end subroutine get_nout subroutine sync_nc # ifdef NETCDF use netcdf , only : nf90_sync implicit none integer :: status status = nf90_sync ( ncid ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid ) # endif end subroutine sync_nc end module stella_io","tags":"","loc":"sourcefile/stella_io.fpp.html"},{"title":"physics_flags.f90 â€“ stella","text":"Contents Modules physics_flags Source Code physics_flags.f90 Source Code module physics_flags implicit none public :: init_physics_flags public :: finish_physics_flags public :: full_flux_surface public :: radial_variation public :: include_parallel_nonlinearity public :: include_parallel_streaming public :: include_mirror public :: prp_shear_enabled public :: hammett_flow_shear public :: include_pressure_variation public :: include_geometric_variation public :: nonlinear public :: adiabatic_option_switch public :: adiabatic_option_fieldlineavg public :: const_alpha_geo private logical :: full_flux_surface logical :: radial_variation logical :: include_parallel_nonlinearity logical :: include_parallel_streaming logical :: include_pressure_variation logical :: include_geometric_variation logical :: include_mirror logical :: nonlinear logical :: prp_shear_enabled logical :: hammett_flow_shear logical :: const_alpha_geo integer :: adiabatic_option_switch integer , parameter :: adiabatic_option_default = 1 , & adiabatic_option_zero = 2 , & adiabatic_option_fieldlineavg = 3 logical :: initialized = . false . contains subroutine init_physics_flags implicit none if ( initialized ) return initialized = . true . call read_parameters end subroutine init_physics_flags subroutine read_parameters use file_utils , only : input_unit_exist , error_unit use mp , only : proc0 , broadcast use text_options , only : text_option , get_option_value implicit none integer :: in_file , ierr logical :: rpexist type ( text_option ), dimension ( 6 ), parameter :: adiabaticopts = & ( / text_option ( 'default' , adiabatic_option_default ), & text_option ( 'no-field-line-average-term' , adiabatic_option_default ), & text_option ( 'field-line-average-term' , adiabatic_option_fieldlineavg ), & text_option ( 'iphi00=0' , adiabatic_option_default ), & text_option ( 'iphi00=1' , adiabatic_option_default ), & text_option ( 'iphi00=2' , adiabatic_option_fieldlineavg ) / ) character ( 30 ) :: adiabatic_option namelist / physics_flags / full_flux_surface , radial_variation , & include_parallel_nonlinearity , include_parallel_streaming , & include_mirror , nonlinear , & include_pressure_variation , include_geometric_variation , & adiabatic_option , const_alpha_geo if ( proc0 ) then full_flux_surface = . false . radial_variation = . false . include_pressure_variation = . true . include_geometric_variation = . true . include_parallel_nonlinearity = . false . include_parallel_streaming = . true . include_mirror = . true . nonlinear = . false . adiabatic_option = 'default' const_alpha_geo = . false . in_file = input_unit_exist ( \"physics_flags\" , rpexist ) if ( rpexist ) read ( unit = in_file , nml = physics_flags ) ierr = error_unit () call get_option_value & ( adiabatic_option , adiabaticopts , adiabatic_option_switch , & ierr , \"adiabatic_option in physics_flags\" ) end if prp_shear_enabled = . false . hammett_flow_shear = . true . call broadcast ( full_flux_surface ) call broadcast ( radial_variation ) call broadcast ( include_pressure_variation ) call broadcast ( include_geometric_variation ) call broadcast ( include_parallel_nonlinearity ) call broadcast ( include_parallel_streaming ) call broadcast ( include_mirror ) call broadcast ( nonlinear ) call broadcast ( adiabatic_option_switch ) call broadcast ( const_alpha_geo ) end subroutine read_parameters subroutine finish_physics_flags implicit none initialized = . false . end subroutine finish_physics_flags end module physics_flags","tags":"","loc":"sourcefile/physics_flags.f90.html"},{"title":"extended_zgrid.f90 â€“ stella","text":"Contents Modules extended_zgrid Source Code extended_zgrid.f90 Source Code module extended_zgrid implicit none public :: nsegments public :: neigen public :: ikxmod public :: iz_low , iz_mid , iz_up public :: periodic public :: nzed_segment public :: fill_zed_ghost_zones public :: init_extended_zgrid , finish_extended_zgrid public :: map_to_extended_zgrid public :: map_from_extended_zgrid !> these arrays needed to keep track of connections between different !> 2pi segments integer :: nzed_segment integer , dimension (:), allocatable :: neigen integer , dimension (:), allocatable :: iz_low , iz_mid , iz_up integer , dimension (:, :), allocatable :: nsegments integer , dimension (:, :, :), allocatable :: ikxmod !> arrays indicate which flux tube index to connect to !> on the left and on the right !> as a function of current flux tube index !> pre-compute to avoid conditionals in loops integer , dimension (:), allocatable :: it_left , it_right complex , dimension (:), allocatable :: phase_shift logical , dimension (:), allocatable :: periodic logical :: extended_zgrid_initialized = . false . contains subroutine init_extended_zgrid use zgrid , only : boundary_option_switch use zgrid , only : boundary_option_self_periodic use zgrid , only : boundary_option_linked use zgrid , only : twist_shift_option_switch use zgrid , only : twist_shift_option_periodic use zgrid , only : twist_shift_option_std use zgrid , only : twist_shift_option_stellarator use zgrid , only : nperiod , nzgrid , nzed , ntubes use kt_grids , only : nakx , naky use kt_grids , only : jtwist , ikx_twist_shift , phase_shift_fac use kt_grids , only : aky , ikx_max use constants , only : zi implicit none integer :: iseg , iky , ie , ikx , it integer :: nseg_max , neigen_max integer , dimension (:), allocatable :: ikx_shift_end integer , dimension (:, :), allocatable :: ikx_shift if ( extended_zgrid_initialized ) return extended_zgrid_initialized = . true . if (. not . allocated ( neigen )) allocate ( neigen ( naky )) if (. not . allocated ( periodic )) allocate ( periodic ( naky )); periodic = . false . if (. not . allocated ( phase_shift )) allocate ( phase_shift ( naky )); phase_shift = 1. if ( boundary_option_switch == boundary_option_self_periodic ) then periodic = . true . else where ( abs ( aky ) < epsilon ( 0.0 )) periodic = . true . end if if ( twist_shift_option_switch == twist_shift_option_periodic ) then periodic = . true . end if select case ( boundary_option_switch ) case ( boundary_option_linked ) !> all periodic modes (e.g., the zonal mode) have no connections do iky = 1 , naky if ( periodic ( iky )) then neigen ( iky ) = nakx else neigen ( iky ) = min (( iky - 1 ) * jtwist , nakx ) end if end do neigen_max = maxval ( neigen ) if (. not . allocated ( ikx_shift_end )) then allocate ( ikx_shift_end ( neigen_max )); ikx_shift_end = 0 allocate ( ikx_shift ( nakx , naky )); ikx_shift = 0 end if !> phi(kx-kx_shift,-nzgrid) = phi(kx,nzgrid) from twist-and-shift BC !> for positive (negative) magnetic shear, kx_shift is positive (negative), !> so start at most positive (negative) kx and !> progress to smaller (larger) kx values as connections occur !> figure out how much to shift ikx by to get to the end of the kx chain !> for positive (negative) magnetic shear, this is the left-most (right-most) theta-theta0 !> in each set of connected 2pi segments !> note that theta0 goes from 0 to theta0_max and then from theta0_min back !> to -dtheta0 do ikx = 1 , neigen_max !> first ikx_max=nakx/2+1 theta0s are 0 and all positive theta0 values !> remainder are negative theta0s !> theta_0 = kx / ky / shat !> if ky > 0, then most positive theta_0 corresponds to most positive kx !> first consider case where shift in kx is negative (corresponds to positive magnetic shear) if ( ikx_twist_shift < 0 ) then if ( ikx <= ikx_max ) then ikx_shift_end ( ikx ) = ikx_max - 2 * ikx + 1 else ikx_shift_end ( ikx ) = 3 * ikx_max - 2 * ikx end if !> then consider case where shift in kx is positive else if ( ikx_twist_shift > 0 ) then if ( ikx < ikx_max ) then if ( ikx + ikx_max <= nakx ) then ikx_shift_end ( ikx ) = ikx_max else ikx_shift_end ( ikx ) = ikx - nakx end if else ikx_shift_end ( ikx ) = 1 - ikx_max end if end if !> note that zero shift case is taken care of by initialization of ikx_shift_end end do do iky = 1 , naky !> ikx_shift is how much to shift each ikx by to connect !> to the next theta0 (from most positive to most negative for positive magnetic shear !> and vice versa for negative magnetic shear) !> first consider shift in index for case where shift is negative !> (corresponds to positive magnetic shear) if ( ikx_twist_shift < 0 ) then !> if ky > 0, then going to more negative theta0 !> corresponds to going to more negative kx do ikx = 1 , ikx_max !> if theta0 is sufficiently positive, shifting to more !> negative theta0 corresponds to decreasing ikx if ( ikx - neigen ( iky ) > 0 ) then ikx_shift ( ikx , iky ) = - neigen ( iky ) !> if a positive theta0 connects to a negative theta0 !> must do more complicated mapping of ikx else if ( ikx - neigen ( iky ) + nakx >= ikx_max + 1 ) then ikx_shift ( ikx , iky ) = nakx - neigen ( iky ) end if end do !> if theta0 is negative, then shifting to more negative !> theta0 corresponds to decreasing ikx do ikx = ikx_max + 1 , nakx !> if theta0 is sufficiently negative, it has no !> more negative theta0 with which it can connect if ( ikx - neigen ( iky ) > ikx_max ) then ikx_shift ( ikx , iky ) = - neigen ( iky ) end if !> theta0 is positive end do else if ( ikx_twist_shift > 0 ) then !> if ky > 0, then going to more positive theta0 !> corresponds to going to more positive kx do ikx = 1 , ikx_max !> if shift in kx, kx_shift, is less than kx-kx_max, !> then shift by the appropriate amount if ( ikx + neigen ( iky ) <= ikx_max ) then ikx_shift ( ikx , iky ) = neigen ( iky ) end if !> otherwise, no kx on grid to connect with end do do ikx = ikx_max + 1 , nakx !> if kx+kx_shift < 0, then simple shift by neigen if ( ikx + neigen ( iky ) <= nakx ) then ikx_shift ( ikx , iky ) = neigen ( iky ) !> if 0 < kx+kx_shift <= kx_max, then more complicated shift !> to positive set of kx values else if ( ikx - ikx_max + neigen ( iky ) <= nakx ) then ikx_shift ( ikx , iky ) = neigen ( iky ) - nakx end if !> otherwise, no kx on grid with which to connect end do end if end do if (. not . allocated ( nsegments )) allocate ( nsegments ( neigen_max , naky )) do iky = 1 , naky if ( neigen ( iky ) == 0 ) then nsegments (:, iky ) = 1 else nsegments (:, iky ) = ( nakx - 1 ) / neigen ( iky ) do ie = 1 , mod ( nakx - 1 , neigen ( iky )) + 1 nsegments ( ie , iky ) = nsegments ( ie , iky ) + 1 end do end if end do nseg_max = maxval ( nsegments ) if (. not . allocated ( iz_low )) then allocate ( iz_low ( nseg_max )); iz_low = - nzgrid allocate ( iz_mid ( nseg_max )); iz_mid = 0 allocate ( iz_up ( nseg_max )); iz_up = nzgrid end if phase_shift = exp ( zi * aky * phase_shift_fac ) case default neigen = nakx ; neigen_max = nakx if (. not . allocated ( ikx_shift_end )) then allocate ( ikx_shift_end ( neigen_max )) allocate ( ikx_shift ( nakx , naky )) end if ikx_shift = 0 ; ikx_shift_end = 0 if (. not . allocated ( nsegments )) then allocate ( nsegments ( neigen_max , naky )) end if !> this is the number of 2pi poloidal segments in the extended theta domain, !> which is needed in initializing the reponse matrix and doing the implicit sweep nsegments = 2 * ( nperiod - 1 ) + 1 nseg_max = maxval ( nsegments ) if (. not . allocated ( iz_low )) then allocate ( iz_low ( nseg_max )) allocate ( iz_mid ( nseg_max )) allocate ( iz_up ( nseg_max )) end if !> iz_low(j) is the ig index corresponding to the inboard midplane from below (theta=-pi) within the jth segment !> iz_mid(j) is the ig index corresponding to the outboard midplane (theta=0) within the jth segment do iseg = 1 , nseg_max iz_low ( iseg ) = - nzgrid + ( iseg - 1 ) * nzed iz_mid ( iseg ) = iz_low ( iseg ) + nzed / 2 iz_up ( iseg ) = iz_low ( iseg ) + nzed end do end select if (. not . allocated ( ikxmod )) then allocate ( ikxmod ( nseg_max , neigen_max , naky )) !> initialize ikxmod to nakx !> should not be necessary but just in case one tries to access !> a value beyond nsegments(ie,iky) ikxmod = nakx end if do iky = 1 , naky !> only do the following once for each independent set of theta0s !> the assumption here is that all kx are on processor and sequential do ie = 1 , neigen ( iky ) !> remap to start at theta0 = theta0_max (theta0_min) for negative (positive) kx shift !> for this set of connected theta0s iseg = 1 ikxmod ( iseg , ie , iky ) = ie + ikx_shift_end ( ie ) if ( nsegments ( ie , iky ) > 1 ) then do iseg = 2 , nsegments ( ie , iky ) ikxmod ( iseg , ie , iky ) = ikxmod ( iseg - 1 , ie , iky ) + ikx_shift ( ikxmod ( iseg - 1 , ie , iky ), iky ) end do end if end do end do if ( allocated ( ikx_shift_end )) deallocate ( ikx_shift_end ) if ( allocated ( ikx_shift )) deallocate ( ikx_shift ) if (. not . allocated ( it_left )) allocate ( it_left ( ntubes )) if (. not . allocated ( it_right )) allocate ( it_right ( ntubes )) it_right ( ntubes ) = 1 if ( ntubes > 1 ) then do it = 1 , ntubes - 1 it_right ( it ) = it + 1 end do end if it_left ( 1 ) = ntubes if ( ntubes > 1 ) then do it = 2 , ntubes it_left ( it ) = it - 1 end do end if !> this is the number of unique zed values in all segments but the first !> the first has one extra unique zed value (all others have one grid common !> with the previous segment due to periodicity) nzed_segment = iz_up ( 1 ) - iz_low ( 1 ) end subroutine init_extended_zgrid subroutine fill_zed_ghost_zones ( it , iseg , ie , iky , g , gleft , gright ) use zgrid , only : nzgrid implicit none integer , intent ( in ) :: it , iseg , ie , iky complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: g complex , dimension (:), intent ( out ) :: gleft , gright integer :: nseg ! stream_sign > 0 --> stream speed < 0 nseg = nsegments ( ie , iky ) if ( iseg == 1 ) then if ( periodic ( iky )) then gleft = phase_shift ( iky ) * g ( iky , ikxmod ( iseg , ie , iky ), iz_up ( nseg ) - 2 : iz_up ( nseg ) - 1 , it ) else gleft = 0.0 end if else gleft = phase_shift ( iky ) * g ( iky , ikxmod ( iseg - 1 , ie , iky ), iz_up ( iseg - 1 ) - 2 : iz_up ( iseg - 1 ) - 1 , it_left ( it )) end if if ( nseg > iseg ) then ! connect to segment with larger theta-theta0 (on right) gright = g ( iky , ikxmod ( iseg + 1 , ie , iky ), iz_low ( iseg + 1 ) + 1 : iz_low ( iseg + 1 ) + 2 , it_right ( it )) / phase_shift ( iky ) else ! apply periodic BC where necessary and zero BC otherwise if ( periodic ( iky )) then gright = g ( iky , ikxmod ( iseg , ie , iky ), iz_low ( 1 ) + 1 : iz_low ( 1 ) + 2 , it ) / phase_shift ( iky ) else gright = 0.0 end if end if end subroutine fill_zed_ghost_zones subroutine map_to_extended_zgrid ( it , ie , iky , g , gext , ulim ) use zgrid , only : nzgrid implicit none integer , intent ( in ) :: it , ie , iky complex , dimension (:, - nzgrid :, :), intent ( in ) :: g complex , dimension (:), intent ( out ) :: gext integer , intent ( out ) :: ulim integer :: iseg , ikx , itmod integer :: llim complex :: curr_shift ! avoid double-counting at boundaries between 2pi segments iseg = 1 curr_shift = 1. ikx = ikxmod ( iseg , ie , iky ) llim = 1 ; ulim = nzed_segment + 1 gext ( llim : ulim ) = g ( ikx , iz_low ( iseg ): iz_up ( iseg ), it ) * curr_shift if ( nsegments ( ie , iky ) > 1 ) then itmod = it do iseg = 2 , nsegments ( ie , iky ) curr_shift = curr_shift / phase_shift ( iky ) ikx = ikxmod ( iseg , ie , iky ) itmod = it_right ( itmod ) llim = ulim + 1 ulim = llim + nzed_segment - 1 gext ( llim : ulim ) = g ( ikx , iz_low ( iseg ) + 1 : iz_up ( iseg ), itmod ) * curr_shift end do end if end subroutine map_to_extended_zgrid subroutine map_from_extended_zgrid ( it , ie , iky , gext , g ) use zgrid , only : nzgrid implicit none integer , intent ( in ) :: it , ie , iky complex , dimension (:), intent ( in ) :: gext complex , dimension (:, - nzgrid :, :), intent ( in out ) :: g integer :: iseg , ikx , itmod integer :: llim , ulim complex :: curr_shift iseg = 1 curr_shift = 1. ikx = ikxmod ( iseg , ie , iky ) llim = 1 ; ulim = nzed_segment + 1 g ( ikx , iz_low ( iseg ): iz_up ( iseg ), it ) = gext ( llim : ulim ) if ( nsegments ( ie , iky ) > 1 ) then itmod = it do iseg = 2 , nsegments ( ie , iky ) curr_shift = curr_shift * phase_shift ( iky ) llim = ulim + 1 ulim = llim + nzed_segment - 1 ikx = ikxmod ( iseg , ie , iky ) itmod = it_right ( itmod ) g ( ikx , iz_low ( iseg ), itmod ) = gext ( llim - 1 ) * curr_shift g ( ikx , iz_low ( iseg ) + 1 : iz_up ( iseg ), itmod ) = gext ( llim : ulim ) * curr_shift end do end if end subroutine map_from_extended_zgrid subroutine finish_extended_zgrid implicit none if ( allocated ( neigen )) deallocate ( neigen ) if ( allocated ( periodic )) deallocate ( periodic ) if ( allocated ( nsegments )) deallocate ( nsegments ) if ( allocated ( iz_low )) deallocate ( iz_low , iz_mid , iz_up ) if ( allocated ( ikxmod )) deallocate ( ikxmod ) if ( allocated ( it_right )) deallocate ( it_right ) if ( allocated ( it_left )) deallocate ( it_left ) if ( allocated ( phase_shift )) deallocate ( phase_shift ) extended_zgrid_initialized = . false . end subroutine finish_extended_zgrid end module extended_zgrid","tags":"","loc":"sourcefile/extended_zgrid.f90.html"},{"title":"time_advance.f90 â€“ stella","text":"Contents Modules time_advance Source Code time_advance.f90 Source Code module time_advance public :: init_time_advance , finish_time_advance public :: advance_stella public :: time_gke , time_parallel_nl public :: checksum private interface get_dgdy module procedure get_dgdy_2d module procedure get_dgdy_3d module procedure get_dgdy_4d end interface interface get_dgdx module procedure get_dgdx_2d module procedure get_dgdx_3d module procedure get_dgdx_4d end interface interface checksum module procedure checksum_field module procedure checksum_dist end interface logical :: time_advance_initialized = . false . logical :: wdriftinit = . false . logical :: wstarinit = . false . logical :: parnlinit = . false . logical :: readinit = . false . logical :: radialinit = . false . logical :: driftimpinit = . false . ! if .true., dist fn is represented on alpha grid ! if .false., dist fn is given on k-alpha grid ! default is .false.; will only ever be set to ! .true. during full_flux_surface simulations !  logical :: alpha_space = .false. integer :: explicit_option_switch integer , parameter :: explicit_option_rk3 = 1 , & explicit_option_rk2 = 2 , & explicit_option_rk4 = 3 real :: xdriftknob , ydriftknob , wstarknob logical :: flip_flop complex , dimension (:, :, :), allocatable :: gamtot_drifts !, apar_denom_drifts complex , dimension (:, :), allocatable :: gamtot3_drifts ! factor multiplying parallel nonlinearity real , dimension (:, :), allocatable :: par_nl_fac , d_par_nl_fac_dr ! factor multiplying higher order linear term in parallel acceleration real , dimension (:, :), allocatable :: par_nl_curv , d_par_nl_curv_dr real , dimension (:), allocatable :: par_nl_driftx , par_nl_drifty real , dimension (:), allocatable :: d_par_nl_driftx_dr , d_par_nl_drifty_dr ! needed for timing various pieces of gke solve real , dimension ( 2 , 10 ) :: time_gke = 0. real , dimension ( 2 , 2 ) :: time_parallel_nl = 0. logical :: debug = . false . contains subroutine init_time_advance use mp , only : proc0 use run_parameters , only : drifts_implicit use physics_flags , only : radial_variation use physics_flags , only : include_parallel_nonlinearity use neoclassical_terms , only : init_neoclassical_terms use dissipation , only : init_collisions , include_collisions use parallel_streaming , only : init_parallel_streaming use mirror_terms , only : init_mirror use flow_shear , only : init_flow_shear use sources , only : init_quasineutrality_source , init_source_timeaverage implicit none if ( time_advance_initialized ) return time_advance_initialized = . true . debug = debug . and . proc0 !> read time_advance_knobs namelist from the input file; !> sets the explicit time advance option, as well as allows for scaling of !> the x and y components of the magnetic drifts and of the drive term if ( debug ) write ( 6 , * ) 'time_advance::init_time_advance::read_parameters' call read_parameters !> allocate distribution function sized arrays needed, e.g., for Runge-Kutta time advance if ( debug ) write ( 6 , * ) 'time_advance::init_time_advance::allocate_arrays' call allocate_arrays !> set up neoclassical corrections to the equilibrium Maxwellian; !> only calculated/needed when simulating higher order terms in rhostar for intrinsic rotation if ( debug ) write ( 6 , * ) 'time_advance::init_time_advance::init_neoclassical_terms' call init_neoclassical_terms !> calculate the term multiplying dg/dvpa in the mirror term !> and set up either the semi-Lagrange machinery or the tridiagonal matrix to be inverted !> if solving implicitly if ( debug ) write ( 6 , * ) 'time_advance::init_time_advance::init_mirror' call init_mirror !> calculate the term multiplying dg/dz in the parallel streaming term !> and set up the tridiagonal matrix to be inverted if solving implicitly if ( debug ) write ( 6 , * ) 'time_advance::init_time_advance::init_parstream' call init_parallel_streaming !> allocate and calculate the factors multiplying dg/dx, dg/dy, dphi/dx and dphi/dy !> in the magnetic drift terms if ( debug ) write ( 6 , * ) 'time_advance::init_time_advance::init_wdrift' call init_wdrift !> allocate and calculate the factor multiplying dphi/dy in the gradient drive term if ( debug ) write ( 6 , * ) 'time_advance::init_time_advance::init_wstar' call init_wstar if ( debug ) write ( 6 , * ) 'time_advance::init_time_advance::init_flow_shear' call init_flow_shear if ( debug ) write ( 6 , * ) 'time_advance::init_time_advance::init_parallel_nonlinearity' if ( include_parallel_nonlinearity ) call init_parallel_nonlinearity if ( debug ) write ( 6 , * ) 'time_advance::init_time_advance::init_radial_variation' if ( radial_variation ) call init_radial_variation if ( debug ) write ( 6 , * ) 'time_advance::init_time_advance::init_drifts_implicit' if ( drifts_implicit ) call init_drifts_implicit if ( include_collisions ) then if ( debug ) write ( 6 , * ) 'time_advance::init_time_advance::init_collisions' call init_collisions end if if ( debug ) write ( 6 , * ) 'time_advance::init_time_advance::init_cfl' call init_cfl if ( debug ) write ( 6 , * ) 'time_advance::init_time_advance::init_source_timeaverage' call init_source_timeaverage if ( debug ) write ( 6 , * ) 'time_advance::init_time_advance::init_quasineutrality_source' call init_quasineutrality_source !call write_drifts end subroutine init_time_advance subroutine read_parameters use file_utils , only : error_unit , input_unit_exist use text_options , only : text_option , get_option_value use mp , only : proc0 , broadcast use run_parameters , only : fully_explicit implicit none logical :: taexist type ( text_option ), dimension ( 4 ), parameter :: explicitopts = & ( / text_option ( 'default' , explicit_option_rk3 ), & text_option ( 'rk3' , explicit_option_rk3 ), & text_option ( 'rk2' , explicit_option_rk2 ), & text_option ( 'rk4' , explicit_option_rk4 ) / ) character ( 10 ) :: explicit_option namelist / time_advance_knobs / xdriftknob , ydriftknob , wstarknob , explicit_option , flip_flop integer :: ierr , in_file if ( readinit ) return readinit = . true . if ( proc0 ) then explicit_option = 'default' xdriftknob = 1.0 ydriftknob = 1.0 wstarknob = 1.0 flip_flop = . false . in_file = input_unit_exist ( \"time_advance_knobs\" , taexist ) if ( taexist ) read ( unit = in_file , nml = time_advance_knobs ) ierr = error_unit () call get_option_value & ( explicit_option , explicitopts , explicit_option_switch , & ierr , \"explicit_option in time_advance_knobs\" ) end if call broadcast ( explicit_option_switch ) call broadcast ( xdriftknob ) call broadcast ( ydriftknob ) call broadcast ( wstarknob ) call broadcast ( flip_flop ) if ( fully_explicit ) flip_flop = . false . end subroutine read_parameters ! subroutine write_drifts !   use dist_fn_arrays, only: wdriftx_g, wdrifty_g !   use dist_fn_arrays, only: wdriftx_phi, wdrifty_phi !   use dist_fn_arrays, only: wstar, wstarp !   use dist_fn_arrays, only: wdriftpx_g, wdriftpy_g !   use dist_fn_arrays, only: wdriftpx_phi, wdriftpy_phi !   use zgrid, only: nzgrid !   use stella_layouts, only: vmu_lo !   use file_utils, only: run_name ! !   implicit none !   integer ia, iz, ivmu !   character(len=512) :: filename !   ia=1 !   filename=trim(run_name)//\".drifts\" !   open(3345,file=trim(filename),status='unknown') !   do ivmu = vmu_lo%llim_proc, vmu_lo%ulim_proc !     do iz= -nzgrid, nzgrid !       write(3345,'(10e25.8)') wstar(ia,iz,ivmu),wstarp(ia,iz,ivmu), & !                              wdriftx_g(ia,iz,ivmu), wdriftpx_g(ia,iz,ivmu), & !                              wdrifty_g(ia,iz,ivmu), wdriftpy_g(ia,iz,ivmu), & !                              wdriftx_phi(ia,iz,ivmu), wdriftpx_phi(ia,iz,ivmu), & !                              wdrifty_phi(ia,iz,ivmu), wdriftpy_phi(ia,iz,ivmu) !     enddo !   enddo !   close (3345) ! end subroutine write_drifts subroutine init_wdrift use mp , only : mp_abort use physics_flags , only : full_flux_surface use dist_fn_arrays , only : wdriftx_g , wdrifty_g use dist_fn_arrays , only : wdriftx_phi , wdrifty_phi use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx , imu_idx , is_idx use stella_time , only : code_dt use species , only : spec use zgrid , only : nzgrid use kt_grids , only : nalpha use stella_geometry , only : cvdrift , gbdrift use stella_geometry , only : cvdrift0 , gbdrift0 use stella_geometry , only : gds23 , gds24 use stella_geometry , only : geo_surf , q_as_x use stella_geometry , only : dxdXcoord , drhodpsi , dydalpha use vpamu_grids , only : vpa , vperp2 use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use neoclassical_terms , only : include_neoclassical_terms use neoclassical_terms , only : dphineo_dzed , dphineo_drho , dphineo_dalpha use neoclassical_terms , only : dfneo_dvpa , dfneo_dzed , dfneo_dalpha implicit none integer :: ivmu , iv , imu , is real :: fac real , dimension (:, :), allocatable :: wcvdrifty , wgbdrifty real , dimension (:, :), allocatable :: wcvdriftx , wgbdriftx if ( wdriftinit ) return wdriftinit = . true . !> allocate wdriftx_phi, the factor multiplying dphi/dx in the magnetic drift term if (. not . allocated ( wdriftx_phi )) then allocate ( wdriftx_phi ( nalpha , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) wdriftx_phi = 0.0 end if !> allocate wdrifty_phi, the factor multiplying dphi/dy in the magnetic drift term if (. not . allocated ( wdrifty_phi )) then allocate ( wdrifty_phi ( nalpha , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) wdrifty_phi = 0.0 end if !> allocate wdriftx_g, the factor multiplying dg/dx in the magnetic drift term if (. not . allocated ( wdriftx_g )) then allocate ( wdriftx_g ( nalpha , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) wdriftx_g = 0.0 end if !> allocate wdrifty_g, the factor multiplying dg/dy in the magnetic drift term if (. not . allocated ( wdrifty_g )) then allocate ( wdrifty_g ( nalpha , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) wdrifty_g = 0.0 end if allocate ( wcvdrifty ( nalpha , - nzgrid : nzgrid )) allocate ( wgbdrifty ( nalpha , - nzgrid : nzgrid )) allocate ( wcvdriftx ( nalpha , - nzgrid : nzgrid )) allocate ( wgbdriftx ( nalpha , - nzgrid : nzgrid )) ! FLAG -- need to deal with shat=0 case.  ideally move away from q as x-coordinate do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) fac = - ydriftknob * 0.5 * code_dt * spec ( is )% tz_psi0 !> this is the curvature drift piece of wdrifty with missing factor of vpa !> vpa factor is missing to avoid singularity when including !> non-Maxwellian corrections to equilibrium wcvdrifty = fac * cvdrift * vpa ( iv ) !> this is the grad-B drift piece of wdrifty wgbdrifty = fac * gbdrift * 0.5 * vperp2 (:, :, imu ) wdrifty_g (:, :, ivmu ) = wcvdrifty * vpa ( iv ) + wgbdrifty !> if including neoclassical correction to equilibrium Maxwellian, !> then add in v_E&#94;{nc} . grad y dg/dy coefficient here if ( include_neoclassical_terms ) then wdrifty_g (:, :, ivmu ) = wdrifty_g (:, :, ivmu ) + code_dt * 0.5 * ( gds23 * dphineo_dzed & + drhodpsi * dydalpha * dphineo_drho ) end if wdrifty_phi (:, :, ivmu ) = spec ( is )% zt * ( wgbdrifty + wcvdrifty * vpa ( iv )) !> if full_flux_surface, evolved distribution function is normalised by a Maxwellian !> otherwise, it is not; a Maxwellian weighting factor must thus be included if (. not . full_flux_surface ) then wdrifty_phi (:, :, ivmu ) = wdrifty_phi (:, :, ivmu ) * maxwell_vpa ( iv , is ) * maxwell_mu (:, :, imu , is ) * maxwell_fac ( is ) end if !> if including neoclassical corrections to equilibrium, !> add in -(Ze/m) * v_curv/vpa . grad y d<phi>/dy * dF&#94;{nc}/dvpa term !> and v_E . grad z dF&#94;{nc}/dz (here get the dphi/dy part of v_E) if ( include_neoclassical_terms ) then !> NB: the below neoclassical correction needs to be divided by an equilibrium Maxwellian !> if running in full flux surface mode if ( full_flux_surface ) then call mp_abort ( \"include_neoclassical_terms=T not currently supported for full_flux_surface=T.  aborting\" ) end if wdrifty_phi (:, :, ivmu ) = wdrifty_phi (:, :, ivmu ) & - 0.5 * spec ( is )% zt * dfneo_dvpa (:, :, ivmu ) * wcvdrifty & - code_dt * 0.5 * dfneo_dzed (:, :, ivmu ) * gds23 end if if ( q_as_x ) then fac = - xdriftknob * 0.5 * code_dt * spec ( is )% tz_psi0 else fac = - xdriftknob * 0.5 * code_dt * spec ( is )% tz_psi0 / geo_surf % shat end if !> this is the curvature drift piece of wdriftx with missing factor of vpa !> vpa factor is missing to avoid singularity when including !> non-Maxwellian corrections to equilibrium wcvdriftx = fac * cvdrift0 * vpa ( iv ) !> this is the grad-B drift piece of wdriftx wgbdriftx = fac * gbdrift0 * 0.5 * vperp2 (:, :, imu ) wdriftx_g (:, :, ivmu ) = wcvdriftx * vpa ( iv ) + wgbdriftx !> if including neoclassical correction to equilibrium Maxwellian, !> then add in v_E&#94;{nc} . grad x dg/dx coefficient here if ( include_neoclassical_terms ) then wdriftx_g (:, :, ivmu ) = wdriftx_g (:, :, ivmu ) + code_dt * 0.5 * ( gds24 * dphineo_dzed & - dxdXcoord * dphineo_dalpha ) end if wdriftx_phi (:, :, ivmu ) = spec ( is )% zt * ( wgbdriftx + wcvdriftx * vpa ( iv )) !> if full_flux_surface, evolved distribution function is normalised by a Maxwellian !> otherwise, it is not; a Maxwellian weighting factor must thus be included if (. not . full_flux_surface ) then wdriftx_phi (:, :, ivmu ) = wdriftx_phi (:, :, ivmu ) * maxwell_vpa ( iv , is ) * maxwell_mu (:, :, imu , is ) * maxwell_fac ( is ) end if !> if including neoclassical corrections to equilibrium, !> add in (Ze/m) * v_curv/vpa . grad x d<phi>/dx * dF&#94;{nc}/dvpa term !> and v_E . grad z dF&#94;{nc}/dz (here get the dphi/dx part of v_E) !> and v_E . grad alpha dF&#94;{nc}/dalpha (dphi/dx part of v_E) if ( include_neoclassical_terms ) then !> NB: the below neoclassical correction needs to be divided by an equilibrium Maxwellian !> if running in full flux surface mode if ( full_flux_surface ) then call mp_abort ( \"include_neoclassical_terms=T not currently supported for full_flux_surface=T.  aborting\" ) end if wdriftx_phi (:, :, ivmu ) = wdriftx_phi (:, :, ivmu ) & - 0.5 * spec ( is )% zt * dfneo_dvpa (:, :, ivmu ) * wcvdriftx & + code_dt * 0.5 * ( dfneo_dalpha (:, :, ivmu ) * dxdXcoord - dfneo_dzed (:, :, ivmu ) * gds24 ) end if end do deallocate ( wcvdriftx , wgbdriftx , wcvdrifty , wgbdrifty ) end subroutine init_wdrift subroutine init_wstar use mp , only : mp_abort use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx , imu_idx , is_idx use stella_time , only : code_dt use species , only : spec use zgrid , only : nzgrid use kt_grids , only : nalpha use stella_geometry , only : dydalpha , drhodpsi use vpamu_grids , only : vperp2 , vpa use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use dist_fn_arrays , only : wstar use neoclassical_terms , only : include_neoclassical_terms use neoclassical_terms , only : dfneo_drho use physics_flags , only : full_flux_surface implicit none integer :: is , imu , iv , ivmu real , dimension (:, :), allocatable :: energy if ( wstarinit ) return wstarinit = . true . if (. not . allocated ( wstar )) & allocate ( wstar ( nalpha , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )); wstar = 0.0 allocate ( energy ( nalpha , - nzgrid : nzgrid )) do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) iv = iv_idx ( vmu_lo , ivmu ) energy = ( vpa ( iv ) ** 2 + vperp2 (:, :, imu )) * ( spec ( is )% temp_psi0 / spec ( is )% temp ) if ( include_neoclassical_terms ) then if ( full_flux_surface ) then call mp_abort ( \"include_neoclassical_terms = T not yet supported for full_flux_surface = T. Aborting.\" ) else wstar (:, :, ivmu ) = dydalpha * drhodpsi * wstarknob * 0.5 * code_dt & * ( maxwell_vpa ( iv , is ) * maxwell_mu (:, :, imu , is ) * maxwell_fac ( is ) & * ( spec ( is )% fprim + spec ( is )% tprim * ( energy - 1.5 )) & - dfneo_drho (:, :, ivmu )) end if else !          wstar(:,:,ivmu) = dydalpha*drhodpsi*wstarknob*0.5*code_dt & !               * maxwell_vpa(iv,is)*maxwell_mu(:,:,imu,is)*maxwell_fac(is) & !               * (spec(is)%fprim+spec(is)%tprim*(energy-1.5)) wstar (:, :, ivmu ) = dydalpha * drhodpsi * wstarknob * 0.5 * code_dt & * ( spec ( is )% fprim + spec ( is )% tprim * ( energy - 1.5 )) end if if (. not . full_flux_surface ) then wstar (:, :, ivmu ) = wstar (:, :, ivmu ) * maxwell_vpa ( iv , is ) * maxwell_mu (:, :, imu , is ) * maxwell_fac ( is ) end if end do deallocate ( energy ) end subroutine init_wstar subroutine init_drifts_implicit use constants , only : zi use mp , only : sum_allreduce , mp_abort use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx , imu_idx , is_idx use gyro_averages , only : aj0x use dist_fn_arrays , only : wdriftx_phi , wdrifty_phi use dist_fn_arrays , only : wdriftx_g , wdrifty_g use dist_fn_arrays , only : wstar use fields_arrays , only : gamtot use fields , only : efac use run_parameters , only : fphi , fapar , time_upwind use species , only : spec , has_electron_species use stella_geometry , only : dl_over_b use zgrid , only : nzgrid use vpamu_grids , only : integrate_species use species , only : spec use kt_grids , only : naky , nakx , aky , akx , zonal_mode use physics_flags , only : adiabatic_option_switch use physics_flags , only : adiabatic_option_fieldlineavg implicit none integer :: ivmu , iz , ikx , is , ia , iv , imu complex :: tmps complex , dimension (:, :, :), allocatable :: g0 complex , dimension (:, :), allocatable :: wd_g , wd_phi , wstr , tmp if ( driftimpinit ) return driftimpinit = . true . ia = 1 allocate ( wd_g ( naky , nakx )) allocate ( wd_phi ( naky , nakx )) allocate ( wstr ( naky , nakx )) allocate ( tmp ( naky , nakx )) if (. not . allocated ( gamtot_drifts )) & allocate ( gamtot_drifts ( naky , nakx , - nzgrid : nzgrid )) gamtot_drifts = 0. if (. not . allocated ( gamtot3_drifts )) & allocate ( gamtot3_drifts ( nakx , - nzgrid : nzgrid )) gamtot3_drifts = 0. !     if (.not.allocated(apar_denom_drifts)) & !          allocate (apar_denom_wstar(naky,nakx,-nzgrid:nzgrid)) !     apar_denom_wstar = 0. if ( fphi > epsilon ( 0.0 )) then allocate ( g0 ( naky , nakx , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) do iz = - nzgrid , nzgrid do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) !there terms already contain a factor of code_dt as well as !a negative sign to account for RHS wd_g = - zi * ( spread ( akx , 1 , naky ) * wdriftx_g ( ia , iz , ivmu ) & + spread ( aky , 2 , nakx ) * wdrifty_g ( ia , iz , ivmu )) wd_phi = - zi * ( spread ( akx , 1 , naky ) * wdriftx_phi ( ia , iz , ivmu ) & + spread ( aky , 2 , nakx ) * wdrifty_phi ( ia , iz , ivmu )) wstr = - zi * spread ( aky , 2 , nakx ) * wstar ( ia , iz , ivmu ) g0 (:, :, ivmu ) = 0.5 * ( 1.0 + time_upwind ) * aj0x (:, :, iz , ivmu ) ** 2 & * ( wd_phi + wstr ) / ( 1.0 + 0.5 * ( 1.0 + time_upwind ) * wd_g ) end do call integrate_species ( g0 , iz , spec % z * spec % dens_psi0 , gamtot_drifts (:, :, iz )) end do gamtot_drifts = gamtot_drifts + gamtot deallocate ( g0 ) if (. not . has_electron_species ( spec )) then ! no need to do anything extra for ky /= 0 because ! already accounted for in gamtot_h if ( adiabatic_option_switch == adiabatic_option_fieldlineavg ) then if ( zonal_mode ( 1 )) then do ikx = 1 , nakx ! do not need kx=ky=0 mode if ( abs ( akx ( ikx )) < epsilon ( 0. )) cycle tmps = 1.0 / efac - sum ( dl_over_b ( ia , :) / gamtot_drifts ( 1 , ikx , :)) gamtot3_drifts ( ikx , :) = 1. / ( gamtot_drifts ( 1 , ikx , :) * tmps ) end do if ( akx ( 1 ) < epsilon ( 0. )) gamtot3_drifts ( 1 , :) = 0.0 end if end if end if end if deallocate ( wd_g , wd_phi , wstr , tmp ) ! FLAG -- NEED TO SORT OUT FINITE FAPAR FOR GSTAR if ( fapar > epsilon ( 0. )) then write ( * , * ) 'APAR NOT SETUP FOR GSTAR YET. aborting' call mp_abort ( 'APAR NOT SETUP FOR GSTAR YET. aborting' ) end if !        allocate (g0(-nvgrid:nvgrid,nmu)) !        do ikxkyz = kxkyz_lo%llim_proc, kxkyz_lo%ulim_proc !           iky = iky_idx(kxkyz_lo,ikxkyz) !           ikx = ikx_idx(kxkyz_lo,ikxkyz) !           ig = iz_idx(kxkyz_lo,ikxkyz) !           is = is_idx(kxkyz_lo,ikxkyz) !           g0 = spread(vpa**2,2,nmu)*spread(aj0v(:,ikxkyz)**2,1,nvpa)*anon(ig,:,:) !           wgt = 2.0*beta*spec(is)%z*spec(is)%z*spec(is)%dens/spec(is)%mass !           call integrate_vmu (g0, ig, tmp) !           apar_denom(iky,ikx,ig) = apar_denom(iky,ikx,ig) + tmp*wgt !        end do !        call sum_allreduce (apar_denom) !        apar_denom = apar_denom + kperp2 !        deallocate (g0) !     end if end subroutine init_drifts_implicit subroutine init_parallel_nonlinearity use physics_parameters , only : rhostar use species , only : spec , nspec use zgrid , only : nztot , nzgrid use stella_geometry , only : geo_surf , drhodpsi , q_as_x use stella_geometry , only : gradpar , dbdzed , bmag use stella_geometry , only : cvdrift , cvdrift0 use stella_geometry , only : dIdrho , dgradpardrho , dBdrho , d2Bdrdth use stella_geometry , only : dcvdriftdrho , dcvdrift0drho use physics_flags , only : radial_variation implicit none if (. not . allocated ( par_nl_fac )) allocate ( par_nl_fac ( - nzgrid : nzgrid , nspec )) ! this is the factor multiplying -dphi/dz * dg/dvpa in the parallel nonlinearity par_nl_fac = 0.5 * rhostar * spread ( spec % stm_psi0 * spec % zt_psi0 , 1 , nztot ) * spread ( gradpar , 2 , nspec ) if (. not . allocated ( par_nl_curv )) allocate ( par_nl_curv ( - nzgrid : nzgrid , nspec )) ! ydriftknob is here because this term comes from bhat x curvature . grad B par_nl_curv = - ydriftknob * rhostar * geo_surf % rgeo * geo_surf % betaprim * drhodpsi & * spread ( dbdzed ( 1 , :) * gradpar / bmag ( 1 , :), 2 , nspec ) / spread ( spec % zt_psi0 , 1 , nztot ) if (. not . allocated ( par_nl_drifty )) allocate ( par_nl_drifty ( - nzgrid : nzgrid )) par_nl_drifty = 0.25 * rhostar * cvdrift ( 1 , :) if (. not . allocated ( par_nl_driftx )) allocate ( par_nl_driftx ( - nzgrid : nzgrid )) if ( q_as_x ) then par_nl_driftx = 0.25 * rhostar * cvdrift0 ( 1 , :) else par_nl_driftx = 0.25 * rhostar * cvdrift0 ( 1 , :) / geo_surf % shat end if if ( radial_variation ) then if (. not . allocated ( d_par_nl_fac_dr )) allocate ( d_par_nl_fac_dr ( - nzgrid : nzgrid , nspec )) ! this is the factor multiplying -dphi/dz * dg/dvpa in the parallel nonlinearity d_par_nl_fac_dr = 0.5 * rhostar * spread ( spec % stm_psi0 * spec % zt_psi0 , 1 , nztot ) * spread ( dgradpardrho , 2 , nspec ) if (. not . allocated ( d_par_nl_curv_dr )) allocate ( d_par_nl_curv_dr ( - nzgrid : nzgrid , nspec )) ! ydriftknob is here because this term comes from bhat x curvature . grad B ! handle terms with no zeroes d_par_nl_curv_dr = par_nl_curv * ( dIdrho / geo_surf % rgeo - drhodpsi * geo_surf % d2psidr2 & - spread ( dBdrho / bmag ( 1 , :) + dgradpardrho / gradpar , 2 , nspec )) ! handle terms with possible zeroes d_par_nl_curv_dr = d_par_nl_curv_dr & - (( ydriftknob * rhostar * geo_surf % rgeo * drhodpsi * spread ( gradpar / bmag ( 1 , :), 2 , nspec )) & / spread ( spec % zt_psi0 , 1 , nztot )) & * ( geo_surf % betadbprim * spread ( dbdzed ( 1 , :), 2 , nspec ) & + geo_surf % betaprim * spread ( d2Bdrdth , 2 , nspec )) if (. not . allocated ( d_par_nl_drifty_dr )) allocate ( d_par_nl_drifty_dr ( - nzgrid : nzgrid )) d_par_nl_drifty_dr = 0.25 * rhostar * dcvdriftdrho ( 1 , :) if (. not . allocated ( d_par_nl_drifty_dr )) allocate ( d_par_nl_driftx_dr ( - nzgrid : nzgrid )) if ( q_as_x ) then d_par_nl_driftx_dr = 0.25 * rhostar * dcvdrift0drho ( 1 , :) else d_par_nl_driftx_dr = 0.25 * rhostar * dcvdrift0drho ( 1 , :) / geo_surf % shat end if end if parnlinit = . true . end subroutine init_parallel_nonlinearity subroutine init_radial_variation use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx , imu_idx , is_idx use stella_time , only : code_dt use species , only : spec , pfac use zgrid , only : nzgrid use kt_grids , only : nalpha use stella_geometry , only : drhodpsi , dydalpha , gfac use stella_geometry , only : dBdrho , geo_surf , q_as_x use stella_geometry , only : dcvdriftdrho , dcvdrift0drho use stella_geometry , only : dgbdriftdrho , dgbdrift0drho use vpamu_grids , only : vperp2 , vpa , mu use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use dist_fn_arrays , only : wstarp use dist_fn_arrays , only : wdriftx_phi , wdrifty_phi use dist_fn_arrays , only : wdriftpx_g , wdriftpy_g use dist_fn_arrays , only : wdriftpx_phi , wdriftpy_phi !, adiabatic_phi !   use neoclassical_terms, only: include_neoclassical_terms implicit none integer :: is , imu , iv , ivmu real :: fac real , dimension (:, :), allocatable :: energy real , dimension (:, :), allocatable :: wcvdrifty , wgbdrifty real , dimension (:, :), allocatable :: wcvdriftx , wgbdriftx !wstar if ( radialinit ) return radialinit = . true . allocate ( wcvdrifty ( nalpha , - nzgrid : nzgrid )) allocate ( wgbdrifty ( nalpha , - nzgrid : nzgrid )) allocate ( wcvdriftx ( nalpha , - nzgrid : nzgrid )) allocate ( wgbdriftx ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( wstarp )) & allocate ( wstarp ( nalpha , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )); wstarp = 0.0 if (. not . allocated ( wdriftpx_phi )) & allocate ( wdriftpx_phi ( nalpha , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) !   if (.not.allocated(adiabatic_phi)) & !      allocate (adiabatic_phi(nalpha,-nzgrid:nzgrid,vmu_lo%llim_proc:vmu_lo%ulim_alloc)) if (. not . allocated ( wdriftpy_phi )) & allocate ( wdriftpy_phi ( nalpha , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) if (. not . allocated ( wdriftpx_g )) & allocate ( wdriftpx_g ( nalpha , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) if (. not . allocated ( wdriftpy_g )) & allocate ( wdriftpy_g ( nalpha , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) allocate ( energy ( nalpha , - nzgrid : nzgrid )) do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) iv = iv_idx ( vmu_lo , ivmu ) energy = ( vpa ( iv ) ** 2 + vperp2 (:, :, imu )) * ( spec ( is )% temp_psi0 / spec ( is )% temp ) !FLAG DSO - THIS NEEDS TO BE ADDED SOMEDAY! !if (include_neoclassical_terms) then !   wstarp(:,:,ivmu) = dydalpha*drhodpsi*wstarknob*0.5*code_dt & !        * (maxwell_vpa(iv)*maxwell_mu(:,:,imu) & !        * (spec(is)%fprim+spec(is)%tprim*(energy-1.5)) & !        - dfneo_drho(:,:,ivmu)) !else !recall that fprim = -dn/dr and trpim = -dt/dr wstarp (:, :, ivmu ) = - wstarknob * 0.5 * code_dt & * dydalpha * drhodpsi * maxwell_vpa ( iv , is ) * maxwell_mu (:, :, imu , is ) * maxwell_fac ( is ) & * ( pfac * ( spec ( is )% d2ndr2 - ( spec ( is )% fprim ) ** 2 - ( spec ( is )% tprim ) ** 2 * energy ) & + pfac * ( spec ( is )% d2Tdr2 - ( spec ( is )% tprim ) ** 2 ) * ( energy - 1.5 ) & - gfac * 2 * spec ( is )% tprim * mu ( imu ) * spread ( dBdrho , 1 , nalpha ) & + ( spec ( is )% fprim + spec ( is )% tprim * ( energy - 1.5 )) & * ( pfac * ( spec ( is )% fprim + spec ( is )% tprim * ( energy - 1.5 )) & + gfac * 2 * mu ( imu ) * spread ( dBdrho , 1 , nalpha ) & + gfac * drhodpsi * geo_surf % d2psidr2 )) !end if !wdrift fac = - ydriftknob * 0.5 * code_dt * spec ( is )% tz_psi0 ! this is the curvature drift piece of wdrifty with missing factor of vpa ! vpa factor is missing to avoid singularity when including ! non-Maxwellian corrections to equilibrium wcvdrifty = gfac * fac * dcvdriftdrho * vpa ( iv ) ! this is the grad-B drift piece of wdrifty wgbdrifty = gfac * fac * dgbdriftdrho * 0.5 * vperp2 (:, :, imu ) wdriftpy_g (:, :, ivmu ) = wcvdrifty * vpa ( iv ) + wgbdrifty wdriftpy_phi (:, :, ivmu ) = spec ( is )% zt * ( wgbdrifty + wcvdrifty * vpa ( iv )) & * maxwell_vpa ( iv , is ) * maxwell_mu (:, :, imu , is ) * maxwell_fac ( is ) & - wdrifty_phi (:, :, ivmu ) * ( pfac * ( spec ( is )% fprim + spec ( is )% tprim * ( energy - 2.5 )) & + gfac * 2. * mu ( imu ) * spread ( dBdrho , 1 , nalpha )) if ( q_as_x ) then fac = - xdriftknob * 0.5 * code_dt * spec ( is )% tz_psi0 else fac = - xdriftknob * 0.5 * code_dt * spec ( is )% tz_psi0 / geo_surf % shat end if ! this is the curvature drift piece of wdriftx with missing factor of vpa ! vpa factor is missing to avoid singularity when including ! non-Maxwellian corrections to equilibrium wcvdriftx = gfac * fac * dcvdrift0drho * vpa ( iv ) ! this is the grad-B drift piece of wdriftx wgbdriftx = gfac * fac * dgbdrift0drho * 0.5 * vperp2 (:, :, imu ) wdriftpx_g (:, :, ivmu ) = wgbdriftx + wcvdriftx * vpa ( iv ) wdriftpx_phi (:, :, ivmu ) = spec ( is )% zt * ( wgbdriftx + wcvdriftx * vpa ( iv )) & * maxwell_vpa ( iv , is ) * maxwell_mu (:, :, imu , is ) * maxwell_fac ( is ) & - wdriftx_phi (:, :, ivmu ) * ( pfac * ( spec ( is )% fprim + spec ( is )% tprim * ( energy - 2.5 )) & + gfac * 2. * mu ( imu ) * spread ( dBdrho , 1 , nalpha )) !      !the next piece is everything under the x derivative, as this needs to be !      !transformed separately !      wdriftpx_phi(:,:,ivmu) = spec(is)%zt*(wgbdriftx + wcvdriftx*vpa(iv))  & !           * maxwell_vpa(iv,is)*maxwell_mu(:,:,imu,is)*maxwell_fac(is) !      !this is variation in the Maxwellian part of the adiabatic response of phi, !      !which needs to be transformed separately before differentiation wrt x !      !the gyroaveraging and quasineutrality is already done in fields !      adiabatic_phi(:,:,ivmu) = -(pfac*(spec(is)%fprim+spec(is)%tprim*(energy-2.5)) & !                                 +gfac*2.*mu(imu)*spread(dBdrho,1,nalpha)) end do deallocate ( energy , wcvdriftx , wgbdriftx , wcvdrifty , wgbdrifty ) end subroutine init_radial_variation subroutine allocate_arrays use stella_layouts , only : vmu_lo use zgrid , only : nzgrid , ntubes use kt_grids , only : naky , nakx use dist_fn_arrays , only : g0 , g1 , g2 , g3 implicit none if (. not . allocated ( g0 )) & allocate ( g0 ( naky , nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) g0 = 0. if (. not . allocated ( g1 )) & allocate ( g1 ( naky , nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) g1 = 0. if (. not . allocated ( g2 )) & allocate ( g2 ( naky , nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) g2 = 0. if (. not . allocated ( g3 ) . and . explicit_option_switch == explicit_option_rk4 ) then allocate ( g3 ( naky , nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) g3 = 0. else allocate ( g3 ( 1 , 1 , 1 , 1 , 1 )) end if end subroutine allocate_arrays subroutine init_cfl use mp , only : proc0 , nproc , max_allreduce , min_allreduce use mp , only : scope , allprocs , subprocs use dist_fn_arrays , only : wdriftx_g , wdrifty_g use stella_time , only : cfl_dt , code_dt , write_dt use run_parameters , only : cfl_cushion use physics_flags , only : radial_variation , prp_shear_enabled use zgrid , only : delzed use vpamu_grids , only : dvpa use kt_grids , only : akx , aky , nx , rho use run_parameters , only : stream_implicit , mirror_implicit , drifts_implicit use parallel_streaming , only : stream use parallel_streaming , only : stream_rad_var1 , stream_rad_var2 use mirror_terms , only : mirror use flow_shear , only : prl_shear , shift_times use file_utils , only : runtype_option_switch , runtype_multibox use dissipation , only : include_collisions , collisions_implicit use dissipation , only : vpa_operator , mu_operator use dissipation , only : cfl_dt_vpadiff , cfl_dt_mudiff implicit none real :: cfl_dt_mirror , cfl_dt_stream , cfl_dt_shear real :: cfl_dt_wdriftx , cfl_dt_wdrifty real :: zero real :: wdriftx_max , wdrifty_max ! avoid divide by zero in cfl_dt terms below zero = 10 0. * epsilon ( 0. ) ! FLAG -- assuming equal spacing in zed! if ( cfl_dt < 0 ) cfl_dt = code_dt / cfl_cushion if (. not . drifts_implicit ) then ! get the local max value of wdriftx on each processor wdriftx_max = maxval ( abs ( wdriftx_g )) ! compare these max values across processors to get global max if ( nproc > 1 ) then call max_allreduce ( wdriftx_max ) end if ! NB: wdriftx_g has code_dt built-in, which accounts for code_dt factor here cfl_dt_wdriftx = abs ( code_dt ) / max ( maxval ( abs ( akx )) * wdriftx_max , zero ) cfl_dt = cfl_dt_wdriftx end if cfl_dt_shear = abs ( code_dt ) / max ( maxval ( abs ( aky )) * maxval ( abs ( prl_shear )), zero ) cfl_dt = min ( cfl_dt , cfl_dt_shear ) if ( prp_shear_enabled ) then cfl_dt_shear = minval ( shift_times ) cfl_dt = min ( cfl_dt , cfl_dt_shear ) end if if (. not . stream_implicit ) then ! NB: stream has code_dt built-in, which accounts for code_dt factor here cfl_dt_stream = abs ( code_dt ) * delzed ( 0 ) / max ( maxval ( abs ( stream )), zero ) cfl_dt = min ( cfl_dt , cfl_dt_stream ) end if if (. not . mirror_implicit ) then ! NB: mirror has code_dt built-in, which accounts for code_dt factor here cfl_dt_mirror = abs ( code_dt ) * dvpa / max ( maxval ( abs ( mirror )), zero ) cfl_dt = min ( cfl_dt , cfl_dt_mirror ) end if if ( radial_variation ) then !while other quantities should go here, parallel streaming with electrons !is what will limit us cfl_dt_stream = abs ( code_dt ) * delzed ( 0 ) / max ( maxval ( abs ( stream_rad_var1 )), zero ) cfl_dt_stream = cfl_dt_stream / abs ( rho ( nx ) + zero ) cfl_dt = min ( cfl_dt , cfl_dt_stream ) cfl_dt_stream = abs ( code_dt ) * delzed ( 0 ) / max ( maxval ( abs ( stream_rad_var2 )), zero ) cfl_dt_stream = cfl_dt_stream / abs ( rho ( nx ) + zero ) cfl_dt = min ( cfl_dt , cfl_dt_stream ) end if if ( include_collisions . and . . not . collisions_implicit ) then if ( vpa_operator ) cfl_dt = min ( cfl_dt , cfl_dt_vpadiff ) if ( mu_operator ) cfl_dt = min ( cfl_dt , cfl_dt_mudiff ) end if if (. not . drifts_implicit ) then ! get the local max value of wdrifty on each processor wdrifty_max = maxval ( abs ( wdrifty_g )) ! compare these max values across processors to get global max if ( nproc > 1 ) then call max_allreduce ( wdrifty_max ) end if ! NB: wdrifty_g has code_dt built-in, which accounts for code_dt factor here cfl_dt_wdrifty = abs ( code_dt ) / max ( maxval ( abs ( aky )) * wdrifty_max , zero ) cfl_dt = min ( cfl_dt , cfl_dt_wdrifty ) end if if ( runtype_option_switch == runtype_multibox ) call scope ( allprocs ) call min_allreduce ( cfl_dt ) if ( runtype_option_switch == runtype_multibox ) call scope ( subprocs ) if ( proc0 ) then write ( * , '(A)' ) \"############################################################\" write ( * , '(A)' ) \"                        CFL CONDITION\" write ( * , '(A)' ) \"############################################################\" write ( * , '(A16)' ) 'LINEAR CFL_DT: ' if (. not . drifts_implicit ) write ( * , '(A12,ES12.4)' ) '   wdriftx: ' , cfl_dt_wdriftx if (. not . drifts_implicit ) write ( * , '(A12,ES12.4)' ) '   wdrifty: ' , cfl_dt_wdrifty if (. not . stream_implicit ) write ( * , '(A12,ES12.4)' ) '   stream: ' , cfl_dt_stream if (. not . mirror_implicit ) write ( * , '(A12,ES12.4)' ) '   mirror: ' , cfl_dt_mirror write ( * , * ) end if if ( abs ( code_dt ) > cfl_dt * cfl_cushion ) then if ( proc0 ) then write ( * , * ) 'CHANGING TIME STEP:' write ( * , '(A16, ES10.2E2)' ) \"   code_dt:\" // REPEAT ( ' ' , 50 ), code_dt write ( * , '(A16, ES10.2E2)' ) \"   cfl_dt:\" // REPEAT ( ' ' , 50 ), cfl_dt write ( * , '(A16, ES10.2E2)' ) \"   cfl_cushion:\" // REPEAT ( ' ' , 50 ), cfl_cushion write ( * , '(A65)' ) '     ==> User-specified delt is larger than cfl_dt*cfl_cushion.' // REPEAT ( ' ' , 50 ) write ( * , '(A49,ES12.4)' ) '     ==> Changing code_dt to cfl_dt*cfl_cushion =' // REPEAT ( ' ' , 50 ), cfl_dt * cfl_cushion end if code_dt = sign ( 1.0 , code_dt ) * cfl_dt * cfl_cushion call reset_dt else if ( proc0 ) then call write_dt write ( * , * ) end if end subroutine init_cfl subroutine reset_dt use parallel_streaming , only : parallel_streaming_initialized use parallel_streaming , only : init_parallel_streaming use dissipation , only : init_collisions , collisions_initialized , include_collisions use run_parameters , only : stream_implicit , driftkinetic_implicit , drifts_implicit use response_matrix , only : response_matrix_initialized use response_matrix , only : init_response_matrix use mirror_terms , only : mirror_initialized use mirror_terms , only : init_mirror use flow_shear , only : flow_shear_initialized use flow_shear , only : init_flow_shear use physics_flags , only : radial_variation use sources , only : init_source_timeaverage use sources , only : init_quasineutrality_source , qn_source_initialized implicit none ! need to recompute mirror and streaming terms ! to account for updated code_dt wdriftinit = . false . wstarinit = . false . radialinit = . false . driftimpinit = . false . flow_shear_initialized = . false . mirror_initialized = . false . parallel_streaming_initialized = . false . qn_source_initialized = . false . if ( debug ) write ( 6 , * ) 'time_advance::reset_dt::init_wstar' call init_wstar if ( debug ) write ( 6 , * ) 'time_advance::reset_dt::init_wdrift' call init_wdrift if ( debug ) write ( 6 , * ) 'time_advance::reset_dt::init_mirror' call init_mirror if ( debug ) write ( 6 , * ) 'time_advance::reset_dt::init_parallel_streaming' call init_parallel_streaming if ( debug ) write ( 6 , * ) 'time_advance::reset_dt::init_flow_shear' call init_flow_shear if ( debug ) write ( 6 , * ) 'time_advance::reset_dt::init_source_timeaverage' call init_source_timeaverage if ( debug ) write ( 6 , * ) 'time_advance::reset_dt::init_quasineutrality_source' call init_quasineutrality_source if ( radial_variation ) then if ( debug ) write ( 6 , * ) 'time_advance::reset_dt::init_radial_variation' call init_radial_variation end if if ( drifts_implicit ) then if ( debug ) write ( 6 , * ) 'time_advance::reset_dt::init_drifts_implicit' call init_drifts_implicit end if if ( include_collisions ) then if ( debug ) write ( 6 , * ) 'time_advance::reset_dt::init_collisions' collisions_initialized = . false . call init_collisions end if ! do not try to re-init response matrix ! before it has been initialized the first time if (( stream_implicit . or . driftkinetic_implicit ) . and . response_matrix_initialized ) then response_matrix_initialized = . false . if ( debug ) write ( 6 , * ) 'time_advance::reset_dt::init_response_matrix' call init_response_matrix end if end subroutine reset_dt subroutine advance_stella ( istep ) use dist_fn_arrays , only : gold , gnew use fields_arrays , only : phi , apar use fields_arrays , only : phi_old use fields , only : advance_fields , fields_updated use run_parameters , only : fully_explicit use multibox , only : RK_step use sources , only : include_krook_operator , update_tcorr_krook use sources , only : include_qn_source , update_quasineutrality_source use sources , only : remove_zero_projection , project_out_zero use kt_grids , only : nakx implicit none integer , intent ( in ) :: istep !> unless running in multibox mode, no need to worry about !> mb_communicate calls as the subroutine is immediately exited !> if not in multibox mode. if (. not . RK_step ) then if ( debug ) write ( * , * ) 'time_advance::multibox' call mb_communicate ( gnew ) end if !> save value of phi !> for use in diagnostics (to obtain frequency) phi_old = phi !> reverse the order of operations every time step !> as part of alternating direction operator splitting !> this is needed to ensure 2nd order accuracy in time if ( mod ( istep , 2 ) == 1 . or . . not . flip_flop ) then !> advance the explicit parts of the GKE if ( debug ) write ( * , * ) 'time_advance::advance_explicit' call advance_explicit ( gnew ) ! enforce periodicity for zonal mode !    if (zonal_mode(1)) gnew(1,:,-nzgrid,:) = gnew(1,:,nzgrid,:) !> use operator splitting to separately evolve !> all terms treated implicitly if (. not . fully_explicit ) call advance_implicit ( istep , phi , apar , gnew ) else if (. not . fully_explicit ) call advance_implicit ( istep , phi , apar , gnew ) call advance_explicit ( gnew ) end if ! presumably this is to do with the radially global version of the code? ! perhaps it could be packaged together with thee update_delay_krook code ! below and made into a single call where all of this happens so that ! users of the flux tube version of the code need not worry about it. if ( remove_zero_projection ) then call project_out_zero ( gold , gnew ) fields_updated = . false . end if gold = gnew !> Ensure fields are updated so that omega calculation is correct. call advance_fields ( gnew , phi , apar , dist = 'gbar' ) !update the delay parameters for the Krook operator if ( include_krook_operator ) call update_tcorr_krook ( gnew ) if ( include_qn_source ) call update_quasineutrality_source end subroutine advance_stella !  subroutine advance_explicit (phi, apar, g) !> advance_explicit takes as input the guiding centre distribution function !> in k-space and updates it to account for all of the terms in the GKE that !> are advanced explicitly in time subroutine advance_explicit ( g ) use mp , only : proc0 use job_manage , only : time_message use zgrid , only : nzgrid use extended_zgrid , only : periodic use kt_grids , only : naky use stella_layouts , only : vmu_lo , iv_idx use parallel_streaming , only : stream_sign implicit none !    complex, dimension (:,:,-nzgrid:), intent (in out) :: phi, apar complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: g integer :: ivmu , iv , sgn , iky !> start the timer for the explicit part of the solve if ( proc0 ) call time_message (. false ., time_gke (:, 8 ), ' explicit' ) select case ( explicit_option_switch ) case ( explicit_option_rk2 ) !> SSP RK2 call advance_explicit_rk2 ( g ) case ( explicit_option_rk3 ) !> default is SSP RK3 call advance_explicit_rk3 ( g ) case ( explicit_option_rk4 ) !> RK4 call advance_explicit_rk4 ( g ) end select !> enforce periodicity for periodic (including zonal) modes do iky = 1 , naky if ( periodic ( iky )) then do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) !> stream_sign > 0 corresponds to dz/dt < 0 sgn = stream_sign ( iv ) g ( iky , :, sgn * nzgrid , :, ivmu ) = g ( iky , :, - sgn * nzgrid , :, ivmu ) end do end if end do !> stop the timer for the explicit part of the solve if ( proc0 ) call time_message (. false ., time_gke (:, 8 ), ' explicit' ) end subroutine advance_explicit !> advance_expliciit_rk2 uses strong stability-preserving RK2 to advance one time step subroutine advance_explicit_rk2 ( g ) use dist_fn_arrays , only : g0 , g1 use zgrid , only : nzgrid use stella_layouts , only : vmu_lo use multibox , only : RK_step implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: g integer :: icnt logical :: restart_time_step !> if CFL condition is violated by nonlinear term !> then must modify time step size and restart time step !> assume false and test restart_time_step = . false . !> RK_step only true if running in multibox mode if ( RK_step ) call mb_communicate ( g ) g0 = g icnt = 1 !> SSP rk3 algorithm to advance explicit part of code !> if GK equation written as dg/dt = rhs - vpar . grad h, !> solve_gke returns rhs*dt do while ( icnt <= 2 ) select case ( icnt ) case ( 1 ) call solve_gke ( g0 , g1 , restart_time_step ) case ( 2 ) g1 = g0 + g1 if ( RK_step ) call mb_communicate ( g1 ) call solve_gke ( g1 , g , restart_time_step ) end select if ( restart_time_step ) then icnt = 1 else icnt = icnt + 1 end if end do !> this is gbar at intermediate time level g = 0.5 * g0 + 0.5 * ( g1 + g ) end subroutine advance_explicit_rk2 !> strong stability-preserving RK3 subroutine advance_explicit_rk3 ( g ) use dist_fn_arrays , only : g0 , g1 , g2 use zgrid , only : nzgrid use stella_layouts , only : vmu_lo use multibox , only : RK_step implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: g integer :: icnt logical :: restart_time_step !> if CFL condition is violated by nonlinear term !> then must modify time step size and restart time step !> assume false and test restart_time_step = . false . !> RK_STEP = false unless in multibox mode if ( RK_step ) call mb_communicate ( g ) g0 = g icnt = 1 !> SSP rk3 algorithm to advance explicit part of code !> if GK equation written as dg/dt = rhs - vpar . grad h, !> solve_gke returns rhs*dt do while ( icnt <= 3 ) select case ( icnt ) case ( 1 ) call solve_gke ( g0 , g1 , restart_time_step ) case ( 2 ) g1 = g0 + g1 if ( RK_step ) call mb_communicate ( g1 ) call solve_gke ( g1 , g2 , restart_time_step ) case ( 3 ) g2 = g1 + g2 if ( RK_step ) call mb_communicate ( g2 ) call solve_gke ( g2 , g , restart_time_step ) end select if ( restart_time_step ) then icnt = 1 else icnt = icnt + 1 end if end do !> this is gbar at intermediate time level g = g0 / 3. + 0.5 * g1 + ( g2 + g ) / 6. end subroutine advance_explicit_rk3 !> standard RK4 subroutine advance_explicit_rk4 ( g ) use dist_fn_arrays , only : g0 , g1 , g2 , g3 use zgrid , only : nzgrid use stella_layouts , only : vmu_lo use multibox , only : RK_step implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: g integer :: icnt logical :: restart_time_step !> if CFL condition is violated by nonlinear term !> then must modify time step size and restart time step !> assume false and test restart_time_step = . false . !> RK_step is false unless in multibox mode if ( RK_step ) call mb_communicate ( g ) g0 = g icnt = 1 !> RK4 algorithm to advance explicit part of code !> if GK equation written as dg/dt = rhs - vpar . grad h, !> solve_gke returns rhs*dt do while ( icnt <= 4 ) select case ( icnt ) case ( 1 ) call solve_gke ( g0 , g1 , restart_time_step ) case ( 2 ) ! g1 is h*k1 g3 = g0 + 0.5 * g1 if ( RK_step ) call mb_communicate ( g3 ) call solve_gke ( g3 , g2 , restart_time_step ) g1 = g1 + 2. * g2 case ( 3 ) ! g2 is h*k2 g2 = g0 + 0.5 * g2 if ( RK_step ) call mb_communicate ( g2 ) call solve_gke ( g2 , g3 , restart_time_step ) g1 = g1 + 2. * g3 case ( 4 ) ! g3 is h*k3 g3 = g0 + g3 if ( RK_step ) call mb_communicate ( g3 ) call solve_gke ( g3 , g , restart_time_step ) g1 = g1 + g end select if ( restart_time_step ) then icnt = 1 else icnt = icnt + 1 end if end do !> this is gbar at intermediate time level g = g0 + g1 / 6. end subroutine advance_explicit_rk4 !> solve_gke accepts as argument gin, the guiding centre distribution function in k-space, !> and returns rhs_ky, the right-hand side of the gyrokinetic equation in k-space; !> i.e., if dg/dt = r, then rhs_ky = r*dt subroutine solve_gke ( gin , rhs_ky , restart_time_step ) use job_manage , only : time_message use fields_arrays , only : phi , apar use stella_layouts , only : vmu_lo use stella_transforms , only : transform_y2ky use redistribute , only : gather , scatter use physics_flags , only : include_parallel_nonlinearity use physics_flags , only : include_parallel_streaming use physics_flags , only : include_mirror use physics_flags , only : nonlinear use physics_flags , only : full_flux_surface , radial_variation use physics_parameters , only : g_exb use zgrid , only : nzgrid , ntubes use kt_grids , only : ikx_max , ny , naky_all use kt_grids , only : swap_kxky_back use run_parameters , only : stream_implicit , mirror_implicit , drifts_implicit use dissipation , only : include_collisions , advance_collisions_explicit , collisions_implicit use sources , only : include_krook_operator , add_krook_operator use parallel_streaming , only : advance_parallel_streaming_explicit use fields , only : advance_fields , fields_updated , get_radial_correction use mirror_terms , only : advance_mirror_explicit use flow_shear , only : advance_parallel_flow_shear use multibox , only : include_multibox_krook , add_multibox_krook implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( inout ) :: gin complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( out ), target :: rhs_ky logical , intent ( out ) :: restart_time_step complex , dimension (:, :, :, :, :), allocatable , target :: rhs_y complex , dimension (:, :, :, :, :), pointer :: rhs complex , dimension (:, :), allocatable :: rhs_ky_swap integer :: iz , it , ivmu rhs_ky = 0. !> if full_flux_surface = .true., then initially obtain the RHS of the GKE in alpha-space; !> will later inverse Fourier transform to get RHS in k_alpha-space if ( full_flux_surface ) then !> rhs_ky will always be needed as the array returned by the subroutine, !> but intermediate array rhs_y (RHS of gke in alpha-space) only needed for full_flux_surface = .true. allocate ( rhs_y ( ny , ikx_max , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) rhs_y = 0. !> rhs is array referred to for both flux tube and full-flux-surface simulations; !> for full-flux-surface it should point to rhs_y rhs => rhs_y else !> rhs is array referred to for both flux tube and full-flux-surface simulations; !> for flux tube it should point to rhs_ky rhs => rhs_ky end if !> start with gbar in k-space and (ky,kx,z) local !> obtain fields corresponding to gbar if ( debug ) write ( * , * ) 'time_advance::advance_stella::advance_explicit::solve_gke::advance_fields' call advance_fields ( gin , phi , apar , dist = 'gbar' ) if ( radial_variation ) call get_radial_correction ( gin , phi , dist = 'gbar' ) !> default is to continue with same time step size. !> if estimated CFL condition for nonlinear terms is violated !> then restart_time_step will be set to .true. restart_time_step = . false . !> calculate and add ExB nonlinearity to RHS of GK eqn !> do this first, as the CFL condition may require a change in time step !> and thus recomputation of mirror, wdrift, wstar, and parstream if ( debug ) write ( * , * ) 'time_advance::advance_stella::advance_explicit::solve_gke::advance_ExB_nonlinearity' if ( nonlinear ) call advance_ExB_nonlinearity ( gin , rhs , restart_time_step ) !> include contribution from the parallel nonlinearity (aka turbulent acceleration) if ( include_parallel_nonlinearity . and . . not . restart_time_step ) & call advance_parallel_nonlinearity ( gin , rhs , restart_time_step ) if (. not . restart_time_step ) then !> include contribution from perp flow shear in the parallel component of the toroidal flow if (( g_exb ** 2 ) > epsilon ( 0.0 )) call advance_parallel_flow_shear ( rhs ) !> calculate and add mirror term to RHS of GK eqn if ( include_mirror . and . . not . mirror_implicit ) then if ( debug ) write ( * , * ) 'time_advance::advance_stella::advance_explicit::solve_gke::advance_mirror_explicit' call advance_mirror_explicit ( gin , rhs ) end if if (. not . drifts_implicit ) then !> calculate and add alpha-component of magnetic drift term to RHS of GK eqn if ( debug ) write ( * , * ) 'time_advance::advance_stella::advance_explicit::solve_gke::advance_wdrifty_explicit' call advance_wdrifty_explicit ( gin , phi , rhs ) !> calculate and add psi-component of magnetic drift term to RHS of GK eqn if ( debug ) write ( * , * ) 'time_advance::advance_stella::advance_explicit::solve_gke::advance_wdriftx_explicit' call advance_wdriftx_explicit ( gin , phi , rhs ) !> calculate and add omega_* term to RHS of GK eqn if ( debug ) write ( * , * ) 'time_advance::advance_stella::advance_explicit::solve_gke::advance_wstar_explicit' call advance_wstar_explicit ( phi , rhs ) end if !> calculate and add contribution from collisions to RHS of GK eqn if ( include_collisions . and . . not . collisions_implicit ) call advance_collisions_explicit ( gin , phi , rhs ) !> calculate and add parallel streaming term to RHS of GK eqn if ( include_parallel_streaming . and . (. not . stream_implicit )) then if ( debug ) write ( * , * ) 'time_advance::advance_stella::advance_explicit::solve_gke::advance_parallel_streaming_explicit' call advance_parallel_streaming_explicit ( gin , phi , rhs ) end if !> if simulating a full flux surface (flux annulus), all terms to this point have been calculated !> in real-space in alpha (y); transform to kalpha (ky) space before adding to RHS of GKE. !> NB: it may be that for fully explicit calculation, this transform can be eliminated with additional code changes if ( full_flux_surface ) then if ( debug ) write ( * , * ) 'time_advance::advance_stella::advance_explicit::solve_gke::transform_y2ky' allocate ( rhs_ky_swap ( naky_all , ikx_max )) it = 1 do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do iz = - nzgrid , nzgrid call transform_y2ky ( rhs_y (:, :, iz , it , ivmu ), rhs_ky_swap ) call swap_kxky_back ( rhs_ky_swap , rhs_ky (:, :, iz , it , ivmu )) end do end do deallocate ( rhs_y , rhs_ky_swap ) end if if ( radial_variation ) call advance_radial_variation ( gin , rhs ) if ( include_krook_operator ) call add_krook_operator ( gin , rhs ) if ( include_multibox_krook ) call add_multibox_krook ( gin , rhs ) end if fields_updated = . false . nullify ( rhs ) end subroutine solve_gke subroutine advance_wstar_explicit ( phi , gout ) use mp , only : proc0 , mp_abort use job_manage , only : time_message use fields , only : get_dchidy use fields_arrays , only : apar use stella_layouts , only : vmu_lo use stella_transforms , only : transform_ky2y use zgrid , only : nzgrid , ntubes use kt_grids , only : naky , naky_all , nakx , ikx_max , ny use kt_grids , only : swap_kxky use physics_flags , only : full_flux_surface use dist_fn_arrays , only : wstar implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: phi complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: gout complex , dimension (:, :, :, :, :), allocatable :: g0 , g0y complex , dimension (:, :), allocatable :: g0_swap integer :: iz , it , ivmu !> start timing the time advance due to the driving gradients if ( proc0 ) call time_message (. false ., time_gke (:, 6 ), ' wstar advance' ) allocate ( g0 ( naky , nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) if ( debug ) write ( * , * ) 'time_advance::solve_gke::get_dchidy' !> get d<chi>/dy in k-space call get_dchidy ( phi , apar , g0 ) if ( full_flux_surface ) then !> assume only a single flux surface simulated it = 1 allocate ( g0y ( ny , ikx_max , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) allocate ( g0_swap ( naky_all , ikx_max )) !> transform d<chi>/dy from k-space to y-space do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do iz = - nzgrid , nzgrid call swap_kxky ( g0 (:, :, iz , it , ivmu ), g0_swap ) call transform_ky2y ( g0_swap , g0y (:, :, iz , it , ivmu )) end do end do !> multiply d<chi>/dy with omega_* coefficient and add to source (RHS of GK eqn) !       call add_wstar_term_ffs (g0y, gout) call add_explicit_term_ffs ( g0y , wstar , gout ) deallocate ( g0y , g0_swap ) else !> omega_* stays in ky,kx,z space with ky,kx,z local !> multiply d<chi>/dy with omega_* coefficient and add to source (RHS of GK eqn) if ( debug ) write ( * , * ) 'time_advance::solve_gke::add_wstar_term' !       call add_wstar_term (g0, gout) call add_explicit_term ( g0 , wstar ( 1 , :, :), gout ) end if deallocate ( g0 ) !> stop timing the time advance due to the driving gradients if ( proc0 ) call time_message (. false ., time_gke (:, 6 ), ' wstar advance' ) end subroutine advance_wstar_explicit !> advance_wdrifty_explicit subroutine calculates and adds the y-component of the !> magnetic drift term to the RHS of the GK equation subroutine advance_wdrifty_explicit ( g , phi , gout ) use mp , only : proc0 use stella_layouts , only : vmu_lo use job_manage , only : time_message use stella_transforms , only : transform_ky2y use zgrid , only : nzgrid , ntubes use kt_grids , only : nakx , ikx_max , naky , naky_all , ny use kt_grids , only : swap_kxky use physics_flags , only : full_flux_surface use gyro_averages , only : gyro_average use dist_fn_arrays , only : wdrifty_g , wdrifty_phi implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: phi complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: gout integer :: ivmu , iz , it complex , dimension (:, :, :, :), allocatable :: dphidy complex , dimension (:, :, :, :, :), allocatable :: g0k , g0y complex , dimension (:, :), allocatable :: g0k_swap !> start the timing of the y component of the magnetic drift advance if ( proc0 ) call time_message (. false ., time_gke (:, 4 ), ' dgdy advance' ) allocate ( dphidy ( naky , nakx , - nzgrid : nzgrid , ntubes )) allocate ( g0k ( naky , nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) if ( debug ) write ( * , * ) 'time_advance::advance_stella::advance_explicit::solve_gke::advance_wdrifty_explicit::get_dgdy' !> calculate dg/dy in (ky,kx) space call get_dgdy ( g , g0k ) !> calculate dphi/dy in (ky,kx) space call get_dgdy ( phi , dphidy ) if ( full_flux_surface ) then !> assume only a single flux surface simulated it = 1 allocate ( g0y ( ny , ikx_max , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) allocate ( g0k_swap ( naky_all , ikx_max )) !> transform dg/dy from k-space to y-space do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do iz = - nzgrid , nzgrid call swap_kxky ( g0k (:, :, iz , it , ivmu ), g0k_swap ) call transform_ky2y ( g0k_swap , g0y (:, :, iz , it , ivmu )) end do end do !> add vM . grad y dg/dy term to equation call add_explicit_term_ffs ( g0y , wdrifty_g , gout ) !> get <dphi/dy> in k-space do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc call gyro_average ( dphidy , ivmu , g0k (:, :, :, :, ivmu )) end do !> transform d<phi>/dy from k-space to y-space do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do iz = - nzgrid , nzgrid call swap_kxky ( g0k (:, :, iz , it , ivmu ), g0k_swap ) call transform_ky2y ( g0k_swap , g0y (:, :, iz , it , ivmu )) end do end do !> add vM . grad y d<phi>/dy term to equation call add_explicit_term_ffs ( g0y , wdrifty_phi , gout ) deallocate ( g0y , g0k_swap ) else if ( debug ) write ( * , * ) 'time_advance::solve_gke::add_dgdy_term' ! add vM . grad y dg/dy term to equation call add_explicit_term ( g0k , wdrifty_g ( 1 , :, :), gout ) ! get <dphi/dy> in k-space do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc call gyro_average ( dphidy , ivmu , g0k (:, :, :, :, ivmu )) end do ! add vM . grad y d<phi>/dy term to equation call add_explicit_term ( g0k , wdrifty_phi ( 1 , :, :), gout ) end if deallocate ( g0k , dphidy ) !> stop the timing of the y component of the magnetic drift advance if ( proc0 ) call time_message (. false ., time_gke (:, 4 ), ' dgdy advance' ) end subroutine advance_wdrifty_explicit !> advance_wdriftx_explicit subroutine calculates and adds the x-component of the !> magnetic drift term to the RHS of the GK equation subroutine advance_wdriftx_explicit ( g , phi , gout ) use mp , only : proc0 use stella_layouts , only : vmu_lo use job_manage , only : time_message use stella_transforms , only : transform_ky2y use zgrid , only : nzgrid , ntubes use kt_grids , only : nakx , ikx_max , naky , naky_all , ny , akx use kt_grids , only : swap_kxky use physics_flags , only : full_flux_surface use gyro_averages , only : gyro_average use dist_fn_arrays , only : wdriftx_g , wdriftx_phi implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: phi complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: gout integer :: ivmu , iz , it complex , dimension (:, :, :, :), allocatable :: dphidx complex , dimension (:, :, :, :, :), allocatable :: g0k , g0y complex , dimension (:, :), allocatable :: g0k_swap !> start the timing of the x component of the magnetic drift advance if ( proc0 ) call time_message (. false ., time_gke (:, 5 ), ' dgdx advance' ) !> do not calculate if wdriftx terms are all zero if ( maxval ( abs ( akx )) < epsilon ( 0. )) then if ( proc0 ) call time_message (. false ., time_gke (:, 5 ), ' dgdx advance' ) return end if allocate ( dphidx ( naky , nakx , - nzgrid : nzgrid , ntubes )) allocate ( g0k ( naky , nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) if ( debug ) write ( * , * ) 'time_advance::solve_gke::get_dgdx' !> calculate dg/dx in (ky,kx) space call get_dgdx ( g , g0k ) !> calculate dphi/dx in (ky,kx) space call get_dgdx ( phi , dphidx ) if ( full_flux_surface ) then !> assume a single flux surface is simulated it = 1 allocate ( g0y ( ny , ikx_max , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) allocate ( g0k_swap ( naky_all , ikx_max )) !> transform dg/dx from k-space to y-space do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do iz = - nzgrid , nzgrid call swap_kxky ( g0k (:, :, iz , it , ivmu ), g0k_swap ) call transform_ky2y ( g0k_swap , g0y (:, :, iz , it , ivmu )) end do end do !> add vM . grad x dg/dx term to equation call add_explicit_term_ffs ( g0y , wdriftx_g , gout ) !> get <dphi/dx> in k-space do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc call gyro_average ( dphidx , ivmu , g0k (:, :, :, :, ivmu )) end do !> transform d<phi>/dx from k-space to y-space do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do iz = - nzgrid , nzgrid call swap_kxky ( g0k (:, :, iz , it , ivmu ), g0k_swap ) call transform_ky2y ( g0k_swap , g0y (:, :, iz , it , ivmu )) end do end do !> add vM . grad x d<phi>/dx term to equation call add_explicit_term_ffs ( g0y , wdriftx_phi , gout ) deallocate ( g0y , g0k_swap ) else if ( debug ) write ( * , * ) 'time_advance::solve_gke::add_dgdx_term' !> add vM . grad x dg/dx term to equation call add_explicit_term ( g0k , wdriftx_g ( 1 , :, :), gout ) !> get <dphi/dx> in k-space do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc call gyro_average ( dphidx , ivmu , g0k (:, :, :, :, ivmu )) end do !> add vM . grad x d<phi>/dx term to equation call add_explicit_term ( g0k , wdriftx_phi ( 1 , :, :), gout ) end if deallocate ( g0k , dphidx ) !> stop the timing of the x component of the magnetic drift advance if ( proc0 ) call time_message (. false ., time_gke (:, 5 ), ' dgdx advance' ) end subroutine advance_wdriftx_explicit subroutine advance_ExB_nonlinearity ( g , gout , restart_time_step ) use mp , only : proc0 , min_allreduce use mp , only : scope , allprocs , subprocs use stella_layouts , only : vmu_lo , imu_idx , is_idx use job_manage , only : time_message use gyro_averages , only : gyro_average use fields , only : get_dchidx , get_dchidy use fields_arrays , only : phi , apar , shift_state use fields_arrays , only : phi_corr_QN , phi_corr_GA !   use fields_arrays, only: apar_corr_QN, apar_corr_GA use stella_transforms , only : transform_y2ky , transform_x2kx use stella_transforms , only : transform_y2ky_xfirst , transform_x2kx_xfirst use stella_time , only : cfl_dt , code_dt , code_dt_max use run_parameters , only : cfl_cushion , delt_adjust , fphi use physics_parameters , only : g_exb , g_exbfac use zgrid , only : nzgrid , ntubes use stella_geometry , only : exb_nonlin_fac , exb_nonlin_fac_p , gfac use kt_grids , only : nakx , ikx_max , naky , naky_all , nx , ny use kt_grids , only : akx , aky , rho_clamped use physics_flags , only : full_flux_surface , radial_variation use physics_flags , only : prp_shear_enabled , hammett_flow_shear use kt_grids , only : x , swap_kxky , swap_kxky_back use constants , only : pi , zi use file_utils , only : runtype_option_switch , runtype_multibox implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: gout logical , intent ( out ) :: restart_time_step complex , dimension (:, :), allocatable :: g0k , g0a , g0k_swap complex , dimension (:, :), allocatable :: g0kxy , g0xky , prefac real , dimension (:, :), allocatable :: g0xy , g1xy , bracket integer :: ivmu , iz , it , imu , is logical :: yfirst ! alpha-component of magnetic drift (requires ky -> y) if ( proc0 ) call time_message (. false ., time_gke (:, 7 ), ' ExB nonlinear advance' ) if ( debug ) write ( * , * ) 'time_advance::solve_gke::advance_ExB_nonlinearity::get_dgdy' restart_time_step = . false . ! this statement seems to imply that flow shear is not compatible with FFS ! need to check yfirst = . not . prp_shear_enabled allocate ( g0k ( naky , nakx )) allocate ( g0a ( naky , nakx )) allocate ( g0xy ( ny , nx )) allocate ( g1xy ( ny , nx )) allocate ( bracket ( ny , nx )) allocate ( prefac ( naky , nx )) if ( yfirst ) then allocate ( g0k_swap ( naky_all , ikx_max )) allocate ( g0kxy ( ny , ikx_max )) else allocate ( g0xky ( naky , nx )) end if !> compute phase factor needed when running with equilibrium flow shear prefac = 1.0 if ( prp_shear_enabled . and . hammett_flow_shear ) then prefac = exp ( - zi * g_exb * g_exbfac * spread ( x , 1 , naky ) * spread ( aky * shift_state , 2 , nx )) end if do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) do it = 1 , ntubes do iz = - nzgrid , nzgrid !> compute i*ky*g call get_dgdy ( g (:, :, iz , it , ivmu ), g0k ) !> FFT to get dg/dy in (y,x) space call forward_transform ( g0k , g0xy ) !> compute i*kx*<chi> call get_dchidx ( iz , ivmu , phi (:, :, iz , it ), apar (:, :, iz , it ), g0k ) !> if running with equilibrium flow shear, make adjustment to !> the term multiplying dg/dy if ( prp_shear_enabled . and . hammett_flow_shear ) then call get_dchidy ( iz , ivmu , phi (:, :, iz , it ), apar (:, :, iz , it ), g0a ) g0k = g0k - g_exb * g_exbfac * spread ( shift_state , 2 , nakx ) * g0a end if !> FFT to get d<chi>/dx in (y,x) space call forward_transform ( g0k , g1xy ) !> multiply by the geometric factor appearing in the Poisson bracket; !> i.e., (dx/dpsi*dy/dalpha)*0.5 g1xy = g1xy * exb_nonlin_fac !> compute the contribution to the Poisson bracket from dg/dy*d<chi>/dx bracket = g0xy * g1xy !> estimate the CFL dt due to the above contribution cfl_dt = min ( cfl_dt , 2. * pi / ( maxval ( abs ( g1xy )) * aky ( naky ))) if ( radial_variation ) then bracket = bracket + gfac * g0xy * g1xy * exb_nonlin_fac_p * spread ( rho_clamped , 1 , ny ) call gyro_average ( phi_corr_QN (:, :, iz , it ), iz , ivmu , g0a ) g0a = fphi * ( g0a + phi_corr_GA (:, :, iz , it , ivmu )) call get_dgdx ( g0a , g0k ) call forward_transform ( g0k , g1xy ) g1xy = g1xy * exb_nonlin_fac bracket = bracket + g0xy * g1xy end if !> estimate the CFL dt due to the above contribution cfl_dt = min ( cfl_dt , 2. * pi / ( maxval ( abs ( g1xy )) * aky ( naky ))) !> compute dg/dx in k-space (= i*kx*g) call get_dgdx ( g (:, :, iz , it , ivmu ), g0k ) !> if running with equilibrium flow shear, correct dg/dx term if ( prp_shear_enabled . and . hammett_flow_shear ) then call get_dgdy ( g (:, :, iz , it , ivmu ), g0a ) g0k = g0k - g_exb * g_exbfac * spread ( shift_state , 2 , nakx ) * g0a end if !> FFT to get dg/dx in (y,x) space call forward_transform ( g0k , g0xy ) !> compute d<chi>/dy in k-space call get_dchidy ( iz , ivmu , phi (:, :, iz , it ), apar (:, :, iz , it ), g0k ) !> FFT to get d<chi>/dy in (y,x) space call forward_transform ( g0k , g1xy ) !> multiply by the geometric factor appearing in the Poisson bracket; !> i.e., (dx/dpsi*dy/dalpha)*0.5 g1xy = g1xy * exb_nonlin_fac !> compute the contribution to the Poisson bracket from dg/dy*d<chi>/dx bracket = bracket - g0xy * g1xy !> estimate the CFL dt due to the above contribution cfl_dt = min ( cfl_dt , 2. * pi / ( maxval ( abs ( g1xy )) * akx ( ikx_max ))) if ( radial_variation ) then bracket = bracket - gfac * g0xy * g1xy * exb_nonlin_fac_p * spread ( rho_clamped , 1 , ny ) call gyro_average ( phi_corr_QN (:, :, iz , it ), iz , ivmu , g0a ) g0a = fphi * ( g0a + phi_corr_GA (:, :, iz , it , ivmu )) call get_dgdy ( g0a , g0k ) call forward_transform ( g0k , g1xy ) g1xy = g1xy * exb_nonlin_fac bracket = bracket - g0xy * g1xy end if !> estimate the CFL dt due to the above contribution cfl_dt = min ( cfl_dt , 2. * pi / ( maxval ( abs ( g1xy )) * akx ( ikx_max ))) if ( yfirst ) then call transform_x2kx ( bracket , g0kxy ) if ( full_flux_surface ) then gout (:, :, iz , it , ivmu ) = g0kxy else call transform_y2ky ( g0kxy , g0k_swap ) call swap_kxky_back ( g0k_swap , gout (:, :, iz , it , ivmu )) end if else call transform_y2ky_xfirst ( bracket , g0xky ) g0xky = g0xky / prefac call transform_x2kx_xfirst ( g0xky , gout (:, :, iz , it , ivmu )) end if end do end do ! enforce periodicity for zonal mode ! FLAG -- THIS IS PROBABLY NOT NECESSARY (DONE AT THE END OF EXPLICIT ADVANCE) ! AND MAY INDEED BE THE WRONG THING TO DO gout ( 1 , :, - nzgrid , :, ivmu ) = 0.5 * ( gout ( 1 , :, nzgrid , :, ivmu ) + gout ( 1 , :, - nzgrid , :, ivmu )) gout ( 1 , :, nzgrid , :, ivmu ) = gout ( 1 , :, - nzgrid , :, ivmu ) end do deallocate ( g0k , g0a , g0xy , g1xy , bracket ) if ( allocated ( g0k_swap )) deallocate ( g0k_swap ) if ( allocated ( g0xky )) deallocate ( g0xky ) if ( allocated ( g0kxy )) deallocate ( g0kxy ) if ( runtype_option_switch == runtype_multibox ) call scope ( allprocs ) call min_allreduce ( cfl_dt ) if ( runtype_option_switch == runtype_multibox ) call scope ( subprocs ) !> check estimated cfl_dt to see if the time step size needs to be changed if ( code_dt > cfl_dt * cfl_cushion ) then if ( proc0 ) then write ( * , * ) ' ' write ( * , * ) 'CHANGING TIME STEP:' write ( * , '(A16, ES10.2E2)' ) \"   code_dt:\" // REPEAT ( ' ' , 50 ), code_dt write ( * , '(A16, ES10.2E2)' ) \"   cfl_dt:\" // REPEAT ( ' ' , 50 ), cfl_dt write ( * , '(A16, ES10.2E2)' ) \"   cfl_cushion:\" // REPEAT ( ' ' , 50 ), cfl_cushion write ( * , '(A16, ES10.2E2)' ) \"   delt_adjust:\" // REPEAT ( ' ' , 50 ), delt_adjust write ( * , '(A65)' ) '     ==> User-specified delt is larger than cfl_dt*cfl_cushion.' // REPEAT ( ' ' , 50 ) write ( * , '(A61,ES12.4)' ) '     ==> Changing code_dt to cfl_dt*cfl_cushion/delt_adjust =' // REPEAT ( ' ' , 50 ), cfl_dt * cfl_cushion / delt_adjust write ( * , * ) ' ' end if code_dt = cfl_dt * cfl_cushion / delt_adjust call reset_dt restart_time_step = . true . else if ( code_dt < min ( cfl_dt * cfl_cushion / delt_adjust , code_dt_max )) then if ( proc0 ) then write ( * , * ) ' ' write ( * , * ) 'CHANGING TIME STEP:' write ( * , '(A16, ES10.2E2)' ) \"   code_dt:\" // REPEAT ( ' ' , 50 ), code_dt write ( * , '(A16, ES10.2E2)' ) \"   cfl_dt:\" // REPEAT ( ' ' , 50 ), cfl_dt write ( * , '(A16, ES10.2E2)' ) \"   cfl_cushion:\" // REPEAT ( ' ' , 50 ), cfl_cushion write ( * , '(A16, ES10.2E2)' ) \"   delt_adjust:\" // REPEAT ( ' ' , 50 ), delt_adjust write ( * , '(A65)' ) '     ==> User-specified delt is larger than cfl_dt*cfl_cushion.' // REPEAT ( ' ' , 50 ) write ( * , '(A61,ES12.4)' ) '     ==> Changing code_dt to cfl_dt*cfl_cushion/delt_adjust =' // REPEAT ( ' ' , 50 ), cfl_dt * cfl_cushion / delt_adjust write ( * , * ) ' ' end if code_dt = min ( cfl_dt * cfl_cushion / delt_adjust , code_dt_max ) call reset_dt ! FLAG -- NOT SURE THIS IS CORRECT gout = code_dt * gout else gout = code_dt * gout end if if ( proc0 ) call time_message (. false ., time_gke (:, 7 ), ' ExB nonlinear advance' ) contains subroutine forward_transform ( gk , gx ) use stella_transforms , only : transform_ky2y , transform_kx2x use stella_transforms , only : transform_ky2y_xfirst , transform_kx2x_xfirst implicit none complex , dimension (:, :), intent ( in ) :: gk real , dimension (:, :), intent ( out ) :: gx if ( yfirst ) then ! we have i*ky*g(kx,ky) for ky >= 0 and all kx ! want to do 1D complex to complex transform in y ! which requires i*ky*g(kx,ky) for all ky and kx >= 0 ! use g(kx,-ky) = conjg(g(-kx,ky)) ! so i*(-ky)*g(kx,-ky) = -i*ky*conjg(g(-kx,ky)) = conjg(i*ky*g(-kx,ky)) ! and i*kx*g(kx,-ky) = i*kx*conjg(g(-kx,ky)) = conjg(i*(-kx)*g(-kx,ky)) ! and i*(-ky)*J0(kx,-ky)*phi(kx,-ky) = conjg(i*ky*J0(-kx,ky)*phi(-kx,ky)) ! and i*kx*J0(kx,-ky)*phi(kx,-ky) = conjg(i*(-kx)*J0(-kx,ky)*phi(-kx,ky)) ! i.e., can calculate dg/dx, dg/dy, d<phi>/dx and d<phi>/dy ! on stella (kx,ky) grid, then conjugate and flip sign of (kx,ky) ! NB: J0(kx,ky) = J0(-kx,-ky) ! TODO DSO: coordinate change for shearing call swap_kxky ( gk , g0k_swap ) call transform_ky2y ( g0k_swap , g0kxy ) call transform_kx2x ( g0kxy , gx ) else call transform_kx2x_xfirst ( gk , g0xky ) g0xky = g0xky * prefac call transform_ky2y_xfirst ( g0xky , gx ) end if end subroutine forward_transform end subroutine advance_ExB_nonlinearity subroutine advance_parallel_nonlinearity ( g , gout , restart_time_step ) use constants , only : zi use mp , only : proc0 , min_allreduce , mp_abort use mp , only : scope , allprocs , subprocs use stella_layouts , only : vmu_lo , xyz_lo use stella_layouts , only : iv_idx , imu_idx , is_idx use job_manage , only : time_message use finite_differences , only : second_order_centered_zed use finite_differences , only : third_order_upwind use redistribute , only : gather , scatter use fields_arrays , only : phi , phi_corr_QN , phi_corr_GA use stella_transforms , only : transform_ky2y , transform_y2ky use stella_transforms , only : transform_kx2x , transform_x2kx use stella_time , only : cfl_dt , code_dt , code_dt_max use run_parameters , only : cfl_cushion , delt_adjust use zgrid , only : nzgrid , delzed , ntubes use extended_zgrid , only : neigen , nsegments , ikxmod use extended_zgrid , only : iz_low , iz_up use extended_zgrid , only : periodic use physics_flags , only : full_flux_surface , radial_variation use kt_grids , only : akx , aky , nakx , naky , nx , ny , ikx_max use kt_grids , only : swap_kxky , swap_kxky_back , rho_clamped use vpamu_grids , only : nvpa , nmu use vpamu_grids , only : dvpa , vpa , mu use gyro_averages , only : gyro_average use parallel_streaming , only : stream_sign use dist_redistribute , only : xyz2vmu use file_utils , only : runtype_option_switch , runtype_multibox use extended_zgrid , only : fill_zed_ghost_zones implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: gout logical , intent ( out ) :: restart_time_step integer :: ivmu , ixyz integer :: iz , it , iv , imu , is integer :: iky , ie , iseg integer :: advect_sign real , dimension (:), allocatable :: dgdv real , dimension (:, :, :, :, :), allocatable :: g0xy real , dimension (:, :, :), allocatable :: gxy_vmulocal real , dimension (:, :), allocatable :: g1xy , advect_speed complex , dimension ( 2 ) :: gleft , gright complex , dimension (:, :, :, :), allocatable :: phi_gyro , dphidz complex , dimension (:, :), allocatable :: g0k , g0kxy , g0k_swap complex , dimension (:, :), allocatable :: tmp ! alpha-component of magnetic drift (requires ky -> y) if ( proc0 ) call time_message (. false ., time_parallel_nl (:, 1 ), ' parallel nonlinearity advance' ) restart_time_step = . false . ! overview: ! need g and d<phi>/dz in (x,y) space in ! order to upwind dg/dvpa ! 1) transform d<phi>/dz from (kx,ky) to (x,y). layout: vmu_lo ! 2) need sign of parnl advection in xyz_lo (since dg/dvpa !    requires vpa local), so d<phi>/dz(vmu_lo) --> d<phi>/dz(xyz_lo) ! 3) transform g from (kx,ky) to (x,y). layout: vmu_lo ! 4) dg/dvpa requires vpa local, so g(vmu_lo) --> g(xyz_lo) ! 5) calculate dg/dvpa ! 6) multiply dg/dvpa with d<phi>/dz ! 7) product(xyz_lo) --> product(vmu_lo) ! 8) inverse transform product(vmu_lo) allocate ( g0k ( naky , nakx )) allocate ( g0xy ( ny , nx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) allocate ( g0kxy ( ny , ikx_max )) if ( radial_variation ) allocate ( g1xy ( ny , nx )) allocate ( phi_gyro ( naky , nakx , - nzgrid : nzgrid , ntubes )) allocate ( dphidz ( naky , nakx , - nzgrid : nzgrid , ntubes )) allocate ( g0k_swap ( 2 * naky - 1 , ikx_max )) allocate ( tmp ( size ( gout , 1 ), size ( gout , 2 ))) ! get d<phi>/dz in vmu_lo ! we will need to transform it to real-space ! as its sign is needed for upwinding of dg/dvpa do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) ! construct <phi> dphidz = phi if ( radial_variation ) dphidz = dphidz + phi_corr_QN call gyro_average ( dphidz , ivmu , phi_gyro ) if ( radial_variation ) phi_gyro = phi_gyro + phi_corr_GA (:, :, :, :, ivmu ) do iky = 1 , naky do it = 1 , ntubes do ie = 1 , neigen ( iky ) do iseg = 1 , nsegments ( ie , iky ) ! first fill in ghost zones at boundaries in g(z) call fill_zed_ghost_zones ( it , iseg , ie , iky , phi_gyro , gleft , gright ) ! now get d<phi>/dz call second_order_centered_zed ( iz_low ( iseg ), iseg , nsegments ( ie , iky ), & phi_gyro ( iky , ikxmod ( iseg , ie , iky ), iz_low ( iseg ): iz_up ( iseg ), it ), & delzed ( 0 ), stream_sign ( iv ), gleft , gright , periodic ( iky ), & dphidz ( iky , ikxmod ( iseg , ie , iky ), iz_low ( iseg ): iz_up ( iseg ), it )) end do end do end do end do if ( radial_variation ) then do it = 1 , ntubes do iz = - nzgrid , nzgrid ! use reality to swap from ky >= 0, all kx to kx >= 0 , all ky call swap_kxky ( dphidz (:, :, iz , it ), g0k_swap ) ! transform in y call transform_ky2y ( g0k_swap , g0kxy ) ! transform in x call transform_kx2x ( g0kxy , g1xy ) g0xy (:, :, iz , it , ivmu ) = g1xy * ( par_nl_fac ( iz , is ) + d_par_nl_fac_dr ( iz , is ) * spread ( rho_clamped , 1 , ny )) g0k = zi * spread ( aky , 2 , nakx ) * phi_gyro (:, :, iz , it ) call swap_kxky ( g0k , g0k_swap ) call transform_ky2y ( g0k_swap , g0kxy ) call transform_kx2x ( g0kxy , g1xy ) g0xy (:, :, iz , it , ivmu ) = g0xy (:, :, iz , it , ivmu ) & + vpa ( iv ) * g1xy * ( par_nl_drifty ( iz ) + d_par_nl_drifty_dr ( iz ) * spread ( rho_clamped , 1 , ny )) g0k = zi * spread ( akx , 1 , naky ) * phi_gyro (:, :, iz , it ) call swap_kxky ( g0k , g0k_swap ) call transform_ky2y ( g0k_swap , g0kxy ) call transform_kx2x ( g0kxy , g1xy ) g0xy (:, :, iz , it , ivmu ) = g0xy (:, :, iz , it , ivmu ) & + vpa ( iv ) * g1xy * ( par_nl_driftx ( iz ) + d_par_nl_driftx_dr ( iz ) * spread ( rho_clamped , 1 , ny )) g0xy (:, :, iz , it , ivmu ) = g0xy (:, :, iz , it , ivmu ) & + vpa ( iv ) * mu ( imu ) * ( par_nl_curv ( iz , is ) + d_par_nl_curv_dr ( iz , is ) * spread ( rho_clamped , 1 , ny )) end do end do else do it = 1 , ntubes do iz = - nzgrid , nzgrid g0k = dphidz (:, :, iz , it ) * par_nl_fac ( iz , is ) + vpa ( iv ) * mu ( imu ) * par_nl_curv ( iz , is ) & + zi * vpa ( iv ) * phi_gyro (:, :, iz , it ) * ( spread ( akx , 1 , naky ) * par_nl_driftx ( iz ) & + spread ( aky , 2 , nakx ) * par_nl_drifty ( iz )) ! use reality to swap from ky >= 0, all kx to kx >= 0 , all ky call swap_kxky ( g0k , g0k_swap ) ! transform in y call transform_ky2y ( g0k_swap , g0kxy ) ! transform in x call transform_kx2x ( g0kxy , g0xy (:, :, iz , it , ivmu )) end do end do end if end do ! do not need phi_gyro or dphidz  again so deallocate deallocate ( phi_gyro , dphidz ) deallocate ( g0k ) if ( allocated ( g1xy )) deallocate ( g1xy ) allocate ( gxy_vmulocal ( nvpa , nmu , xyz_lo % llim_proc : xyz_lo % ulim_alloc )) allocate ( advect_speed ( nmu , xyz_lo % llim_proc : xyz_lo % ulim_alloc )) ! we now have the advection velocity in vpa in (x,y) space ! next redistribute it so that (vpa,mu) are local if ( proc0 ) call time_message (. false ., time_parallel_nl (:, 2 ), ' parallel nonlinearity redist' ) call scatter ( xyz2vmu , g0xy , gxy_vmulocal ) if ( proc0 ) call time_message (. false ., time_parallel_nl (:, 2 ), ' parallel nonlinearity redist' ) ! advect_speed does not depend on vpa advect_speed = gxy_vmulocal ( 1 , :, :) ! transform g from (kx,ky) to (x,y) do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid call swap_kxky ( g (:, :, iz , it , ivmu ), g0k_swap ) ! transform in y call transform_ky2y ( g0k_swap , g0kxy ) ! transform in x call transform_kx2x ( g0kxy , g0xy (:, :, iz , it , ivmu )) end do end do end do ! redistribute so that (vpa,mu) local if ( proc0 ) call time_message (. false ., time_parallel_nl (:, 2 ), ' parallel nonlinearity redist' ) call scatter ( xyz2vmu , g0xy , gxy_vmulocal ) if ( proc0 ) call time_message (. false ., time_parallel_nl (:, 2 ), ' parallel nonlinearity redist' ) allocate ( dgdv ( nvpa )) ! we now need to form dg/dvpa and obtain product of dg/dvpa with advection speed do ixyz = xyz_lo % llim_proc , xyz_lo % ulim_proc do imu = 1 , nmu ! advect_sign set to +/- 1 depending on sign of the parallel nonlinearity ! advection velocity ! NB: advect_sign = -1 corresponds to positive advection velocity advect_sign = int ( sign ( 1.0 , advect_speed ( imu , ixyz ))) call third_order_upwind ( 1 , gxy_vmulocal (:, imu , ixyz ), dvpa , advect_sign , dgdv ) gxy_vmulocal (:, imu , ixyz ) = dgdv * advect_speed ( imu , ixyz ) cfl_dt = min ( cfl_dt , dvpa / abs ( advect_speed ( imu , ixyz ))) end do end do ! finished with dgdv and advect_speed deallocate ( dgdv , advect_speed ) ! now that we have the full parallel nonlinearity in (x,y)-space ! need to redistribute so that (x,y) local for transforms if ( proc0 ) call time_message (. false ., time_parallel_nl (:, 2 ), ' parallel nonlinearity redist' ) call gather ( xyz2vmu , gxy_vmulocal , g0xy ) if ( proc0 ) call time_message (. false ., time_parallel_nl (:, 2 ), ' parallel nonlinearity redist' ) ! finished with gxy_vmulocal deallocate ( gxy_vmulocal ) ! g0xy is parallel nonlinearity term with (x,y) on processor ! need to inverse Fourier transform do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid call transform_x2kx ( g0xy (:, :, iz , it , ivmu ), g0kxy ) if ( full_flux_surface ) then gout (:, :, iz , it , ivmu ) = gout (:, :, iz , it , ivmu ) + code_dt * g0kxy else call transform_y2ky ( g0kxy , g0k_swap ) call swap_kxky_back ( g0k_swap , tmp ) gout (:, :, iz , it , ivmu ) = gout (:, :, iz , it , ivmu ) + code_dt * tmp end if end do end do end do deallocate ( g0k_swap , g0kxy , g0xy ) if ( runtype_option_switch == runtype_multibox ) call scope ( allprocs ) call min_allreduce ( cfl_dt ) if ( runtype_option_switch == runtype_multibox ) call scope ( subprocs ) if ( code_dt > cfl_dt * cfl_cushion ) then if ( proc0 ) then write ( * , * ) ' ' write ( * , * ) 'CHANGING TIME STEP:' write ( * , '(A16, ES10.2E2)' ) \"   code_dt:\" // REPEAT ( ' ' , 50 ), code_dt write ( * , '(A16, ES10.2E2)' ) \"   cfl_dt:\" // REPEAT ( ' ' , 50 ), cfl_dt write ( * , '(A16, ES10.2E2)' ) \"   cfl_cushion:\" // REPEAT ( ' ' , 50 ), cfl_cushion write ( * , '(A16, ES10.2E2)' ) \"   delt_adjust:\" // REPEAT ( ' ' , 50 ), delt_adjust write ( * , '(A65)' ) '     ==> User-specified delt is larger than cfl_dt*cfl_cushion.' // REPEAT ( ' ' , 50 ) write ( * , '(A61,ES12.4)' ) '     ==> Changing code_dt to cfl_dt*cfl_cushion/delt_adjust =' // REPEAT ( ' ' , 50 ), cfl_dt * cfl_cushion / delt_adjust write ( * , * ) ' ' end if code_dt = cfl_dt * cfl_cushion / delt_adjust call reset_dt restart_time_step = . true . else if ( code_dt < min ( cfl_dt * cfl_cushion / delt_adjust , code_dt_max )) then if ( proc0 ) then write ( * , * ) ' ' write ( * , * ) 'CHANGING TIME STEP:' write ( * , '(A16, ES10.2E2)' ) \"   code_dt:\" // REPEAT ( ' ' , 50 ), code_dt write ( * , '(A16, ES10.2E2)' ) \"   cfl_dt:\" // REPEAT ( ' ' , 50 ), cfl_dt write ( * , '(A16, ES10.2E2)' ) \"   cfl_cushion:\" // REPEAT ( ' ' , 50 ), cfl_cushion write ( * , '(A16, ES10.2E2)' ) \"   delt_adjust:\" // REPEAT ( ' ' , 50 ), delt_adjust write ( * , '(A65)' ) '     ==> User-specified delt is larger than cfl_dt*cfl_cushion.' // REPEAT ( ' ' , 50 ) write ( * , '(A61,ES12.4)' ) '     ==> Changing code_dt to cfl_dt*cfl_cushion/delt_adjust =' // REPEAT ( ' ' , 50 ), cfl_dt * cfl_cushion / delt_adjust write ( * , * ) ' ' end if code_dt = min ( cfl_dt * cfl_cushion / delt_adjust , code_dt_max ) call reset_dt !    else !       gout = code_dt*gout end if if ( proc0 ) call time_message (. false ., time_parallel_nl (:, 1 ), ' parallel nonlinearity advance' ) end subroutine advance_parallel_nonlinearity subroutine advance_radial_variation ( g , gout ) use mp , only : mp_abort , proc0 use job_manage , only : time_message use fields , only : get_dchidy use fields_arrays , only : phi , apar use fields_arrays , only : phi_corr_QN , phi_corr_GA !   use fields_arrays, only: apar_corr_QN, apar_corr_GA use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx , imu_idx , is_idx use stella_transforms , only : transform_kx2x_xfirst , transform_x2kx_xfirst use zgrid , only : nzgrid , ntubes use kt_grids , only : nakx , naky , multiply_by_rho use gyro_averages , only : gyro_average , gyro_average_j1 use run_parameters , only : fphi use physics_flags , only : full_flux_surface use physics_flags , only : include_parallel_streaming , include_mirror use dist_fn_arrays , only : wdriftx_phi , wdrifty_phi use dist_fn_arrays , only : wdriftpx_g , wdriftpy_g use dist_fn_arrays , only : wdriftpx_phi , wdriftpy_phi !, adiabatic_phi use dist_fn_arrays , only : wstar , wstarp use mirror_terms , only : add_mirror_radial_variation use flow_shear , only : prl_shear , prl_shear_p use parallel_streaming , only : add_parallel_streaming_radial_variation implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: gout integer :: ia , ivmu , iv , imu , is , iz , it complex , dimension (:, :), allocatable :: g0k , g1k , g0a complex , dimension (:, :, :, :, :), allocatable :: g_corr allocate ( g0k ( naky , nakx )) allocate ( g1k ( naky , nakx )) allocate ( g0a ( naky , nakx )) if ( debug ) write ( * , * ) 'time_advance::solve_gke::advance_radial_variation' if ( proc0 ) call time_message (. false ., time_gke (:, 10 ), ' radial variation advance' ) if ( include_mirror . or . include_parallel_streaming ) then allocate ( g_corr ( naky , nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) g_corr = 0. end if !grab the mirror and parallel streaming corrections here to save on FFTs if ( include_mirror ) then call add_mirror_radial_variation ( g , g_corr ) end if if ( include_parallel_streaming ) then call add_parallel_streaming_radial_variation ( g , g_corr , gout ) end if if ( full_flux_surface ) then ! FLAG -- ADD SOMETHING HERE call mp_abort ( 'wstarp term not yet setup for full_flux_surface = .true. aborting.' ) end if ia = 1 do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) do it = 1 , ntubes do iz = - nzgrid , nzgrid g0k = 0. !wstar variation call get_dchidy ( iz , ivmu , phi (:, :, iz , it ), apar (:, :, iz , it ), g0a ) g0k = g0k + g0a * wstarp ( ia , iz , ivmu ) !radial variation in ExB nonlinearity is handled in advance_ExB_nonlinearity !wdrift(x/y) - g call get_dgdx ( g (:, :, iz , it , ivmu ), g0a ) g0k = g0k + g0a * wdriftpx_g ( ia , iz , ivmu ) call get_dgdy ( g (:, :, iz , it , ivmu ), g0a ) g0k = g0k + g0a * wdriftpy_g ( ia , iz , ivmu ) !wdrift - phi call get_dgdx ( phi (:, :, iz , it ), g1k ) !wdriftx variation call gyro_average ( g1k , iz , ivmu , g0a ) g0k = g0k + g0a * wdriftpx_phi ( ia , iz , ivmu ) call get_dgdy ( phi (:, :, iz , it ), g1k ) !wdrifty variation call gyro_average ( g1k , iz , ivmu , g0a ) g0k = g0k + g0a * wdriftpy_phi ( ia , iz , ivmu ) !prl_shear variation g0k = g0k + g0a * prl_shear_p ( ia , iz , ivmu ) !mirror term and/or parallel streaming if ( include_mirror . or . include_parallel_streaming ) then g0k = g0k + g_corr (:, :, iz , it , ivmu ) end if !inverse and forward transforms call multiply_by_rho ( g0k ) ! !quasineutrality/gyroaveraging ! call gyro_average ( phi_corr_QN (:, :, iz , it ), iz , ivmu , g0a ) g0a = fphi * ( g0a + phi_corr_GA (:, :, iz , it , ivmu )) !wstar - gyroaverage/quasineutrality variation call get_dgdy ( g0a , g1k ) g0k = g0k + g1k * wstar ( ia , iz , ivmu ) !wdrifty gyroaverage/quasineutrality variation g0k = g0k + g1k * wdrifty_phi ( ia , iz , ivmu ) !prl_shear gyroaverage/quasineutrality variation g0k = g0k + g1k * prl_shear ( ia , iz , ivmu ) !wdriftx gyroaverage/quasineutrality variation call get_dgdx ( g0a , g1k ) g0k = g0k + g1k * wdriftx_phi ( ia , iz , ivmu ) !           !wdriftx F_M/T_s variation !           call gyro_average (phi(:,:,iz,it),iz,ivmu,g0a) !           g0a = adiabatic_phi(ia,iz,ivmu)*g0a !           call multiply_by_rho(g0a) !           call get_dgdx(g0a,g1k) !           g0k = g0k + g1k*wdriftx_phi(ia,iz,ivmu) gout (:, :, iz , it , ivmu ) = gout (:, :, iz , it , ivmu ) + g0k end do end do end do deallocate ( g0k , g1k , g0a ) if ( allocated ( g_corr )) deallocate ( g_corr ) if ( proc0 ) call time_message (. false ., time_gke (:, 10 ), ' radial variation advance' ) end subroutine advance_radial_variation !> compute dg/dy in k-space !> accepts g(ky,kx) subroutine get_dgdy_2d ( g , dgdy ) use constants , only : zi use kt_grids , only : nakx , aky implicit none complex , dimension (:, :), intent ( in ) :: g complex , dimension (:, :), intent ( out ) :: dgdy dgdy = zi * spread ( aky , 2 , nakx ) * g end subroutine get_dgdy_2d !> compute dg/dy in k-space !> accepts g(ky,kx,z,tube) subroutine get_dgdy_3d ( g , dgdy ) use constants , only : zi use zgrid , only : nzgrid , ntubes use kt_grids , only : nakx , aky implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( out ) :: dgdy integer :: it , iz , ikx do it = 1 , ntubes do iz = - nzgrid , nzgrid do ikx = 1 , nakx dgdy (:, ikx , iz , it ) = zi * aky (:) * g (:, ikx , iz , it ) end do end do end do end subroutine get_dgdy_3d !> compute dg/dy in k-space !> accepts g(ky,kx,z,tube,(vpa,mu,spec)) subroutine get_dgdy_4d ( g , dgdy ) use constants , only : zi use stella_layouts , only : vmu_lo use zgrid , only : nzgrid , ntubes use kt_grids , only : nakx , aky implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( out ) :: dgdy integer :: ivmu , ikx , iz , it do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid do ikx = 1 , nakx dgdy (:, ikx , iz , it , ivmu ) = zi * aky (:) * g (:, ikx , iz , it , ivmu ) end do end do end do end do end subroutine get_dgdy_4d !> compute dg/dx in k-space !> accepts g(ky,kx) subroutine get_dgdx_2d ( g , dgdx ) use constants , only : zi use kt_grids , only : naky , akx implicit none complex , dimension (:, :), intent ( in ) :: g complex , dimension (:, :), intent ( out ) :: dgdx dgdx = zi * spread ( akx , 1 , naky ) * g end subroutine get_dgdx_2d !> compute dg/dx in k-space !> accepts g(ky,kx,z,tube) subroutine get_dgdx_3d ( g , dgdx ) use constants , only : zi use zgrid , only : nzgrid , ntubes use kt_grids , only : naky , akx , nakx implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( out ) :: dgdx integer :: ikx , iz , it do it = 1 , ntubes do iz = - nzgrid , nzgrid do ikx = 1 , nakx dgdx (:, ikx , iz , it ) = zi * akx ( ikx ) * g (:, ikx , iz , it ) end do end do end do end subroutine get_dgdx_3d !> compute dg/dx in k-space !> accepts g(ky,kx,z,tube,(vpa,mu,spec)) subroutine get_dgdx_4d ( g , dgdx ) use constants , only : zi use stella_layouts , only : vmu_lo use zgrid , only : nzgrid , ntubes use kt_grids , only : naky , akx , nakx implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( out ) :: dgdx integer :: ivmu , ikx , iz , it do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid do ikx = 1 , nakx dgdx (:, ikx , iz , it , ivmu ) = zi * akx ( ikx ) * g (:, ikx , iz , it , ivmu ) end do end do end do end do end subroutine get_dgdx_4d subroutine add_explicit_term ( g , pre_factor , src ) use stella_layouts , only : vmu_lo use zgrid , only : nzgrid , ntubes use kt_grids , only : naky , nakx implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g real , dimension ( - nzgrid :, vmu_lo % llim_proc :), intent ( in ) :: pre_factor complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: src integer :: ivmu integer :: iky , ikx , iz , it do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid do ikx = 1 , nakx do iky = 1 , naky src ( iky , ikx , iz , it , ivmu ) = src ( iky , ikx , iz , it , ivmu ) + pre_factor ( iz , ivmu ) * g ( iky , ikx , iz , it , ivmu ) end do end do end do end do end do end subroutine add_explicit_term !> add vM . grad y d<phi>/dy or vM . grad x d<phi>/dx (or equivalents with g) or omega_* * d<phi>/dy term to RHS of GK equation subroutine add_explicit_term_ffs ( g , pre_factor , src ) use stella_layouts , only : vmu_lo use zgrid , only : nzgrid , ntubes use kt_grids , only : ikx_max , nalpha implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g real , dimension (:, - nzgrid :, vmu_lo % llim_proc :), intent ( in ) :: pre_factor complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: src integer :: ivmu integer :: ia , ikx , iz , it do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid do ikx = 1 , ikx_max do ia = 1 , nalpha src ( ia , ikx , iz , it , ivmu ) = src ( ia , ikx , iz , it , ivmu ) + pre_factor ( ia , iz , ivmu ) * g ( ia , ikx , iz , it , ivmu ) end do end do end do end do end do end subroutine add_explicit_term_ffs ! subroutine add_wstar_term (g, src) !   use dist_fn_arrays, only: wstar !   use stella_layouts, only: vmu_lo !   use zgrid, only: nzgrid, ntubes !   use kt_grids, only: naky, nakx !   implicit none !   complex, dimension (:,:,-nzgrid:,:,vmu_lo%llim_proc:), intent (in) :: g !   complex, dimension (:,:,-nzgrid:,:,vmu_lo%llim_proc:), intent (in out) :: src ! complex, dimension (:,:,-nzgrid:,:,vmu_lo%llim_proc:), intent (in) :: g ! complex, dimension (:,:,-nzgrid:,:,vmu_lo%llim_proc:), intent (in out) :: src ! integer :: ivmu, it, iz, ikx ! do ivmu = vmu_lo%llim_proc, vmu_lo%ulim_proc !   do it = 1, ntubes !     do iz = -nzgrid, nzgrid !       do ikx = 1, nakx !         src(:,ikx,iz,it,ivmu) = src(:,ikx,iz,it,ivmu) + wstar(1,iz,ivmu)*g(:,ikx,iz,it,ivmu) !       enddo !     enddo !   enddo ! enddo ! end subroutine add_wstar_term ! subroutine add_wstar_term_ffs (g, src) !   use dist_fn_arrays, only: wstar !   use stella_layouts, only: vmu_lo !   use zgrid, only: nzgrid, ntubes !   use kt_grids, only: naky, ikx_max !   implicit none !   complex, dimension (:,:,-nzgrid:,:,vmu_lo%llim_proc:), intent (in) :: g !   complex, dimension (:,:,-nzgrid:,:,vmu_lo%llim_proc:), intent (in out) :: src ! integer :: ivmu, it, iz, ikx ! do ivmu = vmu_lo%llim_proc, vmu_lo%ulim_proc !   do it = 1, ntubes !     do iz = -nzgrid, nzgrid !       do ikx = 1, nakx !         src(:,ikx,iz,it,ivmu) = src(:,ikx,iz,it,ivmu) + wstar(:,iz,ivmu)*g(:,ikx,iz,it,ivmu) !       enddo !     enddo !   enddo ! enddo ! end subroutine add_wstar_term_ffs subroutine advance_implicit ( istep , phi , apar , g ) !  subroutine advance_implicit (phi, apar, g) use mp , only : proc0 use job_manage , only : time_message use stella_layouts , only : vmu_lo use zgrid , only : nzgrid use dissipation , only : hyper_dissipation , advance_hyper_dissipation use physics_flags , only : include_parallel_streaming use physics_flags , only : radial_variation , full_flux_surface use physics_flags , only : include_mirror , prp_shear_enabled use run_parameters , only : stream_implicit , mirror_implicit , drifts_implicit use parallel_streaming , only : advance_parallel_streaming_implicit use fields , only : advance_fields , fields_updated use mirror_terms , only : advance_mirror_implicit use dissipation , only : collisions_implicit , include_collisions use dissipation , only : advance_collisions_implicit use run_parameters , only : driftkinetic_implicit use flow_shear , only : advance_perp_flow_shear use multibox , only : RK_step implicit none integer , intent ( in ) :: istep complex , dimension (:, :, - nzgrid :, :), intent ( in out ) :: phi , apar complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: g !    complex, dimension (:,:,-nzgrid:,:,vmu_lo%llim_proc:), intent (in out), target :: g !    complex, dimension (:,:,:,:,:), pointer :: gk, gy !    complex, dimension (:,:,:,:,:), allocatable, target :: g_dual !    ! the 'g' that enters this subroutine may be in alpha-space or kalpha-space !    ! figure out which it is !    if (size(g,1) == naky) then !       alpha_space = .false. !       gk => g !       if (full_flux_surface) then !          allocate (g_dual(nalpha,nakx,-nzgrid:nzgrid,vmu_lo%llim_proc:vmu_lo%ulim_alloc)) !          gy => g_dual !       end if !    else !       alpha_space = .true. !       allocate (g_dual(naky,nakx,-nzgrid:nzgrid,vmu_lo%llim_proc:vmu_lo%ulim_alloc)) !       gy => g !       gk => g_dual !    end if ! start the timer for the implicit part of the solve if ( proc0 ) call time_message (. false ., time_gke (:, 9 ), ' implicit' ) ! reverse the order of operations every time step ! as part of alternating direction operator splitting ! this is needed to ensure 2nd order accuracy in time !    if (mod(istep,2)==0) then ! g&#94;{*} (coming from explicit solve) is input ! get g&#94;{**}, with g&#94;{**}-g&#94;{*} due to mirror term if ( RK_step ) call mb_communicate ( g ) if ( mod ( istep , 2 ) == 1 . or . . not . flip_flop ) then if ( prp_shear_enabled ) then call advance_perp_flow_shear ( g ) fields_updated = . false . end if if ( hyper_dissipation ) then !          ! for hyper-dissipation, need to be in k-alpha space !          if (alpha_space) call transform_y2ky (gy, gk) call advance_hyper_dissipation ( g ) fields_updated = . false . end if if ( collisions_implicit . and . include_collisions ) then call advance_fields ( g , phi , apar , dist = 'gbar' ) call advance_collisions_implicit ( mirror_implicit , phi , apar , g ) fields_updated = . false . end if if ( mirror_implicit . and . include_mirror ) then !          if (full_flux_surface) then !             allocate (gy(ny,nakx,-nzgrid:nzgrid,ntubes,vmu_lo%llim_proc:vmu_lo%ulim_alloc)) !             if (.not.alpha_space) call transform_ky2y (g, gy) !          else !             g_mirror => g !          end if call advance_mirror_implicit ( collisions_implicit , g ) fields_updated = . false . end if ! get updated fields corresponding to advanced g ! note that hyper-dissipation and mirror advances ! depended only on g and so did not need field update call advance_fields ( g , phi , apar , dist = 'gbar' ) ! g&#94;{**} is input ! get g&#94;{***}, with g&#94;{***}-g&#94;{**} due to parallel streaming term if (( stream_implicit . or . driftkinetic_implicit ) . and . include_parallel_streaming ) then call advance_parallel_streaming_implicit ( g , phi , apar ) if ( radial_variation . or . full_flux_surface ) fields_updated = . false . end if call advance_fields ( g , phi , apar , dist = 'gbar' ) if ( drifts_implicit ) call advance_drifts_implicit ( g , phi , apar ) else ! get updated fields corresponding to advanced g ! note that hyper-dissipation and mirror advances ! depended only on g and so did not need field update call advance_fields ( g , phi , apar , dist = 'gbar' ) if ( drifts_implicit ) call advance_drifts_implicit ( g , phi , apar ) ! g&#94;{**} is input ! get g&#94;{***}, with g&#94;{***}-g&#94;{**} due to parallel streaming term if (( stream_implicit . or . driftkinetic_implicit ) . and . include_parallel_streaming ) then call advance_parallel_streaming_implicit ( g , phi , apar ) if ( radial_variation . or . full_flux_surface ) fields_updated = . false . end if if ( mirror_implicit . and . include_mirror ) then call advance_mirror_implicit ( collisions_implicit , g ) fields_updated = . false . end if if ( collisions_implicit . and . include_collisions ) then call advance_fields ( g , phi , apar , dist = 'gbar' ) call advance_collisions_implicit ( mirror_implicit , phi , apar , g ) fields_updated = . false . end if if ( hyper_dissipation ) then call advance_hyper_dissipation ( g ) fields_updated = . false . end if if ( prp_shear_enabled ) then call advance_perp_flow_shear ( g ) fields_updated = . false . end if end if ! stop the timer for the implict part of the solve if ( proc0 ) call time_message (. false ., time_gke (:, 9 ), ' implicit' ) end subroutine advance_implicit subroutine advance_drifts_implicit ( g , phi , apar ) use constants , only : zi use stella_layouts , only : vmu_lo use stella_geometry , only : dl_over_b use run_parameters , only : fphi , fapar , time_upwind use dist_fn_arrays , only : g1 use dist_fn_arrays , only : wdriftx_phi , wdrifty_phi use dist_fn_arrays , only : wdriftx_g , wdrifty_g use dist_fn_arrays , only : wstar use physics_flags , only : adiabatic_option_switch use physics_flags , only : adiabatic_option_fieldlineavg use gyro_averages , only : aj0x , gyro_average use kt_grids , only : akx , aky , nakx , naky , zonal_mode use zgrid , only : nzgrid , ntubes use species , only : spec , has_electron_species use fields , only : advance_fields use vpamu_grids , only : integrate_species implicit none integer :: ivmu , iz , it , ia , ikx complex :: tmp complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( in out ) :: phi , apar complex , dimension (:, :), allocatable :: wd_g , wd_phi , wstr complex , dimension (:, :, :), allocatable :: gyro_g ia = 1 allocate ( wd_g ( naky , nakx )) allocate ( wd_phi ( naky , nakx )) allocate ( wstr ( naky , nakx )) ! given g&#94;{*}, obtain phi&#94;{*} and apar&#94;{*} call advance_fields ( g , phi , apar , dist = 'gbar' ) ! solve for g&#94;inh do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid wd_g = - zi * ( spread ( akx , 1 , naky ) * wdriftx_g ( ia , iz , ivmu ) & + spread ( aky , 2 , nakx ) * wdrifty_g ( ia , iz , ivmu )) wd_phi = - zi * ( spread ( akx , 1 , naky ) * wdriftx_phi ( ia , iz , ivmu ) & + spread ( aky , 2 , nakx ) * wdrifty_phi ( ia , iz , ivmu )) wstr = - zi * spread ( aky , 2 , nakx ) * wstar ( ia , iz , ivmu ) g1 (:, :, iz , it , ivmu ) = ( g (:, :, iz , it , ivmu ) * ( 1.0 - 0.5 * ( 1.0 - time_upwind ) * wd_g ) & - 0.5 * ( 1.0 - time_upwind ) * ( wd_phi + wstr ) & * aj0x (:, :, iz , ivmu ) * fphi * phi (:, :, iz , ia )) & / ( 1.0 + 0.5 * ( 1.0 + time_upwind ) * wd_g ) end do end do end do !we have g_inh, now get phi if ( fphi > epsilon ( 0.0 )) then allocate ( gyro_g ( naky , nakx , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) do it = 1 , ntubes do iz = - nzgrid , nzgrid do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc call gyro_average ( g1 (:, :, iz , it , ivmu ), iz , ivmu , gyro_g (:, :, ivmu )) end do call integrate_species ( gyro_g , iz , spec % z * spec % dens_psi0 , phi (:, :, iz , it )) end do phi (:, :, :, it ) = phi (:, :, :, it ) / gamtot_drifts if ( any ( real ( gamtot_drifts ( 1 , 1 , :)) < epsilon ( 0. ))) phi ( 1 , 1 , :, it ) = 0.0 if (. not . has_electron_species ( spec )) then ! no need to do anything extra for ky /= 0 because ! already accounted for in gamtot_h if ( adiabatic_option_switch == adiabatic_option_fieldlineavg ) then if ( zonal_mode ( 1 )) then do ikx = 1 , nakx tmp = sum ( dl_over_b ( ia , :) * phi ( 1 , ikx , :, it )) phi ( 1 , ikx , :, it ) = phi ( 1 , ikx , :, it ) + tmp * gamtot3_drifts ( ikx , :) end do end if end if end if end do deallocate ( gyro_g ) end if !finally, get g do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid !these terms already contain a factor of code_dt and a ! negative sign wd_g = - zi * ( spread ( akx , 1 , naky ) * wdriftx_g ( ia , iz , ivmu ) & + spread ( aky , 2 , nakx ) * wdrifty_g ( ia , iz , ivmu )) wd_phi = - zi * ( spread ( akx , 1 , naky ) * wdriftx_phi ( ia , iz , ivmu ) & + spread ( aky , 2 , nakx ) * wdrifty_phi ( ia , iz , ivmu )) wstr = - zi * spread ( aky , 2 , nakx ) * wstar ( ia , iz , ivmu ) g (:, :, iz , it , ivmu ) = g1 (:, :, iz , it , ivmu ) & - 0.5 * ( 1.0 + time_upwind ) * ( wd_phi + wstr ) & * aj0x (:, :, iz , ivmu ) * fphi * phi (:, :, iz , it ) & / ( 1.0 + 0.5 * ( 1.0 + time_upwind ) * wd_g ) end do end do end do deallocate ( wd_g , wd_phi , wstr ) end subroutine advance_drifts_implicit subroutine mb_communicate ( g_in ) use mp , only : job use stella_layouts , only : vmu_lo use zgrid , only : nzgrid use multibox , only : multibox_communicate , use_dirichlet_bc , apply_radial_boundary_conditions use fields , only : fields_updated , advance_fields use fields_arrays , only : phi , apar use file_utils , only : runtype_option_switch , runtype_multibox implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: g_in if ( runtype_option_switch == runtype_multibox ) then if ( job /= 1 ) then call advance_fields ( g_in , phi , apar , dist = 'gbar' ) end if call multibox_communicate ( g_in ) if ( job == 1 ) then fields_updated = . false . call advance_fields ( g_in , phi , apar , dist = 'gbar' ) end if else if ( use_dirichlet_BC ) then call apply_radial_boundary_conditions ( g_in ) fields_updated = . false . call advance_fields ( g_in , phi , apar , dist = 'gbar' ) end if end subroutine mb_communicate subroutine checksum_field ( field , total ) use zgrid , only : nzgrid , ntubes use kt_grids , only : naky use extended_zgrid , only : neigen , nsegments , ikxmod use extended_zgrid , only : iz_low , iz_up implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: field real , intent ( out ) :: total integer :: it , iky , ie , iseg integer :: ikx total = 0. do iky = 1 , naky do it = 1 , ntubes do ie = 1 , neigen ( iky ) iseg = 1 ikx = ikxmod ( iseg , ie , iky ) total = total + sum ( cabs ( field ( iky , ikx , iz_low ( iseg ): iz_up ( iseg ), it ))) if ( nsegments ( ie , iky ) > 1 ) then do iseg = 2 , nsegments ( ie , iky ) ikx = ikxmod ( iseg , ie , iky ) total = total + sum ( cabs ( field ( iky , ikx , iz_low ( iseg ) + 1 : iz_up ( iseg ), it ))) end do end if end do end do end do end subroutine checksum_field subroutine checksum_dist ( dist , total , norm ) use mp , only : sum_allreduce use zgrid , only : nzgrid , ntubes use stella_layouts , only : vmu_lo , iv_idx , imu_idx , is_idx use kt_grids , only : naky , nakx use vpamu_grids , only : maxwell_vpa , maxwell_mu implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: dist real , intent ( out ) :: total logical , intent ( in ), optional :: norm integer :: ivmu , iv , imu , is integer :: iky , ikx , it real :: subtotal complex , dimension (:, :, :, :), allocatable :: dist_single total = 0. allocate ( dist_single ( naky , nakx , - nzgrid : nzgrid , ntubes )) do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc dist_single = dist (:, :, :, :, ivmu ) if ( present ( norm )) then if ( norm ) then iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) do it = 1 , ntubes do ikx = 1 , nakx do iky = 1 , naky dist_single ( iky , ikx , :, it ) = dist_single ( iky , ikx , :, it ) * maxwell_vpa ( iv , is ) * maxwell_mu ( 1 , :, imu , is ) end do end do end do else end if end if call checksum ( dist_single , subtotal ) total = total + subtotal end do deallocate ( dist_single ) call sum_allreduce ( total ) end subroutine checksum_dist subroutine finish_time_advance use stella_transforms , only : finish_transforms use physics_flags , only : full_flux_surface use extended_zgrid , only : finish_extended_zgrid use parallel_streaming , only : finish_parallel_streaming use mirror_terms , only : finish_mirror use flow_shear , only : finish_flow_shear use neoclassical_terms , only : finish_neoclassical_terms use dissipation , only : finish_dissipation implicit none if ( full_flux_surface ) call finish_transforms call finish_dissipation call finish_parallel_nonlinearity call finish_wstar call finish_wdrift call finish_drifts_implicit call finish_parallel_streaming call finish_flow_shear call finish_mirror call finish_neoclassical_terms call deallocate_arrays time_advance_initialized = . false . readinit = . false . end subroutine finish_time_advance subroutine finish_parallel_nonlinearity implicit none if ( allocated ( par_nl_fac )) deallocate ( par_nl_fac ) if ( allocated ( par_nl_curv )) deallocate ( par_nl_curv ) if ( allocated ( par_nl_driftx )) deallocate ( par_nl_driftx ) if ( allocated ( par_nl_drifty )) deallocate ( par_nl_drifty ) parnlinit = . false . end subroutine finish_parallel_nonlinearity subroutine finish_wdrift use dist_fn_arrays , only : wdriftx_g , wdrifty_g use dist_fn_arrays , only : wdriftx_phi , wdrifty_phi use dist_fn_arrays , only : wdriftpx_g , wdriftpy_g use dist_fn_arrays , only : wdriftpx_phi , wdriftpy_phi !   use dist_fn_arrays, only: adiabatic_phi implicit none if ( allocated ( wdriftx_g )) deallocate ( wdriftx_g ) if ( allocated ( wdrifty_g )) deallocate ( wdrifty_g ) if ( allocated ( wdriftx_phi )) deallocate ( wdriftx_phi ) if ( allocated ( wdrifty_phi )) deallocate ( wdrifty_phi ) if ( allocated ( wdriftpx_g )) deallocate ( wdriftpx_g ) if ( allocated ( wdriftpy_g )) deallocate ( wdriftpy_g ) if ( allocated ( wdriftpx_phi )) deallocate ( wdriftpx_phi ) if ( allocated ( wdriftpy_phi )) deallocate ( wdriftpy_phi ) !   if (allocated(adiabatic_phi)) deallocate (adiabatic_phi) wdriftinit = . false . end subroutine finish_wdrift subroutine finish_wstar use dist_fn_arrays , only : wstar , wstarp implicit none if ( allocated ( wstar )) deallocate ( wstar ) if ( allocated ( wstarp )) deallocate ( wstarp ) wstarinit = . false . end subroutine finish_wstar subroutine finish_drifts_implicit implicit none if ( allocated ( gamtot_drifts )) deallocate ( gamtot_drifts ) if ( allocated ( gamtot3_drifts )) deallocate ( gamtot3_drifts ) driftimpinit = . false . end subroutine finish_drifts_implicit subroutine deallocate_arrays use dist_fn_arrays , only : g0 , g1 , g2 , g3 implicit none if ( allocated ( g0 )) deallocate ( g0 ) if ( allocated ( g1 )) deallocate ( g1 ) if ( allocated ( g2 )) deallocate ( g2 ) if ( allocated ( g3 )) deallocate ( g3 ) end subroutine deallocate_arrays end module time_advance","tags":"","loc":"sourcefile/time_advance.f90.html"},{"title":"euterpe_interface.f90 â€“ stella","text":"Contents Modules euterpe_interface Source Code euterpe_interface.f90 Source Code module euterpe_interface implicit none contains subroutine read_species_euterpe ( nspec , spec ) use mp , only : mp_abort use finite_differences , only : fd3pt , d2_3pt use common_types , only : spec_type use splines , only : geo_spline use physics_parameters , only : vnew_ref , rhostar , tite , nine use stella_geometry , only : geo_surf , aref , bref implicit none integer , intent ( in ) :: nspec type ( spec_type ), dimension (:), intent ( in out ) :: spec integer , parameter :: electron_species = 2 integer :: euterpe_unit = 1099 , out_unit = 1098 integer :: nradii_euterpe integer :: is , irad character ( 1000 ) :: euterpe_infile real :: mref , tref , nref , local_loglam , vtref , omega_ref , rho_ref real :: vnew_ref_euterpe , rhostar_euterpe real , dimension (:), allocatable :: dr , rhotor , psitor real , dimension (:), allocatable :: ni , Ti real , dimension (:), allocatable :: ne , Te real , dimension (:), allocatable :: dlnneds , dlnTeds real , dimension (:), allocatable :: dlnnids , dlnTids real , dimension (:), allocatable :: neprim , Teprim real , dimension (:), allocatable :: nedbprim , Tedbprim real , dimension (:), allocatable :: niprim , Tiprim real , dimension (:), allocatable :: nidbprim , Tidbprim real , dimension (:), allocatable :: loglam call read_euterpe_parameters ( nradii_euterpe , euterpe_infile ) open ( unit = euterpe_unit , file = trim ( euterpe_infile ), status = 'old' , action = 'read' ) allocate ( dr ( nradii_euterpe )) allocate ( psitor ( nradii_euterpe )) allocate ( rhotor ( nradii_euterpe )) allocate ( Ti ( nradii_euterpe )) allocate ( ni ( nradii_euterpe )) allocate ( Te ( nradii_euterpe )) allocate ( ne ( nradii_euterpe )) allocate ( dlnTids ( nradii_euterpe )) allocate ( dlnTeds ( nradii_euterpe )) allocate ( dlnnids ( nradii_euterpe )) allocate ( dlnneds ( nradii_euterpe )) allocate ( neprim ( nradii_euterpe )) allocate ( nedbprim ( nradii_euterpe )) allocate ( niprim ( nradii_euterpe )) allocate ( nidbprim ( nradii_euterpe )) allocate ( Teprim ( nradii_euterpe )) allocate ( Tedbprim ( nradii_euterpe )) allocate ( Tiprim ( nradii_euterpe )) allocate ( Tidbprim ( nradii_euterpe )) allocate ( loglam ( nradii_euterpe )) ! column 1 is s=psitor/psitor_LCFS, 2 is dlog(Ti)/ds, 3 is Ti in eV, 4 is dlog(Te)/ds, 5 is Te in eV ! 6 is dlog(ni)/ds, 7 is ni in 1/m&#94;3, 8 is dlog(ne)/ds, 9 is ne in 1/m&#94;3 do irad = 1 , nradii_euterpe read ( euterpe_unit , * ) psitor ( irad ), dlnTids ( irad ), Ti ( irad ), dlnTeds ( irad ), & Te ( irad ), dlnnids ( irad ), ni ( irad ), dlnneds ( irad ), ne ( irad ) end do close ( euterpe_unit ) rhotor = sqrt ( psitor ) dr = rhotor ( 2 :) - rhotor (: nradii_euterpe - 1 ) ! obtain -d ln(ne) / drho call fd3pt ( ne , neprim , dr ) call d2_3pt ( ne , nedbprim , dr ) neprim = - neprim / ne nedbprim = nedbprim / ne ! obtain -d ln(Te) / drho call fd3pt ( Te , Teprim , dr ) call d2_3pt ( Te , Tedbprim , dr ) Teprim = - Teprim / Te Tedbprim = Tedbprim / Te ! obtain -d ln(ni) / drho call fd3pt ( ni , niprim , dr ) call d2_3pt ( ni , nidbprim , dr ) niprim = - niprim / ni nidbprim = nidbprim / ni ! obtain -d ln(Ti) / drho call fd3pt ( Ti , Tiprim , dr ) call d2_3pt ( Ti , Tidbprim , dr ) Tiprim = - Tiprim / Ti Tidbprim = Tidbprim / Ti ! next need to pick out the correct flux surface ! and assign various local% values ! choose first species as reference species is = 1 spec ( is )% dens = 1.0 spec ( is )% temp = 1.0 ! get reference density and temperature at local surface if ( spec ( is )% type == electron_species ) then call geo_spline ( rhotor , Te , geo_surf % rhotor , tref ) call geo_spline ( rhotor , ne , geo_surf % rhotor , nref ) else call geo_spline ( rhotor , Ti , geo_surf % rhotor , tref ) call geo_spline ( rhotor , ni , geo_surf % rhotor , nref ) end if ! next get the normalized density and temperature for all other species if ( nspec == 2 ) then do is = 2 , nspec if ( spec ( is )% type == electron_species ) then call geo_spline ( rhotor , Te / tref , geo_surf % rhotor , spec ( is )% temp ) call geo_spline ( rhotor , ne / nref , geo_surf % rhotor , spec ( is )% dens ) else call geo_spline ( rhotor , Ti / tref , geo_surf % rhotor , spec ( is )% temp ) call geo_spline ( rhotor , ni / tref , geo_surf % rhotor , spec ( is )% dens ) end if end do else if ( nspec > 2 ) then call mp_abort ( 'multiple ion species not currently supported for euterpe option. aborting.' ) end if ! assume mass in stella input file given in units of proton mass mref = spec ( 1 )% mass ! convert from eV to keV tref = tref * 0.001 ! convert from 1/m&#94;3 to 10&#94;19/m&#94;3 nref = nref * 1.e-19 ! now get the density and temperature gradients at the requested flux surface do is = 1 , nspec if ( spec ( is )% type == electron_species ) then if ( spec ( is )% tprim < - 99 9.0 ) call geo_spline ( rhotor , Teprim , geo_surf % rhotor , spec ( is )% tprim ) call geo_spline ( rhotor , Tedbprim , geo_surf % rhotor , spec ( is )% d2Tdr2 ) if ( spec ( is )% fprim < - 99 9.0 ) call geo_spline ( rhotor , neprim , geo_surf % rhotor , spec ( is )% fprim ) call geo_spline ( rhotor , nedbprim , geo_surf % rhotor , spec ( is )% d2ndr2 ) else if ( spec ( is )% tprim < - 99 9.0 ) call geo_spline ( rhotor , Tiprim , geo_surf % rhotor , spec ( is )% tprim ) call geo_spline ( rhotor , Tidbprim , geo_surf % rhotor , spec ( is )% d2Tdr2 ) if ( spec ( is )% fprim < - 99 9.0 ) call geo_spline ( rhotor , niprim , geo_surf % rhotor , spec ( is )% fprim ) call geo_spline ( rhotor , nidbprim , geo_surf % rhotor , spec ( is )% d2ndr2 ) end if end do ! get quantities needed for runs with Boltzmann electrons call geo_spline ( rhotor , Ti / Te , geo_surf % rhotor , tite ) call geo_spline ( rhotor , ni / ne , geo_surf % rhotor , nine ) ! get collisionalities for stella loglam = 2 4.0 - log ( 1e4 * sqrt ( 1.e-20 * ne ) / ( te * 0.001 )) call geo_spline ( rhotor , loglam , geo_surf % rhotor , local_loglam ) ! vtref = sqrt(2*Tref/mref), with Tref and mref in SI units ! so vtref has dimensions of meters / second ! note that tref below is T in units of keV and mref is in units of proton mass vtref = 3.09497e5 * sqrt ( 2. * tref / mref ) ! reference collision frequency for stella ! uses the mass, density and temperature of the reference species, ! along with the proton charge in the expression ! vnew_ref = (aref/vtref)*(4/3)sqrt(2pi)/(4pi*epsilon_0)**2 * nref * e**4 * loglam / sqrt(mref) / Tref**1.5 ! note that all quantities are given in SI units and epsilon_0 is permittivity of vacuum vnew_ref_euterpe = 2 8.5134 * ( aref / vtref ) * local_loglam * nref / ( sqrt ( mref ) * tref ** 1.5 ) omega_ref = 9.5791e7 * bref / mref rho_ref = vtref / omega_ref rhostar_euterpe = rho_ref / aref if ( rhostar < 0.0 ) rhostar = rhostar_euterpe if ( vnew_ref < 0.0 ) vnew_ref = vnew_ref_euterpe open ( unit = out_unit , file = 'euterpe.input' , status = 'replace' , action = 'write' ) write ( out_unit , * ) 'aref: ' , aref , 'mref: ' , mref , 'nref: ' , nref , 'tref: ' , tref write ( out_unit , * ) 'loglam: ' , local_loglam , 'vnew_ref_euterpe: ' , vnew_ref_euterpe , 'vnew_ref: ' , vnew_ref write ( out_unit , * ) 'omega_ref: ' , omega_ref , 'rho_ref: ' , rho_ref write ( out_unit , * ) 'rhostar_euterpe: ' , rhostar_euterpe , 'rhostar: ' , rhostar write ( out_unit , * ) 'nine: ' , nine , 'tite: ' , tite , 'fprim: ' , spec ( 1 )% fprim , 'tprim: ' , spec ( 1 )% tprim write ( out_unit , * ) 'd2ndr2: ' , spec ( 1 )% d2ndr2 , 'd2Tdr2: ' , spec ( 1 )% d2Tdr2 close ( out_unit ) deallocate ( dr , rhotor , psitor ) deallocate ( ni , ne , Ti , Te ) deallocate ( dlnTids , dlnTeds , dlnnids , dlnneds ) deallocate ( niprim , neprim , nidbprim , nedbprim ) deallocate ( Tiprim , Teprim , Tidbprim , Tedbprim ) deallocate ( loglam ) end subroutine read_species_euterpe subroutine read_euterpe_parameters ( nradii_out , data_file_out ) use file_utils , only : input_unit_exist implicit none integer :: in_file logical :: exist integer , intent ( out ) :: nradii_out character ( * ), intent ( out ) :: data_file_out integer :: nradii character ( 1000 ) :: data_file namelist / euterpe_parameters / nradii , data_file nradii = 1000 data_file = 'euterpe.dat' in_file = input_unit_exist ( \"euterpe_parameters\" , exist ) if ( exist ) read ( unit = in_file , nml = euterpe_parameters ) nradii_out = nradii data_file_out = data_file end subroutine read_euterpe_parameters end module euterpe_interface","tags":"","loc":"sourcefile/euterpe_interface.f90.html"},{"title":"finite_differences.f90 â€“ stella","text":"Contents Modules finite_differences Source Code finite_differences.f90 Source Code module finite_differences implicit none public :: first_order_upwind public :: third_order_upwind public :: fifth_order_upwind public :: third_order_upwind_zed public :: first_order_upwind_zed public :: second_order_centered public :: fourth_order_centered public :: second_order_centered_zed public :: four_point_triangle public :: fd3pt , fd5pt public :: d2_3pt public :: fd_variable_upwinding_vpa public :: fd_variable_upwinding_zed public :: fd_cell_centres_zed , cell_centres_zed interface fd3pt module procedure fd3pt_real module procedure fd3pt_real_array module procedure fd3pt_complex_array end interface interface fd5pt module procedure fd5pt_real module procedure fd5pt_array end interface interface first_order_upwind module procedure first_order_upwind_real module procedure first_order_upwind_complex end interface interface third_order_upwind module procedure third_order_upwind_complex module procedure third_order_upwind_real end interface interface fifth_order_upwind module procedure fifth_order_upwind_complex module procedure fifth_order_upwind_real end interface interface tridag module procedure tridag_real module procedure tridag_complex end interface interface second_order_centered module procedure second_order_centered_real module procedure second_order_centered_complex end interface interface four_point_triangle module procedure four_point_triangle_real module procedure four_point_triangle_complex end interface interface fourth_order_centered module procedure fourth_order_centered_real module procedure fourth_order_centered_complex end interface interface second_order_centered_zed module procedure second_order_centered_zed_real module procedure second_order_centered_zed_complex end interface interface d2_3pt module procedure d2_3pt_real module procedure d2_3pt_complex end interface contains subroutine first_order_upwind_real ( llim , f , del , sgn , df ) implicit none integer , intent ( in ) :: llim real , dimension ( llim :), intent ( in ) :: f real , intent ( in ) :: del integer , intent ( in ) :: sgn real , dimension ( llim :), intent ( out ) :: df integer :: i , n , istart , iend n = size ( f ) if ( sgn == - 1 ) then istart = llim iend = llim + n - 1 else istart = llim + n - 1 iend = llim end if ! zero BC, 1st order accurate upwind df ( istart ) = - f ( istart ) * sgn / del do i = istart - sgn , iend , - sgn df ( i ) = sgn * ( f ( i + sgn ) - f ( i )) / del end do end subroutine first_order_upwind_real subroutine first_order_upwind_complex ( llim , f , del , sgn , df ) implicit none integer , intent ( in ) :: llim complex , dimension ( llim :), intent ( in ) :: f real , intent ( in ) :: del integer , intent ( in ) :: sgn complex , dimension ( llim :), intent ( out ) :: df integer :: i , n , istart , iend n = size ( f ) if ( sgn == - 1 ) then istart = llim iend = llim + n - 1 else istart = llim + n - 1 iend = llim end if ! zero BC, 1st order accurate upwind df ( istart ) = - f ( istart ) * sgn / del do i = istart - sgn , iend , - sgn df ( i ) = sgn * ( f ( i + sgn ) - f ( i )) / del end do end subroutine first_order_upwind_complex subroutine third_order_upwind_complex ( llim , f , del , sgn , df ) implicit none integer , intent ( in ) :: llim complex , dimension ( llim :), intent ( in ) :: f real , intent ( in ) :: del integer , intent ( in ) :: sgn complex , dimension ( llim :), intent ( out ) :: df integer :: i , n , istart , iend n = size ( f ) if ( sgn == - 1 ) then istart = llim iend = llim + n - 1 else istart = llim + n - 1 iend = llim end if i = istart - sgn ! zero BC, 1st order accurate upwind df ( istart ) = - f ( istart ) * sgn / del ! zero BC, 3rd order accurate upwind df ( i ) = - sgn * ( 2. * f ( i - sgn ) + 3. * f ( i ) - 6. * f ( i + sgn )) / ( 6. * del ) ! 1st order accurate upwind df ( iend ) = sgn * ( f ( iend + sgn ) - f ( iend )) / del ! 3rd order accurate upwind do i = istart - 2 * sgn , iend + sgn , - sgn df ( i ) = - sgn * ( 2. * f ( i - sgn ) + 3 * f ( i ) - 6. * f ( i + sgn ) + f ( i + 2 * sgn )) / ( 6. * del ) end do end subroutine third_order_upwind_complex subroutine third_order_upwind_real ( llim , f , del , sgn , df ) implicit none integer , intent ( in ) :: llim real , dimension ( llim :), intent ( in ) :: f real , intent ( in ) :: del integer , intent ( in ) :: sgn real , dimension ( llim :), intent ( out ) :: df integer :: i , n , istart , iend n = size ( f ) if ( sgn == - 1 ) then istart = llim iend = llim + n - 1 else istart = llim + n - 1 iend = llim end if i = istart - sgn ! zero BC, 1st order accurate upwind df ( istart ) = - f ( istart ) * sgn / del ! zero BC, 3rd order accurate upwind df ( i ) = - sgn * ( 2. * f ( i - sgn ) + 3. * f ( i ) - 6. * f ( i + sgn )) / ( 6. * del ) ! 1st order accurate upwind df ( iend ) = sgn * ( f ( iend + sgn ) - f ( iend )) / del ! 3rd order accurate upwind do i = istart - 2 * sgn , iend + sgn , - sgn df ( i ) = - sgn * ( 2. * f ( i - sgn ) + 3 * f ( i ) - 6. * f ( i + sgn ) + f ( i + 2 * sgn )) / ( 6. * del ) end do end subroutine third_order_upwind_real subroutine fifth_order_upwind_complex ( llim , f , del , sgn , df ) implicit none integer , intent ( in ) :: llim complex , dimension ( llim :), intent ( in ) :: f real , intent ( in ) :: del integer , intent ( in ) :: sgn complex , dimension ( llim :), intent ( out ) :: df integer :: i , n , istart , iend n = size ( f ) if ( sgn == - 1 ) then istart = llim iend = llim + n - 1 else istart = llim + n - 1 iend = llim end if ! zero BC, 1st order accurate upwind df ( istart ) = - f ( istart ) * sgn / del ! zero BC, 3rd order accurate upwind i = istart - sgn df ( i ) = - sgn * ( 2. * f ( i - sgn ) + 3. * f ( i ) - 6. * f ( i + sgn )) / ( 6. * del ) ! zero BC, 5th order accurate upwind i = istart - 2 * sgn df ( i ) = - sgn * ( - 3. * f ( i - 2 * sgn ) + 3 0. * f ( i - sgn ) + 2 0. * f ( i ) - 6 0. * f ( i + sgn ) + 1 5. * f ( i + 2 * sgn )) / ( 6 0. * del ) ! 1st order accurate upwind df ( iend ) = sgn * ( f ( iend + sgn ) - f ( iend )) / del ! 3rd order accurate upwind df ( iend + sgn ) = - sgn * ( 2. * f ( iend ) + 3 * f ( iend + sgn ) - 6. * f ( iend + 2 * sgn ) + f ( iend + 3 * sgn )) / ( 6. * del ) ! 5th order accurate upwind do i = istart - 3 * sgn , iend + 2 * sgn , - sgn df ( i ) = - sgn * ( - 3. * f ( i - 2 * sgn ) + 3 0. * f ( i - sgn ) + 2 0. * f ( i ) - 6 0. * f ( i + sgn ) + 1 5. * f ( i + 2 * sgn ) - 2. * f ( i + 3 * sgn )) & / ( 6 0. * del ) end do end subroutine fifth_order_upwind_complex subroutine fifth_order_upwind_real ( llim , f , del , sgn , df ) implicit none integer , intent ( in ) :: llim real , dimension ( llim :), intent ( in ) :: f real , intent ( in ) :: del integer , intent ( in ) :: sgn real , dimension ( llim :), intent ( out ) :: df integer :: i , n , istart , iend n = size ( f ) if ( sgn == - 1 ) then istart = llim iend = llim + n - 1 else istart = llim + n - 1 iend = llim end if ! zero BC, 1st order accurate upwind df ( istart ) = - f ( istart ) * sgn / del ! zero BC, 3rd order accurate upwind i = istart - sgn df ( i ) = - sgn * ( 2. * f ( i - sgn ) + 3. * f ( i ) - 6. * f ( i + sgn )) / ( 6. * del ) ! zero BC, 5th order accurate upwind i = istart - 2 * sgn df ( i ) = - sgn * ( - 3. * f ( i - 2 * sgn ) + 3 0. * f ( i - sgn ) + 2 0. * f ( i ) - 6 0. * f ( i + sgn ) + 1 5. * f ( i + 2 * sgn )) / ( 6 0. * del ) ! 1st order accurate upwind df ( iend ) = - sgn * ( f ( iend ) - f ( iend + sgn )) / del ! 3rd order accurate upwind df ( iend + sgn ) = - sgn * ( 2. * f ( iend ) + 3 * f ( iend + sgn ) - 6. * f ( iend + 2 * sgn ) + f ( iend + 3 * sgn )) / ( 6. * del ) ! 5th order accurate upwind do i = istart - 3 * sgn , iend + 2 * sgn , - sgn df ( i ) = - sgn * ( - 3. * f ( i - 2 * sgn ) + 3 0. * f ( i - sgn ) + 2 0. * f ( i ) - 6 0. * f ( i + sgn ) + 1 5. * f ( i + 2 * sgn ) - 2. * f ( i + 3 * sgn )) & / ( 6 0. * del ) end do end subroutine fifth_order_upwind_real subroutine third_order_upwind_zed ( llim , iseg , nseg , f , del , sgn , fl , fr , periodic , df ) implicit none integer , intent ( in ) :: llim , iseg , nseg complex , dimension ( llim :), intent ( in ) :: f real , intent ( in ) :: del integer , intent ( in ) :: sgn logical , intent ( in ) :: periodic complex , dimension (:), intent ( in ) :: fl , fr complex , dimension ( llim :), intent ( out ) :: df integer :: i , istart , iend , ulim ulim = size ( f ) + llim - 1 ! if sgn > 0, then stream speed is negative ! so sweep from more positive to more negative zed if ( sgn > 0 ) then if ( iseg == nseg . and . . not . periodic ) then i = ulim df ( i ) = - f ( i ) / del i = ulim - 1 df ( i ) = - ( 2. * f ( i - 1 ) + 3. * f ( i ) - 6. * f ( i + 1 )) / ( 6. * del ) else i = ulim df ( i ) = - ( 2. * f ( i - 1 ) + 3. * f ( i ) - 6. * fr ( 1 ) + fr ( 2 )) / ( 6. * del ) i = ulim - 1 df ( i ) = - ( 2. * f ( i - 1 ) + 3. * f ( i ) - 6. * f ( i + 1 ) + fr ( 1 )) / ( 6. * del ) end if if ( iseg == 1 . and . . not . periodic ) then i = llim df ( i ) = ( f ( i + 1 ) - f ( i )) / del else i = llim df ( i ) = - ( 2. * fl ( 2 ) + 3 * f ( i ) - 6. * f ( i + 1 ) + f ( i + 2 )) / ( 6. * del ) end if istart = ulim iend = llim else if ( iseg == 1 . and . . not . periodic ) then i = llim df ( i ) = f ( i ) / del i = llim + 1 df ( i ) = ( 2. * f ( i + 1 ) + 3. * f ( i ) - 6. * f ( i - 1 )) / ( 6. * del ) else i = llim df ( i ) = ( 2. * f ( i + 1 ) + 3 * f ( i ) - 6. * fl ( 2 ) + fl ( 1 )) / ( 6. * del ) i = llim + 1 df ( i ) = ( 2. * f ( i + 1 ) + 3 * f ( i ) - 6. * f ( i - 1 ) + fl ( 2 )) / ( 6. * del ) end if if ( iseg == nseg . and . . not . periodic ) then i = ulim df ( i ) = ( f ( i ) - f ( i - 1 )) / del else i = ulim df ( i ) = ( 2. * fr ( 1 ) + 3 * f ( i ) - 6. * f ( i - 1 ) + f ( i - 2 )) / ( 6. * del ) end if istart = llim iend = ulim end if ! 3rd order accurate upwind do i = istart - 2 * sgn , iend + sgn , - sgn df ( i ) = - sgn * ( 2. * f ( i - sgn ) + 3 * f ( i ) - 6. * f ( i + sgn ) + f ( i + 2 * sgn )) / ( 6. * del ) end do end subroutine third_order_upwind_zed subroutine first_order_upwind_zed ( llim , iseg , nseg , f , del , sgn , fl , fr , periodic , df ) implicit none integer , intent ( in ) :: llim , iseg , nseg complex , dimension ( llim :), intent ( in ) :: f real , intent ( in ) :: del integer , intent ( in ) :: sgn logical , intent ( in ) :: periodic complex , dimension (:), intent ( in ) :: fl , fr complex , dimension ( llim :), intent ( out ) :: df integer :: i , istart , iend , ulim ulim = size ( f ) + llim - 1 ! if sgn > 0, then stream speed is negative ! so sweep from more positive to more negative zed if ( sgn > 0 ) then if ( iseg == nseg . and . . not . periodic ) then i = ulim df ( i ) = - f ( i ) / del i = ulim - 1 df ( i ) = ( f ( i + 1 ) - f ( i )) / del else i = ulim df ( i ) = ( fr ( 1 ) - f ( i )) / del i = ulim - 1 df ( i ) = ( f ( i + 1 ) - f ( i )) / del end if i = llim df ( i ) = ( f ( i + 1 ) - f ( i )) / del istart = ulim iend = llim else if ( iseg == 1 . and . . not . periodic ) then i = llim df ( i ) = f ( i ) / del i = llim + 1 df ( i ) = ( f ( i ) - f ( i - 1 )) / del else i = llim df ( i ) = ( f ( i ) - fl ( 2 )) / del i = llim + 1 df ( i ) = ( f ( i ) - f ( i - 1 )) / del end if i = ulim df ( i ) = ( f ( i ) - f ( i - 1 )) / del istart = llim iend = ulim end if ! 3rd order accurate upwind do i = istart - 2 * sgn , iend + sgn , - sgn df ( i ) = sgn * ( f ( i + sgn ) - f ( i )) / del end do end subroutine first_order_upwind_zed subroutine second_order_centered_real ( llim , f , del , df ) implicit none integer , intent ( in ) :: llim real , dimension ( llim :), intent ( in ) :: f real , intent ( in ) :: del real , dimension ( llim :), intent ( out ) :: df integer :: i , n , istart , iend n = size ( f ) istart = llim iend = llim + n - 1 ! zero BC df ( istart ) = f ( istart + 1 ) / ( 2. * del ) df ( iend ) = - f ( iend - 1 ) / ( 2. * del ) ! 2nd order accurate centered do i = istart + 1 , iend - 1 df ( i ) = ( f ( i + 1 ) - f ( i - 1 )) / ( 2. * del ) end do end subroutine second_order_centered_real subroutine second_order_centered_complex ( llim , f , del , df ) implicit none integer , intent ( in ) :: llim complex , dimension ( llim :), intent ( in ) :: f real , intent ( in ) :: del complex , dimension ( llim :), intent ( out ) :: df integer :: i , n , istart , iend n = size ( f ) istart = llim iend = llim + n - 1 ! zero BC df ( istart ) = f ( istart + 1 ) / ( 2. * del ) df ( iend ) = - f ( iend - 1 ) / ( 2. * del ) ! 2nd order accurate centered do i = istart + 1 , iend - 1 df ( i ) = ( f ( i + 1 ) - f ( i - 1 )) / ( 2. * del ) end do end subroutine second_order_centered_complex subroutine four_point_triangle_real ( llim , f , del , df ) implicit none integer , intent ( in ) :: llim real , dimension ( llim :), intent ( in ) :: f real , intent ( in ) :: del real , dimension ( llim :), intent ( out ) :: df integer :: i , n , istart , iend n = size ( f ) istart = llim iend = llim + n - 1 ! zero BC i = istart df ( i ) = f ( i + 1 ) / ( 2.0 * del ) i = istart + 1 df ( i ) = ( f ( i + 1 ) - f ( i - 1 )) / ( 2.0 * del ) i = istart + 2 df ( i ) = ( - 2. * f ( i + 3 ) + 9. * f ( i + 1 ) - 9. * f ( i - 1 )) / ( 1 8.0 * del ) i = iend df ( i ) = - f ( i - 1 ) / ( 2.0 * del ) i = iend - 1 df ( i ) = ( f ( i + 1 ) - f ( i - 1 )) / ( 2.0 * del ) i = iend - 2 df ( i ) = ( 9. * f ( i + 1 ) - 9. * f ( i - 1 ) + 2. * f ( i - 3 )) / ( 1 8.0 * del ) ! 2nd order accurate centered do i = istart + 3 , iend - 3 df ( i ) = ( - 2. * f ( i + 3 ) + 9. * f ( i + 1 ) - 9. * f ( i - 1 ) + 2. * f ( i - 3 )) / ( 1 8.0 * del ) end do end subroutine four_point_triangle_real subroutine four_point_triangle_complex ( llim , f , del , df ) implicit none integer , intent ( in ) :: llim complex , dimension ( llim :), intent ( in ) :: f real , intent ( in ) :: del complex , dimension ( llim :), intent ( out ) :: df integer :: i , n , istart , iend n = size ( f ) istart = llim iend = llim + n - 1 ! zero BC i = istart df ( i ) = f ( i + 1 ) / ( 2.0 * del ) i = istart + 1 df ( i ) = ( f ( i + 1 ) - f ( i - 1 )) / ( 2.0 * del ) i = istart + 2 df ( i ) = ( - 2. * f ( i + 3 ) + 9. * f ( i + 1 ) - 9. * f ( i - 1 )) / ( 1 8.0 * del ) i = iend df ( i ) = - f ( i - 1 ) / ( 2.0 * del ) i = iend - 1 df ( i ) = ( f ( i + 1 ) - f ( i - 1 )) / ( 2.0 * del ) i = iend - 2 df ( i ) = ( 9. * f ( i + 1 ) - 9. * f ( i - 1 ) + 2. * f ( i - 3 )) / ( 1 8.0 * del ) ! 2nd order accurate centered do i = istart + 3 , iend - 3 df ( i ) = ( - 2. * f ( i + 3 ) + 9. * f ( i + 1 ) - 9. * f ( i - 1 ) + 2. * f ( i - 3 )) / ( 1 8.0 * del ) end do end subroutine four_point_triangle_complex subroutine fourth_order_centered_real ( llim , f , del , df ) implicit none integer , intent ( in ) :: llim real , dimension ( llim :), intent ( in ) :: f real , intent ( in ) :: del real , dimension ( llim :), intent ( out ) :: df integer :: i , n , istart , iend n = size ( f ) istart = llim iend = llim + n - 1 ! zero BC ! 2nd order accurate centered df ( istart ) = f ( istart + 1 ) / ( 2. * del ) df ( iend ) = - f ( iend - 1 ) / ( 2. * del ) ! 4th order accurate centered df ( istart + 1 ) = ( f ( istart + 3 ) - 8. * f ( istart + 2 ) + 8. * f ( istart )) / ( 1 2. * del ) df ( iend - 1 ) = ( - 8 * f ( iend ) + 8. * f ( iend - 2 ) - f ( iend - 3 )) / ( 1 2. * del ) ! 4th order accurate centered do i = istart + 2 , iend - 2 df ( i ) = ( f ( i + 2 ) - 8. * f ( i + 1 ) + 8. * f ( i - 1 ) - f ( i - 2 )) / ( 1 2. * del ) end do end subroutine fourth_order_centered_real subroutine fourth_order_centered_complex ( llim , f , del , df ) implicit none integer , intent ( in ) :: llim complex , dimension ( llim :), intent ( in ) :: f real , intent ( in ) :: del complex , dimension ( llim :), intent ( out ) :: df integer :: i , n , istart , iend n = size ( f ) istart = llim iend = llim + n - 1 ! zero BC ! 2nd order accurate centered df ( istart ) = f ( istart + 1 ) / ( 2. * del ) df ( iend ) = - f ( iend - 1 ) / ( 2. * del ) ! 4th order accurate centered df ( istart + 1 ) = ( f ( istart + 3 ) - 8. * f ( istart + 2 ) + 8. * f ( istart )) / ( 1 2. * del ) df ( iend - 1 ) = ( - 8 * f ( iend ) + 8. * f ( iend - 2 ) - f ( iend - 3 )) / ( 1 2. * del ) ! 4th order accurate centered do i = istart + 2 , iend - 2 df ( i ) = ( f ( i + 2 ) - 8. * f ( i + 1 ) + 8. * f ( i - 1 ) - f ( i - 2 )) / ( 1 2. * del ) end do end subroutine fourth_order_centered_complex subroutine second_order_centered_zed_real ( llim , iseg , nseg , f , del , sgn , fl , fr , periodic , df ) implicit none integer , intent ( in ) :: llim , iseg , nseg real , dimension ( llim :), intent ( in ) :: f integer , intent ( in ) :: sgn real , intent ( in ) :: del real , dimension (:), intent ( in ) :: fl , fr logical , intent ( in ) :: periodic real , dimension ( llim :), intent ( out ) :: df integer :: i , ulim ulim = size ( f ) + llim - 1 i = llim if ( iseg == 1 . and . sgn > 0 . and . . not . periodic ) then ! sgn > 0 corresponds to negative advection speed ! upwind at boundary requires taking information from right df ( i ) = ( f ( i + 1 ) - f ( i )) / del else df ( i ) = 0.5 * ( f ( i + 1 ) - fl ( 2 )) / del end if i = ulim if ( iseg == nseg . and . sgn < 0 . and . . not . periodic ) then ! sgn < 0 corresponds to positive advection speed ! upwind at boundary requires taking information from left df ( i ) = ( f ( i ) - f ( i - 1 )) / del else df ( i ) = 0.5 * ( fr ( 1 ) - f ( i - 1 )) / del end if do i = llim + 1 , ulim - 1 df ( i ) = 0.5 * ( f ( i + 1 ) - f ( i - 1 )) / del end do end subroutine second_order_centered_zed_real subroutine second_order_centered_zed_complex ( llim , iseg , nseg , f , del , sgn , fl , fr , periodic , df ) implicit none integer , intent ( in ) :: llim , iseg , nseg complex , dimension ( llim :), intent ( in ) :: f integer , intent ( in ) :: sgn real , intent ( in ) :: del complex , dimension (:), intent ( in ) :: fl , fr logical , intent ( in ) :: periodic complex , dimension ( llim :), intent ( out ) :: df integer :: i , ulim ulim = size ( f ) + llim - 1 i = llim if ( iseg == 1 . and . sgn > 0 . and . . not . periodic ) then ! sgn > 0 corresponds to negative advection speed ! upwind at boundary requires taking information from right df ( i ) = ( f ( i + 1 ) - f ( i )) / del else df ( i ) = 0.5 * ( f ( i + 1 ) - fl ( 2 )) / del end if i = ulim if ( iseg == nseg . and . sgn < 0 . and . . not . periodic ) then ! sgn < 0 corresponds to positive advection speed ! upwind at boundary requires taking information from left df ( i ) = ( f ( i ) - f ( i - 1 )) / del else df ( i ) = 0.5 * ( fr ( 1 ) - f ( i - 1 )) / del end if do i = llim + 1 , ulim - 1 df ( i ) = 0.5 * ( f ( i + 1 ) - f ( i - 1 )) / del end do end subroutine second_order_centered_zed_complex subroutine second_order_centered_vpa ( llim , f , del , df ) implicit none integer , intent ( in ) :: llim complex , dimension ( llim :), intent ( in ) :: f real , intent ( in ) :: del complex , dimension ( llim :), intent ( out ) :: df integer :: i , ulim ulim = size ( f ) + llim - 1 i = llim df ( i ) = 0.5 * f ( i + 1 ) / del i = ulim df ( i ) = - 0.5 * f ( i - 1 ) / del do i = llim + 1 , ulim - 1 df ( i ) = 0.5 * ( f ( i + 1 ) - f ( i - 1 )) / del end do end subroutine second_order_centered_vpa subroutine fd_cell_centres_zed ( llim , f , del , sgn , fl , fr , df ) implicit none integer , intent ( in ) :: llim complex , dimension ( llim :), intent ( in ) :: f real , intent ( in ) :: del integer , intent ( in ) :: sgn complex , intent ( in ) :: fl , fr complex , dimension ( llim :), intent ( out ) :: df integer :: i , ulim ulim = size ( f ) + llim - 1 if ( sgn > 0 ) then ! if sgn > 0, then stream speed is negative ! so sweep from more positive to more negative zed i = ulim df ( i ) = ( fr - f ( i )) / del do i = ulim - 1 , llim , - 1 df ( i ) = ( f ( i + 1 ) - f ( i )) / del end do else ! if sgn < 0, then stream speed is positive ! so sweep from more negative to more positive zed i = llim df ( i ) = ( f ( i ) - fl ) / del do i = llim + 1 , ulim df ( i ) = ( f ( i ) - f ( i - 1 )) / del end do end if end subroutine fd_cell_centres_zed ! cell_centres_zed takes f at z grid locations ! and returns f at cell centres ! (with possible offset due to upwinding) subroutine cell_centres_zed ( llim , f , upwnd , sgn , fl , fr , fc ) implicit none integer , intent ( in ) :: llim complex , dimension ( llim :), intent ( in ) :: f real , intent ( in ) :: upwnd integer , intent ( in ) :: sgn complex , intent ( in ) :: fl , fr complex , dimension ( llim :), intent ( out ) :: fc integer :: i , ulim ulim = size ( f ) + llim - 1 if ( sgn > 0 ) then ! if sgn > 0, then stream speed is negative ! so sweep from more positive to more negative zed i = ulim fc ( i ) = 0.5 * (( 1. - upwnd ) * fr + ( 1. + upwnd ) * f ( i )) do i = ulim - 1 , llim , - 1 fc ( i ) = 0.5 * (( 1. - upwnd ) * f ( i + 1 ) + ( 1. + upwnd ) * f ( i )) end do else ! if sgn < 0, then stream speed is positive ! so sweep from more negative to more positive zed i = llim fc ( i ) = 0.5 * (( 1. + upwnd ) * f ( i ) + ( 1. - upwnd ) * fl ) do i = llim + 1 , ulim fc ( i ) = 0.5 * (( 1. + upwnd ) * f ( i ) + ( 1. - upwnd ) * f ( i - 1 )) end do end if end subroutine cell_centres_zed subroutine fd_variable_upwinding_zed ( llim , iseg , nseg , f , del , sgn , upwnd , fl , fr , periodic , df ) implicit none integer , intent ( in ) :: llim , iseg , nseg complex , dimension ( llim :), intent ( in ) :: f real , intent ( in ) :: del , upwnd integer , intent ( in ) :: sgn complex , dimension (:), intent ( in ) :: fl , fr logical , intent ( in ) :: periodic complex , dimension ( llim :), intent ( out ) :: df integer :: i , istart , iend , ulim ! if upwnd is zero or if vpa=0, then use centered differences if ( abs ( upwnd ) < epsilon ( 0. ) . or . sgn == 0 ) then call second_order_centered_zed ( llim , iseg , nseg , f , del , sgn , fl , fr , periodic , df ) else ulim = size ( f ) + llim - 1 ! if sgn > 0, then stream speed is negative ! so sweep from more positive to more negative zed if ( sgn > 0 ) then if ( iseg == nseg . and . . not . periodic ) then i = ulim df ( i ) = ( 0.5 * ( upwnd - 1. ) * f ( i - 1 ) - upwnd * f ( i )) / del else i = ulim df ( i ) = ( 0.5 * ( upwnd - 1. ) * f ( i - 1 ) - upwnd * f ( i ) + 0.5 * ( 1. + upwnd ) * fr ( 1 )) / del end if if ( iseg == 1 . and . . not . periodic ) then i = llim ! at left boundary, must upwind fully as no info for f(i-1) df ( i ) = ( f ( i + 1 ) - f ( i )) / del else i = llim df ( i ) = ( 0.5 * ( 1. + upwnd ) * f ( i + 1 ) - upwnd * f ( i ) + 0.5 * ( upwnd - 1. ) * fl ( 2 )) / del end if istart = ulim iend = llim else if ( iseg == 1 . and . . not . periodic ) then i = llim df ( i ) = ( 0.5 * ( 1. - upwnd ) * f ( i + 1 ) + upwnd * f ( i )) / del else i = llim df ( i ) = ( 0.5 * ( 1. - upwnd ) * f ( i + 1 ) + upwnd * f ( i ) - 0.5 * ( 1. + upwnd ) * fl ( 2 )) / del end if if ( iseg == nseg . and . . not . periodic ) then i = ulim ! if at rightmost zed, have no info for f(i+1) so must fully upwind df ( i ) = ( f ( i ) - f ( i - 1 )) / del else i = ulim df ( i ) = ( 0.5 * ( 1. - upwnd ) * fr ( 1 ) + upwnd * f ( i ) - 0.5 * ( 1. + upwnd ) * f ( i - 1 )) / del end if istart = llim iend = ulim end if ! mixed 2nd order centered and 1st order upwind scheme do i = istart - sgn , iend + sgn , - sgn df ( i ) = sgn * ( 0.5 * ( 1. + upwnd ) * f ( i + sgn ) - upwnd * f ( i ) + 0.5 * ( upwnd - 1. ) * f ( i - sgn )) / del end do end if end subroutine fd_variable_upwinding_zed subroutine fd_variable_upwinding_vpa ( llim , f , del , sgn , upwnd , df ) implicit none integer , intent ( in ) :: llim complex , dimension ( llim :), intent ( in ) :: f real , intent ( in ) :: del , upwnd integer , intent ( in ) :: sgn complex , dimension ( llim :), intent ( out ) :: df integer :: i , istart , iend , ulim ! if upwnd is zero or if z=0, then use centered differences if ( abs ( upwnd ) < epsilon ( 0. ) . or . sgn == 0 ) then call second_order_centered_vpa ( llim , f , del , df ) else ulim = size ( f ) + llim - 1 ! if sgn > 0, then stream speed is negative ! so sweep from more positive to more negative zed if ( sgn > 0 ) then istart = ulim iend = llim else istart = llim iend = ulim end if ! zero_bc assumes that g -> zero beyond grid ! boundaries in vpa df ( istart ) = sgn * ( 0.5 * ( upwnd - 1.0 ) * f ( istart - sgn ) - upwnd * f ( istart )) / del ! as do not have info beyond grid boundary at end of sweep ! use pure upwinding df ( iend ) = sgn * ( f ( iend + sgn ) - f ( iend )) / del ! mixed centered and 1st order upwind scheme do i = istart - sgn , iend + sgn , - sgn df ( i ) = sgn * ( 0.5 * ( 1. + upwnd ) * f ( i + sgn ) - upwnd * f ( i ) + 0.5 * ( upwnd - 1. ) * f ( i - sgn )) / del end do end if end subroutine fd_variable_upwinding_vpa ! only good for equally-spaced grid-pts subroutine fd3pt_real ( prof , profgrad , dr ) implicit none real , dimension (:), intent ( in ) :: prof real , dimension (:), intent ( out ) :: profgrad real , intent ( in ) :: dr integer :: ix , npts real , dimension (:), allocatable :: aa , bb , cc npts = size ( prof ) allocate ( aa ( npts ), bb ( npts ), cc ( npts )) aa = 1.0 ; bb = 4.0 ; cc = 1.0 aa ( 1 ) = 0.0 ; bb ( 1 ) = 0.5 ; cc ( 1 ) = 0.5 aa ( npts ) = 0.5 ; bb ( npts ) = 0.5 ; cc ( npts ) = 0.0 do ix = 2 , npts - 1 profgrad ( ix ) = 3.0 * ( prof ( ix + 1 ) - prof ( ix - 1 )) / dr end do profgrad ( 1 ) = ( prof ( 2 ) - prof ( 1 )) / dr profgrad ( npts ) = ( prof ( npts ) - prof ( npts - 1 )) / dr call tridag ( aa , bb , cc , profgrad ) deallocate ( aa , bb , cc ) end subroutine fd3pt_real subroutine fd3pt_real_array ( prof , profgrad , dr ) implicit none real , dimension (:), intent ( in ) :: prof , dr real , dimension (:), intent ( out ) :: profgrad integer :: ix , npts real :: a , b , c npts = size ( prof ) do ix = 2 , npts - 1 profgrad ( ix ) = (( prof ( ix ) - prof ( ix - 1 )) * dr ( ix ) / dr ( ix - 1 ) & + ( prof ( ix + 1 ) - prof ( ix )) * dr ( ix - 1 ) / dr ( ix )) / ( dr ( ix - 1 ) + dr ( ix )) end do ix = 1 a = - ( 2. * dr ( 1 ) + dr ( 2 )) / ( dr ( 1 ) * ( dr ( 1 ) + dr ( 2 ))) b = ( dr ( 1 ) + dr ( 2 )) / ( dr ( 1 ) * dr ( 2 )) c = - dr ( 1 ) / ( dr ( 2 ) * ( dr ( 1 ) + dr ( 2 ))) profgrad ( 1 ) = a * prof ( 1 ) + b * prof ( 2 ) + c * prof ( 3 ) ix = npts a = dr ( npts - 1 ) / ( dr ( npts - 2 ) * ( dr ( npts - 2 ) + dr ( npts - 1 ))) b = - ( dr ( npts - 1 ) + dr ( npts - 2 )) / ( dr ( npts - 2 ) * dr ( npts - 1 )) c = ( 2. * dr ( npts - 1 ) + dr ( npts - 2 )) / ( dr ( npts - 1 ) * ( dr ( npts - 1 ) + dr ( npts - 2 ))) profgrad ( npts ) = a * prof ( npts - 2 ) + b * prof ( npts - 1 ) + c * prof ( npts ) end subroutine fd3pt_real_array subroutine fd3pt_complex_array ( prof , profgrad , dr ) implicit none complex , dimension (:), intent ( in ) :: prof real , dimension (:), intent ( in ) :: dr complex , dimension (:), intent ( out ) :: profgrad integer :: ix , npts real :: a , b , c npts = size ( prof ) do ix = 2 , npts - 1 profgrad ( ix ) = (( prof ( ix ) - prof ( ix - 1 )) * dr ( ix ) / dr ( ix - 1 ) & + ( prof ( ix + 1 ) - prof ( ix )) * dr ( ix - 1 ) / dr ( ix )) / ( dr ( ix - 1 ) + dr ( ix )) end do ix = 1 a = - ( 2. * dr ( 1 ) + dr ( 2 )) / ( dr ( 1 ) * ( dr ( 1 ) + dr ( 2 ))) b = ( dr ( 1 ) + dr ( 2 )) / ( dr ( 1 ) * dr ( 2 )) c = - dr ( 1 ) / ( dr ( 2 ) * ( dr ( 1 ) + dr ( 2 ))) profgrad ( 1 ) = a * prof ( 1 ) + b * prof ( 2 ) + c * prof ( 3 ) ix = npts a = dr ( npts - 1 ) / ( dr ( npts - 2 ) * ( dr ( npts - 2 ) + dr ( npts - 1 ))) b = - ( dr ( npts - 1 ) + dr ( npts - 2 )) / ( dr ( npts - 2 ) * dr ( npts - 1 )) c = ( 2. * dr ( npts - 1 ) + dr ( npts - 2 )) / ( dr ( npts - 1 ) * ( dr ( npts - 1 ) + dr ( npts - 2 ))) profgrad ( npts ) = a * prof ( npts - 2 ) + b * prof ( npts - 1 ) + c * prof ( npts ) end subroutine fd3pt_complex_array ! boundary points are 2nd-order accurate (2-pt compact difference) ! next to boundary points are 4th-order accurate (2-pt centered compact difference) ! interior points are 6th-order accurate (4-pt centered compact difference) subroutine fd5pt_real ( prof , profgrad , dr ) implicit none real , dimension (:), intent ( in ) :: prof real , dimension (:), intent ( out ) :: profgrad real , intent ( in ) :: dr integer :: ix , npts real , dimension (:), allocatable :: aa , bb , cc npts = size ( prof ) allocate ( aa ( npts ), bb ( npts ), cc ( npts )) aa = 1.0 ; bb = 3.0 ; cc = 1.0 aa ( 1 ) = 0.0 ; bb ( 1 ) = 0.5 ; cc ( 1 ) = 0.5 aa ( 2 ) = 1.0 ; bb ( 2 ) = 4.0 ; cc ( 2 ) = 1.0 aa ( npts - 1 ) = 1.0 ; bb ( npts - 1 ) = 4.0 ; cc ( npts - 1 ) = 1.0 aa ( npts ) = 0.5 ; bb ( npts ) = 0.5 ; cc ( npts ) = 0.0 do ix = 3 , npts - 2 profgrad ( ix ) = ( 7. * ( prof ( ix + 1 ) - prof ( ix - 1 )) + 0.25 * ( prof ( ix + 2 ) - prof ( ix - 2 ))) / ( 3. * dr ) end do profgrad ( 1 ) = ( prof ( 2 ) - prof ( 1 )) / dr profgrad ( 2 ) = 3.0 * ( prof ( 3 ) - prof ( 1 )) / dr profgrad ( npts - 1 ) = 3.0 * ( prof ( npts ) - prof ( npts - 2 )) / dr profgrad ( npts ) = ( prof ( npts ) - prof ( npts - 1 )) / dr call tridag ( aa , bb , cc , profgrad ) deallocate ( aa , bb , cc ) end subroutine fd5pt_real ! boundary points are 2nd-order accurate (2-pt compact difference) ! next to boundary points are 4th-order accurate (2-pt centered compact difference) ! interior points are 6th-order accurate (4-pt centered compact difference) subroutine fd5pt_array ( prof , profgrad , dr ) implicit none real , dimension (:), intent ( in ) :: prof , dr real , dimension (:), intent ( out ) :: profgrad integer :: ix , npts real , dimension (:), allocatable :: aa , bb , cc npts = size ( prof ) allocate ( aa ( npts ), bb ( npts ), cc ( npts )) aa = 1.0 ; bb = 3.0 ; cc = 1.0 aa ( 1 ) = 0.0 ; bb ( 1 ) = 0.5 ; cc ( 1 ) = 0.5 aa ( 2 ) = 1.0 ; bb ( 2 ) = 4.0 ; cc ( 2 ) = 1.0 aa ( npts - 1 ) = 1.0 ; bb ( npts - 1 ) = 4.0 ; cc ( npts - 1 ) = 1.0 aa ( npts ) = 0.5 ; bb ( npts ) = 0.5 ; cc ( npts ) = 0.0 do ix = 3 , npts - 2 profgrad ( ix ) = ( 7. * ( prof ( ix + 1 ) - prof ( ix - 1 )) + 0.25 * ( prof ( ix + 2 ) - prof ( ix - 2 ))) / ( 3. * dr ( ix )) end do profgrad ( 1 ) = ( prof ( 2 ) - prof ( 1 )) / dr ( 1 ) profgrad ( 2 ) = 3.0 * ( prof ( 3 ) - prof ( 1 )) / dr ( 2 ) profgrad ( npts - 1 ) = 3.0 * ( prof ( npts ) - prof ( npts - 2 )) / dr ( npts - 1 ) profgrad ( npts ) = ( prof ( npts ) - prof ( npts - 1 )) / dr ( npts ) call tridag ( aa , bb , cc , profgrad ) deallocate ( aa , bb , cc ) end subroutine fd5pt_array ! second derivative using centered differences ! second order accurate subroutine d2_3pt_real ( f , d2f , dr ) implicit none real , dimension (:), intent ( in ) :: f real , dimension (:), intent ( in ) :: dr real , dimension (:), intent ( out ) :: d2f real :: a , b , c , d integer :: i , n n = size ( f ) do i = 2 , n - 1 a = 2. / ( dr ( i - 1 ) * ( dr ( i ) + dr ( i - 1 ))) b = - 2. / ( dr ( i - 1 ) * dr ( i )) c = 2. / ( dr ( i ) * ( dr ( i ) + dr ( i - 1 ))) d2f ( i ) = a * f ( i - 1 ) + b * f ( i ) + c * f ( i + 1 ) end do i = 1 a = ( 6. * dr ( 1 ) + 4. * dr ( 2 ) + 2. * dr ( 3 )) & / ( dr ( 1 ) * ( dr ( 1 ) + dr ( 2 )) * ( dr ( 1 ) + dr ( 2 ) + dr ( 3 ))) b = - ( 4. * ( dr ( 1 ) + dr ( 2 )) + 2. * dr ( 3 )) & / ( dr ( 1 ) * dr ( 2 ) * ( dr ( 2 ) + dr ( 3 ))) c = ( 4. * dr ( 1 ) + 2. * ( dr ( 2 ) + dr ( 3 ))) & / (( dr ( 2 ) + dr ( 1 )) * dr ( 2 ) * dr ( 3 )) d = - ( 4. * dr ( 1 ) + 2. * dr ( 2 )) & / (( dr ( 3 ) + dr ( 2 ) + dr ( 1 )) * ( dr ( 3 ) + dr ( 2 )) * dr ( 3 )) d2f ( i ) = a * f ( 1 ) + b * f ( 2 ) + c * f ( 3 ) + d * f ( 4 ) i = n a = - ( 4. * dr ( n - 1 ) + 2. * dr ( n - 2 )) & / ( dr ( n - 3 ) * ( dr ( n - 3 ) + dr ( n - 2 )) * ( dr ( n - 3 ) + dr ( n - 2 ) + dr ( n - 1 ))) b = ( 4. * dr ( n - 1 ) + 2. * ( dr ( n - 2 ) + dr ( n - 3 ))) & / ( dr ( n - 3 ) * dr ( n - 2 ) * ( dr ( n - 2 ) + dr ( n - 1 ))) c = - ( 4. * ( dr ( n - 1 ) + dr ( n - 2 )) + 2. * dr ( n - 3 )) & / ( dr ( n - 1 ) * dr ( n - 2 ) * ( dr ( n - 2 ) + dr ( n - 3 ))) d = ( 6. * dr ( n - 1 ) + 4. * dr ( n - 2 ) + 2. * dr ( n - 3 )) & / ( dr ( n - 1 ) * ( dr ( n - 1 ) + dr ( n - 2 )) * ( dr ( n - 1 ) + dr ( n - 2 ) + dr ( n - 3 ))) d2f ( i ) = a * f ( n - 3 ) + b * f ( n - 2 ) + c * f ( n - 1 ) + d * f ( n ) !     ! FLAG -- this is a hack !     ! do not anticipate needing 2nd derivatives !     ! at first and last grid points !     d2f(1) = d2f(2) !     d2f(n) = d2f(n-1) end subroutine d2_3pt_real subroutine d2_3pt_complex ( f , d2f , dr ) implicit none complex , dimension (:), intent ( in ) :: f real , dimension (:), intent ( in ) :: dr complex , dimension (:), intent ( out ) :: d2f real :: a , b , c , d integer :: i , n n = size ( f ) do i = 2 , n - 1 a = 2. / ( dr ( i - 1 ) * ( dr ( i ) + dr ( i - 1 ))) b = - 2. / ( dr ( i - 1 ) * dr ( i )) c = 2. / ( dr ( i ) * ( dr ( i ) + dr ( i - 1 ))) d2f ( i ) = a * f ( i - 1 ) + b * f ( i ) + c * f ( i + 1 ) end do i = 1 a = ( 6. * dr ( 1 ) + 4. * dr ( 2 ) + 2. * dr ( 3 )) & / ( dr ( 1 ) * ( dr ( 1 ) + dr ( 2 )) * ( dr ( 1 ) + dr ( 2 ) + dr ( 3 ))) b = - ( 4. * ( dr ( 1 ) + dr ( 2 )) + 2. * dr ( 3 )) & / ( dr ( 1 ) * dr ( 2 ) * ( dr ( 2 ) + dr ( 3 ))) c = ( 4. * dr ( 1 ) + 2. * ( dr ( 2 ) + dr ( 3 ))) & / (( dr ( 2 ) + dr ( 1 )) * dr ( 2 ) * dr ( 3 )) d = - ( 4. * dr ( 1 ) + 2. * dr ( 2 )) & / (( dr ( 3 ) + dr ( 2 ) + dr ( 1 )) * ( dr ( 3 ) + dr ( 2 )) * dr ( 3 )) d2f ( i ) = a * f ( 1 ) + b * f ( 2 ) + c * f ( 3 ) + d * f ( 4 ) i = n a = - ( 4. * dr ( n - 1 ) + 2. * dr ( n - 2 )) & / ( dr ( n - 3 ) * ( dr ( n - 3 ) + dr ( n - 2 )) * ( dr ( n - 3 ) + dr ( n - 2 ) + dr ( n - 1 ))) b = ( 4. * dr ( n - 1 ) + 2. * ( dr ( n - 2 ) + dr ( n - 3 ))) & / ( dr ( n - 3 ) * dr ( n - 2 ) * ( dr ( n - 2 ) + dr ( n - 1 ))) c = - ( 4. * ( dr ( n - 1 ) + dr ( n - 2 )) + 2. * dr ( n - 3 )) & / ( dr ( n - 1 ) * dr ( n - 2 ) * ( dr ( n - 2 ) + dr ( n - 3 ))) d = ( 6. * dr ( n - 1 ) + 4. * dr ( n - 2 ) + 2. * dr ( n - 3 )) & / ( dr ( n - 1 ) * ( dr ( n - 1 ) + dr ( n - 2 )) * ( dr ( n - 1 ) + dr ( n - 2 ) + dr ( n - 3 ))) d2f ( i ) = a * f ( n - 3 ) + b * f ( n - 2 ) + c * f ( n - 1 ) + d * f ( n ) end subroutine d2_3pt_complex subroutine tridag_real ( aa , bb , cc , sol ) implicit none real , dimension (:), intent ( in ) :: aa , bb , cc real , dimension (:), intent ( in out ) :: sol integer :: ix , npts real :: bet real , dimension (:), allocatable :: gam npts = size ( aa ) allocate ( gam ( npts )) bet = bb ( 1 ) sol ( 1 ) = sol ( 1 ) / bet do ix = 2 , npts gam ( ix ) = cc ( ix - 1 ) / bet bet = bb ( ix ) - aa ( ix ) * gam ( ix ) if ( bet == 0.0 ) write ( * , * ) 'tridiagonal solve failed' sol ( ix ) = ( sol ( ix ) - aa ( ix ) * sol ( ix - 1 )) / bet end do do ix = npts - 1 , 1 , - 1 sol ( ix ) = sol ( ix ) - gam ( ix + 1 ) * sol ( ix + 1 ) end do deallocate ( gam ) end subroutine tridag_real subroutine tridag_complex ( llim , aa , bb , cc , sol ) implicit none integer , intent ( in ) :: llim real , dimension ( llim :), intent ( in ) :: aa , bb , cc complex , dimension ( llim :), intent ( in out ) :: sol integer :: ix , npts real :: bet real , dimension (:), allocatable :: gam npts = size ( bb ) allocate ( gam ( llim : llim + npts - 1 )) bet = bb ( llim ) sol ( llim ) = sol ( llim ) / bet do ix = llim + 1 , llim + npts - 1 gam ( ix ) = cc ( ix - 1 ) / bet bet = bb ( ix ) - aa ( ix ) * gam ( ix ) if ( bet == 0.0 ) write ( * , * ) 'tridiagonal solve failed' sol ( ix ) = ( sol ( ix ) - aa ( ix ) * sol ( ix - 1 )) / bet end do do ix = llim + npts - 2 , llim , - 1 sol ( ix ) = sol ( ix ) - gam ( ix + 1 ) * sol ( ix + 1 ) end do deallocate ( gam ) end subroutine tridag_complex end module finite_differences","tags":"","loc":"sourcefile/finite_differences.f90.html"},{"title":"fields_arrays.f90 â€“ stella","text":"Contents Modules fields_arrays Source Code fields_arrays.f90 Source Code module fields_arrays use common_types , only : response_matrix_type , eigen_type implicit none complex , dimension (:, :, :, :), allocatable :: phi , apar , phi_old ! (naky, nakx, -nzgrid:nzgrid, ntubes) ! DSO 0 the following is a band-aid for radially global simulations until ! we more fully incorporate shared memory complex , dimension (:, :, :, :), pointer :: phi_shared ! (naky, nakx, -nzgrid:nzgrid, ntubes) ! radial corrections to phi and apar from quasineutrality/whatever controls apar complex , dimension (:, :, :, :), allocatable :: phi_corr_QN , apar_corr_QN ! (naky, nakx, -nzgrid:nzgrid, ntubes) ! needed to implement time-delayed source when using projection method complex , dimension (:, :, :), allocatable :: phi_proj , phi_proj_stage ! (nakx, -nzgrid:nzgrid, ntubes) ! radial corrections to phi and apar from gyroaveraging ! may result in tight space constraints however complex , dimension (:, :, :, :, :), allocatable :: phi_corr_GA , apar_corr_GA ! (naky, nakx, -nzgrid:nzgrid, ntubes, -vmu-layout-) type ( response_matrix_type ), dimension (:), allocatable :: response_matrix real , dimension (:), allocatable :: shift_state real , dimension (:, :, :), allocatable :: gamtot , dgamtotdr real , dimension (:, :), allocatable :: gamtot3 , dgamtot3dr !real :: gamtot_h, gamtot3_h, efac, efacp complex , dimension (:, :, :), allocatable :: theta ! (nakx, nakx, -nzgrid:nzgrid) complex , dimension (:, :), allocatable :: c_mat ! (nakx, nakx) complex , dimension (:), pointer :: phi_ext => null () ! (nakx*nztot) type ( eigen_type ), dimension (:, :), allocatable :: phi_solve type ( eigen_type ) :: phizf_solve !variables needed for the source logical :: exclude_boundary_regions_qn real :: tcorr_source_qn , exp_fac_qn integer :: qn_window , qn_zf_window end module fields_arrays","tags":"","loc":"sourcefile/fields_arrays.f90.html"},{"title":"stella_layouts.f90 â€“ stella","text":"Contents Modules stella_layouts Source Code stella_layouts.f90 Source Code module stella_layouts use common_types , only : vmu_layout_type use common_types , only : kxkyz_layout_type , kxyz_layout_type , xyz_layout_type implicit none private public :: xyzs_layout , vms_layout public :: finish_layouts public :: init_stella_layouts , init_dist_fn_layouts public :: kxkyz_lo , kxyz_lo , xyz_lo , vmu_lo public :: kxkyzidx2vmuidx , kxyzidx2vmuidx , xyzidx2vmuidx public :: iz_idx , iky_idx , ikx_idx , iv_idx , imu_idx , is_idx , iy_idx public :: it_idx public :: idx , proc_id , idx_local character ( len = 4 ) :: xyzs_layout character ( len = 3 ) :: vms_layout logical :: exist type ( kxkyz_layout_type ) :: kxkyz_lo type ( kxyz_layout_type ) :: kxyz_lo type ( xyz_layout_type ) :: xyz_lo type ( vmu_layout_type ) :: vmu_lo interface it_idx module procedure it_idx_kxkyz module procedure it_idx_kxyz module procedure it_idx_xyz end interface interface iz_idx module procedure iz_idx_kxkyz module procedure iz_idx_kxyz module procedure iz_idx_xyz end interface interface iv_idx module procedure iv_idx_vmu end interface interface iky_idx module procedure iky_idx_kxkyz end interface interface iy_idx module procedure iy_idx_kxyz module procedure iy_idx_xyz end interface interface ikx_idx module procedure ikx_idx_kxkyz module procedure ikx_idx_kxyz end interface interface ix_idx module procedure ix_idx_xyz end interface interface imu_idx module procedure imu_idx_vmu end interface interface is_idx module procedure is_idx_kxkyz module procedure is_idx_kxyz module procedure is_idx_xyz module procedure is_idx_vmu end interface interface proc_id module procedure proc_id_kxkyz module procedure proc_id_kxyz module procedure proc_id_xyz module procedure proc_id_vmu end interface interface idx module procedure idx_kxkyz module procedure idx_kxyz module procedure idx_xyz module procedure idx_vmu end interface interface idx_local module procedure idx_local_kxkyz , iz_local_kxkyz module procedure idx_local_kxyz , iz_local_kxyz module procedure idx_local_xyz , iz_local_xyz module procedure idx_local_vmu , iz_local_vmu end interface contains subroutine init_stella_layouts use mp , only : proc0 implicit none logical , save :: initialized = . false . if ( initialized ) return initialized = . true . if ( proc0 ) call read_parameters call broadcast_results end subroutine init_stella_layouts subroutine read_parameters use mp , only : mp_abort use file_utils , only : input_unit , error_unit , input_unit_exist , error_unit implicit none integer :: in_file namelist / layouts_knobs / xyzs_layout , vms_layout xyzs_layout = 'xyzs' vms_layout = 'vms' in_file = input_unit_exist ( \"layouts_knobs\" , exist ) if ( exist ) read ( unit = input_unit ( \"layouts_knobs\" ), nml = layouts_knobs ) if ( xyzs_layout /= 'xyzs' . and . & xyzs_layout /= 'xzys' . and . & xyzs_layout /= 'yxzs' . and . & xyzs_layout /= 'yzxs' . and . & xyzs_layout /= 'zxys' . and . & xyzs_layout /= 'zyxs' ) then call mp_abort ( 'stella_layouts: read_parameters finds illegal xyzs_layout. aborting' ) end if if ( vms_layout /= 'vms' . and . & vms_layout /= 'mvs' ) then call mp_abort ( 'stella_layouts: read_parameters finds illegal vms_layout. aborting' ) end if end subroutine read_parameters subroutine broadcast_results use mp , only : broadcast implicit none call broadcast ( xyzs_layout ) call broadcast ( vms_layout ) end subroutine broadcast_results !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Distribution function layouts !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine init_dist_fn_layouts ( nzgrid , ntubes , naky , nakx , nvgrid , nmu , nspec , ny , nx , nalpha ) implicit none integer , intent ( in ) :: nzgrid , ntubes , naky , nakx , nvgrid , nmu , nspec , ny , nx , nalpha call init_kxkyz_layout ( nzgrid , ntubes , naky , nakx , nvgrid , nmu , nspec ) call init_kxyz_layout ( nzgrid , ntubes , naky , nakx , nvgrid , nmu , nspec , ny ) call init_xyz_layout ( nzgrid , ntubes , naky , nakx , nvgrid , nmu , nspec , ny , nx ) call init_vmu_layout ( nzgrid , ntubes , naky , nakx , nvgrid , nmu , nspec , ny , nx , nalpha ) end subroutine init_dist_fn_layouts subroutine init_kxkyz_layout & ( nzgrid , ntubes , naky , nakx , nvgrid , nmu , nspec ) use mp , only : iproc , nproc implicit none integer , intent ( in ) :: nzgrid , ntubes , naky , nakx , nvgrid , nmu , nspec logical , save :: initialized = . false . if ( initialized ) return initialized = . true . kxkyz_lo % iproc = iproc kxkyz_lo % nzgrid = nzgrid kxkyz_lo % nzed = 2 * nzgrid + 1 kxkyz_lo % ntubes = ntubes kxkyz_lo % naky = naky kxkyz_lo % nakx = nakx kxkyz_lo % nvgrid = nvgrid kxkyz_lo % nvpa = 2 * nvgrid kxkyz_lo % nmu = nmu kxkyz_lo % nspec = nspec kxkyz_lo % llim_world = 0 kxkyz_lo % ulim_world = naky * nakx * kxkyz_lo % nzed * ntubes * nspec - 1 kxkyz_lo % blocksize = kxkyz_lo % ulim_world / nproc + 1 kxkyz_lo % llim_proc = kxkyz_lo % blocksize * iproc kxkyz_lo % ulim_proc = min ( kxkyz_lo % ulim_world , kxkyz_lo % llim_proc + kxkyz_lo % blocksize - 1 ) kxkyz_lo % ulim_alloc = max ( kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc ) end subroutine init_kxkyz_layout elemental function is_idx_kxkyz ( lo , i ) implicit none integer :: is_idx_kxkyz type ( kxkyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i is_idx_kxkyz = 1 + mod (( i - lo % llim_world ) / lo % nakx / lo % naky / lo % nzed / lo % ntubes , lo % nspec ) end function is_idx_kxkyz elemental function ikx_idx_kxkyz ( lo , i ) implicit none integer :: ikx_idx_kxkyz type ( kxkyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i select case ( xyzs_layout ) case ( 'xyzs' ) ikx_idx_kxkyz = 1 + mod (( i - lo % llim_world ), lo % nakx ) case ( 'xzys' ) ikx_idx_kxkyz = 1 + mod (( i - lo % llim_world ), lo % nakx ) case ( 'yxzs' ) ikx_idx_kxkyz = 1 + mod (( i - lo % llim_world ) / lo % naky , lo % nakx ) case ( 'zxys' ) ikx_idx_kxkyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % ntubes , lo % nakx ) case ( 'zyxs' ) ikx_idx_kxkyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % ntubes / lo % naky , lo % nakx ) case ( 'yzxs' ) ikx_idx_kxkyz = 1 + mod (( i - lo % llim_world ) / lo % naky / lo % nzed / lo % ntubes , lo % nakx ) end select end function ikx_idx_kxkyz elemental function iky_idx_kxkyz ( lo , i ) implicit none integer :: iky_idx_kxkyz type ( kxkyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i select case ( xyzs_layout ) case ( 'yxzs' ) iky_idx_kxkyz = 1 + mod ( i - lo % llim_world , lo % naky ) case ( 'yzxs' ) iky_idx_kxkyz = 1 + mod ( i - lo % llim_world , lo % naky ) case ( 'xyzs' ) iky_idx_kxkyz = 1 + mod (( i - lo % llim_world ) / lo % nakx , lo % naky ) case ( 'zyxs' ) iky_idx_kxkyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % ntubes , lo % naky ) case ( 'zxys' ) iky_idx_kxkyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % ntubes / lo % nakx , lo % naky ) case ( 'xzys' ) iky_idx_kxkyz = 1 + mod (( i - lo % llim_world ) / lo % nakx / lo % nzed / lo % ntubes , lo % naky ) end select end function iky_idx_kxkyz elemental function iz_idx_kxkyz ( lo , i ) implicit none integer :: iz_idx_kxkyz type ( kxkyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i select case ( xyzs_layout ) case ( 'zyxs' ) iz_idx_kxkyz = - lo % nzgrid + mod (( i - lo % llim_world ), lo % nzed ) case ( 'zxys' ) iz_idx_kxkyz = - lo % nzgrid + mod (( i - lo % llim_world ), lo % nzed ) case ( 'xzys' ) iz_idx_kxkyz = - lo % nzgrid + mod (( i - lo % llim_world ) / lo % nakx , lo % nzed ) case ( 'yzxs' ) iz_idx_kxkyz = - lo % nzgrid + mod (( i - lo % llim_world ) / lo % naky , lo % nzed ) case ( 'yxzs' ) iz_idx_kxkyz = - lo % nzgrid + mod (( i - lo % llim_world ) / lo % naky / lo % nakx , lo % nzed ) case ( 'xyzs' ) iz_idx_kxkyz = - lo % nzgrid + mod (( i - lo % llim_world ) / lo % nakx / lo % naky , lo % nzed ) end select end function iz_idx_kxkyz elemental function it_idx_kxkyz ( lo , i ) implicit none integer :: it_idx_kxkyz type ( kxkyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i select case ( xyzs_layout ) case ( 'zyxs' ) it_idx_kxkyz = 1 + mod (( i - lo % llim_world ) / lo % nzed , lo % ntubes ) case ( 'zxys' ) it_idx_kxkyz = 1 + mod (( i - lo % llim_world ) / lo % nzed , lo % ntubes ) case ( 'xzys' ) it_idx_kxkyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % nakx , lo % ntubes ) case ( 'yzxs' ) it_idx_kxkyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % naky , lo % ntubes ) case ( 'yxzs' ) it_idx_kxkyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % naky / lo % nakx , lo % ntubes ) case ( 'xyzs' ) it_idx_kxkyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % nakx / lo % naky , lo % ntubes ) end select end function it_idx_kxkyz elemental function proc_id_kxkyz ( lo , i ) implicit none integer :: proc_id_kxkyz type ( kxkyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i proc_id_kxkyz = i / lo % blocksize end function proc_id_kxkyz elemental function idx_kxkyz ( lo , iky , ikx , iz , it , is ) implicit none integer :: idx_kxkyz type ( kxkyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: iky , ikx , iz , it , is select case ( xyzs_layout ) case ( 'xyzs' ) idx_kxkyz = ikx - 1 + lo % nakx * ( iky - 1 + lo % naky * ( iz + lo % nzgrid + lo % nzed * ( it - 1 + lo % ntubes * ( is - 1 )))) case ( 'xzys' ) idx_kxkyz = ikx - 1 + lo % nakx * ( iz + lo % nzgrid + lo % nzed * ( it - 1 + lo % ntubes * ( iky - 1 + lo % naky * ( is - 1 )))) case ( 'yxzs' ) idx_kxkyz = iky - 1 + lo % naky * ( ikx - 1 + lo % nakx * ( iz + lo % nzgrid + lo % nzed * ( it - 1 + lo % ntubes * ( is - 1 )))) case ( 'yzxs' ) idx_kxkyz = iky - 1 + lo % naky * ( iz + lo % nzgrid + lo % nzed * ( it - 1 + lo % ntubes * ( ikx - 1 + lo % nakx * ( is - 1 )))) case ( 'zyxs' ) idx_kxkyz = iz + lo % nzgrid + lo % nzed * ( it - 1 + lo % ntubes * ( iky - 1 + lo % naky * ( ikx - 1 ))) case ( 'zxys' ) idx_kxkyz = iz + lo % nzgrid + lo % nzed * ( it - 1 + lo % ntubes * ( ikx - 1 + lo % nakx * ( iky - 1 ))) end select end function idx_kxkyz elemental function idx_local_kxkyz ( lo , iky , ikx , iz , it , is ) implicit none logical :: idx_local_kxkyz type ( kxkyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: iky , ikx , iz , it , is idx_local_kxkyz = idx_local ( lo , idx ( lo , iky , ikx , iz , it , is )) end function idx_local_kxkyz elemental function iz_local_kxkyz ( lo , iz ) implicit none logical :: iz_local_kxkyz type ( kxkyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: iz iz_local_kxkyz = lo % iproc == proc_id ( lo , iz ) end function iz_local_kxkyz subroutine init_kxyz_layout & ( nzgrid , ntubes , naky , nakx , nvgrid , nmu , nspec , ny ) use mp , only : iproc , nproc implicit none integer , intent ( in ) :: nzgrid , ntubes , ny , naky , nakx , nvgrid , nmu , nspec logical , save :: initialized = . false . if ( initialized ) return initialized = . true . kxyz_lo % iproc = iproc kxyz_lo % nzgrid = nzgrid kxyz_lo % nzed = 2 * nzgrid + 1 kxyz_lo % ntubes = ntubes kxyz_lo % ny = ny kxyz_lo % naky = naky kxyz_lo % nakx = nakx kxyz_lo % ikx_max = nakx / 2 + 1 kxyz_lo % nvgrid = nvgrid kxyz_lo % nvpa = 2 * nvgrid kxyz_lo % nmu = nmu kxyz_lo % nspec = nspec kxyz_lo % llim_world = 0 kxyz_lo % ulim_world = ny * kxyz_lo % ikx_max * kxyz_lo % nzed * ntubes * nspec - 1 kxyz_lo % blocksize = kxyz_lo % ulim_world / nproc + 1 kxyz_lo % llim_proc = kxyz_lo % blocksize * iproc kxyz_lo % ulim_proc = min ( kxyz_lo % ulim_world , kxyz_lo % llim_proc + kxyz_lo % blocksize - 1 ) kxyz_lo % ulim_alloc = max ( kxyz_lo % llim_proc , kxyz_lo % ulim_proc ) end subroutine init_kxyz_layout elemental function is_idx_kxyz ( lo , i ) implicit none integer :: is_idx_kxyz type ( kxyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i is_idx_kxyz = 1 + mod (( i - lo % llim_world ) / lo % ikx_max / lo % ny / lo % nzed / lo % ntubes , lo % nspec ) end function is_idx_kxyz elemental function ikx_idx_kxyz ( lo , i ) implicit none integer :: ikx_idx_kxyz type ( kxyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i select case ( xyzs_layout ) case ( 'xyzs' ) ikx_idx_kxyz = 1 + mod (( i - lo % llim_world ), lo % ikx_max ) case ( 'xzys' ) ikx_idx_kxyz = 1 + mod (( i - lo % llim_world ), lo % ikx_max ) case ( 'yxzs' ) ikx_idx_kxyz = 1 + mod (( i - lo % llim_world ) / lo % ny , lo % ikx_max ) case ( 'zxys' ) ikx_idx_kxyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % ntubes , lo % ikx_max ) case ( 'zyxs' ) ikx_idx_kxyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % ntubes / lo % ny , lo % ikx_max ) case ( 'yzxs' ) ikx_idx_kxyz = 1 + mod (( i - lo % llim_world ) / lo % ny / lo % nzed / lo % ntubes , lo % ikx_max ) end select end function ikx_idx_kxyz elemental function iy_idx_kxyz ( lo , i ) implicit none integer :: iy_idx_kxyz type ( kxyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i select case ( xyzs_layout ) case ( 'yxzs' ) iy_idx_kxyz = 1 + mod ( i - lo % llim_world , lo % ny ) case ( 'yzxs' ) iy_idx_kxyz = 1 + mod ( i - lo % llim_world , lo % ny ) case ( 'xyzs' ) iy_idx_kxyz = 1 + mod (( i - lo % llim_world ) / lo % ikx_max , lo % ny ) case ( 'zyxs' ) iy_idx_kxyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % ntubes , lo % ny ) case ( 'zxys' ) iy_idx_kxyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % ntubes / lo % ikx_max , lo % ny ) case ( 'xzys' ) iy_idx_kxyz = 1 + mod (( i - lo % llim_world ) / lo % ikx_max / lo % nzed / lo % ntubes , lo % ny ) end select end function iy_idx_kxyz elemental function iz_idx_kxyz ( lo , i ) implicit none integer :: iz_idx_kxyz type ( kxyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i select case ( xyzs_layout ) case ( 'zyxs' ) iz_idx_kxyz = - lo % nzgrid + mod (( i - lo % llim_world ), lo % nzed ) case ( 'zxys' ) iz_idx_kxyz = - lo % nzgrid + mod (( i - lo % llim_world ), lo % nzed ) case ( 'yzxs' ) iz_idx_kxyz = - lo % nzgrid + mod (( i - lo % llim_world ) / lo % ny , lo % nzed ) case ( 'xzys' ) iz_idx_kxyz = - lo % nzgrid + mod (( i - lo % llim_world ) / lo % ikx_max , lo % nzed ) case ( 'yxzs' ) iz_idx_kxyz = - lo % nzgrid + mod (( i - lo % llim_world ) / lo % ny / lo % ikx_max , lo % nzed ) case ( 'xyzs' ) iz_idx_kxyz = - lo % nzgrid + mod (( i - lo % llim_world ) / lo % ikx_max / lo % ny , lo % nzed ) end select end function iz_idx_kxyz elemental function it_idx_kxyz ( lo , i ) implicit none integer :: it_idx_kxyz type ( kxyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i select case ( xyzs_layout ) case ( 'zyxs' ) it_idx_kxyz = 1 + mod (( i - lo % llim_world ) / lo % nzed , lo % ntubes ) case ( 'zxys' ) it_idx_kxyz = 1 + mod (( i - lo % llim_world ) / lo % nzed , lo % ntubes ) case ( 'yzxs' ) it_idx_kxyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % ny , lo % ntubes ) case ( 'xzys' ) it_idx_kxyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % ikx_max , lo % ntubes ) case ( 'yxzs' ) it_idx_kxyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % ny / lo % ikx_max , lo % ntubes ) case ( 'xyzs' ) it_idx_kxyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % ikx_max / lo % ny , lo % ntubes ) end select end function it_idx_kxyz elemental function proc_id_kxyz ( lo , i ) implicit none integer :: proc_id_kxyz type ( kxyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i proc_id_kxyz = i / lo % blocksize end function proc_id_kxyz elemental function idx_kxyz ( lo , iy , ikx , iz , it , is ) implicit none integer :: idx_kxyz type ( kxyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: iy , ikx , iz , it , is select case ( xyzs_layout ) case ( 'xyzs' ) idx_kxyz = ikx - 1 + lo % ikx_max * ( iy - 1 + lo % ny * ( iz + lo % nzgrid + lo % nzed * ( it - 1 + lo % ntubes * ( is - 1 )))) case ( 'xzys' ) idx_kxyz = ikx - 1 + lo % ikx_max * ( iz + lo % nzgrid + lo % nzed * ( it - 1 + lo % ntubes * ( iy - 1 + lo % ny * ( is - 1 )))) case ( 'yxzs' ) idx_kxyz = iy - 1 + lo % ny * ( ikx - 1 + lo % ikx_max * ( iz + lo % nzgrid + lo % nzed * ( it - 1 + lo % ntubes * ( is - 1 )))) case ( 'yzxs' ) idx_kxyz = iy - 1 + lo % ny * ( iz + lo % nzgrid + lo % nzed * ( it - 1 + lo % ntubes * ( ikx - 1 + lo % ikx_max * ( is - 1 )))) case ( 'zyxs' ) idx_kxyz = iz + lo % nzgrid + lo % nzed * ( it - 1 + lo % ntubes * ( iy - 1 + lo % ny * ( ikx - 1 ))) case ( 'zxys' ) idx_kxyz = iz + lo % nzgrid + lo % nzed * ( it - 1 + lo % ntubes * ( ikx - 1 + lo % ikx_max * ( iy - 1 ))) end select end function idx_kxyz elemental function idx_local_kxyz ( lo , iy , ikx , iz , it , is ) implicit none logical :: idx_local_kxyz type ( kxyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: iy , ikx , iz , it , is idx_local_kxyz = idx_local ( lo , idx ( lo , iy , ikx , iz , it , is )) end function idx_local_kxyz elemental function iz_local_kxyz ( lo , iz ) implicit none logical :: iz_local_kxyz type ( kxyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: iz iz_local_kxyz = lo % iproc == proc_id ( lo , iz ) end function iz_local_kxyz subroutine init_xyz_layout & ( nzgrid , ntubes , naky , nakx , nvgrid , nmu , nspec , ny , nx ) use mp , only : iproc , nproc implicit none integer , intent ( in ) :: nzgrid , ntubes , ny , nx , naky , nakx , nvgrid , nmu , nspec logical , save :: initialized = . false . if ( initialized ) return initialized = . true . xyz_lo % iproc = iproc xyz_lo % nzgrid = nzgrid xyz_lo % nzed = 2 * nzgrid + 1 xyz_lo % ntubes = ntubes xyz_lo % ny = ny xyz_lo % nx = nx xyz_lo % naky = naky xyz_lo % nakx = nakx xyz_lo % nvgrid = nvgrid xyz_lo % nvpa = 2 * nvgrid xyz_lo % nmu = nmu xyz_lo % nspec = nspec xyz_lo % llim_world = 0 xyz_lo % ulim_world = ny * nx * xyz_lo % nzed * xyz_lo % ntubes * nspec - 1 xyz_lo % blocksize = xyz_lo % ulim_world / nproc + 1 xyz_lo % llim_proc = xyz_lo % blocksize * iproc xyz_lo % ulim_proc = min ( xyz_lo % ulim_world , xyz_lo % llim_proc + xyz_lo % blocksize - 1 ) xyz_lo % ulim_alloc = max ( xyz_lo % llim_proc , xyz_lo % ulim_proc ) end subroutine init_xyz_layout elemental function is_idx_xyz ( lo , i ) implicit none integer :: is_idx_xyz type ( xyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i is_idx_xyz = 1 + mod (( i - lo % llim_world ) / lo % nx / lo % ny / lo % nzed / lo % ntubes , lo % nspec ) end function is_idx_xyz elemental function ix_idx_xyz ( lo , i ) implicit none integer :: ix_idx_xyz type ( xyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i select case ( xyzs_layout ) case ( 'xyzs' ) ix_idx_xyz = 1 + mod (( i - lo % llim_world ), lo % nx ) case ( 'xzys' ) ix_idx_xyz = 1 + mod (( i - lo % llim_world ), lo % nx ) case ( 'yxzs' ) ix_idx_xyz = 1 + mod (( i - lo % llim_world ) / lo % ny , lo % nx ) case ( 'zxys' ) ix_idx_xyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % ntubes , lo % nx ) case ( 'zyxs' ) ix_idx_xyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % ntubes / lo % ny , lo % nx ) case ( 'yzxs' ) ix_idx_xyz = 1 + mod (( i - lo % llim_world ) / lo % ny / lo % nzed / lo % ntubes , lo % nx ) end select end function ix_idx_xyz elemental function iy_idx_xyz ( lo , i ) implicit none integer :: iy_idx_xyz type ( xyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i select case ( xyzs_layout ) case ( 'yxzs' ) iy_idx_xyz = 1 + mod ( i - lo % llim_world , lo % ny ) case ( 'yzxs' ) iy_idx_xyz = 1 + mod ( i - lo % llim_world , lo % ny ) case ( 'xyzs' ) iy_idx_xyz = 1 + mod (( i - lo % llim_world ) / lo % nx , lo % ny ) case ( 'zyxs' ) iy_idx_xyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % ntubes , lo % ny ) case ( 'zxys' ) iy_idx_xyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % ntubes / lo % nx , lo % ny ) case ( 'xzys' ) iy_idx_xyz = 1 + mod (( i - lo % llim_world ) / lo % nx / lo % nzed / lo % ntubes , lo % ny ) end select end function iy_idx_xyz elemental function iz_idx_xyz ( lo , i ) implicit none integer :: iz_idx_xyz type ( xyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i select case ( xyzs_layout ) case ( 'zyxs' ) iz_idx_xyz = - lo % nzgrid + mod (( i - lo % llim_world ), lo % nzed ) case ( 'zxys' ) iz_idx_xyz = - lo % nzgrid + mod (( i - lo % llim_world ), lo % nzed ) case ( 'yzxs' ) iz_idx_xyz = - lo % nzgrid + mod (( i - lo % llim_world ) / lo % ny , lo % nzed ) case ( 'xzys' ) iz_idx_xyz = - lo % nzgrid + mod (( i - lo % llim_world ) / lo % nx , lo % nzed ) case ( 'yxzs' ) iz_idx_xyz = - lo % nzgrid + mod (( i - lo % llim_world ) / lo % ny / lo % nx , lo % nzed ) case ( 'xyzs' ) iz_idx_xyz = - lo % nzgrid + mod (( i - lo % llim_world ) / lo % nx / lo % ny , lo % nzed ) end select end function iz_idx_xyz elemental function it_idx_xyz ( lo , i ) implicit none integer :: it_idx_xyz type ( xyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i select case ( xyzs_layout ) case ( 'zyxs' ) it_idx_xyz = 1 + mod (( i - lo % llim_world ) / lo % nzed , lo % ntubes ) case ( 'zxys' ) it_idx_xyz = 1 + mod (( i - lo % llim_world ) / lo % nzed , lo % ntubes ) case ( 'yzxs' ) it_idx_xyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % ny , lo % ntubes ) case ( 'xzys' ) it_idx_xyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % nx , lo % ntubes ) case ( 'yxzs' ) it_idx_xyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % ny / lo % nx , lo % ntubes ) case ( 'xyzs' ) it_idx_xyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % nx / lo % ny , lo % ntubes ) end select end function it_idx_xyz elemental function proc_id_xyz ( lo , i ) implicit none integer :: proc_id_xyz type ( xyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i proc_id_xyz = i / lo % blocksize end function proc_id_xyz elemental function idx_xyz ( lo , iy , ix , iz , it , is ) implicit none integer :: idx_xyz type ( xyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: iy , ix , iz , it , is select case ( xyzs_layout ) case ( 'xyzs' ) idx_xyz = ix - 1 + lo % nx * ( iy - 1 + lo % ny * ( iz + lo % nzgrid + lo % nzed * ( it - 1 + lo % ntubes * ( is - 1 )))) case ( 'xzys' ) idx_xyz = ix - 1 + lo % nx * ( iz + lo % nzgrid + lo % nzed * ( it - 1 + lo % ntubes * ( iy - 1 + lo % ny * ( is - 1 )))) case ( 'yxzs' ) idx_xyz = iy - 1 + lo % ny * ( ix - 1 + lo % nx * ( iz + lo % nzgrid + lo % nzed * ( it - 1 + lo % ntubes * ( is - 1 )))) case ( 'yzxs' ) idx_xyz = iy - 1 + lo % ny * ( iz + lo % nzgrid + lo % nzed * ( it - 1 + lo % ntubes * ( ix - 1 + lo % nx * ( is - 1 )))) case ( 'zyxs' ) idx_xyz = iz + lo % nzgrid + lo % nzed * ( it - 1 + lo % ntubes * ( iy - 1 + lo % ny * ( ix - 1 ))) case ( 'zxys' ) idx_xyz = iz + lo % nzgrid + lo % nzed * ( it - 1 + lo % ntubes * ( ix - 1 + lo % nx * ( iy - 1 ))) end select end function idx_xyz elemental function idx_local_xyz ( lo , iy , ix , iz , it , is ) implicit none logical :: idx_local_xyz type ( xyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: iy , ix , iz , it , is idx_local_xyz = idx_local ( lo , idx ( lo , iy , ix , iz , it , is )) end function idx_local_xyz elemental function iz_local_xyz ( lo , iz ) implicit none logical :: iz_local_xyz type ( xyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: iz iz_local_xyz = lo % iproc == proc_id ( lo , iz ) end function iz_local_xyz subroutine init_vmu_layout & ( nzgrid , ntubes , naky , nakx , nvgrid , nmu , nspec , ny , nx , nalpha ) use mp , only : iproc , nproc implicit none integer , intent ( in ) :: nzgrid , ntubes , naky , nakx , nvgrid , nmu , nspec , ny , nx , nalpha logical , save :: initialized = . false . if ( initialized ) return initialized = . true . vmu_lo % xyz = . true . vmu_lo % iproc = iproc vmu_lo % nzed = 2 * nzgrid + 1 vmu_lo % nzgrid = nzgrid vmu_lo % ntubes = ntubes vmu_lo % ny = ny vmu_lo % nalpha = nalpha vmu_lo % naky = naky vmu_lo % nx = nx vmu_lo % nakx = nakx vmu_lo % nvgrid = nvgrid vmu_lo % nvpa = 2 * nvgrid vmu_lo % nmu = nmu vmu_lo % nspec = nspec vmu_lo % llim_world = 0 vmu_lo % ulim_world = vmu_lo % nvpa * nmu * nspec - 1 vmu_lo % blocksize = vmu_lo % ulim_world / nproc + 1 vmu_lo % llim_proc = vmu_lo % blocksize * iproc vmu_lo % ulim_proc = min ( vmu_lo % ulim_world , vmu_lo % llim_proc + vmu_lo % blocksize - 1 ) vmu_lo % ulim_alloc = max ( vmu_lo % llim_proc , vmu_lo % ulim_proc ) end subroutine init_vmu_layout elemental function is_idx_vmu ( lo , i ) implicit none integer :: is_idx_vmu type ( vmu_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i ! the order of the division does not matter, so no need for branching is_idx_vmu = 1 + mod (( i - lo % llim_world ) / lo % nvpa / lo % nmu , lo % nspec ) end function is_idx_vmu elemental function imu_idx_vmu ( lo , i ) implicit none integer :: imu_idx_vmu type ( vmu_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i select case ( vms_layout ) case ( 'vms' ) imu_idx_vmu = 1 + mod (( i - lo % llim_world ) / lo % nvpa , lo % nmu ) case ( 'mvs' ) imu_idx_vmu = 1 + mod (( i - lo % llim_world ), lo % nmu ) end select end function imu_idx_vmu elemental function iv_idx_vmu ( lo , i ) implicit none integer :: iv_idx_vmu type ( vmu_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i select case ( vms_layout ) case ( 'vms' ) iv_idx_vmu = 1 + mod (( i - lo % llim_world ), lo % nvpa ) case ( 'mvs' ) iv_idx_vmu = 1 + mod (( i - lo % llim_world ) / lo % nmu , lo % nvpa ) end select end function iv_idx_vmu elemental function proc_id_vmu ( lo , i ) implicit none integer :: proc_id_vmu type ( vmu_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i proc_id_vmu = i / lo % blocksize end function proc_id_vmu elemental function idx_vmu ( lo , iv , imu , is ) implicit none integer :: idx_vmu type ( vmu_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: iv , imu , is select case ( vms_layout ) case ( 'vms' ) idx_vmu = iv - 1 + lo % nvpa * ( imu - 1 + lo % nmu * ( is - 1 )) case ( 'mvs' ) idx_vmu = imu - 1 + lo % nmu * ( iv - 1 + lo % nvpa * ( is - 1 )) end select end function idx_vmu elemental function idx_local_vmu ( lo , iv , imu , is ) implicit none logical :: idx_local_vmu type ( vmu_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: iv , imu , is idx_local_vmu = idx_local ( lo , idx ( lo , iv , imu , is )) end function idx_local_vmu elemental function iz_local_vmu ( lo , iz ) implicit none logical :: iz_local_vmu type ( vmu_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: iz iz_local_vmu = lo % iproc == proc_id ( lo , iz ) end function iz_local_vmu elemental subroutine kxkyzidx2vmuidx ( iv , imu , ikxkyz , kxkyz_lo , vmu_lo , iky , ikx , iz , it , ivmu ) implicit none integer , intent ( in ) :: iv , imu , ikxkyz type ( kxkyz_layout_type ), intent ( in ) :: kxkyz_lo type ( vmu_layout_type ), intent ( in ) :: vmu_lo integer , intent ( out ) :: iky , ikx , iz , it , ivmu iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) ivmu = idx ( vmu_lo , iv , imu , is_idx ( kxkyz_lo , ikxkyz )) end subroutine kxkyzidx2vmuidx elemental subroutine kxyzidx2vmuidx ( iv , imu , ikxyz , kxyz_lo , vmu_lo , iy , ikx , iz , it , ivmu ) implicit none integer , intent ( in ) :: iv , imu , ikxyz type ( kxyz_layout_type ), intent ( in ) :: kxyz_lo type ( vmu_layout_type ), intent ( in ) :: vmu_lo integer , intent ( out ) :: iy , ikx , iz , it , ivmu iy = iy_idx ( kxyz_lo , ikxyz ) ikx = ikx_idx ( kxyz_lo , ikxyz ) iz = iz_idx ( kxyz_lo , ikxyz ) it = it_idx ( kxyz_lo , ikxyz ) ivmu = idx ( vmu_lo , iv , imu , is_idx ( kxyz_lo , ikxyz )) end subroutine kxyzidx2vmuidx elemental subroutine xyzidx2vmuidx ( iv , imu , ixyz , xyz_lo , vmu_lo , iy , ix , iz , it , ivmu ) implicit none integer , intent ( in ) :: iv , imu , ixyz type ( xyz_layout_type ), intent ( in ) :: xyz_lo type ( vmu_layout_type ), intent ( in ) :: vmu_lo integer , intent ( out ) :: iy , ix , iz , it , ivmu iy = iy_idx ( xyz_lo , ixyz ) ix = ix_idx ( xyz_lo , ixyz ) iz = iz_idx ( xyz_lo , ixyz ) it = it_idx ( xyz_lo , ixyz ) ivmu = idx ( vmu_lo , iv , imu , is_idx ( xyz_lo , ixyz )) end subroutine xyzidx2vmuidx subroutine finish_layouts implicit none end subroutine finish_layouts end module stella_layouts","tags":"","loc":"sourcefile/stella_layouts.f90.html"},{"title":"fields.fpp â€“ stella","text":"Contents Modules fields Source Code fields.fpp Source Code module fields use common_types , only : eigen_type #if defined MPI && defined ISO_C_BINDING use mpi #endif use common_types , only : coupled_alpha_type , gam0_ffs_type implicit none public :: init_fields , finish_fields public :: advance_fields , get_fields public :: get_radial_correction public :: enforce_reality_field public :: get_fields_by_spec , get_fields_by_spec_idx public :: gamtot_h , gamtot3_h public :: time_field_solve public :: fields_updated public :: get_dchidy , get_dchidx public :: efac , efacp private real , dimension (:, :, :), allocatable :: apar_denom real :: gamtot_h , gamtot3_h , efac , efacp complex , dimension (:, :), allocatable :: save1 , save2 !> arrays allocated/used if simulating a full flux surface type ( coupled_alpha_type ), dimension (:, :, :), allocatable :: gam0_ffs type ( gam0_ffs_type ), dimension (:, :), allocatable :: lu_gam0_ffs complex , dimension (:), allocatable :: adiabatic_response_factor logical :: fields_updated = . false . logical :: fields_initialized = . false . #if defined MPI && defined ISO_C_BINDING logical :: qn_window_initialized = . false . integer :: phi_shared_window = MPI_WIN_NULL #endif logical :: debug = . false . integer :: zm real , dimension ( 2 , 5 ) :: time_field_solve interface get_dchidy module procedure get_dchidy_4d module procedure get_dchidy_2d end interface get_dchidy contains subroutine init_fields use linear_solve , only : lu_decomposition use physics_flags , only : full_flux_surface implicit none if ( full_flux_surface ) then call init_fields_ffs else call init_fields_fluxtube end if end subroutine init_fields !> @todo would be tidier if the code related to radial profile variation !> were gathered into a separate subroutine or subroutines !> init_fields_fluxtube allocates and fills arrays needed during main time advance !> loop for the field solve for flux tube simulations subroutine init_fields_fluxtube use mp , only : sum_allreduce , job #if defined MPI && defined ISO_C_BINDING use , intrinsic :: iso_c_binding , only : c_ptr , c_f_pointer use fields_arrays , only : qn_window , phi_shared use mp , only : sgproc0 , curr_focus , mp_comm , sharedsubprocs use mp , only : scope , real_size , nbytes_real , iproc , nproc , proc0 use mpi #else #endif use stella_layouts , only : kxkyz_lo use stella_layouts , onlY : iz_idx , it_idx , ikx_idx , iky_idx , is_idx use dist_fn_arrays , only : kperp2 , dkperp2dr use gyro_averages , only : aj0v , aj1v use run_parameters , only : fphi , fapar use run_parameters , only : ky_solve_radial , ky_solve_real use physics_parameters , only : tite , nine , beta use physics_flags , only : radial_variation use species , only : spec , has_electron_species , ion_species use stella_geometry , only : dl_over_b , d_dl_over_b_drho , dBdrho , bmag use stella_transforms , only : transform_kx2x_xfirst , transform_x2kx_xfirst use stella_transforms , only : transform_kx2x_unpadded , transform_x2kx_unpadded use zgrid , only : nzgrid , ntubes , nztot use vpamu_grids , only : nvpa , nmu , mu use vpamu_grids , only : vpa , vperp2 use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use vpamu_grids , only : integrate_vmu use species , only : spec , nspec use kt_grids , only : naky , nakx , akx use kt_grids , only : zonal_mode , rho_d_clamped use physics_flags , only : adiabatic_option_switch use physics_flags , only : adiabatic_option_fieldlineavg use linear_solve , only : lu_decomposition , lu_inverse use multibox , only : init_mb_get_phi use fields_arrays , only : gamtot , dgamtotdr , gamtot3 , dgamtot3dr use fields_arrays , only : phi_solve , c_mat , theta use file_utils , only : runtype_option_switch , runtype_multibox implicit none integer :: ikxkyz , iz , it , ikx , iky , is , ia , zmi , naky_r real :: tmp , tmp2 , wgt , dum real , dimension (:, :), allocatable :: g0 real , dimension (:), allocatable :: g1 logical :: has_elec , adia_elec #if defined MPI && ISO_C_BINDING integer :: prior_focus , ierr integer :: counter , c_lo , c_hi , c_max , c_div , c_mod integer :: disp_unit = 1 integer * 8 :: cur_pos integer ( kind = MPI_ADDRESS_KIND ) :: win_size complex , dimension (:), pointer :: phi_shared_temp type ( c_ptr ) :: cptr #endif complex , dimension (:, :), allocatable :: g0k , g0x debug = debug . and . proc0 ia = 1 zm = 0 ! do not see why this is before fields_initialized check below call allocate_arrays if ( fields_initialized ) return fields_initialized = . true . ! could move these array allocations to allocate_arrays to clean up code if (. not . allocated ( gamtot )) allocate ( gamtot ( naky , nakx , - nzgrid : nzgrid )); gamtot = 0. if (. not . allocated ( gamtot3 )) then if (. not . has_electron_species ( spec ) & . and . adiabatic_option_switch == adiabatic_option_fieldlineavg ) then allocate ( gamtot3 ( nakx , - nzgrid : nzgrid )); gamtot3 = 0. else allocate ( gamtot3 ( 1 , 1 )); gamtot3 = 0. end if end if if (. not . allocated ( apar_denom )) then if ( fapar > epsilon ( 0.0 )) then allocate ( apar_denom ( naky , nakx , - nzgrid : nzgrid )); apar_denom = 0. else allocate ( apar_denom ( 1 , 1 , 1 )); apar_denom = 0. end if end if if ( radial_variation ) then if (. not . allocated ( dgamtotdr )) allocate ( dgamtotdr ( naky , nakx , - nzgrid : nzgrid )); dgamtotdr = 0. if (. not . allocated ( dgamtot3dr )) then if (. not . has_electron_species ( spec ) & . and . adiabatic_option_switch == adiabatic_option_fieldlineavg ) then allocate ( dgamtot3dr ( nakx , - nzgrid : nzgrid )); dgamtot3dr = 0. allocate ( save1 ( nakx , ntubes )); save1 = 0. allocate ( save2 ( nakx , ntubes )); save2 = 0. else allocate ( dgamtot3dr ( 1 , 1 )); dgamtot3dr = 0. end if end if else if (. not . allocated ( dgamtotdr )) allocate ( dgamtotdr ( 1 , 1 , 1 )); dgamtotdr = 0. if (. not . allocated ( dgamtot3dr )) allocate ( dgamtot3dr ( 1 , 1 )); dgamtot3dr = 0. end if if ( fphi > epsilon ( 0.0 )) then allocate ( g0 ( nvpa , nmu )) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc it = it_idx ( kxkyz_lo , ikxkyz ) ! gamtot does not depend on flux tube index, ! so only compute for one flux tube index if ( it /= 1 ) cycle iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) g0 = spread (( 1.0 - aj0v (:, ikxkyz ) ** 2 ), 1 , nvpa ) & * spread ( maxwell_vpa (:, is ), 2 , nmu ) * spread ( maxwell_mu ( ia , iz , :, is ), 1 , nvpa ) * maxwell_fac ( is ) wgt = spec ( is )% z * spec ( is )% z * spec ( is )% dens_psi0 / spec ( is )% temp call integrate_vmu ( g0 , iz , tmp ) gamtot ( iky , ikx , iz ) = gamtot ( iky , ikx , iz ) + tmp * wgt end do call sum_allreduce ( gamtot ) gamtot_h = sum ( spec % z * spec % z * spec % dens / spec % temp ) if ( radial_variation ) then allocate ( g1 ( nmu )) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc it = it_idx ( kxkyz_lo , ikxkyz ) ! gamtot does not depend on flux tube index, ! so only compute for one flux tube index if ( it /= 1 ) cycle iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) g1 = aj0v (:, ikxkyz ) * aj1v (:, ikxkyz ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 ( iky , ikx , ia , iz ) * vperp2 ( ia , iz , :) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr ( iky , ikx , ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) & / ( 1.0 - aj0v (:, ikxkyz ) ** 2 + 10 0. * epsilon ( 0.0 )) g0 = spread (( 1.0 - aj0v (:, ikxkyz ) ** 2 ), 1 , nvpa ) & * spread ( maxwell_vpa (:, is ), 2 , nmu ) * spread ( maxwell_mu ( ia , iz , :, is ), 1 , nvpa ) * maxwell_fac ( is ) & * ( - spec ( is )% tprim * ( spread ( vpa ** 2 , 2 , nmu ) + spread ( vperp2 ( ia , iz , :), 1 , nvpa ) - 2.5 ) & - spec ( is )% fprim + ( dBdrho ( iz ) / bmag ( ia , iz )) * ( 1.0 - 2.0 * spread ( mu , 1 , nvpa ) * bmag ( ia , iz )) & + spread ( g1 , 1 , nvpa )) wgt = spec ( is )% z * spec ( is )% z * spec ( is )% dens / spec ( is )% temp call integrate_vmu ( g0 , iz , tmp ) dgamtotdr ( iky , ikx , iz ) = dgamtotdr ( iky , ikx , iz ) + tmp * wgt end do call sum_allreduce ( dgamtotdr ) deallocate ( g1 ) end if ! avoid divide by zero when kx=ky=0 ! do not evolve this mode, so value is irrelevant if ( zonal_mode ( 1 ) . and . akx ( 1 ) < epsilon ( 0. ) . and . has_electron_species ( spec )) then gamtot ( 1 , 1 , :) = 0.0 dgamtotdr ( 1 , 1 , :) = 0.0 zm = 1 end if if (. not . has_electron_species ( spec )) then efac = tite / nine * ( spec ( ion_species )% dens / spec ( ion_species )% temp ) efacp = efac * ( spec ( ion_species )% tprim - spec ( ion_species )% fprim ) gamtot = gamtot + efac gamtot_h = gamtot_h + efac if ( radial_variation ) dgamtotdr = dgamtotdr + efacp if ( adiabatic_option_switch == adiabatic_option_fieldlineavg ) then if ( zonal_mode ( 1 )) then gamtot3_h = efac / ( sum ( spec % zt * spec % z * spec % dens )) do ikx = 1 , nakx ! avoid divide by zero for kx=ky=0 mode, ! which we do not need anyway !if (abs(akx(ikx)) < epsilon(0.)) cycle tmp = 1. / efac - sum ( dl_over_b ( ia , :) / gamtot ( 1 , ikx , :)) gamtot3 ( ikx , :) = 1. / ( gamtot ( 1 , ikx , :) * tmp ) if ( radial_variation ) then tmp2 = ( spec ( ion_species )% tprim - spec ( ion_species )% fprim ) / efac & + sum ( d_dl_over_b_drho ( ia , :) / gamtot ( 1 , ikx , :)) & - sum ( dl_over_b ( ia , :) * dgamtotdr ( 1 , ikx , :) & / gamtot ( 1 , ikx , :) ** 2 ) dgamtot3dr ( ikx , :) = gamtot3 ( ikx , :) & * ( - dgamtotdr ( 1 , ikx , :) / gamtot ( 1 , ikx , :) + tmp2 / tmp ) end if end do if ( akx ( 1 ) < epsilon ( 0. )) then gamtot3 ( 1 , :) = 0.0 dgamtot3dr ( 1 , :) = 0.0 end if end if end if end if if ( radial_variation . and . ky_solve_radial > 0 ) then naky_r = min ( naky , ky_solve_radial ) has_elec = has_electron_species ( spec ) adia_elec = . not . has_elec . and . zonal_mode ( 1 ) & . and . adiabatic_option_switch == adiabatic_option_fieldlineavg if ( runtype_option_switch == runtype_multibox . and . job == 1 . and . ky_solve_real ) then call init_mb_get_phi ( has_elec , adia_elec , efac , efacp ) elseif ( runtype_option_switch /= runtype_multibox . or . & ( job == 1 . and . . not . ky_solve_real )) then allocate ( g0k ( 1 , nakx )) allocate ( g0x ( 1 , nakx )) if (. not . allocated ( phi_solve )) allocate ( phi_solve ( naky_r , - nzgrid : nzgrid )) #if defined MPI && ISO_C_BINDING prior_focus = curr_focus call scope ( sharedsubprocs ) !the following is to parallelize the calculation of QN for radial variation sims if ( debug ) write ( * , * ) 'fields::init_fields::phi_shared_init' if ( phi_shared_window == MPI_WIN_NULL ) then win_size = 0 if ( sgproc0 ) then win_size = int ( naky * nakx * nztot * ntubes , MPI_ADDRESS_KIND ) * 2 * real_size !complex size end if call mpi_win_allocate_shared ( win_size , disp_unit , MPI_INFO_NULL , & mp_comm , cptr , phi_shared_window , ierr ) if (. not . sgproc0 ) then !make sure all the procs have the right memory address call mpi_win_shared_query ( phi_shared_window , 0 , win_size , disp_unit , cptr , ierr ) end if call mpi_win_fence ( 0 , phi_shared_window , ierr ) if (. not . associated ( phi_shared )) then ! associate array with lower bounds of 1 call c_f_pointer ( cptr , phi_shared_temp , ( / naky * nakx * nztot * ntubes / )) ! now get the correct bounds phi_shared ( 1 : naky , 1 : nakx , - nzgrid : nzgrid , 1 : ntubes ) => phi_shared_temp end if call mpi_win_fence ( 0 , phi_shared_window , ierr ) end if if ( debug ) write ( * , * ) 'fields::init_fields::qn_window_init' if ((. not . qn_window_initialized ) . or . ( qn_window == MPI_WIN_NULL )) then win_size = 0 if ( sgproc0 ) then win_size = int ( nakx * nztot * naky_r , MPI_ADDRESS_KIND ) * 4_MPI_ADDRESS_KIND & + int ( nakx ** 2 * nztot * naky_r , MPI_ADDRESS_KIND ) * 2 * real_size !complex size end if call mpi_win_allocate_shared ( win_size , disp_unit , MPI_INFO_NULL , & mp_comm , cptr , qn_window , ierr ) if (. not . sgproc0 ) then !make sure all the procs have the right memory address call mpi_win_shared_query ( qn_window , 0 , win_size , disp_unit , cptr , ierr ) end if call mpi_win_fence ( 0 , qn_window , ierr ) cur_pos = transfer ( cptr , cur_pos ) !allocate the memory do iky = 1 , naky_r zmi = 0 if ( iky == 1 ) zmi = zm !zero mode may or may not be included in matrix do iz = - nzgrid , nzgrid if (. not . associated ( phi_solve ( iky , iz )% zloc )) then allocate ( phi_solve ( iky , iz )% zloc ( nakx - zmi , nakx - zmi )) cptr = transfer ( cur_pos , cptr ) call c_f_pointer ( cptr , phi_solve ( iky , iz )% zloc , ( / nakx - zmi , nakx - zmi / )) end if cur_pos = cur_pos + ( nakx - zmi ) ** 2 * 2 * nbytes_real if (. not . associated ( phi_solve ( iky , iz )% idx )) then cptr = transfer ( cur_pos , cptr ) call c_f_pointer ( cptr , phi_solve ( iky , iz )% idx , ( / nakx - zmi / )) end if cur_pos = cur_pos + ( nakx - zmi ) * 4 end do end do call mpi_win_fence ( 0 , qn_window , ierr ) qn_window_initialized = . true . end if c_max = nztot * naky_r c_div = c_max / nproc c_mod = mod ( c_max , nproc ) c_lo = iproc * c_div + 1 + min ( iproc , c_mod ) c_hi = c_lo + c_div - 1 if ( iproc < c_mod ) c_hi = c_hi + 1 call scope ( prior_focus ) counter = 0 #else do iky = 1 , naky_r zmi = 0 if ( iky == 1 ) zmi = zm !zero mode may or may not be included in matrix do iz = - nzgrid , nzgrid if (. not . associated ( phi_solve ( iky , iz )% zloc )) & allocate ( phi_solve ( iky , iz )% zloc ( nakx - zmi , nakx - zmi )) if (. not . associated ( phi_solve ( iky , iz )% idx )) & allocate ( phi_solve ( iky , iz )% idx ( nakx - zmi )) end do end do #endif do iky = 1 , naky_r zmi = 0 if ( iky == 1 ) zmi = zm !zero mode may or may not be included in matrix do iz = - nzgrid , nzgrid #if defined MPI && ISO_C_BINDING counter = counter + 1 if (( counter >= c_lo ) . and . ( counter <= c_hi )) then #endif phi_solve ( iky , iz )% zloc = 0.0 phi_solve ( iky , iz )% idx = 0 do ikx = 1 + zmi , nakx g0k ( 1 , :) = 0.0 g0k ( 1 , ikx ) = dgamtotdr ( iky , ikx , iz ) call transform_kx2x_unpadded ( g0k , g0x ) g0x ( 1 , :) = rho_d_clamped * g0x ( 1 , :) call transform_x2kx_unpadded ( g0x , g0k ) !row column phi_solve ( iky , iz )% zloc (:, ikx - zmi ) = g0k ( 1 , ( 1 + zmi ):) phi_solve ( iky , iz )% zloc ( ikx - zmi , ikx - zmi ) = phi_solve ( iky , iz )% zloc ( ikx - zmi , ikx - zmi ) & + gamtot ( iky , ikx , iz ) end do call lu_decomposition ( phi_solve ( iky , iz )% zloc , phi_solve ( iky , iz )% idx , dum ) #if defined MPI && ISO_C_BINDING end if #endif end do end do if ( adia_elec ) then if (. not . allocated ( c_mat )) allocate ( c_mat ( nakx , nakx )); if (. not . allocated ( theta )) allocate ( theta ( nakx , nakx , - nzgrid : nzgrid )); !get C do ikx = 1 , nakx g0k ( 1 , :) = 0.0 g0k ( 1 , ikx ) = 1.0 call transform_kx2x_unpadded ( g0k , g0x ) g0x ( 1 , :) = ( efac + efacp * rho_d_clamped ) * g0x ( 1 , :) call transform_x2kx_unpadded ( g0x , g0k ) !row column c_mat (:, ikx ) = g0k ( 1 , :) end do !get Theta do iz = - nzgrid , nzgrid !get Theta do ikx = 1 , nakx g0k ( 1 , :) = 0.0 g0k ( 1 , ikx ) = dgamtotdr ( 1 , ikx , iz ) - efacp call transform_kx2x_unpadded ( g0k , g0x ) g0x ( 1 , :) = rho_d_clamped * g0x ( 1 , :) call transform_x2kx_unpadded ( g0x , g0k ) !row column theta (:, ikx , iz ) = g0k ( 1 , :) theta ( ikx , ikx , iz ) = theta ( ikx , ikx , iz ) + gamtot ( 1 , ikx , iz ) - efac end do end do end if deallocate ( g0k , g0x ) end if end if deallocate ( g0 ) end if if ( fapar > epsilon ( 0. )) then allocate ( g0 ( nvpa , nmu )) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc it = it_idx ( kxkyz_lo , ikxkyz ) ! apar_denom does not depend on flux tube index, ! so only compute for one flux tube index if ( it /= 1 ) cycle iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) g0 = spread ( maxwell_vpa (:, is ) * vpa ** 2 , 2 , nmu ) * maxwell_fac ( is ) & * spread ( maxwell_mu ( ia , iz , :, is ) * aj0v (:, ikxkyz ) ** 2 , 1 , nvpa ) wgt = 2.0 * beta * spec ( is )% z * spec ( is )% z * spec ( is )% dens / spec ( is )% mass call integrate_vmu ( g0 , iz , tmp ) apar_denom ( iky , ikx , iz ) = apar_denom ( iky , ikx , iz ) + tmp * wgt end do call sum_allreduce ( apar_denom ) apar_denom = apar_denom + kperp2 (:, :, ia , :) deallocate ( g0 ) end if end subroutine init_fields_fluxtube !> init_fields_ffs allocates and fills arrays needed during main time advance !> loop for the field solve for full_flux_surface simulations subroutine init_fields_ffs use species , only : modified_adiabatic_electrons implicit none if ( fields_initialized ) return fields_initialized = . true . !> allocate arrays such as phi that are needed !> throughout the simulation call allocate_arrays !> calculate and LU factorise the matrix multiplying the electrostatic potential in quasineutrality !> this involves the factor 1-Gamma_0(kperp(alpha)) call init_gamma0_factor_ffs !> if using a modified Boltzmann response for the electrons if ( modified_adiabatic_electrons ) then !> obtain the response of phi_homogeneous to a unit perturbation in flux-surface-averaged phi call init_adiabatic_response_factor end if end subroutine init_fields_ffs !> calculate and LU factorise the matrix multiplying the electrostatic potential in quasineutrality !> this involves the factor 1-Gamma_0(kperp(alpha)) subroutine init_gamma0_factor_ffs use spfunc , only : j0 use dist_fn_arrays , only : kperp2 use stella_transforms , only : transform_alpha2kalpha use physics_parameters , only : nine , tite use species , only : spec , nspec use species , only : adiabatic_electrons use zgrid , only : nzgrid use stella_geometry , only : bmag use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx , imu_idx , is_idx use kt_grids , only : nalpha , ikx_max , naky_all , naky use kt_grids , only : swap_kxky_ordered use vpamu_grids , only : vperp2 , maxwell_vpa , maxwell_mu , maxwell_fac use vpamu_grids , only : integrate_species use gyro_averages , only : band_lu_factorisation_ffs implicit none integer :: iky , ikx , iz , ia integer :: ivmu , iv , imu , is real :: arg real , dimension (:, :, :), allocatable :: kperp2_swap real , dimension (:), allocatable :: aj0_alpha , gam0_alpha real , dimension (:), allocatable :: wgts complex , dimension (:), allocatable :: gam0_kalpha if ( debug ) write ( * , * ) 'fields::init_fields::init_gamm0_factor_ffs' allocate ( kperp2_swap ( naky_all , ikx_max , nalpha )) allocate ( aj0_alpha ( vmu_lo % llim_proc : vmu_lo % ulim_alloc )) allocate ( gam0_alpha ( nalpha )) allocate ( gam0_kalpha ( naky )) !> wgts are species-dependent factors appearing in Gamma0 factor allocate ( wgts ( nspec )) wgts = spec % dens * spec % z ** 2 / spec % temp !> allocate gam0_ffs array, which will contain the Fourier coefficients in y !> of the Gamma0 factor that appears in quasineutrality if (. not . allocated ( gam0_ffs )) then allocate ( gam0_ffs ( naky_all , ikx_max , - nzgrid : nzgrid )) end if do iz = - nzgrid , nzgrid !> in calculating the Fourier coefficients for Gamma_0, change loop orders !> so that inner loop is over ivmu super-index; !> this is done because we must integrate over v-space and sum over species, !> and we want to minimise memory usage where possible (so, e.g., aj0_alpha need !> only be a function of ivmu and can be over-written for each (ia,iky,ikx)). do ia = 1 , nalpha call swap_kxky_ordered ( kperp2 (:, :, ia , iz ), kperp2_swap (:, :, ia )) end do do ikx = 1 , ikx_max do iky = 1 , naky_all do ia = 1 , nalpha !> get J0 for all vpar, mu, spec values do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) iv = iv_idx ( vmu_lo , ivmu ) !> calculate the argument of the Bessel function J0 arg = spec ( is )% bess_fac * spec ( is )% smz_psi0 * sqrt ( vperp2 ( ia , iz , imu ) * kperp2_swap ( iky , ikx , ia )) / bmag ( ia , iz ) !> compute J0 corresponding to the given argument arg aj0_alpha ( ivmu ) = j0 ( arg ) !> form coefficient needed to calculate 1-Gamma_0 aj0_alpha ( ivmu ) = ( 1.0 - aj0_alpha ( ivmu ) ** 2 ) & * maxwell_vpa ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) * maxwell_fac ( is ) end do !> calculate gamma0(kalpha,alpha,...) = sum_s Zs&#94;2 * ns / Ts int d3v (1-J0&#94;2)*F_{Maxwellian} !> note that v-space Jacobian contains alpha-dependent factor, B(z,alpha), !> but this is not a problem as we have yet to transform from alpha to k_alpha call integrate_species ( aj0_alpha , iz , wgts , gam0_alpha ( ia ), ia ) !> if Boltzmann response used, account for non-flux-surface-averaged component of electron density if ( adiabatic_electrons ) then gam0_alpha ( ia ) = gam0_alpha ( ia ) + tite / nine else if ( ikx == 1 . and . iky == naky ) then !> if kx = ky = 0, 1-Gam0 factor is zero; !> this leads to eqn of form 0 * phi_00 = int d3v g. !> hack for now is to set phi_00 = 0, as above inversion is singular. !> to avoid singular inversion, set gam0_alpha = 1.0 gam0_alpha ( ia ) = 1.0 end if end do !> fourier transform Gamma_0(alpha) from alpha to k_alpha space call transform_alpha2kalpha ( gam0_alpha , gam0_kalpha ) gam0_ffs ( iky , ikx , iz )% max_idx = naky !> allocate array to hold the Fourier coefficients if (. not . associated ( gam0_ffs ( iky , ikx , iz )% fourier )) & allocate ( gam0_ffs ( iky , ikx , iz )% fourier ( gam0_ffs ( iky , ikx , iz )% max_idx )) !> fill the array with the requisite coefficients gam0_ffs ( iky , ikx , iz )% fourier = gam0_kalpha (: gam0_ffs ( iky , ikx , iz )% max_idx ) !                call test_ffs_bessel_coefs (gam0_ffs(iky,ikx,iz)%fourier, gam0_alpha, iky, ikx, iz, gam0_ffs_unit) end do end do end do !> LU factorise array of gam0, using the LAPACK zgbtrf routine for banded matrices if (. not . allocated ( lu_gam0_ffs )) then allocate ( lu_gam0_ffs ( ikx_max , - nzgrid : nzgrid )) !          call test_band_lu_factorisation (gam0_ffs, lu_gam0_ffs) call band_lu_factorisation_ffs ( gam0_ffs , lu_gam0_ffs ) end if deallocate ( wgts ) deallocate ( kperp2_swap ) deallocate ( aj0_alpha , gam0_alpha ) deallocate ( gam0_kalpha ) end subroutine init_gamma0_factor_ffs !> solves Delta * phi_hom = -delta_{ky,0} * ne/Te for phi_hom !> this is the vector describing the response of phi_hom to a unit impulse in phi_fsa !> it is the sum over ky and integral over kx of this that is needed, and this !> is stored in adiabatic_response_factor subroutine init_adiabatic_response_factor use physics_parameters , only : nine , tite use zgrid , only : nzgrid use stella_transforms , only : transform_alpha2kalpha use kt_grids , only : naky , naky_all , ikx_max use gyro_averages , only : band_lu_solve_ffs use volume_averages , only : flux_surface_average_ffs implicit none integer :: ikx complex , dimension (:, :, :), allocatable :: adiabatic_response_vector allocate ( adiabatic_response_vector ( naky_all , ikx_max , - nzgrid : nzgrid )) if (. not . allocated ( adiabatic_response_factor )) allocate ( adiabatic_response_factor ( ikx_max )) !> adiabatic_response_vector is initialised to be the rhs of the equation for the !> 'homogeneous' part of phi, with a unit impulse assumed for the flux-surface-averaged phi !> only the ky=0 component contributes to the flux-surface-averaged potential adiabatic_response_vector = 0.0 adiabatic_response_vector ( naky , :, :) = tite / nine !> pass in the rhs and overwrite with the solution for phi_homogeneous call band_lu_solve_ffs ( lu_gam0_ffs , adiabatic_response_vector ) !> obtain the flux surface average of the response vector do ikx = 1 , ikx_max call flux_surface_average_ffs ( adiabatic_response_vector (:, ikx , :), adiabatic_response_factor ( ikx )) end do adiabatic_response_factor = 1.0 / ( 1.0 - adiabatic_response_factor ) deallocate ( adiabatic_response_vector ) end subroutine init_adiabatic_response_factor subroutine allocate_arrays use fields_arrays , only : phi , apar , phi_old use fields_arrays , only : phi_corr_QN , phi_corr_GA use fields_arrays , only : apar_corr_QN , apar_corr_GA use zgrid , only : nzgrid , ntubes use stella_layouts , only : vmu_lo use physics_flags , only : radial_variation use kt_grids , only : naky , nakx implicit none if (. not . allocated ( phi )) then allocate ( phi ( naky , nakx , - nzgrid : nzgrid , ntubes )) phi = 0. end if if (. not . allocated ( apar )) then allocate ( apar ( naky , nakx , - nzgrid : nzgrid , ntubes )) apar = 0. end if if (. not . allocated ( phi_old )) then allocate ( phi_old ( naky , nakx , - nzgrid : nzgrid , ntubes )) phi_old = 0. end if if (. not . allocated ( phi_corr_QN ) . and . radial_variation ) then allocate ( phi_corr_QN ( naky , nakx , - nzgrid : nzgrid , ntubes )) phi_corr_QN = 0. end if if (. not . allocated ( phi_corr_GA ) . and . radial_variation ) then allocate ( phi_corr_GA ( naky , nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) phi_corr_GA = 0. end if if (. not . allocated ( apar_corr_QN ) . and . radial_variation ) then !allocate (apar_corr(naky,nakx,-nzgrid:nzgrid,ntubes,vmu_lo%llim_proc:vmu_lo%ulim_alloc)) allocate ( apar_corr_QN ( 1 , 1 , 1 , 1 )) apar_corr_QN = 0. end if if (. not . allocated ( apar_corr_GA ) . and . radial_variation ) then !allocate (apar_corr(naky,nakx,-nzgrid:nzgrid,ntubes,vmu_lo%llim_proc:vmu_lo%ulim_alloc)) allocate ( apar_corr_GA ( 1 , 1 , 1 , 1 , 1 )) apar_corr_GA = 0. end if end subroutine allocate_arrays subroutine enforce_reality_field ( fin ) !DSO> while most of the modes in the box have reality built in (as we !     throw out half the kx-ky plane, modes with ky=0 do not have !     this enforcement built in. In theory this should not be a problem !     as these modes should be stable, but I made this function (and !     its relative in the dist file) just in case use kt_grids , only : nakx use zgrid , only : nzgrid implicit none complex , dimension (:, :, - nzgrid :, :), intent ( inout ) :: fin integer ikx fin ( 1 , 1 , :, :) = real ( fin ( 1 , 1 , :, :)) do ikx = 2 , nakx / 2 + 1 fin ( 1 , ikx , :, :) = 0.5 * ( fin ( 1 , ikx , :, :) + conjg ( fin ( 1 , nakx - ikx + 2 , :, :))) fin ( 1 , nakx - ikx + 2 , :, :) = conjg ( fin ( 1 , ikx , :, :)) end do end subroutine enforce_reality_field subroutine advance_fields ( g , phi , apar , dist ) use mp , only : proc0 use stella_layouts , only : vmu_lo use job_manage , only : time_message use redistribute , only : scatter use dist_fn_arrays , only : gvmu use zgrid , only : nzgrid use dist_redistribute , only : kxkyz2vmu use run_parameters , only : fields_kxkyz use physics_flags , only : full_flux_surface implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( inout ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( out ) :: phi , apar character ( * ), intent ( in ) :: dist if ( fields_updated ) return !> time the communications + field solve if ( proc0 ) call time_message (. false ., time_field_solve (:, 1 ), ' fields' ) !> fields_kxkyz = F is the default if ( fields_kxkyz ) then !> first gather (vpa,mu) onto processor for v-space operations !> v-space operations are field solve, dg/dvpa, and collisions if ( debug ) write ( * , * ) 'dist_fn::advance_stella::scatter' if ( proc0 ) call time_message (. false ., time_field_solve (:, 2 ), ' fields_redist' ) call scatter ( kxkyz2vmu , g , gvmu ) if ( proc0 ) call time_message (. false ., time_field_solve (:, 2 ), ' fields_redist' ) !> given gvmu with vpa and mu local, calculate the corresponding fields if ( debug ) write ( * , * ) 'dist_fn::advance_stella::get_fields' call get_fields ( gvmu , phi , apar , dist ) else if ( full_flux_surface ) then if ( debug ) write ( * , * ) 'fields::advance_fields::get_fields_ffs' call get_fields_ffs ( g , phi , apar ) else call get_fields_vmulo ( g , phi , apar , dist ) end if end if !> set a flag to indicate that the fields have been updated !> this helps avoid unnecessary field solves fields_updated = . true . !> time the communications + field solve if ( proc0 ) call time_message (. false ., time_field_solve (:, 1 ), ' fields' ) end subroutine advance_fields subroutine get_fields ( g , phi , apar , dist , skip_fsa ) use mp , only : proc0 use mp , only : sum_allreduce , mp_abort use job_manage , only : time_message use stella_layouts , only : kxkyz_lo use stella_layouts , only : iz_idx , it_idx , ikx_idx , iky_idx , is_idx use dist_fn_arrays , only : kperp2 use gyro_averages , only : gyro_average use run_parameters , only : fphi , fapar use physics_parameters , only : beta use zgrid , only : nzgrid , ntubes use vpamu_grids , only : nvpa , nmu use vpamu_grids , only : vpa use vpamu_grids , only : integrate_vmu use species , only : spec implicit none complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( inout ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( out ) :: phi , apar logical , optional , intent ( in ) :: skip_fsa character ( * ), intent ( in ) :: dist complex :: tmp real :: wgt complex , dimension (:, :), allocatable :: g0 integer :: ikxkyz , iz , it , ikx , iky , is , ia logical :: skip_fsa_local skip_fsa_local = . false . if ( present ( skip_fsa )) skip_fsa_local = skip_fsa if ( debug ) write ( * , * ) 'dist_fn::advance_stella::get_fields_kxkyzlo' ia = 1 phi = 0. if ( fphi > epsilon ( 0.0 )) then if ( proc0 ) call time_message (. false ., time_field_solve (:, 3 ), ' int_dv_g' ) allocate ( g0 ( nvpa , nmu )) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iky = iky_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) call gyro_average ( g (:, :, ikxkyz ), ikxkyz , g0 ) wgt = spec ( is )% z * spec ( is )% dens_psi0 call integrate_vmu ( g0 , iz , tmp ) phi ( iky , ikx , iz , it ) = phi ( iky , ikx , iz , it ) + wgt * tmp end do deallocate ( g0 ) call sum_allreduce ( phi ) if ( proc0 ) call time_message (. false ., time_field_solve (:, 3 ), ' int_dv_g' ) call get_phi ( phi , dist , skip_fsa_local ) end if apar = 0. if ( fapar > epsilon ( 0.0 )) then allocate ( g0 ( nvpa , nmu )) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iky = iky_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) call gyro_average ( spread ( vpa , 2 , nmu ) * g (:, :, ikxkyz ), ikxkyz , g0 ) wgt = 2.0 * beta * spec ( is )% z * spec ( is )% dens * spec ( is )% stm call integrate_vmu ( g0 , iz , tmp ) apar ( iky , ikx , iz , it ) = apar ( iky , ikx , iz , it ) + tmp * wgt end do call sum_allreduce ( apar ) if ( dist == 'h' ) then apar = apar / spread ( kperp2 (:, :, ia , :), 4 , ntubes ) else if ( dist == 'gbar' ) then apar = apar / spread ( apar_denom , 4 , ntubes ) else if ( dist == 'gstar' ) then write ( * , * ) 'APAR NOT SETUP FOR GSTAR YET. aborting.' call mp_abort ( 'APAR NOT SETUP FOR GSTAR YET. aborting.' ) else if ( proc0 ) write ( * , * ) 'unknown dist option in get_fields. aborting' call mp_abort ( 'unknown dist option in get_fields. aborting' ) end if deallocate ( g0 ) end if end subroutine get_fields subroutine get_fields_vmulo ( g , phi , apar , dist , skip_fsa ) use mp , only : mp_abort , sum_allreduce , proc0 use job_manage , only : time_message use stella_layouts , only : vmu_lo use stella_layouts , only : imu_idx , is_idx use gyro_averages , only : gyro_average , aj0x , aj1x use run_parameters , only : fphi , fapar use stella_geometry , only : dBdrho , bmag use physics_flags , only : radial_variation use dist_fn_arrays , only : kperp2 , dkperp2dr use zgrid , only : nzgrid , ntubes use vpamu_grids , only : integrate_species , vperp2 use kt_grids , only : nakx , naky , multiply_by_rho use run_parameters , only : ky_solve_radial use species , only : spec implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( out ) :: phi , apar logical , optional , intent ( in ) :: skip_fsa character ( * ), intent ( in ) :: dist integer :: ivmu , iz , it , ia , imu , is , iky logical :: skip_fsa_local complex , dimension (:, :, :), allocatable :: gyro_g complex , dimension (:, :), allocatable :: g0k skip_fsa_local = . false . if ( present ( skip_fsa )) skip_fsa_local = skip_fsa if ( debug ) write ( * , * ) 'dist_fn::advance_stella::get_fields_vmulo' ia = 1 phi = 0. if ( fphi > epsilon ( 0.0 )) then if ( proc0 ) call time_message (. false ., time_field_solve (:, 3 ), ' int_dv_g' ) allocate ( g0k ( naky , nakx )) allocate ( gyro_g ( naky , nakx , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) ! loop over flux tubes in flux tube train do it = 1 , ntubes ! loop over zed location within flux tube do iz = - nzgrid , nzgrid ! loop over super-index ivmu, which include vpa, mu and spec do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc ! is = species index is = is_idx ( vmu_lo , ivmu ) ! imu = mu index imu = imu_idx ( vmu_lo , ivmu ) ! gyroaverage the distribution function g at each phase space location call gyro_average ( g (:, :, iz , it , ivmu ), iz , ivmu , gyro_g (:, :, ivmu )) ! <g> requires modification if radial profile variation is included if ( radial_variation ) then g0k = 0.0 do iky = 1 , min ( ky_solve_radial , naky ) g0k ( iky , :) = gyro_g ( iky , :, ivmu ) & * ( - 0.5 * aj1x ( iky , :, iz , ivmu ) / aj0x ( iky , :, iz , ivmu ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 ( iky , :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr ( iky , :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) & + dBdrho ( iz ) / bmag ( ia , iz )) end do !g0k(1,1) = 0. call multiply_by_rho ( g0k ) gyro_g (:, :, ivmu ) = gyro_g (:, :, ivmu ) + g0k end if end do ! integrate <g> over velocity space and sum over species within each processor ! as v-space and species possibly spread over processors, wlil need to ! gather sums from each proceessor and sum them all together below call integrate_species ( gyro_g , iz , spec % z * spec % dens_psi0 , phi (:, :, iz , it ), reduce_in = . false .) end do end do ! no longer need <g>, so deallocate deallocate ( gyro_g ) if ( debug ) write ( * , * ) 'dist_fn::advance_stella::sum_all_reduce' !> gather sub-sums from each processor and add them together !> store result in phi, which will be further modified below to account for polarization term call sum_allreduce ( phi ) if ( proc0 ) call time_message (. false ., time_field_solve (:, 3 ), ' int_dv_g' ) call get_phi ( phi , dist , skip_fsa_local ) end if apar = 0. if ( fapar > epsilon ( 0.0 )) then ! FLAG -- NEW LAYOUT NOT YET SUPPORTED !! call mp_abort ( 'APAR NOT YET SUPPORTED FOR NEW FIELD SOLVE. ABORTING.' ) !        allocate (g0(-nvgrid:nvgrid,nmu)) !        do ikxkyz = kxkyz_lo%llim_proc, kxkyz_lo%ulim_proc !           iz = iz_idx(kxkyz_lo,ikxkyz) !           ikx = ikx_idx(kxkyz_lo,ikxkyz) !           iky = iky_idx(kxkyz_lo,ikxkyz) !           is = is_idx(kxkyz_lo,ikxkyz) !           g0 = spread(aj0v(:,ikxkyz),1,nvpa)*spread(vpa,2,nmu)*g(:,:,ikxkyz) !           wgt = 2.0*beta*spec(is)%z*spec(is)%dens*spec(is)%stm !           call integrate_vmu (g0, iz, tmp) !           apar(iky,ikx,iz) = apar(iky,ikx,iz) + tmp*wgt !        end do !        call sum_allreduce (apar) !        if (dist == 'h') then !           apar = apar/kperp2 !        else if (dist == 'gbar') then !           apar = apar/apar_denom !        else if (dist == 'gstar') then !           write (*,*) 'APAR NOT SETUP FOR GSTAR YET. aborting.' !           call mp_abort('APAR NOT SETUP FOR GSTAR YET. aborting.') !        else !           if (proc0) write (*,*) 'unknown dist option in get_fields. aborting' !           call mp_abort ('unknown dist option in get_fields. aborting') !        end if !        deallocate (g0) end if end subroutine get_fields_vmulo !> get_fields_ffs accepts as input the guiding centre distribution function g !> and calculates/returns the electronstatic potential phi for full_flux_surface simulations subroutine get_fields_ffs ( g , phi , apar ) use mp , only : mp_abort use physics_parameters , only : nine , tite use stella_layouts , only : vmu_lo use run_parameters , only : fphi , fapar use species , only : modified_adiabatic_electrons , adiabatic_electrons use zgrid , only : nzgrid use kt_grids , only : nakx , ikx_max , naky , naky_all use kt_grids , only : swap_kxky_ordered use volume_averages , only : flux_surface_average_ffs implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( out ) :: phi , apar integer :: iz , ikx complex , dimension (:), allocatable :: phi_fsa complex , dimension (:, :, :), allocatable :: phi_swap , source if ( fphi > epsilon ( 0.0 )) then allocate ( source ( naky , nakx , - nzgrid : nzgrid )) !> calculate the contribution to quasineutrality coming from the velocity space !> integration of the guiding centre distribution function g; !> the sign is consistent with phi appearing on the RHS of the eqn and int g appearing on the LHS. !> this is returned in source if ( debug ) write ( * , * ) 'fields::advance_fields::get_fields_ffs::get_g_integral_contribution' call get_g_integral_contribution ( g , source ) !> use sum_s int d3v <g> and QN to solve for phi !> NB: assuming here that ntubes = 1 for FFS sim if ( debug ) write ( * , * ) 'fields::advance_fields::get_phi_ffs' call get_phi_ffs ( source , phi (:, :, :, 1 )) !> if using a modified Boltzmann response for the electrons, then phi !> at this stage is the 'inhomogeneous' part of phi. if ( modified_adiabatic_electrons ) then !> first must get phi on grid that includes positive and negative ky (but only positive kx) allocate ( phi_swap ( naky_all , ikx_max , - nzgrid : nzgrid )) if ( debug ) write ( * , * ) 'fields::advance_fields::get_fields_ffs::swap_kxky_ordered' do iz = - nzgrid , nzgrid call swap_kxky_ordered ( phi (:, :, iz , 1 ), phi_swap (:, :, iz )) end do !> calculate the flux surface average of this phi_inhomogeneous allocate ( phi_fsa ( nakx )) if ( debug ) write ( * , * ) 'fields::advance_fields::get_fields_ffs::flux_surface_average_ffs' do ikx = 1 , nakx call flux_surface_average_ffs ( phi_swap (:, ikx , :), phi_fsa ( ikx )) end do !> use the flux surface average of phi_inhomogeneous, together with the !> adiabatic_response_factor, to obtain the flux-surface-averaged phi phi_fsa = phi_fsa * adiabatic_response_factor !> use the computed flux surface average of phi as an additional sosurce in quasineutrality !> to obtain the electrostatic potential; only affects the ky=0 component of QN do ikx = 1 , nakx source ( 1 , ikx , :) = source ( 1 , ikx , :) + phi_fsa ( ikx ) * tite / nine end do if ( debug ) write ( * , * ) 'fields::advance_fields::get_fields_ffs::get_phi_ffs2s' call get_phi_ffs ( source , phi (:, :, :, 1 )) deallocate ( phi_swap , phi_fsa ) end if deallocate ( source ) else if (. not . adiabatic_electrons ) then !> if adiabatic electrons are not employed, then !> no explicit equation for the ky=kx=0 component of phi; !> hack for now is to set it equal to zero. phi ( 1 , 1 , :, :) = 0. end if apar = 0. if ( fapar > epsilon ( 0.0 )) then call mp_abort ( 'apar not yet supported for full_flux_surface = T. aborting.' ) end if contains subroutine get_g_integral_contribution ( g , source ) use mp , only : sum_allreduce use stella_layouts , only : vmu_lo use species , only : spec use zgrid , only : nzgrid use kt_grids , only : naky , nakx use vpamu_grids , only : integrate_species_ffs use gyro_averages , only : gyro_average , j0_B_maxwell_ffs implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :), intent ( in out ) :: source integer :: it , iz , ivmu complex , dimension (:, :, :), allocatable :: gyro_g !> assume there is only a single flux surface being simulated it = 1 allocate ( gyro_g ( naky , nakx , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) !> loop over zed location within flux tube do iz = - nzgrid , nzgrid !> loop over super-index ivmu, which include vpa, mu and spec do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc !> gyroaverage the distribution function g at each phase space location call gyro_average ( g (:, :, iz , it , ivmu ), gyro_g (:, :, ivmu ), j0_B_maxwell_ffs (:, :, iz , ivmu )) end do !> integrate <g> over velocity space and sum over species within each processor !> as v-space and species possibly spread over processors, wlil need to !> gather sums from each proceessor and sum them all together below call integrate_species_ffs ( gyro_g , spec % z * spec % dens_psi0 , source (:, :, iz ), reduce_in = . false .) end do !> gather sub-sums from each processor and add them together !> store result in phi, which will be further modified below to account for polarization term call sum_allreduce ( source ) !> no longer need <g>, so deallocate deallocate ( gyro_g ) end subroutine get_g_integral_contribution end subroutine get_fields_ffs subroutine get_fields_by_spec ( g , fld , skip_fsa ) use mp , only : sum_allreduce use stella_layouts , only : kxkyz_lo use stella_layouts , only : iz_idx , it_idx , ikx_idx , iky_idx , is_idx use gyro_averages , only : gyro_average use run_parameters , only : fphi use stella_geometry , only : dl_over_b use zgrid , only : nzgrid , ntubes use vpamu_grids , only : nvpa , nmu use vpamu_grids , only : integrate_vmu use kt_grids , only : nakx use kt_grids , only : zonal_mode use species , only : spec , nspec , has_electron_species use physics_flags , only : adiabatic_option_switch use physics_flags , only : adiabatic_option_fieldlineavg implicit none complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :, :), intent ( out ) :: fld logical , optional , intent ( in ) :: skip_fsa real :: wgt complex , dimension (:, :), allocatable :: g0 integer :: ikxkyz , iz , it , ikx , iky , is , ia logical :: skip_fsa_local complex , dimension ( nspec ) :: tmp skip_fsa_local = . false . if ( present ( skip_fsa )) skip_fsa_local = skip_fsa if ( debug ) write ( * , * ) 'dist_fn::advance_stella::get_fields_by_spec' ia = 1 fld = 0. if ( fphi > epsilon ( 0.0 )) then allocate ( g0 ( nvpa , nmu )) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iky = iky_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) wgt = spec ( is )% z * spec ( is )% dens_psi0 call gyro_average ( g (:, :, ikxkyz ), ikxkyz , g0 ) g0 = g0 * wgt call integrate_vmu ( g0 , iz , fld ( iky , ikx , iz , it , is )) end do call sum_allreduce ( fld ) fld = fld / gamtot_h if (. not . has_electron_species ( spec ) . and . (. not . skip_fsa_local ) . and . & adiabatic_option_switch == adiabatic_option_fieldlineavg ) then if ( zonal_mode ( 1 )) then do ikx = 1 , nakx do it = 1 , ntubes do is = 1 , nspec tmp ( is ) = sum ( dl_over_b ( ia , :) * fld ( 1 , ikx , :, it , is )) fld ( 1 , ikx , :, it , is ) = fld ( 1 , ikx , :, it , is ) + tmp ( is ) * gamtot3_h end do end do end do end if end if deallocate ( g0 ) end if end subroutine get_fields_by_spec subroutine get_fields_by_spec_idx ( isa , g , fld ) ! apply phi_isa[ ] to all species indices contained in g ! ie get phi_isa[g_is1], phi_isa[g_is2], phi_isa[g_is3] ... use mp , only : sum_allreduce use stella_layouts , only : kxkyz_lo use stella_layouts , only : iz_idx , it_idx , ikx_idx , iky_idx , is_idx use gyro_averages , only : gyro_average use run_parameters , only : fphi use stella_geometry , only : dl_over_b , bmag use zgrid , only : nzgrid , ntubes use vpamu_grids , only : vperp2 , nvpa , nmu use vpamu_grids , only : integrate_vmu use kt_grids , only : nakx use kt_grids , only : zonal_mode use species , only : spec , nspec , has_electron_species use physics_flags , only : adiabatic_option_switch use physics_flags , only : adiabatic_option_fieldlineavg use dist_fn_arrays , only : kperp2 use spfunc , only : j0 implicit none complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :, :), intent ( out ) :: fld integer , intent ( in ) :: isa complex , dimension (:, :), allocatable :: g0 integer :: ikxkyz , iz , it , ikx , iky , is , ia , imu complex , dimension ( nspec ) :: tmp real :: wgt real :: arg ia = 1 fld = 0. if ( fphi > epsilon ( 0.0 )) then allocate ( g0 ( nvpa , nmu )) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iky = iky_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) wgt = spec ( isa )% z * spec ( isa )% dens do imu = 1 , nmu ! AVB: changed this for use of j0, check arg = spec ( isa )% bess_fac * spec ( isa )% smz_psi0 * sqrt ( vperp2 ( ia , iz , imu ) * kperp2 ( iky , ikx , ia , iz )) / bmag ( ia , iz ) g0 (:, imu ) = g (:, imu , ikxkyz ) * j0 ( arg ) ! AVB: gyroaverage end do g0 = g0 * wgt call integrate_vmu ( g0 , iz , fld ( iky , ikx , iz , it , is )) end do call sum_allreduce ( fld ) fld = fld / gamtot_h if (. not . has_electron_species ( spec ) . and . & adiabatic_option_switch == adiabatic_option_fieldlineavg ) then if ( zonal_mode ( 1 )) then do ikx = 1 , nakx do it = 1 , ntubes do is = 1 , nspec tmp ( is ) = sum ( dl_over_b ( ia , :) * fld ( 1 , ikx , :, it , is )) fld ( 1 , ikx , :, it , is ) = fld ( 1 , ikx , :, it , is ) + tmp ( is ) * gamtot3_h end do end do end do end if end if deallocate ( g0 ) end if end subroutine get_fields_by_spec_idx subroutine get_phi ( phi , dist , skip_fsa ) use mp , only : proc0 , mp_abort , job #if defined MPI && ISO_C_BINDING use mpi use mp , only : proc0 , iproc , nproc , sgproc0 , comm_sgroup use mp , only : curr_focus , sharedsubprocs , scope use zgrid , only : nztot use fields_arrays , only : qn_zf_window , phi_shared use mp_lu_decomposition , only : lu_matrix_multiply_local #endif use job_manage , only : time_message use physics_flags , only : full_flux_surface , radial_variation use run_parameters , only : ky_solve_radial , ky_solve_real use zgrid , only : nzgrid , ntubes use stella_transforms , only : transform_kx2x_unpadded , transform_x2kx_unpadded use stella_geometry , only : dl_over_b , d_dl_over_b_drho use kt_grids , only : nakx , naky , zonal_mode , swap_kxky_ordered use kt_grids , only : boundary_size , rho_d_clamped use linear_solve , only : lu_back_substitution use physics_flags , only : adiabatic_option_switch use physics_flags , only : adiabatic_option_fieldlineavg use species , only : spec , has_electron_species use multibox , only : mb_get_phi use fields_arrays , only : gamtot , gamtot3 , phi_solve , phizf_solve , phi_ext use fields_arrays , only : phi_proj , phi_proj_stage , theta use fields_arrays , only : exclude_boundary_regions_qn , exp_fac_qn , tcorr_source_qn use file_utils , only : runtype_option_switch , runtype_multibox implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in out ) :: phi logical , optional , intent ( in ) :: skip_fsa integer :: ia , it , iz , ikx , iky , zmi integer :: inmat , naky_r complex , dimension (:, :), allocatable :: g0k , g1k , g0x , g0a complex :: tmp logical :: skip_fsa_local logical :: has_elec , adia_elec #if defined MPI && ISO_C_BINDING integer :: counter , c_lo , c_hi , c_max , c_div , c_mod integer :: prior_focus , ierr #endif character ( * ), intent ( in ) :: dist if ( debug ) write ( * , * ) 'dist_fn::advance_stella::get_phi' skip_fsa_local = . false . if ( present ( skip_fsa )) skip_fsa_local = skip_fsa ia = 1 has_elec = has_electron_species ( spec ) adia_elec = . not . has_elec & . and . adiabatic_option_switch == adiabatic_option_fieldlineavg if ( proc0 ) call time_message (. false ., time_field_solve (:, 4 ), ' get_phi' ) if ( dist == 'h' ) then phi = phi / gamtot_h else if ( dist == 'gbar' ) then if (( radial_variation . and . ky_solve_radial > 0 & . and . runtype_option_switch /= runtype_multibox ) & . or . & !DSO -> sorry for this if statement ( radial_variation . and . ky_solve_radial > 0 . and . job == 1 & . and . runtype_option_switch == runtype_multibox & . and . . not . ky_solve_real )) then allocate ( g0k ( 1 , nakx )) allocate ( g0x ( 1 , nakx )) allocate ( g0a ( 1 , nakx )) naky_r = min ( naky , ky_solve_radial ) #if defined MPI && ISO_C_BINDING prior_focus = curr_focus call scope ( sharedsubprocs ) c_max = nztot * ntubes * naky_r c_div = c_max / nproc c_mod = mod ( c_max , nproc ) c_lo = iproc * c_div + 1 + min ( iproc , c_mod ) c_hi = c_lo + c_div - 1 if ( iproc < c_mod ) c_hi = c_hi + 1 call scope ( prior_focus ) counter = 0 if ( sgproc0 ) phi_shared = phi call mpi_win_fence ( 0 , phi_shared_window , ierr ) #endif do it = 1 , ntubes do iz = - nzgrid , nzgrid do iky = 1 , naky_r #if defined MPI && ISO_C_BINDING counter = counter + 1 if (( counter >= c_lo ) . and . ( counter <= c_hi )) then if (. not . ( adia_elec . and . zonal_mode ( iky ))) then zmi = 0 if ( iky == 1 ) zmi = zm !zero mode may or may not be included in matrix call lu_back_substitution ( phi_solve ( iky , iz )% zloc , & phi_solve ( iky , iz )% idx , phi_shared ( iky , ( 1 + zmi ):, iz , it )) if ( zmi > 0 ) phi ( iky , zmi , iz , it ) = 0.0 end if end if #else if (. not . ( adia_elec . and . zonal_mode ( iky ))) then zmi = 0 if ( iky == 1 ) zmi = zm !zero mode may or may not be included in matrix call lu_back_substitution ( phi_solve ( iky , iz )% zloc , & phi_solve ( iky , iz )% idx , phi ( iky , ( 1 + zmi ):, iz , it )) if ( zmi > 0 ) phi ( iky , zmi , iz , it ) = 0.0 end if #endif end do end do end do #if defined MPI && ISO_C_BINDING call mpi_win_fence ( 0 , phi_shared_window , ierr ) phi = phi_shared #endif do it = 1 , ntubes do iz = - nzgrid , nzgrid do iky = naky_r , naky phi ( iky , :, iz , it ) = phi ( iky , :, iz , it ) / gamtot ( iky , :, iz ) end do end do end do if ( ky_solve_radial == 0 . and . any ( gamtot ( 1 , 1 , :) < epsilon ( 0. ))) & phi ( 1 , 1 , :, :) = 0.0 deallocate ( g0k , g0x , g0a ) else if ( radial_variation . and . ky_solve_radial > 0 . and . job == 1 & . and . runtype_option_switch == runtype_multibox ) then call mb_get_phi ( phi , has_elec , adia_elec ) else ! divide <g> by sum_s (\\Gamma_0s-1) Zs&#94;2*e*ns/Ts to get phi phi = phi / spread ( gamtot , 4 , ntubes ) if ( any ( gamtot ( 1 , 1 , :) < epsilon ( 0. ))) phi ( 1 , 1 , :, :) = 0.0 end if else if ( proc0 ) write ( * , * ) 'unknown dist option in get_fields. aborting' call mp_abort ( 'unknown dist option in get_fields. aborting' ) return end if if ( any ( gamtot ( 1 , 1 , :) < epsilon ( 0. ))) phi ( 1 , 1 , :, :) = 0.0 if ( proc0 ) call time_message (. false ., time_field_solve (:, 4 ), ' get_phi' ) if ( proc0 ) call time_message (. false ., time_field_solve (:, 5 ), 'get_phi_adia_elec' ) if ( adia_elec . and . zonal_mode ( 1 ) . and . . not . skip_fsa_local ) then if ( debug ) write ( * , * ) 'dist_fn::advance_stella::adiabatic_electrons' if ( dist == 'h' ) then do it = 1 , ntubes do ikx = 1 , nakx tmp = sum ( dl_over_b ( ia , :) * phi ( 1 , ikx , :, it )) phi ( 1 , ikx , :, it ) = phi ( 1 , ikx , :, it ) + tmp * gamtot3_h end do end do else if ( dist == 'gbar' ) then if ( radial_variation . and . ky_solve_radial > 0 . and . job == 1 & . and . runtype_option_switch == runtype_multibox . and . ky_solve_real ) then !this is already taken care of in mb_get_phi elseif (( radial_variation . and . ky_solve_radial > 0 & . and . runtype_option_switch /= runtype_multibox ) & . or . & ( radial_variation . and . ky_solve_radial > 0 . and . job == 1 & . and . runtype_option_switch == runtype_multibox & . and . . not . ky_solve_real )) then allocate ( g0k ( 1 , nakx )) allocate ( g1k ( 1 , nakx )) allocate ( g0x ( 1 , nakx )) do it = 1 , ntubes ! calculate <<g>_psi>_T g1k = 0.0 do iz = - nzgrid , nzgrid - 1 g0k ( 1 , :) = phi ( 1 , :, iz , it ) call transform_kx2x_unpadded ( g0k , g0x ) g0x ( 1 , :) = ( dl_over_b ( ia , iz ) + d_dl_over_b_drho ( ia , iz ) * rho_d_clamped ) * g0x ( 1 , :) if ( exclude_boundary_regions_qn ) then g0x ( 1 , :) = sum ( g0x ( 1 , ( boundary_size + 1 ):( nakx - boundary_size ))) & / ( nakx - 2 * boundary_size ) g0x ( 1 , 1 : boundary_size ) = 0.0 g0x ( 1 , ( nakx - boundary_size + 1 ):) = 0.0 else g0x ( 1 , :) = sum ( g0x ( 1 , :)) / nakx end if call transform_x2kx_unpadded ( g0x , g0k ) g1k = g1k + g0k end do phi_proj_stage (:, 1 , it ) = g1k ( 1 , :) if ( tcorr_source_qn < epsilon ( 0.0 )) then do iz = - nzgrid , nzgrid - 1 phi ( 1 , :, iz , it ) = phi ( 1 , :, iz , it ) - g1k ( 1 , :) end do else do iz = - nzgrid , nzgrid - 1 phi ( 1 , :, iz , it ) = phi ( 1 , :, iz , it ) & - ( 1. - exp_fac_qn ) * g1k ( 1 , :) - exp_fac_qn * phi_proj (:, 1 , it ) end do end if #if defined MPI && ISO_C_BINDING if ( sgproc0 ) then #endif do iz = - nzgrid , nzgrid - 1 do ikx = 1 , nakx inmat = ikx + nakx * ( iz + nzgrid ) phi_ext ( inmat ) = phi ( 1 , ikx , iz , it ) end do end do #if defined MPI && ISO_C_BINDING end if call mpi_win_fence ( 0 , qn_zf_window , ierr ) #endif #if defined MPI && ISO_C_BINDING call lu_matrix_multiply_local ( comm_sgroup , qn_zf_window , phizf_solve % zloc , phi_ext ) call mpi_win_fence ( 0 , qn_zf_window , ierr ) #else call lu_back_substitution ( phizf_solve % zloc , phizf_solve % idx , phi_ext ) #endif do iz = - nzgrid , nzgrid - 1 do ikx = 1 , nakx inmat = ikx + nakx * ( iz + nzgrid ) phi ( 1 , ikx , iz , it ) = phi_ext ( inmat ) end do end do !enforce periodicity phi ( 1 , :, nzgrid , it ) = phi ( 1 , :, - nzgrid , it ) ! calculate Theta.phi g1k = 0.0 do iz = - nzgrid , nzgrid - 1 do ikx = 1 , nakx g0k ( 1 , ikx ) = sum ( theta ( ikx , :, iz ) * phi ( 1 , :, iz , it )) end do call transform_kx2x_unpadded ( g0k , g0x ) g0x ( 1 , :) = ( dl_over_b ( ia , iz ) + d_dl_over_b_drho ( ia , iz ) * rho_d_clamped ) * g0x ( 1 , :) if ( exclude_boundary_regions_qn ) then g0x ( 1 , :) = sum ( g0x ( 1 , ( boundary_size + 1 ):( nakx - boundary_size ))) & / ( nakx - 2 * boundary_size ) g0x ( 1 , 1 : boundary_size ) = 0.0 g0x ( 1 , ( nakx - boundary_size + 1 ):) = 0.0 else g0x ( 1 , :) = sum ( g0x ( 1 , :)) / nakx end if call transform_x2kx_unpadded ( g0x , g0k ) g1k = g1k + g0k end do phi_proj_stage (:, 1 , it ) = phi_proj_stage (:, 1 , it ) - g1k ( 1 , :) end do deallocate ( g0k , g1k , g0x ) else if ( radial_variation ) then do it = 1 , ntubes do ikx = 1 , nakx ! DSO - this is sort of hack in order to avoid extra communications !       However, get_radial_correction should be called immediately !       after advance_fields, so it should be ok... save1 ( ikx , it ) = sum ( dl_over_b ( ia , :) * phi ( 1 , ikx , :, it )) save2 ( ikx , it ) = sum ( d_dl_over_b_drho ( ia , :) * phi ( 1 , ikx , :, it )) end do end do end if do ikx = 1 , nakx do it = 1 , ntubes tmp = sum ( dl_over_b ( ia , :) * phi ( 1 , ikx , :, it )) phi ( 1 , ikx , :, it ) = phi ( 1 , ikx , :, it ) + tmp * gamtot3 ( ikx , :) end do end do end if else if ( proc0 ) write ( * , * ) 'unknown dist option in get_fields. aborting' call mp_abort ( 'unknown dist option in get_fields. aborting' ) end if end if if ( proc0 ) call time_message (. false ., time_field_solve (:, 5 ), 'get_phi_adia_elec' ) end subroutine get_phi subroutine get_phi_ffs ( rhs , phi ) use zgrid , only : nzgrid use kt_grids , only : swap_kxky_ordered , swap_kxky_back_ordered use kt_grids , only : naky_all , ikx_max use gyro_averages , only : band_lu_solve_ffs implicit none complex , dimension (:, :, - nzgrid :), intent ( in ) :: rhs complex , dimension (:, :, - nzgrid :), intent ( out ) :: phi integer :: iz complex , dimension (:, :, :), allocatable :: rhs_swap allocate ( rhs_swap ( naky_all , ikx_max , - nzgrid : nzgrid )) !> change from rhs defined on grid with ky >=0 and kx from 0,...,kxmax,-kxmax,...,-dkx !> to rhs_swap defined on grid with ky = -kymax,...,kymax and kx >= 0 do iz = - nzgrid , nzgrid call swap_kxky_ordered ( rhs (:, :, iz ), rhs_swap (:, :, iz )) end do !> solve sum_s Z_s int d&#94;3v <g> = gam0*phi !> where sum_s Z_s int d&#94;3v <g> is initially passed in as rhs_swap !> and then rhs_swap is over-written with the solution to the linear system call band_lu_solve_ffs ( lu_gam0_ffs , rhs_swap ) !> swap back from the ordered grid in ky to the original (kx,ky) grid do iz = - nzgrid , nzgrid call swap_kxky_back_ordered ( rhs_swap (:, :, iz ), phi (:, :, iz )) end do deallocate ( rhs_swap ) end subroutine get_phi_ffs ! the following routine gets the correction in phi both from gyroaveraging and quasineutrality ! the output, phi, subroutine get_radial_correction ( g , phi_in , dist ) use mp , only : proc0 , mp_abort , sum_allreduce use stella_layouts , only : vmu_lo use gyro_averages , only : gyro_average , gyro_average_j1 use gyro_averages , only : aj0x , aj1x use run_parameters , only : fphi , ky_solve_radial use stella_geometry , only : dl_over_b , bmag , dBdrho use stella_layouts , only : imu_idx , is_idx use zgrid , only : nzgrid , ntubes use vpamu_grids , only : integrate_species , vperp2 use kt_grids , only : nakx , nx , naky use kt_grids , only : zonal_mode , multiply_by_rho use species , only : spec , has_electron_species use fields_arrays , only : phi_corr_QN , phi_corr_GA use fields_arrays , only : gamtot , dgamtotdr use fields_arrays , only : gamtot3 , dgamtot3dr use dist_fn_arrays , only : kperp2 , dkperp2dr use physics_flags , only : adiabatic_option_switch use physics_flags , only : adiabatic_option_fieldlineavg implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: phi_in complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g character ( * ), intent ( in ) :: dist integer :: ikx , iky , ivmu , iz , it , ia , is , imu complex :: tmp complex , dimension (:, :, :, :), allocatable :: phi complex , dimension (:, :, :), allocatable :: gyro_g complex , dimension (:, :), allocatable :: g0k , g0x ia = 1 if ( fphi > epsilon ( 0.0 )) then allocate ( gyro_g ( naky , nakx , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) allocate ( g0k ( naky , nakx )) allocate ( g0x ( naky , nx )) allocate ( phi ( naky , nakx , - nzgrid : nzgrid , ntubes )) phi = 0. do it = 1 , ntubes do iz = - nzgrid , nzgrid do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) g0k = g (:, :, iz , it , ivmu ) & * ( - 0.5 * aj1x (:, :, iz , ivmu ) / aj0x (:, :, iz , ivmu ) & * ( spec ( is )% smz ) ** 2 & * ( kperp2 (:, :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) & + dBdrho ( iz ) / bmag ( ia , iz ) - dgamtotdr (:, :, iz ) / gamtot (:, :, iz )) g0k ( 1 , 1 ) = 0. call gyro_average ( g0k , iz , ivmu , gyro_g (:, :, ivmu )) end do call integrate_species ( gyro_g , iz , spec % z * spec % dens_psi0 , phi (:, :, iz , it ), reduce_in = . false .) end do end do call sum_allreduce ( phi ) if ( dist == 'gbar' ) then !call get_phi (phi) phi = phi / spread ( gamtot , 4 , ntubes ) phi ( 1 , 1 , :, :) = 0.0 else if ( dist == 'h' ) then if ( proc0 ) write ( * , * ) 'dist option \"h\" not implemented in radial_correction. aborting' call mp_abort ( 'dist option \"h\" in radial_correction. aborting' ) else if ( proc0 ) write ( * , * ) 'unknown dist option in radial_correction. aborting' call mp_abort ( 'unknown dist option in radial_correction. aborting' ) end if if (. not . has_electron_species ( spec ) . and . & adiabatic_option_switch == adiabatic_option_fieldlineavg ) then if ( zonal_mode ( 1 )) then if ( dist == 'gbar' ) then do it = 1 , ntubes do ikx = 1 , nakx tmp = sum ( dl_over_b ( ia , :) * phi ( 1 , ikx , :, it )) phi ( 1 , ikx , :, it ) = phi ( 1 , ikx , :, it ) & + tmp * gamtot3 ( ikx , :) & + dgamtot3dr ( ikx , :) * save1 ( ikx , it ) & + gamtot3 ( ikx , :) * save2 ( ikx , it ) end do end do else if ( proc0 ) write ( * , * ) 'unknown dist option in radial_correction. aborting' call mp_abort ( 'unknown dist option in radial_correction. aborting' ) end if end if end if !collect quasineutrality corrections in wavenumber space do it = 1 , ntubes do iz = - nzgrid , nzgrid g0k = phi (:, :, iz , it ) call multiply_by_rho ( g0k ) phi_corr_QN (:, :, iz , it ) = g0k end do end do !zero out the ones we have already solved for using the full method do iky = 1 , min ( ky_solve_radial , naky ) phi_corr_QN ( iky , :, :, :) = 0.0 end do deallocate ( phi ) !collect gyroaveraging corrections in wavenumber space do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) do it = 1 , ntubes do iz = - nzgrid , nzgrid call gyro_average_j1 ( phi_in (:, :, iz , it ), iz , ivmu , g0k ) g0k = - g0k * ( spec ( is )% smz ) ** 2 & * ( kperp2 (:, :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * 0.5 * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) call multiply_by_rho ( g0k ) phi_corr_GA (:, :, iz , it , ivmu ) = g0k end do end do end do deallocate ( g0x , g0k ) deallocate ( gyro_g ) end if end subroutine get_radial_correction !> compute d<chi>/dy in (ky,kx,z,tube) space subroutine get_dchidy_4d ( phi , apar , dchidy ) use constants , only : zi use gyro_averages , only : gyro_average use stella_layouts , only : vmu_lo use stella_layouts , only : is_idx , iv_idx use run_parameters , only : fphi , fapar use species , only : spec use zgrid , only : nzgrid , ntubes use vpamu_grids , only : vpa use kt_grids , only : nakx , aky , naky implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: phi , apar complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( out ) :: dchidy integer :: ivmu , iv , is , iz , it , ikx complex , dimension (:, :, :, :), allocatable :: field allocate ( field ( naky , nakx , - nzgrid : nzgrid , ntubes )) do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) iv = iv_idx ( vmu_lo , ivmu ) do it = 1 , ntubes do iz = - nzgrid , nzgrid do ikx = 1 , nakx field (:, ikx , iz , it ) = zi * aky (:) * ( fphi * phi (:, ikx , iz , it ) - fapar * vpa ( iv ) * spec ( is )% stm * apar (:, ikx , iz , it )) end do end do end do call gyro_average ( field , ivmu , dchidy (:, :, :, :, ivmu )) end do deallocate ( field ) end subroutine get_dchidy_4d !> compute d<chi>/dy in (ky,kx) space subroutine get_dchidy_2d ( iz , ivmu , phi , apar , dchidy ) use constants , only : zi use gyro_averages , only : gyro_average use stella_layouts , only : vmu_lo use stella_layouts , only : is_idx , iv_idx use run_parameters , only : fphi , fapar use species , only : spec use vpamu_grids , only : vpa use kt_grids , only : nakx , aky , naky implicit none integer , intent ( in ) :: ivmu , iz complex , dimension (:, :), intent ( in ) :: phi , apar complex , dimension (:, :), intent ( out ) :: dchidy integer :: iv , is complex , dimension (:, :), allocatable :: field allocate ( field ( naky , nakx )) is = is_idx ( vmu_lo , ivmu ) iv = iv_idx ( vmu_lo , ivmu ) field = zi * spread ( aky , 2 , nakx ) & * ( fphi * phi - fapar * vpa ( iv ) * spec ( is )% stm * apar ) call gyro_average ( field , iz , ivmu , dchidy ) deallocate ( field ) end subroutine get_dchidy_2d !> compute d<chi>/dx in (ky,kx) space subroutine get_dchidx ( iz , ivmu , phi , apar , dchidx ) use constants , only : zi use gyro_averages , only : gyro_average use stella_layouts , only : vmu_lo use stella_layouts , only : is_idx , iv_idx use run_parameters , only : fphi , fapar use species , only : spec use vpamu_grids , only : vpa use kt_grids , only : akx , naky , nakx implicit none integer , intent ( in ) :: ivmu , iz complex , dimension (:, :), intent ( in ) :: phi , apar complex , dimension (:, :), intent ( out ) :: dchidx integer :: iv , is complex , dimension (:, :), allocatable :: field allocate ( field ( naky , nakx )) is = is_idx ( vmu_lo , ivmu ) iv = iv_idx ( vmu_lo , ivmu ) field = zi * spread ( akx , 1 , naky ) & * ( fphi * phi - fapar * vpa ( iv ) * spec ( is )% stm * apar ) call gyro_average ( field , iz , ivmu , dchidx ) deallocate ( field ) end subroutine get_dchidx subroutine finish_fields use fields_arrays , only : phi , phi_old use fields_arrays , only : phi_corr_QN , phi_corr_GA use fields_arrays , only : apar , apar_corr_QN , apar_corr_GA use fields_arrays , only : gamtot , dgamtotdr , gamtot3 , dgamtot3dr use fields_arrays , only : c_mat , theta #if defined MPI && ISO_C_BINDING use fields_arrays , only : qn_window use mpi #else use fields_arrays , only : phi_solve #endif implicit none #if defined MPI && ISO_C_BINDING integer ierr #endif if ( allocated ( phi )) deallocate ( phi ) if ( allocated ( phi_old )) deallocate ( phi_old ) if ( allocated ( phi_corr_QN )) deallocate ( phi_corr_QN ) if ( allocated ( phi_corr_GA )) deallocate ( phi_corr_GA ) if ( allocated ( apar )) deallocate ( apar ) if ( allocated ( apar_corr_QN )) deallocate ( apar_corr_QN ) if ( allocated ( apar_corr_GA )) deallocate ( apar_corr_GA ) if ( allocated ( gamtot )) deallocate ( gamtot ) if ( allocated ( gamtot3 )) deallocate ( gamtot3 ) if ( allocated ( dgamtotdr )) deallocate ( dgamtotdr ) if ( allocated ( dgamtot3dr )) deallocate ( dgamtot3dr ) if ( allocated ( apar_denom )) deallocate ( apar_denom ) if ( allocated ( save1 )) deallocate ( save1 ) if ( allocated ( save2 )) deallocate ( save2 ) #if defined MPI && ISO_C_BINDING if ( phi_shared_window /= MPI_WIN_NULL ) call mpi_win_free ( phi_shared_window , ierr ) if ( qn_window_initialized . and . qn_window /= MPI_WIN_NULL ) then call mpi_win_free ( qn_window , ierr ) qn_window_initialized = . false . end if #else if ( allocated ( phi_solve )) deallocate ( phi_solve ) #endif if ( allocated ( c_mat )) deallocate ( c_mat ) if ( allocated ( theta )) deallocate ( theta ) !> arrays only allocated/used if simulating a full flux surface if ( allocated ( gam0_ffs )) deallocate ( gam0_ffs ) if ( allocated ( lu_gam0_ffs )) deallocate ( lu_gam0_ffs ) if ( allocated ( adiabatic_response_factor )) deallocate ( adiabatic_response_factor ) fields_initialized = . false . end subroutine finish_fields end module fields","tags":"","loc":"sourcefile/fields.fpp.html"},{"title":"stella_transforms.f90 â€“ stella","text":"Contents Modules stella_transforms Source Code stella_transforms.f90 Source Code module stella_transforms use fft_work , only : fft_type implicit none public :: init_transforms , finish_transforms public :: transform_ky2y , transform_y2ky public :: transform_kx2x , transform_x2kx public :: transform_ky2y_unpadded , transform_y2ky_unpadded public :: transform_kx2x_unpadded , transform_x2kx_unpadded public :: transform_kx2x_xfirst , transform_x2kx_xfirst public :: transform_ky2y_xfirst , transform_y2ky_xfirst public :: transform_kalpha2alpha , transform_alpha2kalpha interface transform_ky2y module procedure transform_ky2y_5d module procedure transform_ky2y_2d end interface interface transform_y2ky module procedure transform_y2ky_5d module procedure transform_y2ky_2d end interface private type ( fft_type ) :: yf_fft , yb_fft type ( fft_type ) :: xf_fft , xb_fft type ( fft_type ) :: yfnp_fft , ybnp_fft type ( fft_type ) :: xfnp_fft , xbnp_fft type ( fft_type ) :: xsf_fft , xsb_fft type ( fft_type ) :: ysf_fft , ysb_fft type ( fft_type ) :: alpha_f_fft , alpha_b_fft logical :: transforms_initialized = . false . complex , dimension (:), allocatable :: fft_y_in , fft_y_out , fft_x_k real , dimension (:), allocatable :: fft_x_x complex , dimension (:), allocatable :: fft_xs_k , fft_xs_x , fft_ys_k real , dimension (:), allocatable :: fft_ys_y complex , dimension (:), allocatable :: fftnp_x_k , fftnp_x_x complex , dimension (:), allocatable :: fftnp_y_k real , dimension (:), allocatable :: fftnp_y_y !> arrays for transforming from alpha-space to k-alpha space real , dimension (:), allocatable :: fft_alpha_alpha complex , dimension (:), allocatable :: fft_alpha_kalpha contains subroutine init_transforms use physics_flags , only : full_flux_surface use stella_layouts , only : init_stella_layouts implicit none if ( transforms_initialized ) return transforms_initialized = . true . call init_stella_layouts call init_y_fft call init_x_fft call init_x_xfirst_fft call init_y_xfirst_fft call init_unpadded_x_fft call init_unpadded_y_fft if ( full_flux_surface ) call init_alpha_fft end subroutine init_transforms subroutine init_y_fft use stella_layouts , only : vmu_lo use fft_work , only : init_ccfftw implicit none logical :: initialized = . false . if ( initialized ) return initialized = . true . if (. not . allocated ( fft_y_in )) allocate ( fft_y_in ( vmu_lo % ny )) if (. not . allocated ( fft_y_out )) allocate ( fft_y_out ( vmu_lo % ny )) call init_ccfftw ( yf_fft , 1 , vmu_lo % ny , fft_y_in , fft_y_out ) call init_ccfftw ( yb_fft , - 1 , vmu_lo % ny , fft_y_in , fft_y_out ) end subroutine init_y_fft subroutine init_x_fft use stella_layouts , only : vmu_lo use fft_work , only : init_crfftw , init_rcfftw implicit none logical :: initialized = . false . if ( initialized ) return initialized = . true . if (. not . allocated ( fft_x_k )) allocate ( fft_x_k ( vmu_lo % nx / 2 + 1 )) if (. not . allocated ( fft_x_x )) allocate ( fft_x_x ( vmu_lo % nx )) call init_crfftw ( xf_fft , 1 , vmu_lo % nx , fft_x_k , fft_x_x ) call init_rcfftw ( xb_fft , - 1 , vmu_lo % nx , fft_x_x , fft_x_k ) end subroutine init_x_fft subroutine init_x_xfirst_fft use stella_layouts , only : vmu_lo use fft_work , only : init_ccfftw implicit none logical :: initialized = . false . if ( initialized ) return initialized = . true . if (. not . allocated ( fft_xs_k )) allocate ( fft_xs_k ( vmu_lo % nx )) if (. not . allocated ( fft_xs_x )) allocate ( fft_xs_x ( vmu_lo % nx )) call init_ccfftw ( xsf_fft , 1 , vmu_lo % nx , fft_xs_k , fft_xs_x ) call init_ccfftw ( xsb_fft , - 1 , vmu_lo % nx , fft_xs_x , fft_xs_k ) end subroutine init_x_xfirst_fft subroutine init_y_xfirst_fft use stella_layouts , only : vmu_lo use fft_work , only : init_crfftw , init_rcfftw implicit none logical :: initialized = . false . if ( initialized ) return initialized = . true . if (. not . allocated ( fft_ys_k )) allocate ( fft_ys_k ( vmu_lo % ny / 2 + 1 )) if (. not . allocated ( fft_ys_y )) allocate ( fft_ys_y ( vmu_lo % ny )) call init_crfftw ( ysf_fft , 1 , vmu_lo % ny , fft_ys_k , fft_ys_y ) call init_rcfftw ( ysb_fft , - 1 , vmu_lo % ny , fft_ys_y , fft_ys_k ) end subroutine init_y_xfirst_fft subroutine init_unpadded_x_fft use stella_layouts , only : vmu_lo use fft_work , only : init_ccfftw , FFT_BACKWARD , FFT_FORWARD implicit none if (. not . allocated ( fftnp_x_k )) allocate ( fftnp_x_k ( vmu_lo % nakx )) if (. not . allocated ( fftnp_x_x )) allocate ( fftnp_x_x ( vmu_lo % nakx )) call init_ccfftw ( xfnp_fft , FFT_BACKWARD , vmu_lo % nakx , fftnp_x_k , fftnp_x_x ) call init_ccfftw ( xbnp_fft , FFT_FORWARD , vmu_lo % nakx , fftnp_x_x , fftnp_x_k ) end subroutine init_unpadded_x_fft subroutine init_unpadded_y_fft use stella_layouts , only : vmu_lo use fft_work , only : init_crfftw , init_rcfftw , FFT_BACKWARD , FFT_FORWARD implicit none if (. not . allocated ( fftnp_y_k )) allocate ( fftnp_y_k ( vmu_lo % naky )) if (. not . allocated ( fftnp_y_y )) allocate ( fftnp_y_y ( 2 * vmu_lo % naky - 1 )) call init_crfftw ( yfnp_fft , FFT_BACKWARD , 2 * vmu_lo % naky - 1 , fftnp_y_k , fftnp_y_y ) call init_rcfftw ( ybnp_fft , FFT_FORWARD , 2 * vmu_lo % naky - 1 , fftnp_y_y , fftnp_y_k ) end subroutine init_unpadded_y_fft subroutine init_alpha_fft use fft_work , only : init_rcfftw , init_crfftw use fft_work , only : fft_backward , fft_forward use stella_layouts , only : vmu_lo implicit none logical :: initialized = . false . if ( initialized ) return initialized = . true . if (. not . allocated ( fft_alpha_kalpha )) allocate ( fft_alpha_kalpha ( vmu_lo % nalpha / 2 + 1 )) if (. not . allocated ( fft_alpha_alpha )) allocate ( fft_alpha_alpha ( vmu_lo % nalpha )) call init_crfftw ( alpha_f_fft , fft_backward , vmu_lo % nalpha , fft_alpha_kalpha , fft_alpha_alpha ) call init_rcfftw ( alpha_b_fft , fft_forward , vmu_lo % nalpha , fft_alpha_alpha , fft_alpha_kalpha ) end subroutine init_alpha_fft subroutine transform_ky2y_5d ( gky_unpad , gy ) use stella_layouts , only : vmu_lo implicit none complex , dimension (:, :, - vmu_lo % nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: gky_unpad complex , dimension (:, :, - vmu_lo % nzgrid :, :, vmu_lo % llim_proc :), intent ( out ) :: gy integer :: iky_max , ipad_up integer :: ikx , iz , it , ivmu ! first need to pad input array with zeros iky_max = vmu_lo % naky ipad_up = iky_max + vmu_lo % ny - ( 2 * vmu_lo % naky - 1 ) ! now fill in non-zero elements of array do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , vmu_lo % ntubes do iz = - vmu_lo % nzgrid , vmu_lo % nzgrid do ikx = 1 , vmu_lo % nakx / 2 + 1 fft_y_in ( iky_max + 1 : ipad_up ) = 0. fft_y_in (: iky_max ) = gky_unpad (: iky_max , ikx , iz , it , ivmu ) fft_y_in ( ipad_up + 1 :) = gky_unpad ( iky_max + 1 :, ikx , iz , it , ivmu ) call dfftw_execute_dft ( yf_fft % plan , fft_y_in , fft_y_out ) fft_y_out = fft_y_out * yf_fft % scale gy (:, ikx , iz , it , ivmu ) = fft_y_out end do end do end do end do end subroutine transform_ky2y_5d subroutine transform_ky2y_2d ( gky_unpad , gy ) use stella_layouts , only : vmu_lo implicit none complex , dimension (:, :), intent ( in ) :: gky_unpad complex , dimension (:, :), intent ( out ) :: gy integer :: iky_max , ipad_up integer :: ikx ! first need to pad input array with zeros iky_max = vmu_lo % naky ipad_up = iky_max + vmu_lo % ny - ( 2 * vmu_lo % naky - 1 ) ! now fill in non-zero elements of array do ikx = 1 , vmu_lo % nakx / 2 + 1 fft_y_in ( iky_max + 1 : ipad_up ) = 0. fft_y_in (: iky_max ) = gky_unpad (: iky_max , ikx ) fft_y_in ( ipad_up + 1 :) = gky_unpad ( iky_max + 1 :, ikx ) call dfftw_execute_dft ( yf_fft % plan , fft_y_in , fft_y_out ) fft_y_out = fft_y_out * yf_fft % scale gy (:, ikx ) = fft_y_out end do end subroutine transform_ky2y_2d subroutine transform_y2ky_5d ( gy , gky ) use stella_layouts , only : vmu_lo implicit none complex , dimension (:, :, - vmu_lo % nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: gy complex , dimension (:, :, - vmu_lo % nzgrid :, :, vmu_lo % llim_proc :), intent ( out ) :: gky integer :: iky_max , ipad_up integer :: ikx , iz , it , ivmu iky_max = vmu_lo % naky ipad_up = iky_max + vmu_lo % ny - ( 2 * vmu_lo % naky - 1 ) ! now fill in non-zero elements of array do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , vmu_lo % ntubes do iz = - vmu_lo % nzgrid , vmu_lo % nzgrid do ikx = 1 , vmu_lo % nakx / 2 + 1 fft_y_in = gy (:, ikx , iz , it , ivmu ) call dfftw_execute_dft ( yb_fft % plan , fft_y_in , fft_y_out ) fft_y_out = fft_y_out * yb_fft % scale gky (: iky_max , ikx , iz , it , ivmu ) = fft_y_out (: iky_max ) gky ( iky_max + 1 :, ikx , iz , it , ivmu ) = fft_y_out ( ipad_up + 1 :) end do end do end do end do end subroutine transform_y2ky_5d subroutine transform_y2ky_2d ( gy , gky ) use stella_layouts , only : vmu_lo implicit none complex , dimension (:, :), intent ( in out ) :: gy complex , dimension (:, :), intent ( out ) :: gky integer :: iky_max , ipad_up integer :: ikx iky_max = vmu_lo % naky ipad_up = iky_max + vmu_lo % ny - ( 2 * vmu_lo % naky - 1 ) ! now fill in non-zero elements of array do ikx = 1 , vmu_lo % nakx / 2 + 1 fft_y_in = gy (:, ikx ) call dfftw_execute_dft ( yb_fft % plan , fft_y_in , fft_y_out ) fft_y_out = fft_y_out * yb_fft % scale gky (: iky_max , ikx ) = fft_y_out (: iky_max ) gky ( iky_max + 1 :, ikx ) = fft_y_out ( ipad_up + 1 :) end do end subroutine transform_y2ky_2d subroutine transform_kx2x ( gkx , gx ) use stella_layouts , only : vmu_lo implicit none complex , dimension (:, :), intent ( in ) :: gkx real , dimension (:, :), intent ( out ) :: gx integer :: iy ! now fill in non-zero elements of array do iy = 1 , vmu_lo % ny ! first need to pad input array with zeros fft_x_k ( vmu_lo % nakx / 2 + 2 :) = 0. fft_x_k (: vmu_lo % nakx / 2 + 1 ) = gkx ( iy , :) call dfftw_execute_dft_c2r ( xf_fft % plan , fft_x_k , fft_x_x ) fft_x_x = fft_x_x * xf_fft % scale gx ( iy , :) = fft_x_x end do end subroutine transform_kx2x subroutine transform_x2kx ( gx , gkx ) use stella_layouts , only : vmu_lo implicit none real , dimension (:, :), intent ( in ) :: gx complex , dimension (:, :), intent ( out ) :: gkx integer :: iy do iy = 1 , vmu_lo % ny fft_x_x = gx ( iy , :) call dfftw_execute_dft_r2c ( xb_fft % plan , fft_x_x , fft_x_k ) fft_x_k = fft_x_k * xb_fft % scale gkx ( iy , :) = fft_x_k (: vmu_lo % nakx / 2 + 1 ) end do end subroutine transform_x2kx subroutine transform_kx2x_xfirst ( gkx , gx ) use stella_layouts , only : vmu_lo implicit none complex , dimension (:, :), intent ( in ) :: gkx complex , dimension (:, :), intent ( out ) :: gx integer :: iky , ikx_max , ipad_up ikx_max = vmu_lo % nakx / 2 + 1 ipad_up = ikx_max + vmu_lo % nx - vmu_lo % nakx ! now fill in non-zero elements of array do iky = 1 , vmu_lo % naky ! first need to pad input array with zeros fft_xs_k ( ikx_max + 1 : ipad_up ) = 0. fft_xs_k (: ikx_max ) = gkx ( iky , : ikx_max ) fft_xs_k ( ipad_up + 1 :) = gkx ( iky , ikx_max + 1 :) call dfftw_execute_dft ( xsf_fft % plan , fft_xs_k , fft_xs_x ) fft_xs_x = fft_xs_x * xsf_fft % scale gx ( iky , :) = fft_xs_x end do end subroutine transform_kx2x_xfirst subroutine transform_x2kx_xfirst ( gx , gkx ) use stella_layouts , only : vmu_lo implicit none complex , dimension (:, :), intent ( in ) :: gx complex , dimension (:, :), intent ( out ) :: gkx integer :: iky , ikx_max , ipad_up ikx_max = vmu_lo % nakx / 2 + 1 ipad_up = ikx_max + vmu_lo % nx - vmu_lo % nakx do iky = 1 , vmu_lo % naky fft_xs_x = gx ( iky , :) call dfftw_execute_dft ( xsb_fft % plan , fft_xs_x , fft_xs_k ) fft_xs_k = fft_xs_k * xsb_fft % scale gkx ( iky , : ikx_max ) = fft_xs_k (: ikx_max ) gkx ( iky , ikx_max + 1 :) = fft_xs_k ( ipad_up + 1 :) end do end subroutine transform_x2kx_xfirst subroutine transform_ky2y_xfirst ( gky , gy ) use stella_layouts , only : vmu_lo implicit none complex , dimension (:, :), intent ( in ) :: gky real , dimension (:, :), intent ( out ) :: gy integer :: ix ! now fill in non-zero elements of array do ix = 1 , vmu_lo % nx ! first need to pad input array with zeros fft_ys_k ( vmu_lo % naky + 1 :) = 0. fft_ys_k (: vmu_lo % naky ) = gky (:, ix ) call dfftw_execute_dft_c2r ( ysf_fft % plan , fft_ys_k , fft_ys_y ) fft_ys_y = fft_ys_y * ysf_fft % scale gy (:, ix ) = fft_ys_y end do end subroutine transform_ky2y_xfirst subroutine transform_y2ky_xfirst ( gy , gky ) use stella_layouts , only : vmu_lo implicit none real , dimension (:, :), intent ( in ) :: gy complex , dimension (:, :), intent ( out ) :: gky integer :: ix do ix = 1 , vmu_lo % nx fft_ys_y = gy (:, ix ) call dfftw_execute_dft_r2c ( ysb_fft % plan , fft_ys_y , fft_ys_k ) fft_ys_k = fft_ys_k * ysb_fft % scale gky (:, ix ) = fft_ys_k (: vmu_lo % naky ) end do end subroutine transform_y2ky_xfirst subroutine transform_kx2x_unpadded ( gkx , gx ) implicit none complex , dimension (:, :), intent ( in ) :: gkx complex , dimension (:, :), intent ( out ) :: gx integer :: iy do iy = 1 , size ( gkx , 1 ) fftnp_x_k = gkx ( iy , :) call dfftw_execute_dft ( xfnp_fft % plan , fftnp_x_k , fftnp_x_x ) gx ( iy , :) = fftnp_x_x * xfnp_fft % scale end do end subroutine transform_kx2x_unpadded subroutine transform_x2kx_unpadded ( gx , gkx ) implicit none complex , dimension (:, :), intent ( in ) :: gx complex , dimension (:, :), intent ( out ) :: gkx integer :: iy do iy = 1 , size ( gx , 1 ) fftnp_x_x = gx ( iy , :) call dfftw_execute_dft ( xbnp_fft % plan , fftnp_x_x , fftnp_x_k ) gkx ( iy , :) = fftnp_x_k * xbnp_fft % scale end do end subroutine transform_x2kx_unpadded subroutine transform_ky2y_unpadded ( gky , gy ) implicit none complex , dimension (:, :), intent ( in ) :: gky real , dimension (:, :), intent ( out ) :: gy integer :: ikx do ikx = 1 , size ( gky , 1 ) fftnp_y_k = gky (:, ikx ) call dfftw_execute_dft_c2r ( yfnp_fft % plan , fftnp_y_k , fftnp_y_y ) gy (:, ikx ) = fftnp_y_y * yfnp_fft % scale end do end subroutine transform_ky2y_unpadded subroutine transform_y2ky_unpadded ( gy , gky ) implicit none real , dimension (:, :), intent ( in out ) :: gy complex , dimension (:, :), intent ( out ) :: gky integer :: ikx do ikx = 1 , size ( gy , 2 ) fftnp_y_k = gy (:, ikx ) call dfftw_execute_dft_r2c ( ybnp_fft % plan , fftnp_y_y , fftnp_y_k ) gky (:, ikx ) = fftnp_y_y * ybnp_fft % scale end do end subroutine transform_y2ky_unpadded subroutine transform_kalpha2alpha ( gkalph , galph ) use stella_layouts , only : vmu_lo implicit none complex , dimension (:), intent ( in ) :: gkalph real , dimension (:), intent ( out ) :: galph ! first need to pad input array with zeros fft_alpha_kalpha ( vmu_lo % naky + 1 :) = 0. ! then fill in non-zero elements of array fft_alpha_kalpha (: vmu_lo % naky ) = gkalph call dfftw_execute_dft_c2r ( alpha_f_fft % plan , fft_alpha_kalpha , fft_alpha_alpha ) fft_alpha_alpha = fft_alpha_alpha * alpha_f_fft % scale galph = fft_alpha_alpha end subroutine transform_kalpha2alpha !> input galph array is real and contains values on the padded alpha grid !> gkalph is output array; it contains the Fourier coefficients of galph !> for positive ky values only (reality can be used to obtain the negative ky coefs) !> the highest 1/3 of the ky modes from the FFT have been discarded to avoid de-aliasing subroutine transform_alpha2kalpha ( galph , gkalph ) use stella_layouts , only : vmu_lo implicit none real , dimension (:), intent ( in ) :: galph complex , dimension (:), intent ( out ) :: gkalph fft_alpha_alpha = galph call dfftw_execute_dft_r2c ( alpha_b_fft % plan , fft_alpha_alpha , fft_alpha_kalpha ) fft_alpha_kalpha = fft_alpha_kalpha * alpha_b_fft % scale ! filter out highest k-alpha modes to avoid aliasing gkalph = fft_alpha_kalpha (: vmu_lo % naky ) end subroutine transform_alpha2kalpha subroutine finish_transforms use physics_flags , only : full_flux_surface implicit none call dfftw_destroy_plan ( yf_fft % plan ) call dfftw_destroy_plan ( yb_fft % plan ) call dfftw_destroy_plan ( xf_fft % plan ) call dfftw_destroy_plan ( xb_fft % plan ) call dfftw_destroy_plan ( xsf_fft % plan ) call dfftw_destroy_plan ( xsb_fft % plan ) call dfftw_destroy_plan ( ysf_fft % plan ) call dfftw_destroy_plan ( ysb_fft % plan ) call dfftw_destroy_plan ( yfnp_fft % plan ) call dfftw_destroy_plan ( ybnp_fft % plan ) call dfftw_destroy_plan ( xfnp_fft % plan ) call dfftw_destroy_plan ( xbnp_fft % plan ) if ( full_flux_surface ) then call dfftw_destroy_plan ( alpha_f_fft % plan ) call dfftw_destroy_plan ( alpha_b_fft % plan ) end if if ( allocated ( fft_y_in )) deallocate ( fft_y_in ) if ( allocated ( fft_y_out )) deallocate ( fft_y_out ) if ( allocated ( fft_x_k )) deallocate ( fft_x_k ) if ( allocated ( fft_x_x )) deallocate ( fft_x_x ) if ( allocated ( fft_xs_k )) deallocate ( fft_xs_k ) if ( allocated ( fft_xs_x )) deallocate ( fft_xs_x ) if ( allocated ( fft_ys_k )) deallocate ( fft_ys_k ) if ( allocated ( fft_ys_y )) deallocate ( fft_ys_y ) if ( allocated ( fft_alpha_alpha )) deallocate ( fft_alpha_alpha ) if ( allocated ( fft_alpha_kalpha )) deallocate ( fft_alpha_kalpha ) if ( allocated ( fftnp_y_k )) deallocate ( fftnp_y_k ) if ( allocated ( fftnp_y_y )) deallocate ( fftnp_y_y ) if ( allocated ( fftnp_x_k )) deallocate ( fftnp_x_k ) if ( allocated ( fftnp_x_x )) deallocate ( fftnp_x_x ) transforms_initialized = . false . end subroutine finish_transforms end module stella_transforms","tags":"","loc":"sourcefile/stella_transforms.f90.html"},{"title":"neoclassical_terms.f90 â€“ stella","text":"Contents Modules neoclassical_terms Source Code neoclassical_terms.f90 Source Code module neoclassical_terms implicit none public :: init_neoclassical_terms public :: finish_neoclassical_terms public :: include_neoclassical_terms public :: dfneo_dzed , dfneo_dvpa , dfneo_drho , dfneo_dalpha public :: dphineo_dzed , dphineo_drho , dphineo_dalpha private logical :: include_neoclassical_terms integer :: nradii real :: drho integer :: neo_option_switch integer , parameter :: neo_option_sfincs = 1 real , dimension (:, :, :), allocatable :: dfneo_dzed , dfneo_dvpa , dfneo_drho , dfneo_dalpha real , dimension (:, :), allocatable :: dphineo_dzed , dphineo_drho , dphineo_dalpha logical :: neoinit = . false . logical :: debug = . false . contains subroutine init_neoclassical_terms use zgrid , only : nzgrid use kt_grids , only : nalpha use vpamu_grids , only : nvpa , nmu use species , only : nspec use stella_layouts , only : vmu_lo use sfincs_interface , only : get_neo_from_sfincs implicit none real , dimension (:, :, :, :, :, :), allocatable :: f_neoclassical real , dimension (:, :, :), allocatable :: phi_neoclassical real , dimension (:, :, :, :, :), allocatable :: dfneo_dalpha_local integer :: iz , ialpha if ( neoinit ) return neoinit = . true . call read_parameters if ( include_neoclassical_terms ) then allocate ( f_neoclassical ( nalpha , - nzgrid : nzgrid , nvpa , nmu , nspec , - nradii / 2 : nradii / 2 )) allocate ( phi_neoclassical ( nalpha , - nzgrid : nzgrid , - nradii / 2 : nradii / 2 )) allocate ( dfneo_dalpha_local ( nalpha , - nzgrid : nzgrid , nvpa , nmu , nspec )) if (. not . allocated ( dfneo_dvpa )) & allocate ( dfneo_dvpa ( nalpha , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) if (. not . allocated ( dfneo_drho )) & allocate ( dfneo_drho ( nalpha , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) if (. not . allocated ( dfneo_dzed )) & allocate ( dfneo_dzed ( nalpha , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) if (. not . allocated ( dfneo_dalpha )) & allocate ( dfneo_dalpha ( nalpha , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) if (. not . allocated ( dphineo_dzed )) & allocate ( dphineo_dzed ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( dphineo_drho )) & allocate ( dphineo_drho ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( dphineo_dalpha )) & allocate ( dphineo_dalpha ( nalpha , - nzgrid : nzgrid )) select case ( neo_option_switch ) case ( neo_option_sfincs ) call get_neo_from_sfincs ( nradii , drho , f_neoclassical , phi_neoclassical , dfneo_dalpha_local , dphineo_dalpha ) end select if ( debug ) write ( 6 , * ) 'neoclassical_terms::init_neoclassical_terms::get_dfneo_dzed' call get_dfneo_dzed ( f_neoclassical (:, :, :, :, :, 0 ), dfneo_dzed ) if ( debug ) write ( 6 , * ) 'neoclassical_terms::init_neoclassical_terms::get_dfneo_dvpa' call get_dfneo_dvpa ( f_neoclassical (:, :, :, :, :, 0 ), dfneo_dvpa ) if ( debug ) write ( 6 , * ) 'neoclassical_terms::init_neoclassical_terms::get_dfneo_drho' call get_dfneo_drho ( f_neoclassical , dfneo_drho ) if ( debug ) write ( 6 , * ) 'neoclassical_terms::init_neoclassical_terms::get_dphineo_dzed' call get_dphineo_dzed ( phi_neoclassical (:, :, 0 ), dphineo_dzed ) if ( debug ) write ( 6 , * ) 'neoclassical_terms::init_neoclassical_terms::get_dphineo_drho' call get_dphineo_drho ( phi_neoclassical , dphineo_drho ) do iz = - nzgrid , nzgrid do ialpha = 1 , nalpha call distribute_vmus_over_procs ( dfneo_dalpha_local ( ialpha , iz , :, :, :), dfneo_dalpha ( ialpha , iz , :)) end do end do if ( debug ) write ( 6 , * ) 'neoclassical_terms::init_neoclassical_terms::write_neoclassical' call write_neoclassical ( f_neoclassical , phi_neoclassical ) deallocate ( f_neoclassical , phi_neoclassical , dfneo_dalpha_local ) end if end subroutine init_neoclassical_terms subroutine read_parameters use mp , only : proc0 , broadcast use file_utils , only : error_unit , input_unit_exist use text_options , only : text_option , get_option_value implicit none type ( text_option ), dimension ( 2 ), parameter :: neoopts = ( / & text_option ( 'default' , neo_option_sfincs ), & text_option ( 'sfincs' , neo_option_sfincs ) / ) character ( 10 ) :: neo_option namelist / neoclassical_input / include_neoclassical_terms , & neo_option , nradii , drho logical :: exist integer :: ierr , in_file if ( proc0 ) then ! set to .true. to include neoclassical terms in GK equation include_neoclassical_terms = . false . ! number of radial points used for radial derivatives ! of neoclassical quantities nradii = 5 ! spacing in rhoc between points used for radial derivatives drho = 0.01 ! option for obtaining neoclassical distribution function and potential neo_option = 'sfincs' in_file = input_unit_exist ( \"neoclassical_input\" , exist ) if ( exist ) read ( unit = in_file , nml = neoclassical_input ) ierr = error_unit () call get_option_value & ( neo_option , neoopts , neo_option_switch , & ierr , \"neo_option in neoclassical_input\" ) if ( nradii /= 3 . and . nradii /= 5 ) then write ( * , * ) 'WARNING: only nradii of 3 or 5 is currently supported in neoclassical_input namelist' write ( * , * ) 'WARNING: forcing nradii=5' nradii = 5 end if end if call broadcast ( include_neoclassical_terms ) call broadcast ( neo_option_switch ) call broadcast ( nradii ) call broadcast ( drho ) end subroutine read_parameters subroutine distribute_vmus_over_procs ( local , distributed ) use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx , imu_idx , is_idx implicit none real , dimension (:, :, :), intent ( in ) :: local real , dimension ( vmu_lo % llim_proc :), intent ( out ) :: distributed integer :: ivmu , iv , imu , is do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) distributed ( ivmu ) = local ( iv , imu , is ) end do end subroutine distribute_vmus_over_procs subroutine get_dfneo_dvpa ( fneo , dfneo ) use finite_differences , only : fd5pt use stella_layouts , only : vmu_lo use zgrid , only : nzgrid use vpamu_grids , only : nvpa , nmu use vpamu_grids , only : dvpa use species , only : nspec use kt_grids , only : nalpha implicit none real , dimension (:, - nzgrid :, :, :, :), intent ( in ) :: fneo real , dimension (:, - nzgrid :, vmu_lo % llim_proc :), intent ( out ) :: dfneo integer :: ia , iz , imu , is real , dimension (:), allocatable :: tmp1 , tmp2 real , dimension (:, :, :, :, :), allocatable :: dfneo_local allocate ( tmp1 ( nvpa ), tmp2 ( nvpa )) allocate ( dfneo_local ( nalpha , - nzgrid : nzgrid , nvpa , nmu , nspec )) do is = 1 , nspec do imu = 1 , nmu do iz = - nzgrid , nzgrid do ia = 1 , nalpha ! hack to avoid dealing with negative indices in fd5pt tmp1 = fneo ( ia , iz , :, imu , is ) call fd5pt ( tmp1 , tmp2 , dvpa ) dfneo_local ( ia , iz , :, imu , is ) = tmp2 end do end do end do end do do iz = - nzgrid , nzgrid do ia = 1 , nalpha call distribute_vmus_over_procs ( dfneo_local ( ia , iz , :, :, :), dfneo ( ia , iz , :)) end do end do deallocate ( dfneo_local ) deallocate ( tmp1 , tmp2 ) end subroutine get_dfneo_dvpa subroutine get_dfneo_dzed ( fneo , dfneo ) use finite_differences , only : fd5pt use zgrid , only : nztot , nzgrid , delzed use vpamu_grids , only : nvpa , nmu use species , only : nspec use stella_layouts , only : vmu_lo use kt_grids , only : nalpha implicit none real , dimension (:, - nzgrid :, :, :, :), intent ( in ) :: fneo real , dimension (:, - nzgrid :, vmu_lo % llim_proc :), intent ( out ) :: dfneo integer :: iv , imu , is , iz , ia real , dimension (:), allocatable :: tmp1 , tmp2 real , dimension (:), allocatable :: dfneo_local (:, :, :, :, :) allocate ( tmp1 ( nztot ), tmp2 ( nztot )) allocate ( dfneo_local ( nalpha , - nzgrid : nzgrid , nvpa , nmu , nspec )) do is = 1 , nspec do imu = 1 , nmu do iv = 1 , nvpa do ia = 1 , nalpha ! hack to avoid dealing with negative indices in fd5pt tmp1 = fneo ( ia , :, iv , imu , is ) call fd5pt ( tmp1 , tmp2 , delzed ( 0 )) dfneo_local ( ia , :, iv , imu , is ) = tmp2 end do end do end do end do do iz = - nzgrid , nzgrid do ia = 1 , nalpha call distribute_vmus_over_procs ( dfneo_local ( ia , iz , :, :, :), dfneo ( ia , iz , :)) end do end do deallocate ( dfneo_local ) deallocate ( tmp1 , tmp2 ) end subroutine get_dfneo_dzed subroutine get_dfneo_drho ( fneo , dfneo ) use finite_differences , only : fd3pt , fd5pt use zgrid , only : nzgrid use vpamu_grids , only : nvpa , nmu use species , only : nspec use stella_layouts , only : vmu_lo use kt_grids , only : nalpha implicit none real , dimension (:, - nzgrid :, :, :, :, - nradii / 2 :), intent ( in ) :: fneo real , dimension (:, - nzgrid :, vmu_lo % llim_proc :), intent ( out ) :: dfneo integer :: ia , iz , iv , imu , is real , dimension (:), allocatable :: tmp1 , tmp2 real , dimension (:, :, :, :, :), allocatable :: dfneo_local allocate ( tmp1 ( nradii ), tmp2 ( nradii )) allocate ( dfneo_local ( nalpha , - nzgrid : nzgrid , nvpa , nmu , nspec )) do is = 1 , nspec do imu = 1 , nmu do iv = 1 , nvpa do iz = - nzgrid , nzgrid do ia = 1 , nalpha ! hack to avoid dealing with negative indices in fd5pt tmp1 = fneo ( ia , iz , iv , imu , is , :) if ( nradii == 5 ) then call fd5pt ( tmp1 , tmp2 , drho ) else call fd3pt ( tmp1 , tmp2 , drho ) end if dfneo_local ( ia , iz , iv , imu , is ) = tmp2 ( nradii / 2 + 1 ) end do end do end do end do end do do iz = - nzgrid , nzgrid do ia = 1 , nalpha call distribute_vmus_over_procs ( dfneo_local ( ia , iz , :, :, :), dfneo ( ia , iz , :)) end do end do deallocate ( dfneo_local ) deallocate ( tmp1 , tmp2 ) end subroutine get_dfneo_drho subroutine get_dphineo_dzed ( phineo , dphineo ) use finite_differences , only : fd5pt use zgrid , only : nztot , nzgrid , delzed use kt_grids , only : nalpha implicit none real , dimension (:, - nzgrid :), intent ( in ) :: phineo real , dimension (:, - nzgrid :), intent ( out ) :: dphineo integer :: ia real , dimension (:), allocatable :: tmp1 , tmp2 allocate ( tmp1 ( nztot ), tmp2 ( nztot )) do ia = 1 , nalpha ! hack to avoid dealing with negative indices in fd5pt tmp1 = phineo ( ia , :) call fd5pt ( tmp1 , tmp2 , delzed ( 0 )) dphineo ( ia , :) = tmp2 end do deallocate ( tmp1 , tmp2 ) end subroutine get_dphineo_dzed subroutine get_dphineo_drho ( phineo , dphineo ) use finite_differences , only : fd3pt , fd5pt use zgrid , only : nzgrid use kt_grids , only : nalpha implicit none real , dimension (:, - nzgrid :, - nradii / 2 :), intent ( in ) :: phineo real , dimension (:, - nzgrid :), intent ( out ) :: dphineo integer :: iz , ia real , dimension (:), allocatable :: tmp1 , tmp2 allocate ( tmp1 ( nradii ), tmp2 ( nradii )) do iz = - nzgrid , nzgrid do ia = 1 , nalpha ! hack to avoid dealing with negative indices in fd5pt tmp1 = phineo ( ia , iz , :) if ( nradii == 5 ) then call fd5pt ( tmp1 , tmp2 , drho ) else call fd3pt ( tmp1 , tmp2 , drho ) end if dphineo ( ia , iz ) = tmp2 ( nradii / 2 + 1 ) end do end do deallocate ( tmp1 , tmp2 ) end subroutine get_dphineo_drho subroutine write_neoclassical ( fnc , phinc ) use mp , only : proc0 use mp , only : send , receive use file_utils , only : open_output_file , close_output_file use zgrid , only : nzgrid , zed use vpamu_grids , only : vpa , mu use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx , imu_idx , is_idx use stella_layouts , only : idx_local , proc_id use kt_grids , only : nalpha implicit none real , dimension (:, - nzgrid :, :, :, :, - nradii / 2 :), intent ( in ) :: fnc real , dimension (:, - nzgrid :, - nradii / 2 :), intent ( in ) :: phinc integer :: neo_unit integer :: irad , iz , ivmu , iv , imu , is , ia real , dimension (:, :), allocatable :: dfdv_local , dfdr_local , dfdz_local allocate ( dfdv_local ( nalpha , - nzgrid : nzgrid )) allocate ( dfdr_local ( nalpha , - nzgrid : nzgrid )) allocate ( dfdz_local ( nalpha , - nzgrid : nzgrid )) if ( proc0 ) then call open_output_file ( neo_unit , '.neoclassical' ) write ( neo_unit , '(3a8,10a13)' ) '#1.rad' , '2.spec' , '3.alpha' , '4.zed' , '5.mu' , & '6.vpa' , '7.f_neo' , '8.dfdvpa_neo' , '9.dfdrho_neo' , '10.dfdzed_neo' , '11.phi_neo' , & '12.dphidrho' , '13.dphidzed' end if do irad = - nradii / 2 , nradii / 2 do ivmu = vmu_lo % llim_world , vmu_lo % ulim_world iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) if ( idx_local ( vmu_lo , iv , imu , is )) then if ( proc0 ) then dfdv_local = dfneo_dvpa (:, :, ivmu ) dfdr_local = dfneo_drho (:, :, ivmu ) dfdz_local = dfneo_dzed (:, :, ivmu ) else call send ( dfneo_dvpa (:, :, ivmu ), 0 ) call send ( dfneo_drho (:, :, ivmu ), 0 ) call send ( dfneo_dzed (:, :, ivmu ), 0 ) end if else if ( proc0 ) then call receive ( dfdv_local , proc_id ( vmu_lo , ivmu )) call receive ( dfdr_local , proc_id ( vmu_lo , ivmu )) call receive ( dfdz_local , proc_id ( vmu_lo , ivmu )) end if if ( proc0 ) then do iz = - nzgrid , nzgrid do ia = 1 , nalpha write ( neo_unit , '(3i8,10e13.5)' ) irad , is , ia , zed ( iz ), mu ( imu ), vpa ( iv ), & fnc ( ia , iz , iv , imu , is , irad ), & dfdv_local ( ia , iz ), & dfdr_local ( ia , iz ), & dfdz_local ( ia , iz ), & phinc ( ia , iz , irad ), dphineo_drho ( ia , iz ), dphineo_dzed ( ia , iz ) end do end do end if end do if ( proc0 ) write ( neo_unit , * ) end do if ( proc0 ) call close_output_file ( neo_unit ) deallocate ( dfdv_local , dfdr_local , dfdz_local ) end subroutine write_neoclassical subroutine finish_neoclassical_terms implicit none if ( allocated ( dfneo_dvpa )) deallocate ( dfneo_dvpa ) if ( allocated ( dfneo_drho )) deallocate ( dfneo_drho ) if ( allocated ( dfneo_dzed )) deallocate ( dfneo_dzed ) if ( allocated ( dfneo_dalpha )) deallocate ( dfneo_dalpha ) if ( allocated ( dphineo_dzed )) deallocate ( dphineo_dzed ) if ( allocated ( dphineo_drho )) deallocate ( dphineo_drho ) if ( allocated ( dphineo_dalpha )) deallocate ( dphineo_dalpha ) neoinit = . false . end subroutine finish_neoclassical_terms end module neoclassical_terms","tags":"","loc":"sourcefile/neoclassical_terms.f90.html"},{"title":"dist_redistribute.f90 â€“ stella","text":"Contents Modules dist_redistribute Source Code dist_redistribute.f90 Source Code module dist_redistribute use redistribute , only : redist_type implicit none public :: init_redistribute , finish_redistribute public :: kxkyz2vmu public :: kxyz2vmu public :: xyz2vmu private type ( redist_type ) :: kxkyz2vmu type ( redist_type ) :: kxyz2vmu type ( redist_type ) :: xyz2vmu logical :: redistribute_initialized = . false . contains subroutine init_redistribute use physics_flags , only : full_flux_surface use physics_flags , only : include_parallel_nonlinearity implicit none if ( redistribute_initialized ) return redistribute_initialized = . true . call init_kxkyz_to_vmu_redistribute if ( full_flux_surface ) call init_kxyz_to_vmu_redistribute if ( include_parallel_nonlinearity ) call init_xyz_to_vmu_redistribute end subroutine init_redistribute subroutine init_kxkyz_to_vmu_redistribute use mp , only : nproc use stella_layouts , only : kxkyz_lo , vmu_lo use stella_layouts , only : kxkyzidx2vmuidx use stella_layouts , only : idx_local , proc_id use redistribute , only : index_list_type , init_redist use redistribute , only : delete_list , set_redist_character_type use vpamu_grids , only : nvpa , nmu use zgrid , only : nzgrid implicit none type ( index_list_type ), dimension ( 0 : nproc - 1 ) :: to_list , from_list integer , dimension ( 0 : nproc - 1 ) :: nn_to , nn_from integer , dimension ( 3 ) :: from_low , from_high integer , dimension ( 5 ) :: to_high , to_low integer :: ikxkyz , ivmu integer :: iv , imu , iky , ikx , iz , it integer :: ip , n logical :: initialized = . false . if ( initialized ) return initialized = . true . ! count number of elements to be redistributed to/from each processor nn_to = 0 nn_from = 0 do ikxkyz = kxkyz_lo % llim_world , kxkyz_lo % ulim_world do imu = 1 , nmu do iv = 1 , nvpa call kxkyzidx2vmuidx ( iv , imu , ikxkyz , kxkyz_lo , vmu_lo , iky , ikx , iz , it , ivmu ) if ( idx_local ( kxkyz_lo , ikxkyz )) & nn_from ( proc_id ( vmu_lo , ivmu )) = nn_from ( proc_id ( vmu_lo , ivmu )) + 1 if ( idx_local ( vmu_lo , ivmu )) & nn_to ( proc_id ( kxkyz_lo , ikxkyz )) = nn_to ( proc_id ( kxkyz_lo , ikxkyz )) + 1 end do end do end do do ip = 0 , nproc - 1 if ( nn_from ( ip ) > 0 ) then allocate ( from_list ( ip )% first ( nn_from ( ip ))) allocate ( from_list ( ip )% second ( nn_from ( ip ))) allocate ( from_list ( ip )% third ( nn_from ( ip ))) end if if ( nn_to ( ip ) > 0 ) then allocate ( to_list ( ip )% first ( nn_to ( ip ))) allocate ( to_list ( ip )% second ( nn_to ( ip ))) allocate ( to_list ( ip )% third ( nn_to ( ip ))) allocate ( to_list ( ip )% fourth ( nn_to ( ip ))) allocate ( to_list ( ip )% fifth ( nn_to ( ip ))) end if end do ! get local indices of elements distributed to/from other processors nn_to = 0 nn_from = 0 ! loop over all vmu indices, find corresponding y indices do ikxkyz = kxkyz_lo % llim_world , kxkyz_lo % ulim_world do imu = 1 , nmu do iv = 1 , nvpa ! obtain corresponding y indices call kxkyzidx2vmuidx ( iv , imu , ikxkyz , kxkyz_lo , vmu_lo , iky , ikx , iz , it , ivmu ) ! if vmu index local, set: ! ip = corresponding y processor ! from_list%first-third arrays = iv,imu,ikxkyz  (ie vmu indices) ! later will send from_list to proc ip if ( idx_local ( kxkyz_lo , ikxkyz )) then ip = proc_id ( vmu_lo , ivmu ) n = nn_from ( ip ) + 1 nn_from ( ip ) = n from_list ( ip )% first ( n ) = iv from_list ( ip )% second ( n ) = imu from_list ( ip )% third ( n ) = ikxkyz end if ! if y index local, set ip to corresponding vmu processor ! set to_list%first,second arrays = iky,iy  (ie y indices) ! will receive to_list from ip if ( idx_local ( vmu_lo , ivmu )) then ip = proc_id ( kxkyz_lo , ikxkyz ) n = nn_to ( ip ) + 1 nn_to ( ip ) = n to_list ( ip )% first ( n ) = iky to_list ( ip )% second ( n ) = ikx to_list ( ip )% third ( n ) = iz to_list ( ip )% fourth ( n ) = it to_list ( ip )% fifth ( n ) = ivmu end if end do end do end do from_low ( 1 ) = 1 from_low ( 2 ) = 1 from_low ( 3 ) = kxkyz_lo % llim_proc from_high ( 1 ) = nvpa from_high ( 2 ) = nmu from_high ( 3 ) = kxkyz_lo % ulim_alloc to_low ( 1 ) = 1 to_low ( 2 ) = 1 to_low ( 3 ) = - nzgrid to_low ( 4 ) = 1 to_low ( 5 ) = vmu_lo % llim_proc to_high ( 1 ) = vmu_lo % naky to_high ( 2 ) = vmu_lo % nakx to_high ( 3 ) = vmu_lo % nzed to_high ( 4 ) = vmu_lo % ntubes to_high ( 5 ) = vmu_lo % ulim_alloc call set_redist_character_type ( kxkyz2vmu , 'kxkyz2vmu' ) call init_redist ( kxkyz2vmu , 'c' , to_low , to_high , to_list , & from_low , from_high , from_list ) call delete_list ( to_list ) call delete_list ( from_list ) end subroutine init_kxkyz_to_vmu_redistribute subroutine init_kxyz_to_vmu_redistribute use mp , only : nproc use stella_layouts , only : kxyz_lo , vmu_lo use stella_layouts , only : kxyzidx2vmuidx use stella_layouts , only : idx_local , proc_id use redistribute , only : index_list_type , init_redist use redistribute , only : delete_list , set_redist_character_type use vpamu_grids , only : nvpa , nmu use zgrid , only : nzgrid implicit none type ( index_list_type ), dimension ( 0 : nproc - 1 ) :: to_list , from_list integer , dimension ( 0 : nproc - 1 ) :: nn_to , nn_from integer , dimension ( 3 ) :: from_low , from_high integer , dimension ( 5 ) :: to_high , to_low integer :: ikxyz , ivmu integer :: iv , imu , iy , ikx , iz , it integer :: ip , n logical :: initialized = . false . if ( initialized ) return initialized = . true . ! count number of elements to be redistributed to/from each processor nn_to = 0 nn_from = 0 do ikxyz = kxyz_lo % llim_world , kxyz_lo % ulim_world do imu = 1 , nmu do iv = 1 , nvpa call kxyzidx2vmuidx ( iv , imu , ikxyz , kxyz_lo , vmu_lo , iy , ikx , iz , it , ivmu ) if ( idx_local ( kxyz_lo , ikxyz )) & nn_from ( proc_id ( vmu_lo , ivmu )) = nn_from ( proc_id ( vmu_lo , ivmu )) + 1 if ( idx_local ( vmu_lo , ivmu )) & nn_to ( proc_id ( kxyz_lo , ikxyz )) = nn_to ( proc_id ( kxyz_lo , ikxyz )) + 1 end do end do end do do ip = 0 , nproc - 1 if ( nn_from ( ip ) > 0 ) then allocate ( from_list ( ip )% first ( nn_from ( ip ))) allocate ( from_list ( ip )% second ( nn_from ( ip ))) allocate ( from_list ( ip )% third ( nn_from ( ip ))) end if if ( nn_to ( ip ) > 0 ) then allocate ( to_list ( ip )% first ( nn_to ( ip ))) allocate ( to_list ( ip )% second ( nn_to ( ip ))) allocate ( to_list ( ip )% third ( nn_to ( ip ))) allocate ( to_list ( ip )% fourth ( nn_to ( ip ))) allocate ( to_list ( ip )% fifth ( nn_to ( ip ))) end if end do ! get local indices of elements distributed to/from other processors nn_to = 0 nn_from = 0 ! loop over all vmu indices, find corresponding y indices do ikxyz = kxyz_lo % llim_world , kxyz_lo % ulim_world do imu = 1 , nmu do iv = 1 , nvpa ! obtain corresponding y indices call kxyzidx2vmuidx ( iv , imu , ikxyz , kxyz_lo , vmu_lo , iy , ikx , iz , it , ivmu ) ! if vmu index local, set: ! ip = corresponding y processor ! from_list%first-third arrays = iv,imu,ikxyz  (ie vmu indices) ! later will send from_list to proc ip if ( idx_local ( kxyz_lo , ikxyz )) then ip = proc_id ( vmu_lo , ivmu ) n = nn_from ( ip ) + 1 nn_from ( ip ) = n from_list ( ip )% first ( n ) = iv from_list ( ip )% second ( n ) = imu from_list ( ip )% third ( n ) = ikxyz end if ! if y index local, set ip to corresponding vmu processor ! set to_list%first,second arrays = iy,iy  (ie y indices) ! will receive to_list from ip if ( idx_local ( vmu_lo , ivmu )) then ip = proc_id ( kxyz_lo , ikxyz ) n = nn_to ( ip ) + 1 nn_to ( ip ) = n to_list ( ip )% first ( n ) = iy to_list ( ip )% second ( n ) = ikx to_list ( ip )% third ( n ) = iz to_list ( ip )% fourth ( n ) = it to_list ( ip )% fifth ( n ) = ivmu end if end do end do end do from_low ( 1 ) = 1 from_low ( 2 ) = 1 from_low ( 3 ) = kxyz_lo % llim_proc from_high ( 1 ) = nvpa from_high ( 2 ) = nmu from_high ( 3 ) = kxyz_lo % ulim_alloc to_low ( 1 ) = 1 to_low ( 2 ) = 1 to_low ( 3 ) = - nzgrid to_low ( 4 ) = 1 to_low ( 5 ) = vmu_lo % llim_proc to_high ( 1 ) = vmu_lo % ny to_high ( 2 ) = vmu_lo % nakx / 2 + 1 to_high ( 3 ) = vmu_lo % nzed to_high ( 4 ) = vmu_lo % ntubes to_high ( 5 ) = vmu_lo % ulim_alloc call set_redist_character_type ( kxyz2vmu , 'kxyz2vmu' ) call init_redist ( kxyz2vmu , 'c' , to_low , to_high , to_list , & from_low , from_high , from_list ) call delete_list ( to_list ) call delete_list ( from_list ) end subroutine init_kxyz_to_vmu_redistribute subroutine init_xyz_to_vmu_redistribute use mp , only : nproc use stella_layouts , only : xyz_lo , vmu_lo use stella_layouts , only : xyzidx2vmuidx use stella_layouts , only : idx_local , proc_id use redistribute , only : index_list_type , init_redist use redistribute , only : delete_list , set_redist_character_type use vpamu_grids , only : nvpa , nmu use zgrid , only : nzgrid implicit none type ( index_list_type ), dimension ( 0 : nproc - 1 ) :: to_list , from_list integer , dimension ( 0 : nproc - 1 ) :: nn_to , nn_from integer , dimension ( 3 ) :: from_low , from_high integer , dimension ( 5 ) :: to_high , to_low integer :: ixyz , ivmu integer :: iv , imu , iy , ix , iz , it integer :: ip , n logical :: initialized = . false . if ( initialized ) return initialized = . true . ! count number of elements to be redistributed to/from each processor nn_to = 0 nn_from = 0 do ixyz = xyz_lo % llim_world , xyz_lo % ulim_world do imu = 1 , nmu do iv = 1 , nvpa call xyzidx2vmuidx ( iv , imu , ixyz , xyz_lo , vmu_lo , iy , ix , iz , it , ivmu ) if ( idx_local ( xyz_lo , ixyz )) & nn_from ( proc_id ( vmu_lo , ivmu )) = nn_from ( proc_id ( vmu_lo , ivmu )) + 1 if ( idx_local ( vmu_lo , ivmu )) & nn_to ( proc_id ( xyz_lo , ixyz )) = nn_to ( proc_id ( xyz_lo , ixyz )) + 1 end do end do end do do ip = 0 , nproc - 1 if ( nn_from ( ip ) > 0 ) then allocate ( from_list ( ip )% first ( nn_from ( ip ))) allocate ( from_list ( ip )% second ( nn_from ( ip ))) allocate ( from_list ( ip )% third ( nn_from ( ip ))) end if if ( nn_to ( ip ) > 0 ) then allocate ( to_list ( ip )% first ( nn_to ( ip ))) allocate ( to_list ( ip )% second ( nn_to ( ip ))) allocate ( to_list ( ip )% third ( nn_to ( ip ))) allocate ( to_list ( ip )% fourth ( nn_to ( ip ))) allocate ( to_list ( ip )% fifth ( nn_to ( ip ))) end if end do ! get local indices of elements distributed to/from other processors nn_to = 0 nn_from = 0 ! loop over all vmu indices, find corresponding y indices do ixyz = xyz_lo % llim_world , xyz_lo % ulim_world do imu = 1 , nmu do iv = 1 , nvpa ! obtain corresponding y indices call xyzidx2vmuidx ( iv , imu , ixyz , xyz_lo , vmu_lo , iy , ix , iz , it , ivmu ) ! if vmu index local, set: ! ip = corresponding y processor ! from_list%first-third arrays = iv,imu,ixyz  (ie vmu indices) ! later will send from_list to proc ip if ( idx_local ( xyz_lo , ixyz )) then ip = proc_id ( vmu_lo , ivmu ) n = nn_from ( ip ) + 1 nn_from ( ip ) = n from_list ( ip )% first ( n ) = iv from_list ( ip )% second ( n ) = imu from_list ( ip )% third ( n ) = ixyz end if ! if y index local, set ip to corresponding vmu processor ! set to_list%first,second arrays = iy,iy  (ie y indices) ! will receive to_list from ip if ( idx_local ( vmu_lo , ivmu )) then ip = proc_id ( xyz_lo , ixyz ) n = nn_to ( ip ) + 1 nn_to ( ip ) = n to_list ( ip )% first ( n ) = iy to_list ( ip )% second ( n ) = ix to_list ( ip )% third ( n ) = iz to_list ( ip )% fourth ( n ) = it to_list ( ip )% fifth ( n ) = ivmu end if end do end do end do from_low ( 1 ) = 1 from_low ( 2 ) = 1 from_low ( 3 ) = xyz_lo % llim_proc from_high ( 1 ) = nvpa from_high ( 2 ) = nmu from_high ( 3 ) = xyz_lo % ulim_alloc to_low ( 1 ) = 1 to_low ( 2 ) = 1 to_low ( 3 ) = - nzgrid to_low ( 4 ) = 1 to_low ( 5 ) = vmu_lo % llim_proc to_high ( 1 ) = vmu_lo % ny to_high ( 2 ) = vmu_lo % nx to_high ( 3 ) = vmu_lo % nzed to_high ( 4 ) = vmu_lo % ntubes to_high ( 5 ) = vmu_lo % ulim_alloc call set_redist_character_type ( xyz2vmu , 'xyz2vmu' ) call init_redist ( xyz2vmu , 'r' , to_low , to_high , to_list , & from_low , from_high , from_list ) call delete_list ( to_list ) call delete_list ( from_list ) end subroutine init_xyz_to_vmu_redistribute subroutine finish_redistribute implicit none redistribute_initialized = . false . end subroutine finish_redistribute end module dist_redistribute","tags":"","loc":"sourcefile/dist_redistribute.f90.html"},{"title":"gyro_averages.f90 â€“ stella","text":"Contents Modules gyro_averages Source Code gyro_averages.f90 Source Code module gyro_averages use common_types , only : coupled_alpha_type public :: aj0x , aj0v , aj1x , aj1v public :: init_bessel , finish_bessel public :: gyro_average public :: gyro_average_j1 public :: j0_B_maxwell_ffs , j0_ffs public :: band_lu_solve_ffs , band_lu_factorisation_ffs private interface gyro_average module procedure gyro_average_kxky_local module procedure gyro_average_kxkyz_local module procedure gyro_average_vmu_local module procedure gyro_average_vmus_nonlocal module procedure gyro_average_ffs_kxky_local module procedure gyro_average_ffs_kxkyz_local module procedure gyro_average_ffs end interface gyro_average interface gyro_average_j1 module procedure gyro_average_j1_kxky_local module procedure gyro_average_j1_kxkyz_local module procedure gyro_average_j1_vmu_local end interface real , dimension (:, :, :, :), allocatable :: aj0x , aj1x ! (naky, nakx, nalpha, -nzgrid:nzgrid, -vmu-layout-) real , dimension (:, :), allocatable :: aj0v , aj1v ! (nmu, -kxkyz-layout-) type ( coupled_alpha_type ), dimension (:, :, :, :), allocatable :: j0_ffs , j0_B_maxwell_ffs logical :: bessinit = . false . logical :: debug = . false . contains subroutine init_bessel use dist_fn_arrays , only : kperp2 use physics_flags , only : full_flux_surface use species , only : spec , nspec use stella_geometry , only : bmag use zgrid , only : nzgrid use vpamu_grids , only : vperp2 , nmu use kt_grids , only : naky , nakx use stella_layouts , only : kxkyz_lo , vmu_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , is_idx , imu_idx use spfunc , only : j0 , j1 implicit none integer :: iz , iky , ikx , imu , is , ia integer :: ikxkyz , ivmu real :: arg if ( bessinit ) return bessinit = . true . if ( debug ) write ( * , * ) 'gyro_averages::init_bessel::allocate_aj0v_aj1v' if (. not . allocated ( aj0v )) then allocate ( aj0v ( nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) aj0v = 0. end if if (. not . allocated ( aj1v )) then allocate ( aj1v ( nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) aj1v = 0. end if if ( debug ) write ( * , * ) 'gyro_averages::init_bessel::calculate_aj0v_aj1v' ia = 1 do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) do imu = 1 , nmu arg = spec ( is )% bess_fac * spec ( is )% smz_psi0 * sqrt ( vperp2 ( ia , iz , imu ) * kperp2 ( iky , ikx , ia , iz )) / bmag ( ia , iz ) aj0v ( imu , ikxkyz ) = j0 ( arg ) ! note that j1 returns and aj1 stores J_1(x)/x (NOT J_1(x)), aj1v ( imu , ikxkyz ) = j1 ( arg ) end do end do if ( debug ) write ( * , * ) 'gyro_averages::init_bessel::full_flux_surface' if ( full_flux_surface ) then call init_bessel_ffs else if (. not . allocated ( aj0x )) then allocate ( aj0x ( naky , nakx , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) aj0x = 0. end if if (. not . allocated ( aj1x )) then allocate ( aj1x ( naky , nakx , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) aj1x = 0. end if ia = 1 do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) do iz = - nzgrid , nzgrid do ikx = 1 , nakx do iky = 1 , naky arg = spec ( is )% bess_fac * spec ( is )% smz_psi0 * sqrt ( vperp2 ( ia , iz , imu ) * kperp2 ( iky , ikx , ia , iz )) / bmag ( ia , iz ) aj0x ( iky , ikx , iz , ivmu ) = j0 ( arg ) ! note that j1 returns and aj1 stores J_1(x)/x (NOT J_1(x)), aj1x ( iky , ikx , iz , ivmu ) = j1 ( arg ) end do end do end do end do end if if ( debug ) write ( * , * ) 'gyro_averages::init_bessel::test_gyro_average' !    call test_gyro_average contains !     ! set up field that varies as x&#94;2 = rho&#94;2 * cos(angle)&#94;2, !     ! with rho the distance from the origin, and 'angle' is the angle made with the horizontal !     ! if considering a particle at x=0, then rho is thee gyro-radius and angle is the gyro-angle !     ! the gyro-average should theen be 1/(2pi) * int_0&#94;2pi dangle rho&#94;2 * cos(angle)&#94;2 = rho&#94;2/2 !     subroutine test_gyro_average !       use constants, only: pi !       use kt_grids, only: ny, nx, x, x0, y, y0 !       use kt_grids, only: nakx, ikx_max, naky, naky_all !       use kt_grids, only: swap_kxky, swap_kxky_back !       use stella_transforms, only: transform_x2kx, transform_y2ky !       use stella_transforms, only: transform_kx2x, transform_ky2y !       use stella_layouts, only: vmu_lo, iv_idx, imu_idx, is_idx !       use vpamu_grids, only: nmu !       use species, only: nspec, spec !       use stella_geometry, only: alpha, bmag, x_displacement_fac !       use spfunc, only: bessi0 !       implicit none !       real, dimension (:,:), allocatable :: fld_yx !       complex, dimension (:,:), allocatable :: fld_ykx !       complex, dimension (:,:), allocatable :: fld_kykx_swapped !       complex, dimension (:,:), allocatable :: fld_kykx, gyro_fld !       real, dimension (:,:,:,:), allocatable :: gyro_fld_yx !       real :: gyroradius !       integer :: iy, ix, ivmu, iv, imu, is !       integer, parameter :: iz = 0 !       allocate (fld_yx(ny,nx)) !       allocate (fld_ykx(ny,ikx_max)) !       allocate (fld_kykx_swapped(naky_all,ikx_max)) !       allocate (fld_kykx(naky,nakx)) !       allocate (gyro_fld(naky,nakx)) !       allocate (gyro_fld_yx(ny,nx,nmu,nspec)) !       if (debug) write (*,*) 'gyro_averages::init_bessel::test_gyro_averages::fld_yx' !       ! set up field that varies as x&#94;2 = rho&#94;2 * cos(angle)&#94;2 and is constant in y ! !      fld_yx = spread(0.1*(x-pi*x0),1,ny)**2 !       fld_yx = spread(cos(50.0*(x/x0-pi)),1,ny) ! !      fld_yx = spread(exp(-0.1*(x-pi*x0)**2),1,ny) !       if (debug) write (*,*) 'gyro_averages::init_bessel::test_gyro_averages::transform_x2kx' !       ! transform from (y,x) to (y,kx), with kx going from 0 to kxmax !       call transform_x2kx (fld_yx, fld_ykx) !       if (debug) write (*,*) 'gyro_averages::init_bessel::test_gyro_averages::transform_y2ky' !       ! transform from (y,kx) to (ky,kx), with ky going from (0,...,kymax,-kymax,...,-dky) !       ! and kx going from 0 to kxmax !       call transform_y2ky (fld_ykx, fld_kykx_swapped) !       if (debug) write (*,*) 'gyro_averages::init_bessel::test_gyro_averages::swap_kxky_back' !       ! use reality condition to re-arrange array so that ky goes from 0 to kymax !       ! and kx goes from (0,...,kxmax,-kxmax,...,-dkx) !       call swap_kxky_back (fld_kykx_swapped, fld_kykx) !       ! gyro-average the field at z=0 for different values of mu !       do ivmu = vmu_lo%llim_proc, vmu_lo%ulim_proc !          ! get the vpa index !          iv = iv_idx(vmu_lo,ivmu) !          ! as J0 independent of vpa, pick only one vpa to test !          if (iv /= 1) cycle !          ! get the species index !          is = is_idx(vmu_lo,ivmu) !          ! get the mu index !          imu = imu_idx(vmu_lo,ivmu) ! !         if (debug) write (*,*) 'gyro_averages::init_bessel::test_gyro_averages::gyro_average' !          if (full_flux_surface) then !             call gyro_average (fld_kykx, gyro_fld, j0_ffs(:,:,iz,ivmu)) !          else !             call gyro_average (fld_kykx, iz, ivmu, gyro_fld) !          end if !          ! use reality to re-arrange array entries so that ky goes from (0,...,kymax,-kymax,...,-dky) !          ! and kx goes from 0 to kxmax !          call swap_kxky (gyro_fld, fld_kykx_swapped) !          ! transform from (ky,kx) to (y,kx) !          call transform_ky2y (fld_kykx_swapped, fld_ykx) !          ! transform from (y,kx) to (y,x) !          call transform_kx2x (fld_ykx, gyro_fld_yx(:,:,imu,is)) !       end do !       if (debug) write (*,*) 'gyro_averages::init_bessel::test_gyro_averages::write_to_screen' !       ! NB: this is only set up to work on a single processor at the moment !       ! NB: to extend, must move information about gyro_fld onto proc0 !       do is = 1, nspec !          do imu = 1, nmu !             do ix = 1, nx !                do iy = 1, ny !                   ! gyro-radius/reference gyro-radius is v_perp/Omega/rho_ref = (v_perp/vths)*(rho_s/rho_ref) !                   ! = vperp * sqrt(T_s/T_ref*m_s/m_ref)(B_ref/Z*B) = vperp / (spec%zstm*bmag) !                   gyroradius = sqrt(vperp2(iy,iz,imu))/(spec(is)%zstm*bmag(iy,iz)) ! !                  gyroradius = sqrt(vperp2(1,iz,imu))/(spec(is)%zstm*bmag(1,iz)) !                   write (42,*) 'y: ', y(iy), 'x: ', x(ix)-x0*pi, 'gyro_fld: ', gyro_fld_yx(iy,ix,imu,is), 'gyroradius: ', gyroradius, 'spec: ', is, & !                        'alpha: ', alpha(iy), 'x_displacement_fac: ', x_displacement_fac(iy,iz) !                end do !                write (42,*) !             end do !             write (42,*) !          end do !          write (42,*) !       end do !       do iy = 1, 1000 !          gyroradius = (iy-1)*15.0/999. !          !         write (43,*) 'gyroradius: ', gyroradius, 'bes: ', bessi0(0.1*0.5*(gyroradius/x_displacement_fac(1,iz))**2)*exp(-0.1*0.5*(gyroradius/x_displacement_fac(1,iz))**2) !          !         write (43,*) 'gyroradius: ', gyroradius, 'analytical: ', 0.5*(0.1*gyroradius/x_displacement_fac(1,iz))**2 !          write (43,*) 'gyroradius: ', gyroradius, 'analytical: ', j0(50.*gyroradius/(x0*x_displacement_fac(1,iz))) !       end do !       ! TMP FOR TESTING ! !      stop !       deallocate (fld_yx, fld_ykx) !       deallocate (fld_kykx_swapped, fld_kykx) !       deallocate (gyro_fld, gyro_fld_yx) !     end subroutine test_gyro_average end subroutine init_bessel subroutine init_bessel_ffs use mp , only : sum_allreduce , proc0 use spfunc , only : j0 use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx , imu_idx , is_idx use stella_transforms , only : transform_alpha2kalpha use species , only : nspec , spec use stella_geometry , only : bmag use zgrid , only : nzgrid , nztot use vpamu_grids , only : nmu , nvpa use vpamu_grids , only : vperp2 , maxwell_vpa , maxwell_mu use kt_grids , only : nalpha , naky , naky_all , ikx_max use kt_grids , only : swap_kxky_ordered use dist_fn_arrays , only : kperp2 implicit none !    integer :: j0_ffs_unit, j0_B_maxwell_ffs_unit integer :: iky , ikx , ia , iz integer :: ivmu , iv , imu , is integer :: ia_max_j0_count , ia_max_j0_B_maxwell_count real :: arg real :: ia_max_j0_reduction_factor , ia_max_j0_B_maxwell_reduction_factor real , dimension (:), allocatable :: wgts real , dimension (:), allocatable :: aj0_alpha , j0_B_maxwell real , dimension (:, :, :), allocatable :: kperp2_swap complex , dimension (:), allocatable :: aj0_kalpha , j0_B_maxwell_kalpha !       call open_output_file (j0_ffs_unit, '.j0_ffs') !       call open_output_file (j0_B_maxwell_ffs_unit, '.j0_over_B_ffs') ! wgts are species-dependent factors appearing in Gamma0 factor allocate ( wgts ( nspec )) wgts = spec % dens * spec % z ** 2 / spec % temp if ( debug ) write ( * , * ) 'gyro_averages::init_bessel::full_flux_surface::allocate_arrays' !> aj0_alpha will contain J_0 as a function of k_alpha and alpha allocate ( aj0_alpha ( nalpha )) allocate ( aj0_kalpha ( naky )) !> j0_B_maxwell will contain J_0*B*exp(-v&#94;2) as a function of k_alpha and alpha allocate ( j0_B_maxwell ( nalpha )) allocate ( j0_B_maxwell_kalpha ( naky )) allocate ( kperp2_swap ( naky_all , ikx_max , nalpha )) if (. not . allocated ( j0_ffs )) then allocate ( j0_ffs ( naky_all , ikx_max , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) end if if (. not . allocated ( j0_B_maxwell_ffs )) then allocate ( j0_B_maxwell_ffs ( naky_all , ikx_max , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) end if ia_max_j0_count = 0 ; ia_max_j0_B_maxwell_count = 0 do iz = - nzgrid , nzgrid write ( * , * ) 'calculating Fourier coefficients needed for gyro-averaging with alpha variation; zed index: ' , iz !> for each value of alpha, take kperp&#94;2 calculated on domain kx = [-kx_max, kx_max] and ky = [0, ky_max] !> and use symmetry to obtain kperp&#94;2 on domain kx = [0, kx_max] and ky = [-ky_max, ky_max] !> this makes later convolutions involving sums over all ky more straightforward if ( debug ) write ( * , * ) 'gyro_averages::init_bessel::full_flux_surface::swap_kxky' do ia = 1 , nalpha call swap_kxky_ordered ( kperp2 (:, :, ia , iz ), kperp2_swap (:, :, ia )) end do if ( debug ) write ( * , * ) 'gyro_averages::init_bessel::full_flux_surface::j0_loop' do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) do ikx = 1 , ikx_max do iky = 1 , naky_all do ia = 1 , nalpha !> calculate the argument of the Bessel function, which depends on both alpha and k_alpha arg = spec ( is )% bess_fac * spec ( is )% smz_psi0 * sqrt ( vperp2 ( ia , iz , imu ) * kperp2_swap ( iky , ikx , ia )) / bmag ( ia , iz ) ! compute the value of the Bessel function J0 corresponding to argument arg aj0_alpha ( ia ) = j0 ( arg ) !> compute J_0*B*exp(-v&#94;2), needed when integrating g over v-space in Maxwell's equations, !> due to B in v-space Jacobian and Maxwellian factor hidden in normalisation of g j0_B_maxwell ( ia ) = aj0_alpha ( ia ) * bmag ( ia , iz ) * maxwell_vpa ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) end do !> fourier transform aj0_alpha and j0_B_maxwell. !> note that fourier coefficients aj0_kalpha and j0_B_maxwell_kalpha have !> been filtered to avoid aliasing call transform_alpha2kalpha ( aj0_alpha , aj0_kalpha ) call transform_alpha2kalpha ( j0_B_maxwell , j0_B_maxwell_kalpha ) !> given the Fourier coefficients aj0_kalpha, calculate the minimum number of coefficients needed, !> called j0_ffs%max_idx, to ensure that the relative error in the total spectral energy is below a specified tolerance !if (debug) write (*,*) 'gyro_averages::init_bessel::full_flux_surface::find_max_required_kalpha_index' !                ! TMP FOR TESTING !                j0_ffs(iky,ikx,iz,ivmu)%max_idx = naky call find_max_required_kalpha_index ( aj0_kalpha , j0_ffs ( iky , ikx , iz , ivmu )% max_idx , imu , iz , is ) !> given the Fourier coefficients j0_B_maxwell_kalpha, calculate the minimum number of coefficients needed, !> called j0_B_maxwell_ffs%max_idx, to ensure that the relative error in the total spectral energy is below a specified tolerance call find_max_required_kalpha_index ( j0_B_maxwell_kalpha , j0_B_maxwell_ffs ( iky , ikx , iz , ivmu )% max_idx , imu , iz , is ) !> keep track of the total number of coefficients that must be retained across different phase space points ia_max_j0_count = ia_max_j0_count + j0_ffs ( iky , ikx , iz , ivmu )% max_idx !> keep track of the total number of coefficients that must be retained across different phase space points ia_max_j0_B_maxwell_count = ia_max_j0_B_maxwell_count + j0_B_maxwell_ffs ( iky , ikx , iz , ivmu )% max_idx !> allocate array to hold the reduced number of Fourier coefficients if (. not . associated ( j0_ffs ( iky , ikx , iz , ivmu )% fourier )) & allocate ( j0_ffs ( iky , ikx , iz , ivmu )% fourier ( j0_ffs ( iky , ikx , iz , ivmu )% max_idx )) !> fill the array with the requisite coefficients j0_ffs ( iky , ikx , iz , ivmu )% fourier = aj0_kalpha (: j0_ffs ( iky , ikx , iz , ivmu )% max_idx ) !                   call test_ffs_bessel_coefs (j0_ffs(iky,ikx,iz,ivmu)%fourier, aj0_alpha, iky, ikx, iz, j0_ffs_unit, ivmu) if (. not . associated ( j0_B_maxwell_ffs ( iky , ikx , iz , ivmu )% fourier )) & allocate ( j0_B_maxwell_ffs ( iky , ikx , iz , ivmu )% fourier ( j0_B_maxwell_ffs ( iky , ikx , iz , ivmu )% max_idx )) !> fill the array with the requisite coefficients j0_B_maxwell_ffs ( iky , ikx , iz , ivmu )% fourier = j0_B_maxwell_kalpha (: j0_B_maxwell_ffs ( iky , ikx , iz , ivmu )% max_idx ) !                   call test_ffs_bessel_coefs (j0_B_maxwell_ffs(iky,ikx,iz,ivmu)%fourier, j0_B_maxwell, iky, ikx, iz, j0_B_maxwell_ffs_unit, ivmu) end do end do end do end do deallocate ( aj0_alpha , j0_B_maxwell , j0_B_maxwell_kalpha ) !> calculate the reduction factor of Fourier modes !> used to represent J0 call sum_allreduce ( ia_max_j0_count ) ia_max_j0_reduction_factor = real ( ia_max_j0_count ) / real ( naky * ikx_max * nztot * nmu * nvpa * nspec * naky_all ) call sum_allreduce ( ia_max_j0_B_maxwell_count ) ia_max_j0_B_maxwell_reduction_factor = real ( ia_max_j0_B_maxwell_count ) / real ( naky * ikx_max * nztot * nmu * nvpa * nspec * naky_all ) if ( proc0 ) then write ( * , * ) 'average number of k-alphas needed to represent J0(kperp(alpha))=' , ia_max_j0_reduction_factor * naky , 'out of ' , naky write ( * , * ) 'average number of k-alphas needed to represent J0(kperp(alpha))*B(alpha)*exp(-v&#94;2)=' , & ia_max_j0_B_maxwell_reduction_factor * naky , 'out of ' , naky write ( * , * ) end if deallocate ( wgts ) deallocate ( aj0_kalpha ) deallocate ( kperp2_swap ) !       call close_output_file (j0_ffs_unit) !       call close_output_file (j0_B_maxwell_ffs_unit) contains !> inverse fourier transform coefs%fourier for several phase space points and compare with !> unfiltered version in alpha-space ! subroutine test_ffs_bessel_coefs (coefs, f_alpha, iky, ikx, iz, unit, ivmu) !   use stella_layouts, only: vmu_lo, iv_idx, is_idx, imu_idx !   implicit none !   complex, dimension (:), intent (in) :: coefs !   real, dimension (:), intent (in) :: f_alpha !   integer, intent (in) :: iky, ikx, iz !   integer, intent (in) :: unit !   integer, intent (in), optional :: ivmu !   integer :: iv, imu, is !   if (present(ivmu)) then !      !> coefficients should all be independent of vpa, so only do comparison for one vpa point !      iv = iv_idx(vmu_lo,ivmu) !      if (iv == 1) then !         !> only sample subset of mu locations !         imu = imu_idx(vmu_lo,ivmu) !         if (mod(imu-1,nmu/2-1)==0) then !            is = is_idx(vmu_lo,ivmu) !            call test_ffs_bessel_coefs_subset (coefs, f_alpha, iky, ikx, iz, unit, iv, imu, is) !         end if !      end if !   else !      call test_ffs_bessel_coefs_subset (coefs, f_alpha, iky, ikx, iz, unit) !   end if ! end subroutine test_ffs_bessel_coefs ! subroutine test_ffs_bessel_coefs_subset (coefs, f_alpha, iky, ikx, iz, unit, iv, imu, is) !   use constants, only: pi !   use zgrid, only: nzgrid, zed !   use kt_grids, only: naky, nalpha, aky_all_ordered !   use vpamu_grids, only: mu !   use stella_transforms, only: transform_kalpha2alpha !   use stella_geometry, only: alpha !   implicit none !   complex, dimension (:), intent (in) :: coefs !   real, dimension (:), intent (in) :: f_alpha !   integer, intent (in) :: iky, ikx, iz !   integer, intent (in) :: unit !   integer, intent (in), optional :: iv, imu, is !   complex, dimension (:), allocatable :: coefs_padded !   real, dimension (:), allocatable :: f_alpha_approx !   integer :: ia !   integer :: max_idx !   real :: relative_error !   real, parameter :: minval = 1.0e-3 !   ! only sample a subset of z locations !   if (mod(iz,nzgrid/2)==0) then !      ! consider only kx = 0 !      if (ikx == 1) then !         allocate (coefs_padded(naky)) !         allocate (f_alpha_approx(nalpha)) !         ! initialize the padded coefficient array to zero !         coefs_padded = 0.0 !         ! fill in non-zero entries with truncated Fourier coefficients !         max_idx = size(coefs) !         coefs_padded(:max_idx) = coefs !         ! inverse Fourier transform to get alpha-dependent function !         call transform_kalpha2alpha (coefs_padded, f_alpha_approx) !         if (present(iv)) then !            do ia = 1, nalpha !               relative_error = 2.0*abs(f_alpha(ia)-f_alpha_approx(ia))/(abs(f_alpha(ia)) + abs(f_alpha_approx(ia))) !               write (unit,*) alpha(ia), f_alpha(ia), f_alpha_approx(ia), & !                    relative_error, aky_all_ordered(iky), ikx, iz, zed(iz), iv, imu, mu(imu), is !            end do !            ! user 2*pi periodicity in alpha to fill in final point (for visualization purposes) !            ia = 1 !            relative_error = 2.0*abs(f_alpha(ia)-f_alpha_approx(ia))/(abs(f_alpha(ia)) + abs(f_alpha_approx(ia))) !            write (unit,*) 2.0*pi, f_alpha(1), f_alpha_approx(1), & !                 relative_error, aky_all_ordered(iky), ikx, iz, zed(iz), iv, imu, mu(imu), is !         else !            do ia = 1, nalpha !               relative_error = 2.0*abs(f_alpha(ia)-f_alpha_approx(ia))/(abs(f_alpha(ia)) + abs(f_alpha_approx(ia))) !               write (unit,*) alpha(ia), f_alpha(ia), f_alpha_approx(ia), & !                    relative_error, aky_all_ordered(iky), ikx, iz, zed(iz) !            end do !            ! user 2*pi periodicity in alpha to fill in final point (for visualization purposes) !            ia = 1 !            relative_error = 2.0*abs(f_alpha(ia)-f_alpha_approx(ia))/(abs(f_alpha(ia)) + abs(f_alpha_approx(ia))) !            write (unit,*) 2.0*pi, f_alpha(1), f_alpha_approx(1), & !                 relative_error, aky_all_ordered(iky), ikx, iz, zed(iz) !         end if !         write (unit,*) !         deallocate (coefs_padded, f_alpha_approx) !      end if !   end if ! end subroutine test_ffs_bessel_coefs_subset end subroutine init_bessel_ffs !> subroutine takes a set of Fourier coefficients (ft) !> and returns the minimum number of coeffients that must be retained (idx) !> to ensure that the relative error in the total spectral energy is !> below a specified tolerance (tol_floor) subroutine find_max_required_kalpha_index ( ft , idx , imu , iz , is ) use vpamu_grids , only : maxwell_mu implicit none complex , dimension (:), intent ( in ) :: ft integer , intent ( out ) :: idx integer , intent ( in ), optional :: imu , iz , is real , parameter :: tol_floor = 1.0e-8 integer :: i , n real :: subtotal , total real :: tol real , dimension (:), allocatable :: ftmod2 n = size ( ft ) ! use conservative estimate ! when deciding number of modes to retain if ( present ( imu ) . and . present ( iz ) . and . present ( is )) then !       tol = min(0.1,tol_floor/maxval(maxwell_mu(:,iz,imu,is))) tol = min ( 1.0e-6 , tol_floor / maxval ( maxwell_mu (:, iz , imu , is ))) else tol = tol_floor end if allocate ( ftmod2 ( n )) ! get spectral energy associated with each mode ftmod2 = sqrt ( real ( ft * conjg ( ft ))) ! get total spectral energy total = sqrt ( sum ( ftmod2 )) subtotal = 0. ! find minimum spectral index for which ! desired percentage of spectral energy contained ! in modes with indices at or below it if ( total > 0. ) then i = 1 do while ( subtotal < total * ( 1.0 - tol )) idx = i subtotal = sqrt ( sum ( ftmod2 (: i ))) i = i + 1 end do else idx = 1 end if deallocate ( ftmod2 ) end subroutine find_max_required_kalpha_index subroutine finish_bessel implicit none if ( allocated ( aj0v )) deallocate ( aj0v ) if ( allocated ( aj1v )) deallocate ( aj1v ) if ( allocated ( aj0x )) deallocate ( aj0x ) if ( allocated ( aj1x )) deallocate ( aj1x ) if ( allocated ( j0_ffs )) deallocate ( j0_ffs ) if ( allocated ( j0_B_maxwell_ffs )) deallocate ( j0_B_maxwell_ffs ) bessinit = . false . end subroutine finish_bessel subroutine gyro_average_kxky_local ( field , iz , ivmu , gyro_field ) use physics_flags , only : full_flux_surface implicit none complex , dimension (:, :), intent ( in ) :: field integer , intent ( in ) :: iz , ivmu complex , dimension (:, :), intent ( out ) :: gyro_field if ( full_flux_surface ) then !> if simulating a full flux surface, the alpha dependence present !> in kperp makes gyro-averaging non-local in k-space call gyro_average ( field , gyro_field , j0_ffs (:, :, iz , ivmu )) else !> if simulating a flux tube, a gyro-average is local in k-space gyro_field = aj0x (:, :, iz , ivmu ) * field end if end subroutine gyro_average_kxky_local subroutine gyro_average_kxkyz_local ( field , ivmu , gyro_field ) use physics_flags , only : full_flux_surface use zgrid , only : nzgrid , ntubes implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: field integer , intent ( in ) :: ivmu complex , dimension (:, :, - nzgrid :, :), intent ( out ) :: gyro_field if ( full_flux_surface ) then !> if simulating a full flux surface, the alpha dependence present !> in kperp makes gyro-averaging non-local in k-space call gyro_average ( field , gyro_field , j0_ffs (:, :, :, ivmu )) else !> if simulating a flux tube, a gyro-average is local in k-space gyro_field = spread ( aj0x (:, :, :, ivmu ), 4 , ntubes ) * field end if end subroutine gyro_average_kxkyz_local subroutine gyro_average_ffs_kxky_local ( field , gyro_field , coefs ) use kt_grids , only : naky , nakx use kt_grids , only : naky_all , ikx_max use kt_grids , only : swap_kxky_ordered , swap_kxky_back_ordered implicit none complex , dimension (:, :), intent ( in ) :: field complex , dimension (:, :), intent ( out ) :: gyro_field type ( coupled_alpha_type ), dimension (:, :), intent ( in ) :: coefs integer :: iky , ikx , ikyp integer :: idx complex , dimension (:, :), allocatable :: field_kyall , gyro_field_kyall ! need to switch from ky>=0 and all kx ! to kx>=0 and all ky (using reality condition) allocate ( field_kyall ( naky_all , ikx_max )) allocate ( gyro_field_kyall ( naky_all , ikx_max )); gyro_field_kyall = 0. call swap_kxky_ordered ( field , field_kyall ) ! NB: J0(kx,ky) = J0(-kx,-ky) and Gamma0(kx,ky) = Gamma0(-kx,-ky) do ikx = 1 , ikx_max do iky = 1 , naky_all ! account for contributions from less positive ky values (and this ky itself) do ikyp = 1 , min ( naky , iky ) ! idx is the index corresponding to k_alpha - k_alpha' ! runs from iky down to 1 idx = iky - ikyp + 1 ! if the Fourier coefficient corresponding to this value of (k_alpha-k_alpha',k_alpha') ! is sufficiently small, then it will not have been included in the truncated version ! of the coefficients; in this case, it makes no contribution to the gyro-average sum if ( coefs ( idx , ikx )% max_idx >= ikyp ) then gyro_field_kyall ( iky , ikx ) = gyro_field_kyall ( iky , ikx ) & + coefs ( idx , ikx )% fourier ( ikyp ) * field_kyall ( idx , ikx ) end if end do ! if iky = naky_all, then already at max positive ky, so no contributions ! from more positive ky value possible if ( iky == naky_all ) cycle ! account for contributions from more positive ky values (but not this ky itself, ! as already accounted for above do ikyp = 2 , min ( naky , naky_all - iky + 1 ) ! idx is the index corresponding to k_alpha - k_alpha' ! runs from iky + 1 up to iky + naky (or until naky_all, if it is reached first) idx = iky + ikyp - 1 ! if the Fourier coefficient corresponding to this value of (k_alpha-k_alpha',k_alpha') ! is sufficiently small, then it will not have been included in the truncated version ! of the coefficients; in this case, it makes no contribution to the gyro-average sum if ( coefs ( idx , ikx )% max_idx >= ikyp ) then ! the k_alpha' values considered in this loop are negative, but only have ! Fourier coefficients for positive ky values; ! must use the reality condition to convert this to the equivalent coefficients for negative ky gyro_field_kyall ( iky , ikx ) = gyro_field_kyall ( iky , ikx ) & + conjg ( coefs ( idx , ikx )% fourier ( ikyp )) * field_kyall ( idx , ikx ) end if end do end do end do call swap_kxky_back_ordered ( gyro_field_kyall , gyro_field ) deallocate ( field_kyall , gyro_field_kyall ) end subroutine gyro_average_ffs_kxky_local subroutine gyro_average_ffs_kxkyz_local ( field , gyro_field , coefs ) use zgrid , only : nzgrid , ntubes implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: field complex , dimension (:, :, - nzgrid :, :), intent ( out ) :: gyro_field type ( coupled_alpha_type ), dimension (:, :, - nzgrid :), intent ( in ) :: coefs integer :: iz , it do it = 1 , ntubes do iz = - nzgrid , nzgrid call gyro_average ( field (:, :, iz , it ), gyro_field (:, :, iz , it ), coefs (:, :, iz )) end do end do end subroutine gyro_average_ffs_kxkyz_local subroutine gyro_average_ffs ( dist , gyro_dist , coefs ) use common_types , only : coupled_alpha_type use stella_layouts , only : vmu_lo use zgrid , only : nzgrid implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: dist complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( out ) :: gyro_dist type ( coupled_alpha_type ), dimension (:, :, - nzgrid :, vmu_lo % llim_proc :), intent ( in ) :: coefs integer :: ivmu do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc call gyro_average ( dist (:, :, :, :, ivmu ), gyro_dist (:, :, :, :, ivmu ), coefs (:, :, :, ivmu )) end do end subroutine gyro_average_ffs subroutine gyro_average_vmu_local ( distfn , ikxkyz , gyro_distfn ) use vpamu_grids , only : nvpa implicit none complex , dimension (:, :), intent ( in ) :: distfn integer , intent ( in ) :: ikxkyz complex , dimension (:, :), intent ( out ) :: gyro_distfn gyro_distfn = spread ( aj0v (:, ikxkyz ), 1 , nvpa ) * distfn end subroutine gyro_average_vmu_local subroutine gyro_average_vmus_nonlocal ( field , iky , ikx , iz , gyro_field ) use stella_layouts , only : vmu_lo implicit none complex , dimension ( vmu_lo % llim_proc :), intent ( in ) :: field integer , intent ( in ) :: iky , ikx , iz complex , dimension ( vmu_lo % llim_proc :), intent ( out ) :: gyro_field gyro_field = aj0x ( iky , ikx , iz , :) * field end subroutine gyro_average_vmus_nonlocal subroutine gyro_average_j1_kxky_local ( field , iz , ivmu , gyro_field ) implicit none complex , dimension (:, :), intent ( in ) :: field integer , intent ( in ) :: iz , ivmu complex , dimension (:, :), intent ( out ) :: gyro_field gyro_field = aj1x (:, :, iz , ivmu ) * field end subroutine gyro_average_j1_kxky_local subroutine gyro_average_j1_kxkyz_local ( field , ivmu , gyro_field ) use zgrid , only : nzgrid , ntubes implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: field integer , intent ( in ) :: ivmu complex , dimension (:, :, - nzgrid :, :), intent ( out ) :: gyro_field integer :: iz , it do it = 1 , ntubes do iz = - nzgrid , nzgrid gyro_field (:, :, iz , it ) = aj1x (:, :, iz , ivmu ) * field (:, :, iz , it ) end do end do end subroutine gyro_average_j1_kxkyz_local subroutine gyro_average_j1_vmu_local ( distfn , ikxkyz , gyro_distfn ) use vpamu_grids , only : nvpa implicit none complex , dimension (:, :), intent ( in ) :: distfn integer , intent ( in ) :: ikxkyz complex , dimension (:, :), intent ( out ) :: gyro_distfn gyro_distfn = spread ( aj1v (:, ikxkyz ), 1 , nvpa ) * distfn end subroutine gyro_average_j1_vmu_local subroutine band_lu_solve_ffs ( lu , solvec ) use common_types , only : gam0_ffs_type use zgrid , only : nzgrid use kt_grids , only : ikx_max implicit none type ( gam0_ffs_type ), dimension (:, - nzgrid :), intent ( in ) :: lu complex , dimension (:, :, - nzgrid :), intent ( in out ) :: solvec integer :: ikx , iz do iz = - nzgrid , nzgrid do ikx = 1 , ikx_max call band_lu_solve_ffs_single ( lu ( ikx , iz ), solvec (:, ikx , iz )) end do end do end subroutine band_lu_solve_ffs subroutine band_lu_solve_ffs_single ( lu , solvec ) use common_types , only : gam0_ffs_type use kt_grids , only : naky implicit none type ( gam0_ffs_type ), intent ( in ) :: lu complex , dimension (:), intent ( in out ) :: solvec integer :: n , nsubdiag , nsupdiag , nrhs integer :: info complex , dimension (:, :), allocatable :: solmat ! n is the order of the matrix for which we have the LU factorisation n = size ( lu % pivot_index ) ! nsubdiag and nsupdiag are the number of sub- and super-diagonals within the band of the matrix to be decomposed nsubdiag = naky - 1 ; nsupdiag = naky - 1 ! nrhs is the number of right-hand sides of the matrix equation lu%matrix * solvec = rhs for which to solve nrhs = 1 ! initialise solmat = rhs, as it will be overwritten by zgbtrs below allocate ( solmat ( size ( solvec ), 1 )) solmat (:, 1 ) = solvec call zgbtrs ( 'N' , n , nsubdiag , nsupdiag , nrhs , lu % matrix , size ( lu % matrix , 1 ), lu % pivot_index , solmat , size ( solmat , 1 ), info ) solvec = solmat (:, 1 ) deallocate ( solmat ) end subroutine band_lu_solve_ffs_single subroutine band_lu_factorisation_ffs ( gam0 , lu_gam0 ) use common_types , only : coupled_alpha_type , gam0_ffs_type use zgrid , only : nzgrid use kt_grids , only : ikx_max , naky_all , naky implicit none type ( coupled_alpha_type ), dimension (:, :, - nzgrid :), intent ( in ) :: gam0 type ( gam0_ffs_type ), dimension (:, - nzgrid :), intent ( out ) :: lu_gam0 integer :: iky , ikx , iz complex , dimension (:, :), allocatable :: gam0tmp allocate ( gam0tmp ( naky , naky_all )) do ikx = 1 , ikx_max do iz = - nzgrid , nzgrid ! create array from Fourier coefficients of Gamma_0(ky,y) do iky = 1 , naky_all gam0tmp (:, iky ) = gam0 ( iky , ikx , iz )% fourier end do call band_lu_factorisation_single ( gam0tmp , lu_gam0 ( ikx , iz )) end do end do deallocate ( gam0tmp ) end subroutine band_lu_factorisation_ffs subroutine band_lu_factorisation_single ( gam0 , lu_gam0 ) use common_types , only : gam0_ffs_type use kt_grids , only : naky , naky_all implicit none complex , dimension (:, :), intent ( in ) :: gam0 type ( gam0_ffs_type ), intent ( out ) :: lu_gam0 integer :: nrows , ncols , nsubdiag , nsupdiag , leading_dim integer :: info integer :: i , imod ! nrows and ncols are the number of rows and columns of the matrix to be LU-decomposed (variant of gam0) ! this matrix is naky_all x naky_all nrows = naky_all ; ncols = naky_all ! nsubdiag and nsupdiag are the number of sub- and super-diagonals within the band of the matrix to be decomposed nsubdiag = naky - 1 ; nsupdiag = naky - 1 ! leading_dim is the 'leading dimension' of the lu_gam0 array leading_dim = 2 * nsubdiag + nsupdiag + 1 ! lu_gam0 is a re-arranged version of gam0 on entry, and on exit contains details of LU factorisation ! that can be used by zgbtrs to solve the linear system gam0 * phi = rhs if (. not . associated ( lu_gam0 % matrix )) then allocate ( lu_gam0 % matrix ( leading_dim , ncols )) ! initialise first nsubdiag rows to zero, as they are unused lu_gam0 % matrix (: nsubdiag , :) = 0.0 ! fill next supdiag rows using elements from super-diagonals ! using reality of gam0 to set fourier(ky < 0) = conjg(fourier(ky > 0)) do i = 1 , nsupdiag imod = naky - i + 1 lu_gam0 % matrix ( nsubdiag + i , imod :) = conjg ( gam0 ( imod , imod :)) ! fill unused entries with zero lu_gam0 % matrix ( nsubdiag + i , : imod - 1 ) = 0.0 end do ! fill next row using main diagonal entries lu_gam0 % matrix ( nsubdiag + nsupdiag + 1 , :) = gam0 ( 1 , :) ! fill remaining nsubdiag rows using elements from sub-diagonals do i = 1 , nsubdiag imod = naky + i - 1 lu_gam0 % matrix ( leading_dim - i + 1 , : imod ) = gam0 ( naky - i + 1 , : imod ) ! fill unused entries with zeroes lu_gam0 % matrix ( leading_dim - i + 1 , imod + 1 :) = 0.0 end do end if if (. not . associated ( lu_gam0 % pivot_index )) allocate ( lu_gam0 % pivot_index ( min ( nrows , ncols ))) ! overwrites lu_gam0%matrix with information needed to solve the linear system gam0 * phi = rhs; ! also returns pivot_index, with pivot_index(i) giving the row of the matrix interchanged with the ith row, ! and info, which should be zero if the LU factorisation is successful call zgbtrf ( nrows , ncols , nsubdiag , nsupdiag , lu_gam0 % matrix , leading_dim , lu_gam0 % pivot_index , info ) end subroutine band_lu_factorisation_single ! subroutine test_band_lu_factorisation (gam0, lu_gam0) !   use common_types, only: coupled_alpha_type, gam0_ffs_type !   use zgrid, only: nzgrid !   use kt_grids, only: naky_all, naky !   implicit none !   type (coupled_alpha_type), dimension (:,:,-nzgrid:), intent (in) :: gam0 !   type (gam0_ffs_type), dimension (:,-nzgrid:), intent (out) :: lu_gam0 !   integer :: iky, ikx, ikyp, iz !   complex, dimension (naky_all) :: solvec !   ikx = 1 ; iz = -nzgrid !   do iky = 1, naky_all !      do ikyp = 1, naky !         gam0(iky,ikx,iz)%fourier(ikyp) = iky-naky + ikyp-1 !      end do !   end do !   call band_lu_factorisation_ffs (gam0, lu_gam0) !   do iky = 1, naky_all !      solvec(iky) = iky !   end do !   call band_lu_solve_ffs_single (lu_gam0(ikx,iz), solvec) !   do iky = 1, naky_all !      write (*,*) 'iky: ', iky, 'solution: ', solvec(iky) !   end do !   stop ! end subroutine test_band_lu_factorisation end module gyro_averages","tags":"","loc":"sourcefile/gyro_averages.f90.html"},{"title":"flow_shear.f90 â€“ stella","text":"Contents Modules flow_shear Source Code flow_shear.f90 Source Code module flow_shear implicit none public :: flow_shear_initialized public :: init_flow_shear , finish_flow_shear public :: prl_shear , prl_shear_p , prp_shear public :: advance_parallel_flow_shear , advance_perp_flow_shear public :: v_edge , v_shift public :: shift_times private logical :: flow_shear_initialized = . false . complex , dimension (:, :), allocatable :: upwind_advect real , dimension (:, :, :), allocatable :: prl_shear , prl_shear_p real , dimension (:), allocatable :: prp_shear , shift_times integer :: shift_sign , shift_start real :: v_edge , v_shift = 0. contains subroutine init_flow_shear use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx , imu_idx , is_idx use stella_time , only : code_dt use species , only : spec use constants , only : zi , pi use zgrid , only : nzgrid use kt_grids , only : x , x_d , nalpha , nx , nakx , naky , akx , aky , ikx_max , zonal_mode , box use fields_arrays , only : shift_state use stella_geometry , only : q_as_x , geo_surf , bmag , btor , rmajor , dBdrho , dIdrho use stella_geometry , only : dydalpha , drhodpsi use physics_parameters , only : g_exb , g_exbfac , omprimfac use vpamu_grids , only : vperp2 , vpa , mu use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use physics_flags , only : radial_variation , prp_shear_enabled , hammett_flow_shear use file_utils , only : runtype_option_switch , runtype_multibox use job_manage , only : njobs use mp , only : job , send , receive , crossdomprocs , subprocs , scope implicit none integer :: is , imu , iv , ivmu , iz , ia real , dimension (:, :), allocatable :: energy if ( flow_shear_initialized ) return flow_shear_initialized = . true . if ( abs ( g_exb * g_exbfac ) > epsilon ( 0. )) prp_shear_enabled = . true . if ( runtype_option_switch == runtype_multibox . and . job == 1 ) then hammett_flow_shear = . false . end if if ( runtype_option_switch == runtype_multibox ) then call scope ( crossdomprocs ) if ( job == 1 ) then call send ( g_exbfac * g_exb * x ( 1 ), 0 , 120 ) call send ( g_exbfac * g_exb * x ( nx ), njobs - 1 , 121 ) v_shift = 0.0 elseif ( job == 0 ) then call receive ( v_edge , 1 , 120 ) v_shift = v_edge - g_exbfac * g_exb * x ( 1 ) elseif ( job == njobs - 1 ) then call receive ( v_edge , 1 , 121 ) v_shift = v_edge - g_exbfac * g_exb * x ( nx ) end if call scope ( subprocs ) end if ia = 1 !parallel flow shear allocate ( energy ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( prl_shear )) then allocate ( prl_shear ( nalpha , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) prl_shear = 0.0 end if if ( radial_variation . and . . not . allocated ( prl_shear_p )) & allocate ( prl_shear_p ( nalpha , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) do iz = - nzgrid , nzgrid prl_shear ( ia , iz , ivmu ) = - omprimfac * g_exb * code_dt * vpa ( iv ) * spec ( is )% stm_psi0 & * dydalpha * drhodpsi & * ( geo_surf % qinp_psi0 / geo_surf % rhoc_psi0 ) & * ( btor ( iz ) * rmajor ( iz ) / bmag ( ia , iz )) * ( spec ( is )% mass / spec ( is )% temp ) & * maxwell_vpa ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) * maxwell_fac ( is ) end do if ( radial_variation ) then energy = ( vpa ( iv ) ** 2 + vperp2 (:, :, imu )) * ( spec ( is )% temp_psi0 / spec ( is )% temp ) prl_shear_p (:, :, ivmu ) = prl_shear (:, :, ivmu ) * ( dIdrho / spread ( rmajor * btor , 1 , nalpha ) & - spread ( dBdrho , 1 , nalpha ) / bmag & - spec ( is )% fprim - spec ( is )% tprim * ( energy - 2.5 ) & - 2. * mu ( imu ) * spread ( dBdrho , 1 , nalpha )) end if end do if ( q_as_x ) prl_shear = prl_shear / geo_surf % shat_psi0 deallocate ( energy ) !perpendicular flow shear if (. not . allocated ( shift_times )) allocate ( shift_times ( naky )) if (. not . allocated ( upwind_advect )) allocate ( upwind_advect ( naky , nakx )) if (. not . allocated ( shift_state )) then allocate ( shift_state ( naky )) shift_state = 0. end if if ( nakx > 1 . and . abs ( g_exb * g_exbfac ) > 0 ) then shift_times = abs ( akx ( 2 ) / ( aky * g_exb * g_exbfac )) end if if ( zonal_mode ( 1 )) shift_times ( 1 ) = huge ( 0. ) if ( g_exb * g_exbfac > 0. ) then shift_sign = - 1 shift_start = ikx_max else shift_sign = 1 shift_start = ikx_max + 1 end if if ( box ) upwind_advect = exp ( - zi * g_exbfac * g_exb * code_dt * spread ( aky , 2 , nakx ) * spread ( x_d , 1 , naky )) end subroutine init_flow_shear subroutine advance_parallel_flow_shear ( gout ) use mp , only : proc0 , mp_abort use physics_flags , only : full_flux_surface use stella_layouts , only : vmu_lo use zgrid , only : nzgrid , ntubes use kt_grids , only : nakx , naky use fields , only : get_dchidy use fields_arrays , only : phi , apar implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: gout complex , dimension (:, :), allocatable :: g0k integer :: ivmu , iz , it , ia ia = 1 allocate ( g0k ( naky , nakx )) if ( full_flux_surface ) then if ( proc0 ) write ( * , * ) '!!!WARNING: flow shear not currently supported for full_flux_surface=T!!!' call mp_abort ( \"flow shear not currently supported for full_flux_surface=T.\" ) end if do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid call get_dchidy ( iz , ivmu , phi (:, :, iz , it ), apar (:, :, iz , it ), g0k ) !parallel flow shear gout (:, :, iz , it , ivmu ) = gout (:, :, iz , it , ivmu ) + prl_shear ( ia , iz , ivmu ) * g0k end do end do end do deallocate ( g0k ) end subroutine advance_parallel_flow_shear subroutine advance_perp_flow_shear ( g ) use stella_layouts , only : vmu_lo use constants , only : zi use physics_flags , only : prp_shear_enabled , hammett_flow_shear use stella_transforms , only : transform_kx2x_unpadded , transform_x2kx_unpadded use zgrid , only : nzgrid , ntubes use fields_arrays , only : shift_state use kt_grids , only : aky , nakx , naky , ikx_max , zonal_mode use file_utils , only : runtype_option_switch , runtype_multibox use stella_time , only : code_dt implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: g complex , dimension (:, :), allocatable :: g0k , g0x real :: shift_fac integer :: ivmu , iz , it , iky if (. not . prp_shear_enabled ) return allocate ( g0k ( naky , nakx )) allocate ( g0x ( naky , nakx )) if ( hammett_flow_shear ) then !TODO (DSO) - This assumes the timestep is small enough so that a shift is never !             more than a single cell do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid do iky = 1 , naky if ( zonal_mode ( iky )) cycle if ( shift_state ( iky ) > 0.5 * shift_times ( iky )) then if ( shift_sign < 0 ) then !shift everything left by one g ( iky , ( ikx_max + 1 ):( nakx - 1 ), iz , it , ivmu ) = g ( iky , ikx_max + 2 :, iz , it , ivmu ) g ( iky , nakx , iz , it , ivmu ) = g ( iky , 1 , iz , it , ivmu ) g ( iky , : ikx_max - 1 , iz , it , ivmu ) = g ( iky , 2 : ikx_max , iz , it , ivmu ) else !shift everything right by one g ( iky , 2 : ikx_max , iz , it , ivmu ) = g ( iky , 1 :( ikx_max - 1 ), iz , it , ivmu ) g ( iky , 1 , iz , it , ivmu ) = g ( iky , nakx , iz , it , ivmu ) g ( iky , ikx_max + 2 :, iz , it , ivmu ) = g ( iky , ( ikx_max + 1 ):( nakx - 1 ), iz , it , ivmu ) end if g ( iky , shift_start , iz , it , ivmu ) = 0. end if end do end do end do end do else do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid g0k = g (:, :, iz , it , ivmu ) call transform_kx2x_unpadded ( g0k , g0x ) g0x = upwind_advect * g0x call transform_x2kx_unpadded ( g0x , g0k ) do iky = 1 , naky if ( zonal_mode ( iky )) cycle if ( shift_state ( iky ) > shift_times ( iky )) then g0k ( iky , shift_start ) = 0.0 end if end do g (:, :, iz , it , ivmu ) = g0k end do end do end do end if shift_fac = 1.0 if ( hammett_flow_shear ) shift_fac = 0.5 do iky = 1 , naky if ( zonal_mode ( iky )) cycle if ( shift_state ( iky ) > shift_fac * shift_times ( iky )) then shift_state ( iky ) = shift_state ( iky ) - shift_times ( iky ) end if end do shift_state = shift_state + code_dt if ( zonal_mode ( 1 )) shift_state ( 1 ) = 0. if ( runtype_option_switch == runtype_multibox ) then do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid g (:, :, iz , it , ivmu ) = g (:, :, iz , it , ivmu ) * exp ( - code_dt * zi * spread ( aky , 2 , nakx ) * v_shift ) end do end do end do end if deallocate ( g0k , g0x ) end subroutine advance_perp_flow_shear subroutine finish_flow_shear use fields_arrays , only : shift_state implicit none if ( allocated ( prl_shear )) deallocate ( prl_shear ) if ( allocated ( prl_shear_p )) deallocate ( prl_shear_p ) if ( allocated ( shift_times )) deallocate ( shift_times ) if ( allocated ( shift_state )) deallocate ( shift_state ) if ( allocated ( upwind_advect )) deallocate ( upwind_advect ) flow_shear_initialized = . false . end subroutine finish_flow_shear end module flow_shear","tags":"","loc":"sourcefile/flow_shear.f90.html"},{"title":"stella_save.fpp â€“ stella","text":"Contents Modules stella_save Source Code stella_save.fpp Source Code # include \"define.inc\" module stella_save use mp , only : mp_comm , mp_info # ifdef NETCDF !  use netcdf, only: NF90_FLOAT, NF90_DOUBLE # ifdef NETCDF_PARALLEL ! If using netcdf version 4.1.2 or older delete NF90_MPIIO use netcdf , only : NF90_HDF5 , NF90_MPIIO use netcdf , only : nf90_var_par_access , NF90_COLLECTIVE use netcdf , only : nf90_put_att , NF90_GLOBAL , nf90_get_att # endif use netcdf , only : NF90_NOWRITE , NF90_CLOBBER , NF90_NOERR use netcdf , only : nf90_create , nf90_open , nf90_sync , nf90_close use netcdf , only : nf90_def_dim , nf90_def_var , nf90_enddef use netcdf , only : nf90_put_var , nf90_get_var , nf90_strerror use netcdf , only : nf90_inq_dimid , nf90_inquire_dimension use netcdf , only : nf90_inq_varid , nf90_inquire_variable use netcdf , only : nf90_int use netcdf_utils , only : get_netcdf_code_precision use netcdf_utils , only : check_netcdf_file_precision use netcdf_utils , only : netcdf_error use netcdf_utils , only : netcdf_real , kind_nf # endif implicit none public :: stella_restore , stella_save_for_restart public :: read_many , save_many public :: init_save , init_dt , init_tstart , finish_save !# ifdef NETCDF !  public :: netcdf_real, kind_nf, get_netcdf_code_precision, netcdf_error !# endif interface stella_restore module procedure stella_restore_many end interface logical :: read_many = . true ., save_many = . true . ! Read and write single or multiple restart files private character ( 300 ), save :: restart_file # ifdef NETCDF real , allocatable , dimension (:, :, :) :: tmpr , tmpi real , allocatable , dimension (:, :, :, :) :: ktmpr , ktmpi real , allocatable , dimension (:, :, :, :) :: ptmpr , ptmpi real , allocatable , dimension (:, :, :) :: pptmpr , pptmpi integer ( kind_nf ) :: ncid , zedid , vpaid , gloid , gvmuloid , kyid , kxid , muid , tubeid integer ( kind_nf ) :: krookr_id , krooki_id , projr_id , proji_id integer ( kind_nf ) :: phiprojr_id , phiproji_id !  integer (kind_nf) :: bparr_id, bpari_id integer ( kind_nf ) :: t0id , gr_id , gi_id , delt0id , istep0id integer ( kind_nf ) :: intkrook_id , intproj_id ; integer ( kind_nf ) :: shift_id logical :: initialized = . false . # endif contains !!----------------------------------------------------------------------!! !!----------------------------------------------------------------------!! !!--Save----------------------------------------------------------------!! !!----------------------------------------------------------------------!! !!----------------------------------------------------------------------!! subroutine stella_save_for_restart & ( g , istep0 , t0 , delt0 , istatus , exit_in , fileopt ) # ifdef NETCDF use fields_arrays , only : shift_state , phi_proj use dist_fn_arrays , only : g_krook , g_proj use kt_grids , only : naky , nakx # else use mp , only : proc0 # endif use mp , only : iproc , barrier # ifdef NETCDF_PARALLEL use zgrid , only : nztot # endif use zgrid , only : nzgrid , ntubes ! Must include kxkyz_layout_type here to avoid obscure bomb while compiling ! stella_diagnostics.f90 (which uses this module) with the Compaq F90 compiler: use stella_layouts , only : kxkyz_lo , vmu_lo use common_types , only : kxkyz_layout_type use file_utils , only : error_unit use vpamu_grids , only : nvpa , nmu use sources , only : include_krook_operator , int_krook use sources , only : remove_zero_projection , int_proj use sources , only : include_qn_source use physics_flags , only : prp_shear_enabled implicit none complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( in ) :: g real , intent ( in ) :: t0 , delt0 integer , intent ( in ) :: istep0 integer , intent ( out ) :: istatus logical , intent ( in ), optional :: exit_in character ( 20 ), INTENT ( in ), optional :: fileopt # ifdef NETCDF character ( 306 ) :: file_proc character ( 10 ) :: suffix integer :: i , n_elements , nvmulo_elements , ierr integer :: total_elements , total_vmulo_elements logical :: has_vmulo # ifdef NETCDF_PARALLEL integer , dimension ( 3 ) :: start_pos , counts # endif logical :: exit !*********-----------------------_********************** istatus = 0 if ( present ( exit_in )) then exit = exit_in else exit = . false . end if !    if (proc0) then !      write (*,*) \"Starting save_for_restart in \", restart_file !      write (*,*) \"List restart files\" !      call system(\"echo 'start' >> filelist.txt; ls nc/* >> filelist.txt;  \") !    end if n_elements = kxkyz_lo % ulim_proc - kxkyz_lo % llim_proc + 1 total_elements = kxkyz_lo % ulim_world + 1 nvmulo_elements = vmu_lo % ulim_proc - vmu_lo % llim_proc + 1 total_vmulo_elements = vmu_lo % ulim_world + 1 if ( n_elements <= 0 ) return has_vmulo = nvmulo_elements > 0 . or . . not . save_many if (. not . initialized ) then initialized = . true . file_proc = trim ( restart_file ) !CMR, 5/4/2011: Add optional piece of filename IF ( PRESENT ( fileopt )) THEN file_proc = trim ( file_proc ) // trim ( fileopt ) END IF !CMRend !</HL>  The NETCDF_PARALLEL directives include code for parallel !       netcdf using HDF5 to write the output to a single restart file !       The read_many flag allows the old style multiple file output # ifdef NETCDF_PARALLEL if ( save_many ) then # endif WRITE ( suffix , '(a1,i0)' ) '.' , iproc # ifdef NETCDF_PARALLEL else WRITE ( suffix , * ) '' end if # endif file_proc = trim ( trim ( file_proc ) // adjustl ( suffix )) # ifdef NETCDF_PARALLEL if ( save_many ) then # endif istatus = nf90_create ( file_proc , NF90_CLOBBER , ncid ) # ifdef NETCDF_PARALLEL else call barrier if ( iproc == 0 ) then open ( unit = tmpunit , file = file_proc ) close ( unit = tmpunit , status = 'delete' ) end if call barrier ! If using netcdf version 4.1.2 or older replace NF90_MPIIO with NF90_CLOBBER istatus = nf90_create ( file_proc , IOR ( NF90_HDF5 , NF90_MPIIO ), ncid , comm = mp_comm , info = mp_info ) end if # endif if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_create error: \" , nf90_strerror ( istatus ) goto 1 end if # ifdef NETCDF_PARALLEL if (. not . save_many ) then istatus = nf90_put_att ( ncid , NF90_GLOBAL , 'xyzs_layout' , xyzs_layout ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_put_attr error: \" , nf90_strerror ( istatus ) goto 1 end if istatus = nf90_put_att ( ncid , NF90_GLOBAL , 'vms_layout' , vms_layout ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_put_attr error: \" , nf90_strerror ( istatus ) goto 1 end if end if # endif if ( n_elements > 0 ) then istatus = nf90_def_dim ( ncid , \"tube\" , ntubes , tubeid ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_dim zed error: \" , nf90_strerror ( istatus ) goto 1 end if istatus = nf90_def_dim ( ncid , \"zed\" , 2 * nzgrid + 1 , zedid ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_dim zed error: \" , nf90_strerror ( istatus ) goto 1 end if istatus = nf90_def_dim ( ncid , \"vpa\" , nvpa , vpaid ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_dim vpa error: \" , nf90_strerror ( istatus ) goto 1 end if istatus = nf90_def_dim ( ncid , \"mu\" , nmu , muid ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_dim mu error: \" , nf90_strerror ( istatus ) goto 1 end if # ifdef NETCDF_PARALLEL if ( save_many ) then # endif istatus = nf90_def_dim ( ncid , \"glo\" , n_elements , gloid ) # ifdef NETCDF_PARALLEL else istatus = nf90_def_dim ( ncid , \"glo\" , total_elements , gloid ) end if # endif if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_dim glo error: \" , nf90_strerror ( istatus ) goto 1 end if # ifdef NETCDF_PARALLEL if ( save_many ) then # endif if ( nvmulo_elements > 0 ) then istatus = nf90_def_dim ( ncid , \"gvmulo\" , nvmulo_elements , gvmuloid ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_dim gvmulo error: \" , nf90_strerror ( istatus ) goto 1 end if end if # ifdef NETCDF_PARALLEL else istatus = nf90_def_dim ( ncid , \"gvmulo\" , total_vmulo_elements , gvmuloid ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_dim gvmulo error: \" , nf90_strerror ( istatus ) goto 1 end if end if # endif istatus = nf90_def_dim ( ncid , \"aky\" , naky , kyid ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_dim aky error: \" , nf90_strerror ( istatus ) goto 1 end if istatus = nf90_def_dim ( ncid , \"akx\" , nakx , kxid ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_dim akx error: \" , nf90_strerror ( istatus ) goto 1 end if end if if ( netcdf_real == 0 ) netcdf_real = get_netcdf_code_precision () istatus = nf90_def_var ( ncid , \"t0\" , netcdf_real , t0id ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_var t0 error: \" , nf90_strerror ( istatus ) goto 1 end if istatus = nf90_def_var ( ncid , \"istep0\" , nf90_int , istep0id ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_var istep0 error: \" , nf90_strerror ( istatus ) goto 1 end if istatus = nf90_def_var ( ncid , \"delt0\" , netcdf_real , delt0id ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_var delt0 error: \" , nf90_strerror ( istatus ) goto 1 end if if ( n_elements > 0 ) then istatus = nf90_def_var ( ncid , \"gr\" , netcdf_real , & ( / vpaid , muid , gloid / ), gr_id ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_var g error: \" , nf90_strerror ( istatus ) goto 1 end if istatus = nf90_def_var ( ncid , \"gi\" , netcdf_real , & ( / vpaid , muid , gloid / ), gi_id ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_var g error: \" , nf90_strerror ( istatus ) goto 1 end if if ( include_krook_operator . and . has_vmulo ) then istatus = nf90_def_var ( ncid , \"intkrook\" , netcdf_real , intkrook_id ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_var intkrook error: \" , nf90_strerror ( istatus ) goto 1 end if istatus = nf90_def_var ( ncid , \"krookr\" , netcdf_real , & ( / kxid , zedid , tubeid , gvmuloid / ), krookr_id ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_var apar error: \" , nf90_strerror ( istatus ) goto 1 end if istatus = nf90_def_var ( ncid , \"krooki\" , netcdf_real , & ( / kxid , zedid , tubeid , gvmuloid / ), krooki_id ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_var krooki error: \" , nf90_strerror ( istatus ) goto 1 end if end if if ( include_qn_source . and . iproc == 0 ) then istatus = nf90_def_var ( ncid , \"phiprojr\" , netcdf_real , & ( / kxid , zedid , tubeid / ), phiprojr_id ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_var phiprojr error: \" , nf90_strerror ( istatus ) goto 1 end if istatus = nf90_def_var ( ncid , \"phiproji\" , netcdf_real , & ( / kxid , zedid , tubeid / ), phiproji_id ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_var phiproji error: \" , nf90_strerror ( istatus ) goto 1 end if end if if ( remove_zero_projection . and . has_vmulo ) then istatus = nf90_def_var ( ncid , \"intproj\" , netcdf_real , intproj_id ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_var intproj error: \" , nf90_strerror ( istatus ) goto 1 end if istatus = nf90_def_var ( ncid , \"projr\" , netcdf_real , & ( / kxid , zedid , tubeid , gvmuloid / ), projr_id ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_var projr error: \" , nf90_strerror ( istatus ) goto 1 end if istatus = nf90_def_var ( ncid , \"proji\" , netcdf_real , & ( / kxid , zedid , tubeid , gvmuloid / ), proji_id ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_var proji error: \" , nf90_strerror ( istatus ) goto 1 end if end if if ( prp_shear_enabled ) then istatus = nf90_def_var ( ncid , \"shiftstate\" , netcdf_real , & ( / kyid / ), shift_id ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_var shiftstate error: \" , nf90_strerror ( istatus ) goto 1 end if end if !           if (fbpar > epsilon(0.)) then !              istatus = nf90_def_var (ncid, \"bpar_r\", netcdf_real, & !                   (/ zedid, kxid, kyid /), bparr_id) !              if (istatus /= NF90_NOERR) then !                 ierr = error_unit() !                 write(ierr,*) \"nf90_def_var bparr error: \", nf90_strerror(istatus) !                 goto 1 !              end if !              istatus = nf90_def_var (ncid, \"bpar_i\", netcdf_real, & !                   (/ zedid, kxid, kyid /), bpari_id) !              if (istatus /= NF90_NOERR) then !                 ierr = error_unit() !                 write(ierr,*) \"nf90_def_var bpari error: \", nf90_strerror(istatus) !                 goto 1 !              end if !           end if end if ! remove allocated conditional because we want to be able to restart ! using exb shear from a case which does not have exb shear (i.e. ! we need kx_shift variable defined in netcdf file even if no exb ! shear present in simulation) -- MAB + CMR !       if (allocated(kx_shift)) then   ! MR begin !       istatus = nf90_def_var (ncid, \"kx_shift\", netcdf_real, & !            (/ kyid /), kx_shift_id) !       if (istatus /= NF90_NOERR) then !          ierr = error_unit() !          write(ierr,*) \"nf90_def_var kx_shift error: \", nf90_strerror(istatus) !          goto 1 !       endif !       endif   ! MR end !    if (proc0) then !      write (*,*) \"Finished definitions\" !      write (*,*) \"List restart files\" !      call system(\"echo 'defs' >> filelist.txt; ls nc/* >> filelist.txt;  \") !    end if istatus = nf90_enddef ( ncid ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_enddef error: \" , nf90_strerror ( istatus ) goto 1 end if end if !!!-----------------------!!! !!!-----------------------!!! !!!-----------------------!!! # ifdef NETCDF_PARALLEL if ( save_many . or . iproc == 0 ) then # endif istatus = nf90_put_var ( ncid , delt0id , delt0 ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_put_var delt0 error: \" , nf90_strerror ( istatus ) goto 1 end if istatus = nf90_put_var ( ncid , t0id , t0 ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_put_var t0 error: \" , nf90_strerror ( istatus ) goto 1 end if istatus = nf90_put_var ( ncid , istep0id , istep0 ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_put_var istep0 error: \" , nf90_strerror ( istatus ) goto 1 end if # ifdef NETCDF_PARALLEL end if # endif 1 continue if ( istatus /= NF90_NOERR ) then i = nf90_close ( ncid ) return end if if ( n_elements > 0 ) then if (. not . allocated ( tmpr )) & allocate ( tmpr ( nvpa , nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) tmpr = real ( g ) # ifdef NETCDF_PARALLEL if ( save_many ) then # endif istatus = nf90_put_var ( ncid , gr_id , tmpr ) #ifdef NETCDF_PARALLEL else istatus = nf90_var_par_access ( ncid , gr_id , NF90_COLLECTIVE ) istatus = nf90_var_par_access ( ncid , gi_id , NF90_COLLECTIVE ) start_pos = ( / 1 , 1 , kxkyz_lo % llim_proc + 1 / ) counts = ( / nvpa , nmu , n_elements / ) istatus = nf90_put_var ( ncid , gr_id , tmpr , start = start_pos , count = counts ) end if # endif if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , gr_id ) tmpr = aimag ( g ) # ifdef NETCDF_PARALLEL if ( save_many ) then # endif istatus = nf90_put_var ( ncid , gi_id , tmpr ) #ifdef NETCDF_PARALLEL else istatus = nf90_put_var ( ncid , gi_id , tmpr , start = start_pos , count = counts ) end if # endif if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , gi_id ) if ( include_krook_operator . and . has_vmulo ) then if (. not . allocated ( ktmpr )) & allocate ( ktmpr ( nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) if (. not . allocated ( ktmpi )) & allocate ( ktmpi ( nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) # ifdef NETCDF_PARALLEL if ( save_many . or . iproc == 0 ) then # endif istatus = nf90_put_var ( ncid , intkrook_id , int_krook ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_put_var int_krook error: \" , nf90_strerror ( istatus ) goto 1 end if # ifdef NETCDF_PARALLEL end if # endif ktmpr = real ( g_krook ) ktmpi = aimag ( g_krook ) # ifdef NETCDF_PARALLEL if ( save_many ) then # endif istatus = nf90_put_var ( ncid , krookr_id , ktmpr ) #ifdef NETCDF_PARALLEL else istatus = nf90_var_par_access ( ncid , krookr_id , NF90_COLLECTIVE ) istatus = nf90_var_par_access ( ncid , krooki_id , NF90_COLLECTIVE ) start_pos = ( / 1 , 1 , 1 , vmu_lo % llim_proc + 1 / ) counts = ( / nakx , nztot , ntubes , nvmulo_elements / ) istatus = nf90_put_var ( ncid , krookr_id , ktmpr , start = start_pos , count = counts ) end if # endif if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , krookr_id ) # ifdef NETCDF_PARALLEL if ( save_many ) then # endif istatus = nf90_put_var ( ncid , krooki_id , ktmpi ) #ifdef NETCDF_PARALLEL else istatus = nf90_put_var ( ncid , krooki_id , ktmpi , start = start_pos , count = counts ) end if # endif if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , krooki_id ) end if if ( remove_zero_projection . and . has_vmulo ) then if (. not . allocated ( ptmpr )) & allocate ( ptmpr ( nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) if (. not . allocated ( ptmpi )) & allocate ( ptmpi ( nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) # ifdef NETCDF_PARALLEL if ( save_many . or . iproc == 0 ) then # endif istatus = nf90_put_var ( ncid , intproj_id , int_proj ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_put_var int_proj error: \" , nf90_strerror ( istatus ) goto 1 end if # ifdef NETCDF_PARALLEL end if # endif ptmpr = real ( g_proj ) ptmpi = aimag ( g_proj ) # ifdef NETCDF_PARALLEL if ( save_many ) then # endif istatus = nf90_put_var ( ncid , projr_id , ptmpr ) #ifdef NETCDF_PARALLEL else istatus = nf90_var_par_access ( ncid , projr_id , NF90_COLLECTIVE ) istatus = nf90_var_par_access ( ncid , proji_id , NF90_COLLECTIVE ) start_pos = ( / 1 , 1 , 1 , vmu_lo % llim_proc + 1 / ) counts = ( / nakx , nztot , ntubes , nvmulo_elements / ) istatus = nf90_put_var ( ncid , projr_id , ptmpr , start = start_pos , count = counts ) end if # endif if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , projr_id ) # ifdef NETCDF_PARALLEL if ( save_many ) then # endif istatus = nf90_put_var ( ncid , proji_id , ptmpi ) #ifdef NETCDF_PARALLEL else istatus = nf90_put_var ( ncid , proji_id , ptmpi , start = start_pos , count = counts ) end if # endif if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , proji_id ) end if if ( prp_shear_enabled ) then istatus = nf90_put_var ( ncid , shift_id , shift_state ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , shift_id ) end if if ( include_qn_source . and . iproc == 0 ) then if (. not . allocated ( pptmpr )) & allocate ( pptmpr ( nakx , - nzgrid : nzgrid , ntubes )) if (. not . allocated ( pptmpi )) & allocate ( pptmpi ( nakx , - nzgrid : nzgrid , ntubes )) pptmpr = real ( phi_proj ) pptmpi = aimag ( phi_proj ) # ifdef NETCDF_PARALLEL if ( save_many ) then # endif istatus = nf90_put_var ( ncid , phiprojr_id , pptmpr ) #ifdef NETCDF_PARALLEL else istatus = nf90_var_par_access ( ncid , phiprojr_id , NF90_COLLECTIVE ) istatus = nf90_var_par_access ( ncid , phiproji_id , NF90_COLLECTIVE ) start_pos = ( / 1 , 1 , 1 / ) counts = ( / nakx , nztot , ntubes / ) istatus = nf90_put_var ( ncid , phiprojr_id , ktmpr , start = start_pos , count = counts ) end if # endif if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , phiprojr_id ) # ifdef NETCDF_PARALLEL if ( save_many ) then # endif istatus = nf90_put_var ( ncid , phiproji_id , pptmpi ) #ifdef NETCDF_PARALLEL else istatus = nf90_put_var ( ncid , phiproji_id , pptmpi , start = start_pos , count = counts ) end if # endif if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , phiproji_id ) end if end if if ( exit ) then i = nf90_close ( ncid ) if ( i /= NF90_NOERR ) & call netcdf_error ( istatus , message = 'nf90_close error' ) else i = nf90_sync ( ncid ) if ( i /= NF90_NOERR ) & call netcdf_error ( istatus , message = 'nf90_sync error' ) end if # else if ( proc0 ) write ( error_unit (), * ) & 'WARNING: stella_save_for_restart is called without netcdf library' # endif if ( allocated ( tmpr )) deallocate ( tmpr ) if ( allocated ( tmpi )) deallocate ( tmpi ) if ( allocated ( ptmpr )) deallocate ( ptmpr ) if ( allocated ( ptmpi )) deallocate ( ptmpi ) if ( allocated ( ktmpr )) deallocate ( ktmpr ) if ( allocated ( ktmpi )) deallocate ( ktmpi ) if ( allocated ( pptmpr )) deallocate ( pptmpr ) if ( allocated ( pptmpi )) deallocate ( pptmpi ) end subroutine stella_save_for_restart !!----------------------------------------------------------------------!! !!----------------------------------------------------------------------!! !!---Restart------------------------------------------------------------!! !!----------------------------------------------------------------------!! !!----------------------------------------------------------------------!! subroutine stella_restore_many ( g , scale , istatus ) # ifdef NETCDF use fields_arrays , only : shift_state , phi_proj use dist_fn_arrays , only : g_krook , g_proj use kt_grids , only : naky , nakx # endif # ifdef NETCDF_PARALLEL use zgrid , only : nztot # endif use mp , only : iproc , broadcast use zgrid , only : nzgrid , ntubes use vpamu_grids , only : nvpa , nmu use stella_layouts , only : kxkyz_lo , vmu_lo use file_utils , only : error_unit use sources , only : include_krook_operator , int_krook use sources , only : remove_zero_projection , int_proj use physics_flags , only : prp_shear_enabled use sources , only : include_qn_source implicit none complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( out ) :: g real , intent ( in ) :: scale integer , intent ( out ) :: istatus # ifdef NETCDF # ifdef NETCDF_PARALLEL integer , dimension ( 3 ) :: counts , start_pos # endif character ( 306 ) :: file_proc character ( 10 ) :: suffix integer :: i , n_elements , nvmulo_elements , ierr logical :: has_vmulo n_elements = kxkyz_lo % ulim_proc - kxkyz_lo % llim_proc + 1 nvmulo_elements = vmu_lo % ulim_proc - vmu_lo % llim_proc + 1 if ( n_elements <= 0 ) return has_vmulo = nvmulo_elements > 0 . or . . not . read_many if (. not . initialized ) then !       initialized = .true. file_proc = trim ( restart_file ) # ifdef NETCDF_PARALLEL if ( read_many ) then # endif write ( suffix , '(a1,i0)' ) '.' , iproc file_proc = trim ( trim ( file_proc ) // adjustl ( suffix )) istatus = nf90_open ( file_proc , NF90_NOWRITE , ncid ) # ifdef NETCDF_PARALLEL else ! If using netcdf version 4.1.2 deleted NF90_MPIIO and the associated IOR istatus = nf90_open ( file_proc , IOR ( NF90_NOWRITE , NF90_MPIIO ), ncid , comm = mp_comm , info = mp_info ) end if # endif if ( istatus /= NF90_NOERR ) then call netcdf_error ( istatus , file = file_proc , abort = . true .) end if ! check precision if ( netcdf_real == 0 ) netcdf_real = get_netcdf_code_precision () call check_netcdf_file_precision ( ncid ) istatus = nf90_inq_dimid ( ncid , \"tube\" , tubeid ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , dim = 'tube' ) istatus = nf90_inq_dimid ( ncid , \"zed\" , zedid ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , dim = 'zed' ) istatus = nf90_inq_dimid ( ncid , \"aky\" , kyid ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , dim = 'aky' ) istatus = nf90_inq_dimid ( ncid , \"akx\" , kxid ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , dim = 'akx' ) istatus = nf90_inq_dimid ( ncid , \"glo\" , gloid ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , dim = 'glo' ) if ( has_vmulo ) then istatus = nf90_inq_dimid ( ncid , \"gvmulo\" , gvmuloid ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , dim = 'gvmulo' ) end if istatus = nf90_inquire_dimension ( ncid , tubeid , len = i ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , dimid = tubeid ) if ( i /= ntubes ) write ( * , * ) 'Restart error: ntubes=? ' , i , ' : ' , ntubes , ' : ' , iproc istatus = nf90_inquire_dimension ( ncid , zedid , len = i ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , dimid = zedid ) if ( i /= 2 * nzgrid + 1 ) write ( * , * ) 'Restart error: nzgrid=? ' , i , ' : ' , nzgrid , ' : ' , iproc istatus = nf90_inquire_dimension ( ncid , kyid , len = i ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , dimid = kyid ) if ( i /= naky ) write ( * , * ) 'Restart error: naky=? ' , i , ' : ' , naky , ' : ' , iproc istatus = nf90_inquire_dimension ( ncid , kxid , len = i ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , dimid = kxid ) if ( i /= nakx ) write ( * , * ) 'Restart error: nakx=? ' , i , ' : ' , nakx , ' : ' , iproc istatus = nf90_inquire_dimension ( ncid , gloid , len = i ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , dimid = gloid ) #ifdef NETCDF_PARALLEL if ( read_many ) then #endif if ( i /= n_elements ) write ( * , * ) 'Restart error: glo=? ' , i , ' : ' , iproc #ifdef NETCDF_PARALLEL else if ( i /= kxkyz_lo % ulim_world + 1 ) write ( * , * ) 'Restart error: glo=? ' , i , ' : ' , iproc end if #endif if ( has_vmulo ) then istatus = nf90_inquire_dimension ( ncid , gvmuloid , len = i ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , dimid = gvmuloid ) #ifdef NETCDF_PARALLEL if ( read_many ) then #endif if ( i /= nvmulo_elements ) write ( * , * ) 'Restart error: gvmulo=? ' , i , ' : ' , iproc #ifdef NETCDF_PARALLEL else if ( i /= vmu_lo % ulim_world + 1 ) write ( * , * ) 'Restart error: gvmulo=? ' , i , ' : ' , iproc end if #endif end if if ( include_krook_operator . and . has_vmulo ) then istatus = nf90_inq_varid ( ncid , \"intkrook\" , intkrook_id ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , var = 'intkrook' ) istatus = nf90_inq_varid ( ncid , \"krookr\" , krookr_id ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , var = 'krookr' ) istatus = nf90_inq_varid ( ncid , \"krooki\" , krooki_id ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , var = 'krooki' ) end if if ( remove_zero_projection . and . has_vmulo ) then istatus = nf90_inq_varid ( ncid , \"intproj\" , intproj_id ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , var = 'intproj' ) istatus = nf90_inq_varid ( ncid , \"projr\" , projr_id ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , var = 'projr' ) istatus = nf90_inq_varid ( ncid , \"proji\" , proji_id ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , var = 'proji' ) end if if ( include_qn_source . and . iproc == 0 ) then istatus = nf90_inq_varid ( ncid , \"phiprojr\" , phiprojr_id ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , var = 'phiprojr' ) istatus = nf90_inq_varid ( ncid , \"phiproji\" , phiproji_id ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , var = 'phiproji' ) end if if ( prp_shear_enabled ) then istatus = nf90_inq_varid ( ncid , \"shiftstate\" , shift_id ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , var = 'shiftstate' ) end if !        if (fbpar > epsilon(0.)) then !           istatus = nf90_inq_varid (ncid, \"bpar_r\", bparr_id) !           if (istatus /= NF90_NOERR) call netcdf_error (istatus, var='bpar_r') !           istatus = nf90_inq_varid (ncid, \"bpar_i\", bpari_id) !           if (istatus /= NF90_NOERR) call netcdf_error (istatus, var='bpar_i') !        end if !       if (allocated(kx_shift)) then   ! MR begin !          istatus = nf90_inq_varid (ncid, \"kx_shift\", kx_shift_id) !          if (istatus /= NF90_NOERR) call netcdf_error (istatus, var='kx_shift') !       endif   ! MR end istatus = nf90_inq_varid ( ncid , \"gr\" , gr_id ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , var = 'gr' ) istatus = nf90_inq_varid ( ncid , \"gi\" , gi_id ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , var = 'gi' ) end if if (. not . allocated ( tmpr )) & allocate ( tmpr ( nvpa , nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) if (. not . allocated ( tmpi )) & allocate ( tmpi ( nvpa , nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) tmpr = 0. ; tmpi = 0. # ifdef NETCDF_PARALLEL if ( read_many ) then # endif istatus = nf90_get_var ( ncid , gr_id , tmpr ) #ifdef NETCDF_PARALLEL else start_pos = ( / 1 , 1 , kxkyz_lo % llim_proc + 1 / ) counts = ( / nvpa , nmu , n_elements / ) istatus = nf90_get_var ( ncid , gr_id , tmpr , start = start_pos , count = counts ) end if # endif if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , gr_id ) # ifdef NETCDF_PARALLEL if ( read_many ) then # endif istatus = nf90_get_var ( ncid , gi_id , tmpi ) #ifdef NETCDF_PARALLEL else istatus = nf90_get_var ( ncid , gi_id , tmpi , start = start_pos , count = counts ) end if # endif if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , gi_id ) g = cmplx ( tmpr , tmpi ) if ( include_krook_operator . and . has_vmulo ) then if (. not . allocated ( ktmpr )) & allocate ( ktmpr ( nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) if (. not . allocated ( ktmpi )) & allocate ( ktmpi ( nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) istatus = nf90_get_var ( ncid , intkrook_id , int_krook ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , intkrook_id ) ktmpr = 0. ; ktmpi = 0. # ifdef NETCDF_PARALLEL if ( read_many ) then # endif istatus = nf90_get_var ( ncid , krookr_id , ktmpr ) #ifdef NETCDF_PARALLEL else start_pos = ( / 1 , 1 , 1 , vmu_lo % llim_proc + 1 / ) counts = ( / nakx , nztot , ntubes , nvmulo_elements / ) istatus = nf90_get_var ( ncid , krookr_id , ktmpr , start = start_pos , count = counts ) end if # endif if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , krookr_id ) # ifdef NETCDF_PARALLEL if ( read_many ) then # endif istatus = nf90_get_var ( ncid , krooki_id , ktmpi ) #ifdef NETCDF_PARALLEL else istatus = nf90_get_var ( ncid , krooki_id , ktmpi , start = start_pos , count = counts ) end if # endif if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , krooki_id ) g_krook = cmplx ( ktmpr , ktmpi ) end if if ( remove_zero_projection . and . has_vmulo ) then if (. not . allocated ( ptmpr )) & allocate ( ptmpr ( nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) if (. not . allocated ( ptmpi )) & allocate ( ptmpi ( nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) istatus = nf90_get_var ( ncid , intproj_id , int_proj ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , intproj_id ) ptmpr = 0. ; ptmpi = 0. # ifdef NETCDF_PARALLEL if ( read_many ) then # endif istatus = nf90_get_var ( ncid , projr_id , ptmpr ) #ifdef NETCDF_PARALLEL else start_pos = ( / 1 , 1 , 1 , vmu_lo % llim_proc + 1 / ) counts = ( / nakx , nztot , ntubes , nvmulo_elements / ) istatus = nf90_get_var ( ncid , projr_id , ptmpr , start = start_pos , count = counts ) end if # endif if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , projr_id ) # ifdef NETCDF_PARALLEL if ( read_many ) then # endif istatus = nf90_get_var ( ncid , proji_id , ptmpi ) #ifdef NETCDF_PARALLEL else istatus = nf90_get_var ( ncid , proji_id , ptmpi , start = start_pos , count = counts ) end if # endif if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , proji_id ) g_proj = cmplx ( ptmpr , ptmpi ) end if if ( include_qn_source . and . iproc == 0 ) then if (. not . allocated ( pptmpr )) allocate ( pptmpr ( nakx , - nzgrid : nzgrid , ntubes )) if (. not . allocated ( pptmpi )) allocate ( pptmpi ( nakx , - nzgrid : nzgrid , ntubes )) pptmpr = 0. ; pptmpi = 0. # ifdef NETCDF_PARALLEL if ( read_many ) then # endif istatus = nf90_get_var ( ncid , phiprojr_id , pptmpr ) #ifdef NETCDF_PARALLEL else start_pos = ( / 1 , 1 , 1 / ) counts = ( / nakx , nztot , ntubes / ) istatus = nf90_get_var ( ncid , phiprojr_id , pptmpr , start = start_pos , count = counts ) end if # endif if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , phiprojr_id ) # ifdef NETCDF_PARALLEL if ( read_many ) then # endif istatus = nf90_get_var ( ncid , phiproji_id , pptmpi ) #ifdef NETCDF_PARALLEL else istatus = nf90_get_var ( ncid , phiproji_id , pptmpi , start = start_pos , count = counts ) end if # endif if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , phiproji_id ) phi_proj = cmplx ( pptmpr , pptmpi ) end if if ( prp_shear_enabled ) then istatus = nf90_get_var ( ncid , shift_id , shift_state ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , shift_id ) end if if ( scale > 0. ) then g = g * scale if ( include_krook_operator ) g_krook = g_krook * scale if ( remove_zero_projection ) g_proj = g_proj * scale end if ! RN 2008/05/23: this was commented out. why? HJL 2013/05/15 Because it stops future writing to the file !    istatus = nf90_close (ncid) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_close error: \" , nf90_strerror ( istatus ), ' ' , iproc end if # else write ( error_unit (), * ) & 'ERROR: stella_restore_many is called without netcdf' # endif if ( allocated ( tmpr )) deallocate ( tmpr ) if ( allocated ( tmpi )) deallocate ( tmpi ) if ( allocated ( ptmpr )) deallocate ( ptmpr ) if ( allocated ( ptmpi )) deallocate ( ptmpi ) if ( allocated ( ktmpr )) deallocate ( ktmpr ) if ( allocated ( ktmpi )) deallocate ( ktmpi ) if ( allocated ( pptmpr )) deallocate ( pptmpr ) if ( allocated ( pptmpi )) deallocate ( pptmpi ) if ( include_qn_source ) call broadcast ( phi_proj ) end subroutine stella_restore_many subroutine init_save ( file ) character ( 300 ), intent ( in ) :: file restart_file = file end subroutine init_save subroutine init_dt ( delt0 , istatus ) # ifdef NETCDF use mp , only : proc0 , broadcast use file_utils , only : error_unit # endif implicit none real , intent ( in out ) :: delt0 integer , intent ( out ) :: istatus # ifdef NETCDF character ( 306 ) :: file_proc if ( proc0 ) then if (. not . initialized ) then # ifdef NETCDF_PARALLEL if ( read_many ) then # endif file_proc = trim ( trim ( restart_file ) // '.0' ) # ifdef NETCDF_PARALLEL else file_proc = trim ( trim ( restart_file )) end if # endif istatus = nf90_open ( file_proc , NF90_NOWRITE , ncid ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , file = file_proc ) istatus = nf90_inq_varid ( ncid , \"delt0\" , delt0id ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , var = 'delt0' ) end if istatus = nf90_get_var ( ncid , delt0id , delt0 ) if ( istatus /= NF90_NOERR ) then call netcdf_error ( istatus , ncid , delt0id , message = ' in init_dt' ) delt0 = - 1. end if if (. not . initialized ) istatus = nf90_close ( ncid ) end if call broadcast ( istatus ) call broadcast ( delt0 ) # endif end subroutine init_dt subroutine init_tstart ( tstart , istep0 , istatus ) # ifdef NETCDF use mp , only : proc0 , broadcast use file_utils , only : error_unit # endif implicit none real , intent ( in out ) :: tstart integer , intent ( out ) :: istep0 integer , intent ( out ) :: istatus # ifdef NETCDF character ( 306 ) :: file_proc if ( proc0 ) then # ifdef NETCDF_PARALLEL if ( read_many ) then # endif file_proc = trim ( trim ( restart_file ) // '.0' ) # ifdef NETCDF_PARALLEL else file_proc = trim ( trim ( restart_file )) end if # endif if (. not . initialized ) then istatus = nf90_open ( file_proc , NF90_NOWRITE , ncid ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , file = file_proc ) end if istatus = nf90_inq_varid ( ncid , \"t0\" , t0id ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , var = 't0' ) istatus = nf90_get_var ( ncid , t0id , tstart ) if ( istatus /= NF90_NOERR ) then call netcdf_error ( istatus , ncid , t0id , message = ' in init_tstart' ) tstart = - 1. end if istatus = nf90_inq_varid ( ncid , \"istep0\" , istep0id ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , var = 'istep0' ) istatus = nf90_get_var ( ncid , istep0id , istep0 ) if ( istatus /= NF90_NOERR ) then call netcdf_error ( istatus , ncid , istep0id , message = ' in init_tstart' ) istep0 = - 1 end if if (. not . initialized ) istatus = nf90_close ( ncid ) end if call broadcast ( istatus ) call broadcast ( istep0 ) call broadcast ( tstart ) # endif end subroutine init_tstart subroutine finish_save if ( allocated ( tmpr )) deallocate ( tmpr ) if ( allocated ( tmpi )) deallocate ( tmpi ) end subroutine finish_save end module stella_save","tags":"","loc":"sourcefile/stella_save.fpp.html"},{"title":"dissipation.f90 â€“ stella","text":"Contents Modules dissipation Source Code dissipation.f90 Source Code module dissipation implicit none public :: init_dissipation , finish_dissipation public :: init_collisions , collisions_initialized public :: include_collisions public :: advance_collisions_explicit , advance_collisions_implicit public :: time_collisions public :: hyper_dissipation public :: advance_hyper_dissipation public :: collisions_implicit public :: vpa_operator , mu_operator public :: cfl_dt_vpadiff , cfl_dt_mudiff public :: fieldpart private logical :: include_collisions , vpa_operator , mu_operator logical :: collisions_implicit logical :: momentum_conservation , energy_conservation logical :: hyper_dissipation logical :: use_physical_ksqr real :: D_hyper real :: cfl_dt_vpadiff , cfl_dt_mudiff logical :: density_conservation , density_conservation_field , density_conservation_tp , exact_conservation_tp , exact_conservation , spitzer_problem , no_j1l1 , no_j1l2 , no_j0l2 logical :: fieldpart , testpart logical :: interspec , intraspec logical :: advfield_coll character ( 30 ) :: collision_model integer :: nresponse = 1 integer :: nresponse_vpa = 1 integer :: nresponse_mu = 1 real :: cfac , cfac2 real :: nuxfac real :: iiknob , ieknob , eeknob , eiknob , eiediffknob , eideflknob , deflknob logical :: eimassr_approx integer :: jmax = 1 integer :: lmax = 1 integer :: nvel_local real , dimension (:, :), allocatable :: aa_vpa , bb_vpa , cc_vpa real , dimension (:, :, :), allocatable :: aa_mu , cc_mu real , dimension (:, :), allocatable :: bb_mu complex , dimension (:, :, :), allocatable :: vpadiff_response integer , dimension (:, :), allocatable :: vpadiff_idx complex , dimension (:, :, :), allocatable :: mudiff_response integer , dimension (:, :), allocatable :: mudiff_idx complex , dimension (:, :, :), allocatable :: fp_response integer , dimension (:, :), allocatable :: diff_idx complex , dimension (:, :, :), allocatable :: vpadiff_zf_response integer , dimension (:, :), allocatable :: vpadiff_zf_idx complex , dimension (:, :, :), allocatable :: mudiff_zf_response integer , dimension (:, :), allocatable :: mudiff_zf_idx complex , dimension (:, :, :, :, :), allocatable :: aa_blcs , cc_blcs complex , dimension (:, :, :, :, :), allocatable :: bb_blcs complex , dimension (:, :, :, :, :, :), allocatable :: cdiffmat_band complex , dimension (:, :, :, :), allocatable :: blockmatrix complex , dimension (:, :, :), allocatable :: blockmatrix_sum integer , dimension (:, :, :, :, :), allocatable :: ipiv real , dimension (:, :, :, :, :), allocatable :: nus , nuD , nupa , nux real , dimension (:, :, :, :), allocatable :: mw , modmw real , dimension (:, :, :), allocatable :: velvpamu integer :: info real , dimension (:), allocatable :: wgts_v real , dimension (:), allocatable :: vel real , dimension (:, :, :, :, :, :, :, :), allocatable :: deltaj , deltaj_tp complex , dimension (:, :, :, :), allocatable :: deltajint real , dimension (:, :, :, :, :), allocatable :: psijnorm real , dimension (:, :, :, :, :), allocatable :: legendre_vpamu real , dimension (:, :, :, :, :, :), allocatable :: jm real , dimension (:, :, :, :, :), allocatable :: jm0 real , dimension (:), allocatable :: mwnorm real , dimension (:), allocatable :: modmwnorm logical :: collisions_initialized = . false . real , dimension ( 2 , 2 ) :: time_collisions = 0. real :: i1fac , i2fac contains subroutine init_dissipation use mp , only : proc0 implicit none call read_parameters if ( include_collisions ) then if ( collision_model == \"dougherty\" ) then write ( * , * ) write ( * , * ) 'Coll. model:     Dougherty' if ( collisions_implicit ) then write ( * , * ) 'Coll. algorithm: implicit' else write ( * , * ) 'Coll. algorithm: explicit' end if end if if ( collision_model == \"fokker-planck\" ) then write ( * , * ) 'Coll. model:     Fokker-Planck' if ( collisions_implicit ) then write ( * , * ) 'Coll. algorithm: implicit' else write ( * , * ) 'Coll. algorithm: explicit' end if end if write ( * , * ) else if ( proc0 ) then write ( * , '(A)' ) \"############################################################\" write ( * , '(A)' ) \"                         COLLISIONS\" write ( * , '(A)' ) \"############################################################\" write ( * , * ) 'Coll. model:     None' write ( * , * ) end if end if end subroutine init_dissipation subroutine read_parameters use file_utils , only : input_unit_exist use physics_flags , only : full_flux_surface , radial_variation use mp , only : proc0 , broadcast use run_parameters , only : fully_explicit implicit none namelist / dissipation / collision_model , testpart , fieldpart , lmax , jmax , nvel_local , hyper_dissipation , D_hyper , & include_collisions , collisions_implicit , & interspec , intraspec , iiknob , ieknob , eeknob , eiknob , eiediffknob , eideflknob , deflknob , eimassr_approx , advfield_coll , spitzer_problem , & density_conservation , density_conservation_field , density_conservation_tp , exact_conservation , exact_conservation_tp , & momentum_conservation , energy_conservation , & momentum_conservation , energy_conservation , & vpa_operator , mu_operator , use_physical_ksqr , & cfac , cfac2 , nuxfac , i1fac , i2fac , no_j1l1 , no_j1l2 , no_j0l2 integer :: in_file logical :: dexist if ( proc0 ) then include_collisions = . false . collisions_implicit = . true . collision_model = \"dougherty\" ! dougherty or fokker-planck !!! control parameters specific to the Fokker-Planck collision model testpart = . true . ! test particle component (TPO) of fokker-planck operator, must be True fieldpart = . false . ! enable the field particle component (FPO) of the fokker-planck operator intraspec = . true . ! intra-species collisions in the Fokker-Planck operator interspec = . true . ! inter-species iiknob = 1. ! control the ion-ion coll freq in Fokker-Planck operator ieknob = 1. ! ...ion-eon coll freq eeknob = 1. ! ...eon-eon coll freq eiknob = 1. ! ...eon-ion coll freq eiediffknob = 1. ! control the eon-ion energy diffusion in Fokker-Planck operator deflknob = 1. ! control pitch angle scattering in Fokker-Planck operator, must be 1 or 0 eimassr_approx = . false . ! use mass ratio approximation for test particle operator, beta advfield_coll = . true . ! disable electrostatic potential terms in the field particle operator, beta density_conservation = . false . ! if True and equally_spaced_mu_grid=True and conservative_wgts_vpa=True, then TPO conserves density to machine precision density_conservation_field = . false . ! if True and jmax, lmax < 2, then FPO conserves density to machine precision density_conservation_tp = . false . ! if True add term to field particle operator to ensure density conservation, also on non-uniform grids exact_conservation = . false . ! if True and fieldpart=True and lmax=jmax=1 then momentum and energy conserved to machine precision - in beta & ! & works only if nux = 0, need to correct the discretisation of nux terms in TPO exact_conservation_tp = . false . ! if True and lmax=jmax=1 then momentum and energy conserved to machine precision, by using the test particle operator & ! to compute field particle terms; this is slower than exact_conservation momentum_conservation = . true . ! momentum conservation for Dougherty operator energy_conservation = . true . ! energy conservation for Dougherty operator spitzer_problem = . false . ! to solve the Spitzer problem for tests of the collision operator cfac = 1 ! scale gyrodiffusive term in test particle component of Fokker-Planck operator cfac2 = 1 ! scale gyrodiffusive terms in field particle component of Fokker-Planck operator - in beta nuxfac = 1 ! scale nux (mixed derivative) terms in test particle component of Fokker-Planck operator jmax = 1 ! maximum j in Hirshman-Sigmar expansion of the field particle operator lmax = 1 ! maximum l in spherical harmonic expansion of the field particle operator i1fac = 1 ! for Spitzer problem i2fac = 0 ! for Spitzer problem no_j1l1 = . true . ! disable j1l1 term in the field particle component of Fokker-Planck operator no_j1l2 = . false . ! disable j1l2 term no_j0l2 = . false . ! disable j0l2 term !!! vpa_operator = . true . ! include vpa components in Dougherty or Fokker-Planck operator mu_operator = . true . ! include mu components in Dougherty or Fokker-Planck operator hyper_dissipation = . false . nvel_local = 512 use_physical_ksqr = . not . ( full_flux_surface . or . radial_variation ) D_hyper = 0.05 in_file = input_unit_exist ( \"dissipation\" , dexist ) if ( dexist ) read ( unit = in_file , nml = dissipation ) end if call broadcast ( include_collisions ) call broadcast ( collisions_implicit ) call broadcast ( collision_model ) call broadcast ( fieldpart ) call broadcast ( testpart ) call broadcast ( interspec ) call broadcast ( intraspec ) call broadcast ( iiknob ) call broadcast ( ieknob ) call broadcast ( eeknob ) call broadcast ( eiknob ) call broadcast ( eiediffknob ) call broadcast ( deflknob ) call broadcast ( eimassr_approx ) call broadcast ( eideflknob ) call broadcast ( advfield_coll ) call broadcast ( density_conservation ) call broadcast ( density_conservation_field ) call broadcast ( density_conservation_tp ) call broadcast ( exact_conservation ) call broadcast ( exact_conservation_tp ) call broadcast ( momentum_conservation ) call broadcast ( energy_conservation ) call broadcast ( spitzer_problem ) call broadcast ( vpa_operator ) call broadcast ( mu_operator ) call broadcast ( hyper_dissipation ) call broadcast ( use_physical_ksqr ) call broadcast ( D_hyper ) call broadcast ( cfac ) call broadcast ( cfac2 ) call broadcast ( nuxfac ) call broadcast ( jmax ) call broadcast ( lmax ) call broadcast ( nvel_local ) call broadcast ( i1fac ) call broadcast ( i2fac ) call broadcast ( no_j1l1 ) call broadcast ( no_j1l2 ) call broadcast ( no_j0l2 ) if (. not . include_collisions ) collisions_implicit = . false . if ( hyper_dissipation ) fully_explicit = . false . end subroutine read_parameters subroutine init_collisions use species , only : spec , nspec use vpamu_grids , only : dvpa , dmu , mu , nmu !   use vpamu_grids, only: calculate_velocity_integrals use stella_geometry , only : bmag use stella_layouts use run_parameters , only : fully_explicit use common_types , only : spec_type implicit none integer :: is , is2 integer , parameter :: ion_species = 1 integer , parameter :: electron_species = 2 integer , parameter :: impurity_species = 3 ! AVB: clear up difference between slowing down species ('3' in species.f90) and impurity species real :: vnew_max if ( collisions_initialized ) return collisions_initialized = . true . !   call calculate_velocity_integrals if ( collision_model == \"dougherty\" ) then if ( collisions_implicit ) then if ( vpa_operator ) then call init_vpadiff_matrix call init_vpadiff_conserve end if if ( mu_operator ) then call init_mudiff_matrix call init_mudiff_conserve end if else vnew_max = 0.0 do is = 1 , nspec vnew_max = max ( vnew_max , maxval ( spec ( is )% vnew )) end do cfl_dt_vpadiff = 2.0 * dvpa ** 2 / vnew_max cfl_dt_mudiff = minval ( bmag ) / ( vnew_max * maxval ( mu ( 2 :) / dmu (: nmu - 1 ) ** 2 )) end if end if if ( collision_model == \"fokker-planck\" ) then ! disable inter-species collisions if interspec==false if (. not . interspec ) then do is = 1 , nspec do is2 = 1 , nspec if ( is /= is2 ) then spec ( is )% vnew ( is2 ) = 0. end if end do end do end if ! disable intra-species collisions if intraspec==false if (. not . intraspec ) then do is = 1 , nspec do is2 = 1 , nspec if ( is == is2 ) then spec ( is )% vnew ( is2 ) = 0. end if end do end do end if ! control inter-species collisions do is = 1 , nspec do is2 = 1 , nspec if (( spec ( is )% type == ion_species ) . and . ( spec ( is2 )% type == ion_species )) then spec ( is )% vnew ( is2 ) = spec ( is )% vnew ( is2 ) * iiknob else if (( spec ( is )% type == ion_species ) . and . ( spec ( is2 )% type == electron_species )) then spec ( is )% vnew ( is2 ) = spec ( is )% vnew ( is2 ) * ieknob else if (( spec ( is )% type == electron_species ) . and . ( spec ( is2 )% type == electron_species )) then spec ( is )% vnew ( is2 ) = spec ( is )% vnew ( is2 ) * eeknob else if (( spec ( is )% type == electron_species ) . and . ( spec ( is2 )% type == ion_species )) then spec ( is )% vnew ( is2 ) = spec ( is )% vnew ( is2 ) * eiknob else spec ( is )% vnew ( is2 ) = spec ( is )% vnew ( is2 ) end if ! AVB: to do - add impurity collision control end do end do ! initialise speed dependent collision frequencies call init_nusDpa if ( collisions_implicit ) then write ( * , * ) 'Coll. algorithm: implicit' fully_explicit = . false . call init_legendre call init_vgrid call init_bessel_fn call init_fp_diffmatrix call init_deltaj_vmu call init_fp_conserve else vnew_max = 0.0 do is = 1 , nspec vnew_max = max ( vnew_max , maxval ( spec ( is )% vnew )) end do cfl_dt_vpadiff = 2.0 * dvpa ** 2 / vnew_max cfl_dt_mudiff = minval ( bmag ) / ( vnew_max * maxval ( mu ( 2 :) / dmu (: nmu - 1 ) ** 2 )) end if end if end subroutine init_collisions subroutine init_nusDpa ! AVB: compute the collision frequencies nuD, nus and nupa use zgrid , only : nzgrid use vpamu_grids , only : nmu , mu , vpa , nvpa , integrate_vmu use stella_geometry , only : bmag use species , only : spec , nspec use spfunc , only : erf => erf_ext use finite_differences , only : fd3pt use vpamu_grids , only : maxwell_mu , maxwell_vpa use constants , only : pi implicit none real , dimension ( - nzgrid : nzgrid ) :: v2mwint , v4mwint integer :: ia , imu , iv , iz , is , isb real :: x , Gf , massr if (. not . allocated ( nus )) allocate ( nus ( nvpa , nmu , - nzgrid : nzgrid , nspec , nspec )) if (. not . allocated ( nuD )) allocate ( nuD ( nvpa , nmu , - nzgrid : nzgrid , nspec , nspec )) if (. not . allocated ( nupa )) allocate ( nupa ( nvpa , nmu , - nzgrid : nzgrid , nspec , nspec )) if (. not . allocated ( nux )) allocate ( nux ( nvpa , nmu , - nzgrid : nzgrid , nspec , nspec )) if (. not . allocated ( mw )) allocate ( mw ( nvpa , nmu , - nzgrid : nzgrid , nspec )) if (. not . allocated ( modmw )) allocate ( modmw ( nvpa , nmu , - nzgrid : nzgrid , nspec )) if (. not . allocated ( velvpamu )) allocate ( velvpamu ( nvpa , nmu , - nzgrid : nzgrid )) ia = 1 do is = 1 , nspec do isb = 1 , nspec massr = spec ( is )% mass / spec ( isb )% mass do iz = - nzgrid , nzgrid do iv = 1 , nvpa do imu = 1 , nmu x = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mu ( imu )) Gf = ( erf ( x / sqrt ( massr )) - x / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - x ** 2 / massr )) / ( 2 * x ** 2 / massr ) nuD ( iv , imu , iz , is , isb ) = deflknob * spec ( is )% vnew ( isb ) * ( erf ( x / sqrt ( massr )) - Gf ) / x ** 3 nus ( iv , imu , iz , is , isb ) = spec ( is )% vnew ( isb ) * 2 * ( 1 + 1. / massr ) * Gf / x ! nus is never used; note - have assumed T_a = T_b here nupa ( iv , imu , iz , is , isb ) = spec ( is )% vnew ( isb ) * 2 * Gf / x ** 3 velvpamu ( iv , imu , iz ) = x mw ( iv , imu , iz , is ) = maxwell_vpa ( iv , is ) * maxwell_mu ( 1 , iz , imu , is ) end do end do end do ! electron-ion collisions ! approximation of Lorentz operator using mass-ratio expansion if (( is == 2 ) . and . ( isb == 1 ) . and . ( eimassr_approx )) then do iz = - nzgrid , nzgrid do iv = 1 , nvpa do imu = 1 , nmu x = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mu ( imu )) nuD ( iv , imu , iz , is , isb ) = deflknob * spec ( is )% vnew ( isb ) * 1. / x ** 3 end do end do end do end if end do end do ! get a function with vanishing energy moment, modmw do is = 1 , nspec do iz = - nzgrid , nzgrid call integrate_vmu ( velvpamu (:, :, iz ) ** 2 * mw (:, :, iz , is ), iz , v2mwint ( iz )) call integrate_vmu ( velvpamu (:, :, iz ) ** 4 * mw (:, :, iz , is ), iz , v4mwint ( iz )) modmw (:, :, iz , is ) = mw (:, :, iz , is ) - velvpamu (:, :, iz ) ** 2 * v2mwint ( iz ) / v4mwint ( iz ) * mw (:, :, iz , is ) end do end do nux = nuxfac * ( nupa - deflknob * nuD ) if ( nspec > 1 ) then ! eiediffknob controls e-i energy diffusion, note that it is also used in blockmatrix nux (:, :, :, 2 , 1 ) = nuxfac * ( eiediffknob * nupa (:, :, :, 2 , 1 ) - eideflknob * deflknob * nuD (:, :, :, 2 , 1 )) nuD (:, :, :, 2 , 1 ) = eideflknob * nuD (:, :, :, 2 , 1 ) end if end subroutine init_nusDpa subroutine finish_nusDpa implicit none if ( allocated ( nus )) deallocate ( nus ) if ( allocated ( nuD )) deallocate ( nuD ) if ( allocated ( nupa )) deallocate ( nupa ) if ( allocated ( nux )) deallocate ( nux ) if ( allocated ( mw )) deallocate ( mw ) if ( allocated ( modmw )) deallocate ( modmw ) if ( allocated ( velvpamu )) deallocate ( velvpamu ) end subroutine finish_nusDpa subroutine init_fp_diffmatrix use stella_time , only : code_dt use species , only : nspec , spec use zgrid , only : nzgrid , ntubes use vpamu_grids , only : dvpa , vpa , nvpa , mu , nmu , maxwell_mu , maxwell_vpa , dmu , equally_spaced_mu_grid use stella_layouts , only : kxkyz_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , is_idx use stella_geometry , only : bmag use dist_fn_arrays , only : kperp2 use physics_parameters , only : zeff use constants , only : pi use common_types , only : spec_type use kt_grids , only : naky , nakx use spfunc , only : erf => erf_ext use file_utils , only : open_output_file , close_output_file implicit none integer :: ikxkyz , iky , ikx , iz , is , isb integer :: imu , ia , iv , ivv , imm , imu2 integer :: nc , nb , lldab , bm_colind , bm_rowind real :: vpap , vpam , vfac , mum , mup real :: xpv , xmv , nupapv , nupamv , nuDpv , nuDmv , mwpv , mwmv , gam_mu , gam_mum , gam_mup real :: mwm , mwp , nuDm , nuDp , nupam , nupap , xm , xp real :: nuDfac , massr , eiediff , eidefl integer , parameter :: ion_species = 1 integer , parameter :: electron_species = 2 if (. not . allocated ( aa_blcs )) allocate ( aa_blcs ( nvpa , nmu , nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc , nspec )) if (. not . allocated ( bb_blcs )) allocate ( bb_blcs ( nvpa , nmu , nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc , nspec )) if (. not . allocated ( cc_blcs )) allocate ( cc_blcs ( nvpa , nmu , nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc , nspec )) if (. not . allocated ( cdiffmat_band )) allocate ( cdiffmat_band ( 3 * ( nmu + 1 ) + 1 , nmu * nvpa , naky , nakx , - nzgrid : nzgrid , nspec )) if (. not . allocated ( ipiv )) allocate ( ipiv ( nvpa * nmu , naky , nakx , - nzgrid : nzgrid , nspec )) ! AVB: calculate the discretisation matrix -\\Delta t C_test&#94;{ab} ! because of mixed vpa-mu derivatives in the test particle operator ! this matrix is block tri-diagonal, with dimension nmu*nvpa x nmu*nvpa ! store and operate with the matrix in band format ! aa_blcs stores subdiagonal blocks, bb_blcs diagonal blocks and cc_blcs superdiagonal blocks ! aa_blcs(1,:,:) and cc_blcs(nvpa,:,:) are never used ! mu-derivatives are contained within blocks, thus blocks have dimension nmu x nmu ia = 1 vfac = 1 ! zero vpa-operator, in beta nuDfac = 1. aa_blcs = 0. bb_blcs = 0. cc_blcs = 0. do imu = 1 , nmu do iv = 1 , nvpa do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) if ( spitzer_problem ) then if (. not . ( spec ( is )% type == electron_species )) cycle ! add eon-eon and eon-ion collisions only for Spitzer problem end if do isb = 1 , nspec ! for Spitzer problem, disable e-i energy diffusion if eiediffknob = 0. if ( spitzer_problem ) then if (( is == 2 ) . and . ( isb == 1 )) then eiediff = eiediffknob eidefl = eideflknob else eiediff = 1. eidefl = 1. end if else if (( is == 2 ) . and . ( isb == 1 )) then eiediff = eiediffknob eidefl = eideflknob else eiediff = 1. eidefl = 1. end if end if massr = spec ( is )% mass / spec ( isb )% mass if ( iv == 1 ) then vpap = 0.5 * ( vpa ( iv ) + vpa ( iv + 1 )) mwpv = exp ( - vpap ** 2 ) * maxwell_mu ( 1 , iz , imu , is ) xpv = sqrt ( vpap ** 2 + 2 * bmag ( ia , iz ) * mu ( imu )) nupapv = vfac * spec ( is )% vnew ( isb ) * 2 * ( erf ( xpv / sqrt ( massr )) & - xpv / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - ( xpv / sqrt ( massr )) ** 2 )) / ( 2 * ( xpv / sqrt ( massr )) ** 2 ) / xpv ** 3 if (( is == 2 ) . and . ( isb == 1 ) . and . ( eimassr_approx )) then nuDpv = vfac * spec ( is )% vnew ( isb ) / xpv ** 3 else nuDpv = vfac * spec ( is )% vnew ( isb ) * ( erf ( xpv / sqrt ( massr )) - ( erf ( xpv / sqrt ( massr )) & - ( xpv / sqrt ( massr )) * ( 2 / sqrt ( pi )) * exp ( - ( xpv / sqrt ( massr )) ** 2 )) / ( 2 * ( xpv / sqrt ( massr )) ** 2 )) / xpv ** 3 end if if ( imu == 1 ) then ! one-sided difference for mu-derivative at imu=1: !cc_blcs(iv,imu,imu+1,iz,is) = cc_blcs(iv,imu,imu+1,iz,is) & !  - vfac*code_dt*vpa(iv+1)*mu(imu)*nux(iv+1,imu,iz,is,isb)*mw(iv+1,imu,iz,is)/mw(iv+1,imu+1,iz,is) / (2*dvpa) / dmu(imu) !cc_blcs(iv,imu,imu,iz,is)   = cc_blcs(iv,imu,imu,iz,is) & !  - code_dt*0.5*(eiediff*nupapv*vpap**2 + 2*nuDpv*bmag(ia,iz)*mu(imu))*mwpv / dvpa**2 / mw(iv+1,imu,iz,is) & !                                +vfac*code_dt*vpa(iv+1)*mu(imu)*nux(iv+1,imu,iz,is,isb)*mw(iv+1,imu,iz,is)/mw(iv+1,imu,iz,is) / (2*dvpa) / dmu(imu) ! using ghost cell at mu=0: cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - 0.5 * vfac * code_dt * vpa ( iv + 1 ) * 0.5 * ( mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ) + mu ( imu + 1 ) * nux ( iv + 1 , imu + 1 , iz , is , isb ) * mw ( iv + 1 , imu + 1 , iz , is ))& / mw ( iv + 1 , imu + 1 , iz , is ) / ( dvpa ) / dmu ( imu ) cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * 0.5 * ( eiediff * nupapv * vpap ** 2 + eidefl * deflknob * 2 * nuDpv * bmag ( ia , iz ) * mu ( imu )) * mwpv / dvpa ** 2 / mw ( iv + 1 , imu , iz , is ) & + 0.5 * vfac * code_dt * vpa ( iv + 1 ) * 0.5 * ( mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ) + mu ( imu + 1 ) * nux ( iv + 1 , imu + 1 , iz , is , isb ) * mw ( iv + 1 , imu + 1 , iz , is ))& / mw ( iv + 1 , imu , iz , is ) / ( dvpa ) / dmu ( imu ) bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - 0.5 * vfac * code_dt * vpa ( iv ) * 0.5 * ( mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) + mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ))& / mw ( iv , imu + 1 , iz , is ) / ( dvpa ) / dmu ( imu ) bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & + 0.5 * vfac * code_dt * vpa ( iv ) * 0.5 * ( mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) + mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ))& / mw ( iv , imu , iz , is ) / ( dvpa ) / dmu ( imu ) ! bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & + code_dt * ( 0.5 * ( eiediff * nupapv * vpap ** 2 + eidefl * deflknob * 2 * nuDpv * bmag ( ia , iz ) * mu ( imu )) * mwpv ) / dvpa ** 2 / mw ( iv , imu , iz , is ) ! mu operator if ( mu_operator ) then ! use ghost cell at mu_{0} = 0 mup = 0.5 * ( mu ( imu ) + mu ( imu + 1 )) mwp = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mup ) xp = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mup ) if (( is == 2 ) . and . ( isb == 1 ) . and . ( eimassr_approx )) then nuDp = eidefl * deflknob * spec ( is )% vnew ( isb ) / xp ** 3 else nuDp = eidefl * deflknob * spec ( is )% vnew ( isb ) * ( erf ( xp / sqrt ( massr )) & - ( erf ( xp / sqrt ( massr )) - xp / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 / massr )) / ( 2 * xp ** 2 / massr )) / xp ** 3 end if nupap = spec ( is )% vnew ( isb ) * 2 * ( erf ( xp / sqrt ( massr )) - xp / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 / massr )) / ( 2 * xp ** 2 / massr ) / xp ** 3 gam_mu = 2 * ( eiediff * nupa ( iv , imu , iz , is , isb ) * mu ( imu ) ** 2 + eidefl * deflknob * nuD ( iv , imu , iz , is , isb ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mu ( imu )) * mw ( iv , imu , iz , is ) gam_mup = 2 * ( eiediff * nupap * mup ** 2 + eidefl * deflknob * nuDp * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mup ) * mwp bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) - code_dt * ( gam_mu *- 1 / dmu ( imu ) * dmu ( imu ) / 2. / mu ( imu ) & + ( gam_mup *- 1 / dmu ( imu ) - gam_mu *- 1 / dmu ( imu )) * mu ( imu ) / ( dmu ( imu ) / 2. )) / mw ( iv , imu , iz , is ) / ( dmu ( imu ) / 2. + mu ( imu )) bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) - code_dt * ( gam_mu * 1 / dmu ( imu ) * dmu ( imu ) / 2. / mu ( imu ) & + ( gam_mup * 1 / dmu ( imu ) - gam_mu * 1 / dmu ( imu )) * mu ( imu ) / ( dmu ( imu ) / 2. )) / mw ( iv , imu + 1 , iz , is ) / ( dmu ( imu ) / 2. + mu ( imu )) ! mixed derivative: if ( density_conservation ) then ! to ensure density conservation, change discretisation of mixed derivative term at imu=1 ! from explicit routine: Dmuh1 = (vpa(iv)*mu(imu)*nux(iv,imu,iz)*mw(iv,imu,iz,is)*Dvpah & !  + vpa(iv)*mu(imu+1)*nux(iv,imu+1,iz)*mw(iv,imu+1,iz,is)*Dvpah_p) / (2.*dmu(imu)) cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & - 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) + vpa ( iv + 1 ) * mu ( imu ) & * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is )) * 1 / mw ( iv + 1 , imu , iz , is )) / ( 2 * dmu ( imu )) / dvpa cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ) + vpa ( iv + 1 ) * mu ( imu + 1 ) & * nux ( iv + 1 , imu + 1 , iz , is , isb ) * mw ( iv + 1 , imu + 1 , iz , is )) * 1 / mw ( iv + 1 , imu + 1 , iz , is )) / ( 2 * dmu ( imu )) / dvpa bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & + 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) + vpa ( iv + 1 ) * mu ( imu ) & * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is )) * 1 / mw ( iv , imu , iz , is )) / ( 2 * dmu ( imu )) / dvpa bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & + 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ) + vpa ( iv + 1 ) * mu ( imu + 1 ) & * nux ( iv + 1 , imu + 1 , iz , is , isb ) * mw ( iv + 1 , imu + 1 , iz , is )) * 1 / mw ( iv , imu + 1 , iz , is )) / ( 2 * dmu ( imu )) / dvpa else cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & - 1.0 * code_dt * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) * 1 / mw ( iv + 1 , imu , iz , is ) * ( dmu ( imu ) / mu ( imu ) - mu ( imu ) / dmu ( imu )))& / ( mu ( imu ) + dmu ( imu )) / dvpa cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - 1.0 * code_dt * ( vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ) * 1 / mw ( iv + 1 , imu + 1 , iz , is ) * mu ( imu ) / dmu ( imu ))& / ( mu ( imu ) + dmu ( imu )) / dvpa bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & + 1.0 * code_dt * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) * 1 / mw ( iv , imu , iz , is ) * ( dmu ( imu ) / mu ( imu ) - mu ( imu ) / dmu ( imu )))& / ( mu ( imu ) + dmu ( imu )) / dvpa bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & + 1.0 * code_dt * ( vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ) * 1 / mw ( iv , imu + 1 , iz , is ) * mu ( imu ) / dmu ( imu ))& / ( mu ( imu ) + dmu ( imu )) / dvpa end if end if else if ( imu == nmu ) then ! AVB: one-sided difference for mu-derivative at imu=nmu: !cc_blcs(iv,imu,imu-1,iz,is) = cc_blcs(iv,imu,imu-1,iz,is) & !  + 1.000*vfac*code_dt*vpa(iv+1)*mu(imu)*nux(iv+1,imu,iz,is,isb)*mw(iv+1,imu,iz,is)/mw(iv+1,imu-1,iz,is) / (2*dvpa) / dmu(nmu-1) !cc_blcs(iv,imu,imu,iz,is)   = cc_blcs(iv,imu,imu,iz,is) & !  - code_dt*0.5*(eiediff*nupapv*vpap**2 + 2*nuDpv*bmag(ia,iz)*mu(imu))*mwpv / dvpa**2 / mw(iv+1,imu,iz,is) & !  - 1.000*vfac*code_dt*vpa(iv+1)*mu(imu)*nux(iv+1,imu,iz,is,isb)*mw(iv+1,imu,iz,is)/mw(iv+1,imu,iz,is) / (2*dvpa) / dmu(nmu-1) ! AVB: second-order: if ( density_conservation ) then cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & + 0.5 * vfac * code_dt * vpa ( iv + 1 ) * 0.5 * ( mu ( imu - 1 ) * nux ( iv + 1 , imu - 1 , iz , is , isb ) * mw ( iv + 1 , imu - 1 , iz , is ) + mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ))& / mw ( iv + 1 , imu - 1 , iz , is ) / ( dvpa ) / dmu ( nmu - 1 ) cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * 0.5 * ( eiediff * nupapv * vpap ** 2 + eidefl * deflknob * 2 * nuDpv * bmag ( ia , iz ) * mu ( imu )) * mwpv / dvpa ** 2 / mw ( iv + 1 , imu , iz , is ) & - 0.5 * vfac * code_dt * vpa ( iv + 1 ) * 0.5 * ( mu ( imu - 1 ) * nux ( iv + 1 , imu - 1 , iz , is , isb ) * mw ( iv + 1 , imu - 1 , iz , is ) + mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ))& / mw ( iv + 1 , imu , iz , is ) / ( dvpa ) / dmu ( nmu - 1 ) bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & + 0.5 * vfac * code_dt * vpa ( iv ) * 0.5 * ( mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ) + mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ))& / mw ( iv , imu - 1 , iz , is ) / ( dvpa ) / dmu ( nmu - 1 ) bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & - 0.5 * vfac * code_dt * vpa ( iv ) * 0.5 * ( mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ) + mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ))& / mw ( iv , imu , iz , is ) / ( dvpa ) / dmu ( nmu - 1 ) else cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & + 1.0 * vfac * code_dt * vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ) / mw ( iv + 1 , imu - 1 , iz , is ) / ( 2 * dvpa ) / dmu ( nmu - 1 ) cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * 0.5 * ( eiediff * nupapv * vpap ** 2 + eidefl * deflknob * 2 * nuDpv * bmag ( ia , iz ) * mu ( imu )) * mwpv / dvpa ** 2 / mw ( iv + 1 , imu , iz , is ) & - 1.0 * vfac * code_dt * vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ) / mw ( iv + 1 , imu , iz , is ) / ( 2 * dvpa ) / dmu ( nmu - 1 ) end if bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & + code_dt * ( 0.5 * ( eiediff * nupapv * vpap ** 2 + eidefl * deflknob * 2 * nuDpv * bmag ( ia , iz ) * mu ( imu )) * mwpv ) / dvpa ** 2 / mw ( iv , imu , iz , is ) ! mu operator if ( mu_operator ) then mum = 0.5 * ( mu ( imu ) + mu ( imu - 1 )) mwm = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mum ) xm = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mum ) if (( is == 2 ) . and . ( isb == 1 ) . and . ( eimassr_approx )) then nuDm = eidefl * deflknob * spec ( is )% vnew ( isb ) / xm ** 3 else nuDm = eidefl * deflknob * spec ( is )% vnew ( isb ) * ( erf ( xm / sqrt ( massr )) & - ( erf ( xm / sqrt ( massr )) - xm / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 / massr )) / ( 2 * xm ** 2 / massr )) / xm ** 3 end if nupam = spec ( is )% vnew ( isb ) * 2 * ( erf ( xm / sqrt ( massr )) - xm / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 / massr )) / ( 2 * xm ** 2 / massr ) / xm ** 3 gam_mu = 2 * ( eiediff * nupa ( iv , imu , iz , is , isb ) * mu ( imu ) ** 2 + eidefl * deflknob * nuD ( iv , imu , iz , is , isb ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mu ( imu )) * mw ( iv , imu , iz , is ) gam_mum = 2 * ( eiediff * nupam * mum ** 2 + eidefl * deflknob * nuDm * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mum ) * mwm if ( density_conservation ) then ! to ensure density conservation we assume that the argument of the outer derivative vanishes at nmu+1/2, ie ! d/dmu[...]_{nmu} = ([...]_{nmu+1/2} - [...]_{nmu-1/2})/(dmu_{nmu-1}/2+dmu(nmu-1)/2) ! where [...]_{nmu+1/2} is a ghost cell at mu = mu_{nmu} + dmu(nmu-1)/2, with [...]_{nmu+1/2} = 0. bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) - code_dt * (( gam_mu / dmu ( imu - 1 ) - gam_mum / dmu ( imu - 1 )) * dmu ( imu - 1 ) / ( dmu ( imu - 1 )) & + ( - gam_mu / dmu ( imu - 1 )) * dmu ( imu - 1 ) / dmu ( imu - 1 )) / mw ( iv , imu , iz , is ) / ( dmu ( imu - 1 ) / 2. + dmu ( imu - 1 ) / 2. ) bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) - code_dt * (( - gam_mu / dmu ( imu - 1 ) - gam_mum * - 1 / dmu ( imu - 1 )) * dmu ( imu - 1 ) / ( dmu ( imu - 1 )) & - gam_mu *- 1 / dmu ( imu - 1 ) * dmu ( imu - 1 ) / dmu ( imu - 1 )) / mw ( iv , imu - 1 , iz , is ) / ( dmu ( imu - 1 ) / 2. + dmu ( imu - 1 ) / 2. ) else bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) - code_dt * (( gam_mu / dmu ( imu - 1 ) - gam_mum / dmu ( imu - 1 )) * dmu ( imu - 1 ) / ( dmu ( imu - 1 ) / 2. ) & + ( - gam_mu / dmu ( imu - 1 )) * dmu ( imu - 1 ) / 2. / dmu ( imu - 1 )) / mw ( iv , imu , iz , is ) / ( dmu ( imu - 1 ) / 2. + dmu ( imu - 1 )) bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) - code_dt * (( - gam_mu / dmu ( imu - 1 ) - gam_mum * - 1 / dmu ( imu - 1 )) * dmu ( imu - 1 ) / ( dmu ( imu - 1 ) / 2. ) & - gam_mu *- 1 / dmu ( imu - 1 ) * dmu ( imu - 1 ) / 2. / dmu ( imu - 1 )) / mw ( iv , imu - 1 , iz , is ) / ( dmu ( imu - 1 ) / 2. + dmu ( imu - 1 )) end if ! mixed derivative: !cc_blcs(iv,imu,imu,iz,is)   = cc_blcs(iv,imu,imu  ,iz,is)  & ! - 1.000*code_dt*(vpa(iv)*mu(imu)*nux(iv,imu,iz,is,isb)*mw(iv,imu,iz,is)*1/mw(iv+1,imu,iz,is)*(dmu(imu-1)/dmu(imu-1)-dmu(imu-1)/dmu(imu-1))) / (dmu(imu-1)+dmu(imu-1)) / (dvpa) !cc_blcs(iv,imu,imu-1,iz,is) = cc_blcs(iv,imu,imu-1,iz,is)  & ! + 1.000*code_dt*(vpa(iv)*mu(imu-1)*nux(iv,imu-1,iz,is,isb)*mw(iv,imu-1,iz,is)*1/mw(iv+1,imu-1,iz,is)* dmu(imu-1)/dmu(imu-1)) / (dmu(imu-1)+dmu(imu-1)) / (dvpa) !bb_blcs(iv,imu,imu,ikxkyz)  = bb_blcs(iv,imu,imu  ,ikxkyz) & !+ 1.000*code_dt*(vpa(iv)*mu(imu)*nux(iv,imu,iz,is,isb)*mw(iv,imu,iz,is)*1/mw(iv,imu,iz,is)*(dmu(imu-1)/dmu(imu-1)-dmu(imu-1)/dmu(imu-1))) / (dmu(imu-1)+dmu(imu-1)) / (dvpa) !bb_blcs(iv,imu,imu-1,ikxkyz)= bb_blcs(iv,imu,imu-1,ikxkyz) & !- 1.000*code_dt*(vpa(iv)*mu(imu-1)*nux(iv,imu-1,iz,is,isb)*mw(iv,imu-1,iz,is)*1/mw(iv,imu-1,iz,is)* dmu(imu-1)/dmu(imu-1)) / (dmu(imu-1)+dmu(imu-1)) / (dvpa) if ( density_conservation ) then cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & + 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) + vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ))& * 1 / mw ( iv + 1 , imu , iz , is )) / ( 2 * dmu ( imu - 1 )) / dvpa cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & + 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ) + vpa ( iv + 1 ) * mu ( imu - 1 ) * nux ( iv + 1 , imu - 1 , iz , is , isb ) * mw ( iv + 1 , imu - 1 , iz , is ))& * 1 / mw ( iv + 1 , imu - 1 , iz , is )) / ( 2 * dmu ( imu - 1 )) / dvpa bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & - 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) + vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ))& * 1 / mw ( iv , imu , iz , is )) / ( 2 * dmu ( imu - 1 )) / dvpa bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ) + vpa ( iv + 1 ) * mu ( imu - 1 ) * nux ( iv + 1 , imu - 1 , iz , is , isb ) * mw ( iv + 1 , imu - 1 , iz , is ))& * 1 / mw ( iv , imu - 1 , iz , is )) / ( 2 * dmu ( imu - 1 )) / dvpa else cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & - 1.0 * code_dt * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) * 1 / mw ( iv + 1 , imu , iz , is ) * ( dmu ( imu - 1 ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu - 1 )))& / ( dmu ( imu - 1 ) + dmu ( imu - 1 )) / ( dvpa ) cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & + 1.0 * code_dt * ( vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ) * 1 / mw ( iv + 1 , imu - 1 , iz , is ) * dmu ( imu - 1 ) / dmu ( imu - 1 ))& / ( dmu ( imu - 1 ) + dmu ( imu - 1 )) / ( dvpa ) bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & + 1.0 * code_dt * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) * 1 / mw ( iv , imu , iz , is ) * ( dmu ( imu - 1 ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu - 1 )))& / ( dmu ( imu - 1 ) + dmu ( imu - 1 )) / ( dvpa ) bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - 1.0 * code_dt * ( vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ) * 1 / mw ( iv , imu - 1 , iz , is ) * dmu ( imu - 1 ) / dmu ( imu - 1 ))& / ( dmu ( imu - 1 ) + dmu ( imu - 1 )) / ( dvpa ) end if end if else ! interior mu points for iv = 1 ! use ghost cell for derivative ! d/dvpa [vpa*mu*nux*F0*dhdmu] = [ ]_nvpa+0.5-[ ]_nvpa-0.5 / dvpa = -[ ]_nvpa-0.5 / dvpa ! = -0.5*([ ]_nvpa-1 + [ ]_nvpa) / dvpa ! could be cleared up, by moving non-nux part of aa_blcs down to non-nux part of bb_bcls cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & + 0.5 * vfac * code_dt * vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ) / mw ( iv + 1 , imu - 1 , iz , is ) * dmu ( imu ) / dmu ( imu - 1 ) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - 0.5 * vfac * code_dt * vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ) / mw ( iv + 1 , imu + 1 , iz , is ) * dmu ( imu - 1 ) / dmu ( imu ) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * 0.5 * ( eiediff * nupapv * vpap ** 2 + eidefl * deflknob * 2 * nuDpv * bmag ( ia , iz ) * mu ( imu )) * mwpv / dvpa ** 2 / mw ( iv + 1 , imu , iz , is ) & - 0.5 * vfac * code_dt * vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & + 0.5 * vfac * code_dt * vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) / mw ( iv , imu - 1 , iz , is ) * dmu ( imu ) / dmu ( imu - 1 ) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - 0.5 * vfac * code_dt * vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) / mw ( iv , imu + 1 , iz , is ) * dmu ( imu - 1 ) / dmu ( imu ) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & - 0.5 * vfac * code_dt * vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & + code_dt * ( 0.5 * ( eiediff * nupapv * vpap ** 2 + eidefl * deflknob * 2 * nuDpv * bmag ( ia , iz ) * mu ( imu )) * mwpv ) / dvpa ** 2 / mw ( iv , imu , iz , is ) ! mu operator if ( mu_operator ) then ! quantities at mu_{i+1/2} and mu_{i-1/2}: mup = 0.5 * ( mu ( imu ) + mu ( imu + 1 )) mum = 0.5 * ( mu ( imu ) + mu ( imu - 1 )) mwp = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mup ) mwm = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mum ) xp = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mup ) xm = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mum ) if (( is == 2 ) . and . ( isb == 1 ) . and . ( eimassr_approx )) then nuDp = eidefl * deflknob * spec ( is )% vnew ( isb ) / xp ** 3 nuDm = eidefl * deflknob * spec ( is )% vnew ( isb ) / xm ** 3 else nuDp = eidefl * deflknob * spec ( is )% vnew ( isb ) * ( erf ( xp / sqrt ( massr )) & - ( erf ( xp / sqrt ( massr )) - xp / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 / massr )) / ( 2 * xp ** 2 / massr )) / xp ** 3 nuDm = eidefl * deflknob * spec ( is )% vnew ( isb ) * ( erf ( xm / sqrt ( massr )) & - ( erf ( xm / sqrt ( massr )) - xm / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 / massr )) / ( 2 * xm ** 2 / massr )) / xm ** 3 end if nupap = spec ( is )% vnew ( isb ) * 2 * ( erf ( xp / sqrt ( massr )) - xp / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 / massr )) / ( 2 * xp ** 2 / massr ) / xp ** 3 nupam = spec ( is )% vnew ( isb ) * 2 * ( erf ( xm / sqrt ( massr )) - xm / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 / massr )) / ( 2 * xm ** 2 / massr ) / xm ** 3 gam_mu = 2 * ( eiediff * nupa ( iv , imu , iz , is , isb ) * mu ( imu ) ** 2 + eidefl * deflknob * nuD ( iv , imu , iz , is , isb ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mu ( imu )) * mw ( iv , imu , iz , is ) gam_mum = 2 * ( eiediff * nupam * mum ** 2 + eidefl * deflknob * nuDm * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mum ) * mwm gam_mup = 2 * ( eiediff * nupap * mup ** 2 + eidefl * deflknob * nuDp * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mup ) * mwp bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * (( gam_mu * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) - gam_mum / dmu ( imu - 1 )) * dmu ( imu ) / dmu ( imu - 1 ) & + ( - gam_mu * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) - gam_mup / dmu ( imu )) * dmu ( imu - 1 ) / dmu ( imu )) & / mw ( iv , imu , iz , is ) * 2. / ( dmu ( imu - 1 ) + dmu ( imu )) bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - code_dt * (( gam_mu *- 1 * dmu ( imu ) / dmu ( imu - 1 ) / ( dmu ( imu - 1 ) + dmu ( imu )) - gam_mum *- 1 / dmu ( imu - 1 )) * dmu ( imu ) / dmu ( imu - 1 ) & - gam_mu *- 1 * dmu ( imu ) / dmu ( imu - 1 ) / ( dmu ( imu - 1 ) + dmu ( imu )) * dmu ( imu - 1 ) / dmu ( imu )) / mw ( iv , imu - 1 , iz , is ) * 2. / ( dmu ( imu - 1 ) + dmu ( imu )) bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - code_dt * ( gam_mu * dmu ( imu - 1 ) / dmu ( imu ) / ( dmu ( imu - 1 ) + dmu ( imu )) * dmu ( imu ) / dmu ( imu - 1 ) & + ( gam_mup / dmu ( imu ) - gam_mu * dmu ( imu - 1 ) / dmu ( imu ) / ( dmu ( imu - 1 ) + dmu ( imu ))) * dmu ( imu - 1 ) / dmu ( imu )) & / mw ( iv , imu + 1 , iz , is ) * 2 / ( dmu ( imu - 1 ) + dmu ( imu )) ! mixed derivative: cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & - 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) + vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ))& * 1 / mw ( iv + 1 , imu , iz , is ) * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu ))) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & + 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ) + vpa ( iv + 1 ) * mu ( imu - 1 ) * nux ( iv + 1 , imu - 1 , iz , is , isb ) * mw ( iv + 1 , imu - 1 , iz , is ))& * 1 / mw ( iv + 1 , imu - 1 , iz , is ) * dmu ( imu ) / dmu ( imu - 1 )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ) + vpa ( iv + 1 ) * mu ( imu + 1 ) * nux ( iv + 1 , imu + 1 , iz , is , isb ) * mw ( iv + 1 , imu + 1 , iz , is ))& * 1 / mw ( iv + 1 , imu + 1 , iz , is ) * dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & + 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) + vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ))& * 1 / mw ( iv , imu , iz , is ) * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu ))) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ) + vpa ( iv + 1 ) * mu ( imu - 1 ) * nux ( iv + 1 , imu - 1 , iz , is , isb ) * mw ( iv + 1 , imu - 1 , iz , is ))& * 1 / mw ( iv , imu - 1 , iz , is ) * dmu ( imu ) / dmu ( imu - 1 )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & + 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ) + vpa ( iv + 1 ) * mu ( imu + 1 ) * nux ( iv + 1 , imu + 1 , iz , is , isb ) * mw ( iv + 1 , imu + 1 , iz , is ))& * 1 / mw ( iv , imu + 1 , iz , is ) * dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) end if end if else if ( iv == nvpa ) then vpam = 0.5 * ( vpa ( iv ) + vpa ( iv - 1 )) mwmv = exp ( - vpam ** 2 ) * maxwell_mu ( 1 , iz , imu , is ) xmv = sqrt ( vpam ** 2 + 2 * bmag ( ia , iz ) * mu ( imu )) nupamv = vfac * spec ( is )% vnew ( isb ) * 2 * ( erf ( xmv / sqrt ( massr )) - xmv / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xmv ** 2 / massr )) / ( 2 * xmv ** 2 / massr ) / xmv ** 3 if (( is == 2 ) . and . ( isb == 1 ) . and . ( eimassr_approx )) then nuDmv = eidefl * deflknob * vfac * spec ( is )% vnew ( isb ) / xmv ** 3 else nuDmv = eidefl * deflknob * vfac * spec ( is )% vnew ( isb ) * ( erf ( xmv / sqrt ( massr )) & - ( erf ( xmv / sqrt ( massr )) - xmv / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xmv ** 2 / massr )) / ( 2 * xmv ** 2 / massr )) / xmv ** 3 end if if ( imu == 1 ) then ! one-sided difference for mu-derivative at imu=1: ! ie d/dvpa [vpa*mu*nux*F0*dhdmu] = [ ]_nvpa+0.5-[ ]_nvpa-0.5 / dvpa = -[ ]_nvpa-0.5 / dvpa ! = -0.5*([ ]_nvpa-1 + [ ]_nvpa) / dvpa ! could be cleared up, by moving non-nux part of aa_blcs down to non-nux part of bb_bcls aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & + 0.5 * vfac * code_dt * vpa ( iv - 1 ) * 0.5 * ( mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) + mu ( imu + 1 ) * nux ( iv - 1 , imu + 1 , iz , is , isb ) * mw ( iv - 1 , imu + 1 , iz , is ))& / mw ( iv - 1 , imu + 1 , iz , is ) / ( dvpa ) / dmu ( imu ) aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) - code_dt * 0.5 * ( eiediff * nupamv * vpam ** 2 & + eidefl * deflknob * 2 * nuDmv * bmag ( ia , iz ) * mu ( imu )) * mwmv / dvpa ** 2 / mw ( iv - 1 , imu , iz , is ) & - 0.5 * vfac * code_dt * vpa ( iv - 1 ) * 0.5 * ( mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) + mu ( imu + 1 ) * nux ( iv - 1 , imu + 1 , iz , is , isb ) * mw ( iv - 1 , imu + 1 , iz , is ))& / mw ( iv - 1 , imu , iz , is ) / ( dvpa ) / dmu ( imu ) bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & + 0.5 * vfac * code_dt * vpa ( iv ) * 0.5 * ( mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) + mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ))& / mw ( iv , imu + 1 , iz , is ) / ( dvpa ) / dmu ( imu ) bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & - 0.5 * vfac * code_dt * vpa ( iv ) * 0.5 * ( mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) + mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ))& / mw ( iv , imu , iz , is ) / ( dvpa ) / dmu ( imu ) bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & + code_dt * ( 0.5 * ( eiediff * nupamv * vpam ** 2 + eidefl * deflknob * 2 * nuDmv * bmag ( ia , iz ) * mu ( imu )) * mwmv ) / dvpa ** 2 / mw ( iv , imu , iz , is ) ! mu operator if ( mu_operator ) then ! use ghost cell at mu_{0} = 0 mup = 0.5 * ( mu ( imu ) + mu ( imu + 1 )) mwp = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mup ) xp = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mup ) if (( is == 2 ) . and . ( isb == 1 ) . and . ( eimassr_approx )) then nuDp = eidefl * deflknob * spec ( is )% vnew ( isb ) / xp ** 3 else nuDp = eidefl * deflknob * spec ( is )% vnew ( isb ) * ( erf ( xp / sqrt ( massr )) & - ( erf ( xp / sqrt ( massr )) - xp / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 / massr )) / ( 2 * xp ** 2 / massr )) / xp ** 3 end if nupap = spec ( is )% vnew ( isb ) * 2 * ( erf ( xp / sqrt ( massr )) - xp / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 / massr )) / ( 2 * xp ** 2 / massr ) / xp ** 3 gam_mu = 2 * ( eiediff * nupa ( iv , imu , iz , is , isb ) * mu ( imu ) ** 2 + eidefl * deflknob * nuD ( iv , imu , iz , is , isb ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mu ( imu )) * mw ( iv , imu , iz , is ) gam_mup = 2 * ( eiediff * nupap * mup ** 2 + eidefl * deflknob * nuDp * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mup ) * mwp bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) - code_dt * ( gam_mu *- 1 / dmu ( imu ) * dmu ( imu ) / 2. / mu ( imu ) & + ( gam_mup *- 1 / dmu ( imu ) - gam_mu *- 1 / dmu ( imu )) * mu ( imu ) / ( dmu ( imu ) / 2. )) / mw ( iv , imu , iz , is ) / ( dmu ( imu ) / 2. + mu ( imu )) bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) - code_dt * ( gam_mu * 1 / dmu ( imu ) * dmu ( imu ) / 2. / mu ( imu ) & + ( gam_mup * 1 / dmu ( imu ) - gam_mu * 1 / dmu ( imu )) * mu ( imu ) / ( dmu ( imu ) / 2. )) / mw ( iv , imu + 1 , iz , is ) / ( dmu ( imu ) / 2. + mu ( imu )) ! mixed derivative: if ( density_conservation ) then ! to ensure density conservation, change discretisation of mixed derivative term at imu=1 ! from explicit routine: Dmuh1 = (vpa(iv)*mu(imu)*nux(iv,imu,iz)*mw(iv,imu,iz,is)*Dvpah + vpa(iv)*mu(imu+1)*nux(iv,imu+1,iz)*mw(iv,imu+1,iz,is)*Dvpah_p) / (2.*dmu(imu)) aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) & + 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) + vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ))& * 1 / mw ( iv - 1 , imu , iz , is )) / ( 2 * dmu ( imu )) / ( dvpa ) aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & + 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv - 1 ) * mu ( imu + 1 ) * nux ( iv - 1 , imu + 1 , iz , is , isb ) * mw ( iv - 1 , imu + 1 , iz , is ) + vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ))& * 1 / mw ( iv - 1 , imu + 1 , iz , is )) / ( 2 * dmu ( imu )) / ( dvpa ) bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & - 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) + vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ))& * 1 / mw ( iv , imu , iz , is )) / ( 2 * dmu ( imu )) / ( dvpa ) bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv - 1 ) * mu ( imu + 1 ) * nux ( iv - 1 , imu + 1 , iz , is , isb ) * mw ( iv - 1 , imu + 1 , iz , is ) + vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ))& * 1 / mw ( iv , imu + 1 , iz , is )) / ( 2 * dmu ( imu )) / ( dvpa ) else aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) & + 1.0 * code_dt * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) * 1 / mw ( iv - 1 , imu , iz , is ) * ( dmu ( imu ) / mu ( imu ) - mu ( imu ) / dmu ( imu )))& / ( mu ( imu ) + dmu ( imu )) / ( dvpa ) aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & + 1.0 * code_dt * ( vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ) * 1 / mw ( iv - 1 , imu + 1 , iz , is ) * mu ( imu ) / dmu ( imu ))& / ( mu ( imu ) + dmu ( imu )) / ( dvpa ) bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & - 1.0 * code_dt * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) * 1 / mw ( iv , imu , iz , is ) * ( dmu ( imu ) / mu ( imu ) - mu ( imu ) / dmu ( imu )))& / ( mu ( imu ) + dmu ( imu )) / ( dvpa ) bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - 1.0 * code_dt * ( vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ) * 1 / mw ( iv , imu + 1 , iz , is ) * mu ( imu ) / dmu ( imu ))& / ( mu ( imu ) + dmu ( imu )) / ( dvpa ) end if end if else if ( imu == nmu ) then ! one-sided difference for mu-derivative at imu=nmu: !aa_blcs(iv,imu,imu-1,iz,is) = aa_blcs(iv,imu,imu-1,iz,is) - 1.000*vfac*code_dt*vpa(iv-1)*mu(imu)*nux(iv-1,imu,iz,is,isb)*mw(iv-1,imu,iz,is)/mw(iv-1,imu-1,iz,is) / (2*dvpa) / dmu(nmu-1) !aa_blcs(iv,imu,imu,iz,is)   = aa_blcs(iv,imu,imu,iz,is) - code_dt*0.5*(eiediff*nupamv*vpam**2 + 2*nuDmv*bmag(ia,iz)*mu(imu))*mwmv / dvpa**2  / mw(iv-1,imu,iz,is) & !  + 1.000*vfac*code_dt*vpa(iv-1)*mu(imu)*nux(iv-1,imu,iz,is,isb)*mw(iv-1,imu,iz,is)/mw(iv-1,imu,iz,is) / (2*dvpa) / dmu(nmu-1) ! 24.02.21, second order: if ( density_conservation ) then !aa_blcs(iv,imu,imu-1,iz,is) = aa_blcs(iv,imu,imu-1,iz,is) & !- 1.000*vfac*code_dt*vpa(iv-1)*0.5*(mu(imu-1)*nux(iv-1,imu-1,iz,is,isb)*mw(iv-1,imu-1,iz,is)+mu(imu)*nux(iv-1,imu,iz,is,isb)*mw(iv-1,imu,iz,is))/mw(iv-1,imu-1,iz,is) / (2*dvpa) / dmu(nmu-1) !aa_blcs(iv,imu,imu,iz,is)   = aa_blcs(iv,imu,imu  ,iz,is) - code_dt*0.5*(eiediff*nupamv*vpam**2 + 2*nuDmv*bmag(ia,iz)*mu(imu))*mwmv / dvpa**2 / mw(iv-1,imu,iz,is) & ! + 1.000*vfac*code_dt*vpa(iv-1)*0.5*(mu(imu-1)*nux(iv-1,imu-1,iz,is,isb)*mw(iv-1,imu-1,iz,is)+mu(imu)*nux(iv-1,imu,iz,is,isb)*mw(iv-1,imu,iz,is))/mw(iv-1,imu  ,iz,is) / (2*dvpa) / dmu(nmu-1) ! take vpa derivative using ghost cell at nvpa+0.5 ! ie d/dvpa [vpa*mu*nux*F0*dhdmu] = [ ]_nvpa+0.5-[ ]_nvpa-0.5 / dvpa = -[ ]_nvpa-0.5 / dvpa ! = -0.5*([ ]_nvpa-1 + [ ]_nvpa) / dvpa ! note this could be cleared up, by moving the non-nux part of aa_blcs down to the non-nux part of bb_bcls aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - 0.5 * vfac * code_dt * vpa ( iv - 1 ) * 0.5 * ( mu ( imu - 1 ) * nux ( iv - 1 , imu - 1 , iz , is , isb ) * mw ( iv - 1 , imu - 1 , iz , is ) + mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ))& / mw ( iv - 1 , imu - 1 , iz , is ) / ( dvpa ) / dmu ( nmu - 1 ) aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * 0.5 * ( eiediff * nupamv * vpam ** 2 + eidefl * deflknob * 2 * nuDmv * bmag ( ia , iz ) * mu ( imu )) * mwmv / dvpa ** 2 / mw ( iv - 1 , imu , iz , is ) & + 0.5 * vfac * code_dt * vpa ( iv - 1 ) * 0.5 * ( mu ( imu - 1 ) * nux ( iv - 1 , imu - 1 , iz , is , isb ) * mw ( iv - 1 , imu - 1 , iz , is ) + mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ))& / mw ( iv - 1 , imu , iz , is ) / ( dvpa ) / dmu ( nmu - 1 ) bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - 0.5 * vfac * code_dt * vpa ( iv ) * 0.5 * ( mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ) + mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ))& / mw ( iv , imu - 1 , iz , is ) / ( dvpa ) / dmu ( nmu - 1 ) bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & + 0.5 * vfac * code_dt * vpa ( iv ) * 0.5 * ( mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ) + mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ))& / mw ( iv , imu , iz , is ) / ( dvpa ) / dmu ( nmu - 1 ) else aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - 1.0 * vfac * code_dt * vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) / mw ( iv - 1 , imu - 1 , iz , is ) / ( 2 * dvpa ) / dmu ( nmu - 1 ) aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * 0.5 * ( eiediff * nupamv * vpam ** 2 + eidefl * deflknob * 2 * nuDmv * bmag ( ia , iz ) * mu ( imu )) * mwmv / dvpa ** 2 / mw ( iv - 1 , imu , iz , is ) & + 1.0 * vfac * code_dt * vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) / mw ( iv - 1 , imu , iz , is ) / ( 2 * dvpa ) / dmu ( nmu - 1 ) end if bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & + code_dt * ( 0.5 * ( eiediff * nupamv * vpam ** 2 + eidefl * deflknob * 2 * nuDmv * bmag ( ia , iz ) * mu ( imu )) * mwmv ) / dvpa ** 2 / mw ( iv , imu , iz , is ) ! mu operator if ( mu_operator ) then mum = 0.5 * ( mu ( imu ) + mu ( imu - 1 )) mwm = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mum ) xm = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mum ) if (( is == 2 ) . and . ( isb == 1 ) . and . ( eimassr_approx )) then nuDm = eidefl * deflknob * spec ( is )% vnew ( isb ) / xm ** 3 else nuDm = eidefl * deflknob * spec ( is )% vnew ( isb ) * ( erf ( xm / sqrt ( massr )) & - ( erf ( xm / sqrt ( massr )) - xm / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 / massr )) / ( 2 * xm ** 2 / massr )) / xm ** 3 end if nupam = spec ( is )% vnew ( isb ) * 2 * ( erf ( xm / sqrt ( massr )) - xm / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 / massr )) / ( 2 * xm ** 2 / massr ) / xm ** 3 gam_mu = 2 * ( eiediff * nupa ( iv , imu , iz , is , isb ) * mu ( imu ) ** 2 + eidefl * deflknob * nuD ( iv , imu , iz , is , isb ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mu ( imu )) * mw ( iv , imu , iz , is ) gam_mum = 2 * ( eiediff * nupam * mum ** 2 + eidefl * deflknob * nuDm * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mum ) * mwm if ( density_conservation ) then ! to ensure density conservation we assume that the argument of the outer derivative vanishes at nmu+1/2, ie ! d/dmu[...]_{nmu} = ([...]_{nmu+1/2} - [...]_{nmu-1/2})/(dmu_{nmu-1}/2+dmu(nmu-1)/2), where [...]_{nmu+1/2} is a ghost cell at mu = mu_{nmu} + dmu(nmu-1)/2, with [...]_{nmu+1/2} = 0. bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) - code_dt * (( gam_mu / dmu ( imu - 1 ) - gam_mum / dmu ( imu - 1 )) * dmu ( imu - 1 ) / ( dmu ( imu - 1 )) & + ( - gam_mu / dmu ( imu - 1 )) * dmu ( imu - 1 ) / dmu ( imu - 1 )) / mw ( iv , imu , iz , is ) / ( dmu ( imu - 1 ) / 2. + dmu ( imu - 1 ) / 2. ) bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) - code_dt * (( - gam_mu / dmu ( imu - 1 ) - gam_mum * - 1 / dmu ( imu - 1 )) * dmu ( imu - 1 ) / ( dmu ( imu - 1 )) & - gam_mu *- 1 / dmu ( imu - 1 ) * dmu ( imu - 1 ) / dmu ( imu - 1 )) / mw ( iv , imu - 1 , iz , is ) / ( dmu ( imu - 1 ) / 2. + dmu ( imu - 1 ) / 2. ) else bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) - code_dt * (( gam_mu / dmu ( imu - 1 ) - gam_mum / dmu ( imu - 1 )) * dmu ( imu - 1 ) / ( dmu ( imu - 1 ) / 2. ) & + ( - gam_mu / dmu ( imu - 1 )) * dmu ( imu - 1 ) / 2. / dmu ( imu - 1 )) / mw ( iv , imu , iz , is ) / ( dmu ( imu - 1 ) / 2. + dmu ( imu - 1 )) bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) - code_dt * (( - gam_mu / dmu ( imu - 1 ) - gam_mum * - 1 / dmu ( imu - 1 )) * dmu ( imu - 1 ) / ( dmu ( imu - 1 ) / 2. ) & - gam_mu *- 1 / dmu ( imu - 1 ) * dmu ( imu - 1 ) / 2. / dmu ( imu - 1 )) / mw ( iv , imu - 1 , iz , is ) / ( dmu ( imu - 1 ) / 2. + dmu ( imu - 1 )) end if ! mixed derivative: ! 24.02.21, commenting out !aa_blcs(iv,imu,imu,iz,is)    = aa_blcs(iv,imu,imu  ,iz,is) & !  + 1.000*code_dt*(vpa(iv)*mu(imu)*nux(iv,imu,iz,is,isb)*mw(iv,imu,iz,is)*1/mw(iv-1,imu,iz,is)*(dmu(imu-1)/dmu(imu-1)-dmu(imu-1)/dmu(imu-1))) / (dmu(imu-1)+dmu(imu-1)) / (dvpa) !aa_blcs(iv,imu,imu-1,iz,is)  = aa_blcs(iv,imu,imu-1,iz,is) & !  - 1.000*code_dt*(vpa(iv)*mu(imu-1)*nux(iv,imu-1,iz,is,isb)*mw(iv,imu-1,iz,is)*1/mw(iv-1,imu-1,iz,is)* dmu(imu-1)/dmu(imu-1)) / (dmu(imu-1)+dmu(imu-1)) / (dvpa) !bb_blcs(iv,imu,imu,ikxkyz)   = bb_blcs(iv,imu,imu  ,ikxkyz) & !  - 1.000*code_dt*(vpa(iv)*mu(imu)*nux(iv,imu,iz,is,isb)*mw(iv,imu,iz,is)*1/mw(iv,imu,iz,is)*(dmu(imu-1)/dmu(imu-1)-dmu(imu-1)/dmu(imu-1))) / (dmu(imu-1)+dmu(imu-1)) / (dvpa) !bb_blcs(iv,imu,imu-1,ikxkyz) = bb_blcs(iv,imu,imu-1,ikxkyz) & !  + 1.000*code_dt*(vpa(iv)*mu(imu-1)*nux(iv,imu-1,iz,is,isb)*mw(iv,imu-1,iz,is)*1/mw(iv,imu-1,iz,is)* dmu(imu-1)/dmu(imu-1)) / (dmu(imu-1)+dmu(imu-1)) / (dvpa) if ( density_conservation ) then ! 04.03. removed an extra bracket at end of lines in following block aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv - 1 ) * mu ( imu - 1 ) * nux ( iv - 1 , imu - 1 , iz , is , isb ) * mw ( iv - 1 , imu - 1 , iz , is ) + vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ))& * 1 / mw ( iv - 1 , imu - 1 , iz , is )) / ( 2 * dmu ( imu - 1 )) / dvpa aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) & - 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) + vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ))& * 1 / mw ( iv - 1 , imu , iz , is )) / ( 2 * dmu ( imu - 1 )) / dvpa bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & + 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv - 1 ) * mu ( imu - 1 ) * nux ( iv - 1 , imu - 1 , iz , is , isb ) * mw ( iv - 1 , imu - 1 , iz , is ) + vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ))& * 1 / mw ( iv , imu - 1 , iz , is )) / ( 2 * dmu ( imu - 1 )) / dvpa bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & + 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) + vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ))& * 1 / mw ( iv , imu , iz , is )) / ( 2 * dmu ( imu - 1 )) / dvpa else aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) & + 1.0 * code_dt * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) * 1 / mw ( iv - 1 , imu , iz , is ) * ( dmu ( imu - 1 ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu - 1 )))& / ( dmu ( imu - 1 ) + dmu ( imu - 1 )) / ( dvpa ) aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - 1.0 * code_dt * ( vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ) * 1 / mw ( iv - 1 , imu - 1 , iz , is ) * dmu ( imu - 1 ) / dmu ( imu - 1 ))& / ( dmu ( imu - 1 ) + dmu ( imu - 1 )) / ( dvpa ) bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & - 1.0 * code_dt * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) * 1 / mw ( iv , imu , iz , is ) * ( dmu ( imu - 1 ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu - 1 )))& / ( dmu ( imu - 1 ) + dmu ( imu - 1 )) / ( dvpa ) bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & + 1.0 * code_dt * ( vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ) * 1 / mw ( iv , imu - 1 , iz , is ) * dmu ( imu - 1 ) / dmu ( imu - 1 ))& / ( dmu ( imu - 1 ) + dmu ( imu - 1 )) / ( dvpa ) end if end if else ! interior mu points for iv=nvpa ! take vpa derivative using ghost cell at nvpa+0.5 ! ie d/dvpa [vpa*mu*nux*F0*dhdmu] = [ ]_nvpa+0.5-[ ]_nvpa-0.5 / dvpa = -[ ]_nvpa-0.5 / dvpa ! = -0.5*([ ]_nvpa-1 + [ ]_nvpa) / dvpa ! note this could be cleared up, by moving the non-nux part of aa_blcs down to the non-nux part of bb_bcls aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - 0.5 * vfac * code_dt * vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) / mw ( iv - 1 , imu - 1 , iz , is ) * dmu ( imu ) / dmu ( imu - 1 ) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & + 0.5 * vfac * code_dt * vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) / mw ( iv - 1 , imu + 1 , iz , is ) * dmu ( imu - 1 ) / dmu ( imu ) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * 0.5 * ( eiediff * nupamv * vpam ** 2 + eidefl * deflknob * 2 * nuDmv * bmag ( ia , iz ) * mu ( imu )) * mwmv / dvpa ** 2 / mw ( iv - 1 , imu , iz , is ) & + 0.5 * vfac * code_dt * vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - 0.5 * vfac * code_dt * vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) / mw ( iv , imu - 1 , iz , is ) * dmu ( imu ) / dmu ( imu - 1 ) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & + 0.5 * vfac * code_dt * vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) / mw ( iv , imu + 1 , iz , is ) * dmu ( imu - 1 ) / dmu ( imu ) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & + 0.5 * vfac * code_dt * vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & + code_dt * ( 0.5 * ( eiediff * nupamv * vpam ** 2 + eidefl * deflknob * 2 * nuDmv * bmag ( ia , iz ) * mu ( imu )) * mwmv ) / dvpa ** 2 / mw ( iv , imu , iz , is ) ! mu operator if ( mu_operator ) then ! quantities at mu_{i+1/2} and mu_{i-1/2}: mup = 0.5 * ( mu ( imu ) + mu ( imu + 1 )) mum = 0.5 * ( mu ( imu ) + mu ( imu - 1 )) mwp = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mup ) mwm = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mum ) xp = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mup ) xm = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mum ) if (( is == 2 ) . and . ( isb == 1 ) . and . ( eimassr_approx )) then nuDp = eidefl * deflknob * spec ( is )% vnew ( isb ) / xp ** 3 nuDm = eidefl * deflknob * spec ( is )% vnew ( isb ) / xm ** 3 else nuDp = eidefl * deflknob * spec ( is )% vnew ( isb ) * ( erf ( xp / sqrt ( massr )) - ( erf ( xp / sqrt ( massr )) - xp / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 / massr )) / ( 2 * xp ** 2 / massr )) / xp ** 3 nuDm = eidefl * deflknob * spec ( is )% vnew ( isb ) * ( erf ( xm / sqrt ( massr )) - ( erf ( xm / sqrt ( massr )) - xm / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 / massr )) / ( 2 * xm ** 2 / massr )) / xm ** 3 end if nupap = spec ( is )% vnew ( isb ) * 2 * ( erf ( xp / sqrt ( massr )) - xp / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 / massr )) / ( 2 * xp ** 2 / massr ) / xp ** 3 nupam = spec ( is )% vnew ( isb ) * 2 * ( erf ( xm / sqrt ( massr )) - xm / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 / massr )) / ( 2 * xm ** 2 / massr ) / xm ** 3 gam_mu = 2 * ( eiediff * nupa ( iv , imu , iz , is , isb ) * mu ( imu ) ** 2 + eidefl * deflknob * nuD ( iv , imu , iz , is , isb ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mu ( imu )) * mw ( iv , imu , iz , is ) gam_mum = 2 * ( eiediff * nupam * mum ** 2 + eidefl * deflknob * nuDm * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mum ) * mwm gam_mup = 2 * ( eiediff * nupap * mup ** 2 + eidefl * deflknob * nuDp * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mup ) * mwp bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * (( gam_mu * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) - gam_mum / dmu ( imu - 1 )) * dmu ( imu ) / dmu ( imu - 1 ) & + ( - gam_mu * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) - gam_mup / dmu ( imu )) * dmu ( imu - 1 ) / dmu ( imu )) & / mw ( iv , imu , iz , is ) * 2. / ( dmu ( imu - 1 ) + dmu ( imu )) bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - code_dt * (( gam_mu *- 1 * dmu ( imu ) / dmu ( imu - 1 ) / ( dmu ( imu - 1 ) + dmu ( imu )) - gam_mum *- 1 / dmu ( imu - 1 )) * dmu ( imu ) / dmu ( imu - 1 ) & - gam_mu *- 1 * dmu ( imu ) / dmu ( imu - 1 ) / ( dmu ( imu - 1 ) + dmu ( imu )) * dmu ( imu - 1 ) / dmu ( imu )) / mw ( iv , imu - 1 , iz , is ) * 2. / ( dmu ( imu - 1 ) + dmu ( imu )) bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - code_dt * ( gam_mu * dmu ( imu - 1 ) / dmu ( imu ) / ( dmu ( imu - 1 ) + dmu ( imu )) * dmu ( imu ) / dmu ( imu - 1 ) & + ( gam_mup / dmu ( imu ) - gam_mu * dmu ( imu - 1 ) / dmu ( imu ) / ( dmu ( imu - 1 ) + dmu ( imu ))) * dmu ( imu - 1 ) / dmu ( imu )) & / mw ( iv , imu + 1 , iz , is ) * 2 / ( dmu ( imu - 1 ) + dmu ( imu )) ! mixed derivative, one-sided difference in vpa at iv = nvpa: ! use second order accurate treatment for vpa derivative at nvpa aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) & + 0.5 * code_dt * ( 0.5 * ( vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) + vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ))& * 1 / mw ( iv - 1 , imu , iz , is ) * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu ))) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - 0.5 * code_dt * ( 0.5 * ( vpa ( iv - 1 ) * mu ( imu - 1 ) * nux ( iv - 1 , imu - 1 , iz , is , isb ) * mw ( iv - 1 , imu - 1 , iz , is ) + vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ))& * 1 / mw ( iv - 1 , imu - 1 , iz , is ) * dmu ( imu ) / dmu ( imu - 1 )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & + 0.5 * code_dt * ( 0.5 * ( vpa ( iv - 1 ) * mu ( imu + 1 ) * nux ( iv - 1 , imu + 1 , iz , is , isb ) * mw ( iv - 1 , imu + 1 , iz , is ) + vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ))& * 1 / mw ( iv - 1 , imu + 1 , iz , is ) * dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & - 0.5 * code_dt * ( 0.5 * ( vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) + vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ))& * 1 / mw ( iv , imu , iz , is ) * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu ))) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & + 0.5 * code_dt * ( 0.5 * ( vpa ( iv - 1 ) * mu ( imu - 1 ) * nux ( iv - 1 , imu - 1 , iz , is , isb ) * mw ( iv - 1 , imu - 1 , iz , is ) + vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ))& * 1 / mw ( iv , imu - 1 , iz , is ) * dmu ( imu ) / dmu ( imu - 1 )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - 0.5 * code_dt * ( 0.5 * ( vpa ( iv - 1 ) * mu ( imu + 1 ) * nux ( iv - 1 , imu + 1 , iz , is , isb ) * mw ( iv - 1 , imu + 1 , iz , is ) + vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ))& * 1 / mw ( iv , imu + 1 , iz , is ) * dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) end if end if else ! interior vpa points vpam = 0.5 * ( vpa ( iv ) + vpa ( iv - 1 )) vpap = 0.5 * ( vpa ( iv ) + vpa ( iv + 1 )) mwmv = exp ( - vpam ** 2 ) * maxwell_mu ( 1 , iz , imu , is ) mwpv = exp ( - vpap ** 2 ) * maxwell_mu ( 1 , iz , imu , is ) xpv = sqrt ( vpap ** 2 + 2 * bmag ( ia , iz ) * mu ( imu )) xmv = sqrt ( vpam ** 2 + 2 * bmag ( ia , iz ) * mu ( imu )) nupamv = vfac * spec ( is )% vnew ( isb ) * 2 * ( erf ( xmv / sqrt ( massr )) - xmv / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xmv ** 2 / massr )) / ( 2 * xmv ** 2 / massr ) / xmv ** 3 nupapv = vfac * spec ( is )% vnew ( isb ) * 2 * ( erf ( xpv / sqrt ( massr )) - xpv / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xpv ** 2 / massr )) / ( 2 * xpv ** 2 / massr ) / xpv ** 3 if (( is == 2 ) . and . ( isb == 1 ) . and . ( eimassr_approx )) then nuDmv = eidefl * deflknob * vfac * spec ( is )% vnew ( isb ) / xmv ** 3 nuDpv = eidefl * deflknob * vfac * spec ( is )% vnew ( isb ) / xpv ** 3 else nuDmv = eidefl * deflknob * vfac * spec ( is )% vnew ( isb ) * ( erf ( xmv / sqrt ( massr )) & - ( erf ( xmv / sqrt ( massr )) - xmv / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xmv ** 2 / massr )) / ( 2 * xmv ** 2 / massr )) / xmv ** 3 nuDpv = eidefl * deflknob * vfac * spec ( is )% vnew ( isb ) * ( erf ( xpv / sqrt ( massr )) & - ( erf ( xpv / sqrt ( massr )) - xpv / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xpv ** 2 / massr )) / ( 2 * xpv ** 2 / massr )) / xpv ** 3 end if if ( imu == 1 ) then ! one-sided difference for mu-derivative at imu=1: if (. not . density_conservation ) then aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & + vfac * code_dt * vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) / mw ( iv - 1 , imu + 1 , iz , is ) / ( 2 * dvpa ) / dmu ( imu ) aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * 0.5 * ( eiediff * nupamv * vpam ** 2 + eidefl * deflknob * 2 * nuDmv * bmag ( ia , iz ) * mu ( imu )) * mwmv / dvpa ** 2 / mw ( iv - 1 , imu , iz , is ) & - vfac * code_dt * vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) / ( 2 * dvpa ) / dmu ( imu ) cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - vfac * code_dt * vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ) / mw ( iv + 1 , imu + 1 , iz , is ) / ( 2 * dvpa ) / dmu ( imu ) cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * 0.5 * ( eiediff * nupapv * vpap ** 2 + eidefl * deflknob * 2 * nuDpv * bmag ( ia , iz ) * mu ( imu )) * mwpv / dvpa ** 2 / mw ( iv + 1 , imu , iz , is ) & + vfac * code_dt * vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) / ( 2 * dvpa ) / dmu ( imu ) else if ( density_conservation ) then ! to ensure density conservation, assume that nux*F0 vanishes at iv=1 and iv=nvpa aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & + 0.5 * vfac * code_dt * vpa ( iv - 1 ) * ( mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) + mu ( imu + 1 ) * nux ( iv - 1 , imu + 1 , iz , is , isb ) * mw ( iv - 1 , imu + 1 , iz , is ))& / mw ( iv - 1 , imu + 1 , iz , is ) / ( 2 * dvpa ) / dmu ( imu ) aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * 0.5 * ( eiediff * nupamv * vpam ** 2 + eidefl * deflknob * 2 * nuDmv * bmag ( ia , iz ) * mu ( imu )) * mwmv / dvpa ** 2 / mw ( iv - 1 , imu , iz , is ) & - 0.5 * vfac * code_dt * vpa ( iv - 1 ) * ( mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) + mu ( imu + 1 ) * nux ( iv - 1 , imu + 1 , iz , is , isb ) * mw ( iv - 1 , imu + 1 , iz , is ))& / mw ( iv - 1 , imu , iz , is ) / ( 2 * dvpa ) / dmu ( imu ) cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - 0.5 * vfac * code_dt * vpa ( iv + 1 ) * ( mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ) + mu ( imu + 1 ) * nux ( iv + 1 , imu + 1 , iz , is , isb ) * mw ( iv + 1 , imu + 1 , iz , is ))& / mw ( iv + 1 , imu + 1 , iz , is ) / ( 2 * dvpa ) / dmu ( imu ) cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * 0.5 * ( eiediff * nupapv * vpap ** 2 + eidefl * deflknob * 2 * nuDpv * bmag ( ia , iz ) * mu ( imu )) * mwpv / dvpa ** 2 / mw ( iv + 1 , imu , iz , is ) & + 0.5 * vfac * code_dt * vpa ( iv + 1 ) * ( mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ) + mu ( imu + 1 ) * nux ( iv + 1 , imu + 1 , iz , is , isb ) * mw ( iv + 1 , imu + 1 , iz , is ))& / mw ( iv + 1 , imu , iz , is ) / ( 2 * dvpa ) / dmu ( imu ) end if bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & + code_dt * ( 0.5 * ( eiediff * nupapv * vpap ** 2 + eidefl * deflknob * 2 * nuDpv * bmag ( ia , iz ) * mu ( imu )) * mwpv & + 0.5 * ( eiediff * nupamv * vpam ** 2 + eidefl * deflknob * 2 * nuDmv * bmag ( ia , iz ) * mu ( imu )) * mwmv ) / dvpa ** 2 / mw ( iv , imu , iz , is ) ! mu operator if ( mu_operator ) then ! use ghost cell at mu_{0} = 0, where term vanishes, so dmu(0) = mu(1). mup = 0.5 * ( mu ( imu ) + mu ( imu + 1 )) mwp = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mup ) xp = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mup ) if (( is == 2 ) . and . ( isb == 1 ) . and . ( eimassr_approx )) then nuDp = eidefl * deflknob * spec ( is )% vnew ( isb ) / xp ** 3 else nuDp = eidefl * deflknob * spec ( is )% vnew ( isb ) * ( erf ( xp / sqrt ( massr )) & - ( erf ( xp / sqrt ( massr )) - xp / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 / massr )) / ( 2 * xp ** 2 / massr )) / xp ** 3 end if nupap = spec ( is )% vnew ( isb ) * 2 * ( erf ( xp / sqrt ( massr )) - xp / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 / massr )) / ( 2 * xp ** 2 / massr ) / xp ** 3 gam_mu = 2 * ( eiediff * nupa ( iv , imu , iz , is , isb ) * mu ( imu ) ** 2 + eidefl * deflknob * nuD ( iv , imu , iz , is , isb ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mu ( imu )) * mw ( iv , imu , iz , is ) gam_mup = 2 * ( eiediff * nupap * mup ** 2 + eidefl * deflknob * nuDp * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mup ) * mwp bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) - code_dt * ( gam_mu *- 1 / dmu ( imu ) * dmu ( imu ) / 2. / mu ( imu ) & + ( gam_mup *- 1 / dmu ( imu ) - gam_mu *- 1 / dmu ( imu )) * mu ( imu ) / ( dmu ( imu ) / 2. )) / mw ( iv , imu , iz , is ) / ( dmu ( imu ) / 2. + mu ( imu )) bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) - code_dt * ( gam_mu * 1 / dmu ( imu ) * dmu ( imu ) / 2. / mu ( imu ) & + ( gam_mup * 1 / dmu ( imu ) - gam_mu * 1 / dmu ( imu )) * mu ( imu ) / ( dmu ( imu ) / 2. )) / mw ( iv , imu + 1 , iz , is ) / ( dmu ( imu ) / 2. + mu ( imu )) ! mixed derivative: if ( density_conservation ) then ! to ensure density conservation, we change discretisation of mixed derivative term at imu=1 ! from explicit routine: Dmuh1 = (vpa(iv)*mu(imu)*nux(iv,imu,iz)*mw(iv,imu,iz,is)*Dvpah & !     + vpa(iv)*mu(imu+1)*nux(iv,imu+1,iz)*mw(iv,imu+1,iz,is)*Dvpah_p) / (2.*dmu(imu)) aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) & + code_dt * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) * 1 / mw ( iv - 1 , imu , iz , is )) / ( 2 * dmu ( imu )) / ( 2 * dvpa ) aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & + code_dt * ( vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ) * 1 / mw ( iv - 1 , imu + 1 , iz , is )) / ( 2 * dmu ( imu )) / ( 2 * dvpa ) cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) * 1 / mw ( iv + 1 , imu , iz , is )) / ( 2 * dmu ( imu )) / ( 2 * dvpa ) cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - code_dt * ( vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ) * 1 / mw ( iv + 1 , imu + 1 , iz , is )) / ( 2 * dmu ( imu )) / ( 2 * dvpa ) else aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) & + code_dt * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) * 1 / mw ( iv - 1 , imu , iz , is ) * ( dmu ( imu ) / mu ( imu ) - mu ( imu ) / dmu ( imu )))& / ( mu ( imu ) + dmu ( imu )) / ( 2 * dvpa ) aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & + code_dt * ( vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ) * 1 / mw ( iv - 1 , imu + 1 , iz , is ) * mu ( imu ) / dmu ( imu )) & / ( mu ( imu ) + dmu ( imu )) / ( 2 * dvpa ) cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) * 1 / mw ( iv + 1 , imu , iz , is ) * ( dmu ( imu ) / mu ( imu ) - mu ( imu ) / dmu ( imu ))) & / ( mu ( imu ) + dmu ( imu )) / ( 2 * dvpa ) cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - code_dt * ( vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ) * 1 / mw ( iv + 1 , imu + 1 , iz , is ) * mu ( imu ) / dmu ( imu )) & / ( mu ( imu ) + dmu ( imu )) / ( 2 * dvpa ) end if end if else if ( imu == nmu ) then ! one-sided difference for mu-derivative at imu=nmu: ! to be consistent with treatment of mixed mu operator; assume that nux(imu)=0. if ( density_conservation ) then aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - 1.0 * vfac * code_dt * vpa ( iv - 1 ) * 0.5 * ( mu ( imu - 1 ) * nux ( iv - 1 , imu - 1 , iz , is , isb ) * mw ( iv - 1 , imu - 1 , iz , is ) + mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ))& / mw ( iv - 1 , imu - 1 , iz , is ) / ( 2 * dvpa ) / dmu ( nmu - 1 ) aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * 0.5 * ( eiediff * nupamv * vpam ** 2 + eidefl * deflknob * 2 * nuDmv * bmag ( ia , iz ) * mu ( imu )) * mwmv / dvpa ** 2 / mw ( iv - 1 , imu , iz , is ) & + 1.0 * vfac * code_dt * vpa ( iv - 1 ) * 0.5 * ( mu ( imu - 1 ) * nux ( iv - 1 , imu - 1 , iz , is , isb ) * mw ( iv - 1 , imu - 1 , iz , is ) + mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ))& / mw ( iv - 1 , imu , iz , is ) / ( 2 * dvpa ) / dmu ( nmu - 1 ) cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & + 1.0 * vfac * code_dt * vpa ( iv + 1 ) * 0.5 * ( mu ( imu - 1 ) * nux ( iv + 1 , imu - 1 , iz , is , isb ) * mw ( iv + 1 , imu - 1 , iz , is ) + mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ))& / mw ( iv + 1 , imu - 1 , iz , is ) / ( 2 * dvpa ) / dmu ( nmu - 1 ) cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * 0.5 * ( eiediff * nupapv * vpap ** 2 + eidefl * deflknob * 2 * nuDpv * bmag ( ia , iz ) * mu ( imu )) * mwpv / dvpa ** 2 / mw ( iv + 1 , imu , iz , is ) & - 1.0 * vfac * code_dt * vpa ( iv + 1 ) * 0.5 * ( mu ( imu - 1 ) * nux ( iv + 1 , imu - 1 , iz , is , isb ) * mw ( iv + 1 , imu - 1 , iz , is ) + mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ))& / mw ( iv + 1 , imu , iz , is ) / ( 2 * dvpa ) / dmu ( nmu - 1 ) else aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - 1.0 * vfac * code_dt * vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) / mw ( iv - 1 , imu - 1 , iz , is ) / ( 2 * dvpa ) / dmu ( nmu - 1 ) aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * 0.5 * ( eiediff * nupamv * vpam ** 2 + eidefl * deflknob * 2 * nuDmv * bmag ( ia , iz ) * mu ( imu )) * mwmv / dvpa ** 2 / mw ( iv - 1 , imu , iz , is ) & + 1.0 * vfac * code_dt * vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) / ( 2 * dvpa ) / dmu ( nmu - 1 ) cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & + 1.0 * vfac * code_dt * vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ) / mw ( iv + 1 , imu - 1 , iz , is ) / ( 2 * dvpa ) / dmu ( nmu - 1 ) cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * 0.5 * ( eiediff * nupapv * vpap ** 2 + eidefl * deflknob * 2 * nuDpv * bmag ( ia , iz ) * mu ( imu )) * mwpv / dvpa ** 2 / mw ( iv + 1 , imu , iz , is ) & - 1.0 * vfac * code_dt * vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) / ( 2 * dvpa ) / dmu ( nmu - 1 ) end if bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & + code_dt * ( 0.5 * ( eiediff * nupapv * vpap ** 2 + eidefl * deflknob * 2 * nuDpv * bmag ( ia , iz ) * mu ( imu )) * mwpv & + 0.5 * ( eiediff * nupamv * vpam ** 2 + eidefl * deflknob * 2 * nuDmv * bmag ( ia , iz ) * mu ( imu )) * mwmv ) / dvpa ** 2 / mw ( iv , imu , iz , is ) ! mu operator if ( mu_operator ) then mum = 0.5 * ( mu ( imu ) + mu ( imu - 1 )) mwm = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mum ) xm = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mum ) if (( is == 2 ) . and . ( isb == 1 ) . and . ( eimassr_approx )) then nuDm = eidefl * deflknob * spec ( is )% vnew ( isb ) / xm ** 3 else nuDm = eidefl * deflknob * spec ( is )% vnew ( isb ) * ( erf ( xm / sqrt ( massr )) & - ( erf ( xm / sqrt ( massr )) - xm / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 / massr )) / ( 2 * xm ** 2 / massr )) / xm ** 3 end if nupam = spec ( is )% vnew ( isb ) * 2 * ( erf ( xm / sqrt ( massr )) - xm / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 / massr )) / ( 2 * xm ** 2 / massr ) / xm ** 3 gam_mu = 2 * ( eiediff * nupa ( iv , imu , iz , is , isb ) * mu ( imu ) ** 2 + eidefl * deflknob * nuD ( iv , imu , iz , is , isb ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mu ( imu )) * mw ( iv , imu , iz , is ) gam_mum = 2 * ( eiediff * nupam * mum ** 2 + eidefl * deflknob * nuDm * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mum ) * mwm if ( density_conservation ) then ! to ensure density conservation assume that argument of outer derivative vanishes at nmu+1/2, ie ! d/dmu[...]_{nmu} = ([...]_{nmu+1/2} - [...]_{nmu-1/2})/(dmu_{nmu-1}/2+dmu(nmu-1)/2) ! where [...]_{nmu+1/2} is a ghost cell at mu = mu_{nmu} + dmu(nmu-1)/2, with [...]_{nmu+1/2} = 0. bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * (( gam_mu / dmu ( imu - 1 ) - gam_mum / dmu ( imu - 1 )) * dmu ( imu - 1 ) / ( dmu ( imu - 1 )) & + ( - gam_mu / dmu ( imu - 1 )) * dmu ( imu - 1 ) / dmu ( imu - 1 )) / mw ( iv , imu , iz , is ) / ( dmu ( imu - 1 ) / 2. + dmu ( imu - 1 ) / 2. ) bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - code_dt * (( - gam_mu / dmu ( imu - 1 ) - gam_mum *- 1 / dmu ( imu - 1 )) * dmu ( imu - 1 ) / ( dmu ( imu - 1 )) & - gam_mu *- 1 / dmu ( imu - 1 ) * dmu ( imu - 1 ) / dmu ( imu - 1 )) / mw ( iv , imu - 1 , iz , is ) / ( dmu ( imu - 1 ) / 2. + dmu ( imu - 1 ) / 2. ) else bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * (( gam_mu / dmu ( imu - 1 ) - gam_mum / dmu ( imu - 1 )) * dmu ( imu - 1 ) / ( dmu ( imu - 1 ) / 2. ) & + ( - gam_mu / dmu ( imu - 1 )) * dmu ( imu - 1 ) / 2. / dmu ( imu - 1 )) / mw ( iv , imu , iz , is ) / ( dmu ( imu - 1 ) / 2. + dmu ( imu - 1 )) bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - code_dt * (( - gam_mu / dmu ( imu - 1 ) - gam_mum *- 1 / dmu ( imu - 1 )) * dmu ( imu - 1 ) / ( dmu ( imu - 1 ) / 2. ) & - gam_mu *- 1 / dmu ( imu - 1 ) * dmu ( imu - 1 ) / 2. / dmu ( imu - 1 )) / mw ( iv , imu - 1 , iz , is ) / ( dmu ( imu - 1 ) / 2. + dmu ( imu - 1 )) end if ! no distinction here between density_conserving and default if ( density_conservation ) then aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - code_dt * ( vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ) * 1 / mw ( iv - 1 , imu - 1 , iz , is )) / ( 2 * dmu ( imu - 1 )) / ( 2 * dvpa ) aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) * 1 / mw ( iv - 1 , imu , iz , is )) / ( 2 * dmu ( imu - 1 )) / ( 2 * dvpa ) cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & + code_dt * ( vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ) * 1 / mw ( iv + 1 , imu - 1 , iz , is )) / ( 2 * dmu ( imu - 1 )) / ( 2 * dvpa ) cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & + code_dt * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) * 1 / mw ( iv + 1 , imu , iz , is )) / ( 2 * dmu ( imu - 1 )) / ( 2 * dvpa ) else aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) & + code_dt * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) * 1 / mw ( iv - 1 , imu , iz , is ) * ( dmu ( imu - 1 ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu - 1 ))) & / ( dmu ( imu - 1 ) + dmu ( imu - 1 )) / ( 2 * dvpa ) aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - code_dt * ( vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ) * 1 / mw ( iv - 1 , imu - 1 , iz , is ) * dmu ( imu - 1 ) / dmu ( imu - 1 )) & / ( dmu ( imu - 1 ) + dmu ( imu - 1 )) / ( 2 * dvpa ) cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) * 1 / mw ( iv + 1 , imu , iz , is ) * ( dmu ( imu - 1 ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu - 1 ))) & / ( dmu ( imu - 1 ) + dmu ( imu - 1 )) / ( 2 * dvpa ) cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & + code_dt * ( vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ) * 1 / mw ( iv + 1 , imu - 1 , iz , is ) * dmu ( imu - 1 ) / dmu ( imu - 1 )) & / ( dmu ( imu - 1 ) + dmu ( imu - 1 )) / ( 2 * dvpa ) end if end if else ! interior mu points if ( density_conservation ) then aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * 0.5 * ( eiediff * nupamv * vpam ** 2 + eidefl * deflknob * 2 * nuDmv * bmag ( ia , iz ) * mu ( imu )) * mwmv / dvpa ** 2 / mw ( iv - 1 , imu , iz , is ) & + vfac * code_dt * vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( 2 * dvpa ) cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * 0.5 * ( eiediff * nupapv * vpap ** 2 + eidefl * deflknob * 2 * nuDpv * bmag ( ia , iz ) * mu ( imu )) * mwpv / dvpa ** 2 / mw ( iv + 1 , imu , iz , is ) & - vfac * code_dt * vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( 2 * dvpa ) ! vpa operator, mixed (interior treatment): aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - vfac * code_dt * vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) / mw ( iv - 1 , imu - 1 , iz , is ) * dmu ( imu ) / dmu ( imu - 1 ) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( 2 * dvpa ) aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & + vfac * code_dt * vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) / mw ( iv - 1 , imu + 1 , iz , is ) * dmu ( imu - 1 ) / dmu ( imu ) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( 2 * dvpa ) cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & + vfac * code_dt * vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ) / mw ( iv + 1 , imu - 1 , iz , is ) * dmu ( imu ) / dmu ( imu - 1 ) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( 2 * dvpa ) cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - vfac * code_dt * vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ) / mw ( iv + 1 , imu + 1 , iz , is ) * dmu ( imu - 1 ) / dmu ( imu ) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( 2 * dvpa ) else aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * 0.5 * ( eiediff * nupamv * vpam ** 2 + eidefl * deflknob * 2 * nuDmv * bmag ( ia , iz ) * mu ( imu )) * mwmv / dvpa ** 2 / mw ( iv - 1 , imu , iz , is ) & + vfac * code_dt * vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( 2 * dvpa ) cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * 0.5 * ( eiediff * nupapv * vpap ** 2 + eidefl * deflknob * 2 * nuDpv * bmag ( ia , iz ) * mu ( imu )) * mwpv / dvpa ** 2 / mw ( iv + 1 , imu , iz , is ) & - vfac * code_dt * vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( 2 * dvpa ) ! vpa operator, mixed (interior treatment): aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - vfac * code_dt * vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) / mw ( iv - 1 , imu - 1 , iz , is ) * dmu ( imu ) / dmu ( imu - 1 ) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( 2 * dvpa ) aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & + vfac * code_dt * vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) / mw ( iv - 1 , imu + 1 , iz , is ) * dmu ( imu - 1 ) / dmu ( imu ) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( 2 * dvpa ) cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & + vfac * code_dt * vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ) / mw ( iv + 1 , imu - 1 , iz , is ) * dmu ( imu ) / dmu ( imu - 1 ) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( 2 * dvpa ) cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - vfac * code_dt * vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ) / mw ( iv + 1 , imu + 1 , iz , is ) * dmu ( imu - 1 ) / dmu ( imu ) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( 2 * dvpa ) end if bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & + code_dt * ( 0.5 * ( eiediff * nupapv * vpap ** 2 + 2 * eidefl * deflknob * nuDpv * bmag ( ia , iz ) * mu ( imu )) * mwpv & + 0.5 * ( eiediff * nupamv * vpam ** 2 + 2 * eidefl * deflknob * nuDmv * bmag ( ia , iz ) * mu ( imu )) * mwmv ) / dvpa ** 2 / mw ( iv , imu , iz , is ) ! mu operator if ( mu_operator ) then ! quantities at mu_{i+1/2} and mu_{i-1/2}: mup = 0.5 * ( mu ( imu ) + mu ( imu + 1 )) mum = 0.5 * ( mu ( imu ) + mu ( imu - 1 )) mwp = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mup ) mwm = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mum ) xp = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mup ) xm = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mum ) if (( is == 2 ) . and . ( isb == 1 ) . and . ( eimassr_approx )) then nuDp = eidefl * deflknob * spec ( is )% vnew ( isb ) / xp ** 3 nuDm = eidefl * deflknob * spec ( is )% vnew ( isb ) / xm ** 3 else nuDp = eidefl * deflknob * spec ( is )% vnew ( isb ) * ( erf ( xp / sqrt ( massr )) & - ( erf ( xp / sqrt ( massr )) - xp / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 / massr )) / ( 2 * xp ** 2 / massr )) / xp ** 3 nuDm = eidefl * deflknob * spec ( is )% vnew ( isb ) * ( erf ( xm / sqrt ( massr )) & - ( erf ( xm / sqrt ( massr )) - xm / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 / massr )) / ( 2 * xm ** 2 / massr )) / xm ** 3 end if nupap = spec ( is )% vnew ( isb ) * 2 * ( erf ( xp / sqrt ( massr )) - xp / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 / massr )) / ( 2 * xp ** 2 / massr ) / xp ** 3 nupam = spec ( is )% vnew ( isb ) * 2 * ( erf ( xm / sqrt ( massr )) - xm / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 / massr )) / ( 2 * xm ** 2 / massr ) / xm ** 3 gam_mu = 2 * ( eiediff * nupa ( iv , imu , iz , is , isb ) * mu ( imu ) ** 2 + eidefl * deflknob * nuD ( iv , imu , iz , is , isb ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mu ( imu )) * mw ( iv , imu , iz , is ) gam_mum = 2 * ( eiediff * nupam * mum ** 2 + eidefl * deflknob * nuDm * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mum ) * mwm gam_mup = 2 * ( eiediff * nupap * mup ** 2 + eidefl * deflknob * nuDp * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mup ) * mwp ! mu_operator (interior treatment): bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * (( gam_mu * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) - gam_mum / dmu ( imu - 1 )) * dmu ( imu ) / dmu ( imu - 1 ) & + ( - gam_mu * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) - gam_mup / dmu ( imu )) * dmu ( imu - 1 ) / dmu ( imu )) / mw ( iv , imu , iz , is ) * 2. / ( dmu ( imu - 1 ) + dmu ( imu )) bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - code_dt * (( gam_mu *- 1 * dmu ( imu ) / dmu ( imu - 1 ) / ( dmu ( imu - 1 ) + dmu ( imu )) - gam_mum *- 1 / dmu ( imu - 1 )) * dmu ( imu ) / dmu ( imu - 1 ) & - gam_mu *- 1 * dmu ( imu ) / dmu ( imu - 1 ) / ( dmu ( imu - 1 ) + dmu ( imu )) * dmu ( imu - 1 ) / dmu ( imu )) / mw ( iv , imu - 1 , iz , is ) * 2. / ( dmu ( imu - 1 ) + dmu ( imu )) bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - code_dt * ( gam_mu * dmu ( imu - 1 ) / dmu ( imu ) / ( dmu ( imu - 1 ) + dmu ( imu )) * dmu ( imu ) / dmu ( imu - 1 ) & + ( gam_mup / dmu ( imu ) - gam_mu * dmu ( imu - 1 ) / dmu ( imu ) / ( dmu ( imu - 1 ) + dmu ( imu ))) * dmu ( imu - 1 ) / dmu ( imu )) / mw ( iv , imu + 1 , iz , is ) * 2 / ( dmu ( imu - 1 ) + dmu ( imu )) ! mu operator, mixed (interior treatment): aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) & + code_dt * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) * 1 / mw ( iv - 1 , imu , iz , is ) & * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu ))) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( 2 * dvpa ) aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - code_dt * ( vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ) * 1 / mw ( iv - 1 , imu - 1 , iz , is ) & * dmu ( imu ) / dmu ( imu - 1 )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( 2 * dvpa ) aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & + code_dt * ( vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ) * 1 / mw ( iv - 1 , imu + 1 , iz , is ) & * dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( 2 * dvpa ) cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) * 1 / mw ( iv + 1 , imu , iz , is ) & * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu ))) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( 2 * dvpa ) cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & + code_dt * ( vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ) * 1 / mw ( iv + 1 , imu - 1 , iz , is ) & * dmu ( imu ) / dmu ( imu - 1 )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( 2 * dvpa ) cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - code_dt * ( vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ) * 1 / mw ( iv + 1 , imu + 1 , iz , is ) & * dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( 2 * dvpa ) end if end if end if end do end do end do end do if ( testpart . eqv . . false .) then aa_blcs = 0. cc_blcs = 0. bb_blcs = 0. do isb = 1 , nspec do imu = 1 , nmu do iv = 1 , nvpa do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc bb_blcs ( iv , imu , imu , ikxkyz , isb ) = 1. ! AVB: in beta end do end do end do end do end if ! construct full block matrix if (( exact_conservation_tp ) . or . ( density_conservation_tp )) then ! this is memory intensive, operating with blockmatrix is slow ! currently used for exact conservation scheme on non-uniform grids ! AVB: to do - replace this with band matrix operations if (. not . allocated ( blockmatrix )) allocate ( blockmatrix ( nvpa * nmu , nvpa * nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc , nspec )) if (. not . allocated ( blockmatrix_sum )) allocate ( blockmatrix_sum ( nvpa * nmu , nvpa * nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) blockmatrix = 0. do isb = 1 , nspec do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) do iv = 1 , nvpa ! diagonal blocks: blockmatrix ( nmu * ( iv - 1 ) + 1 : nmu * iv , nmu * ( iv - 1 ) + 1 : nmu * iv , ikxkyz , isb ) = bb_blcs ( iv , :, :, ikxkyz , isb ) if ( iv < nvpa ) then ! subdiagonal blocks: blockmatrix ( nmu * iv + 1 : nmu * ( iv + 1 ), nmu * ( iv - 1 ) + 1 : nmu * iv , ikxkyz , isb ) = aa_blcs ( iv + 1 , :, :, ikxkyz , isb ) ! superdiagonal blocks: blockmatrix ( nmu * ( iv - 1 ) + 1 : nmu * iv , nmu * iv + 1 : nmu * ( iv + 1 ), ikxkyz , isb ) = cc_blcs ( iv , :, :, ikxkyz , isb ) end if end do end do end do end if ! switch to band-storage for LAPACK banded solver routines: ! and sum the interspecies and intraspecies operators for each species ! a_ij is stored in aband(ku+1+i-j,j) for $\\max(1,j-ku) \\leq i \\leq \\min(m,j+kl)$ cdiffmat_band = 0. do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) ! loop through aa_blcs, bb_blcs, cc_blcs ! find corresponding index of blockmatrix at each location within blcs ! calculate index of cdiffmat_band do iv = 1 , nvpa ! bb_blcs do imu = 1 , nmu bm_rowind = ( iv - 1 ) * nmu + imu do imu2 = 1 , nmu bm_colind = ( iv - 1 ) * nmu + imu2 if (( max ( 1 , bm_colind - ( nmu + 1 )) <= bm_rowind ) . and . ( bm_rowind <= min ( nvpa * nmu , bm_colind + ( nmu + 1 )))) then cdiffmat_band ( nmu + 1 + nmu + 1 + 1 + bm_rowind - bm_colind , bm_colind , iky , ikx , iz , is ) = bb_blcs ( iv , imu , imu2 , ikxkyz , is ) end if end do end do ! cc_blcs if ( iv < nvpa ) then ! aa_blcs and cc_blcs contain only (nvpa-1) blocks, since they are off-diagonal do imu = 1 , nmu bm_rowind = ( iv - 1 ) * nmu + imu do imu2 = 1 , nmu bm_colind = nmu + ( iv - 1 ) * nmu + imu2 ! nvpa*nmu - nmu + imu2 if (( max ( 1 , bm_colind - ( nmu + 1 )) <= bm_rowind ) . and . ( bm_rowind <= min ( nvpa * nmu , bm_colind + ( nmu + 1 )))) then cdiffmat_band ( nmu + 1 + nmu + 1 + 1 + bm_rowind - bm_colind , bm_colind , iky , ikx , iz , is ) = cc_blcs ( iv , imu , imu2 , ikxkyz , is ) end if end do end do ! aa_blcs do imu = 1 , nmu bm_rowind = nmu + ( iv - 1 ) * nmu + imu do imu2 = 1 , nmu bm_colind = ( iv - 1 ) * nmu + imu2 if (( max ( 1 , bm_colind - ( nmu + 1 )) <= bm_rowind ) . and . ( bm_rowind <= min ( nvpa * nmu , bm_colind + ( nmu + 1 )))) then cdiffmat_band ( nmu + 1 + nmu + 1 + 1 + bm_rowind - bm_colind , bm_colind , iky , ikx , iz , is ) = aa_blcs ( 1 + iv , imu , imu2 , ikxkyz , is ) end if end do end do end if ! inter-species test particle contributions: do isb = 1 , nspec if ( isb == is ) cycle ! bb_blcs do imu = 1 , nmu bm_rowind = ( iv - 1 ) * nmu + imu do imu2 = 1 , nmu bm_colind = ( iv - 1 ) * nmu + imu2 if (( max ( 1 , bm_colind - ( nmu + 1 )) <= bm_rowind ) . and . ( bm_rowind <= min ( nvpa * nmu , bm_colind + ( nmu + 1 )))) then cdiffmat_band ( nmu + 1 + nmu + 1 + 1 + bm_rowind - bm_colind , bm_colind , iky , ikx , iz , is ) = & cdiffmat_band ( nmu + 1 + nmu + 1 + 1 + bm_rowind - bm_colind , bm_colind , iky , ikx , iz , is ) + bb_blcs ( iv , imu , imu2 , ikxkyz , isb ) end if end do end do ! cc_blcs if ( iv < nvpa ) then do imu = 1 , nmu bm_rowind = ( iv - 1 ) * nmu + imu do imu2 = 1 , nmu bm_colind = ( iv - 1 ) * nmu + nmu + imu2 if (( max ( 1 , bm_colind - ( nmu + 1 )) <= bm_rowind ) . and . ( bm_rowind <= min ( nvpa * nmu , bm_colind + ( nmu + 1 )))) then cdiffmat_band ( nmu + 1 + nmu + 1 + 1 + bm_rowind - bm_colind , bm_colind , iky , ikx , iz , is ) = & cdiffmat_band ( nmu + 1 + nmu + 1 + 1 + bm_rowind - bm_colind , bm_colind , iky , ikx , iz , is ) + cc_blcs ( iv , imu , imu2 , ikxkyz , isb ) end if end do end do ! aa_blcs do imu = 1 , nmu bm_rowind = ( iv - 1 ) * nmu + nmu + imu do imu2 = 1 , nmu bm_colind = ( iv - 1 ) * nmu + imu2 if (( max ( 1 , bm_colind - ( nmu + 1 )) <= bm_rowind ) . and . ( bm_rowind <= min ( nvpa * nmu , bm_colind + ( nmu + 1 )))) then cdiffmat_band ( nmu + 1 + nmu + 1 + 1 + bm_rowind - bm_colind , bm_colind , iky , ikx , iz , is ) = & cdiffmat_band ( nmu + 1 + nmu + 1 + 1 + bm_rowind - bm_colind , bm_colind , iky , ikx , iz , is ) + aa_blcs ( 1 + iv , imu , imu2 , ikxkyz , isb ) end if end do end do end if end do end do end do ! add the gyro-diffusive term to cdiffmat do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) do iv = 1 , nvpa do imu = 1 , nmu ! diagonal indices in blockmatrix ivv = nmu * ( iv - 1 ) + imu imm = ivv if (( max ( 1 , ivv - ( nmu + 1 )) <= imm ) . and . ( imm <= min ( nvpa * nmu , ivv + ( nmu + 1 )))) then ! intra-species: cdiffmat_band ( nmu + 1 + nmu + 1 + 1 + imm - ivv , ivv , iky , ikx , iz , is ) = cdiffmat_band ( nmu + 1 + nmu + 1 + 1 + imm - ivv , ivv , iky , ikx , iz , is ) & + code_dt * cfac * 0.5 * kperp2 ( iky , ikx , ia , iz ) * ( spec ( is )% smz / bmag ( ia , iz )) ** 2 * ( nupa ( iv , imu , iz , is , is ) * bmag ( ia , iz ) * mu ( imu ) & + deflknob * nuD ( iv , imu , iz , is , is ) * ( vpa ( iv ) ** 2 + bmag ( ia , iz ) * mu ( imu ))) ! inter-species: do isb = 1 , nspec if ( isb == is ) cycle if (( is == 2 ) . and . ( isb == 1 )) then eiediff = eiediffknob eidefl = eideflknob else eiediff = 1 eidefl = 1 end if cdiffmat_band ( nmu + 1 + nmu + 1 + 1 + imm - ivv , ivv , iky , ikx , iz , is ) = cdiffmat_band ( nmu + 1 + nmu + 1 + 1 + imm - ivv , ivv , iky , ikx , iz , is ) & + code_dt * cfac * 0.5 * kperp2 ( iky , ikx , ia , iz ) * ( spec ( is )% smz / bmag ( ia , iz )) ** 2 * ( eiediff * nupa ( iv , imu , iz , is , isb ) * bmag ( ia , iz ) * mu ( imu ) & + eidefl * deflknob * nuD ( iv , imu , iz , is , isb ) * ( vpa ( iv ) ** 2 + bmag ( ia , iz ) * mu ( imu ))) end do end if end do end do end do ! add 1 to the diagonal, since the matrix operator is 1 - C&#94;{ab}[h_a] do is = 1 , nspec do iv = 1 , nmu * nvpa do imu = 1 , nmu * nvpa if (( max ( 1 , iv - ( nmu + 1 )) <= imu ) . and . ( imu <= min ( nvpa * nmu , iv + ( nmu + 1 )))) then if ( iv == imu ) then cdiffmat_band ( nmu + 1 + nmu + 1 + 1 + imu - iv , iv , :, :, :, is ) = cdiffmat_band ( nmu + 1 + nmu + 1 + 1 + imu - iv , iv , :, :, :, is ) + 1. end if end if end do end do end do ! to write matrix in band-storage, for debugging !do ikxkyz = kxkyz_lo%llim_proc, kxkyz_lo%ulim_proc !    iky = iky_idx(kxkyz_lo,ikxkyz) !    ikx = ikx_idx(kxkyz_lo,ikxkyz) !    iz = iz_idx(kxkyz_lo,ikxkyz) !    is  = is_idx(kxkyz_lo,ikxkyz) !    if (iz/=0) cycle !    if (iky/=1) cycle !    if (is==2) then !        call open_output_file (tmpunit,'.cdiffmatband') !        do iv = 1, nvpa*nmu !          write (tmpunit,'(9es15.4e3)') cdiffmat_band(iv,:,iky,ikx,iz,is) !        end do !        write (tmpunit,*) !        call close_output_file (tmpunit) !    end if !end do ! AVB: LU factorise cdiffmat, using LAPACK's zgbtrf routine for banded matrices nc = nvpa * nmu nb = nmu + 1 lldab = 3 * ( nmu + 1 ) + 1 do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) call zgbtrf ( nc , nc , nb , nb , cdiffmat_band (:, :, iky , ikx , iz , is ), lldab , ipiv (:, iky , ikx , iz , is ), info ) end do end subroutine init_fp_diffmatrix elemental function associated_laguerre ( n , alpha , x ) integer , intent ( in ) :: n real , intent ( in ) :: x real , intent ( in ) :: alpha integer :: k real :: associated_laguerre , p , p1 , p2 p1 = dble ( 1.0 ) p2 = dble ( 1.0 ) + alpha - x if ( n == 0 ) then associated_laguerre = p1 return else if ( n == 1 ) then associated_laguerre = p2 return end if do k = 2 , n p = (( dble ( 2.0 ) * k - dble ( 1.0 ) + alpha - x ) * p2 - ( k - dble ( 1.0 ) + alpha ) * p1 ) / k p1 = p2 p2 = p end do associated_laguerre = p end function associated_laguerre elemental function associated_legendre ( l , m , x ) integer , intent ( in ) :: l , m double precision , intent ( in ) :: x integer :: k double precision :: associated_legendre , p , p1 , p2 , fac double precision :: pi pi = 3.14159265359 ! to start the recursion, use that P_l&#94;m = 0 for l < abs(m) ! and P_l&#94;l = (-1)&#94;l*(2l-1)!!(1-x&#94;2)&#94;(l/2) ! where (2l-1)!! = 2**l * Gamma(l+0.5) / sqrt(pi) p1 = 0. p2 = ( - 1 ) ** abs ( m ) * 2 ** abs ( m ) * gamma ( abs ( m ) + 0.5 ) / sqrt ( pi ) * ( 1. - x ** 2 ) ** ( abs ( m ) / 2. ) if ( abs ( m ) > l ) then associated_legendre = 0. return end if if ( l == 0 ) then associated_legendre = 1. return end if if ( l == m ) then associated_legendre = p2 return end if if ( l == - m ) then fac = ( - 1 ) ** abs ( m ) * gamma ( l - abs ( m ) + 1. ) / gamma ( l + abs ( m ) + 1. ) associated_legendre = p2 * fac return end if do k = abs ( m ) + 1 , l p = (( dble ( 2.0 ) * k - dble ( 1.0 )) * x * p2 - ( k - dble ( 1.0 ) + abs ( m )) * p1 ) / ( k - abs ( m )) p1 = p2 p2 = p end do if ( m < 0 ) then fac = ( - 1 ) ** abs ( m ) * gamma ( l - abs ( m ) + 1. ) / gamma ( l + abs ( m ) + 1. ) p = p * fac end if associated_legendre = p end function associated_legendre subroutine init_legendre use vpamu_grids , only : mu , nmu , vpa , nvpa use zgrid , only : nzgrid use stella_geometry , only : bmag use stella_layouts , only : iky_idx , ikx_idx , iz_idx , is_idx use file_utils , only : open_output_file , close_output_file implicit none integer :: iv , imu , iz , ia , mm , ll double precision :: xi allocate ( legendre_vpamu ( 0 : lmax , - lmax : lmax , nvpa , nmu , - nzgrid : nzgrid )) ia = 1 ! note lmin = 0, lmax = nsph-1 ! mmin = -lmax, mmax = lmax legendre_vpamu = 0. ia = 1 do iv = 1 , nvpa do imu = 1 , nmu do iz = - nzgrid , nzgrid do ll = 0 , lmax do mm = - lmax , lmax xi = dble ( vpa ( iv ) / sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mu ( imu ))) legendre_vpamu ( ll , mm , iv , imu , iz ) = associated_legendre ( ll , mm , xi ) end do end do end do end do end do end subroutine init_legendre subroutine init_bessel_fn use zgrid , only : nzgrid use vpamu_grids , only : nmu , vperp2 use stella_layouts , only : kxkyz_lo , iky_idx , ikx_idx , iz_idx , it_idx , is_idx use gyro_averages , only : aj0v use species , only : spec , nspec use stella_geometry , only : bmag use kt_grids , only : naky , nakx use dist_fn_arrays , only : kperp2 use file_utils , only : open_output_file , close_output_file implicit none integer :: ikxkyz , iky , ikx , iz , is , ia , mm , imu real :: arg , aj1fac , aj1exp , aj0exp allocate ( jm ( nmu , 0 : lmax , naky , nakx , - nzgrid : nzgrid , nspec )) allocate ( jm0 ( nmu , naky , nakx , - nzgrid : nzgrid , nspec )) jm = 0 ia = 1 aj1fac = 1.0 aj0exp = 1.0 aj1exp = 1.0 do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) jm0 (:, iky , ikx , iz , is ) = aj0v (:, ikxkyz ) ** aj0exp do mm = 0 , lmax if ( mm == 0 ) then jm (:, 0 , iky , ikx , iz , is ) = aj0v (:, ikxkyz ) ** aj0exp else if ( mm == 1 ) then !jm(:,1,iky,ikx,iz,is) = aj1fac*aj1v(:,ikxkyz)*spec(is)%smz_psi0*sqrt(vperp2(ia,iz,:)*kperp2(iky,ikx,ia,iz))/bmag(ia,iz) !mu*spec(is)%smz*sqrt(2*bmag(ia,iz)*kperp2(iky,ikx,ia,iz))/bmag(ia,iz) do imu = 1 , nmu arg = spec ( is )% smz_psi0 * sqrt ( vperp2 ( ia , iz , imu ) * kperp2 ( iky , ikx , ia , iz )) / bmag ( ia , iz ) jm ( imu , mm , iky , ikx , iz , is ) = bessel_jn ( mm , arg ) ** aj1exp * aj1fac end do else do imu = 1 , nmu arg = spec ( is )% smz_psi0 * sqrt ( vperp2 ( ia , iz , imu ) * kperp2 ( iky , ikx , ia , iz )) / bmag ( ia , iz ) !mu(imu)*spec(is)%smz*sqrt(2*bmag(ia,iz)*kperp2(iky,ikx,ia,iz))/bmag(ia,iz) jm ( imu , mm , iky , ikx , iz , is ) = bessel_jn ( mm , arg ) end do end if end do end do if ( cfac2 == 0. ) then ! disable gyro-diffusive effects in the field particle operator jm (:, 0 , :, :, :, :) = 1. if ( lmax > 0 ) then do mm = 1 , lmax jm (:, mm , :, :, :, :) = 0. end do end if end if end subroutine init_bessel_fn subroutine init_vgrid ! v grid used for writing various coll freqs to file for debugging use vpamu_grids , only : mu , nmu , vpa , vperp_max , vpa_max use stella_geometry , only : bmag integer :: ia , iv real :: delv , vmax , vmin allocate ( wgts_v ( nvel_local )); wgts_v = 0.0 allocate ( vel ( nvel_local )); vel = 0.0 ia = 1 ! calculation of Delta_j[x&#94;l L_j(x&#94;2) exp(-x&#94;2)] requires integrals over v, set these up below: ! velocity grid, equally spaced, from 0 to vmax: vmax = sqrt ( maxval ( vpa ) ** 2 + 2 * maxval ( bmag ( ia , :)) * maxval ( mu )) !sqrt(vperp_max**2 + vpa_max**2) !vmin = 1e-9 delv = vmax / nvel_local ! (vmax-vmin)/(nvel_local-1) vmin = sqrt ( minval ( abs ( vpa )) ** 2 + 2 * minval ( bmag ) * minval ( mu )) !delv !1e-9 do iv = 1 , nvel_local vel ( iv ) = vmin + ( iv - 1 ) * delv end do ! Trapezoidal rule: wgts_v = 0.5 * delv ! Composite Simpson's at interior nodes, average of Simpson's 3/8 and Composite at boundaries: ! Lower boundary, Simpson's 3/8: !del = 0.375*delv !wgts_v(1) = del !wgts_v(2:3) = 3.*del !wgts_v(4) = del ! Interior points, Composite: !nv_seg = (nvel_local-4)/2 !del = delv/3. !do iseg = 1, nv_seg !   idx = 2*(iseg-1) + 4 ! for iseg = 1, idx = 4; for iseg = nv_seg, idx = nv-2. !   wgts_v(idx) = wgts_v(idx) + del !   wgts_v(idx+1) = wgts_v(idx+1) + 4.*del !   wgts_v(idx+2) = wgts_v(idx+2) + del !end do ! Upper boundary, Simpson's 3/8: !del = 0.375*delv !wgts_v(nvel_local-3) = wgts_v(nvel_local-3) + del !wgts_v(nvel_local-2:nvel_local-1) = wgts_v(nvel_local-2:nvel_local-1) + 3.*del !wgts_v(nvel_local) = wgts_v(nvel_local) + del ! Interior points, Composite: !nv_seg = (nvel_local-4)/2 !del = delv/3. !do iseg = 1, nv_seg !   idx = 2*(iseg-1)+1 ! for iseg = 1, idx = 1; for iseg = nv_seg, idx = nv-5. !   wgts_v(idx) = wgts_v(idx) + del !   wgts_v(idx+1) = wgts_v(idx+1) + 4.*del !   wgts_v(idx+2) = wgts_v(idx+2) + del !end do ! AVB: the points idx = 4 and idx = nv-3 are counted three times ! divide by 2 to account for double-counting !wgts_v = 0.5*wgts_v end subroutine init_vgrid recursive subroutine gamlow ( a , x , gl ) ! recursive calculation of lower incomplete gamma function for half-integer a > 0 use constants , only : pi use spfunc , only : erf => erf_ext implicit none real , intent ( in ) :: a real , intent ( in ) :: x real , intent ( out ) :: gl real :: glm1 if ( a == 0.5 ) then gl = sqrt ( pi ) * erf ( sqrt ( x )) else call gamlow ( a - 1. , x , glm1 ) gl = ( a - 1. ) * glm1 - x ** ( a - 1. ) * exp ( - x ) end if end subroutine gamlow recursive subroutine gamup ( a , x , gu ) ! recursive calculation of the upper incomplete gamma function for integer a > 0 use constants , only : pi use spfunc , only : erf => erf_ext implicit none real , intent ( in ) :: a real , intent ( in ) :: x real , intent ( out ) :: gu real :: gum1 if ( a == 1.0 ) then gu = exp ( - x ) else call gamup ( a - 1. , x , gum1 ) gu = ( a - 1. ) * gum1 + x ** ( a - 1. ) * exp ( - x ) end if end subroutine gamup subroutine calc_delta0 ( xa , jj , ll , isa , isb , delt0 ) ! calculate Delta0&#94;{j,l,ab}(xa) (on xa grid) ! j and l denote the degree and index of the associated laguerre polynomial use species , only : nspec , spec use constants , only : pi implicit none integer , intent ( in ) :: jj , ll , isa , isb real , intent ( in ) :: xa real , intent ( out ) :: delt0 real :: massr , ckjl , xb , gaml1 , gaml2 , gamu1 , gamu2 integer :: kk massr = spec ( isa )% mass / spec ( isb )% mass xb = xa / sqrt ( massr ) delt0 = 0 do kk = 0 , jj ckjl = ( - 1 ) ** kk * gamma ( jj + ll + 0.5 + 1 ) / ( gamma ( jj - kk + 1. ) * gamma ( ll + kk + 0.5 + 1 ) * gamma ( kk + 1. )) call gamlow ( 1.5 + ll + kk , xb ** 2 , gaml1 ) call gamlow ( 2.5 + ll + kk , xb ** 2 , gaml2 ) call gamup ( 1. + kk , xb ** 2 , gamu1 ) call gamup ( 2. + kk , xb ** 2 , gamu2 ) delt0 = delt0 + ckjl * (( 2 * ll + 1. ) * xb ** ( ll + 2. * kk ) * exp ( - xb ** 2 ) & - xb * ( 1. - massr ) * ( - ( ll + 1. ) / xb ** ( ll + 2. ) * gaml1 + ll * xb ** ( ll - 1. ) * gamu1 ) & - ( 1. / xb ** ( ll + 1. ) * gaml1 + xb ** ll * gamu1 ) & + massr * xb ** 2 * (( ll + 1. ) * ( ll + 2. ) / ( 2 * ll + 3. ) * ( xb ** ( - ll - 3. ) * gaml2 + xb ** ll * gamu1 ) & - ll * ( ll - 1. ) / ( 2 * ll - 1. ) * ( xb ** ( - ll - 1. ) * gaml1 + xb ** ( ll - 2. ) * gamu2 ))) end do delt0 = delt0 * 4 * pi / ( pi ** 1.5 ) * exp ( - xa ** 2 ) * massr / ( 2 * ll + 1. ) end subroutine calc_delta0 recursive subroutine calc_deltaj_vmu ( jj , nn , ll , isa , isb , deltj ) ! calculate Delta_j&#94;{ab,l}[x_b&#94;l L_n&#94;{l+0.5}(x_b&#94;2) exp(-x_b&#94;2)](xa) (on x_a grid) ! these are normalised, and calculated without the collision frequency ! in contrast to Hirshman & Sigmar 1976 use species , only : nspec use vpamu_grids , only : mu , nmu , vpa , nvpa use zgrid , only : nzgrid use stella_geometry , only : bmag implicit none integer , intent ( in ) :: jj , nn , ll , isa , isb real , dimension ( nvpa , nmu , - nzgrid : nzgrid ), intent ( out ) :: deltj real , dimension ( nvpa , nmu , - nzgrid : nzgrid ) :: deltajm1_n , deltajm1_j integer :: iv , imu , iz , ia real :: v real , dimension ( - nzgrid : nzgrid ) :: psijm1_n ia = 1 if ( jj == 0 ) then do iv = 1 , nvpa do imu = 1 , nmu do iz = - nzgrid , nzgrid v = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mu ( imu )) call calc_delta0 ( v , nn , ll , isa , isb , deltj ( iv , imu , iz )) end do end do end do else ! get Delta_[j-1]&#94;{ab,l}[x_b&#94;l L_n&#94;{l+0.5}(x_b&#94;2) exp(-x_b&#94;2)](xa) call calc_deltaj_vmu ( jj - 1 , nn , ll , isa , isb , deltajm1_n ) ! get Delta_[j-1]&#94;{ab,l}[x_b&#94;l L_[j-1]&#94;{l+0.5}(x_b&#94;2) exp(-x_b&#94;2)](xa) call calc_deltaj_vmu ( jj - 1 , jj - 1 , ll , isa , isb , deltajm1_j ) ! get psi_[j-1]&#94;{ab,l}[x_b&#94;l L_n&#94;{l+0.5}(x_b&#94;2) exp(-x_b&#94;2)](xa) call calc_psi_vmu ( jj - 1 , nn , ll , isa , isb , psijm1_n ) deltj = deltajm1_n - spread ( spread ( psijm1_n , 1 , nvpa ), 2 , nmu ) * deltajm1_j end if end subroutine calc_deltaj_vmu subroutine vLj_vmu ( jj , ll , vLj ) use species , only : nspec use vpamu_grids , only : mu , nmu , vpa , nvpa use zgrid , only : nzgrid use stella_geometry , only : bmag implicit none integer , intent ( in ) :: jj , ll real , dimension ( nvpa , nmu , - nzgrid : nzgrid ), intent ( out ) :: vLj integer :: iv , imu , iz , ia real :: v ia = 1 do iv = 1 , nvpa do imu = 1 , nmu do iz = - nzgrid , nzgrid v = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mu ( imu )) vLj ( iv , imu , iz ) = v ** ll * associated_laguerre ( jj , ll + 1. / 2. , v ** 2 ) end do end do end do end subroutine vLj_vmu recursive subroutine calc_psi_vmu ( jj , nn , ll , isa , isb , psij ) ! calculate psi_j&#94;{ab,l}[x_b&#94;l L_n&#94;{l+0.5}(x_b&#94;2) exp(-x_b&#94;2)] ! have defined deltaj without collision frequency ! and normalised everthing to species thermal speeds use species , only : nspec , spec use vpamu_grids , only : nmu , nvpa , integrate_vmu use zgrid , only : nzgrid implicit none integer , intent ( in ) :: jj , nn , ll , isa , isb real , dimension ( nvpa , nmu , - nzgrid : nzgrid ) :: deltj_j , vLj , vLn !deltj_n real , dimension ( - nzgrid : nzgrid ), intent ( out ) :: psij integer :: iz real , dimension ( - nzgrid : nzgrid ) :: num , den if ( jj == 0 ) then if (( ll == 0 ) . and . ( nn == 0 )) then ! never used num = 1 den = 1 else ! get delta_j&#94;{ba}(x_a&#94;l L_j&#94;{l+0.5}(x_a&#94;2) exp(-x_a&#94;2)), on x_b grid call calc_deltaj_vmu ( jj , jj , ll , isb , isa , deltj_j ) ! multiply by x_b&#94;l L_n(x_b&#94;2) and integrate call vLj_vmu ( nn , ll , vLn ) do iz = - nzgrid , nzgrid call integrate_vmu ( vLn (:, :, iz ) * deltj_j (:, :, iz ), iz , num ( iz )) ! numerator in psijl end do ! if mb / ma < 1 use self-adjointness to avoid resolution problems if ( spec ( isb )% mass / spec ( isa )% mass < 1. ) then call calc_deltaj_vmu ( jj , jj , ll , isa , isb , deltj_j ) ! need to account for mass ratio normalisation ! and collision frequency ! \\int x_a&#94;l L_j&#94;{l+1/2}(x_a&#94;2) \\Delta_j'&#94;{ab}[\\tilde{f}_b/F0b * F0b] x_a&#94;2 dx_a !   = ma&#94;0.5/mb&#94;0.5 * ma&#94;3/mb&#94;3 \\int f_b/F0b \\Delta_j&#94;{ba}'[x_a&#94;l L_j&#94;{l+1/2}(x_a&#94;2) \\tilde{F0a}] x_b&#94;2 dx_b call vLj_vmu ( jj , ll , vLj ) do iz = - nzgrid , nzgrid call integrate_vmu ( spec ( isb )% mass ** 3.5 / spec ( isa )% mass ** 3.5 * vLj (:, :, iz ) * deltj_j (:, :, iz ), iz , den ( iz )) ! denominator in psijl end do else call vLj_vmu ( jj , ll , vLj ) do iz = - nzgrid , nzgrid call integrate_vmu ( vLj (:, :, iz ) * deltj_j (:, :, iz ), iz , den ( iz )) ! denominator in psijl end do end if end if else ! get delta_j&#94;{ba}(x_a&#94;l L_j&#94;{l+0.5}(x_a&#94;2) exp(-x_a&#94;2)), on x_b grid call calc_deltaj_vmu ( jj , jj , ll , isb , isa , deltj_j ) ! multiply by x_b&#94;l L_n(x_b&#94;2) and integrate call vLj_vmu ( nn , ll , vLn ) do iz = - nzgrid , nzgrid call integrate_vmu ( vLn (:, :, iz ) * deltj_j (:, :, iz ), iz , num ( iz )) ! numerator in psijl end do ! if mb / ma < 1 use self-adjointness to avoid resolution problems if ( spec ( isb )% mass / spec ( isa )% mass < 1. ) then call calc_deltaj_vmu ( jj , jj , ll , isa , isb , deltj_j ) ! need to account for mass ratio normalisation ! and collision frequency ! \\int x_a&#94;l L_j&#94;{l+1/2}(x_a&#94;2) \\Delta_j'&#94;{ab}[\\tilde{f}_b/F0b * F0b] x_a&#94;2 dx_a !   = ma&#94;0.5/mb&#94;0.5 * ma&#94;3/mb&#94;3 \\int f_b/F0b \\Delta_j&#94;{ba}'[x_a&#94;l L_j&#94;{l+1/2}(x_a&#94;2) \\tilde{F0a}] x_b&#94;2 dx_b call vLj_vmu ( jj , ll , vLj ) do iz = - nzgrid , nzgrid call integrate_vmu ( spec ( isb )% mass ** 3.5 / spec ( isa )% mass ** 3.5 * vLj (:, :, iz ) * deltj_j (:, :, iz ), iz , den ( iz )) ! denominator in psijl end do else call vLj_vmu ( jj , ll , vLj ) do iz = - nzgrid , nzgrid call integrate_vmu ( vLj (:, :, iz ) * deltj_j (:, :, iz ), iz , den ( iz )) ! denominator in psijl end do end if end if psij = num / den end subroutine calc_psi_vmu subroutine init_deltaj_vmu use species , only : nspec , spec use zgrid , only : nzgrid use stella_geometry , only : bmag use vpamu_grids , only : mu , nmu , vpa , nvpa , vperp_max , vpa_max , integrate_vmu , set_vpa_weights use file_utils , only : open_output_file , close_output_file use constants , only : pi use stella_layouts , only : kxkyz_lo , iky_idx , ikx_idx , iz_idx , is_idx , it_idx use stella_time , only : code_dt use kt_grids , only : naky implicit none real , dimension ( 0 : lmax , 0 : jmax , nvpa , nmu , 1 , - nzgrid : nzgrid ) :: vlaguerre_vmu integer :: ll , iv , jj , ia , imu , iz , is , isa , isb , ix , ikx , iky , ikxkyz real , dimension ( - nzgrid : nzgrid ) :: deltajint , deltajint_tp real , dimension ( nvpa * nmu , - nzgrid : nzgrid ) :: vpaF0vec , v2F0vec real , dimension ( nvpa * nmu , nvpa * nmu ) :: ident logical :: conservative_wgts ia = 1 allocate ( deltaj ( 0 : lmax , 0 : jmax , nspec , nspec , nvpa , nmu , ia , - nzgrid : nzgrid )) allocate ( deltaj_tp ( 0 : lmax , 0 : jmax , nspec , nspec , nvpa , nmu , ia , - nzgrid : nzgrid )) allocate ( psijnorm ( 0 : lmax , 0 : jmax , nspec , nspec , - nzgrid : nzgrid )) allocate ( mwnorm ( - nzgrid : nzgrid )) allocate ( modmwnorm ( - nzgrid : nzgrid )) if ( density_conservation ) then conservative_wgts = . true . call set_vpa_weights ( conservative_wgts ) else if ( exact_conservation_tp ) then conservative_wgts = . false . call set_vpa_weights ( conservative_wgts ) else conservative_wgts = . false . call set_vpa_weights ( conservative_wgts ) end if ! AVB: to do - option for cons_wgts when exact_conservation is true ! get Delta_j&#94;{l,ab}[x_b&#94;l L_j&#94;{l+0.5}(x_b&#94;2)F_{0b}](x_a) ! and Delta_j&#94;{l,ba}[x_a&#94;l L_j&#94;{l+0.5}(x_a&#94;2)F_{0a}](x_b) deltaj = 0 ! construct an identity matrix required below ident = 0 forall ( iv = 1 : nvpa * nmu ) ident ( iv , iv ) = 1. do isa = 1 , nspec do isb = 1 , nspec do ll = 0 , lmax do jj = 0 , jmax call calc_deltaj_vmu ( jj , jj , ll , isa , isb , deltaj ( ll , jj , isa , isb , :, :, ia , :)) call vLj_vmu ( jj , ll , vlaguerre_vmu ( ll , jj , :, :, ia , :)) if ( spitzer_problem ) then if (( exact_conservation ) . and . ( ll == 1 ) . and . ( jj == 0 ) & . and . . not . (( isa == 1 ) . and . ( isb == 1 )) & . and . . not . (( isa == 1 ) . and . ( isb == 2 )) & ) then ! to ensure conservation of momentum to machine precision !call open_output_file (tmpunit,'.deltaj_l1default') !do iv = 1, nvpa !    write (tmpunit,'(32es15.4e3)') ( deltaj(ll, jj, isa, isb, iv, imu, ia, 0), imu=1, nmu ) ! at z = 0 ! electron-ion !end do !write (tmpunit,*) !call close_output_file (tmpunit) ! calculate delta_{j=0,l=1}&#94;{ab} using the differential test particle operator C&#94;{ab} acting on m_a v_\\parallel F0a do iv = 1 , nvpa do imu = 1 , nmu do iz = - nzgrid , nzgrid vpaF0vec ( nmu * ( iv - 1 ) + imu , iz ) = vpa ( iv ) * mw ( iv , imu , iz , isa ) end do end do end do do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) if ( is /= isa ) cycle vpaF0vec (:, iz ) = matmul ( blockmatrix (:, :, ikxkyz , isb ) / code_dt / spec ( is )% vnew ( isb ), ( spec ( isa )% mass / spec ( isb )% mass ) ** 2 * vpaF0vec (:, iz )) end do do ix = 1 , nvpa deltaj_tp ( ll , jj , isa , isb , ix , :, ia , :) = vpaF0vec ( nmu * ( ix - 1 ) + 1 : nmu * ( ix - 1 ) + nmu , :) end do deltaj_tp ( ll , jj , isa , isb , :, :, ia , :) = deltaj_tp ( ll , jj , isa , isb , :, :, ia , :) * velvpamu / spread ( spread ( vpa , 2 , nmu ), 3 , 2 * nzgrid + 1 ) !call open_output_file (tmpunit,'.deltaj_l1modified') !do iv = 1, nvpa !    write (tmpunit,'(32es15.4e3)') ( deltaj_tp(ll, jj, isa, isb, iv, imu, ia, 0), imu=1, nmu ) ! at z = 0 !end do !write (tmpunit,*) !call close_output_file (tmpunit) end if else if (( exact_conservation ) . and . ( ll == 1 ) . and . ( jj == 0 )) then if ( spec ( isa )% vnew ( isb ) == 0 ) cycle !if ((isa==1).and.(isb==2)) then !   call open_output_file (tmpunit,'.deltaj_l1default_ie') !   do iv = 1, nvpa !       write (tmpunit,'(32es15.4e3)') ( deltaj(ll, jj, isa, isb, iv, imu, ia, 0), imu=1, nmu ) !   end do !   write (tmpunit,*) !   call close_output_file (tmpunit) !end if ! calculate delta_{j=0,l=1}&#94;{ab} using the differential test particle operator C&#94;{ab} acting on m_a v_\\parallel F0a do iv = 1 , nvpa do imu = 1 , nmu do iz = - nzgrid , nzgrid vpaF0vec ( nmu * ( iv - 1 ) + imu , iz ) = vpa ( iv ) * mw ( iv , imu , iz , isa ) end do end do end do do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) if ( iky /= naky ) cycle if ( is /= isa ) cycle vpaF0vec (:, iz ) = matmul ( blockmatrix (:, :, ikxkyz , isb ) / code_dt / spec ( is )% vnew ( isb ), ( spec ( isa )% mass / spec ( isb )% mass ) ** 2 * vpaF0vec (:, iz )) end do do ix = 1 , nvpa deltaj_tp ( ll , jj , isa , isb , ix , :, ia , :) = vpaF0vec ( nmu * ( ix - 1 ) + 1 : nmu * ( ix - 1 ) + nmu , :) end do deltaj_tp ( ll , jj , isa , isb , :, :, ia , :) = deltaj_tp ( ll , jj , isa , isb , :, :, ia , :) * velvpamu / spread ( spread ( vpa , 2 , nmu ), 3 , 2 * nzgrid + 1 ) !if ((isa==1).and.(isb==2)) then !call open_output_file (tmpunit,'.deltaj_l1modified_ie') !   do iv = 1, nvpa !       write (tmpunit,'(32es15.4e3)') ( deltaj_tp(ll, jj, isa, isb, iv, imu, ia, 0), imu=1, nmu ) ! at z = 0 !  end do !  write (tmpunit,*) !  call close_output_file (tmpunit) !end if end if end if if ( spitzer_problem ) then if (( exact_conservation ) . and . ( ll == 0 ) . and . ( jj == 1 ) & . and . . not . (( isa == 1 ) . and . ( isb == 1 )) & . and . . not . (( isa == 1 ) . and . ( isb == 2 )) & ) then ! energy conservation to machine precision !call open_output_file (tmpunit,'.deltaj_j1default') !do iv = 1, nvpa !    write (tmpunit,'(32es15.4e3)') ( deltaj(ll, jj, isa, isb, iv, imu, ia, 0), imu=1, nmu ) ! at z = 0 ! electron-ion !end do !write (tmpunit,*) !call close_output_file (tmpunit) ! calculate delta_{j=1,l=0}&#94;{ab} using the differential test particle operator C&#94;{ab} acting on m_a v&#94;2 F0a do iv = 1 , nvpa do imu = 1 , nmu do iz = - nzgrid , nzgrid v2F0vec ( nmu * ( iv - 1 ) + imu , iz ) = ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mu ( imu )) * mw ( iv , imu , iz , isa ) end do end do end do do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) if ( is /= isa ) cycle v2F0vec (:, iz ) = matmul ( blockmatrix (:, :, ikxkyz , isb ) / code_dt / spec ( is )% vnew ( isb ), - ( spec ( isa )% mass / spec ( isb )% mass ) ** 1.5 * v2F0vec (:, iz )) end do do ix = 1 , nvpa deltaj_tp ( ll , jj , isa , isb , ix , :, ia , :) = v2F0vec ( nmu * ( ix - 1 ) + 1 : nmu * ( ix - 1 ) + nmu , :) end do !call open_output_file (tmpunit,'.deltaj_j1modified') !do iv = 1, nvpa !    write (tmpunit,'(32es15.4e3)') ( deltaj_tp(ll, jj, isa, isb, iv, imu, ia, 0), imu=1, nmu ) ! at z = 0 !end do !write (tmpunit,*) !call close_output_file (tmpunit) end if else if (( exact_conservation ) . and . ( ll == 0 ) . and . ( jj == 1 )) then if ( spec ( isa )% vnew ( isb ) == 0 ) cycle !if ((isa==1).and.(isb==2)) then !    call open_output_file (tmpunit,'.deltaj_j1default_ie') !    do iv = 1, nvpa !        write (tmpunit,*) ( deltaj(ll, jj, isa, isb, iv, imu, ia, 0), imu=1, nmu ) ! at z = 0 ! electron-ion !    end do !    write (tmpunit,*) !    call close_output_file (tmpunit) !end if ! calculate delta_{j=1,l=0}&#94;{ab} using the differential test particle operator C&#94;{ab} acting on m_a v_\\parallel&#94;2 F0a do iv = 1 , nvpa do imu = 1 , nmu do iz = - nzgrid , nzgrid v2F0vec ( nmu * ( iv - 1 ) + imu , iz ) = ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mu ( imu )) * mw ( iv , imu , iz , isa ) end do end do end do do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) if ( is /= isa ) cycle if ( iky /= naky ) cycle v2F0vec (:, iz ) = matmul ( blockmatrix (:, :, ikxkyz , isb ) / code_dt / spec ( is )% vnew ( isb ), - ( spec ( isa )% mass / spec ( isb )% mass ) ** 1.5 * v2F0vec (:, iz )) end do do ix = 1 , nvpa deltaj_tp ( ll , jj , isa , isb , ix , :, ia , :) = v2F0vec ( nmu * ( ix - 1 ) + 1 : nmu * ( ix - 1 ) + nmu , :) end do !if ((isa==1).and.(isb==2)) then !    call open_output_file (tmpunit,'.deltaj_j1modified_ie') !    do iv = 1, nvpa !        write (tmpunit,*) ( deltaj_tp(ll, jj, isa, isb, iv, imu, ia, 0), imu=1, nmu ) ! at z = 0 !    end do !    write (tmpunit,*) !    call close_output_file (tmpunit) !end if end if end if !conservative_wgts = .false. !call set_vpa_weights (conservative_wgts) ! required integrals to ensure density conservation in field particle operator: do iz = - nzgrid , nzgrid call integrate_vmu ( mw (:, :, iz , isa ), iz , mwnorm ( iz )) end do do iz = - nzgrid , nzgrid call integrate_vmu ( modmw (:, :, iz , isa ), iz , modmwnorm ( iz )) end do ! to ensure number conservation to machine precision, \\Delta_{j=1} -> \\Delta_{j=1} - F0/\\int F0 dv * \\int \\Delta_{j=1} dv ! AVB: to do - need to generalise this to higher-order terms in the field particle operator if (( density_conservation_field ) . and . ( ll == 0 ) . and . ( jj == 1 )) then do iz = - nzgrid , nzgrid call integrate_vmu ( deltaj ( ll , jj , isa , isb , :, :, ia , iz ), iz , deltajint ( iz )) end do do iz = - nzgrid , nzgrid call integrate_vmu ( deltaj_tp ( ll , jj , isa , isb , :, :, ia , iz ), iz , deltajint_tp ( iz )) end do ! check accuracy of deltaj: !call open_output_file (tmpunit,'.deltaj_check') !do iv = 1, nvpa !    write (tmpunit,'(32es15.4e3)') ( deltaj(ll, jj, isa, isb, iv, imu, ia, 0), imu=1, nmu ) ! at z = 0 !end do !write (tmpunit,*) !call close_output_file (tmpunit) deltaj ( ll , jj , isa , isb , :, :, ia , :) = deltaj ( ll , jj , isa , isb , :, :, ia , :) & - mw (:, :, :, isa ) / spread ( spread ( mwnorm , 1 , nvpa ), 2 , nmu ) * spread ( spread ( deltajint , 1 , nvpa ), 2 , nmu ) deltaj_tp ( ll , jj , isa , isb , :, :, ia , :) = deltaj_tp ( ll , jj , isa , isb , :, :, ia , :) & - mw (:, :, :, isa ) / spread ( spread ( mwnorm , 1 , nvpa ), 2 , nmu ) * spread ( spread ( deltajint_tp , 1 , nvpa ), 2 , nmu ) !all open_output_file (tmpunit,'.deltaj_check_mod') !do iv = 1, nvpa !    write (tmpunit,'(32es15.4e3)') ( deltaj(ll, jj, isa, isb, iv, imu, ia, 0), imu=1, nmu ) ! at z = 0 !end do !write (tmpunit,*) !call close_output_file (tmpunit) ! check density conservation to machine precision !do iz = -nzgrid, nzgrid !    call integrate_vmu(deltaj(ll, jj, isa, isb, :, :, ia, iz), iz, deltajint(iz)) !end do end if end do end do end do end do ! get normalisations for psijls do isa = 1 , nspec do isb = 1 , nspec do ll = 0 , lmax do iz = - nzgrid , nzgrid do jj = 0 , jmax if (( ll == 0 ) . and . ( jj == 0 )) then psijnorm ( ll , jj , isa , isb , iz ) = 1 ! never used else ! note self-adjointness of deltaj after normalisation and without coll freqs (\\Delta_j') is ! \\int x_a&#94;l L_j&#94;{l+1/2}(x_a&#94;2) \\Delta_j'&#94;{ab}[\\tilde{f}_b/F0b * F0b] x_a&#94;2 dx_a ! = ma&#94;0.5/mb&#94;0.5 * ma&#94;3/mb&#94;3 \\int f_b/F0b \\Delta_j&#94;{ba}'[x_a&#94;l L_j&#94;{l+1/2}(x_a&#94;2) \\tilde{F0a}] x_b&#94;2 dx_b if (( exact_conservation ) . and . ( ll == 1 ) . and . ( jj == 0 )) then ! momentum conservation term for uniform mu grid call integrate_vmu ( 3 * legendre_vpamu ( ll , 0 , :, :, iz ) ** 2 * vlaguerre_vmu ( ll , jj , :, :, ia , iz ) * deltaj ( ll , jj , isa , isb , :, :, ia , iz ) & * ( spec ( isa )% mass / spec ( isb )% mass ) ** ( - 3 ) * ( spec ( isa )% mass / spec ( isb )% mass ) ** ( - 0.5 ), iz , psijnorm ( ll , jj , isa , isb , iz )) else if (( exact_conservation ) . and . ( ll == 0 ) . and . ( jj == 1 )) then ! energy conservation term for uniform mu grid call integrate_vmu ( legendre_vpamu ( ll , 0 , :, :, iz ) ** 2 * vlaguerre_vmu ( ll , jj , :, :, ia , iz ) * deltaj ( ll , jj , isa , isb , :, :, ia , iz ) & * ( spec ( isa )% mass / spec ( isb )% mass ) ** ( - 3 ) * ( spec ( isa )% mass / spec ( isb )% mass ) ** ( - 0.5 ), iz , psijnorm ( ll , jj , isa , isb , iz )) else if (( exact_conservation_tp ) . and . ( ll == 0 ) . and . ( jj == 1 )) then ! energy conservation term for non-uniform mu grid call integrate_vmu ( legendre_vpamu ( ll , 0 , :, :, iz ) ** 2 * vlaguerre_vmu ( ll , jj , :, :, ia , iz ) * deltaj ( ll , jj , isa , isb , :, :, ia , iz ) & * ( spec ( isa )% mass / spec ( isb )% mass ) ** ( - 3 ) * ( spec ( isa )% mass / spec ( isb )% mass ) ** ( - 0.5 ), iz , psijnorm ( ll , jj , isa , isb , iz )) else if (( exact_conservation_tp ) . and . ( ll == 1 ) . and . ( jj == 0 )) then ! momentum conservation term for non-uniform mu grid call integrate_vmu ( 3 * legendre_vpamu ( ll , 0 , :, :, iz ) ** 2 * vlaguerre_vmu ( ll , jj , :, :, ia , iz ) * deltaj ( ll , jj , isa , isb , :, :, ia , iz ) & * ( spec ( isa )% mass / spec ( isb )% mass ) ** ( - 3 ) * ( spec ( isa )% mass / spec ( isb )% mass ) ** ( - 0.5 ), iz , psijnorm ( ll , jj , isa , isb , iz )) else if (. not . (( exact_conservation ) . or . ( exact_conservation_tp )) . and . ( ll == 0 ) . and . ( jj == 1 )) then ! non-exact conservation of energy if ( spec ( isa )% mass / spec ( isb )% mass < 1. ) then ! use self-adjointness to avoid resolution problems call integrate_vmu (( - velvpamu (:, :, iz ) ** 2 ) * deltaj ( ll , jj , isb , isa , :, :, ia , iz ), iz , psijnorm ( ll , jj , isa , isb , iz )) else call integrate_vmu (( - velvpamu (:, :, iz ) ** 2 ) * deltaj ( ll , jj , isa , isb , :, :, ia , iz ) * ( spec ( isa )% mass / spec ( isb )% mass ) ** ( - 3 ) & * ( spec ( isa )% mass / spec ( isb )% mass ) ** ( - 0.5 ), iz , psijnorm ( ll , jj , isa , isb , iz )) end if else ! non-exact conservation of momentum, and higher-order terms if ( spec ( isa )% mass / spec ( isb )% mass < 1. ) then ! use self-adjointness to avoid resolution problems call integrate_vmu ( vlaguerre_vmu ( ll , jj , :, :, ia , iz ) * deltaj ( ll , jj , isb , isa , :, :, ia , iz ), iz , psijnorm ( ll , jj , isa , isb , iz )) else call integrate_vmu ( vlaguerre_vmu ( ll , jj , :, :, ia , iz ) * deltaj ( ll , jj , isa , isb , :, :, ia , iz ) * ( spec ( isa )% mass / spec ( isb )% mass ) ** ( - 3 ) & * ( spec ( isa )% mass / spec ( isb )% mass ) ** ( - 0.5 ), iz , psijnorm ( ll , jj , isa , isb , iz )) end if end if end if end do end do end do end do end do psijnorm = psijnorm / ( 4 * pi ) ! account for theta and phi integrals included in integrate_vmu ! to check self-adjointness !!print('Integral A =', np.trapz(vlinspace**lll * assoc_laguerre(vlinspace**2, jjj, lll+0.5) * fp0(vlinspace, ma, mb, jjj, lll) * vlinspace**2, x=vlinspace) ) !!print('Integral B =', np.trapz(ma**0.5/mb**0.5 * ma**3/mb**3 * vlinspace**lll * assoc_laguerre(vlinspace**2, jjj, lll+0.5) * fp0(vlinspace, mb, ma, jjj, lll) * vlinspace**2, x=vlinspace) ) !if (nspec > 1) then !    ia  = 1 !    ll  = 0 !    jj  = 1 !    isa = 1 !    isb = 2 !    print*,'' !    call integrate_vmu( vlaguerre_vmu(ll,jj,:,:,ia,0)*deltaj(ll,jj,isa,isb,:,:,ia,0), 0, psijnorm(ll,jj,isa,isb,0) ) !    print*,'Integral A j1l0 =', psijnorm(ll,jj,isa,isb,0) !    call integrate_vmu( vlaguerre_vmu(ll,jj,:,:,ia,0)*deltaj(ll,jj,isb,isa,:,:,ia,0) * (spec(isa)%mass/spec(isb)%mass)**3.0 * (spec(isa)%mass/spec(isb)%mass)**0.5, 0, psijnorm(ll,jj,isb,isa,0) ) !    print*,'Integral B j1l0 =', psijnorm(ll,jj,isb,isa,0) !    call integrate_vmu( (-velvpamu(:,:,0)**2)*deltaj(ll,jj,isb,isa,:,:,ia,0) * (spec(isa)%mass/spec(isb)%mass)**3.0 * (spec(isa)%mass/spec(isb)%mass)**0.5, 0, psijnorm(ll,jj,isb,isa,0) ) !    print*,'Integral B j1l0b=', psijnorm(ll,jj,isb,isa,0) !    print*,'' !    ia  = 1 !    ll  = 1 !    jj  = 0 !    isa = 1 !    isb = 2 !    print*,'' !    call integrate_vmu( vlaguerre_vmu(ll,jj,:,:,ia,0)*deltaj(ll,jj,isa,isb,:,:,ia,0), 0, psijnorm(ll,jj,isa,isb,0) ) !    print*,'Integral A l1j0 =', psijnorm(ll,jj,isa,isb,0) !    call integrate_vmu( vlaguerre_vmu(ll,jj,:,:,ia,0)*deltaj(ll,jj,isb,isa,:,:,ia,0) * (spec(isa)%mass/spec(isb)%mass)**3.0 * (spec(isa)%mass/spec(isb)%mass)**0.5, 0, psijnorm(ll,jj,isb,isa,0) ) !    print*,'Integral B l1j0 =', psijnorm(ll,jj,isb,isa,0) !    print*,'' !end if ! to write interspec delt0 to file !if (nspec > 1) then !    do iv = 1, nvel_local !        call calc_delta0 (vel(iv), 1, 0, 1, 2, delt0test1(iv)) ! jj=1, ll=0, ie !        call calc_delta0 (vel(iv), 1, 0, 2, 1, delt0test2(iv)) ! jj=1, ll=0, ei !        call calc_delta0 (vel(iv), 0, 1, 1, 2, delt0test3(iv)) ! jj=1, ll=0, ie !        call calc_delta0 (vel(iv), 0, 2, 2, 2, delt0test4(iv)) ! jj=1, ll=0, ei !    end do !    call open_output_file (tmpunit,'.delt0test') !    do iv = 1, nvel_local !      write (tmpunit,'(9es15.4e3)') vel(iv), delt0test1(iv), delt0test2(iv), delt0test3(iv), delt0test4(iv) !    end do !    write (tmpunit,*) !    call close_output_file (tmpunit) !    call open_output_file (tmpunit,'.delt0l2test') !    do iv = 1, nvel_local !      write (tmpunit,'(9es15.4e3)') vel(iv), delt0test4(iv) !    end do !    write (tmpunit,*) !    call close_output_file (tmpunit) !end if conservative_wgts = . false . call set_vpa_weights ( conservative_wgts ) ! save deltajl for inspection !call open_output_file (tmpunit,'.deltaj1l1_ee') !do iv = 1, nvpa !    write (tmpunit,*) ( deltaj(1, 1, 2, 2, iv, imu, 1, 0), imu=1, nmu ) ! at z = 0 !end do !write (tmpunit,*) !call close_output_file (tmpunit) !call open_output_file (tmpunit,'.deltaj2l1_ee') !do iv = 1, nvpa !    write (tmpunit,*) ( deltaj(1, 2, 2, 2, iv, imu, 1, 0), imu=1, nmu ) ! at z = 0 !end do !write (tmpunit,*) !call close_output_file (tmpunit) !call open_output_file (tmpunit,'.deltaj3l1_ee') !do iv = 1, nvpa !    write (tmpunit,*) ( deltaj(1, 3, 2, 2, iv, imu, 1, 0), imu=1, nmu ) ! at z = 0 !end do !write (tmpunit,*) !call close_output_file (tmpunit) !call open_output_file (tmpunit,'.deltaj1l1_ei') !do iv = 1, nvpa !    write (tmpunit,*) ( deltaj(1, 1, 2, 1, iv, imu, 1, 0), imu=1, nmu ) ! at z = 0 !end do !write (tmpunit,*) !call close_output_file (tmpunit) !call open_output_file (tmpunit,'.deltaj2l1_ei') !do iv = 1, nvpa !    write (tmpunit,*) ( deltaj(1, 2, 2, 1, iv, imu, 1, 0), imu=1, nmu ) ! at z = 0 !end do !write (tmpunit,*) !call close_output_file (tmpunit) !call open_output_file (tmpunit,'.deltaj3l1_ei') !do iv = 1, nvpa !    write (tmpunit,*) ( deltaj(1, 3, 2, 1, iv, imu, 1, 0), imu=1, nmu ) ! at z = 0 !end do !write (tmpunit,*) !call close_output_file (tmpunit) !call open_output_file (tmpunit,'.deltaj0l2_ee') !do iv = 1, nvpa !    write (tmpunit,*) ( deltaj(2, 0, 2, 2, iv, imu, 1, 0), imu=1, nmu ) ! at z = 0 !end do !write (tmpunit,*) !call close_output_file (tmpunit) !print*,'maxval deltaj0l2' !print*,maxval(abs(deltaj(2, 0, 2, 2, :, :, 1, 0))) !print*,'' !call open_output_file (tmpunit,'.deltaj1l2_ee') !do iv = 1, nvpa !    write (tmpunit,*) ( deltaj(2, 1, 2, 2, iv, imu, 1, 0), imu=1, nmu ) ! at z = 0 !end do !write (tmpunit,*) !call close_output_file (tmpunit) !call open_output_file (tmpunit,'.deltaj2l2_ee') !do iv = 1, nvpa !    write (tmpunit,*) ( deltaj(2, 2, 2, 2, iv, imu, 1, 0), imu=1, nmu ) ! at z = 0 !end do !write (tmpunit,*) !call close_output_file (tmpunit) !call open_output_file (tmpunit,'.deltaj0l1_ee') !do iv = 1, nvpa !    write (tmpunit,*) ( deltaj(1, 0, 2, 2, iv, imu, 1, 0), imu=1, nmu ) ! at z = 0 !end do !write (tmpunit,*) !call close_output_file (tmpunit) end subroutine init_deltaj_vmu subroutine get_testpart_density ( isa , isb , g , fld ) ! if isb==0: ! get the field tp_den_isa(g_isa), store it in fld(:,:,:,:,isa) ! if isa=0, fix the species indices of the operator tp_den, ie ! get the fields tp_den_isb(g_a), tp_den_isb(g_b), tp_den_isb(g_c) ... use mp , only : sum_allreduce use zgrid , only : nzgrid use vpamu_grids , only : integrate_vmu , set_vpa_weights , nvpa , nmu use stella_layouts , only : kxkyz_lo , iky_idx , ikx_idx , iz_idx , it_idx , is_idx use constants , only : pi use species , only : nspec use file_utils , only : open_output_file , close_output_file use stella_time , only : code_dt implicit none integer , intent ( in ) :: isa , isb complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :, :), intent ( out ) :: fld integer :: ikxkyz , iky , ikx , iz , it , is , ia , iv , ikxkyz_isb , is_b , iky_b , ikx_b , iz_b , it_b complex , dimension (:, :), allocatable :: g0 complex , dimension (:), allocatable :: ghrs allocate ( g0 ( nvpa , nmu )) allocate ( ghrs ( nmu * nvpa )) !conservative_wgts = .false. !call set_vpa_weights (conservative_wgts) ia = 1 fld = 0. if ( isb == 0 ) then do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) if ( is /= isa ) cycle do iv = 1 , nvpa ghrs ( nmu * ( iv - 1 ) + 1 : nmu * iv ) = g ( iv , :, ikxkyz ) end do ! blockmatrix_sum contains sum of interspecies test particle operators ghrs = matmul ( - blockmatrix_sum (:, :, ikxkyz ) / code_dt , ghrs ) do iv = 1 , nvpa g0 ( iv , :) = ghrs ( nmu * ( iv - 1 ) + 1 : nmu * iv ) end do call integrate_vmu ( g0 , iz , fld ( iky , ikx , iz , it , is )) end do else if ( isa == isb ) then ! apply the operator tp_den_isb[] to every species index of g; only used in the calculation of the response matrix ! where the species index, is, of g contains the response \\delta h_a / \\delta \\psi&#94;{a,is}; always given on an x_a grid do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) ! AVB: to do - cumbersome below, fix do iv = 1 , nvpa ghrs ( nmu * ( iv - 1 ) + 1 : nmu * iv ) = g ( iv , :, ikxkyz ) end do do ikxkyz_isb = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc is_b = is_idx ( kxkyz_lo , ikxkyz_isb ) iky_b = iky_idx ( kxkyz_lo , ikxkyz_isb ) ikx_b = ikx_idx ( kxkyz_lo , ikxkyz_isb ) iz_b = iz_idx ( kxkyz_lo , ikxkyz_isb ) it_b = it_idx ( kxkyz_lo , ikxkyz_isb ) if (( is_b /= isb ) . or . ( iky_b /= iky ) . or . ( ikx_b /= ikx ) . or . ( iz_b /= iz ) . or . ( it_b /= it )) cycle ghrs = matmul ( - blockmatrix_sum (:, :, ikxkyz_isb ) / code_dt , ghrs ) end do do iv = 1 , nvpa g0 ( iv , :) = ghrs ( nmu * ( iv - 1 ) + 1 : nmu * iv ) end do call integrate_vmu ( g0 , iz , fld ( iky , ikx , iz , it , is )) end do else fld = 0. end if deallocate ( g0 ) deallocate ( ghrs ) call sum_allreduce ( fld ) end subroutine get_testpart_density subroutine init_fp_conserve use linear_solve , only : lu_decomposition use stella_time , only : code_dt use species , only : nspec use zgrid , only : nzgrid , ntubes use vpamu_grids , only : ztmax , maxwell_mu , nmu , nvpa , set_vpa_weights use kt_grids , only : naky , nakx use stella_layouts , only : kxkyz_lo , iky_idx , ikx_idx , iz_idx , is_idx , it_idx use dist_fn_arrays , only : gvmu use fields , only : get_fields , get_fields_by_spec_idx use job_manage , only : time_message , timer_local use file_utils , only : open_output_file , close_output_file use constants , only : pi implicit none integer :: ikxkyz , iky , ikx , iz , is , it , iv , imu , ix , ia , idx1 , idx2 , il , im , ij , mm , ll , jj integer :: il1 , im1 , ij1 , mm1 , ll1 , jj1 integer :: il2 , im2 , ij2 , mm2 , ll2 , jj2 , isa , isb logical :: conservative_wgts real :: dum2 complex , dimension (:, :, :, :), allocatable :: dum1 complex , dimension (:, :, :, :, :), allocatable :: field complex , dimension (:, :), allocatable :: sumdelta complex , dimension (:, :), allocatable :: gvmutr complex , dimension (:), allocatable :: ghrs complex , dimension (:, :, :, :, :), allocatable :: response_vpamu if (. not . allocated ( fp_response )) then if ( fieldpart ) then nresponse = 1 + ( jmax + 1 ) * ( lmax + 1 ) ** 2 * nspec ** 2 else nresponse = 1 end if allocate ( fp_response ( nresponse , nresponse , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )); fp_response = 0. allocate ( diff_idx ( nresponse , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) allocate ( response_vpamu ( nvpa , nmu , nvpa , nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) end if allocate ( dum1 ( naky , nakx , - nzgrid : nzgrid , ntubes )) allocate ( field ( naky , nakx , - nzgrid : nzgrid , ntubes , nspec )) allocate ( sumdelta ( nvpa , nmu )); sumdelta = 0. allocate ( gvmutr ( nvpa , nmu )) allocate ( ghrs ( nmu * nvpa )); ghrs = 0. allocate ( deltajint ( jmax + 1 , nvpa , nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) ia = 1 ! set wgts to uniform to ensure exact conservation properties if ( density_conservation ) then conservative_wgts = . true . call set_vpa_weights ( conservative_wgts ) end if if ( exact_conservation_tp ) then conservative_wgts = . false . call set_vpa_weights ( conservative_wgts ) end if ! phi response do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) ghrs = reshape ( transpose ( spread ( ztmax (:, is ), 2 , nmu ) * spread ( maxwell_mu ( 1 , iz ,:, is ), 1 , nvpa ) * spread ( jm0 (:, iky , ikx , iz , is ), 1 , nvpa )), shape = ( / nmu * nvpa / )) call zgbtrs ( 'No transpose' , nvpa * nmu , nmu + 1 , nmu + 1 , 1 , cdiffmat_band (:,:, iky , ikx , iz , is ), 3 * ( nmu + 1 ) + 1 , ipiv (:, iky , ikx , iz , is ), ghrs , nvpa * nmu , info ) gvmu (:, :, ikxkyz ) = transpose ( reshape ( ghrs , shape = ( / nmu , nvpa / ))) end do ! gvmu contains dhs/dphi ! for phi equation, need 1-P[dhs/dphi] call get_fields ( gvmu , field (:, :, :, :, 1 ), dum1 , dist = 'h' ) ! note that get_fields sums over species, as required in response matrix do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) fp_response ( 1 , 1 , ikxkyz ) = 1.0 - field ( iky , ikx , iz , it , 1 ) end do ! field particle operator ! collect all tp terms for species a in blockmatrix_sum(isa) ! required for tp density conservation to machine precision ! to do - avoid operations with blockmatrix or blockmatrix_sum, use band storage if ( density_conservation_tp ) then do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc is = is_idx ( kxkyz_lo , ikxkyz ) blockmatrix_sum (:, :, ikxkyz ) = blockmatrix (:, :, ikxkyz , is ) do isb = 1 , nspec if ( isb == is ) cycle blockmatrix_sum (:, :, ikxkyz ) = blockmatrix_sum (:, :, ikxkyz ) + blockmatrix (:, :, ikxkyz , isb ) end do end do end if ! field particle terms if ( fieldpart ) then idx1 = 1 ! first row (phi equation) do idx2 = 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 * nspec ! column indices isa = 1 + int (( idx2 - 1 ) / float (( jmax + 1 ) * ( lmax + 1 ) ** 2 )) ij = 1 + mod ( 1 + mod ( idx2 - 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 ) - 1 , jmax + 1 ) il = 1 + int ( sqrt ( 1.0 * ( 1 + mod ( idx2 - 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 ) - ij ) / ( jmax + 1 ))) im = 1 + ( 1 + mod ( idx2 - 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 ) - ij ) / ( jmax + 1 ) - ( il - 1 ) ** 2 ll = il - 1 mm = - ll + im - 1 jj = ij - 1 ! get psi response, dh/dpsi_{ikn}, need responses: ! dh/dpsi_aa, dh/dpsi_ab, ... ! dh/dpsi_bb, dh/dpsi_ba, ... ! jj=0, ll=0 term is zero because Delta_j&#94;l = 0 for jj=0, ll=0 ! optionally replace this term with density conserving term ! that ensures conservation of density of the test particle operator to machine precision when using non-uniform mu-grid if (( jj == 0 ) . and . ( ll == 0 ) . and . ( density_conservation_tp )) then gvmu = 0. ! get testpart_den response for kperp = 0, only need dh_isa / d testpart_den_isa ! since this includes all interspecies test-particle operators do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) if ( is /= isa ) cycle do iv = 1 , nvpa do imu = 1 , nmu ghrs ( nmu * ( iv - 1 ) + imu ) = - code_dt * modmw ( iv , imu , iz , is ) / modmwnorm ( iz ) end do end do call zgbtrs ( 'No transpose' , nvpa * nmu , nmu + 1 , nmu + 1 , 1 , cdiffmat_band (:,:, iky , ikx , iz , is ), 3 * ( nmu + 1 ) + 1 , ipiv (:, iky , ikx , iz , is ), ghrs , nvpa * nmu , info ) do ix = 1 , nvpa gvmu ( ix , :, ikxkyz ) = ghrs ( nmu * ( ix - 1 ) + 1 : nmu * ( ix - 1 ) + nmu ) end do end do ! get phi_isa(dh_is2a/dh_is1), phi_isa(dh_is2a/dh_is2) ... call get_fields_by_spec_idx ( isa , gvmu , field ) ! AVB: check - using by_spec_idx instead of by_spec_mod do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) fp_response ( idx1 , 2 + ( idx2 - 1 ) * nspec : 1 + idx2 * nspec , ikxkyz ) = - field ( iky , ikx , iz , it , :) end do else ! get the responses dh_is2a/dh_is1, dh_is2a/dh_is2, dh_is2a/dh_is3 ... call get_psi_response ( ll , mm , jj , isa , gvmu ) ! get phi_isa(dh_is2a/dh_is1), phi_isa(dh_is2a/dh_is2) ... call get_fields_by_spec_idx ( isa , gvmu , field ) ! AVB: check - using by_spec_idx instead of by_spec_mod do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) fp_response ( idx1 , 2 + ( idx2 - 1 ) * nspec : 1 + idx2 * nspec , ikxkyz ) = - field ( iky , ikx , iz , it , :) end do end if end do idx2 = 1 ! first column do idx1 = 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 * nspec ! row indices isa = 1 + int (( idx1 - 1 ) / float (( jmax + 1 ) * ( lmax + 1 ) ** 2 )) ij = 1 + mod ( 1 + mod ( idx1 - 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 ) - 1 , jmax + 1 ) il = 1 + int ( sqrt ( 1.0 * ( 1 + mod ( idx1 - 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 ) - ij ) / ( jmax + 1 ))) im = 1 + ( 1 + mod ( idx1 - 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 ) - ij ) / ( jmax + 1 ) - ( il - 1 ) ** 2 ll = il - 1 mm = - ll + im - 1 jj = ij - 1 ! get phi responses, dh_{isa}/dphi, dh_{isb}/dphi, dh_{isc}/dphi ... store in gvmu do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) do iv = 1 , nvpa do imu = 1 , nmu ghrs ( nmu * ( iv - 1 ) + imu ) = ztmax ( iv , is ) * maxwell_mu ( 1 , iz , imu , is ) * jm0 ( imu , iky , ikx , iz , is ) end do end do call zgbtrs ( 'No transpose' , nvpa * nmu , nmu + 1 , nmu + 1 , 1 , cdiffmat_band (:,:, iky , ikx , iz , is ), 3 * ( nmu + 1 ) + 1 , ipiv (:, iky , ikx , iz , is ), ghrs , nvpa * nmu , info ) do ix = 1 , nvpa gvmu ( ix , :, ikxkyz ) = ghrs ( nmu * ( ix - 1 ) + 1 : nmu * ( ix - 1 ) + nmu ) end do end do if (( jj == 0 ) . and . ( ll == 0 ) . and . ( density_conservation_tp )) then ! get C_testpart[isa,isa+isb+isc...][dh_a/dphi], store in field(:,:,:,:,isa) field = 0. call get_testpart_density ( isa , 0 , gvmu , field ) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) fp_response ( 2 + ( idx1 - 1 ) * nspec : 1 + idx1 * nspec , idx2 , ikxkyz ) = - field ( iky , ikx , iz , it , :) end do else ! get psi_{isa,isa}[dh_{isa}/dphi], psi_{isa,isb}[dh_{isb}/dphi], psi_{isa,isc}[dh_{isc}/dphi] ... call get_psi ( gvmu , field , isa , 0 , ll , mm , jj ) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) fp_response ( 2 + ( idx1 - 1 ) * nspec : 1 + idx1 * nspec , idx2 , ikxkyz ) = - field ( iky , ikx , iz , it , :) end do end if end do ! interior entries do idx1 = 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 * nspec ! row indices do idx2 = 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 * nspec ! column indices isa = 1 + int (( idx1 - 1 ) / float (( jmax + 1 ) * ( lmax + 1 ) ** 2 )) ij1 = 1 + mod ( 1 + mod ( idx1 - 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 ) - 1 , jmax + 1 ) il1 = 1 + int ( sqrt ( 1.0 * ( 1 + mod ( idx1 - 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 ) - ij1 ) / ( jmax + 1 ))) im1 = 1 + ( 1 + mod ( idx1 - 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 ) - ij1 ) / ( jmax + 1 ) - ( il1 - 1 ) ** 2 ll1 = il1 - 1 mm1 = - ll1 + im1 - 1 jj1 = ij1 - 1 isb = 1 + int (( idx2 - 1 ) / float (( jmax + 1 ) * ( lmax + 1 ) ** 2 )) ij2 = 1 + mod ( 1 + mod ( idx2 - 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 ) - 1 , jmax + 1 ) il2 = 1 + int ( sqrt ( 1.0 * ( 1 + mod ( idx2 - 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 ) - ij2 ) / ( jmax + 1 ))) im2 = 1 + ( 1 + mod ( idx2 - 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 ) - ij2 ) / ( jmax + 1 ) - ( il2 - 1 ) ** 2 ll2 = il2 - 1 mm2 = - ll2 + im2 - 1 jj2 = ij2 - 1 if (( jj2 == 0 ) . and . ( ll2 == 0 ) . and . ( density_conservation_tp )) then gvmu = 0. do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) if ( is /= isb ) cycle do iv = 1 , nvpa do imu = 1 , nmu ghrs ( nmu * ( iv - 1 ) + imu ) = - code_dt * modmw ( iv , imu , iz , is ) / modmwnorm ( iz ) end do end do call zgbtrs ( 'No transpose' , nvpa * nmu , nmu + 1 , nmu + 1 , 1 , cdiffmat_band (:,:, iky , ikx , iz , is ), 3 * ( nmu + 1 ) + 1 , ipiv (:, iky , ikx , iz , is ), ghrs , nvpa * nmu , info ) do ix = 1 , nvpa gvmu ( ix , :, ikxkyz ) = ghrs ( nmu * ( ix - 1 ) + 1 : nmu * ( ix - 1 ) + nmu ) end do end do else gvmu = 0. call get_psi_response ( ll2 , mm2 , jj2 , isb , gvmu ) end if if (( jj1 == 0 ) . and . ( ll1 == 0 ) . and . ( density_conservation_tp )) then ! get the fields C_testpart[isa,isa+isb+isc...][dh_a/dpsi&#94;ab], C_testpart[isa,isa+isb+isc...][dh_a/dpsi&#94;ac], C_testpart[isa,isa+isb+isc...][dh_a/dpsi&#94;ad] ... call get_testpart_density ( isa , isb , gvmu , field ) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) ! AVB: check - is index fp_response ( 2 + ( idx1 - 1 ) * nspec + ( isb - 1 ), 2 + ( idx2 - 1 ) * nspec : 1 + idx2 * nspec , ikxkyz ) = - field ( iky , ikx , iz , it , :) end do else ! get fields Q_(isa,isb)[dh_{is}/dpsi&#94;{is,isa}], Q_(isa,isb)[dh_{is}/dpsi&#94;{is,isa}], ... call get_psi ( gvmu , field , isa , isb , ll1 , mm1 , jj1 ) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) ! AVB: check - is index fp_response ( 2 + ( idx1 - 1 ) * nspec + ( isb - 1 ), 2 + ( idx2 - 1 ) * nspec : 1 + idx2 * nspec , ikxkyz ) = - field ( iky , ikx , iz , it , :) end do end if end do end do ! add 1 to diagonal do idx1 = 2 , 1 + ( jmax + 1 ) * ( lmax + 1 ) ** 2 * nspec ** 2 fp_response ( idx1 , idx1 , :) = fp_response ( idx1 , idx1 , :) + 1 end do end if ! save response matrix, to examine contents !do ikxkyz = kxkyz_lo%llim_proc, kxkyz_lo%ulim_proc ! iky = iky_idx(kxkyz_lo,ikxkyz) ! ikx = ikx_idx(kxkyz_lo,ikxkyz) ! iz  = iz_idx(kxkyz_lo,ikxkyz) ! is  = is_idx(kxkyz_lo,ikxkyz) !it  = it_idx(kxkyz_lo,ikxkyz) !if ((iky==naky).and.(is==1).and.(iz==0)) then !     call open_output_file (tmpunit,'.fp_response') !      do idx1 = 1, nresponse !          write(tmpunit,*) (real(fp_response(idx1,idx2,ikxkyz)), idx2 = 1,nresponse) ! (12es15.4e3) !      end do !      write (tmpunit,*) !      call close_output_file (tmpunit) !  end if !end do ! LU decomposition for response do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc call lu_decomposition ( fp_response (:, :, ikxkyz ), diff_idx (:, ikxkyz ), dum2 ) end do conservative_wgts = . false . call set_vpa_weights ( conservative_wgts ) deallocate ( dum1 , field ) end subroutine init_fp_conserve subroutine get_psi_response ( ll , mm , jj , isa , response ) ! solve for responses dh_a / dpsi&#94;{aa}, dh_a / dpsi&#94;{ab}, dh_a / dpsi&#94;{ac} ... for all species b, c, ... use finite_differences , only : tridag use linear_solve , only : lu_decomposition use stella_time , only : code_dt use species , only : nspec , spec use zgrid , only : ntubes use vpamu_grids , only : nmu , nvpa use vpamu_grids , only : set_vpa_weights use kt_grids , only : naky , nakx use stella_layouts , only : kxkyz_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , is_idx , it_idx use fields , only : get_fields , get_fields_by_spec use job_manage , only : time_message , timer_local use constants , only : pi use file_utils , only : open_output_file , close_output_file implicit none complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( out ) :: response integer , intent ( in ) :: ll , mm , jj , isa complex , dimension (:), allocatable :: ghrs integer :: ikxkyz , iky , ikx , iz , is , ia , iv , imu real :: clm allocate ( ghrs ( nmu * nvpa )) ia = 1 clm = sqrt ((( 2 * ll + 1 ) * gamma ( ll - mm + 1. )) / ( 4 * pi * gamma ( ll + mm + 1. ))) ! calculate response dh/dpsi_jlm, for unit impulse to psi_jlm do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) ! isb ! supply unit impulse to psi_j&#94;(lm)&#94;{isa,isb} do iv = 1 , nvpa do imu = 1 , nmu if ( mm == 0 ) then ghrs ( nmu * ( iv - 1 ) + imu ) = code_dt * spec ( isa )% vnew ( is ) * clm * legendre_vpamu ( ll , mm , iv , imu , iz ) & * jm ( imu , mm , iky , ikx , iz , isa ) * ( spec ( isa )% mass / spec ( is )% mass ) ** ( - 1.5 ) * deltaj ( ll , jj , isa , is , iv , imu , ia , iz ) else if ( mm > 0 ) then ghrs ( nmu * ( iv - 1 ) + imu ) = code_dt * spec ( isa )% vnew ( is ) * clm * legendre_vpamu ( ll , mm , iv , imu , iz ) & * jm ( imu , mm , iky , ikx , iz , isa ) * ( spec ( isa )% mass / spec ( is )% mass ) ** ( - 1.5 ) * deltaj ( ll , jj , isa , is , iv , imu , ia , iz ) else if ( mm < 0 ) then ghrs ( nmu * ( iv - 1 ) + imu ) = ( - 1 ) ** mm * code_dt * spec ( isa )% vnew ( is ) * clm * legendre_vpamu ( ll , mm , iv , imu , iz ) & * jm ( imu , abs ( mm ), iky , ikx , iz , isa ) * ( spec ( isa )% mass / spec ( is )% mass ) ** ( - 1.5 ) * deltaj ( ll , jj , isa , is , iv , imu , ia , iz ) end if end do end do ! solve for response ! need to solve [1 - Deltat C_{test}] dh_a/dpsi&#94;ab = delta_{ab} for dh_a/dpsi&#94;ab. Here, C_{test} includes self collisions and a-b collisions, call zgbtrs ( 'No transpose' , nvpa * nmu , nmu + 1 , nmu + 1 , 1 , & cdiffmat_band (:, :, iky , ikx , iz , isa ), 3 * ( nmu + 1 ) + 1 , ipiv (:, iky , ikx , iz , isa ), ghrs , nvpa * nmu , info ) do iv = 1 , nvpa response ( iv , :, ikxkyz ) = ghrs ( nmu * ( iv - 1 ) + 1 : nmu * ( iv - 1 ) + nmu ) end do ! to zero l=1,j=1 term: if ( no_j1l1 ) then if (( ll == 1 ) . and . ( jj == 1 )) then response (:, :, ikxkyz ) = 0. end if end if if ( no_j1l2 ) then if (( ll == 2 ) . and . ( jj == 1 )) then response (:, :, ikxkyz ) = 0. end if end if if ( no_j0l2 ) then if (( ll == 2 ) . and . ( jj == 0 )) then response (:, :, ikxkyz ) = 0. end if end if if ( spitzer_problem ) then if (. not . (( isa == 2 ) . and . ( is == 2 ))) then response (:, :, ikxkyz ) = 0. end if end if end do deallocate ( ghrs ) end subroutine get_psi_response subroutine get_psi ( g , fld , isa , isb , ll , mm , jj ) ! if isb==0: ! get the fields psi_aa&#94;lmj(g_a), psi_ab&#94;lmj(g_b), psi_ac&#94;lmj(g_c) ..., for species b, c, ... ! if isb/=0, fix the species indices of the operator psi_ab, ie ! get the fields psi_ab&#94;lmj(g_a), psi_ab&#94;lmj(g_b), psi_ab&#94;lmj(g_c) ... use mp , only : sum_allreduce use zgrid , only : nzgrid use vpamu_grids , only : integrate_vmu , set_vpa_weights , nvpa , nmu , vpa use stella_layouts , only : kxkyz_lo , iky_idx , ikx_idx , iz_idx , it_idx , is_idx use constants , only : pi use species , only : spec , nspec use file_utils , only : open_output_file , close_output_file use stella_time , only : code_dt implicit none complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :, :), intent ( out ) :: fld integer , intent ( in ) :: isa , isb , ll , mm , jj integer :: ikxkyz , iky , ikx , iz , it , is , ia , iv , ikxkyz_isb , is_b , iky_b , ikx_b , iz_b , it_b complex , dimension (:, :), allocatable :: g0 complex , dimension (:), allocatable :: ghrs real :: clm logical :: conservative_wgts allocate ( g0 ( nvpa , nmu )) allocate ( ghrs ( nmu * nvpa )) if ( density_conservation ) then conservative_wgts = . true . call set_vpa_weights ( conservative_wgts ) else conservative_wgts = . false . call set_vpa_weights ( conservative_wgts ) end if clm = ( - 1 ) ** mm * sqrt ((( 2 * ll + 1 ) * gamma ( ll + mm + 1. )) / ( 4 * pi * gamma ( ll - mm + 1. ))) ia = 1 if ( isb == 0 ) then do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) if ( mm == 0 ) then if (( exact_conservation ) . and . ((( ll == 0 ) . and . ( jj == 1 )) . or . (( ll == 1 ) . and . ( jj == 0 )))) then g0 = clm * g (:,:, ikxkyz ) / mw (:,:, iz , is ) * spread ( jm (:, - mm , iky , ikx , iz , is ), 1 , nvpa ) * legendre_vpamu ( ll , - mm ,:,:, iz ) * deltaj_tp ( ll , jj , is , isa ,:,:, ia , iz ) else if (( exact_conservation_tp ) . and . (( ll == 1 ) . and . ( jj == 0 ))) then do iv = 1 , nvpa ghrs ( nmu * ( iv - 1 ) + 1 : nmu * iv ) = clm * ( spec ( is )% mass / spec ( isa )% mass ) ** 2 * jm (:, - mm , iky , ikx , iz , is ) * g ( iv , :, ikxkyz ) end do ghrs = matmul ( - blockmatrix (:, :, ikxkyz , isa ) / code_dt / spec ( is )% vnew ( isa ), ghrs ) do iv = 1 , nvpa g0 ( iv , :) = - vpa ( iv ) * ghrs ( nmu * ( iv - 1 ) + 1 : nmu * iv ) end do if ( spec ( is )% vnew ( isa ) == 0 ) then g0 = 0. end if else if (( exact_conservation_tp ) . and . (( ll == 0 ) . and . ( jj == 1 ))) then do iv = 1 , nvpa ghrs ( nmu * ( iv - 1 ) + 1 : nmu * iv ) = clm * ( spec ( is )% mass / spec ( isa )% mass ) ** 1.5 * jm (:, - mm , iky , ikx , iz , is ) * g ( iv , :, ikxkyz ) end do ghrs = matmul ( - blockmatrix (:, :, ikxkyz , isa ) / code_dt / spec ( is )% vnew ( isa ), ghrs ) do iv = 1 , nvpa g0 ( iv , :) = velvpamu ( iv , :, iz ) ** 2 * ghrs ( nmu * ( iv - 1 ) + 1 : nmu * iv ) end do if ( spec ( is )% vnew ( isa ) == 0 ) then g0 = 0. end if else g0 = clm * g (:,:, ikxkyz ) / mw (:,:, iz , is ) * spread ( jm (:, - mm , iky , ikx , iz , is ), 1 , nvpa ) * legendre_vpamu ( ll , - mm ,:,:, iz ) * deltaj ( ll , jj , is , isa ,:,:, ia , iz ) end if else if ( mm < 0 ) then if (( exact_conservation ) . and . ((( ll == 0 ) . and . ( jj == 1 )) . or . (( ll == 1 ) . and . ( jj == 0 )))) then g0 = ( - 1 ) ** mm * clm * g (:, :, ikxkyz ) / mw (:, :, iz , is ) * spread ( jm (:, abs ( mm ), iky , ikx , iz , is ), 1 , nvpa ) & * legendre_vpamu ( ll , - mm , :, :, iz ) * deltaj_tp ( ll , jj , is , isa , :, :, ia , iz ) else g0 = ( - 1 ) ** mm * clm * g (:, :, ikxkyz ) / mw (:, :, iz , is ) * spread ( jm (:, abs ( mm ), iky , ikx , iz , is ), 1 , nvpa ) & * legendre_vpamu ( ll , - mm , :, :, iz ) * deltaj ( ll , jj , is , isa , :, :, ia , iz ) end if else if ( mm > 0 ) then if (( exact_conservation ) . and . ((( ll == 0 ) . and . ( jj == 1 )) . or . (( ll == 1 ) . and . ( jj == 0 )))) then g0 = clm * g (:, :, ikxkyz ) / mw (:, :, iz , is ) * spread ( jm (:, mm , iky , ikx , iz , is ), 1 , nvpa ) & * legendre_vpamu ( ll , - mm , :, :, iz ) * deltaj_tp ( ll , jj , is , isa , :, :, ia , iz ) else g0 = clm * g (:, :, ikxkyz ) / mw (:, :, iz , is ) * spread ( jm (:, mm , iky , ikx , iz , is ), 1 , nvpa ) & * legendre_vpamu ( ll , - mm , :, :, iz ) * deltaj ( ll , jj , is , isa , :, :, ia , iz ) end if end if call integrate_vmu ( g0 , iz , fld ( iky , ikx , iz , it , is )) ! to zero l=1,j=1 term: if ( no_j1l1 ) then if (( ll == 1 ) . and . ( jj == 1 )) then fld (:, :, :, :, is ) = 0. end if end if if ( no_j1l2 ) then if (( ll == 2 ) . and . ( jj == 1 )) then fld (:, :, :, :, is ) = 0. end if end if if ( no_j0l2 ) then if (( ll == 2 ) . and . ( jj == 0 )) then fld (:, :, :, :, is ) = 0. end if end if if ( spitzer_problem ) then if (. not . (( isa == 2 ) . and . ( is == 2 ))) then fld (:, :, :, :, is ) = 0. end if end if end do else ! isb /= 0: ! apply the operator \\psi_ab&#94;jlm[] to every species index of g; only used in the calculation of the response matrix ! where the species index, is, of g contains the response \\delta h_a / \\delta \\psi&#94;{a,is} do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) if ( mm == 0 ) then if (( exact_conservation ) . and . ((( ll == 0 ) . and . ( jj == 1 )) . or . (( ll == 1 ) . and . ( jj == 0 )))) then g0 = clm * g (:, :, ikxkyz ) / mw (:, :, iz , is ) * spread ( jm (:, mm , iky , ikx , iz , isb ), 1 , nvpa ) & * legendre_vpamu ( ll , - mm , :, :, iz ) * deltaj_tp ( ll , jj , isb , isa , :, :, ia , iz ) else if (( exact_conservation_tp ) . and . (( ll == 1 ) . and . ( jj == 0 ))) then do iv = 1 , nvpa ghrs ( nmu * ( iv - 1 ) + 1 : nmu * iv ) = clm * ( spec ( isb )% mass / spec ( isa )% mass ) ** 2 & * jm (:, mm , iky , ikx , iz , isb ) * g ( iv , :, ikxkyz ) end do do ikxkyz_isb = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc is_b = is_idx ( kxkyz_lo , ikxkyz_isb ) iky_b = iky_idx ( kxkyz_lo , ikxkyz_isb ) ikx_b = ikx_idx ( kxkyz_lo , ikxkyz_isb ) iz_b = iz_idx ( kxkyz_lo , ikxkyz_isb ) it_b = it_idx ( kxkyz_lo , ikxkyz_isb ) if (( is_b /= isb ) . or . ( iky_b /= iky ) . or . ( ikx_b /= ikx ) . or . ( iz_b /= iz ) . or . ( it_b /= it )) cycle ghrs = matmul ( - blockmatrix (:, :, ikxkyz_isb , isa ) / code_dt / spec ( isb )% vnew ( isa ), ghrs ) end do do iv = 1 , nvpa g0 ( iv , :) = - vpa ( iv ) * ghrs ( nmu * ( iv - 1 ) + 1 : nmu * iv ) end do if ( spec ( isb )% vnew ( isa ) == 0 ) then g0 = 0. end if else if (( exact_conservation_tp ) . and . (( ll == 0 ) . and . ( jj == 1 ))) then do iv = 1 , nvpa ghrs ( nmu * ( iv - 1 ) + 1 : nmu * iv ) = clm * ( spec ( isb )% mass / spec ( isa )% mass ) ** 1.5 & * jm (:, mm , iky , ikx , iz , isb ) * g ( iv , :, ikxkyz ) end do do ikxkyz_isb = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc is_b = is_idx ( kxkyz_lo , ikxkyz_isb ) iky_b = iky_idx ( kxkyz_lo , ikxkyz_isb ) ikx_b = ikx_idx ( kxkyz_lo , ikxkyz_isb ) iz_b = iz_idx ( kxkyz_lo , ikxkyz_isb ) it_b = it_idx ( kxkyz_lo , ikxkyz_isb ) if (( is_b /= isb ) . or . ( iky_b /= iky ) . or . ( ikx_b /= ikx ) . or . ( iz_b /= iz ) . or . ( it_b /= it )) cycle ghrs = matmul ( - blockmatrix (:, :, ikxkyz_isb , isa ) / code_dt / spec ( isb )% vnew ( isa ), ghrs ) end do do iv = 1 , nvpa g0 ( iv , :) = velvpamu ( iv , :, iz ) ** 2 * ghrs ( nmu * ( iv - 1 ) + 1 : nmu * iv ) end do if ( spec ( isb )% vnew ( isa ) == 0 ) then g0 = 0. end if else g0 = clm * g (:, :, ikxkyz ) / mw (:, :, iz , is ) * spread ( jm (:, mm , iky , ikx , iz , isb ), 1 , nvpa ) & * legendre_vpamu ( ll , - mm , :, :, iz ) * deltaj ( ll , jj , isb , isa , :, :, ia , iz ) end if else if ( mm < 0 ) then if (( exact_conservation ) . and . ((( ll == 0 ) . and . ( jj == 1 )) . or . (( ll == 1 ) . and . ( jj == 0 )))) then g0 = ( - 1 ) ** mm * clm * g (:, :, ikxkyz ) / mw (:, :, iz , is ) * spread ( jm (:, abs ( mm ), iky , ikx , iz , isb ), 1 , nvpa ) & * legendre_vpamu ( ll , - mm , :, :, iz ) * deltaj_tp ( ll , jj , isb , isa , :, :, ia , iz ) else g0 = ( - 1 ) ** mm * clm * g (:, :, ikxkyz ) / mw (:, :, iz , is ) * spread ( jm (:, abs ( mm ), iky , ikx , iz , isb ), 1 , nvpa ) & * legendre_vpamu ( ll , - mm , :, :, iz ) * deltaj ( ll , jj , isb , isa , :, :, ia , iz ) end if else if ( mm > 0 ) then if (( exact_conservation ) . and . ((( ll == 0 ) . and . ( jj == 1 )) . or . (( ll == 1 ) . and . ( jj == 0 )))) then g0 = clm * g (:, :, ikxkyz ) / mw (:, :, iz , is ) * spread ( jm (:, mm , iky , ikx , iz , isb ), 1 , nvpa ) & * legendre_vpamu ( ll , - mm , :, :, iz ) * deltaj_tp ( ll , jj , isb , isa , :, :, ia , iz ) else g0 = clm * g (:, :, ikxkyz ) / mw (:, :, iz , is ) * spread ( jm (:, mm , iky , ikx , iz , isb ), 1 , nvpa ) & * legendre_vpamu ( ll , - mm , :, :, iz ) * deltaj ( ll , jj , isb , isa , :, :, ia , iz ) end if end if call integrate_vmu ( g0 , iz , fld ( iky , ikx , iz , it , is )) ! to zero l=1,j=1 term: if ( no_j1l1 ) then if (( ll == 1 ) . and . ( jj == 1 )) then fld (:, :, :, :, is ) = 0. end if end if if ( no_j1l2 ) then if (( ll == 2 ) . and . ( jj == 1 )) then fld (:, :, :, :, is ) = 0. end if end if if ( no_j0l2 ) then if (( ll == 2 ) . and . ( jj == 0 )) then fld (:, :, :, :, is ) = 0. end if end if if ( spitzer_problem ) then if (. not . (( isa == 2 ) . and . ( isb == 2 ))) then fld (:, :, :, :, is ) = 0. end if end if end do end if ! normalise psijs if ( isb == 0 ) then do is = 1 , nspec do iz = - nzgrid , nzgrid fld (:, :, iz , :, is ) = fld (:, :, iz , :, is ) / psijnorm ( ll , jj , isa , is , iz ) end do end do else do iz = - nzgrid , nzgrid fld (:, :, iz , :, :) = fld (:, :, iz , :, :) / psijnorm ( ll , jj , isa , isb , iz ) end do end if deallocate ( g0 ) deallocate ( ghrs ) conservative_wgts = . false . call set_vpa_weights ( conservative_wgts ) call sum_allreduce ( fld ) end subroutine get_psi subroutine init_vpadiff_matrix use stella_time , only : code_dt use species , only : nspec , spec use vpamu_grids , only : dvpa , vpa , nvpa use stella_layouts , only : kxkyz_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , is_idx use stella_geometry , only : bmag use dist_fn_arrays , only : kperp2 implicit none integer :: ikxkyz , iky , ikx , iz , is integer :: ia if (. not . allocated ( aa_vpa )) allocate ( aa_vpa ( nvpa , nspec )) !    if (.not.allocated(bb_vpa)) allocate (bb_vpa(nvpa,nspec)) if (. not . allocated ( bb_vpa )) allocate ( bb_vpa ( nvpa , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) if (. not . allocated ( cc_vpa )) allocate ( cc_vpa ( nvpa , nspec )) ! deal with boundary points (BC is f(vpa)=0 beyond +/- vpa_max) aa_vpa ( 1 , :) = 0.0 ; cc_vpa ( nvpa , :) = 0.0 ! 2nd order centered differences for d/dvpa (1/2 dh/dvpa + vpa h) do is = 1 , nspec aa_vpa ( 2 :, is ) = - code_dt * spec ( is )% vnew ( is ) * 0.5 * ( 1.0 / dvpa - vpa (: nvpa - 1 )) / dvpa !       bb_vpa(:,is) = 1.0+code_dt*spec(is)%vnew(is)/dvpa**2 cc_vpa (: nvpa - 1 , is ) = - code_dt * spec ( is )% vnew ( is ) * 0.5 * ( 1.0 / dvpa + vpa ( 2 :)) / dvpa end do ia = 1 do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) bb_vpa (:, ikxkyz ) = 1.0 + code_dt * spec ( is )% vnew ( is ) & * ( 0.25 * kperp2 ( iky , ikx , ia , iz ) * ( spec ( is )% smz / bmag ( ia , iz )) ** 2 + 1. / dvpa ** 2 ) end do end subroutine init_vpadiff_matrix subroutine init_mudiff_matrix use stella_time , only : code_dt use species , only : nspec , spec use zgrid , only : nzgrid use stella_geometry , only : bmag use vpamu_grids , only : dmu , nmu use vpamu_grids , only : dmu_cell , mu_cell , wgts_mu_bare use stella_layouts , only : kxkyz_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , is_idx use dist_fn_arrays , only : kperp2 implicit none integer :: ikxkyz , iky , ikx , iz , is integer :: ia ! TMP FOR TESTING -- MAB !    integer :: imu if (. not . allocated ( aa_mu )) allocate ( aa_mu ( - nzgrid : nzgrid , nmu , nspec )) if (. not . allocated ( bb_mu )) allocate ( bb_mu ( nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) if (. not . allocated ( cc_mu )) allocate ( cc_mu ( - nzgrid : nzgrid , nmu , nspec )) ia = 1 ! deal with boundary points (BC is f(mu)=0 beyond mu_max and collision operator vanishes for mu -> 0) aa_mu (:, 1 , :) = 0.0 ; cc_mu (:, nmu , :) = 0.0 ! 2nd order centered differences for dt * nu * d/dmu (mu/B*dh/dmu + 2*mu*h) do is = 1 , nspec do iz = - nzgrid , nzgrid aa_mu ( iz , 2 :, is ) = - code_dt * spec ( is )% vnew ( is ) * mu_cell (: nmu - 1 ) * ( 1.0 / ( bmag ( ia , iz ) * dmu ) - 1.0 ) / wgts_mu_bare ( 2 :) cc_mu ( iz , : nmu - 1 , is ) = - code_dt * spec ( is )% vnew ( is ) * mu_cell (: nmu - 1 ) * ( 1.0 / ( bmag ( ia , iz ) * dmu ) + 1.0 ) / wgts_mu_bare (: nmu - 1 ) end do end do !1st derivative here is  2 d/dmu( mu h) -> (mu(i+1/2)h(i+1/2) - mu(i-1/2)h(i-1/2))/(mu(i+1/2)-mu(i-1/2)) !where h(i+1/2) = 0.5*[h(i+1)+h(i)] and mu(i+1/2) = 0.5*(mu(i+1)+mu(i)) !2nd derivative here is d/dmu ( mu dh/dmu ) = (mu(i+1/2)h'(i+1/2) - mu(i-1/2)h'(i-1/2))/(mu(i+1/2)-mu(i-1/2)) !where h'(i+1/2) = (h(i+1)-h(i))/(mu(i+1)-mu(i)) !left  endpoint i=1   -> mu(i-1/2) = 0 !right endpoint i=nmu -> h(i+1/2) = h'(i+1/2) = 0 (these are the two boundary conditions) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) bb_mu ( 1 , ikxkyz ) = 1.0 + code_dt * spec ( is )% vnew ( is ) & * ( 0.25 * kperp2 ( iky , ikx , ia , iz ) * ( spec ( is )% smz / bmag ( ia , iz )) ** 2 & + dmu_cell ( 1 ) * ( 1.0 / ( dmu ( 1 ) * bmag ( ia , iz )) - 1.0 ) / wgts_mu_bare ( 1 )) bb_mu ( 2 : nmu - 1 , ikxkyz ) = 1.0 + code_dt * spec ( is )% vnew ( is ) & * ( 0.25 * kperp2 ( iky , ikx , ia , iz ) * ( spec ( is )% smz / bmag ( ia , iz )) ** 2 & + ( mu_cell ( 2 : nmu - 1 ) / dmu ( 2 :) + mu_cell (: nmu - 2 ) / dmu (: nmu - 2 )) & / ( wgts_mu_bare ( 2 : nmu - 1 ) * bmag ( ia , iz )) - dmu_cell ( 2 : nmu - 1 ) / wgts_mu_bare ( 2 : nmu - 1 )) bb_mu ( nmu , ikxkyz ) = 1.0 + code_dt * spec ( is )% vnew ( is ) & * ( 0.25 * kperp2 ( iky , ikx , ia , iz ) * ( spec ( is )% smz / bmag ( ia , iz )) ** 2 & + mu_cell ( nmu - 1 ) * ( 1.0 / ( dmu ( nmu - 1 ) * bmag ( ia , iz )) + 1.0 ) / wgts_mu_bare ( nmu )) end do end subroutine init_mudiff_matrix subroutine init_vpadiff_conserve use mp , only : sum_allreduce use finite_differences , only : tridag use linear_solve , only : lu_decomposition , lu_inverse use stella_time , only : code_dt use species , only : nspec , spec , has_electron_species use zgrid , only : nzgrid , ntubes use vpamu_grids , only : ztmax , maxwell_vpa , maxwell_mu use vpamu_grids , only : nmu , vpa , vperp2 use vpamu_grids , only : set_vpa_weights use kt_grids , only : naky , nakx , zonal_mode use stella_layouts , only : kxkyz_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , it_idx , is_idx use stella_geometry , only : dl_over_b use dist_fn_arrays , only : gvmu use gyro_averages , only : aj0v use fields , only : get_fields , get_fields_by_spec , efac , gamtot_h use physics_flags , only : adiabatic_option_switch use physics_flags , only : adiabatic_option_fieldlineavg implicit none integer :: ikxkyz , iky , ikx , iz , it , is , ia integer :: imu integer :: idx logical :: conservative_wgts real :: dum2 complex , dimension (:, :, :, :), allocatable :: dum1 complex , dimension (:, :, :, :, :), allocatable :: field complex , dimension (:, :), allocatable :: temp_mat ia = 1 nresponse_vpa = 1 if ( momentum_conservation ) nresponse_vpa = nresponse_vpa + nspec if ( energy_conservation ) nresponse_vpa = nresponse_vpa + nspec if (. not . allocated ( vpadiff_response )) then allocate ( vpadiff_response ( nresponse_vpa , nresponse_vpa , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) vpadiff_response = 0. allocate ( vpadiff_idx ( nresponse_vpa , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) end if if (. not . has_electron_species ( spec ) . and . adiabatic_option_switch == adiabatic_option_fieldlineavg ) then if (. not . allocated ( vpadiff_zf_response )) then allocate ( vpadiff_zf_response ( nresponse_vpa , nresponse_vpa , nakx )) vpadiff_zf_response = 0. allocate ( vpadiff_zf_idx ( nresponse_vpa , nakx )) end if end if allocate ( dum1 ( naky , nakx , - nzgrid : nzgrid , ntubes )) allocate ( field ( naky , nakx , - nzgrid : nzgrid , ntubes , nspec )) ! set wgts to be equally spaced to ensure exact conservation properties conservative_wgts = . true . call set_vpa_weights ( conservative_wgts ) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) do imu = 1 , nmu gvmu (:, imu , ikxkyz ) = ztmax (:, is ) * maxwell_mu ( 1 , iz , imu , is ) * aj0v ( imu , ikxkyz ) call tridag ( 1 , aa_vpa (:, is ), bb_vpa (:, ikxkyz ), cc_vpa (:, is ), gvmu (:, imu , ikxkyz )) end do end do ! gvmu contains dhs/dphi ! for phi equation, need 1-P[dhs/dphi] ! for upar equations, need -Us[dhs/dphi] ! for energy conservation, need -Qs[dhs/dphi] call get_fields ( gvmu , field (:, :, :, :, 1 ), dum1 , dist = 'h' , skip_fsa = . true .) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) vpadiff_response ( 1 , 1 , ikxkyz ) = 1.0 - field ( iky , ikx , iz , it , 1 ) end do idx = 2 if ( momentum_conservation ) then call get_upar ( gvmu , field ) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) vpadiff_response ( idx : idx + nspec - 1 , 1 , ikxkyz ) = - field ( iky , ikx , iz , it , :) end do idx = idx + nspec end if if ( energy_conservation ) then call get_temp ( gvmu , field ) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) vpadiff_response ( idx : idx + nspec - 1 , 1 , ikxkyz ) = - field ( iky , ikx , iz , it , :) end do end if idx = 2 if ( momentum_conservation ) then do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) do imu = 1 , nmu gvmu (:, imu , ikxkyz ) = 2. * code_dt * spec ( is )% vnew ( is ) * vpa * aj0v ( imu , ikxkyz ) * maxwell_vpa (:, is ) * maxwell_mu ( 1 , iz , imu , is ) call tridag ( 1 , aa_vpa (:, is ), bb_vpa (:, ikxkyz ), cc_vpa (:, is ), gvmu (:, imu , ikxkyz )) end do end do ! gvmu now contains dhs/dupars ! need to get -Ps[dhs/dupars] for phi equation ! need to get 1-Us[dhs/dupars] for momentum conservation ! need to get -Qs[dhs/dupars] for energy conservation call get_fields_by_spec ( gvmu , field , skip_fsa = . true .) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) vpadiff_response ( 1 , idx : idx + nspec - 1 , ikxkyz ) = - field ( iky , ikx , iz , it , :) end do call get_upar ( gvmu , field ) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) do is = 1 , nspec vpadiff_response ( idx + is - 1 , idx + is - 1 , ikxkyz ) = 1.0 - field ( iky , ikx , iz , it , is ) end do end do if ( energy_conservation ) then call get_temp ( gvmu , field ) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) do is = 1 , nspec vpadiff_response ( idx + is + nspec - 1 , idx + is - 1 , ikxkyz ) = - field ( iky , ikx , iz , it , is ) end do end do end if idx = idx + nspec end if if ( energy_conservation ) then do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) do imu = 1 , nmu gvmu (:, imu , ikxkyz ) = 2. * code_dt * spec ( is )% vnew ( is ) * ( vpa ** 2 + vperp2 ( 1 , iz , imu ) - 1.5 ) & * aj0v ( imu , ikxkyz ) * maxwell_vpa (:, is ) * maxwell_mu ( 1 , iz , imu , is ) call tridag ( 1 , aa_vpa (:, is ), bb_vpa (:, ikxkyz ), cc_vpa (:, is ), gvmu (:, imu , ikxkyz )) end do end do ! gvmu now contains dhs/dQs ! need to get -Ps[dhs/dQs] for phi equation ! need to get 1-Us[dhs/dQs] for momentum conservation ! need to get -Qs[dhs/dQs] for energy conservation call get_fields_by_spec ( gvmu , field , skip_fsa = . true .) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) vpadiff_response ( 1 , idx : idx + nspec - 1 , ikxkyz ) = - field ( iky , ikx , iz , it , :) end do if ( momentum_conservation ) then call get_upar ( gvmu , field ) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) do is = 1 , nspec vpadiff_response ( idx + is - 1 - nspec , idx + is - 1 , ikxkyz ) = - field ( iky , ikx , iz , it , is ) end do end do end if call get_temp ( gvmu , field ) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) do is = 1 , nspec vpadiff_response ( idx + is - 1 , idx + is - 1 , ikxkyz ) = 1.0 - field ( iky , ikx , iz , it , is ) end do end do end if ! now get LU decomposition for vpadiff_response do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc call lu_decomposition ( vpadiff_response (:, :, ikxkyz ), vpadiff_idx (:, ikxkyz ), dum2 ) end do ! if electrons are adiabatic, compute the matrices for the flux-surface-average if (. not . has_electron_species ( spec ) . and . zonal_mode ( 1 ) & . and . adiabatic_option_switch == adiabatic_option_fieldlineavg ) then allocate ( temp_mat ( nresponse_vpa , nresponse_vpa )) vpadiff_zf_response = 0.0 do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) if ( iky /= 1 . or . it /= 1 ) cycle !calculate inverse of vpadiff_response call lu_inverse ( vpadiff_response (:, :, ikxkyz ), vpadiff_idx (:, ikxkyz ), temp_mat ) !calculate -inv(vpadiff_response).Q, where Q has a single entry do idx = 1 , nresponse_vpa vpadiff_zf_response ( idx , 1 , ikx ) = vpadiff_zf_response ( idx , 1 , ikx ) & - temp_mat ( idx , 1 ) * ( efac / gamtot_h ) * dl_over_b ( ia , iz ) end do end do !finish the flux surface average call sum_allreduce ( vpadiff_zf_response ) !calculate 1 - fsa(inv(vpadiff_response).Q) do idx = 1 , nresponse_vpa vpadiff_zf_response ( idx , idx , :) = vpadiff_zf_response ( idx , idx , :) + 1.0 end do do ikx = 1 , nakx call lu_decomposition ( vpadiff_zf_response (:, :, ikx ), vpadiff_zf_idx (:, ikx ), dum2 ) end do deallocate ( temp_mat ) end if ! reset wgts to default setting conservative_wgts = . false . call set_vpa_weights ( conservative_wgts ) deallocate ( dum1 , field ) end subroutine init_vpadiff_conserve subroutine init_mudiff_conserve use mp , only : sum_allreduce use finite_differences , only : tridag use linear_solve , only : lu_decomposition , lu_inverse use stella_time , only : code_dt use species , only : nspec , spec , has_electron_species use zgrid , only : nzgrid , ntubes use vpamu_grids , only : ztmax , maxwell_vpa , maxwell_mu use vpamu_grids , only : nvpa , vpa , vperp2 use kt_grids , only : naky , nakx , zonal_mode use stella_geometry , only : dl_over_b , bmag use stella_layouts , only : kxkyz_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , it_idx , is_idx use dist_fn_arrays , only : gvmu , kperp2 use gyro_averages , only : aj0v , aj1v use fields , only : get_fields , get_fields_by_spec , efac , gamtot_h use physics_flags , only : adiabatic_option_switch use physics_flags , only : adiabatic_option_fieldlineavg implicit none integer :: ikxkyz , iky , ikx , iz , it , is , ia integer :: iv integer :: idx real :: dum2 complex , dimension (:, :), allocatable :: temp_mat complex , dimension (:, :, :, :), allocatable :: dum1 complex , dimension (:, :, :, :, :), allocatable :: field nresponse_mu = 1 if ( momentum_conservation ) nresponse_mu = nresponse_mu + nspec if ( energy_conservation ) nresponse_mu = nresponse_mu + nspec if (. not . allocated ( mudiff_response )) then allocate ( mudiff_response ( nresponse_mu , nresponse_mu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) mudiff_response = 0. allocate ( mudiff_idx ( nresponse_mu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) end if if (. not . has_electron_species ( spec ) . and . adiabatic_option_switch == adiabatic_option_fieldlineavg ) then if (. not . allocated ( mudiff_zf_response )) then allocate ( mudiff_zf_response ( nresponse_mu , nresponse_mu , nakx )) mudiff_zf_response = 0. allocate ( mudiff_zf_idx ( nresponse_mu , nakx )) end if end if allocate ( dum1 ( naky , nakx , - nzgrid : nzgrid , ntubes )) allocate ( field ( naky , nakx , - nzgrid : nzgrid , ntubes , nspec )) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) do iv = 1 , nvpa gvmu ( iv , :, ikxkyz ) = ztmax ( iv , is ) * maxwell_mu ( 1 , iz , :, is ) * aj0v (:, ikxkyz ) call tridag ( 1 , aa_mu ( iz , :, is ), bb_mu (:, ikxkyz ), cc_mu ( iz , :, is ), gvmu ( iv , :, ikxkyz )) end do end do ! gvmu contains dhs/dphi ! for phi equation, need 1-P[dhs/dphi] ! for uperp equations, need -Us[dhs/dphi] ! for energy conservation, need -Qs[dhs/dphi] call get_fields ( gvmu , field (:, :, :, :, 1 ), dum1 , dist = 'h' , skip_fsa = . true .) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) mudiff_response ( 1 , 1 , ikxkyz ) = 1.0 - field ( iky , ikx , iz , it , 1 ) end do idx = 2 if ( momentum_conservation ) then call get_uperp ( gvmu , field ) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) mudiff_response ( idx : idx + nspec - 1 , 1 , ikxkyz ) = - field ( iky , ikx , iz , it , :) end do idx = idx + nspec end if if ( energy_conservation ) then call get_temp_mu ( gvmu , field ) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) mudiff_response ( idx : idx + nspec - 1 , 1 , ikxkyz ) = - field ( iky , ikx , iz , it , :) end do end if idx = 2 if ( momentum_conservation ) then ia = 1 do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) do iv = 1 , nvpa gvmu ( iv , :, ikxkyz ) = 2. * code_dt * spec ( is )% vnew ( is ) * kperp2 ( iky , ikx , ia , iz ) * vperp2 ( ia , iz , :) & * ( spec ( is )% smz / bmag ( ia , iz )) ** 2 * aj1v (:, ikxkyz ) * maxwell_vpa ( iv , is ) * maxwell_mu ( ia , iz , :, is ) call tridag ( 1 , aa_mu ( iz , :, is ), bb_mu (:, ikxkyz ), cc_mu ( iz , :, is ), gvmu ( iv , :, ikxkyz )) end do end do ! gvmu now contains dhs/dupars ! need to get -Ps[dhs/dupars] for phi equation ! need to get 1-Us[dhs/dupars] for momentum conservation ! need to get -Qs[dhs/dupars] for energy conservation call get_fields_by_spec ( gvmu , field , skip_fsa = . true .) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) mudiff_response ( 1 , idx : idx + nspec - 1 , ikxkyz ) = - field ( iky , ikx , iz , it , :) end do call get_uperp ( gvmu , field ) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) do is = 1 , nspec mudiff_response ( idx + is - 1 , idx + is - 1 , ikxkyz ) = 1.0 - field ( iky , ikx , iz , it , is ) end do end do if ( energy_conservation ) then call get_temp_mu ( gvmu , field ) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) do is = 1 , nspec mudiff_response ( idx + is + nspec - 1 , idx + is - 1 , ikxkyz ) = - field ( iky , ikx , iz , it , is ) end do end do end if idx = idx + nspec end if if ( energy_conservation ) then do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) do iv = 1 , nvpa gvmu ( iv , :, ikxkyz ) = 2.0 * code_dt * spec ( is )% vnew ( is ) * ( vpa ( iv ) ** 2 + vperp2 ( 1 , iz , :) - 1.5 ) & * aj0v (:, ikxkyz ) * maxwell_vpa ( iv , is ) * maxwell_mu ( 1 , iz , :, is ) call tridag ( 1 , aa_mu ( iz , :, is ), bb_mu (:, ikxkyz ), cc_mu ( iz , :, is ), gvmu ( iv , :, ikxkyz )) end do end do ! gvmu now contains dhs/dQs ! need to get -Ps[dhs/dQs] for phi equation ! need to get 1-Us[dhs/dQs] for momentum conservation ! need to get -Qs[dhs/dQs] for energy conservation call get_fields_by_spec ( gvmu , field , skip_fsa = . true .) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) mudiff_response ( 1 , idx : idx + nspec - 1 , ikxkyz ) = - field ( iky , ikx , iz , it , :) end do if ( momentum_conservation ) then call get_uperp ( gvmu , field ) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) do is = 1 , nspec mudiff_response ( idx + is - 1 - nspec , idx + is - 1 , ikxkyz ) = - field ( iky , ikx , iz , it , is ) end do end do end if call get_temp_mu ( gvmu , field ) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) do is = 1 , nspec mudiff_response ( idx + is - 1 , idx + is - 1 , ikxkyz ) = 1.0 - field ( iky , ikx , iz , it , is ) end do end do end if ! now get LU decomposition for mudiff_response do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc call lu_decomposition ( mudiff_response (:, :, ikxkyz ), mudiff_idx (:, ikxkyz ), dum2 ) end do ! if electrons are adiabatic, compute the matrices for the flux-surface-average if (. not . has_electron_species ( spec ) . and . zonal_mode ( 1 ) & . and . adiabatic_option_switch == adiabatic_option_fieldlineavg ) then allocate ( temp_mat ( nresponse_mu , nresponse_mu )) mudiff_zf_response = 0.0 do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) if ( iky /= 1 . or . it /= 1 ) cycle !calculate inverse of mudiff_response call lu_inverse ( mudiff_response (:, :, ikxkyz ), mudiff_idx (:, ikxkyz ), temp_mat ) !calculate -inv(mudiff_response).Q, where Q has a single entry do idx = 1 , nresponse_mu mudiff_zf_response ( idx , 1 , ikx ) = mudiff_zf_response ( idx , 1 , ikx ) & - temp_mat ( idx , 1 ) * ( efac / gamtot_h ) * dl_over_b ( ia , iz ) end do end do !finish the flux surface average call sum_allreduce ( mudiff_zf_response ) !calculate 1 - fsa(inv(mudiff_response).Q) do idx = 1 , nresponse_mu mudiff_zf_response ( idx , idx , :) = mudiff_zf_response ( idx , idx , :) + 1.0 end do do ikx = 1 , nakx call lu_decomposition ( mudiff_zf_response (:, :, ikx ), mudiff_zf_idx (:, ikx ), dum2 ) end do deallocate ( temp_mat ) end if deallocate ( dum1 , field ) end subroutine init_mudiff_conserve subroutine get_upar ( g , fld ) use mp , only : sum_allreduce use zgrid , only : nzgrid use vpamu_grids , only : integrate_vmu use vpamu_grids , only : nvpa , nmu use vpamu_grids , only : vpa use stella_layouts , only : kxkyz_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , it_idx , is_idx use gyro_averages , only : aj0v implicit none complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :, :), intent ( out ) :: fld integer :: ikxkyz , iky , ikx , iz , it , is complex , dimension (:, :), allocatable :: g0 allocate ( g0 ( nvpa , nmu )) fld = 0. do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) g0 = g (:, :, ikxkyz ) * spread ( vpa , 2 , nmu ) * spread ( aj0v (:, ikxkyz ), 1 , nvpa ) call integrate_vmu ( g0 , iz , fld ( iky , ikx , iz , it , is )) end do deallocate ( g0 ) call sum_allreduce ( fld ) end subroutine get_upar subroutine get_uperp ( g , fld ) use mp , only : sum_allreduce use zgrid , only : nzgrid use vpamu_grids , only : integrate_vmu use vpamu_grids , only : nvpa , nmu use vpamu_grids , only : vperp2 use stella_layouts , only : kxkyz_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , it_idx , is_idx use gyro_averages , only : aj1v implicit none complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :, :), intent ( out ) :: fld integer :: ikxkyz , iky , ikx , iz , it , is complex , dimension (:, :), allocatable :: g0 allocate ( g0 ( nvpa , nmu )) fld = 0. do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) !       g0 = 2.0*g(:,:,ikxkyz)*spread((vperp2(1,iz,:)-0.5)*aj1v(:,ikxkyz),1,nvpa) g0 = g (:, :, ikxkyz ) * spread (( vperp2 ( 1 , iz , :) - 0.5 ) * aj1v (:, ikxkyz ), 1 , nvpa ) call integrate_vmu ( g0 , iz , fld ( iky , ikx , iz , it , is )) end do deallocate ( g0 ) call sum_allreduce ( fld ) end subroutine get_uperp subroutine get_temp ( g , fld ) use mp , only : sum_allreduce use zgrid , only : nzgrid use vpamu_grids , only : integrate_vmu use vpamu_grids , only : nvpa , nmu use vpamu_grids , only : vpa use stella_layouts , only : kxkyz_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , it_idx , is_idx use gyro_averages , only : aj0v implicit none complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :, :), intent ( out ) :: fld integer :: ikxkyz , iky , ikx , iz , it , is complex , dimension (:, :), allocatable :: g0 allocate ( g0 ( nvpa , nmu )) fld = 0. do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) g0 = g (:, :, ikxkyz ) * ( spread ( vpa ** 2 , 2 , nmu ) - 0.5 ) & * spread ( aj0v (:, ikxkyz ), 1 , nvpa ) / 1.5 call integrate_vmu ( g0 , iz , fld ( iky , ikx , iz , it , is )) end do deallocate ( g0 ) call sum_allreduce ( fld ) end subroutine get_temp subroutine get_temp_mu ( g , fld ) use mp , only : sum_allreduce use zgrid , only : nzgrid use vpamu_grids , only : integrate_vmu use vpamu_grids , only : nvpa , nmu , vperp2 use stella_layouts , only : kxkyz_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , it_idx , is_idx use gyro_averages , only : aj0v implicit none complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :, :), intent ( out ) :: fld integer :: ikxkyz , iky , ikx , iz , it , is complex , dimension (:, :), allocatable :: g0 allocate ( g0 ( nvpa , nmu )) fld = 0. do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) g0 = g (:, :, ikxkyz ) * ( spread ( vperp2 ( 1 , iz , :), 1 , nvpa ) - 1.0 ) & * spread ( aj0v (:, ikxkyz ), 1 , nvpa ) / 1.5 call integrate_vmu ( g0 , iz , fld ( iky , ikx , iz , it , is )) end do deallocate ( g0 ) call sum_allreduce ( fld ) end subroutine get_temp_mu subroutine finish_dissipation implicit none call finish_collisions end subroutine finish_dissipation subroutine finish_collisions implicit none if ( collisions_implicit ) then call finish_vpadiff_matrix call finish_mudiff_matrix call finish_vpadiff_response call finish_mudiff_response end if if ( collision_model == \"fokker-planck\" ) then call finish_nusDpa call finish_fp_diffmatrix call finish_fp_response call finish_deltaj end if collisions_initialized = . false . end subroutine finish_collisions subroutine finish_deltaj implicit none if ( allocated ( deltaj )) deallocate ( deltaj ) if ( allocated ( psijnorm )) deallocate ( psijnorm ) if ( allocated ( mwnorm )) deallocate ( mwnorm ) end subroutine finish_deltaj subroutine finish_fp_diffmatrix implicit none if ( allocated ( aa_vpa )) deallocate ( aa_vpa ) if ( allocated ( bb_vpa )) deallocate ( bb_vpa ) if ( allocated ( cc_vpa )) deallocate ( cc_vpa ) if ( allocated ( aa_blcs )) deallocate ( aa_blcs ) if ( allocated ( bb_blcs )) deallocate ( bb_blcs ) if ( allocated ( cc_blcs )) deallocate ( cc_blcs ) if ( allocated ( cdiffmat_band )) deallocate ( cdiffmat_band ) if ( allocated ( blockmatrix )) deallocate ( blockmatrix ) if ( allocated ( blockmatrix_sum )) deallocate ( blockmatrix_sum ) end subroutine finish_fp_diffmatrix subroutine finish_fp_response implicit none if ( allocated ( fp_response )) deallocate ( fp_response ) if ( allocated ( diff_idx )) deallocate ( diff_idx ) end subroutine finish_fp_response subroutine finish_vpadiff_matrix implicit none if ( allocated ( aa_vpa )) deallocate ( aa_vpa ) if ( allocated ( bb_vpa )) deallocate ( bb_vpa ) if ( allocated ( cc_vpa )) deallocate ( cc_vpa ) end subroutine finish_vpadiff_matrix subroutine finish_mudiff_matrix implicit none if ( allocated ( aa_mu )) deallocate ( aa_mu ) if ( allocated ( bb_mu )) deallocate ( bb_mu ) if ( allocated ( cc_mu )) deallocate ( cc_mu ) end subroutine finish_mudiff_matrix subroutine finish_vpadiff_response implicit none if ( allocated ( vpadiff_response )) deallocate ( vpadiff_response ) if ( allocated ( vpadiff_idx )) deallocate ( vpadiff_idx ) end subroutine finish_vpadiff_response subroutine finish_mudiff_response implicit none if ( allocated ( mudiff_response )) deallocate ( mudiff_response ) if ( allocated ( mudiff_idx )) deallocate ( mudiff_idx ) end subroutine finish_mudiff_response subroutine advance_collisions_explicit ( g , phi , gke_rhs ) use mp , only : proc0 , mp_abort use job_manage , only : time_message use redistribute , only : scatter , gather use stella_time , only : code_dt use zgrid , only : nzgrid , ntubes use species , only : spec use run_parameters , only : fphi use physics_flags , only : radial_variation , full_flux_surface use kt_grids , only : naky , nakx , multiply_by_rho , rho_d_clamped use vpamu_grids , only : nvpa , nmu use vpamu_grids , only : set_vpa_weights use stella_geometry , only : bmag , dBdrho use stella_layouts , only : vmu_lo , kxkyz_lo use stella_layouts , only : is_idx , iky_idx , ikx_idx , iz_idx use dist_redistribute , only : kxkyz2vmu use dist_fn_arrays , only : gvmu , kperp2 , dkperp2dr use fields_arrays , only : phi_corr_QN use g_tofrom_h , only : g_to_h use stella_transforms , only : transform_kx2x_unpadded , transform_x2kx_unpadded implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: phi complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: gke_rhs integer :: is , ikxkyz , imu , iv , ivmu , ikx , iky , iz , ia , it logical :: conservative_wgts real :: tfac , kfac complex , dimension (:), allocatable :: mucoll complex , dimension (:, :, :), allocatable :: coll complex , dimension (:, :, :, :, :), allocatable :: tmp_vmulo complex , dimension (:, :, :), allocatable :: mucoll_fp complex , dimension (:, :, :), allocatable :: coll_fp complex , dimension (:, :), allocatable :: g0k , g0x ia = 1 if ( full_flux_surface ) then call mp_abort ( \"collisions not currently supported for full_flux_surface=T.  Aborting.\" ) end if if ( proc0 ) call time_message (. false ., time_collisions (:, 1 ), ' collisions' ) kfac = 0.0 if ( mu_operator ) kfac = kfac + 0.5 if ( vpa_operator ) kfac = kfac + 0.5 allocate ( tmp_vmulo ( naky , nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) ! want exact conservation properties for collision operator conservative_wgts = . true . call set_vpa_weights ( conservative_wgts ) if ( radial_variation ) then allocate ( g0k ( naky , nakx )) allocate ( g0x ( naky , nakx )) !TODO (DSO) - could perhaps operator split the profile variation pieces off the main pieces, and so !             this portion of the code could just treat the terms that vary in x if ( collision_model == \"dougherty\" ) then ! switch from g = <f> to h = f + Z*e*phi/T * F0 tmp_vmulo = g call g_to_h ( tmp_vmulo , phi , fphi , phi_corr_QN ) !handle gyroviscous term do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) do it = 1 , ntubes do iz = - nzgrid , nzgrid g0k = 0.5 * kfac * tmp_vmulo (:, :, iz , it , ivmu ) * kperp2 (:, :, ia , iz ) * ( spec ( is )% smz / bmag ( ia , iz )) ** 2 gke_rhs (:, :, iz , it , ivmu ) = gke_rhs (:, :, iz , it , ivmu ) - code_dt * spec ( is )% vnew ( is ) * g0k g0k = g0k * ( dkperp2dr (:, :, ia , iz ) - 2.0 * dBdrho ( iz ) / bmag ( ia , iz ) - spec ( is )% tprim ) call multiply_by_rho ( g0k ) gke_rhs (:, :, iz , it , ivmu ) = gke_rhs (:, :, iz , it , ivmu ) - code_dt * spec ( is )% vnew ( is ) * g0k end do end do end do !handle the conservation terms if ( momentum_conservation ) call conserve_momentum_vmulo ( tmp_vmulo , gke_rhs ) if ( energy_conservation ) call conserve_energy_vmulo ( tmp_vmulo , gke_rhs ) !since Bessel functions do not appear under the velocity derivatives, these terms are one-point in x space ! and we can simply inverse Fourier transform do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid call transform_kx2x_unpadded ( tmp_vmulo (:, :, iz , it , ivmu ), g0x ) tmp_vmulo (:, :, iz , it , ivmu ) = g0x end do end do end do ! remap so that (vpa,mu) local if ( proc0 ) call time_message (. false ., time_collisions (:, 2 ), ' coll_redist' ) call scatter ( kxkyz2vmu , tmp_vmulo , gvmu ) if ( proc0 ) call time_message (. false ., time_collisions (:, 2 ), ' coll_redist' ) ! take vpa derivatives allocate ( coll ( nvpa , nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) allocate ( mucoll ( nmu )) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) if ( vpa_operator ) then !fix the temperature term tfac = ( spec ( is )% temp / spec ( is )% temp_psi0 ) * ( 1.0 - rho_d_clamped ( ikx ) * spec ( is )% tprim ) do imu = 1 , nmu call vpa_differential_operator ( tfac , gvmu (:, imu , ikxkyz ), coll (:, imu , ikxkyz )) end do else coll (:, :, ikxkyz ) = 0.0 end if if ( mu_operator ) then !fix the temperature/bmag term tfac = ( spec ( is )% temp / spec ( is )% temp_psi0 ) & * ( 1.0 - rho_d_clamped ( ikx ) * ( spec ( is )% tprim + dBdrho ( iz ) / bmag ( ia , iz ))) do iv = 1 , nvpa call mu_differential_operator ( tfac , iz , ia , gvmu ( iv , :, ikxkyz ), mucoll ) coll ( iv , :, ikxkyz ) = coll ( iv , :, ikxkyz ) + mucoll end do end if gvmu (:, :, ikxkyz ) = coll (:, :, ikxkyz ) end do deallocate ( coll , mucoll ) ! remap so that (ky,kx,z,tube) local call gather ( kxkyz2vmu , gvmu , tmp_vmulo ) !don't forget to Fourier transform do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) do it = 1 , ntubes do iz = - nzgrid , nzgrid call transform_x2kx_unpadded ( tmp_vmulo (:, :, iz , it , ivmu ), g0k ) tmp_vmulo (:, :, iz , it , ivmu ) = g0k end do end do end do do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) gke_rhs (:, :, :, :, ivmu ) = gke_rhs (:, :, :, :, ivmu ) + code_dt * spec ( is )% vnew ( is ) * tmp_vmulo (:, :, :, :, ivmu ) end do end if deallocate ( g0k , g0x ) else ! switch from g = <f> to h = f + Z*e*phi/T * F0 tmp_vmulo = g call g_to_h ( tmp_vmulo , phi , fphi ) ! remap so that (vpa,mu) local if ( proc0 ) call time_message (. false ., time_collisions (:, 2 ), ' coll_redist' ) call scatter ( kxkyz2vmu , tmp_vmulo , gvmu ) if ( proc0 ) call time_message (. false ., time_collisions (:, 2 ), ' coll_redist' ) ia = 1 ! take vpa derivatives if ( collision_model == \"dougherty\" ) then allocate ( coll ( nvpa , nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) allocate ( mucoll ( nmu )) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) if ( vpa_operator ) then do imu = 1 , nmu call vpa_differential_operator ( 1.0 , gvmu (:, imu , ikxkyz ), coll (:, imu , ikxkyz )) end do else coll (:, :, ikxkyz ) = 0.0 end if if ( mu_operator ) then do iv = 1 , nvpa call mu_differential_operator ( 1.0 , iz , ia , gvmu ( iv , :, ikxkyz ), mucoll ) coll ( iv , :, ikxkyz ) = coll ( iv , :, ikxkyz ) + mucoll end do end if if ( momentum_conservation ) call conserve_momentum ( iky , ikx , iz , is , ikxkyz , gvmu (:, :, ikxkyz ), coll (:, :, ikxkyz )) if ( energy_conservation ) call conserve_energy ( iz , is , ikxkyz , gvmu (:, :, ikxkyz ), coll (:, :, ikxkyz )) ! save memory by using gvmu and deallocating coll below ! before re-allocating tmp_vmulo gvmu (:, :, ikxkyz ) = coll (:, :, ikxkyz ) - 0.5 * kfac * kperp2 ( iky , ikx , ia , iz ) * ( spec ( is )% smz / bmag ( ia , iz )) ** 2 * gvmu (:, :, ikxkyz ) end do deallocate ( coll , mucoll ) ! remap so that (ky,kx,z,tube) local call gather ( kxkyz2vmu , gvmu , tmp_vmulo ) do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) gke_rhs (:, :, :, :, ivmu ) = gke_rhs (:, :, :, :, ivmu ) + code_dt * spec ( is )% vnew ( is ) * tmp_vmulo (:, :, :, :, ivmu ) end do end if if ( collision_model == \"fokker-planck\" ) then allocate ( coll_fp ( nvpa , nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )); coll_fp = 0.0 allocate ( mucoll_fp ( nvpa , nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )); mucoll_fp = 0.0 if ( density_conservation ) then do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) if ( vpa_operator ) then do imu = 1 , nmu call vpa_differential_operator_fp_conservative ( gvmu (:, :, ikxkyz ), coll_fp (:, :, ikxkyz ), imu , iz , is , ia ) end do end if if ( mu_operator ) then do iv = 1 , nvpa call mu_differential_operator_fp_conservative ( gvmu (:, :, ikxkyz ), mucoll_fp (:, :, ikxkyz ), iv , iz , is , ia , iky , ikx , cfac ) end do end if gvmu (:, :, ikxkyz ) = coll_fp (:, :, ikxkyz ) + mucoll_fp (:, :, ikxkyz ) end do else do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) if ( vpa_operator ) then do imu = 1 , nmu call vpa_differential_operator_fp ( gvmu (:, :, ikxkyz ), coll_fp (:, :, ikxkyz ), imu , iz , is , ia ) end do end if if ( mu_operator ) then do iv = 1 , nvpa call mu_differential_operator_fp ( gvmu (:, :, ikxkyz ), mucoll_fp (:, :, ikxkyz ), iv , iz , is , ia , iky , ikx , cfac ) end do end if gvmu (:, :, ikxkyz ) = coll_fp (:, :, ikxkyz ) + mucoll_fp (:, :, ikxkyz ) end do end if deallocate ( coll_fp , mucoll_fp ) call gather ( kxkyz2vmu , gvmu , tmp_vmulo ) do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc gke_rhs (:, :, :, :, ivmu ) = gke_rhs (:, :, :, :, ivmu ) + code_dt * tmp_vmulo (:, :, :, :, ivmu ) end do end if end if deallocate ( tmp_vmulo ) ! reset to default integration wgts conservative_wgts = . false . call set_vpa_weights ( conservative_wgts ) if ( proc0 ) call time_message (. false ., time_collisions (:, 1 ), ' collisions' ) end subroutine advance_collisions_explicit subroutine vpa_differential_operator_fp ( h , Dh , imu , iz , is , ia ) use vpamu_grids , only : nvpa , vpa , dvpa , mu , dmu , nmu , equally_spaced_mu_grid , maxwell_mu use stella_geometry , only : bmag use constants , only : pi use species , only : spec implicit none complex , dimension (:, :), intent ( out ) :: Dh complex , dimension (:, :), intent ( in ) :: h integer , intent ( in ) :: imu , iz , ia , is integer :: iv complex :: dmuhp , dmuhm , dvpahp , dvpahm real :: xp , xm , vpap , vpam , nupap , nupam , nuDp , nuDm , mwp , mwm iv = 1 vpap = 0.5 * ( vpa ( iv ) + vpa ( iv + 1 )) xp = sqrt ( vpap ** 2 + 2 * bmag ( ia , iz ) * mu ( imu )) nuDp = spec ( is )% vnew ( is ) * ( erf ( xp ) - ( erf ( xp ) - xp * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 )) / ( 2 * xp ** 2 )) / xp ** 3 nupap = spec ( is )% vnew ( is ) * 2 * ( erf ( xp ) - xp * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 )) / ( 2 * xp ** 2 ) / xp ** 3 mwp = exp ( - vpap ** 2 ) * maxwell_mu ( 1 , iz , imu , is ) dvpahp = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv , imu ) / mw ( iv , imu , iz , is )) / dvpa if ( imu == 1 ) then ! second-order accurate !a = -(2.*dmu(1) + dmu(2))/(dmu(1)*(dmu(1)+dmu(2))) !b = (dmu(1)+dmu(2))/(dmu(1)*dmu(2)) !c = -dmu(1)/(dmu(2)*(dmu(1)+dmu(2))) !dmuhp = a*h(iv+1,imu)/mw(iv+1,imu,iz,is)+ b*h(iv+1,imu+1)/mw(iv+1,imu+1,iz,is) + c*h(iv+1,imu+2)/mw(iv+1,imu+2,iz) ! first-order accurate, as in implicit routine: dmuhp = ( h ( iv + 1 , imu + 1 ) / mw ( iv + 1 , imu + 1 , iz , is ) - h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is )) / dmu ( imu ) else if ( imu == nmu ) then ! second-order accurate !a = dmu(nmu-1)/(dmu(nmu-2)*(dmu(nmu-2)+dmu(nmu-1))) !b = -(dmu(nmu-1)+dmu(nmu-2))/(dmu(nmu-2)*dmu(nmu-1)) !c = (2.*dmu(nmu-1)+dmu(nmu-2))/(dmu(nmu-1)*(dmu(nmu-1)+dmu(nmu-2))) !dmuhp = a*h(iv+1,imu-2)/mw(iv+1,imu-2,iz) + b*h(iv+1,imu-1)/mw(iv+1,imu-1,iz,is) + c*h(iv+1,imu)/mw(iv+1,imu,iz,is) ! first-order accurate, as in implicit routine: dmuhp = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv + 1 , imu - 1 ) / mw ( iv + 1 , imu - 1 , iz , is )) / dmu ( imu - 1 ) else dmuhp = (( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv + 1 , imu - 1 ) / mw ( iv + 1 , imu - 1 , iz , is )) * dmu ( imu ) / dmu ( imu - 1 ) & + ( h ( iv + 1 , imu + 1 ) / mw ( iv + 1 , imu + 1 , iz , is ) - h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is )) * dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) end if Dh ( iv , imu ) = ( 2 * 0.5 * ( nupap * vpap ** 2 + 2 * nuDp * bmag ( ia , iz ) * mu ( imu )) * mwp * dvpahp + vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , is ) * mw ( iv + 1 , imu , iz , is ) * dmuhp ) / ( 2 * dvpa ) iv = nvpa vpam = 0.5 * ( vpa ( iv ) + vpa ( iv - 1 )) xm = sqrt ( vpam ** 2 + 2 * bmag ( ia , iz ) * mu ( imu )) nuDm = spec ( is )% vnew ( is ) * ( erf ( xm ) - ( erf ( xm ) - xm * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 )) / ( 2 * xm ** 2 )) / xm ** 3 nupam = spec ( is )% vnew ( is ) * 2 * ( erf ( xm ) - xm * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 )) / ( 2 * xm ** 2 ) / xm ** 3 mwm = exp ( - vpam ** 2 ) * maxwell_mu ( 1 , iz , imu , is ) dvpahm = ( h ( iv , imu ) / mw ( iv , imu , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / dvpa if ( imu == 1 ) then ! second-order accurate !a = -(2.*dmu(1) + dmu(2))/(dmu(1)*(dmu(1)+dmu(2))) !b = (dmu(1)+dmu(2))/(dmu(1)*dmu(2)) !c = -dmu(1)/(dmu(2)*(dmu(1)+dmu(2))) !dmuhm = a*h(iv-1,imu)/mw(iv-1,imu,iz,is) + b*h(iv-1,imu+1)/mw(iv-1,imu+1,iz,is) + c*h(iv-1,imu+2)/mw(iv-1,imu+2,iz) ! first-order accurate, as in implicit routine: dmuhm = ( h ( iv - 1 , imu + 1 ) / mw ( iv - 1 , imu + 1 , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / dmu ( imu ) else if ( imu == nmu ) then ! second-order accurate !a = dmu(nmu-1)/(dmu(nmu-2)*(dmu(nmu-2)+dmu(nmu-1))) !b = -(dmu(nmu-1)+dmu(nmu-2))/(dmu(nmu-2)*dmu(nmu-1)) !c = (2.*dmu(nmu-1)+dmu(nmu-2))/(dmu(nmu-1)*(dmu(nmu-1)+dmu(nmu-2))) !dmuhm = a*h(iv-1,imu-2)/mw(iv-1,imu-2,iz) + b*h(iv-1,imu-1)/mw(iv-1,imu-1,iz,is) + c*h(iv-1,imu)/mw(iv-1,imu,iz,is) ! first-order accurate, as in implicit routine: dmuhm = ( h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is ) - h ( iv - 1 , imu - 1 ) / mw ( iv - 1 , imu - 1 , iz , is )) / dmu ( imu - 1 ) else dmuhm = (( h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is ) - h ( iv - 1 , imu - 1 ) / mw ( iv - 1 , imu - 1 , iz , is )) * dmu ( imu ) / dmu ( imu - 1 ) & + ( h ( iv - 1 , imu + 1 ) / mw ( iv - 1 , imu + 1 , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) * dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) end if Dh ( iv , imu ) = ( - 2 * 0.5 * ( nupam * vpam ** 2 + 2 * nuDm * bmag ( ia , iz ) * mu ( imu )) * mwm * dvpahm - vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , is ) * mw ( iv - 1 , imu , iz , is ) * dmuhm ) / ( 2 * dvpa ) do iv = 2 , nvpa - 1 ! AVB: interior nodes: ! quantities at half-grid-points: vpap = 0.5 * ( vpa ( iv ) + vpa ( iv + 1 )) vpam = 0.5 * ( vpa ( iv ) + vpa ( iv - 1 )) xp = sqrt ( vpap ** 2 + 2 * bmag ( ia , iz ) * mu ( imu )) xm = sqrt ( vpam ** 2 + 2 * bmag ( ia , iz ) * mu ( imu )) nuDp = spec ( is )% vnew ( is ) * ( erf ( xp ) - ( erf ( xp ) - xp * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 )) / ( 2 * xp ** 2 )) / xp ** 3 nuDm = spec ( is )% vnew ( is ) * ( erf ( xm ) - ( erf ( xm ) - xm * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 )) / ( 2 * xm ** 2 )) / xm ** 3 nupap = spec ( is )% vnew ( is ) * 2 * ( erf ( xp ) - xp * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 )) / ( 2 * xp ** 2 ) / xp ** 3 nupam = spec ( is )% vnew ( is ) * 2 * ( erf ( xm ) - xm * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 )) / ( 2 * xm ** 2 ) / xm ** 3 mwp = exp ( - vpap ** 2 ) * maxwell_mu ( 1 , iz , imu , is ) mwm = exp ( - vpam ** 2 ) * maxwell_mu ( 1 , iz , imu , is ) dvpahp = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv , imu ) / mw ( iv , imu , iz , is )) / dvpa dvpahm = ( h ( iv , imu ) / mw ( iv , imu , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / dvpa if ( imu == 1 ) then ! second-order accurate: !a = -(2.*dmu(1) + dmu(2))/(dmu(1)*(dmu(1)+dmu(2))) !b = (dmu(1)+dmu(2))/(dmu(1)*dmu(2)) !c = -dmu(1)/(dmu(2)*(dmu(1)+dmu(2))) !dmuhp = a*h(iv+1,imu)/mw(iv+1,imu,iz,is) + b*h(iv+1,imu+1)/mw(iv+1,imu+1,iz,is) + c*h(iv+1,imu+2)/mw(iv+1,imu+2,iz) !dmuhm = a*h(iv-1,imu)/mw(iv-1,imu,iz,is) + b*h(iv-1,imu+1)/mw(iv-1,imu+1,iz,is) + c*h(iv-1,imu+2)/mw(iv-1,imu+2,iz) ! or first-order accurate, as in implicit routine: dmuhp = ( h ( iv + 1 , imu + 1 ) / mw ( iv + 1 , imu + 1 , iz , is ) - h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is )) / dmu ( imu ) dmuhm = ( h ( iv - 1 , imu + 1 ) / mw ( iv - 1 , imu + 1 , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / dmu ( imu ) else if ( imu == nmu ) then ! second-order accurate: !a = dmu(nmu-1)/(dmu(nmu-2)*(dmu(nmu-2)+dmu(nmu-1))) !b = -(dmu(nmu-1)+dmu(nmu-2))/(dmu(nmu-2)*dmu(nmu-1)) !c = (2.*dmu(nmu-1)+dmu(nmu-2))/(dmu(nmu-1)*(dmu(nmu-1)+dmu(nmu-2))) !dmuhp = a*h(iv+1,imu-2)/mw(iv+1,imu-2,iz) + b*h(iv+1,imu-1)/mw(iv+1,imu-1,iz,is) + c*h(iv+1,imu)/mw(iv+1,imu,iz,is) !dmuhm = a*h(iv-1,imu-2)/mw(iv-1,imu-2,iz) + b*h(iv-1,imu-1)/mw(iv-1,imu-1,iz,is) + c*h(iv-1,imu)/mw(iv-1,imu,iz,is) ! or first-order accurate, as in implicit routine: dmuhp = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv + 1 , imu - 1 ) / mw ( iv + 1 , imu - 1 , iz , is )) / dmu ( imu - 1 ) dmuhm = ( h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is ) - h ( iv - 1 , imu - 1 ) / mw ( iv - 1 , imu - 1 , iz , is )) / dmu ( imu - 1 ) else dmuhp = (( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv + 1 , imu - 1 ) / mw ( iv + 1 , imu - 1 , iz , is )) * dmu ( imu ) / dmu ( imu - 1 ) & + ( h ( iv + 1 , imu + 1 ) / mw ( iv + 1 , imu + 1 , iz , is ) - h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is )) * dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) dmuhm = (( h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is ) - h ( iv - 1 , imu - 1 ) / mw ( iv - 1 , imu - 1 , iz , is )) * dmu ( imu ) / dmu ( imu - 1 ) & + ( h ( iv - 1 , imu + 1 ) / mw ( iv - 1 , imu + 1 , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) * dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) end if Dh ( iv , imu ) = ( 2 * 0.5 * ( nupap * vpap ** 2 + 2 * nuDp * bmag ( ia , iz ) * mu ( imu )) * mwp * dvpahp & + vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , is ) * mw ( iv + 1 , imu , iz , is ) * dmuhp & - 2 * 0.5 * ( nupam * vpam ** 2 + 2 * nuDm * bmag ( ia , iz ) * mu ( imu )) * mwm * dvpahm & - vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , is ) * mw ( iv - 1 , imu , iz , is ) * dmuhm ) / ( 2 * dvpa ) end do end subroutine vpa_differential_operator_fp subroutine mu_differential_operator_fp ( h , Dh , iv , iz , is , ia , iky , ikx , cfac ) use vpamu_grids , only : nmu , mu , dmu , vpa , dvpa , nvpa , maxwell_vpa , equally_spaced_mu_grid use stella_geometry , only : bmag use species , only : spec use dist_fn_arrays , only : kperp2 use constants , only : pi use job_manage , only : timer_local , time_message implicit none complex , dimension (:, :), intent ( in ) :: h complex , dimension (:, :), intent ( out ) :: Dh integer , intent ( in ) :: iv , iz , is , ia , iky , ikx real , intent ( in ) :: cfac complex :: Dvpah , Dvpah_p , Dvpah_m , Dmuh , Dmuh_m , Dmuh_p , Dmuh1 , Dmuh2 real :: nuDp , nuDm , nupap , nupam , mup , mum , xp , xm , mwm , mwp integer :: imu imu = 1 ! vpa-differential terms: if ( iv == 1 ) then ! AVB: first order accurate: Dvpah = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv , imu ) / mw ( iv , imu , iz , is )) / dvpa Dvpah_p = ( h ( iv + 1 , imu + 1 ) / mw ( iv + 1 , imu + 1 , iz , is ) - h ( iv , imu + 1 ) / mw ( iv , imu + 1 , iz , is )) / dvpa else if ( iv == nvpa ) then ! AVB: first order accurate: Dvpah = ( h ( iv , imu ) / mw ( iv , imu , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / dvpa Dvpah_p = ( h ( iv , imu + 1 ) / mw ( iv , imu + 1 , iz , is ) - h ( iv - 1 , imu + 1 ) / mw ( iv - 1 , imu + 1 , iz , is )) / dvpa else Dvpah = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / ( 2 * dvpa ) Dvpah_p = ( h ( iv + 1 , imu + 1 ) / mw ( iv + 1 , imu + 1 , iz , is ) - h ( iv - 1 , imu + 1 ) / mw ( iv - 1 , imu + 1 , iz , is )) / ( 2 * dvpa ) end if ! first mu-derivative term at mu_{i}: ! use ghost cell at mu_{0} = 0, where mu*vpa*nux(vpa,mu)*F0 vanishes, dmu(0) = mu(1). Dmuh1 = (( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , is ) * mw ( iv , imu , iz , is ) * Dvpah ) * dmu ( imu ) / mu ( imu ) & + ( vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , is ) * mw ( iv , imu + 1 , iz , is ) * Dvpah_p - vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , is ) * mw ( iv , imu , iz , is ) * Dvpah ) * mu ( imu ) / dmu ( imu )) / ( mu ( imu ) + dmu ( imu )) ! first derivative of h, at mu_{i+1/2}, and at mu_i: Dmuh = ( h ( iv , imu + 1 ) / mw ( iv , imu + 1 , iz , is ) - h ( iv , imu ) / mw ( iv , imu , iz , is )) / dmu ( imu ) ! first-order accurate, as used in implicit routine ! for second-order accuracy: !a = -(2.*dmu(1) + dmu(2))/(dmu(1)*(dmu(1)+dmu(2))) !b = (dmu(1)+dmu(2))/(dmu(1)*dmu(2)) !c = -dmu(1)/(dmu(2)*(dmu(1)+dmu(2))) !Dmuh   = a*h(iv,imu)/mw(iv,imu,iz,is) + b*h(iv,imu+1)/mw(iv,imu+1,iz,is) + c*h(iv,imu+2)/mw(iv,imu+2,iz) ! second order accurate Dmuh_p = ( h ( iv , imu + 1 ) / mw ( iv , imu + 1 , iz , is ) - h ( iv , imu ) / mw ( iv , imu , iz , is )) / dmu ( imu ) ! second-order accurate ! quantities at mu_{i+1/2}: mup = 0.5 * ( mu ( imu ) + mu ( imu + 1 )) mwp = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mup ) xp = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mup ) nuDp = spec ( is )% vnew ( is ) * ( erf ( xp ) - ( erf ( xp ) - xp * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 )) / ( 2 * xp ** 2 )) / xp ** 3 nupap = spec ( is )% vnew ( is ) * 2 * ( erf ( xp ) - xp * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 )) / ( 2 * xp ** 2 ) / xp ** 3 ! second mu-derivative term at mu_{i}: ! use d/dmu[...]_{1} = ([...]_{1+1/2} - [...]_{0})/(dmu_{1}/2+mu(1)), where [...]_{0} is a ghost cell at mu_{0} = 0, with [...]_{0} = 0. Dmuh2 = ( ( 2 * ( nupa ( iv , imu , iz , is , is ) * mu ( imu ) ** 2 + nuD ( iv , imu , iz , is , is ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mu ( imu )) * mw ( iv , imu , iz , is ) * Dmuh ) * dmu ( imu ) / 2. / mu ( imu ) & + ( 2 * ( nupap * mup ** 2 + nuDp * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mup ) * mwp * Dmuh_p & - 2 * ( nupa ( iv , imu , iz , is , is ) * mu ( imu ) ** 2 + nuD ( iv , imu , iz , is , is ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mu ( imu )) * mw ( iv , imu , iz , is ) * Dmuh ) * mu ( imu ) / ( dmu ( imu ) / 2. ) ) / ( mu ( imu ) + dmu ( imu ) / 2. ) ! add differential terms and gyro-diffusive term: Dh ( iv , imu ) = Dmuh2 + Dmuh1 - cfac * 0.5 * kperp2 ( iky , ikx , ia , iz ) * ( spec ( is )% smz / bmag ( ia , iz )) ** 2 & * ( nupa ( iv , imu , iz , is , is ) * bmag ( ia , iz ) * mu ( imu ) + nuD ( iv , imu , iz , is , is ) * ( vpa ( iv ) ** 2 + bmag ( ia , iz ) * mu ( imu ))) * h ( iv , imu ) imu = nmu ! vpa-differential terms: if ( iv == 1 ) then ! AVB: first order accurate: Dvpah = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv , imu ) / mw ( iv , imu , iz , is )) / dvpa Dvpah_m = ( h ( iv + 1 , imu - 1 ) / mw ( iv + 1 , imu - 1 , iz , is ) - h ( iv , imu - 1 ) / mw ( iv , imu - 1 , iz , is )) / dvpa else if ( iv == nvpa ) then ! AVB: first order accurate: Dvpah = ( h ( iv , imu ) / mw ( iv , imu , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / dvpa Dvpah_m = ( h ( iv , imu - 1 ) / mw ( iv , imu - 1 , iz , is ) - h ( iv - 1 , imu - 1 ) / mw ( iv - 1 , imu - 1 , iz , is )) / dvpa else Dvpah = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / ( 2 * dvpa ) Dvpah_m = ( h ( iv + 1 , imu - 1 ) / mw ( iv + 1 , imu - 1 , iz , is ) - h ( iv - 1 , imu - 1 ) / mw ( iv - 1 , imu - 1 , iz , is )) / ( 2 * dvpa ) end if ! first mu-derivative term at mu_{nmu}: Dmuh1 = (( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , is ) * mw ( iv , imu , iz , is ) * Dvpah & - vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , is ) * mw ( iv , imu - 1 , iz , is ) * Dvpah_m ) * dmu ( imu - 1 ) / dmu ( imu - 1 ) & + ( - vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , is ) * mw ( iv , imu , iz , is ) * Dvpah ) * dmu ( imu - 1 ) / dmu ( imu - 1 )) / ( dmu ( imu - 1 ) + dmu ( imu - 1 )) ! first derivative of h, at mu_{nmu} and mu_{nmu-1/2}: Dmuh_m = ( h ( iv , imu ) / mw ( iv , imu , iz , is ) - h ( iv , imu - 1 ) / mw ( iv , imu - 1 , iz , is )) / dmu ( imu - 1 ) Dmuh = ( h ( iv , imu ) / mw ( iv , imu , iz , is ) - h ( iv , imu - 1 ) / mw ( iv , imu - 1 , iz , is )) / dmu ( imu - 1 ) ! first-order accurate ! for second-order accuracy: !a = dmu(nmu-1)/(dmu(nmu-2)*(dmu(nmu-2)+dmu(nmu-1))) !b = -(dmu(nmu-1)+dmu(nmu-2))/(dmu(nmu-2)*dmu(nmu-1)) !c = (2.*dmu(nmu-1)+dmu(nmu-2))/(dmu(nmu-1)*(dmu(nmu-1)+dmu(nmu-2))) !Dmuh = a*h(iv,imu-2)/mw(iv,imu-2,iz) + b*h(iv,imu-1)/mw(iv,imu-1,iz,is) + c*h(iv,imu)/mw(iv,imu,iz,is) ! quantities at mu_{nmu-1/2}: mum = 0.5 * ( mu ( imu ) + mu ( imu - 1 )) mwm = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mum ) xm = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mum ) nuDm = spec ( is )% vnew ( is ) * ( erf ( xm ) - ( erf ( xm ) - xm * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 )) / ( 2 * xm ** 2 )) / xm ** 3 nupam = spec ( is )% vnew ( is ) * 2 * ( erf ( xm ) - xm * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 )) / ( 2 * xm ** 2 ) / xm ** 3 ! second mu-derivative term at mu_{nmu}: ! use d/dmu[...]_{nmu} = ([...]_{nmu+1} - [...]_{nmu-1/2})/(dmu_{nmu-1}/2+dmu(nmu-1)), where [...]_{nmu+1} is a ghost cell at mu = mu_{nmu} + dmu(nmu-1), with [...]_{nmu+1} = 0. Dmuh2 = (( 2 * ( nupa ( iv , imu , iz , is , is ) * mu ( imu ) ** 2 + nuD ( iv , imu , iz , is , is ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) & * mu ( imu )) * mw ( iv , imu , iz , is ) * Dmuh - 2 * ( nupam * mum ** 2 + nuDm * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mum ) * mwm * Dmuh_m ) * dmu ( imu - 1 ) / ( dmu ( imu - 1 ) / 2 ) & + ( - 2 * ( nupa ( iv , imu , iz , is , is ) * mu ( imu ) ** 2 + nuD ( iv , imu , iz , is , is ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) & * mu ( imu )) * mw ( iv , imu , iz , is ) * Dmuh ) * dmu ( imu - 1 ) / 2. / dmu ( imu - 1 )) / ( dmu ( imu - 1 ) / 2. + dmu ( imu - 1 )) ! add differential terms and gyro-diffusive term: Dh ( iv , imu ) = Dmuh2 + Dmuh1 - cfac * 0.5 * kperp2 ( iky , ikx , ia , iz ) * ( spec ( is )% smz / bmag ( ia , iz )) ** 2 & * ( nupa ( iv , imu , iz , is , is ) * bmag ( ia , iz ) * mu ( imu ) + nuD ( iv , imu , iz , is , is ) * ( vpa ( iv ) ** 2 + bmag ( ia , iz ) * mu ( imu ))) * h ( iv , imu ) do imu = 2 , nmu - 1 ! vpa-differential terms: if ( iv == 1 ) then ! AVB: first order accurate: Dvpah = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv , imu ) / mw ( iv , imu , iz , is )) / dvpa Dvpah_p = ( h ( iv + 1 , imu + 1 ) / mw ( iv + 1 , imu + 1 , iz , is ) - h ( iv , imu + 1 ) / mw ( iv , imu + 1 , iz , is )) / dvpa Dvpah_m = ( h ( iv + 1 , imu - 1 ) / mw ( iv + 1 , imu - 1 , iz , is ) - h ( iv , imu - 1 ) / mw ( iv , imu - 1 , iz , is )) / dvpa else if ( iv == nvpa ) then ! AVB: first order accurate: Dvpah = ( h ( iv , imu ) / mw ( iv , imu , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / dvpa Dvpah_p = ( h ( iv , imu + 1 ) / mw ( iv , imu + 1 , iz , is ) - h ( iv - 1 , imu + 1 ) / mw ( iv - 1 , imu + 1 , iz , is )) / dvpa Dvpah_m = ( h ( iv , imu - 1 ) / mw ( iv , imu - 1 , iz , is ) - h ( iv - 1 , imu - 1 ) / mw ( iv - 1 , imu - 1 , iz , is )) / dvpa else Dvpah = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / ( 2 * dvpa ) Dvpah_p = ( h ( iv + 1 , imu + 1 ) / mw ( iv + 1 , imu + 1 , iz , is ) - h ( iv - 1 , imu + 1 ) / mw ( iv - 1 , imu + 1 , iz , is )) / ( 2 * dvpa ) Dvpah_m = ( h ( iv + 1 , imu - 1 ) / mw ( iv + 1 , imu - 1 , iz , is ) - h ( iv - 1 , imu - 1 ) / mw ( iv - 1 , imu - 1 , iz , is )) / ( 2 * dvpa ) end if ! first mu-derivative of vpa-derivative term, at mu_{i}: Dmuh1 = (( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , is ) * mw ( iv , imu , iz , is ) * Dvpah & - vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , is ) * mw ( iv , imu - 1 , iz , is ) * Dvpah_m ) * dmu ( imu ) / dmu ( imu - 1 ) & + ( vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , is ) * mw ( iv , imu + 1 , iz , is ) * Dvpah_p & - vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , is ) * mw ( iv , imu , iz , is ) * Dvpah ) * dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) ! first mu-derivatives of h, at mu_i, mu_{i+1/2} and mu_{i-1/2}: Dmuh = (( h ( iv , imu ) / mw ( iv , imu , iz , is ) - h ( iv , imu - 1 ) / mw ( iv , imu - 1 , iz , is )) * dmu ( imu ) / dmu ( imu - 1 ) & + ( h ( iv , imu + 1 ) / mw ( iv , imu + 1 , iz , is ) - h ( iv , imu ) / mw ( iv , imu , iz , is )) * dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) Dmuh_m = ( h ( iv , imu ) / mw ( iv , imu , iz , is ) - h ( iv , imu - 1 ) / mw ( iv , imu - 1 , iz , is )) / dmu ( imu - 1 ) Dmuh_p = ( h ( iv , imu + 1 ) / mw ( iv , imu + 1 , iz , is ) - h ( iv , imu ) / mw ( iv , imu , iz , is )) / dmu ( imu ) ! quantities at mu_{i+1/2} and mu_{i-1/2}: mup = 0.5 * ( mu ( imu ) + mu ( imu + 1 )) mum = 0.5 * ( mu ( imu ) + mu ( imu - 1 )) mwp = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mup ) mwm = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mum ) xp = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mup ) xm = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mum ) nuDp = spec ( is )% vnew ( is ) * ( erf ( xp ) - ( erf ( xp ) - xp * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 )) / ( 2 * xp ** 2 )) / xp ** 3 nuDm = spec ( is )% vnew ( is ) * ( erf ( xm ) - ( erf ( xm ) - xm * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 )) / ( 2 * xm ** 2 )) / xm ** 3 nupap = spec ( is )% vnew ( is ) * 2 * ( erf ( xp ) - xp * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 )) / ( 2 * xp ** 2 ) / xp ** 3 nupam = spec ( is )% vnew ( is ) * 2 * ( erf ( xm ) - xm * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 )) / ( 2 * xm ** 2 ) / xm ** 3 ! second mu-derivative term at mu_{i}: Dmuh2 = ( ( 2 * ( nupa ( iv , imu , iz , is , is ) * mu ( imu ) ** 2 + nuD ( iv , imu , iz , is , is ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mu ( imu )) * mw ( iv , imu , iz , is ) * Dmuh & - 2 * ( nupam * mum ** 2 + nuDm * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mum ) * mwm * Dmuh_m ) * dmu ( imu ) / dmu ( imu - 1 ) & + ( 2 * ( nupap * mup ** 2 + nuDp * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mup ) * mwp * Dmuh_p - 2 * ( nupa ( iv , imu , iz , is , is ) * mu ( imu ) ** 2 & + nuD ( iv , imu , iz , is , is ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mu ( imu )) * mw ( iv , imu , iz , is ) * Dmuh ) * dmu ( imu - 1 ) / dmu ( imu ) ) * 2 / ( dmu ( imu - 1 ) + dmu ( imu )) ! add differential terms and gyro-diffusive term: Dh ( iv , imu ) = Dmuh2 + Dmuh1 - cfac * 0.5 * kperp2 ( iky , ikx , ia , iz ) * ( spec ( is )% smz / bmag ( ia , iz )) ** 2 * ( nupa ( iv , imu , iz , is , is ) * bmag ( ia , iz ) * mu ( imu ) & + nuD ( iv , imu , iz , is , is ) * ( vpa ( iv ) ** 2 + bmag ( ia , iz ) * mu ( imu ))) * h ( iv , imu ) end do end subroutine mu_differential_operator_fp subroutine vpa_differential_operator_fp_conservative ( h , Dh , imu , iz , is , ia ) use vpamu_grids , only : nvpa , vpa , dvpa , mu , dmu , nmu , equally_spaced_mu_grid , maxwell_mu use stella_geometry , only : bmag use constants , only : pi use species , only : spec implicit none complex , dimension (:, :), intent ( out ) :: Dh complex , dimension (:, :), intent ( in ) :: h integer , intent ( in ) :: imu , iz , ia , is integer :: iv complex :: dmuhp , dmuhm , dvpahp , dvpahm real :: xp , xm , vpap , vpam , nupap , nupam , nuDp , nuDm , mwp , mwm iv = 1 vpap = 0.5 * ( vpa ( iv ) + vpa ( iv + 1 )) xp = sqrt ( vpap ** 2 + 2 * bmag ( ia , iz ) * mu ( imu )) nuDp = spec ( is )% vnew ( is ) * ( erf ( xp ) - ( erf ( xp ) - xp * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 )) / ( 2 * xp ** 2 )) / xp ** 3 nupap = spec ( is )% vnew ( is ) * 2 * ( erf ( xp ) - xp * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 )) / ( 2 * xp ** 2 ) / xp ** 3 mwp = exp ( - vpap ** 2 ) * maxwell_mu ( 1 , iz , imu , is ) dvpahp = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv , imu ) / mw ( iv , imu , iz , is )) / dvpa if ( imu == 1 ) then ! second-order accurate !a = -(2.*dmu(1) + dmu(2))/(dmu(1)*(dmu(1)+dmu(2))) !b = (dmu(1)+dmu(2))/(dmu(1)*dmu(2)) !c = -dmu(1)/(dmu(2)*(dmu(1)+dmu(2))) !dmuhp = a*h(iv+1,imu)/mw(iv+1,imu,iz,is)+ b*h(iv+1,imu+1)/mw(iv+1,imu+1,iz,is) + c*h(iv+1,imu+2)/mw(iv+1,imu+2,iz) ! first-order accurate, as in implicit routine: dmuhp = ( h ( iv + 1 , imu + 1 ) / mw ( iv + 1 , imu + 1 , iz , is ) - h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is )) / dmu ( imu ) else if ( imu == nmu ) then ! second-order accurate !a = dmu(nmu-1)/(dmu(nmu-2)*(dmu(nmu-2)+dmu(nmu-1))) !b = -(dmu(nmu-1)+dmu(nmu-2))/(dmu(nmu-2)*dmu(nmu-1)) !c = (2.*dmu(nmu-1)+dmu(nmu-2))/(dmu(nmu-1)*(dmu(nmu-1)+dmu(nmu-2))) !dmuhp = a*h(iv+1,imu-2)/mw(iv+1,imu-2,iz) + b*h(iv+1,imu-1)/mw(iv+1,imu-1,iz,is) + c*h(iv+1,imu)/mw(iv+1,imu,iz,is) ! first-order accurate, as in implicit routine: dmuhp = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv + 1 , imu - 1 ) / mw ( iv + 1 , imu - 1 , iz , is )) / dmu ( imu - 1 ) else dmuhp = (( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv + 1 , imu - 1 ) / mw ( iv + 1 , imu - 1 , iz , is )) * dmu ( imu ) / dmu ( imu - 1 ) & + ( h ( iv + 1 , imu + 1 ) / mw ( iv + 1 , imu + 1 , iz , is ) - h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is )) * dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) end if Dh ( iv , imu ) = ( 2 * 0.5 * ( nupap * vpap ** 2 + 2 * nuDp * bmag ( ia , iz ) * mu ( imu )) * mwp * dvpahp + vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , is ) * mw ( iv + 1 , imu , iz , is ) * dmuhp ) / ( 2 * dvpa ) iv = nvpa vpam = 0.5 * ( vpa ( iv ) + vpa ( iv - 1 )) xm = sqrt ( vpam ** 2 + 2 * bmag ( ia , iz ) * mu ( imu )) nuDm = spec ( is )% vnew ( is ) * ( erf ( xm ) - ( erf ( xm ) - xm * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 )) / ( 2 * xm ** 2 )) / xm ** 3 nupam = spec ( is )% vnew ( is ) * 2 * ( erf ( xm ) - xm * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 )) / ( 2 * xm ** 2 ) / xm ** 3 mwm = exp ( - vpam ** 2 ) * maxwell_mu ( 1 , iz , imu , is ) dvpahm = ( h ( iv , imu ) / mw ( iv , imu , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / dvpa if ( imu == 1 ) then ! second-order accurate !a = -(2.*dmu(1) + dmu(2))/(dmu(1)*(dmu(1)+dmu(2))) !b = (dmu(1)+dmu(2))/(dmu(1)*dmu(2)) !c = -dmu(1)/(dmu(2)*(dmu(1)+dmu(2))) !dmuhm = a*h(iv-1,imu)/mw(iv-1,imu,iz,is) + b*h(iv-1,imu+1)/mw(iv-1,imu+1,iz,is) + c*h(iv-1,imu+2)/mw(iv-1,imu+2,iz) ! first-order accurate, as in implicit routine: dmuhm = ( h ( iv - 1 , imu + 1 ) / mw ( iv - 1 , imu + 1 , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / dmu ( imu ) else if ( imu == nmu ) then ! second-order accurate !a = dmu(nmu-1)/(dmu(nmu-2)*(dmu(nmu-2)+dmu(nmu-1))) !b = -(dmu(nmu-1)+dmu(nmu-2))/(dmu(nmu-2)*dmu(nmu-1)) !c = (2.*dmu(nmu-1)+dmu(nmu-2))/(dmu(nmu-1)*(dmu(nmu-1)+dmu(nmu-2))) !dmuhm = a*h(iv-1,imu-2)/mw(iv-1,imu-2,iz) + b*h(iv-1,imu-1)/mw(iv-1,imu-1,iz,is) + c*h(iv-1,imu)/mw(iv-1,imu,iz,is) ! first-order accurate, as in implicit routine: dmuhm = ( h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is ) - h ( iv - 1 , imu - 1 ) / mw ( iv - 1 , imu - 1 , iz , is )) / dmu ( imu - 1 ) else dmuhm = (( h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is ) - h ( iv - 1 , imu - 1 ) / mw ( iv - 1 , imu - 1 , iz , is )) * dmu ( imu ) / dmu ( imu - 1 ) & + ( h ( iv - 1 , imu + 1 ) / mw ( iv - 1 , imu + 1 , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) * dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) end if Dh ( iv , imu ) = ( - 2 * 0.5 * ( nupam * vpam ** 2 + 2 * nuDm * bmag ( ia , iz ) * mu ( imu )) * mwm * dvpahm - vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , is ) * mw ( iv - 1 , imu , iz , is ) * dmuhm ) / ( 2 * dvpa ) do iv = 2 , nvpa - 1 ! AVB: interior nodes: ! quantities at half-grid-points: vpap = 0.5 * ( vpa ( iv ) + vpa ( iv + 1 )) vpam = 0.5 * ( vpa ( iv ) + vpa ( iv - 1 )) xp = sqrt ( vpap ** 2 + 2 * bmag ( ia , iz ) * mu ( imu )) xm = sqrt ( vpam ** 2 + 2 * bmag ( ia , iz ) * mu ( imu )) nuDp = spec ( is )% vnew ( is ) * ( erf ( xp ) - ( erf ( xp ) - xp * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 )) / ( 2 * xp ** 2 )) / xp ** 3 nuDm = spec ( is )% vnew ( is ) * ( erf ( xm ) - ( erf ( xm ) - xm * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 )) / ( 2 * xm ** 2 )) / xm ** 3 nupap = spec ( is )% vnew ( is ) * 2 * ( erf ( xp ) - xp * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 )) / ( 2 * xp ** 2 ) / xp ** 3 nupam = spec ( is )% vnew ( is ) * 2 * ( erf ( xm ) - xm * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 )) / ( 2 * xm ** 2 ) / xm ** 3 mwp = exp ( - vpap ** 2 ) * maxwell_mu ( 1 , iz , imu , is ) mwm = exp ( - vpam ** 2 ) * maxwell_mu ( 1 , iz , imu , is ) dvpahp = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv , imu ) / mw ( iv , imu , iz , is )) / dvpa dvpahm = ( h ( iv , imu ) / mw ( iv , imu , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / dvpa if ( imu == 1 ) then ! second-order accurate: !a = -(2.*dmu(1) + dmu(2))/(dmu(1)*(dmu(1)+dmu(2))) !b = (dmu(1)+dmu(2))/(dmu(1)*dmu(2)) !c = -dmu(1)/(dmu(2)*(dmu(1)+dmu(2))) !dmuhp = a*h(iv+1,imu)/mw(iv+1,imu,iz,is) + b*h(iv+1,imu+1)/mw(iv+1,imu+1,iz,is) + c*h(iv+1,imu+2)/mw(iv+1,imu+2,iz) !dmuhm = a*h(iv-1,imu)/mw(iv-1,imu,iz,is) + b*h(iv-1,imu+1)/mw(iv-1,imu+1,iz,is) + c*h(iv-1,imu+2)/mw(iv-1,imu+2,iz) ! or first-order accurate, as in implicit routine: dmuhp = ( h ( iv + 1 , imu + 1 ) / mw ( iv + 1 , imu + 1 , iz , is ) - h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is )) / dmu ( imu ) dmuhm = ( h ( iv - 1 , imu + 1 ) / mw ( iv - 1 , imu + 1 , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / dmu ( imu ) else if ( imu == nmu ) then ! second-order accurate: !a = dmu(nmu-1)/(dmu(nmu-2)*(dmu(nmu-2)+dmu(nmu-1))) !b = -(dmu(nmu-1)+dmu(nmu-2))/(dmu(nmu-2)*dmu(nmu-1)) !c = (2.*dmu(nmu-1)+dmu(nmu-2))/(dmu(nmu-1)*(dmu(nmu-1)+dmu(nmu-2))) !dmuhp = a*h(iv+1,imu-2)/mw(iv+1,imu-2,iz) + b*h(iv+1,imu-1)/mw(iv+1,imu-1,iz,is) + c*h(iv+1,imu)/mw(iv+1,imu,iz,is) !dmuhm = a*h(iv-1,imu-2)/mw(iv-1,imu-2,iz) + b*h(iv-1,imu-1)/mw(iv-1,imu-1,iz,is) + c*h(iv-1,imu)/mw(iv-1,imu,iz,is) ! or first-order accurate, as in implicit routine: dmuhp = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv + 1 , imu - 1 ) / mw ( iv + 1 , imu - 1 , iz , is )) / dmu ( imu - 1 ) dmuhm = ( h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is ) - h ( iv - 1 , imu - 1 ) / mw ( iv - 1 , imu - 1 , iz , is )) / dmu ( imu - 1 ) else dmuhp = (( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv + 1 , imu - 1 ) / mw ( iv + 1 , imu - 1 , iz , is )) * dmu ( imu ) / dmu ( imu - 1 ) & + ( h ( iv + 1 , imu + 1 ) / mw ( iv + 1 , imu + 1 , iz , is ) - h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is )) * dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) dmuhm = (( h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is ) - h ( iv - 1 , imu - 1 ) / mw ( iv - 1 , imu - 1 , iz , is )) * dmu ( imu ) / dmu ( imu - 1 ) & + ( h ( iv - 1 , imu + 1 ) / mw ( iv - 1 , imu + 1 , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) * dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) end if if ( iv == 2 ) then ! assume vpa*mu*nux*F0*dh/dmu vanishes at iv=1, to ensure density conservation Dh ( iv , imu ) = ( 2 * 0.5 * ( nupap * vpap ** 2 + 2 * nuDp * bmag ( ia , iz ) * mu ( imu )) * mwp * dvpahp & + vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , is ) * mw ( iv + 1 , imu , iz , is ) * dmuhp & - 2 * 0.5 * ( nupam * vpam ** 2 + 2 * nuDm * bmag ( ia , iz ) * mu ( imu )) * mwm * dvpahm & - 0 * vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , is ) * mw ( iv - 1 , imu , iz , is ) * dmuhm ) / ( 2 * dvpa ) else if ( iv == nvpa - 1 ) then ! assume vpa*mu*nux*F0*dh/dmu vanishes at iv=nvpa, to ensure density conservation Dh ( iv , imu ) = ( 2 * 0.5 * ( nupap * vpap ** 2 + 2 * nuDp * bmag ( ia , iz ) * mu ( imu )) * mwp * dvpahp & + 0 * vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , is ) * mw ( iv + 1 , imu , iz , is ) * dmuhp & - 2 * 0.5 * ( nupam * vpam ** 2 + 2 * nuDm * bmag ( ia , iz ) * mu ( imu )) * mwm * dvpahm & - vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , is ) * mw ( iv - 1 , imu , iz , is ) * dmuhm ) / ( 2 * dvpa ) else Dh ( iv , imu ) = ( 2 * 0.5 * ( nupap * vpap ** 2 + 2 * nuDp * bmag ( ia , iz ) * mu ( imu )) * mwp * dvpahp & + vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , is ) * mw ( iv + 1 , imu , iz , is ) * dmuhp & - 2 * 0.5 * ( nupam * vpam ** 2 + 2 * nuDm * bmag ( ia , iz ) * mu ( imu )) * mwm * dvpahm & - vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , is ) * mw ( iv - 1 , imu , iz , is ) * dmuhm ) / ( 2 * dvpa ) end if end do end subroutine vpa_differential_operator_fp_conservative subroutine mu_differential_operator_fp_conservative ( h , Dh , iv , iz , is , ia , iky , ikx , cfac ) use vpamu_grids , only : nmu , mu , dmu , vpa , dvpa , nvpa , maxwell_vpa , equally_spaced_mu_grid use stella_geometry , only : bmag use species , only : spec use dist_fn_arrays , only : kperp2 use constants , only : pi use job_manage , only : timer_local , time_message implicit none complex , dimension (:, :), intent ( in ) :: h complex , dimension (:, :), intent ( out ) :: Dh integer , intent ( in ) :: iv , iz , is , ia , iky , ikx real , intent ( in ) :: cfac complex :: Dvpah , Dvpah_p , Dvpah_m , Dmuh , Dmuh_m , Dmuh_p , Dmuh1 , Dmuh2 real :: nuDp , nuDm , nupap , nupam , mup , mum , xp , xm , mwm , mwp integer :: imu imu = 1 ! vpa-differential terms: if ( iv == 1 ) then ! AVB: first order accurate: Dvpah = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv , imu ) / mw ( iv , imu , iz , is )) / dvpa Dvpah_p = ( h ( iv + 1 , imu + 1 ) / mw ( iv + 1 , imu + 1 , iz , is ) - h ( iv , imu + 1 ) / mw ( iv , imu + 1 , iz , is )) / dvpa else if ( iv == nvpa ) then ! AVB: first order accurate: Dvpah = ( h ( iv , imu ) / mw ( iv , imu , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / dvpa Dvpah_p = ( h ( iv , imu + 1 ) / mw ( iv , imu + 1 , iz , is ) - h ( iv - 1 , imu + 1 ) / mw ( iv - 1 , imu + 1 , iz , is )) / dvpa else Dvpah = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / ( 2 * dvpa ) Dvpah_p = ( h ( iv + 1 , imu + 1 ) / mw ( iv + 1 , imu + 1 , iz , is ) - h ( iv - 1 , imu + 1 ) / mw ( iv - 1 , imu + 1 , iz , is )) / ( 2 * dvpa ) end if ! first mu-derivative term at mu_{i}: ! use ghost cell at mu_{0} = 0, where mu*vpa*nux(vpa,mu)*F0 vanishes, dmu(0) = mu(1) ! to ensure conservation of density we approximate as follows: Dmuh1 = ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , is ) * mw ( iv , imu , iz , is ) * Dvpah + vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , is ) * mw ( iv , imu + 1 , iz , is ) * Dvpah_p ) / ( 2. * dmu ( imu )) !!Dmuh1 = ((vpa(iv)*mu(imu  )*nux(iv,imu  ,iz)*mw(iv,imu  ,iz,is)*Dvpah)*dmu(imu)/mu(imu) & !!      +(vpa(iv)*mu(imu+1)*nux(iv,imu+1,iz)*mw(iv,imu+1,iz,is)*Dvpah_p - vpa(iv)*mu(imu)*nux(iv,imu,iz)*mw(iv,imu,iz,is)*Dvpah)*mu(imu)/dmu(imu)) / (mu(imu)+dmu(imu)) ! first derivative of h, at mu_{i+1/2}, and at mu_i: Dmuh = ( h ( iv , imu + 1 ) / mw ( iv , imu + 1 , iz , is ) - h ( iv , imu ) / mw ( iv , imu , iz , is )) / dmu ( imu ) ! first-order accurate, as used in implicit routine ! for second-order accuracy: !a = -(2.*dmu(1) + dmu(2))/(dmu(1)*(dmu(1)+dmu(2))) !b = (dmu(1)+dmu(2))/(dmu(1)*dmu(2)) !c = -dmu(1)/(dmu(2)*(dmu(1)+dmu(2))) !Dmuh   = a*h(iv,imu)/mw(iv,imu,iz,is) + b*h(iv,imu+1)/mw(iv,imu+1,iz,is) + c*h(iv,imu+2)/mw(iv,imu+2,iz) ! second order accurate Dmuh_p = ( h ( iv , imu + 1 ) / mw ( iv , imu + 1 , iz , is ) - h ( iv , imu ) / mw ( iv , imu , iz , is )) / dmu ( imu ) ! second-order accurate ! quantities at mu_{i+1/2}: mup = 0.5 * ( mu ( imu ) + mu ( imu + 1 )) mwp = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mup ) xp = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mup ) nuDp = spec ( is )% vnew ( is ) * ( erf ( xp ) - ( erf ( xp ) - xp * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 )) / ( 2 * xp ** 2 )) / xp ** 3 nupap = spec ( is )% vnew ( is ) * 2 * ( erf ( xp ) - xp * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 )) / ( 2 * xp ** 2 ) / xp ** 3 ! second mu-derivative term at mu_{i}: ! use d/dmu[...]_{1} = ([...]_{1+1/2} - [...]_{0})/(dmu_{1}/2+mu(1)), where [...]_{0} is a ghost cell at mu_{0} = 0, with [...]_{0} = 0. Dmuh2 = ( ( 2 * ( nupa ( iv , imu , iz , is , is ) * mu ( imu ) ** 2 + nuD ( iv , imu , iz , is , is ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mu ( imu )) * mw ( iv , imu , iz , is ) * Dmuh ) * dmu ( imu ) / 2. / mu ( imu ) & + ( 2 * ( nupap * mup ** 2 + nuDp * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mup ) * mwp * Dmuh_p & - 2 * ( nupa ( iv , imu , iz , is , is ) * mu ( imu ) ** 2 + nuD ( iv , imu , iz , is , is ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mu ( imu )) * mw ( iv , imu , iz , is ) * Dmuh ) * mu ( imu ) / ( dmu ( imu ) / 2. ) ) / ( mu ( imu ) + dmu ( imu ) / 2. ) ! add differential terms and gyro-diffusive term: Dh ( iv , imu ) = Dmuh2 + Dmuh1 - cfac * 0.5 * kperp2 ( iky , ikx , ia , iz ) * ( spec ( is )% smz / bmag ( ia , iz )) ** 2 & * ( nupa ( iv , imu , iz , is , is ) * bmag ( ia , iz ) * mu ( imu ) + nuD ( iv , imu , iz , is , is ) * ( vpa ( iv ) ** 2 + bmag ( ia , iz ) * mu ( imu ))) * h ( iv , imu ) do imu = 2 , nmu - 1 ! vpa-differential terms: if ( iv == 1 ) then ! AVB: first order accurate: Dvpah = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv , imu ) / mw ( iv , imu , iz , is )) / dvpa Dvpah_p = ( h ( iv + 1 , imu + 1 ) / mw ( iv + 1 , imu + 1 , iz , is ) - h ( iv , imu + 1 ) / mw ( iv , imu + 1 , iz , is )) / dvpa Dvpah_m = ( h ( iv + 1 , imu - 1 ) / mw ( iv + 1 , imu - 1 , iz , is ) - h ( iv , imu - 1 ) / mw ( iv , imu - 1 , iz , is )) / dvpa else if ( iv == nvpa ) then ! AVB: first order accurate: Dvpah = ( h ( iv , imu ) / mw ( iv , imu , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / dvpa Dvpah_p = ( h ( iv , imu + 1 ) / mw ( iv , imu + 1 , iz , is ) - h ( iv - 1 , imu + 1 ) / mw ( iv - 1 , imu + 1 , iz , is )) / dvpa Dvpah_m = ( h ( iv , imu - 1 ) / mw ( iv , imu - 1 , iz , is ) - h ( iv - 1 , imu - 1 ) / mw ( iv - 1 , imu - 1 , iz , is )) / dvpa else Dvpah = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / ( 2 * dvpa ) Dvpah_p = ( h ( iv + 1 , imu + 1 ) / mw ( iv + 1 , imu + 1 , iz , is ) - h ( iv - 1 , imu + 1 ) / mw ( iv - 1 , imu + 1 , iz , is )) / ( 2 * dvpa ) Dvpah_m = ( h ( iv + 1 , imu - 1 ) / mw ( iv + 1 , imu - 1 , iz , is ) - h ( iv - 1 , imu - 1 ) / mw ( iv - 1 , imu - 1 , iz , is )) / ( 2 * dvpa ) end if ! first mu-derivative of vpa-derivative term, at mu_{i}: if ( imu == nmu - 1 ) then ! to ensure conservation of density we assume mu*nux*F0*d(h/F0)/dvpa vanishes at nmu Dmuh1 = ( - vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , is ) * mw ( iv , imu - 1 , iz , is ) * Dvpah_m ) / ( dmu ( imu - 1 ) + dmu ( imu - 1 )) else Dmuh1 = ( - vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , is ) * mw ( iv , imu - 1 , iz , is ) * Dvpah_m & + vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , is ) * mw ( iv , imu + 1 , iz , is ) * Dvpah_p ) / ( dmu ( imu - 1 ) + dmu ( imu - 1 )) end if ! first mu-derivatives of h, at mu_i, mu_{i+1/2} and mu_{i-1/2}: Dmuh = ( ( h ( iv , imu ) / mw ( iv , imu , iz , is ) - h ( iv , imu - 1 ) / mw ( iv , imu - 1 , iz , is )) * dmu ( imu ) / dmu ( imu - 1 ) + ( h ( iv , imu + 1 ) / mw ( iv , imu + 1 , iz , is ) - h ( iv , imu ) / mw ( iv , imu , iz , is ))& * dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) Dmuh_m = ( h ( iv , imu ) / mw ( iv , imu , iz , is ) - h ( iv , imu - 1 ) / mw ( iv , imu - 1 , iz , is )) / dmu ( imu - 1 ) Dmuh_p = ( h ( iv , imu + 1 ) / mw ( iv , imu + 1 , iz , is ) - h ( iv , imu ) / mw ( iv , imu , iz , is )) / dmu ( imu ) ! quantities at mu_{i+1/2} and mu_{i-1/2}: mup = 0.5 * ( mu ( imu ) + mu ( imu + 1 )) mum = 0.5 * ( mu ( imu ) + mu ( imu - 1 )) mwp = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mup ) mwm = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mum ) xp = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mup ) xm = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mum ) nuDp = spec ( is )% vnew ( is ) * ( erf ( xp ) - ( erf ( xp ) - xp * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 )) / ( 2 * xp ** 2 )) / xp ** 3 nuDm = spec ( is )% vnew ( is ) * ( erf ( xm ) - ( erf ( xm ) - xm * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 )) / ( 2 * xm ** 2 )) / xm ** 3 nupap = spec ( is )% vnew ( is ) * 2 * ( erf ( xp ) - xp * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 )) / ( 2 * xp ** 2 ) / xp ** 3 nupam = spec ( is )% vnew ( is ) * 2 * ( erf ( xm ) - xm * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 )) / ( 2 * xm ** 2 ) / xm ** 3 ! second mu-derivative term at mu_{i}: Dmuh2 = ( ( 2 * ( nupa ( iv , imu , iz , is , is ) * mu ( imu ) ** 2 + nuD ( iv , imu , iz , is , is ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mu ( imu )) * mw ( iv , imu , iz , is ) * Dmuh & - 2 * ( nupam * mum ** 2 + nuDm * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mum ) * mwm * Dmuh_m ) * dmu ( imu ) / dmu ( imu - 1 ) & + ( 2 * ( nupap * mup ** 2 + nuDp * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mup ) * mwp * Dmuh_p & - 2 * ( nupa ( iv , imu , iz , is , is ) * mu ( imu ) ** 2 + nuD ( iv , imu , iz , is , is ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mu ( imu )) * mw ( iv , imu , iz , is ) * Dmuh ) * dmu ( imu - 1 ) / dmu ( imu ) ) * 2 / ( dmu ( imu - 1 ) + dmu ( imu )) ! add differential terms and gyro-diffusive term: Dh ( iv , imu ) = Dmuh2 + Dmuh1 - cfac * 0.5 * kperp2 ( iky , ikx , ia , iz ) * ( spec ( is )% smz / bmag ( ia , iz )) ** 2 * ( nupa ( iv , imu , iz , is , is ) * bmag ( ia , iz ) * mu ( imu ) & + nuD ( iv , imu , iz , is , is ) * ( vpa ( iv ) ** 2 + bmag ( ia , iz ) * mu ( imu ))) * h ( iv , imu ) end do imu = nmu ! vpa-differential terms: if ( iv == 1 ) then ! AVB: first order accurate: Dvpah = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv , imu ) / mw ( iv , imu , iz , is )) / dvpa Dvpah_m = ( h ( iv + 1 , imu - 1 ) / mw ( iv + 1 , imu - 1 , iz , is ) - h ( iv , imu - 1 ) / mw ( iv , imu - 1 , iz , is )) / dvpa else if ( iv == nvpa ) then ! AVB: first order accurate: Dvpah = ( h ( iv , imu ) / mw ( iv , imu , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / dvpa Dvpah_m = ( h ( iv , imu - 1 ) / mw ( iv , imu - 1 , iz , is ) - h ( iv - 1 , imu - 1 ) / mw ( iv - 1 , imu - 1 , iz , is )) / dvpa else Dvpah = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / ( 2 * dvpa ) Dvpah_m = ( h ( iv + 1 , imu - 1 ) / mw ( iv + 1 , imu - 1 , iz , is ) - h ( iv - 1 , imu - 1 ) / mw ( iv - 1 , imu - 1 , iz , is )) / ( 2 * dvpa ) end if ! first mu-derivative term at mu_{nmu}: ! to ensure conservation of density, assume that term is zero beyond nmu Dmuh1 = ( - vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , is ) * mw ( iv , imu - 1 , iz , is ) * Dvpah_m ) / ( dmu ( imu - 1 ) + dmu ( imu - 1 )) ! first derivative of h, at mu_{nmu} and mu_{nmu-1/2}: Dmuh_m = ( h ( iv , imu ) / mw ( iv , imu , iz , is ) - h ( iv , imu - 1 ) / mw ( iv , imu - 1 , iz , is )) / dmu ( imu - 1 ) Dmuh = ( h ( iv , imu ) / mw ( iv , imu , iz , is ) - h ( iv , imu - 1 ) / mw ( iv , imu - 1 , iz , is )) / dmu ( imu - 1 ) ! first-order accurate ! for second-order accuracy: !a = dmu(nmu-1)/(dmu(nmu-2)*(dmu(nmu-2)+dmu(nmu-1))) !b = -(dmu(nmu-1)+dmu(nmu-2))/(dmu(nmu-2)*dmu(nmu-1)) !c = (2.*dmu(nmu-1)+dmu(nmu-2))/(dmu(nmu-1)*(dmu(nmu-1)+dmu(nmu-2))) !Dmuh = a*h(iv,imu-2)/mw(iv,imu-2,iz) + b*h(iv,imu-1)/mw(iv,imu-1,iz,is) + c*h(iv,imu)/mw(iv,imu,iz,is) ! quantities at mu_{nmu-1/2}: mum = 0.5 * ( mu ( imu ) + mu ( imu - 1 )) mwm = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mum ) xm = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mum ) nuDm = spec ( is )% vnew ( is ) * ( erf ( xm ) - ( erf ( xm ) - xm * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 )) / ( 2 * xm ** 2 )) / xm ** 3 nupam = spec ( is )% vnew ( is ) * 2 * ( erf ( xm ) - xm * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 )) / ( 2 * xm ** 2 ) / xm ** 3 ! second mu-derivative term at mu_{nmu}: ! to ensure density conservation ! use d/dmu[...]_{nmu} = ([...]_{nmu+1/2} - [...]_{nmu-1/2})/(dmu_{nmu-1}/2+dmu(nmu-1)/2), where [...]_{nmu+1/2} is a ghost cell at mu = mu_{nmu} + dmu(nmu-1)/2, with [...]_{nmu+1/2} = 0. Dmuh2 = ( ( 2 * ( nupa ( iv , imu , iz , is , is ) * mu ( imu ) ** 2 + nuD ( iv , imu , iz , is , is ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mu ( imu )) * mw ( iv , imu , iz , is ) * Dmuh & - 2 * ( nupam * mum ** 2 + nuDm * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mum ) * mwm * Dmuh_m ) * dmu ( imu - 1 ) / dmu ( imu - 1 ) & + ( - 2 * ( nupa ( iv , imu , iz , is , is ) * mu ( imu ) ** 2 + nuD ( iv , imu , iz , is , is ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mu ( imu )) & * mw ( iv , imu , iz , is ) * Dmuh ) * dmu ( imu - 1 ) / dmu ( imu - 1 )) / ( dmu ( imu - 1 ) / 2. + dmu ( imu - 1 ) / 2. ) ! add differential terms and gyro-diffusive term: Dh ( iv , imu ) = Dmuh2 + Dmuh1 - cfac * 0.5 * kperp2 ( iky , ikx , ia , iz ) * ( spec ( is )% smz / bmag ( ia , iz )) ** 2 * ( nupa ( iv , imu , iz , is , is ) * bmag ( ia , iz ) * mu ( imu ) & + nuD ( iv , imu , iz , is , is ) * ( vpa ( iv ) ** 2 + bmag ( ia , iz ) * mu ( imu ))) * h ( iv , imu ) end subroutine mu_differential_operator_fp_conservative subroutine vpa_differential_operator ( tfac , h , Dh ) use vpamu_grids , only : nvpa , vpa , dvpa implicit none real , intent ( in ) :: tfac complex , dimension (:), intent ( in ) :: h complex , dimension (:), intent ( out ) :: Dh integer :: iv ! use h = 0 at ghost cells beyond +/- vpa_max iv = 1 Dh ( iv ) = ( 0.5 * h ( iv + 1 ) * ( tfac / dvpa + vpa ( iv + 1 )) - tfac * h ( iv ) / dvpa ) / dvpa iv = nvpa Dh ( iv ) = ( - tfac * h ( iv ) / dvpa + 0.5 * h ( iv - 1 ) * ( tfac / dvpa - vpa ( iv - 1 ))) / dvpa do iv = 2 , nvpa - 1 Dh ( iv ) = ( 0.5 * h ( iv + 1 ) * ( tfac / dvpa + vpa ( iv + 1 )) - tfac * h ( iv ) / dvpa + 0.5 * h ( iv - 1 ) * ( tfac / dvpa - vpa ( iv - 1 ))) / dvpa end do end subroutine vpa_differential_operator subroutine mu_differential_operator ( tfac , iz , ia , h , Dh ) use vpamu_grids , only : nmu , dmu use vpamu_grids , only : mu_cell , dmu_cell , wgts_mu_bare use vpamu_grids , only : equally_spaced_mu_grid use stella_geometry , only : bmag implicit none real , intent ( in ) :: tfac integer , intent ( in ) :: iz , ia complex , dimension (:), intent ( in ) :: h complex , dimension (:), intent ( out ) :: Dh integer :: imu real :: mm , m0 , mp ! the following finite difference method is explained in init_mudiff_matrix imu = 1 m0 = dmu_cell ( imu ) * ( 1.0 - tfac / ( dmu ( imu ) * bmag ( ia , iz ))) / wgts_mu_bare ( imu ) mp = mu_cell ( imu ) * ( tfac / ( bmag ( ia , iz ) * dmu ( imu )) + 1.0 ) / wgts_mu_bare ( imu ) Dh ( imu ) = m0 * h ( imu ) + mp * h ( imu + 1 ) imu = nmu mm = mu_cell ( imu - 1 ) * ( tfac / ( bmag ( ia , iz ) * dmu ( imu - 1 )) - 1.0 ) / wgts_mu_bare ( imu ) m0 = - mu_cell ( imu - 1 ) * ( tfac / ( dmu ( imu - 1 ) * bmag ( ia , iz )) + 1.0 ) / wgts_mu_bare ( imu ) Dh ( imu ) = mm * h ( imu - 1 ) + m0 * h ( imu ) do imu = 2 , nmu - 1 mm = mu_cell ( imu - 1 ) * ( tfac / ( bmag ( ia , iz ) * dmu ( imu - 1 )) - 1.0 ) / wgts_mu_bare ( imu ) m0 = - ( mu_cell ( imu ) / dmu ( imu ) + mu_cell ( imu - 1 ) / dmu ( imu - 1 )) * tfac / ( wgts_mu_bare ( imu ) * bmag ( ia , iz )) + dmu_cell ( imu ) / wgts_mu_bare ( imu ) mp = mu_cell ( imu ) * ( tfac / ( bmag ( ia , iz ) * dmu ( imu )) + 1.0 ) / wgts_mu_bare ( imu ) Dh ( imu ) = mm * h ( imu - 1 ) + m0 * h ( imu ) + mp * h ( imu + 1 ) end do end subroutine mu_differential_operator subroutine conserve_momentum ( iky , ikx , iz , is , ikxkyz , h , Ch ) use species , only : spec use stella_geometry , only : bmag use vpamu_grids , only : integrate_vmu use vpamu_grids , only : vpa , nvpa , nmu , vperp2 use vpamu_grids , only : maxwell_vpa , maxwell_mu !   use vpamu_grids, only: int_vpa2 use dist_fn_arrays , only : kperp2 use gyro_averages , only : aj0v , aj1v implicit none integer , intent ( in ) :: iky , ikx , iz , is , ikxkyz complex , dimension (:, :), intent ( in ) :: h complex , dimension (:, :), intent ( in out ) :: Ch complex , dimension (:, :), allocatable :: u_fac complex :: integral integer :: ia real :: norm allocate ( u_fac ( nvpa , nmu )) ia = 1 !   norm = 1.0/int_vpa2(ia,iz,is) norm = 2.0 if ( vpa_operator ) then u_fac = spread ( aj0v (:, ikxkyz ), 1 , nvpa ) * spread ( vpa , 2 , nmu ) call integrate_vmu ( u_fac * h , iz , integral ) Ch = Ch + norm * u_fac * integral * spread ( maxwell_mu ( 1 , iz , :, is ), 1 , nvpa ) * spread ( maxwell_vpa (:, is ), 2 , nmu ) end if if ( mu_operator ) then u_fac = spread ( vperp2 ( ia , iz , :) * aj1v (:, ikxkyz ), 1 , nvpa ) * sqrt ( kperp2 ( iky , ikx , ia , iz )) * spec ( is )% smz / bmag ( ia , iz ) call integrate_vmu ( u_fac * h , iz , integral ) Ch = Ch + norm * u_fac * integral * spread ( maxwell_mu ( 1 , iz , :, is ), 1 , nvpa ) * spread ( maxwell_vpa (:, is ), 2 , nmu ) end if deallocate ( u_fac ) end subroutine conserve_momentum subroutine conserve_energy ( iz , is , ikxkyz , h , Ch ) use vpamu_grids , only : integrate_vmu use vpamu_grids , only : vpa , nvpa , nmu , vperp2 use vpamu_grids , only : maxwell_vpa , maxwell_mu !   use vpamu_grids, only: int_unit, int_vpa2, int_vperp2, int_vfrth use gyro_averages , only : aj0v implicit none integer , intent ( in ) :: iz , is , ikxkyz complex , dimension (:, :), intent ( in ) :: h complex , dimension (:, :), intent ( in out ) :: Ch complex , dimension (:, :), allocatable :: T_fac complex :: integral real :: norm integer :: ia allocate ( T_fac ( nvpa , nmu )) ia = 1 T_fac = 0.0 if ( vpa_operator ) T_fac = spread ( aj0v (:, ikxkyz ), 1 , nvpa ) * ( spread ( vpa ** 2 , 2 , nmu )) - 0.5 if ( mu_operator ) T_fac = T_fac + spread ( vperp2 ( ia , iz , :), 1 , nvpa ) - 1.0 call integrate_vmu ( T_fac * h , iz , integral ) !   norm = 1.0/(int_vfrth(ia,iz,is) - (int_vperp2(ia,iz,is) + int_vpa2(ia,iz,is))**2/int_unit(ia,iz,is)) norm = 2.0 / 3.0 Ch = Ch + 2.0 * norm * T_fac * integral * spread ( maxwell_mu ( ia , iz , :, is ), 1 , nvpa ) * spread ( maxwell_vpa (:, is ), 2 , nmu ) deallocate ( T_fac ) end subroutine conserve_energy subroutine conserve_momentum_vmulo ( h , gke_rhs ) use mp , only : sum_allreduce use stella_time , only : code_dt use stella_layouts , only : vmu_lo use stella_layouts , only : imu_idx , iv_idx , is_idx use species , only : spec use physics_flags , only : radial_variation use stella_geometry , only : bmag , dBdrho use kt_grids , only : nakx , naky , multiply_by_rho use zgrid , only : nzgrid , ntubes use vpamu_grids , only : integrate_species , mu , vpa , vperp2 use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use dist_fn_arrays , only : kperp2 , dkperp2dr use gyro_averages , only : gyro_average , gyro_average_j1 , aj0x , aj1x implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: h complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: gke_rhs complex , dimension (:, :), allocatable :: g0k , g1k complex , dimension (:, :, :), allocatable :: gyro_g complex , dimension (:, :, :, :), allocatable :: field1 , field2 real :: prefac , energy integer :: it , iz , ivmu , imu , iv , ia , is ia = 1 allocate ( g0k ( naky , nakx )) allocate ( g1k ( naky , nakx )) allocate ( gyro_g ( naky , nakx , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) allocate ( field1 ( naky , nakx , - nzgrid : nzgrid , ntubes )) allocate ( field2 ( naky , nakx , - nzgrid : nzgrid , ntubes )) !component from vpa do it = 1 , ntubes do iz = - nzgrid , nzgrid do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) iv = iv_idx ( vmu_lo , ivmu ) call gyro_average ( h (:, :, iz , it , ivmu ), iz , ivmu , gyro_g (:, :, ivmu )) gyro_g (:, :, ivmu ) = gyro_g (:, :, ivmu ) * vpa ( iv ) g0k = 0.0 if ( radial_variation ) then g0k (:, :) = gyro_g (:, :, ivmu ) & * ( - 0.5 * aj1x (:, :, iz , ivmu ) / aj0x (:, :, iz , ivmu ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 (:, :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) & + dBdrho ( iz ) / bmag ( ia , iz )) call multiply_by_rho ( g0k ) end if gyro_g (:, :, ivmu ) = gyro_g (:, :, ivmu ) + g0k end do call integrate_species ( gyro_g , iz , spec % dens_psi0 * spec % temp_psi0 , field1 (:, :, iz , it ), reduce_in = . false .) end do end do call sum_allreduce ( field1 ) !component from vperp do it = 1 , ntubes do iz = - nzgrid , nzgrid do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) iv = iv_idx ( vmu_lo , ivmu ) !component from vpa call gyro_average_j1 ( h (:, :, iz , it , ivmu ), iz , ivmu , gyro_g (:, :, ivmu )) gyro_g (:, :, ivmu ) = gyro_g (:, :, ivmu ) * vperp2 ( ia , iz , imu ) * sqrt ( kperp2 (:, :, ia , iz )) * spec ( is )% smz_psi0 / bmag ( ia , iz ) g0k = 0.0 if ( radial_variation ) then g0k = gyro_g (:, :, ivmu ) * ( dBdrho ( iz ) / bmag ( ia , iz ) + 0.5 * dkperp2dr (:, :, ia , iz )) & + h (:, :, iz , it , ivmu ) * ( 0.5 * aj0x (:, :, iz , ivmu ) - aj1x (:, :, iz , ivmu )) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) * vperp2 ( ia , iz , imu ) & * sqrt ( kperp2 (:, :, ia , iz )) * spec ( is )% smz_psi0 / bmag ( ia , iz ) call multiply_by_rho ( g0k ) end if gyro_g (:, :, ivmu ) = gyro_g (:, :, ivmu ) + g0k end do call integrate_species ( gyro_g , iz , spec % dens_psi0 * spec % temp_psi0 , field2 (:, :, iz , it ), reduce_in = . false .) end do end do call sum_allreduce ( field2 ) deallocate ( gyro_g ) do it = 1 , ntubes do iz = - nzgrid , nzgrid do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) iv = iv_idx ( vmu_lo , ivmu ) prefac = 2.0 / ( spec ( is )% dens * spec ( is )% temp ) * code_dt * spec ( is )% vnew ( is ) & * maxwell_mu ( ia , iz , imu , is ) * maxwell_vpa ( iv , is ) * maxwell_fac ( is ) g0k = aj0x (:, :, iz , ivmu ) * vpa ( iv ) * field1 (:, :, iz , it ) & + aj1x (:, :, iz , ivmu ) * vperp2 ( ia , iz , imu ) * field2 (:, :, iz , it ) & * spec ( is )% smz_psi0 * sqrt ( kperp2 (:, :, ia , iz )) / bmag ( ia , iz ) gke_rhs (:, :, iz , it , ivmu ) = gke_rhs (:, :, iz , it , ivmu ) + prefac * g0k if ( radial_variation ) then energy = ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu )) * ( spec ( is )% temp_psi0 / spec ( is )% temp ) g1k = field1 (:, :, iz , it ) * vpa ( iv ) * ( - 0.5 * aj1x (:, :, iz , ivmu ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 (:, :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz ))) & + field2 (:, :, iz , it ) * spec ( is )% smz_psi0 * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) * sqrt ( kperp2 (:, :, ia , iz )) & * ( 0.5 * aj1x (:, :, iz , ivmu ) * dkperp2dr (:, :, ia , iz ) + ( 0.5 * aj0x (:, :, iz , ivmu ) - aj1x (:, :, iz , ivmu )) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz ))) g1k = g1k + g0k * ( spec ( is )% tprim * ( energy - 2.5 ) + 2 * mu ( imu ) * dBdrho ( iz )) call multiply_by_rho ( g1k ) gke_rhs (:, :, iz , it , ivmu ) = gke_rhs (:, :, iz , it , ivmu ) + prefac * g1k end if end do end do end do deallocate ( g0k , g1k ) deallocate ( field1 , field2 ) end subroutine conserve_momentum_vmulo subroutine conserve_energy_vmulo ( h , gke_rhs ) use mp , only : sum_allreduce use stella_time , only : code_dt use stella_layouts , only : vmu_lo use stella_layouts , only : imu_idx , iv_idx , is_idx use species , only : spec use physics_flags , only : radial_variation use stella_geometry , only : bmag , dBdrho use kt_grids , only : nakx , naky , multiply_by_rho use zgrid , only : nzgrid , ntubes use vpamu_grids , only : integrate_species use vpamu_grids , only : mu , vpa , nmu , vperp2 use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use dist_fn_arrays , only : kperp2 , dkperp2dr use gyro_averages , only : gyro_average , gyro_average_j1 , aj0x , aj1x implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: h complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: gke_rhs complex , dimension (:, :), allocatable :: g0k , g1k complex , dimension (:, :, :), allocatable :: gyro_g complex , dimension (:, :, :, :), allocatable :: field real :: prefac , energy integer :: it , iz , ivmu , imu , iv , ia , is ia = 1 allocate ( g0k ( naky , nakx )) allocate ( g1k ( naky , nakx )) allocate ( gyro_g ( naky , nakx , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) allocate ( field ( naky , nakx , - nzgrid : nzgrid , ntubes )) !component from vpa do it = 1 , ntubes do iz = - nzgrid , nzgrid do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) iv = iv_idx ( vmu_lo , ivmu ) call gyro_average ( h (:, :, iz , it , ivmu ), iz , ivmu , gyro_g (:, :, ivmu )) gyro_g (:, :, ivmu ) = gyro_g (:, :, ivmu ) * ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu ) - 1.5 * spec ( is )% temp / spec ( is )% temp_psi0 ) g0k = 0.0 if ( radial_variation ) then g0k (:, :) = gyro_g (:, :, ivmu ) & * ( - 0.5 * aj1x (:, :, iz , ivmu ) / aj0x (:, :, iz , ivmu ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 (:, :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) & + dBdrho ( iz ) / bmag ( ia , iz )) & + h (:, :, iz , it , ivmu ) * aj0x (:, :, iz , ivmu ) * ( vperp2 ( ia , iz , imu ) * dBdrho ( iz ) / bmag ( ia , iz ) & + 1.5 * spec ( is )% tprim ) call multiply_by_rho ( g0k ) end if gyro_g (:, :, ivmu ) = gyro_g (:, :, ivmu ) + g0k end do call integrate_species ( gyro_g , iz , spec % dens_psi0 * spec % temp_psi0 ** 2 , field (:, :, iz , it ), reduce_in = . false .) end do end do call sum_allreduce ( field ) deallocate ( gyro_g ) do it = 1 , ntubes do iz = - nzgrid , nzgrid do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) iv = iv_idx ( vmu_lo , ivmu ) prefac = 4.0 / ( 3.0 * spec ( is )% dens * spec ( is )% temp ** 2 ) * code_dt * spec ( is )% vnew ( is ) & * maxwell_mu ( ia , iz , imu , is ) * maxwell_vpa ( iv , is ) * maxwell_fac ( is ) g0k = aj0x (:, :, iz , ivmu ) * field (:, :, iz , it ) & * ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu ) - 1.5 * spec ( is )% temp / spec ( is )% temp_psi0 ) gke_rhs (:, :, iz , it , ivmu ) = gke_rhs (:, :, iz , it , ivmu ) + prefac * g0k if ( radial_variation ) then energy = ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu )) * ( spec ( is )% temp_psi0 / spec ( is )% temp ) g1k = field (:, :, iz , it ) * ( energy - 1.5 ) * ( - 0.5 * aj1x (:, :, iz , ivmu ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 (:, :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz ))) & + field (:, :, iz , it ) * aj0x (:, :, iz , ivmu ) * ( vperp2 ( ia , iz , imu ) * dBdrho ( iz ) / bmag ( ia , iz ) + 1.5 * spec ( is )% tprim ) g1k = g1k + g0k * ( spec ( is )% tprim * ( energy - 3.5 ) + 2 * mu ( imu ) * dBdrho ( iz )) call multiply_by_rho ( g1k ) gke_rhs (:, :, iz , it , ivmu ) = gke_rhs (:, :, iz , it , ivmu ) + prefac * g1k end if end do end do end do deallocate ( g0k , g1k ) deallocate ( field ) end subroutine conserve_energy_vmulo subroutine advance_collisions_implicit ( mirror_implicit , phi , apar , g ) use mp , only : proc0 use redistribute , only : gather , scatter use dist_redistribute , only : kxkyz2vmu use job_manage , only : time_message use zgrid , only : nzgrid use vpamu_grids , only : set_vpa_weights use stella_layouts , only : vmu_lo use dist_fn_arrays , only : gvmu implicit none logical , intent ( in ) :: mirror_implicit complex , dimension (:, :, - nzgrid :, :), intent ( in out ) :: phi , apar complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: g logical :: conservative_wgts if ( proc0 ) call time_message (. false ., time_collisions (:, 1 ), ' collisions' ) conservative_wgts = . true . call set_vpa_weights ( conservative_wgts ) if ( proc0 ) call time_message (. false ., time_collisions (:, 2 ), ' coll_redist' ) call scatter ( kxkyz2vmu , g , gvmu ) if ( proc0 ) call time_message (. false ., time_collisions (:, 2 ), ' coll_redist' ) if ( collision_model == \"dougherty\" ) then if ( vpa_operator ) call advance_vpadiff_implicit ( phi , apar , gvmu ) if ( mu_operator ) call advance_mudiff_implicit ( phi , apar , gvmu ) end if if ( collision_model == \"fokker-planck\" ) then if ( density_conservation ) then conservative_wgts = . true . call set_vpa_weights ( conservative_wgts ) end if if ( exact_conservation_tp ) then conservative_wgts = . false . call set_vpa_weights ( conservative_wgts ) end if call advance_implicit_fp ( phi , apar , gvmu ) end if if (. not . mirror_implicit ) then ! then take the results and remap again so ky,kx,z local. if ( proc0 ) call time_message (. false ., time_collisions (:, 2 ), ' coll_redist' ) call gather ( kxkyz2vmu , gvmu , g ) if ( proc0 ) call time_message (. false ., time_collisions (:, 2 ), ' coll_redist' ) end if conservative_wgts = . false . call set_vpa_weights ( conservative_wgts ) if ( proc0 ) call time_message (. false ., time_collisions (:, 1 ), ' collisions' ) end subroutine advance_collisions_implicit subroutine advance_implicit_fp ( phi , apar , g ) use mp , only : sum_allreduce use finite_differences , only : tridag use linear_solve , only : lu_back_substitution use stella_time , only : code_dt use run_parameters , only : fphi use species , only : nspec , spec use zgrid , only : nzgrid , ntubes use vpamu_grids , only : nmu , nvpa , integrate_vmu use vpamu_grids , only : vpa use vpamu_grids , only : set_vpa_weights use kt_grids , only : naky , nakx use stella_layouts , only : kxkyz_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , is_idx , it_idx use g_tofrom_h , only : g_to_h use fields , only : get_fields use constants , only : pi use stella_time , only : code_dt implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in out ) :: phi , apar complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( in out ) :: g complex , dimension (:, :, :, :, :), allocatable :: flds complex , dimension (:, :, :), allocatable :: g_in complex , dimension (:, :), allocatable :: gvmutr complex , dimension (:), allocatable :: ghrs complex , dimension (:, :, :, :, :), allocatable :: field complex , dimension (:, :), allocatable :: g0spitzer integer :: ikxkyz , iky , ikx , iz , is , iv , it , ia integer :: idx1 , ij , il , im , jj , ll , mm , ll1 , mm1 , jj1 , isa , isb real :: clm real :: spitzer_i1 , spitzer_i2 , applied_Epar , gradpar_lnp0 , gradpar_lnT0 ! store input g for use later, as g will be overwritten below allocate ( g_in ( nvpa , nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) allocate ( g0spitzer ( nvpa , nmu )) ia = 1 if ( spitzer_problem ) then ! to solve the Spitzer problem, we add a source term associated with a constant ! applied electric field, and pressure and temperature gradients here ! all other non-collisional terms are disabled, and Delta t --> \\infty applied_Epar = 0.01 gradpar_lnp0 = 0 gradpar_lnT0 = 0.01 spitzer_i1 = ( applied_Epar - gradpar_lnp0 ) * i1fac spitzer_i2 = gradpar_lnT0 * i2fac do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) if ( is == 1 ) cycle g (:, :, ikxkyz ) = g (:, :, ikxkyz ) - 1. / sqrt ( spec ( is )% mass ) * code_dt * ( spread ( vpa , 2 , nmu ) * spitzer_i1 & + ( spread ( vpa , 2 , nmu ) * velvpamu (:, :, iz ) ** 2 - 5. / 2. * spread ( vpa , 2 , nmu )) * spitzer_i2 ) * mw (:, :, iz , is ) end do end if g_in = g allocate ( gvmutr ( nvpa , nmu )) allocate ( ghrs ( nmu * nvpa )) allocate ( field ( naky , nakx , - nzgrid : nzgrid , ntubes , nspec )) allocate ( flds ( naky , nakx , - nzgrid : nzgrid , ntubes , nresponse )) ! since backwards difference in time, (I-dt*D)h_inh&#94;{n+1} = g&#94;{***} ! invert above equation to get h_inh&#94;{n+1} do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) do iv = 1 , nvpa ghrs ( nmu * ( iv - 1 ) + 1 : nmu * iv ) = g ( iv , :, ikxkyz ) end do call zgbtrs ( 'No transpose' , nvpa * nmu , nmu + 1 , nmu + 1 , 1 , cdiffmat_band (:,:, iky , ikx , iz , is ), 3 * ( nmu + 1 ) + 1 , ipiv (:, iky , ikx , iz , is ), ghrs , nvpa * nmu , info ) do iv = 1 , nvpa g ( iv , :, ikxkyz ) = ghrs ( nmu * ( iv - 1 ) + 1 : nmu * iv ) end do end do ! obtain phi&#94;{n+1} and conservation terms using response matrix approach ! first get phi_inh&#94;{n+1} if ( advfield_coll ) then call get_fields ( g , phi , apar , dist = 'h' ) flds (:, :, :, :, 1 ) = phi end if ! next get the psi&#94;{s1s2,jlm}_inh&#94;{n+1} ! note g contains h_s1_inh, h_s2_inh, ... ie all species if ( fieldpart ) then ! layout of field(,,,,:) is phi; jlm0 psi_aa, jlm0 psi_ab, jlm0 psi_ba,  jlm0 psi_bb; jlm1 psi_aa, etc, because we want species to be contiguous do idx1 = 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 * nspec isa = 1 + int (( idx1 - 1 ) / (( jmax + 1 ) * ( lmax + 1 ) ** 2 )) !1 + mod(idx1-1,(jmax+1)*(lmax+1)**2) ij = 1 + mod ( 1 + mod ( idx1 - 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 ) - 1 , jmax + 1 ) il = 1 + int ( sqrt ( 1.0 * ( 1 + mod ( idx1 - 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 ) - ij ) / ( jmax + 1 ))) im = ( 1 + mod ( idx1 - 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 ) - ij ) / ( jmax + 1 ) - ( il - 1 ) ** 2 + 1 ll = il - 1 mm = - ll + im - 1 jj = ij - 1 if ( density_conservation_tp . and . ( jj == 0 ) . and . ( ll == 0 )) then ! get the density produced by the combined test particle operator C_{test,isa} = C_{test,isa,isa} + C_{test,isa,isb} + ... ! this is stored in field(:,:,:,:,isa), all other entries are zero field = 0. call get_testpart_density ( isa , 0 , g , field ) else ! get psi&#94;{isa[is1....isN],jlm}_inh&#94;{n+1} call get_psi ( g , field , isa , 0 , ll , mm , jj ) end if ! add to rhs vector flds (:, :, :, :, 2 + ( idx1 - 1 ) * nspec : 1 + idx1 * nspec ) = field (:, :, :, :, :) end do end if ! AVB: obtain phi&#94;{n+1} and psijlm&#94;{n+1} from response matrix do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) ! all is indices inside ikxkyz super-index have same info ! no need to compute multiple times is = is_idx ( kxkyz_lo , ikxkyz ); if ( is /= 1 ) cycle call lu_back_substitution ( fp_response (:, :, ikxkyz ), diff_idx (:, ikxkyz ), flds ( iky , ikx , iz , it , :)) end do if ( advfield_coll ) then phi (:, :, :, :) = flds (:, :, :, :, 1 ) call sum_allreduce ( phi ) end if g = g_in ! RHS is g&#94;{***} + Ze/T*<phi&#94;{n+1}>*F0 + sum_jlm psi_jlm&#94;{n+1}*delta_jl ! first two terms added via g_to_h subroutine if ( advfield_coll ) then call g_to_h ( g , phi , fphi ) end if ! add field particle contribution to RHS: if ( fieldpart ) then do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) do idx1 = 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 ij = 1 + mod ( idx1 - 1 , jmax + 1 ) il = 1 + int ( sqrt ( 1.0 * ( idx1 - ij ) / ( jmax + 1 ))) im = ( idx1 - ij ) / ( jmax + 1 ) - ( il - 1 ) ** 2 + 1 ll1 = il - 1 mm1 = - ll1 + im - 1 jj1 = ij - 1 if ( density_conservation_tp . and . ( jj1 == 0 ) . and . ( ll1 == 0 )) then isb = is g (:,:, ikxkyz ) = g (:,:, ikxkyz ) - code_dt * flds ( iky , ikx , iz , it , 2 + ( is - 1 ) * (( jmax + 1 ) * ( lmax + 1 ) ** 2 * nspec ) + ( idx1 - 1 ) * nspec + ( isb - 1 ))& * modmw (:, :, iz , is ) / modmwnorm ( iz ) else clm = sqrt ((( 2 * ll1 + 1 ) * gamma ( ll1 - mm1 + 1. )) / ( 4 * pi * gamma ( ll1 + mm1 + 1. ))) do isb = 1 , nspec if ( mm1 == 0 ) then g (:,:, ikxkyz ) = g (:,:, ikxkyz ) + code_dt * spec ( is )% vnew ( isb ) * clm * legendre_vpamu ( ll1 , mm1 ,:,:, iz ) * spread ( jm (:, mm1 , iky , ikx , iz , is ), 1 , nvpa ) & * flds ( iky , ikx , iz , it , 2 + ( is - 1 ) * (( jmax + 1 ) * ( lmax + 1 ) ** 2 * nspec ) + ( idx1 - 1 ) * nspec + ( isb - 1 )) & * ( spec ( is )% mass / spec ( isb )% mass ) ** ( - 1.5 ) * deltaj ( ll1 , jj1 , is , isb , :, :, ia , iz ) else if ( mm1 > 0 ) then g (:,:, ikxkyz ) = g (:,:, ikxkyz ) + code_dt * spec ( is )% vnew ( isb ) * clm * legendre_vpamu ( ll1 , mm1 ,:,:, iz ) * spread ( jm (:, mm1 , iky , ikx , iz , is ), 1 , nvpa ) & * flds ( iky , ikx , iz , it , 2 + ( is - 1 ) * (( jmax + 1 ) * ( lmax + 1 ) ** 2 * nspec ) + ( idx1 - 1 ) * nspec + ( isb - 1 )) & * ( spec ( is )% mass / spec ( isb )% mass ) ** ( - 1.5 ) * deltaj ( ll1 , jj1 , is , isb , :, :, ia , iz ) else if ( mm1 < 0 ) then g (:,:, ikxkyz ) = g (:,:, ikxkyz ) + ( - 1 ) ** mm1 * code_dt * spec ( is )% vnew ( isb ) * clm * legendre_vpamu ( ll1 , mm1 ,:,:, iz ) * spread ( jm (:, abs ( mm1 ), iky , ikx , iz , is ), 1 , nvpa ) & * flds ( iky , ikx , iz , it , 2 + ( is - 1 ) * (( jmax + 1 ) * ( lmax + 1 ) ** 2 * nspec ) + ( idx1 - 1 ) * nspec + ( isb - 1 )) & * ( spec ( is )% mass / spec ( isb )% mass ) ** ( - 1.5 ) * deltaj ( ll1 , jj1 , is , isb , :, :, ia , iz ) end if end do end if end do end do end if deallocate ( flds ) ! invert system to get h&#94;{n+1} do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) do iv = 1 , nvpa ghrs ( nmu * ( iv - 1 ) + 1 : nmu * iv ) = g ( iv , :, ikxkyz ) end do call zgbtrs ( 'No transpose' , nvpa * nmu , nmu + 1 , nmu + 1 , 1 , cdiffmat_band (:,:, iky , ikx , iz , is ), 3 * ( nmu + 1 ) + 1 , ipiv (:, iky , ikx , iz , is ), ghrs , nvpa * nmu , info ) do iv = 1 , nvpa g ( iv , :, ikxkyz ) = ghrs ( nmu * ( iv - 1 ) + 1 : nmu * iv ) end do end do ! get g&#94;{n+1} from h&#94;{n+1} and phi&#94;{n+1} if ( advfield_coll ) then call g_to_h ( g , phi , - fphi ) end if !fields_updated = .false. deallocate ( g_in ) deallocate ( field ) deallocate ( gvmutr ) deallocate ( ghrs ) end subroutine advance_implicit_fp subroutine advance_vpadiff_implicit ( phi , apar , g ) use mp , only : sum_allreduce use finite_differences , only : tridag use linear_solve , only : lu_back_substitution use stella_time , only : code_dt use run_parameters , only : fphi use species , only : nspec , spec , has_electron_species use zgrid , only : nzgrid , ntubes use vpamu_grids , only : nmu , nvpa use vpamu_grids , only : maxwell_vpa , maxwell_mu , vpa , vperp2 use vpamu_grids , only : set_vpa_weights use kt_grids , only : naky , nakx , zonal_mode use stella_geometry , only : dl_over_b use stella_layouts , only : kxkyz_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , it_idx , is_idx use g_tofrom_h , only : g_to_h use gyro_averages , only : aj0v use fields , only : get_fields , efac , gamtot_h use physics_flags , only : adiabatic_option_switch use physics_flags , only : adiabatic_option_fieldlineavg implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in out ) :: phi , apar complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( in out ) :: g integer :: ikxkyz , iky , ikx , iz , it , is , ia integer :: imu integer :: idx real , dimension (:, :), allocatable :: tmp complex , dimension (:, :, :, :, :), allocatable :: flds complex , dimension (:), allocatable :: tmp2 complex , dimension (:, :, :), allocatable :: flds_zf , g_in ia = 1 ! store input g for use later, as g will be overwritten below allocate ( g_in ( nvpa , nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) g_in = g ! since backwards difference in time, (I-dt*D)h_inh&#94;{n+1} = g&#94;{***} ! g = g&#94;{***}.  tridag below inverts above equation to get h_inh&#94;{n+1} do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc is = is_idx ( kxkyz_lo , ikxkyz ) do imu = 1 , nmu call tridag ( 1 , aa_vpa (:, is ), bb_vpa (:, ikxkyz ), cc_vpa (:, is ), g (:, imu , ikxkyz )) end do end do allocate ( flds ( naky , nakx , - nzgrid : nzgrid , ntubes , nresponse_vpa )) allocate ( flds_zf ( nakx , ntubes , nresponse_vpa )); flds_zf = 0. ! need to obtain phi&#94;{n+1} and conservation terms using response matrix approach ! first get phi_inh&#94;{n+1} call get_fields ( g , phi , apar , dist = 'h' , skip_fsa = . true .) flds (:, :, :, :, 1 ) = phi idx = 2 ! get upar_inh&#94;{n+1} if ( momentum_conservation ) then call get_upar ( g , flds (:, :, :, :, idx : idx + nspec - 1 )) idx = idx + nspec end if ! get temp_inh&#94;{n+1} if ( energy_conservation ) call get_temp ( g , flds (:, :, :, :, idx : idx + nspec - 1 )) phi = 0.0 do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) ! all is indices inside ikxkyz super-index have same info ! no need to compute multiple times is = is_idx ( kxkyz_lo , ikxkyz ); if ( is /= 1 ) cycle call lu_back_substitution ( vpadiff_response (:, :, ikxkyz ), vpadiff_idx (:, ikxkyz ), & flds ( iky , ikx , iz , it , :)) if (. not . has_electron_species ( spec ) . and . zonal_mode ( iky ) & . and . adiabatic_option_switch == adiabatic_option_fieldlineavg ) then flds_zf ( ikx , it , :) = flds_zf ( ikx , it , :) + dl_over_b ( ia , iz ) * flds ( iky , ikx , iz , it , :) end if phi ( iky , ikx , iz , it ) = flds ( iky , ikx , iz , it , 1 ) end do if (. not . has_electron_species ( spec ) . and . zonal_mode ( 1 ) & . and . adiabatic_option_switch == adiabatic_option_fieldlineavg ) then !complete flux-surface average call sum_allreduce ( flds_zf ) do it = 1 , ntubes do ikx = 1 , nakx call lu_back_substitution ( vpadiff_zf_response (:, :, ikx ), vpadiff_zf_idx (:, ikx ), & flds_zf ( ikx , it , :)) !multiply by Q, which has a single non-zero component flds_zf ( ikx , it , 1 ) = ( efac / gamtot_h ) * flds_zf ( ikx , it , 1 ) flds_zf ( ikx , it , 2 :) = 0. end do end do allocate ( tmp2 ( nresponse_vpa )) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) if ( iky /= 1 . or . is /= 1 ) cycle tmp2 = flds_zf ( ikx , it , :) call lu_back_substitution ( vpadiff_response (:, :, ikxkyz ), vpadiff_idx (:, ikxkyz ), & tmp2 ) phi ( 1 , ikx , iz , it ) = phi ( 1 , ikx , iz , it ) + tmp2 ( 1 ) end do deallocate ( tmp2 ) end if call sum_allreduce ( phi ) g = g_in ! RHS is g&#94;{***} + Ze/T*<phi&#94;{n+1}>*F0 + 2*dt*nu*J0*F0*(vpa*upar+(v&#94;2-3/2)*temp) ! first two terms added via g_to_h subroutine call g_to_h ( g , phi , fphi ) allocate ( tmp ( nvpa , nmu )) if ( momentum_conservation . or . energy_conservation ) then do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) tmp = 2.0 * code_dt * spec ( is )% vnew ( is ) & * spread ( maxwell_vpa (:, is ), 2 , nmu ) * spread ( aj0v (:, ikxkyz ) * maxwell_mu ( 1 , iz , :, is ), 1 , nvpa ) if ( momentum_conservation ) & g (:, :, ikxkyz ) = g (:, :, ikxkyz ) + tmp * spread ( vpa * flds ( iky , ikx , iz , it , is + 1 ), 2 , nmu ) if ( energy_conservation ) & g (:, :, ikxkyz ) = g (:, :, ikxkyz ) & + tmp * ( spread ( vpa ** 2 , 2 , nmu ) + spread ( vperp2 ( 1 , iz , :), 1 , nvpa ) - 1.5 ) * flds ( iky , ikx , iz , it , idx + is - 1 ) end do end if deallocate ( tmp , flds , flds_zf ) ! now invert system to get h&#94;{n+1} do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc is = is_idx ( kxkyz_lo , ikxkyz ) do imu = 1 , nmu call tridag ( 1 , aa_vpa (:, is ), bb_vpa (:, ikxkyz ), cc_vpa (:, is ), g (:, imu , ikxkyz )) end do end do ! now get g&#94;{n+1} from h&#94;{n+1} and phi&#94;{n+1} call g_to_h ( g , phi , - fphi ) deallocate ( g_in ) end subroutine advance_vpadiff_implicit subroutine advance_mudiff_implicit ( phi , apar , g ) use mp , only : sum_allreduce use finite_differences , only : tridag use linear_solve , only : lu_back_substitution use stella_time , only : code_dt use run_parameters , only : fphi use species , only : nspec , spec , has_electron_species use zgrid , only : nzgrid , ntubes use vpamu_grids , only : nmu , nvpa use vpamu_grids , only : maxwell_vpa , maxwell_mu , vpa , vperp2 use vpamu_grids , only : set_vpa_weights use kt_grids , only : naky , nakx , zonal_mode use stella_layouts , only : kxkyz_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , it_idx , is_idx use dist_fn_arrays , only : kperp2 use gyro_averages , only : aj0v , aj1v use g_tofrom_h , only : g_to_h use fields , only : get_fields , efac , gamtot_h use stella_geometry , only : bmag , dl_over_b use physics_flags , only : adiabatic_option_switch use physics_flags , only : adiabatic_option_fieldlineavg ! TMP FOR TESTING !    use vpamu_grids, only: mu implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in out ) :: phi , apar complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( in out ) :: g integer :: ikxkyz , iky , ikx , iz , it , is , ia integer :: iv integer :: idx ! TMP FOR TESTING !    integer :: imu real , dimension (:, :), allocatable :: tmp complex , dimension (:), allocatable :: tmp2 complex , dimension (:, :, :, :, :), allocatable :: flds complex , dimension (:, :, :), allocatable :: flds_zf , g_in ia = 1 ! store input g for use later, as g will be overwritten below allocate ( g_in ( nvpa , nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) g_in = g ! since backwards difference in time, (I-dt*D)h_inh&#94;{n+1} = g&#94;{***} ! g = g&#94;{***}.  tridag below inverts above equation to get h_inh&#94;{n+1} do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) ! TMP FOR TESTING !       do imu = 1, nmu !          g(:,imu,ikxkyz) = maxwell_vpa*maxwell_mu(1,iz,imu) !       end do do iv = 1 , nvpa call tridag ( 1 , aa_mu ( iz , :, is ), bb_mu (:, ikxkyz ), cc_mu ( iz , :, is ), g ( iv , :, ikxkyz )) end do ! TMP FOR TESTING !       iv = nvpa/2 !       do imu = 1, nmu !          write (*,*) 'ggg', mu(imu), real(g(iv,imu,ikxkyz)), aimag(g(iv,imu,ikxkyz)), maxwell_vpa(iv,is)*maxwell_mu(1,iz,imu) !       end do end do allocate ( flds ( naky , nakx , - nzgrid : nzgrid , ntubes , nresponse_mu )) allocate ( flds_zf ( nakx , ntubes , nresponse_mu )); flds_zf = 0. ! need to obtain phi&#94;{n+1} and conservation terms using response matrix approach ! first get phi_inh&#94;{n+1} call get_fields ( g , phi , apar , dist = 'h' , skip_fsa = . true .) flds (:, :, :, :, 1 ) = phi idx = 2 ! get upar_inh&#94;{n+1} if ( momentum_conservation ) then call get_uperp ( g , flds (:, :, :, :, idx : idx + nspec - 1 )) idx = idx + nspec end if ! get temp_inh&#94;{n+1} if ( energy_conservation ) call get_temp_mu ( g , flds (:, :, :, :, idx : idx + nspec - 1 )) phi = 0.0 do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) ! all is indices inside ikxkyz super-index have same info ! no need to compute multiple times is = is_idx ( kxkyz_lo , ikxkyz ); if ( is /= 1 ) cycle call lu_back_substitution ( mudiff_response (:, :, ikxkyz ), mudiff_idx (:, ikxkyz ), & flds ( iky , ikx , iz , it , :)) if (. not . has_electron_species ( spec ) . and . zonal_mode ( iky ) & . and . adiabatic_option_switch == adiabatic_option_fieldlineavg ) then flds_zf ( ikx , it , :) = flds_zf ( ikx , it , :) + dl_over_b ( ia , iz ) * flds ( iky , ikx , iz , it , :) end if phi ( iky , ikx , iz , it ) = flds ( iky , ikx , iz , it , 1 ) end do if (. not . has_electron_species ( spec ) . and . zonal_mode ( 1 ) & . and . adiabatic_option_switch == adiabatic_option_fieldlineavg ) then !complete flux-surface average call sum_allreduce ( flds_zf ) do it = 1 , ntubes do ikx = 1 , nakx call lu_back_substitution ( mudiff_zf_response (:, :, ikx ), mudiff_zf_idx (:, ikx ), & flds_zf ( ikx , it , :)) !multiply by Q, which has a single non-zero component flds_zf ( ikx , it , 1 ) = ( efac / gamtot_h ) * flds_zf ( ikx , it , 1 ) flds_zf ( ikx , it , 2 :) = 0. end do end do allocate ( tmp2 ( nresponse_mu )) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) if ( iky /= 1 . or . is /= 1 ) cycle tmp2 = flds_zf ( ikx , it , :) call lu_back_substitution ( mudiff_response (:, :, ikxkyz ), mudiff_idx (:, ikxkyz ), & tmp2 ) phi ( 1 , ikx , iz , it ) = phi ( 1 , ikx , iz , it ) + tmp2 ( 1 ) end do deallocate ( tmp2 ) end if call sum_allreduce ( phi ) g = g_in ! RHS is g&#94;{***} + Ze/T*<phi&#94;{n+1}>*F0 + ... ! first two terms added via g_to_h subroutine call g_to_h ( g , phi , fphi ) allocate ( tmp ( nvpa , nmu )) if ( momentum_conservation . or . energy_conservation ) then do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) tmp = 2.0 * code_dt * spec ( is )% vnew ( is ) & * spread ( maxwell_vpa (:, is ), 2 , nmu ) * spread ( maxwell_mu ( 1 , iz , :, is ), 1 , nvpa ) if ( momentum_conservation ) & g (:, :, ikxkyz ) = g (:, :, ikxkyz ) + tmp * kperp2 ( iky , ikx , ia , iz ) & * spread ( vperp2 ( ia , iz , :) * aj1v (:, ikxkyz ), 1 , nvpa ) * ( spec ( is )% smz / bmag ( ia , iz )) ** 2 & * flds ( iky , ikx , iz , it , is + 1 ) if ( energy_conservation ) & g (:, :, ikxkyz ) = g (:, :, ikxkyz ) & + flds ( iky , ikx , iz , it , idx + is - 1 ) * tmp * spread ( aj0v (:, ikxkyz ), 1 , nvpa ) & * ( spread ( vpa ** 2 , 2 , nmu ) + spread ( vperp2 ( 1 , iz , :), 1 , nvpa ) - 1.5 ) end do end if deallocate ( tmp , flds , flds_zf ) ! now invert system to get h&#94;{n+1} do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) do iv = 1 , nvpa call tridag ( 1 , aa_mu ( iz , :, is ), bb_mu (:, ikxkyz ), cc_mu ( iz , :, is ), g ( iv , :, ikxkyz )) end do end do ! now get g&#94;{n+1} from h&#94;{n+1} and phi&#94;{n+1} call g_to_h ( g , phi , - fphi ) deallocate ( g_in ) end subroutine advance_mudiff_implicit subroutine advance_hyper_dissipation ( g ) use stella_time , only : code_dt use zgrid , only : nzgrid , ntubes , zed use stella_layouts , only : vmu_lo use dist_fn_arrays , only : kperp2 use kt_grids , only : ikx_max , naky , nakx use kt_grids , only : aky , akx , theta0 , zonal_mode use stella_geometry , only : geo_surf , q_as_x implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: g integer :: ia , ivmu , iz , it , iky real :: tfac real :: k2max if (. not . use_physical_ksqr ) then ! avoid spatially dependent kperp !get k2max at outboard midplane k2max = akx ( ikx_max ) ** 2 + aky ( naky ) ** 2 tfac = geo_surf % shat ** 2 if ( q_as_x ) tfac = 1.0 ! add in hyper-dissipation of form dg/dt = -D*(k/kmax)&#94;4*g do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid do iky = 1 , naky if ( zonal_mode ( iky )) then g ( iky , :, iz , it , ivmu ) = g ( iky , :, iz , it , ivmu ) / ( 1. + code_dt * ( akx (:) ** 2 / k2max ) ** 2 * D_hyper ) else g ( iky , :, iz , it , ivmu ) = g ( iky , :, iz , it , ivmu ) / ( 1. + code_dt * ( aky ( iky ) ** 2 & * ( 1.0 + tfac * ( zed ( iz ) - theta0 ( iky , :)) ** 2 ) / k2max ) ** 2 * D_hyper ) end if end do end do end do !        g(:,:,:,:,ivmu) = g(:,:,:,:,ivmu)/(1.+code_dt & !           * (spread(spread(spread(akx**2,1,naky)+spread(aky**2,2,nakx),3,nztot),4,ntubes)/k2max)**2*D_hyper) end do else k2max = maxval ( kperp2 ) ia = 1 ! add in hyper-dissipation of form dg/dt = -D*(k/kmax)&#94;4*g do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc g (:, :, :, :, ivmu ) = g (:, :, :, :, ivmu ) / ( 1. + code_dt * ( spread ( kperp2 (:, :, ia , :), 4 , ntubes ) / k2max ) ** 2 * D_hyper ) end do end if end subroutine advance_hyper_dissipation end module dissipation","tags":"","loc":"sourcefile/dissipation.f90.html"},{"title":"kt_grids.f90 â€“ stella","text":"Contents Modules kt_grids Source Code kt_grids.f90 Source Code ! Set up the perpendicular wavenumbers by calling the appropriate sub-modules. module kt_grids implicit none public :: init_kt_grids , finish_kt_grids public :: read_kt_grids_parameters , box public :: aky , theta0 , akx , zed0 public :: aky_all , aky_all_ordered public :: naky , nakx , nx , ny , reality public :: dx , dy , dkx , dky , dx_d public :: jtwist , jtwistfac , ikx_twist_shift , x0 , y0 public :: x , x_d , y public :: rho , rho_d , rho_clamped , rho_d_clamped public :: nalpha public :: ikx_max , naky_all public :: phase_shift_fac public :: zonal_mode public :: swap_kxky , swap_kxky_back public :: swap_kxky_ordered , swap_kxky_back_ordered public :: multiply_by_rho , centered_in_rho public :: periodic_variation public :: communicate_ktgrids_multibox public :: boundary_size , copy_size , krook_size private interface swap_kxky module procedure swap_kxky_real module procedure swap_kxky_complex end interface interface swap_kxky_ordered module procedure swap_kxky_ordered_real module procedure swap_kxky_ordered_complex end interface real , dimension (:, :), allocatable :: theta0 , zed0 real , dimension (:), allocatable :: aky , akx , aky_all , aky_all_ordered real , dimension (:), allocatable :: x , x_d , y real , dimension (:), allocatable :: rho , rho_d , rho_clamped , rho_d_clamped complex , dimension (:, :), allocatable :: g0x real :: dx , dy , dkx , dky , dx_d real :: jtwistfac , phase_shift_fac integer :: naky , nakx , nx , ny , nalpha integer :: jtwist , ikx_twist_shift integer :: ikx_max , naky_all integer :: boundary_size , copy_size , krook_size logical :: reality = . false . logical :: centered_in_rho , periodic_variation , randomize_phase_shift character ( 20 ) :: grid_option logical , dimension (:), allocatable :: zonal_mode namelist / kt_grids_knobs / grid_option ! internal variables integer :: gridopt_switch integer , parameter :: gridopt_range = 1 , gridopt_box = 2 real :: aky_min , aky_max real :: akx_min , akx_max real :: theta0_min , theta0_max real :: x0 , y0 logical :: read_kt_grids_initialized = . false . logical :: init_kt_grids_initialized = . false . logical :: box contains subroutine read_kt_grids_parameters use mp , only : proc0 implicit none if ( read_kt_grids_initialized ) return read_kt_grids_initialized = . true . if ( proc0 ) then call read_grid_option select case ( gridopt_switch ) case ( gridopt_range ) call read_kt_grids_range case ( gridopt_box ) call read_kt_grids_box end select end if call broadcast_input call allocate_arrays end subroutine read_kt_grids_parameters subroutine read_grid_option use file_utils , only : input_unit , error_unit , input_unit_exist use text_options , only : text_option , get_option_value implicit none type ( text_option ), dimension ( 5 ), parameter :: gridopts = & ( / text_option ( 'default' , gridopt_range ), & text_option ( 'range' , gridopt_range ), & text_option ( 'box' , gridopt_box ), & text_option ( 'annulus' , gridopt_box ), & text_option ( 'nonlinear' , gridopt_box ) / ) integer :: ierr , in_file logical :: nml_exist grid_option = 'default' in_file = input_unit_exist ( \"kt_grids_knobs\" , nml_exist ) if ( nml_exist ) read ( unit = in_file , nml = kt_grids_knobs ) ierr = error_unit () call get_option_value ( grid_option , gridopts , gridopt_switch , & ierr , \"grid_option in kt_grids_knobs\" ) end subroutine read_grid_option subroutine read_kt_grids_box use file_utils , only : input_unit_exist use physics_flags , only : full_flux_surface implicit none integer :: in_file logical :: exist namelist / kt_grids_box_parameters / nx , ny , jtwist , jtwistfac , y0 , & centered_in_rho , periodic_variation , & randomize_phase_shift , phase_shift_fac ! note that jtwist and y0 will possibly be modified ! later in init_kt_grids_box if they make it out ! of this subroutine with negative values ! it is necessary to wait until later to do this check ! because the values to which they may be set will ! depend on information from the geometry module, ! which itself may rely on ny from here (number of alphas) nx = 1 ny = 1 jtwist = - 1 jtwistfac = 1. phase_shift_fac = 0. y0 = - 1.0 nalpha = 1 centered_in_rho = . true . randomize_phase_shift = . false . periodic_variation = . false . in_file = input_unit_exist ( \"kt_grids_box_parameters\" , exist ) if ( exist ) read ( in_file , nml = kt_grids_box_parameters ) ! get the number of de-aliased modes in y and x, using reality to halve the number of ky modes naky = ( ny - 1 ) / 3 + 1 nakx = 2 * (( nx - 1 ) / 3 ) + 1 ! get the total number of ky values, including negative ky; ! this is approximately 2/3 ny because ny includes padding to avoid aliasing naky_all = 2 * naky - 1 reality = . true . if ( full_flux_surface ) nalpha = ny end subroutine read_kt_grids_box subroutine read_kt_grids_range use mp , only : mp_abort , proc0 use file_utils , only : input_unit , input_unit_exist use physics_flags , only : full_flux_surface implicit none integer :: in_file logical :: exist namelist / kt_grids_range_parameters / naky , nakx , & aky_min , aky_max , theta0_min , theta0_max , akx_min , akx_max nalpha = 1 naky = 1 nakx = 1 aky_min = 0.0 aky_max = 0.0 ! set these to be nonsense values ! so can check later if they've been set akx_min = 0.0 akx_max = - 1.0 theta0_min = 0.0 theta0_max = - 1.0 in_file = input_unit_exist ( \"kt_grids_range_parameters\" , exist ) if ( exist ) read ( in_file , nml = kt_grids_range_parameters ) if ( full_flux_surface ) then if ( proc0 ) then write ( * , * ) '!!! ERROR !!!' write ( * , * ) 'kt_grids \"range\" option is not supported for full_flux_surface = T. aborting' write ( * , * ) '!!! ERROR !!!' end if call mp_abort ( 'kt_grids \"range\" option is not supported for full_flux_surface = T. aborting' ) end if naky_all = naky end subroutine read_kt_grids_range subroutine init_kt_grids use common_types , only : flux_surface_type use zgrid , only : init_zgrid implicit none if ( init_kt_grids_initialized ) return init_kt_grids_initialized = . true . call init_zgrid select case ( gridopt_switch ) case ( gridopt_range ) call init_kt_grids_range case ( gridopt_box ) call init_kt_grids_box end select !> determine if iky corresponds to zonal mode if (. not . allocated ( zonal_mode )) allocate ( zonal_mode ( naky )) zonal_mode = . false . if ( abs ( aky ( 1 )) < epsilon ( 0. )) zonal_mode ( 1 ) = . true . end subroutine init_kt_grids subroutine init_kt_grids_box use mp , only : mp_abort , proc0 , broadcast use common_types , only : flux_surface_type use constants , only : pi , zi use stella_geometry , only : geo_surf , twist_and_shift_geo_fac , dydalpha use stella_geometry , only : q_as_x , get_x_to_rho , dxdXcoord , drhodpsi use physics_parameters , only : rhostar use physics_flags , only : full_flux_surface , radial_variation use file_utils , only : runtype_option_switch , runtype_multibox use zgrid , only : shat_zero , nperiod , grad_x_grad_y_zero use zgrid , only : twist_shift_option_switch , twist_shift_option_std , twist_shift_option_stellarator use zgrid , only : twist_shift_option_periodic use ran , only : ranf implicit none integer :: ikx , iky integer :: ikyneg real :: x_shift , dqdrho , pfac , norm box = . true . !> set jtwist and y0 for cases where they have not been specified !> and for which it makes sense to set them automatically if ( jtwist < 1 ) then jtwist = max ( 1 , int ( abs ( twist_and_shift_geo_fac ) + 0.5 )) jtwist = max ( 1 , int ( jtwistfac * jtwist + 0.5 )) end if !> signed version of jtwist, with sign determined by, e.g., magnetic shear ikx_twist_shift = - jtwist * int ( sign ( 1.0 , twist_and_shift_geo_fac )) if ( y0 < 0. ) then if ( full_flux_surface ) then !> if simulating a flux annulus, then !> y0 determined by the physical !> extent of the device if ( rhostar > 0. ) then !y0 = 1./(rhostar*geo_surf%rhotor) y0 = geo_surf % rhotor / rhostar else call mp_abort ( 'must set rhostar if simulating a full flux surface. aborting.' ) end if else !> if simulating a flux tube !> makes no sense to have y0 < 0.0 !> so abort call mp_abort ( 'y0 negative only makes sense when simulating a flux annulus.  aborting.' ) end if end if !> get the grid spacing in ky and then in kx using twist-and-shift BC dky = 1. / y0 ! kx = ky * twist_shift_geo_fac / jtwist for every linked boundary condition ! except for the periodic ones select case ( twist_shift_option_switch ) case ( twist_shift_option_std ) dkx = ( 2 * nperiod - 1 ) * dky * abs ( twist_and_shift_geo_fac ) / real ( jtwist ) case ( twist_shift_option_stellarator ) dkx = dky * abs ( twist_and_shift_geo_fac ) / real ( jtwist ) case ( twist_shift_option_periodic ) !> MAB: this seems overly restrictive; should allow for arbitrary box aspect ratio via inpur parameter dkx = dky end select x0 = 1. / dkx !> ky goes from zero to ky_max do iky = 1 , naky aky ( iky ) = real ( iky - 1 ) * dky end do !> get the ikx index corresponding to kx_max ikx_max = nakx / 2 + 1 !> aky_all contains all ky values (positive and negative), !> stored in the same order as akx (0 -> ky_max, -ky_max -> -dky) !> first set arrays equal for ky >= 0 aky_all (: naky ) = aky !> aky_all_ordered contains all ky values, stored from !> most negative to most positive (-ky_max -> ky_max) aky_all_ordered ( naky : naky_all ) = aky !> next fill in ky < 0 do iky = naky + 1 , naky_all !> this is the ky index corresponding to +ky in original array ikyneg = naky_all - iky + 2 aky_all ( iky ) = - aky ( ikyneg ) end do aky_all_ordered (: naky - 1 ) = aky_all ( naky + 1 :) !> kx goes from zero to kx_max down to zero... do ikx = 1 , ikx_max akx ( ikx ) = real ( ikx - 1 ) * dkx end do !> and then from -kx_max to -|kx_min| do ikx = ikx_max + 1 , nakx akx ( ikx ) = real ( ikx - nakx - 1 ) * dkx end do !> set theta0=0 for ky=0 theta0 ( 1 , :) = 0.0 if ( q_as_x ) then do ikx = 1 , nakx !> theta0 = kx/ky theta0 ( 2 :, ikx ) = akx ( ikx ) / aky ( 2 :) end do else do ikx = 1 , nakx !> theta0 = kx/ky/shat theta0 ( 2 :, ikx ) = akx ( ikx ) / ( aky ( 2 :) * geo_surf % shat ) end do end if norm = 1. if ( naky > 1 ) norm = aky ( 2 ) if ( rhostar > 0. ) then phase_shift_fac = - 2. * pi * ( 2 * nperiod - 1 ) * geo_surf % qinp_psi0 * dydalpha / rhostar else if ( randomize_phase_shift ) then if ( proc0 ) phase_shift_fac = 2. * pi * ranf () / norm call broadcast ( phase_shift_fac ) else phase_shift_fac = phase_shift_fac / norm end if !> MAB: a lot of the radial variation coding below should probably be tidied away !> into one or more separate subroutines !> for radial variation if (. not . allocated ( x_d )) allocate ( x_d ( nakx )) if (. not . allocated ( rho )) allocate ( rho ( nx )) if (. not . allocated ( rho_d )) allocate ( rho_d ( nakx )) if (. not . allocated ( rho_clamped )) allocate ( rho_clamped ( nx )) if (. not . allocated ( rho_d_clamped )) allocate ( rho_d_clamped ( nakx )) if (. not . allocated ( x )) allocate ( x ( nx )) if (. not . allocated ( y )) allocate ( y ( ny )) dx = ( 2 * pi * x0 ) / nx dy = ( 2 * pi * y0 ) / ny x_shift = pi * x0 pfac = 1.0 if ( centered_in_rho ) then if ( q_as_x ) then dqdrho = geo_surf % shat * geo_surf % qinp / geo_surf % rhoc x_shift = pi * x0 * ( 1.0 & - 0.5 * pfac * rhostar * pi * x0 * geo_surf % d2qdr2 / ( dqdrho ** 2 * dxdXcoord )) else x_shift = pi * x0 * ( 1.0 & - 0.5 * pfac * rhostar * pi * x0 * geo_surf % d2psidr2 * drhodpsi ** 2 / dxdXcoord ) end if end if do ikx = 1 , nx if ( radial_variation . or . runtype_option_switch == runtype_multibox ) then if ( periodic_variation ) then if ( ikx <= nx / 2 ) then x ( ikx ) = ( ikx - 1 ) * dx - 0.5 * x_shift else x ( ikx ) = x ( nx - ikx + 1 ) end if else x ( ikx ) = ( ikx - 0.5 ) * dx - x_shift end if else x ( ikx ) = ( ikx - 1 ) * dx end if end do dx_d = ( 2 * pi * x0 ) / nakx do ikx = 1 , nakx if ( radial_variation . or . runtype_option_switch == runtype_multibox ) then if ( periodic_variation ) then if ( ikx <= ( nakx + 1 ) / 2 ) then x_d ( ikx ) = ( ikx - 1 ) * dx_d - 0.5 * x_shift else x_d ( ikx ) = x_d ( nakx - ikx + 1 ) end if else x_d ( ikx ) = ( ikx - 0.5 ) * dx_d - x_shift end if else x_d ( ikx ) = ( ikx - 1 ) * dx_d end if end do call get_x_to_rho ( 1 , x , rho ) call get_x_to_rho ( 1 , x_d , rho_d ) if (. not . allocated ( rho_clamped )) allocate ( rho_clamped ( nx )); rho_clamped = rho if (. not . allocated ( rho_d_clamped )) allocate ( rho_d_clamped ( nakx )); rho_d_clamped = rho_d zed0 = theta0 * geo_surf % zed0_fac if ( radial_variation ) call dump_radial_grid if ( radial_variation . and . ( any (( rho + geo_surf % rhoc ) < 0.0 ) & . or . any (( rho + geo_surf % rhoc ) > 1.0 ))) then call mp_abort ( 'rho(x) is beyond range [0,1]. Try changing rhostar or q/psi profiles' ) end if do iky = 1 , ny y ( iky ) = ( iky - 1 ) * dy end do end subroutine init_kt_grids_box subroutine init_kt_grids_range use mp , only : mp_abort use common_types , only : flux_surface_type use stella_geometry , only : geo_surf , q_as_x use zgrid , only : shat_zero implicit none integer :: i , j real :: dkx , dky , dtheta0 , tfac real :: zero box = . false . ! NB: we are assuming here that all ky are positive ! when running in range mode dky = 0.0 if ( naky > 1 ) dky = ( aky_max - aky_min ) / real ( naky - 1 ) aky = ( / ( aky_min + dky * real ( i ), i = 0 , naky - 1 ) / ) ! set default akx and theta0 to 0 akx = 0.0 ; theta0 = 0.0 if ( q_as_x ) then tfac = 1.0 else tfac = geo_surf % shat end if zero = 10 0. * epsilon ( 0. ) ! if theta0_min and theta0_max have been specified, ! use them to determine akx_min and akx_max if ( theta0_max > theta0_min - zero ) then if ( geo_surf % shat > epsilon ( 0. )) then akx_min = theta0_min * tfac * aky ( 1 ) akx_max = theta0_max * tfac * aky ( 1 ) else akx_min = theta0_max * tfac * aky ( 1 ) akx_max = theta0_min * tfac * aky ( 1 ) end if end if ! shat_zero is minimum shat value below which periodic BC is enforced if ( abs ( geo_surf % shat ) > shat_zero ) then ! ie assumes boundary_option .eq. 'linked' ! if akx_min and akx_max specified in input ! instead of theta0_min and theta0_max, ! use them to get theta0_min and theta0_max if ( theta0_min > theta0_max + zero . and . abs ( aky ( 1 )) > zero ) then theta0_min = akx_min / ( tfac * aky ( 1 )) theta0_max = akx_max / ( tfac * aky ( 1 )) dtheta0 = 0.0 if ( nakx > 1 ) dtheta0 = ( theta0_max - theta0_min ) / real ( nakx - 1 ) do j = 1 , naky theta0 ( j , :) & = ( / ( theta0_min + dtheta0 * real ( i ), i = 0 , nakx - 1 ) / ) end do akx = theta0 ( 1 , :) * tfac * aky ( 1 ) else if ( akx_max > akx_min - zero . or . nakx == 1 ) then dkx = 0.0 if ( nakx > 1 ) dkx = ( akx_max - akx_min ) / real ( nakx - 1 ) akx = ( / ( akx_min + dkx * real ( i ), i = 0 , nakx - 1 ) / ) dtheta0 = 0.0 if ( nakx > 1 ) dtheta0 = ( theta0_max - theta0_min ) / real ( nakx - 1 ) if ( geo_surf % shat > epsilon ( 0. )) then do j = 1 , naky theta0 ( j , :) & = ( / ( theta0_min + dtheta0 * real ( i ), i = 0 , nakx - 1 ) / ) end do else do j = 1 , naky theta0 ( j , :) & = ( / ( theta0_min + dtheta0 * real ( i ), i = nakx - 1 , 0 , - 1 ) / ) end do end if else call mp_abort ( 'ky=0 is inconsistent with kx_min different from kx_max. aborting.' ) end if else ! here assume boundary_option .eq. 'periodic' ! used for periodic finite kx ballooning space runs with shat=0 dkx = 0.0 if ( nakx > 1 ) dkx = ( akx_max - akx_min ) / real ( nakx - 1 ) akx = ( / ( akx_min + dkx * real ( i ), i = 0 , nakx - 1 ) / ) end if ikx_max = nakx naky_all = naky end subroutine init_kt_grids_range subroutine broadcast_input use mp , only : broadcast implicit none call broadcast ( gridopt_switch ) call broadcast ( centered_in_rho ) call broadcast ( periodic_variation ) call broadcast ( naky ) call broadcast ( naky_all ) call broadcast ( nakx ) call broadcast ( ny ) call broadcast ( nx ) call broadcast ( nalpha ) call broadcast ( reality ) call broadcast ( jtwist ) call broadcast ( jtwistfac ) call broadcast ( y0 ) call broadcast ( aky_min ) call broadcast ( aky_max ) call broadcast ( akx_min ) call broadcast ( akx_max ) call broadcast ( theta0_min ) call broadcast ( theta0_max ) call broadcast ( randomize_phase_shift ) call broadcast ( phase_shift_fac ) end subroutine broadcast_input subroutine dump_radial_grid use file_utils , only : run_name use physics_parameters , only : rhostar use stella_geometry , only : q_as_x , geo_surf , dxdXcoord , drhodpsi implicit none integer :: ix character ( 300 ) :: filename filename = trim ( trim ( run_name ) // '.radial_grid' ) open ( 1047 , file = filename , status = 'unknown' ) if ( q_as_x ) then write ( 1047 , '(1a12,1e12.4,1a12,1e12.4,1a12,1e12.4,1a12,1e12.4)' ) & '#dxdXcoord = ' , dxdXcoord , & ' q    = ' , geo_surf % qinp , & ' dqdr = ' , geo_surf % shat * geo_surf % qinp / geo_surf % rhoc , & ' d2qdr2 = ' , geo_surf % d2qdr2 write ( 1047 , '(3a12)' ) '#1.x' , '2.q' , '3.rho' do ix = 1 , nx write ( 1047 , '(3e12.4,i9)' ) & x ( ix ), & rhostar * x ( ix ) / dxdXcoord + geo_surf % qinp , & rho ( ix ) + geo_surf % rhoc end do else write ( 1047 , '(1a12,1e12.4,1a12,1e12.4,1a12,1e12.4,1a12,1e12.4)' ) & '#dxdXcoord = ' , dxdXcoord , & ' dpsidr    = ' , 1.0 / drhodpsi , & ' d2psidr2 = ' , geo_surf % d2psidr2 write ( 1047 , '(3a12,a9)' ) '#1.x' , '2.psi-psi0' , '3.rho' do ix = 1 , nx write ( 1047 , '(3e12.4,i9)' ) & x ( ix ), & rhostar * x ( ix ) / dxdXcoord , & rho ( ix ) + geo_surf % rhoc end do end if close ( 1047 ) end subroutine dump_radial_grid subroutine allocate_arrays implicit none allocate ( akx ( nakx )) allocate ( aky ( naky )) allocate ( aky_all ( naky_all )) allocate ( aky_all_ordered ( naky_all )) allocate ( theta0 ( naky , nakx )) allocate ( zed0 ( naky , nakx )) end subroutine allocate_arrays ! take an array with ky >= 0 and all kx (ordered like 0, ..., kxmax, -kxmax, ..., -dkx) ! and uses reality condition to return array ! with kx >= 0 and all ky (ordered like 0, ..., kymax, -kymax, ..., -dky) subroutine swap_kxky_complex ( gin , gout ) implicit none complex , dimension (:, :), intent ( in ) :: gin complex , dimension (:, :), intent ( out ) :: gout integer :: ikx , ikxneg integer :: iky , ikyneg ! first set arrays equal for ky >= 0 and kx >= 0 gout (: naky , :) = gin (:, : ikx_max ) ! next fill in ky < 0, kx >= 0 elements of array using reality ikx = 1 ikxneg = ikx do iky = naky + 1 , naky_all ! this is the ky index corresponding to +ky in original array ikyneg = naky_all - iky + 2 gout ( iky , ikx ) = conjg ( gin ( ikyneg , ikxneg )) end do do ikx = 2 , ikx_max ikxneg = nakx - ikx + 2 do iky = naky + 1 , naky_all ! this is the ky index corresponding to +ky in original array ikyneg = naky_all - iky + 2 gout ( iky , ikx ) = conjg ( gin ( ikyneg , ikxneg )) end do end do end subroutine swap_kxky_complex ! take an array with ky >= 0 and all kx (ordered like 0, ..., kxmax, -kxmax, ..., -dkx) ! and uses reality condition to return array ! with kx >= 0 and all ky (ordered like 0, ..., kymax, -kymax, ..., -dky) subroutine swap_kxky_real ( gin , gout ) implicit none real , dimension (:, :), intent ( in ) :: gin real , dimension (:, :), intent ( out ) :: gout integer :: ikx , ikxneg integer :: iky , ikyneg ! first set arrays equal for ky >= 0 and kx >= 0 gout (: naky , :) = gin (:, : ikx_max ) ! next fill in ky < 0, kx >= 0 elements of array using reality ikx = 1 ikxneg = ikx do iky = naky + 1 , naky_all ! this is the ky index corresponding to +ky in original array ikyneg = naky_all - iky + 2 gout ( iky , ikx ) = gin ( ikyneg , ikxneg ) end do do ikx = 2 , ikx_max ikxneg = nakx - ikx + 2 do iky = naky + 1 , naky_all ! this is the ky index corresponding to +ky in original array ikyneg = naky_all - iky + 2 gout ( iky , ikx ) = gin ( ikyneg , ikxneg ) end do end do end subroutine swap_kxky_real ! take an array with ky >= 0 and all kx (ordered like 0, ..., kxmax, -kxmax, ..., -dkx) ! and uses reality condition to return array ! with kx >= 0 and all ky (ordered like -kymax, ..., 0, ..., kymax) subroutine swap_kxky_ordered_real ( gin , gout ) implicit none real , dimension (:, :), intent ( in ) :: gin real , dimension (:, :), intent ( out ) :: gout integer :: ikx , ikxneg integer :: iky , ikyneg ! first set arrays equal for ky >= 0 and kx >= 0 gout ( naky :, :) = gin (:, : ikx_max ) ! next fill in ky < 0, kx >= 0 elements of array using reality ikx = 1 ikxneg = ikx do iky = 1 , naky - 1 ! this is the ky index corresponding to +ky in original array ikyneg = naky - iky + 1 gout ( iky , ikx ) = gin ( ikyneg , ikxneg ) end do do ikx = 2 , ikx_max ikxneg = nakx - ikx + 2 do iky = 1 , naky - 1 ! this is the ky index corresponding to +ky in original array ikyneg = naky - iky + 1 gout ( iky , ikx ) = gin ( ikyneg , ikxneg ) end do end do end subroutine swap_kxky_ordered_real ! take an array with ky >= 0 and all kx (ordered like 0, ..., kxmax, -kxmax, ..., -dkx) ! and uses reality condition to return array ! with kx >= 0 and all ky (ordered like -kymax, ..., 0, ..., kymax) subroutine swap_kxky_ordered_complex ( gin , gout ) implicit none complex , dimension (:, :), intent ( in ) :: gin complex , dimension (:, :), intent ( out ) :: gout integer :: ikx , ikxneg integer :: iky , ikyneg ! first set arrays equal for ky >= 0 and kx >= 0 gout ( naky :, :) = gin (:, : ikx_max ) ! next fill in ky < 0, kx >= 0 elements of array using reality ikx = 1 ikxneg = ikx do iky = 1 , naky - 1 ! this is the ky index corresponding to +ky in original array ikyneg = naky - iky + 1 gout ( iky , ikx ) = conjg ( gin ( ikyneg , ikxneg )) end do do ikx = 2 , ikx_max ikxneg = nakx - ikx + 2 do iky = 1 , naky - 1 ! this is the ky index corresponding to +ky in original array ikyneg = naky - iky + 1 gout ( iky , ikx ) = conjg ( gin ( ikyneg , ikxneg )) end do end do end subroutine swap_kxky_ordered_complex ! take an array with kx >= 0 and all ky (ordered like 0, ..., kymax, -kymax, ..., -dky) ! and uses reality condition to return array ! with ky >= 0 and all kx (ordered like 0, ..., kxmax, -kxmax, ..., -dkx) subroutine swap_kxky_back ( gin , gout ) implicit none complex , dimension (:, :), intent ( in ) :: gin complex , dimension (:, :), intent ( out ) :: gout integer :: ikx , ikxneg integer :: iky , ikyneg ! first set arrays equal for ky >= 0 and kx >= 0 gout (:, : ikx_max ) = gin (: naky , :) ! next fill in kx < 0, ky >= 0 elements of array using reality do ikx = ikx_max + 1 , nakx ikxneg = nakx - ikx + 2 iky = 1 ikyneg = iky gout ( iky , ikx ) = conjg ( gin ( ikyneg , ikxneg )) do iky = 2 , naky ikyneg = naky_all - iky + 2 gout ( iky , ikx ) = conjg ( gin ( ikyneg , ikxneg )) end do end do end subroutine swap_kxky_back ! take an array with kx >= 0 and all ky (ordered like -kymax, ..., 0, ..., kymax) ! and uses reality condition to return array ! with ky >= 0 and all kx (ordered like 0, ..., kxmax, -kxmax, ..., -dkx) subroutine swap_kxky_back_ordered ( gin , gout ) implicit none complex , dimension (:, :), intent ( in ) :: gin complex , dimension (:, :), intent ( out ) :: gout integer :: ikx , ikxneg integer :: iky , ikyneg ! first set arrays equal for ky >= 0 and kx >= 0 gout (:, : ikx_max ) = gin ( naky :, :) ! next fill in kx < 0, ky >= 0 elements of array using reality do ikx = ikx_max + 1 , nakx ikxneg = nakx - ikx + 2 do iky = 1 , naky ikyneg = naky - iky + 1 gout ( iky , ikx ) = conjg ( gin ( ikyneg , ikxneg )) end do end do end subroutine swap_kxky_back_ordered subroutine communicate_ktgrids_multibox use job_manage , only : njobs use mp , only : job , scope , & crossdomprocs , subprocs , & send , receive implicit none call scope ( crossdomprocs ) if ( job == 1 ) then call send ( phase_shift_fac , 0 , 120 ) call send ( phase_shift_fac , njobs - 1 , 130 ) elseif ( job == 0 ) then call receive ( phase_shift_fac , 1 , 120 ) elseif ( job == njobs - 1 ) then call receive ( phase_shift_fac , 1 , 130 ) end if call scope ( subprocs ) end subroutine communicate_ktgrids_multibox subroutine finish_kt_grids implicit none if ( allocated ( aky )) deallocate ( aky ) if ( allocated ( aky_all )) deallocate ( aky_all ) if ( allocated ( aky_all_ordered )) deallocate ( aky_all_ordered ) if ( allocated ( akx )) deallocate ( akx ) if ( allocated ( theta0 )) deallocate ( theta0 ) if ( allocated ( zed0 )) deallocate ( zed0 ) if ( allocated ( x )) deallocate ( x ) if ( allocated ( y )) deallocate ( y ) if ( allocated ( x_d )) deallocate ( x_d ) if ( allocated ( rho )) deallocate ( rho ) if ( allocated ( rho_d )) deallocate ( rho_d ) if ( allocated ( rho_clamped )) deallocate ( rho_clamped ) if ( allocated ( rho_d_clamped )) deallocate ( rho_d_clamped ) if ( allocated ( g0x )) deallocate ( g0x ) reality = . false . read_kt_grids_initialized = . false . init_kt_grids_initialized = . false . end subroutine finish_kt_grids subroutine multiply_by_rho ( gin ) use stella_transforms , only : transform_kx2x_unpadded , transform_x2kx_unpadded !   use stella_transforms, only: transform_kx2x_xfirst, transform_x2kx_xfirst implicit none complex , dimension (:, :), intent ( inout ) :: gin if (. not . allocated ( g0x )) allocate ( g0x ( naky , nakx )) call transform_kx2x_unpadded ( gin , g0x ) g0x = spread ( rho_d_clamped , 1 , naky ) * g0x if ( zonal_mode ( 1 )) g0x ( 1 , :) = real ( g0x ( 1 , :)) call transform_x2kx_unpadded ( g0x , gin ) !   if(.not.allocated(g0x)) allocate(g0x(naky,nx)) !   call transform_kx2x_xfirst(gin,g0x) !   g0x = spread(rho_clamped,1,naky)*g0x !   if(zonal_mode(1)) g0x(1,:) = real(g0x(1,:)) !   call transform_x2kx_xfirst(g0x,gin) end subroutine multiply_by_rho end module kt_grids","tags":"","loc":"sourcefile/kt_grids.f90.html"},{"title":"physics_parameters.f90 â€“ stella","text":"Contents Modules physics_parameters Source Code physics_parameters.f90 Source Code module physics_parameters implicit none public :: init_physics_parameters public :: finish_physics_parameters public :: beta , zeff , tite , nine , rhostar , vnew_ref public :: g_exb , g_exbfac , omprimfac private real :: beta , zeff , tite , nine , rhostar , irhostar , vnew_ref real :: g_exb , g_exbfac , omprimfac logical :: initialized = . false . contains subroutine init_physics_parameters implicit none if ( initialized ) return initialized = . true . call read_parameters end subroutine init_physics_parameters subroutine read_parameters use file_utils , only : input_unit_exist use mp , only : proc0 , broadcast implicit none integer :: in_file logical :: rpexist namelist / parameters / beta , zeff , tite , nine , rhostar , vnew_ref & , g_exb , g_exbfac , omprimfac , irhostar if ( proc0 ) then beta = 0.0 vnew_ref = - 1.0 ! various input options will override this value if it is negative rhostar = - 1.0 ! = m_ref * vt_ref / (e * B_ref * a_ref), with refs in SI irhostar = - 1.0 zeff = 1.0 tite = 1.0 nine = 1.0 g_exb = 0.0 g_exbfac = 1.0 omprimfac = 1.0 in_file = input_unit_exist ( \"parameters\" , rpexist ) if ( rpexist ) read ( unit = in_file , nml = parameters ) if ( irhostar > 0 ) rhostar = 1. / irhostar end if call broadcast ( beta ) call broadcast ( vnew_ref ) call broadcast ( zeff ) call broadcast ( rhostar ) call broadcast ( tite ) call broadcast ( nine ) call broadcast ( g_exb ) call broadcast ( g_exbfac ) call broadcast ( omprimfac ) end subroutine read_parameters subroutine finish_physics_parameters implicit none initialized = . false . end subroutine finish_physics_parameters end module physics_parameters","tags":"","loc":"sourcefile/physics_parameters.f90.html"},{"title":"sfincs_interface.fpp â€“ stella","text":"Contents Modules sfincs_interface Source Code sfincs_interface.fpp Source Code module sfincs_interface implicit none public :: get_neo_from_sfincs private # ifdef USE_SFINCS integer :: nproc_sfincs integer :: irad_min , irad_max real :: Er_window logical :: includeXDotTerm logical :: includeElectricFieldTermInXiDot !  logical :: includeRadialExBDrive integer :: magneticDriftScheme logical :: includePhi1 logical :: includePhi1InKineticEquation !  logical :: includePhi1InCollisionOperator integer :: geometryScheme integer :: VMECRadialOption integer :: coordinateSystem integer :: inputRadialCoordinate integer :: inputRadialCoordinateForGradients character ( 200 ) :: equilibriumFile real :: aHat , psiAHat , Delta real :: nu_n , dPhiHatdrN integer :: nxi , nx , ntheta , nzeta logical :: calculate_radial_electric_field logical :: read_sfincs_output_from_file logical :: sfincs_finished = . true . real , dimension (:), allocatable :: fprim_local , tprim_local # endif contains subroutine get_neo_from_sfincs ( nradii , drho , f_neoclassical , phi_neoclassical , & dfneo_dalpha , dphineo_dalpha ) # ifdef USE_SFINCS use mp , only : proc0 , iproc use mp , only : comm_split , comm_free use stella_geometry , only : geo_surf use species , only : spec , nspec # endif use mp , only : mp_abort use zgrid , only : nzgrid implicit none integer , intent ( in ) :: nradii real , intent ( in ) :: drho real , dimension (:, - nzgrid :, :, :, :, - nradii / 2 :), intent ( out ) :: f_neoclassical real , dimension (:, - nzgrid :, - nradii / 2 :), intent ( out ) :: phi_neoclassical real , dimension (:, - nzgrid :, :, :, :), intent ( out ) :: dfneo_dalpha real , dimension (:, - nzgrid :), intent ( out ) :: dphineo_dalpha # ifdef USE_SFINCS integer :: sfincs_comm integer :: color , ierr integer :: irad real :: dPhiHatdrN_best_guess logical :: Er_converged integer :: nsfincs_calls if (. not . allocated ( fprim_local )) allocate ( fprim_local ( nspec )) if (. not . allocated ( tprim_local )) allocate ( tprim_local ( nspec )) if ( proc0 ) call read_sfincs_parameters ( nradii ) call broadcast_sfincs_parameters if ( iproc < nproc_sfincs ) then color = 0 else color = 1 end if call comm_split ( color , sfincs_comm , ierr ) if ( iproc < nproc_sfincs ) then do irad = irad_min , irad_max ! get local values of -dlog(ns)/drho and -dlog(Ts)/drho ! using dlog(n)/drho = dlog(n0)/drho + delrho*d/drho(dlog(n)/drho) fprim_local = 1.0 / geo_surf % drhotordrho * ( spec % fprim & + irad * drho * ( spec % fprim ** 2 - spec % d2ndr2 ) / geo_surf % drhotordrho ) tprim_local = 1.0 / geo_surf % drhotordrho * ( spec % tprim & + irad * drho * ( spec % tprim ** 2 - spec % d2Tdr2 ) / geo_surf % drhotordrho ) !          fprim_local = 1.0/geo_surf%drhotordrho*(spec%fprim - irad*drho*spec%d2ndr2) !          tprim_local = 1.0/geo_surf%drhotordrho*(spec%tprim - irad*drho*spec%d2Tdr2) if ( calculate_radial_electric_field ) then ! get best guess at radial electric field ! using force balance with radial pressure gradient if ( dPhiHatdrN > - 999 9.0 ) then dPhiHatdrN_best_guess = dPhiHatdrN else dPhiHatdrN_best_guess = fprim_local ( 1 ) + tprim_local ( 1 ) end if call iterate_sfincs_until_electric_field_converged ( sfincs_comm , & irad , drho , irad_max , dPhiHatdrN_best_guess , & Er_converged , nsfincs_calls ) if ( proc0 ) then write ( * , * ) write ( * , * ) 'At irad= ' , irad , 'Er_converged= ' , Er_converged , & 'nsfincs_calls_required= ' , nsfincs_calls , 'dPhiHatdrN= ' , dPhiHatdrN write ( * , * ) end if ! write_and_finish_sfincs manipulates sfincs output ! to get the neoclassical distribution function and potential ! on the stella (zed,alpha,vpa,mu) grid; it then ! deallocates sfincs arrays, etc. to make it ready ! for running again if need be call write_and_finish_sfincs ( f_neoclassical (:, :, :, :, :, irad ), & phi_neoclassical (:, :, irad ), dfneo_dalpha , dphineo_dalpha , irad ) else ! init_and_run_sfincs initializes sfincs, ! including passing geometry info if necessary; ! and runs sfincs (if requested) call init_and_run_sfincs ( sfincs_comm , irad , drho , irad_max ) ! write_and_finish_sfincs manipulates sfincs output ! to get the neoclassical distribution function and potential ! on the stella (zed,alpha,vpa,mu) grid; it then ! deallocates sfincs arrays, etc. to make it ready ! for running again if need be call write_and_finish_sfincs ( f_neoclassical (:, :, :, :, :, irad ), & phi_neoclassical (:, :, irad ), dfneo_dalpha , dphineo_dalpha , irad ) end if end do end if call comm_free ( sfincs_comm , ierr ) ! NB: NEED TO CHECK THIS BROADCAST OF SFINCS RESULTS do irad = irad_min , irad_max call broadcast_sfincs_output & ( f_neoclassical (:, :, :, :, :, irad ), phi_neoclassical (:, :, irad )) end do call broadcast_sfincs_output ( dfneo_dalpha , dphineo_dalpha ) deallocate ( fprim_local , tprim_local ) if ( proc0 ) then write ( * , * ) write ( * , * ) 'maxval(fneo): ' , maxval ( f_neoclassical (:, :, :, :, :, irad_min : irad_max )), & 'maxval(phineo): ' , maxval ( phi_neoclassical (:, :, irad_min : irad_max )) write ( * , * ) end if if (( irad_min /= - nradii / 2 ) . or . ( irad_max /= nradii / 2 )) & call mp_abort ( 'WARNING: irad_min must equal -nradii/2 and irad_max must equal & & nradii/2 to proceed to stella calculation.  aborting.' ) # else real :: dum ! this pointless dum assignment only here to avoid ! annoying warning messages during compilation ! about unused variable drho dum = drho f_neoclassical = 0. ; phi_neoclassical = 0. dfneo_dalpha = 0. ; dphineo_dalpha = 0. call mp_abort ( \"to run with include_neoclassical_terms=.true., & & USE_SFINCS must be defined at compilation time.  Aborting.\" ) # endif end subroutine get_neo_from_sfincs # ifdef USE_SFINCS subroutine iterate_sfincs_until_electric_field_converged ( & sfincs_comm , irad , drho , nrad_max , dPhiHatdrN_best_guess , & dphiHatdrN_is_converged , number_of_sfincs_calls_for_convergence ) use mp , only : proc0 , iproc implicit none integer , intent ( in ) :: sfincs_comm , irad , nrad_max real , intent ( in ) :: drho , dPhiHatdrN_best_guess logical , intent ( out ) :: dPhiHatdrN_is_converged integer , intent ( out ) :: number_of_sfincs_calls_for_convergence integer :: itmax_bracket = 10 integer :: itmax_root = 10 real :: window = 0.3 real :: tol = 0.1 integer :: it real :: a , b , c , d , e , fa , fb , fc , p , q , r , s , tol1 , xm , eps real :: converged_dPhiHatdrN dPhiHatdrN_is_converged = . false . a = dPhiHatdrN_best_guess * ( 1.0 - Er_window ) b = dPhiHatdrN_best_guess * ( 1.0 + Er_window ) ! initialize sfincs, run it, and return the total charge flux as fa call get_total_charge_flux ( sfincs_comm , irad , drho , nrad_max , a , fa ) call get_total_charge_flux ( sfincs_comm , irad , drho , nrad_max , b , fb ) number_of_sfincs_calls_for_convergence = 2 do it = 1 , itmax_bracket eps = epsilon ( a ) if (( fa > 0.0 . and . fb > 0.0 ) . or . ( fa < 0.0 . and . fb < 0.0 )) then if ( proc0 ) then write ( * , * ) write ( * , * ) 'dPhiHatdrN values ' , a , ' and ' , b , ' do not bracket root.' write ( * , * ) 'flux at ' , a , ' is ' , fa , '.' write ( * , * ) 'flux at ' , b , ' is ' , fb , '.' end if a = a * ( 1.0 - Er_window ) b = b * ( 1.0 + Er_window ) if ( proc0 ) then write ( * , * ) 'Trying again with values ' , a , ' and ' , b , ' .' write ( * , * ) end if call get_total_charge_flux ( sfincs_comm , irad , drho , nrad_max , a , fa ) call get_total_charge_flux ( sfincs_comm , irad , drho , nrad_max , b , fb ) number_of_sfincs_calls_for_convergence = number_of_sfincs_calls_for_convergence + 2 !           ! eliminate the endpoint corresonding to the flux that is furthest from zero in magnitude !           if (abs(fa) > abs(fb)) then !              ! keep b as an endpoint and eliminate a !              a = b ; fa = fb !              b = a*(1.0+window) !              if (proc0) then !                 write (*,*) 'Trying again with values ', a, ' and ', b, ' .' !                 write (*,*) !              end if !              call get_total_charge_flux (sfincs_comm, irad, drho, nrad_max, b, fb) !           else !              ! keep a as an endpoint and eliminate b !              b = a ; fb = fa !              a = b*(1.0-window) !              if (proc0) then !                 write (*,*) 'Trying again with values ', a, ' and ', b, ' .' !                 write (*,*) !              end if !              call get_total_charge_flux (sfincs_comm, irad, drho, nrad_max, a, fa) !           end if else exit end if end do c = b fc = fb do it = 1 , itmax_root if (( fb > 0.0 . and . fc > 0.0 ) . or . ( fb < 0.0 . and . fc < 0.0 )) then c = a fc = fa d = b - a e = d end if if ( abs ( fc ) < abs ( fb )) then a = b b = c c = a fa = fb fb = fc fc = fa end if tol1 = 2.0 * eps * abs ( b ) + 0.5 * tol xm = 0.5 * ( c - b ) if ( abs ( xm ) <= tol1 . or . fb == 0.0 ) then converged_dPhiHatdrN = b dPhiHatdrN_is_converged = . true . !          number_of_sfincs_calls_for_convergence = it+1 exit end if if ( abs ( e ) >= tol1 . and . abs ( fa ) > abs ( fb )) then s = fb / fa if ( a == c ) then p = 2.0 * xm * s q = 1.0 - s else q = fa / fc r = fb / fc p = s * ( 2.0 * xm * q * ( q - r ) - ( b - a ) * ( r - 1.0 )) q = ( q - 1.0 ) * ( r - 1.0 ) * ( s - 1.0 ) end if if ( p > 0.0 ) q = - q p = abs ( p ) if ( 2.0 * p < min ( 3.0 * xm * q - abs ( tol1 * q ), abs ( e * q ))) then e = d d = p / q else d = xm e = d end if else d = xm e = d end if a = b fa = fb b = b + merge ( d , sign ( tol1 , xm ), abs ( d ) > tol1 ) call get_total_charge_flux ( sfincs_comm , irad , drho , nrad_max , b , fb ) number_of_sfincs_calls_for_convergence = number_of_sfincs_calls_for_convergence + 1 end do end subroutine iterate_sfincs_until_electric_field_converged subroutine get_total_charge_flux ( sfincs_comm , irad , drho , nrad_max , & dPhiHatdrN_in , total_charge_flux ) use mp , only : iproc , broadcast_with_comm use sfincs_main , only : finish_sfincs use globalVariables , only : Zs , particleFlux_vd_psiHat use species , only : nspec implicit none integer , intent ( in ) :: sfincs_comm , irad , nrad_max real , intent ( in ) :: drho real , intent ( in ) :: dPhiHatdrN_in real , intent ( out ) :: total_charge_flux dPhiHatdrN = dPhiHatdrN_in call init_and_run_sfincs ( sfincs_comm , irad , drho , nrad_max ) call broadcast_with_comm ( Zs , sfincs_comm ) call broadcast_with_comm ( particleFlux_vd_psiHat , sfincs_comm ) total_charge_flux = sum ( Zs (: nspec ) * particleFlux_vd_psiHat (: nspec )) end subroutine get_total_charge_flux subroutine init_and_run_sfincs ( sfincs_comm , irad , drho , nrad_max ) use mp , only : proc0 , iproc use sfincs_main , only : init_sfincs , prepare_sfincs , run_sfincs , finish_sfincs use globalVariables , only : Zs , particleFlux_vd_psiHat use species , only : nspec implicit none integer , intent ( in ) :: sfincs_comm , irad , nrad_max real , intent ( in ) :: drho if (. not . sfincs_finished ) then call finish_sfincs sfincs_finished = . true . end if call init_sfincs ( sfincs_comm ) call pass_inputoptions_to_sfincs ( irad * drho ) call pass_outputoptions_to_sfincs call prepare_sfincs ! if geometryScheme = 5, then sfincs will read in equilibrium ! parameters from vmec file separately ! otherwise, assume system is axisymmetric and pass geometry ! from stella (miller local equilibrium or similar) if ( geometryScheme /= 5 ) call pass_geometry_to_sfincs ( irad * drho ) if ( read_sfincs_output_from_file ) then if ( proc0 ) call read_sfincs_output ( irad , nrad_max ) else if ( proc0 ) then write ( * , * ) write ( * , * ) 'Running sfincs at irad= ' , irad , ', with dPhiHatdrN= ' , dPhiHatdrN end if call run_sfincs if ( proc0 ) then write ( * , * ) 'sfincs finished running.  total charge flux= ' , sum ( Zs (: nspec ) * particleFlux_vd_psiHat (: nspec )) write ( * , * ) end if ! write Phi1Hat and delta_f to file ! so we have the option of using it ! again without re-running sfincs if ( proc0 ) call write_sfincs ( irad , nrad_max ) end if sfincs_finished = . false . end subroutine init_and_run_sfincs subroutine write_and_finish_sfincs ( fneo , phineo , dfneo , dphineo , irad ) use mp , only : proc0 use sfincs_main , only : finish_sfincs use zgrid , only : nzgrid implicit none real , dimension (:, - nzgrid :, :, :, :), intent ( out ) :: fneo real , dimension (:, - nzgrid :), intent ( out ) :: phineo real , dimension (:, - nzgrid :, :, :, :), intent ( in out ) :: dfneo real , dimension (:, - nzgrid :), intent ( in out ) :: dphineo integer , intent ( in ) :: irad if ( proc0 ) then ! only need to compute dfneo_dalpha and dphineo_dalpha ! for central radius and for stellarator calculation if ( irad == 0 . and . geometryScheme == 5 ) then call get_sfincs_output ( fneo , phineo , dfneo , dphineo ) else call get_sfincs_output ( fneo , phineo ) end if end if call finish_sfincs end subroutine write_and_finish_sfincs subroutine read_sfincs_parameters ( nradii ) use constants , only : pi use mp , only : nproc use file_utils , only : input_unit_exist use species , only : nspec use physics_parameters , only : rhostar , vnew_ref use stella_geometry , only : geo_surf , aref , bref implicit none integer , intent ( in ) :: nradii namelist / sfincs_input / nproc_sfincs , & calculate_radial_electric_field , & includeXDotTerm , & includeElectricFieldTermInXiDot , & irad_min , irad_max , & magneticDriftScheme , & includePhi1 , & includePhi1InKineticEquation , & !         includePhi1InCollisionOperator, & geometryScheme , & VMECRadialOption , & equilibriumFile , & coordinateSystem , & inputRadialCoordinate , & inputRadialCoordinateForGradients , & aHat , psiAHat , nu_N , nxi , nx , Delta , & dPhiHatdrN , & ntheta , nzeta , & read_sfincs_output_from_file , Er_window logical :: exist integer :: in_file ! if read_sfincs_output_from_file=.true., ! will try to read in Phi1Hat and delta_f ! from pre-saved file named sfincs.output ! otherwise, run sfincs to compute these ! quantities on the fly read_sfincs_output_from_file = . false . ! number of processors to use for sfincs calculation nproc_sfincs = 1 ! minimum and maximum radial index (irad=0 corresponds to central radius) irad_min = - nradii / 2 ; irad_max = nradii / 2 ! if calculate_radial_electric_field, then ! will scan in radial electric field to find value ! for which ambipolarity is satisfied, and then ! use this value to obtain neoclassical fluxes, ! distribution function, and potential calculate_radial_electric_field = . true . ! do not include radial electric field term if set to .false. includeXDotTerm = . true . includeElectricFieldTermInXiDot = . true . ! include v_E . grad r term !    includeRadialExBDrive = .true. ! no poloidal or toroidal magnetic drifts magneticDriftScheme = 0 ! combo of next two variables means ! phi1 will be calculated via quasineutrality includePhi1 = . true . includePhi1InKineticEquation = . false . !    includePhi1InCollisionOperator = .false. ! will be overridden by direct input of geometric quantities ! unless geometryScheme = 5 (vmec equilibrium) geometryScheme = 1 ! only relevant if geometryScheme = 5 ! radial option to use for vmec equilibrium ! 0 corresponds to using radial interpolation to get desired surface ! 1 corresponds to using nearest surface on VMEC HALF grid ! 2 corresponds to using nearest surface on VMEC FULL grid ! should not change this unless self-consistently change in the ! vmec input namelist VMECRadialOption = 0 ! path of vmec equilibrium file equilibriumFile = 'wout_161s1.nc' ! seems to be a nonsensical option coordinateSystem = 3 ! option 3 corresponds to using sqrt of toroidal flux ! normalized by toroidal flux enclosed by the LCFS inputRadialCoordinate = 3 ! option 3 corresponds to same choice ! when calculating gradients of density, temperature, and potential inputRadialCoordinateForGradients = 3 ! corresponds to r_LCFS as reference length in sfincs ! only used in sfincs when geometryScheme=1 aHat = 1.0 ! psitor_LCFS / (B_ref * a_ref&#94;2) psiAHat = geo_surf % psitor_lcfs ! Delta is rho* = mref*vt_ref/(e*Bref*aref), with reference ! quantities given in SI units ! unless geometryScheme = 5, in which case Bref=1T ! and aref = 1m (these are hardwired in sfincs) ! set negative to allow check later to see if any value given in input file Delta = - 1.0 ! nu_n = nu_ref * aref/vt_ref ! nu_ref = 4*sqrt(2*pi)*nref*e**4*loglam/(3*sqrt(mref)*Tref**3/2) ! (with nref, Tref, and mref in Gaussian units) ! set negative to allow check later to see if any value given in input file nu_n = - 1.0 ! radial derivative of normalized phi dPhiHatdrN = - 999 9.9 Er_window = 0.3 ! number of spectral coefficients in pitch angle nxi = 48 ! number of speeds nx = 12 ! number of poloidal angles Ntheta = 65 ! number of toroidal angles, 1 is appropriate for tokamak Nzeta = 1 in_file = input_unit_exist ( \"sfincs_input\" , exist ) if ( exist ) read ( unit = in_file , nml = sfincs_input ) if ( nproc_sfincs > nproc ) then write ( * , * ) 'requested number of processors for sfincs is greater & & than total processor count.' write ( * , * ) 'allocating ' , nproc , ' processors for sfincs.' end if if ( Delta < 0.0 ) then Delta = rhostar ! if geometryScheme=5, Bref=1T and aref=1m are hard-wired in sfincs ! but these are not the values used in stella to define rhostar if ( geometryScheme == 5 ) Delta = rhostar * bref * aref end if if ( nu_n < 0.0 ) then nu_n = vnew_ref * ( 4. / ( 3. * sqrt ( pi ))) ! if geometryScheme=5, aref=1m is hard-wired in sfincs ! but this is not the value used in stella if ( geometryScheme == 5 ) nu_n = nu_n / aref end if ! FLAG -- NOT YET SURE IF THIS SHOULD BE HERE !    if (nspec == 1 .and. includePhi1) then !       write (*,*) 'includePhi1 = .true. is incompatible with a single-species run.' !       write (*,*) 'forcing includePhi1 = .false.' !       includePhi1 = .false. !    end if ! ensure that ntheta and nzeta are odd for SFINCS ntheta = 2 * ( ntheta / 2 ) + 1 nzeta = 2 * ( nzeta / 2 ) + 1 end subroutine read_sfincs_parameters subroutine broadcast_sfincs_parameters use mp , only : broadcast use physics_parameters , only : rhostar implicit none call broadcast ( read_sfincs_output_from_file ) call broadcast ( nproc_sfincs ) call broadcast ( irad_min ) call broadcast ( irad_max ) call broadcast ( calculate_radial_electric_field ) call broadcast ( includeXDotTerm ) call broadcast ( includeElectricFieldTermInXiDot ) !    call broadcast (includeRadialExBDrive) call broadcast ( magneticDriftScheme ) call broadcast ( includePhi1 ) call broadcast ( includePhi1InKineticEquation ) !    call broadcast (includePhi1InCollisionOperator) call broadcast ( geometryScheme ) call broadcast ( VMECRadialOption ) call broadcast ( equilibriumFile ) call broadcast ( coordinateSystem ) call broadcast ( inputRadialCoordinate ) call broadcast ( inputRadialCoordinateForGradients ) call broadcast ( aHat ) call broadcast ( psiAHat ) call broadcast ( Delta ) call broadcast ( nu_N ) call broadcast ( dPhiHatdrN ) call broadcast ( Er_window ) call broadcast ( nxi ) call broadcast ( nx ) call broadcast ( ntheta ) call broadcast ( nzeta ) write ( * , * ) 'Delta stella' , Delta , rhostar end subroutine broadcast_sfincs_parameters subroutine pass_inputoptions_to_sfincs ( delrho ) use mp , only : mp_abort use stella_geometry , only : geo_surf use species , only : spec , nspec use zgrid , only : nzed use physics_parameters , only : nine , tite use globalVariables , only : includeXDotTerm_sfincs => includeXDotTerm use globalVariables , only : includeElectricFieldTermInXiDot_sfincs => includeElectricFieldTermInXiDot !    use globalVariables, only: includeRadialExBDrive_sfincs => includeRadialExBDrive use globalVariables , only : magneticDriftScheme_sfincs => magneticDriftScheme use globalVariables , only : includePhi1_sfincs => includePhi1 use globalVariables , only : includePhi1InKineticEquation_sfincs => includePhi1InKineticEquation !    use globalVariables, only: includePhi1InCollisionOperator_sfincs => includePhi1InCollisionOperator use globalVariables , only : geometryScheme_sfincs => geometryScheme use globalVariables , only : equilibriumFile_sfincs => equilibriumFile use globalVariables , only : VMECRadialOption_sfincs => VMECRadialOption use globalVariables , only : coordinateSystem_sfincs => coordinateSystem use globalVariables , only : RadialCoordinate => inputRadialCoordinate use globalVariables , only : RadialCoordinateForGradients => inputRadialCoordinateForGradients use globalVariables , only : rN_wish use globalVariables , only : Nspecies , nHats , THats , MHats , Zs use globalVariables , only : adiabaticNHat , adiabaticTHat , adiabaticZ use globalVariables , only : nxi_sfincs => Nxi use globalVariables , only : nx_sfincs => Nx use globalVariables , only : ntheta_sfincs => Ntheta use globalVariables , only : nzeta_sfincs => Nzeta use globalVariables , only : dnHatdrNs , dTHatdrNs use globalVariables , only : aHat_sfincs => aHat use globalVariables , only : psiAHat_sfincs => psiAHat use globalVariables , only : Delta_sfincs => Delta use globalVariables , only : nu_n_sfincs => nu_n use globalVariables , only : dPhiHatdrN_sfincs => dPhiHatdrN use globalVariables , only : withAdiabatic implicit none real , intent ( in ) :: delrho includeXDotTerm_sfincs = includeXDotTerm includeElectricFieldTermInXiDot_sfincs = includeElectricFieldTermInXiDot !    includeRadialExBDrive_sfincs = includeRadialExBDrive magneticDriftScheme_sfincs = magneticDriftScheme includePhi1_sfincs = includePhi1 includePhi1InKineticEquation_sfincs = includePhi1InKineticEquation !    includePhi1InCollisionOperator_sfincs = includePhi1InCollisionOperator geometryScheme_sfincs = geometryScheme VMECRadialOption_sfincs = VMECRadialOption equilibriumFile_sfincs = trim ( equilibriumFile ) coordinateSystem_sfincs = coordinateSystem RadialCoordinate = inputRadialCoordinate RadialCoordinateForGradients = inputRadialCoordinateForGradients Nspecies = nspec nHats (: nspec ) = spec % dens * ( 1.0 - delrho * spec % fprim ) THats (: nspec ) = spec % temp * ( 1.0 - delrho * spec % tprim ) mHats (: nspec ) = spec % mass Zs (: nspec ) = spec % z nzeta_sfincs = nzeta ntheta_sfincs = ntheta nx_sfincs = nx nxi_sfincs = nxi aHat_sfincs = aHat psiAHat_sfincs = psiAHat Delta_sfincs = Delta nu_n_sfincs = nu_n dPhiHatdrN_sfincs = dPhiHatdrN if ( nspec == 1 ) then withAdiabatic = . true . adiabaticNHat = nHats ( 1 ) / nine adiabaticTHat = THats ( 1 ) / tite adiabaticZ = - 1 end if if ( inputRadialCoordinate == 3 ) then rN_wish = geo_surf % rhotor + delrho * geo_surf % drhotordrho else call mp_abort ( 'only inputRadialCoordinate=3 currently supported. aborting.' ) end if if ( inputRadialCoordinateForGradients == 3 ) then ! radial density gradient with respect to rhotor = sqrt(psitor/psitor_LCFS) ! normalized by reference density (not species density) dnHatdrNs (: nspec ) = - spec % dens * fprim_local ! radial temperature gradient with respect to rhotor = sqrt(psitor/psitor_LCFS) ! normalized by reference tmperatures (not species temperature) dTHatdrNs (: nspec ) = - spec % temp * tprim_local else call mp_abort ( 'only inputRadialCoordinateForGradients=3 currently supported. aborting.' ) end if end subroutine pass_inputoptions_to_sfincs subroutine pass_outputoptions_to_sfincs use export_f , only : export_f_theta_option use export_f , only : export_f_zeta_option use export_f , only : export_f_xi_option use export_f , only : export_f_x_option use export_f , only : export_delta_f , export_full_f use export_f , only : export_f_stella implicit none export_f_theta_option = 0 export_f_zeta_option = 0 export_f_xi_option = 0 export_f_x_option = 0 export_delta_f = . true . export_full_f = . false . export_f_stella = . true . end subroutine pass_outputoptions_to_sfincs ! if this subroutine is being called, then ! using sfincs in tokamak geometry ! so zed in stella is theta subroutine pass_geometry_to_sfincs ( delrho ) use constants , only : pi use splines , only : linear_interp_periodic use zgrid , only : nz2pi , zed use stella_geometry , only : bmag , dbdzed , gradpar use stella_geometry , only : dBdrho , d2Bdrdth , dgradpardrho , dIdrho use stella_geometry , only : geo_surf use globalVariables , only : BHat use globalVariables , only : dBHatdtheta use globalVariables , only : iota use globalVariables , only : DHat use globalVariables , only : BHat_sup_theta use globalVariables , only : BHat_sub_zeta use export_f , only : export_f_theta implicit none real , intent ( in ) :: delrho integer :: nzeta = 1 integer :: nzpi real :: q_local real , dimension (:), allocatable :: B_local , dBdz_local , gradpar_local real , dimension (:), allocatable :: zed_stella real , dimension (:), allocatable :: theta_sfincs nzpi = nz2pi / 2 allocate ( B_local ( - nzpi : nzpi )) allocate ( dBdz_local ( - nzpi : nzpi )) allocate ( gradpar_local ( - nzpi : nzpi )) allocate ( theta_sfincs ( ntheta )) allocate ( zed_stella ( - nzpi : nzpi )) call init_zero_arrays ! first get some geometric quantities at this radius ! for theta from -pi to pi q_local = geo_surf % qinp * ( 1.0 + delrho * geo_surf % shat / geo_surf % rhoc ) B_local = bmag ( 1 , - nzpi : nzpi ) + delrho * dBdrho ( - nzpi : nzpi ) dBdz_local = dbdzed ( 1 , - nzpi : nzpi ) + delrho * d2Bdrdth ( - nzpi : nzpi ) gradpar_local = gradpar ( - nzpi : nzpi ) + delrho * dgradpardrho ( - nzpi : nzpi ) zed_stella = zed ( - nzpi : nzpi ) + pi theta_sfincs = export_f_theta (: ntheta ) iota = 1. / q_local ! interpolate from stella zed-grid to sfincs theta grid ! point at -pi (stella) is same as point at 0 (sfincs) BHat ( 1 , 1 ) = B_local ( - nzpi ) call linear_interp_periodic ( zed_stella , B_local , theta_sfincs ( 2 :), BHat ( 2 :, 1 )) ! FLAG -- needs to be changed for stellarator runs BHat = spread ( BHat (:, 1 ), 2 , nzeta ) dBHatdtheta ( 1 , 1 ) = dBdz_local ( - nzpi ) call linear_interp_periodic ( zed_stella , dBdz_local , theta_sfincs ( 2 :), dBHatdtheta ( 2 :, 1 )) dBHatdtheta = spread ( dBHatdtheta (:, 1 ), 2 , nzeta ) ! this is bhat . grad theta BHat_sup_theta ( 1 , 1 ) = B_local ( - nzpi ) * gradpar_local ( - nzpi ) call linear_interp_periodic ( zed_stella , B_local * gradpar_local , theta_sfincs ( 2 :), BHat_sup_theta ( 2 :, 1 )) BHat_sup_theta = spread ( BHat_sup_theta (:, 1 ), 2 , nzeta ) ! this is I(psi) / (aref*Bref) BHat_sub_zeta = geo_surf % rgeo + delrho * dIdrho ! this is grad psitor . (grad theta x grad zeta) ! note that + sign below relies on B = I grad zeta + grad zeta x grad psi DHat = q_local * BHat_sup_theta deallocate ( B_local , dBdz_local , gradpar_local ) deallocate ( theta_sfincs , zed_stella ) end subroutine pass_geometry_to_sfincs subroutine init_zero_arrays use globalVariables , only : dBHatdzeta use globalVariables , only : dBHatdpsiHat use globalVariables , only : BHat_sup_zeta use globalVariables , only : BHat_sub_psi use globalVariables , only : BHat_sub_theta use globalVariables , only : dBHat_sub_psi_dtheta use globalVariables , only : dBHat_sub_psi_dzeta use globalVariables , only : dBHat_sub_theta_dpsiHat use globalVariables , only : dBHat_sub_theta_dzeta use globalVariables , only : dBHat_sub_zeta_dpsiHat use globalVariables , only : dBHat_sub_zeta_dtheta use globalVariables , only : dBHat_sup_theta_dpsiHat use globalVariables , only : dBHat_sup_theta_dzeta use globalVariables , only : dBHat_sup_zeta_dpsiHat use globalVariables , only : dBHat_sup_zeta_dtheta implicit none dBHatdzeta = 0. dBHatdpsiHat = 0. BHat_sup_zeta = 0. BHat_sub_psi = 0. BHat_sub_theta = 0. dBHat_sub_psi_dtheta = 0. dBHat_sub_psi_dzeta = 0. dBHat_sub_theta_dpsiHat = 0. dBHat_sub_theta_dzeta = 0. dBHat_sub_zeta_dpsiHat = 0. dBHat_sub_zeta_dtheta = 0. dBHat_sup_theta_dpsiHat = 0. dBHat_sup_theta_dzeta = 0. dBHat_sup_zeta_dpsiHat = 0. dBHat_sup_zeta_dtheta = 0. end subroutine init_zero_arrays subroutine get_sfincs_output ( f_neoclassical , phi_neoclassical , & dfneo_dalpha , dphineo_dalpha ) use constants , only : pi use sort , only : sort_array_ascending , unsort_array_ascending use species , only : nspec use zgrid , only : nzgrid , nz2pi use export_f , only : h_sfincs => delta_f use globalVariables , only : Phi1Hat use kt_grids , only : nalpha implicit none real , dimension (:, - nzgrid :, :, :, :), intent ( out ) :: f_neoclassical real , dimension (:, - nzgrid :), intent ( out ) :: phi_neoclassical real , dimension (:, - nzgrid :, :, :, :), intent ( out ), optional :: dfneo_dalpha real , dimension (:, - nzgrid :), intent ( out ), optional :: dphineo_dalpha integer :: i , j integer :: ialpha , iz , is real , dimension (:), allocatable :: zed_stella integer :: nfp , nfp_stella integer , dimension (:), allocatable :: nzed_per_field_period real , dimension (:, :), allocatable :: zed_stella_by_field_period real , dimension (:, :), allocatable :: alpha_like_stella integer , dimension (:, :), allocatable :: alpha_sort_map integer :: nzed_sfincs , nalpha_sfincs real , dimension (:), allocatable :: zed_sfincs , alpha_like_sfincs real , dimension (:, :), allocatable :: phi_sfincs real , dimension (:, :), allocatable :: phi_stella_zgrid , phi_stella real , dimension (:, :), allocatable :: dphi_dalpha_stella_zgrid real , dimension (:, :), allocatable :: tmp_sfincs , tmp_stella_zgrid , tmp_stella real , dimension (:, :), allocatable :: dh_stella_zgrid real , dimension (:, :, :, :), allocatable :: h_stella , dh_stella ! zed coordinate in stella is zeta when simulating stellarators (using vmec) ! and theta otherwise.  this leads to some complications, treated below allocate ( zed_stella ( nz2pi )) allocate ( alpha_like_stella ( nalpha , nz2pi )) allocate ( alpha_sort_map ( nalpha , nz2pi )) ! obtain theta and zeta grids used in stella, and assign them ! to the zed and alpha-like coordinates. ! for stellarator, zed=zeta and alpha_like=theta. ! for tokamak, zed=theta and alpha_like = zeta. call get_stella_theta_zeta_grids ( alpha_like_stella , zed_stella ) !    do iz = 1, nz2pi !       do ialpha = 1, size(alpha_like_stella,1) !          write (*,*) 'unsorted_alpha_like_stella', alpha_like_stella(ialpha,iz) !       end do !       write (*,*) !    end do ! rearrange alpha_like_stella to be in ascending order and store map ! so that sorting can be undone later do iz = 1 , nz2pi call sort_array_ascending ( alpha_like_stella (:, iz ), alpha_sort_map (:, iz )) end do !    do iz = 1, nz2pi !       do ialpha = 1, size(alpha_like_stella,1) !          write (*,*) 'sorted_alpha_like_stella', alpha_like_stella(ialpha,iz) !       end do !       write (*,*) !    end do ! obtain the number of alpha-like and zed grid points to use in sfincs theta-zeta grid ! also obtain the number of field periods per 2*pi segment in zed call get_sfincs_theta_zeta_grid_sizes ( nalpha_sfincs , nzed_sfincs , nfp ) ! obtain the alpha-like and zed coordinate grids ! note that additional points are added at periodic points ! that are not sampled in sfincs allocate ( zed_sfincs ( nzed_sfincs )) allocate ( alpha_like_sfincs ( nalpha_sfincs )) call get_sfincs_theta_zeta_grids ( alpha_like_sfincs , zed_sfincs ) allocate ( phi_sfincs ( nalpha_sfincs , nzed_sfincs )) call get_sfincs_field_theta_zeta ( Phi1Hat , phi_sfincs ) ! this is the number of field periods included in stella ! simulation domain nfp_stella = int (( zed_stella ( nz2pi ) * nfp - 10 0. * epsilon ( 0. )) / ( 2. * pi )) + 1 ! obtain the number of zed grid points in each field period within the zed domain allocate ( nzed_per_field_period ( nfp_stella )) call get_nzed_per_field_period ( zed_stella , nfp , nzed_per_field_period ) ! obtain the zed grid within each field period allocate ( zed_stella_by_field_period ( maxval ( nzed_per_field_period ), nfp_stella )) call sort_zed_by_field_period ( zed_stella , nzed_per_field_period , nfp , zed_stella_by_field_period ) ! interpolate phi from sfincs zed grid to stella zed grid allocate ( phi_stella_zgrid ( nalpha_sfincs , nz2pi )) call get_field_on_stella_zed_grid ( phi_sfincs , nfp_stella , nfp , nzed_per_field_period , & nalpha_sfincs , zed_sfincs , zed_stella_by_field_period , phi_stella_zgrid ) allocate ( phi_stella ( nalpha , nz2pi )) ! interpolate onto stella (sorted) alpha grid call get_field_stella ( phi_stella_zgrid , alpha_like_sfincs , alpha_like_stella , phi_stella ) ! need to remap from ascending (sorted) alpha grid to original ordering do iz = 1 , nz2pi call unsort_array_ascending ( phi_stella (:, iz ), alpha_sort_map (:, iz )) end do call get_field_on_extended_zed ( phi_stella , phi_neoclassical ) if ( present ( dphineo_dalpha )) then allocate ( dphi_dalpha_stella_zgrid ( nalpha_sfincs , nz2pi )) call get_dfield_dalpha ( phi_stella_zgrid , alpha_like_sfincs , dphi_dalpha_stella_zgrid ) call get_field_stella ( dphi_dalpha_stella_zgrid , alpha_like_sfincs , alpha_like_stella , phi_stella ) do iz = 1 , nz2pi call unsort_array_ascending ( phi_stella (:, iz ), alpha_sort_map (:, iz )) end do call get_field_on_extended_zed ( phi_stella , dphineo_dalpha ) deallocate ( dphi_dalpha_stella_zgrid ) end if deallocate ( phi_stella , phi_stella_zgrid , phi_sfincs ) allocate ( tmp_sfincs ( nalpha_sfincs , nzed_sfincs )) allocate ( tmp_stella_zgrid ( nalpha_sfincs , nz2pi )) allocate ( tmp_stella ( nalpha , nz2pi )) allocate ( h_stella ( nalpha , nz2pi , size ( h_sfincs , 4 ), size ( h_sfincs , 5 ))) if ( present ( dfneo_dalpha )) then allocate ( dh_stella_zgrid ( nalpha_sfincs , nz2pi )) allocate ( dh_stella ( nalpha , nz2pi , size ( h_sfincs , 4 ), size ( h_sfincs , 5 ))) end if do is = 1 , nspec do i = 1 , size ( h_sfincs , 5 ) do j = 1 , size ( h_sfincs , 4 ) ! re-order theta and zeta indices for sfincs h to ensure alpha-like coordinate ! appears before zed coordinate call get_sfincs_field_theta_zeta ( h_sfincs ( is , :, :, j , i ), tmp_sfincs ) ! interpolate onto stella zed grid call get_field_on_stella_zed_grid ( tmp_sfincs , nfp_stella , nfp , nzed_per_field_period , & nalpha_sfincs , zed_sfincs , zed_stella_by_field_period , tmp_stella_zgrid ) ! interpolate onto (sorted) stella alpha-like coordinate call get_field_stella ( tmp_stella_zgrid , alpha_like_sfincs , alpha_like_stella , tmp_stella ) do iz = 1 , nz2pi call unsort_array_ascending ( tmp_stella (:, iz ), alpha_sort_map (:, iz )) end do ! use periodicity to copy onto extended zed grid if nperiod > 1 call get_field_on_extended_zed ( tmp_stella , h_stella (:, :, j , i )) if ( present ( dfneo_dalpha )) then call get_dfield_dalpha ( tmp_stella_zgrid , alpha_like_sfincs , dh_stella_zgrid ) call get_field_stella ( dh_stella_zgrid , alpha_like_sfincs , & alpha_like_stella , tmp_stella ) do iz = 1 , nz2pi call unsort_array_ascending ( tmp_stella (:, iz ), alpha_sort_map (:, iz )) end do call get_field_on_extended_zed ( tmp_stella , dh_stella (:, :, j , i )) end if end do end do do ialpha = 1 , nalpha do iz = - nzgrid , nzgrid call sfincs_vspace_to_stella_vspace ( ialpha , iz , is , h_stella ( ialpha , iz + nzgrid + 1 , :, :), & phi_neoclassical ( ialpha , iz ), f_neoclassical ( ialpha , iz , :, :, is )) if ( present ( dfneo_dalpha )) & call sfincs_vspace_to_stella_vspace ( ialpha , iz , is , & dh_stella ( ialpha , iz + nzgrid + 1 , :, :), dphineo_dalpha ( ialpha , iz ), & dfneo_dalpha ( ialpha , iz , :, :, is )) end do end do end do deallocate ( tmp_sfincs , tmp_stella_zgrid , tmp_stella ) deallocate ( zed_stella , alpha_like_stella ) deallocate ( alpha_sort_map ) deallocate ( zed_sfincs , alpha_like_sfincs ) deallocate ( nzed_per_field_period , zed_stella_by_field_period ) deallocate ( h_stella ) if ( present ( dfneo_dalpha )) deallocate ( dh_stella , dh_stella_zgrid ) end subroutine get_sfincs_output subroutine get_stella_theta_zeta_grids ( alpha_like_stella , zed_stella ) use constants , only : pi use zgrid , only : nz2pi , zed use stella_geometry , only : zed_scalefac use stella_geometry , only : alpha use kt_grids , only : nalpha use globalVariables , only : iota implicit none real , dimension (:, :), intent ( out ) :: alpha_like_stella real , dimension (:), intent ( out ) :: zed_stella integer :: nzpi nzpi = nz2pi / 2 ! convert from scaled zed grid on [-pi,pi] ! to un-scaled grid with lower bound of zero ! note that zed_scalefac=1 unless geometryScheme=5 (VMEC) ! for geometryScheme=5, this will get extended zeta domain ! with lower bound of 0 zed_stella = ( zed ( - nzpi : nzpi ) + pi ) / zed_scalefac ! if geometryScheme is 5, then using vmec geo ! and thus zed in stella is scaled zeta ! otherwise zed in stella is theta if ( geometryScheme == 5 ) then ! alpha_like coordinate is theta = alpha + iota*zeta alpha_like_stella = spread ( alpha , 2 , nz2pi ) + spread ( iota * zed_stella , 1 , nalpha ) else ! alpha_like coordinate is zeta = (theta-alpha)/iota alpha_like_stella = ( spread ( zed_stella , 1 , nalpha ) - spread ( alpha , 2 , nz2pi )) / iota end if ! restrict alpha to [0,2*pi] alpha_like_stella = modulo ( alpha_like_stella , 2. * pi ) end subroutine get_stella_theta_zeta_grids subroutine get_nzed_per_field_period ( zed_stella , nfp , nzed_per_field_period ) use constants , only : pi use zgrid , only : nz2pi implicit none real , dimension (:), intent ( in ) :: zed_stella integer , intent ( in ) :: nfp integer , dimension (:), intent ( out ) :: nzed_per_field_period integer :: ifp , iz nzed_per_field_period = 0 ifp = 1 ; iz = 1 do while ( iz <= nz2pi ) if ( zed_stella ( iz ) <= ifp * 2. * pi / nfp ) then nzed_per_field_period ( ifp ) = nzed_per_field_period ( ifp ) + 1 iz = iz + 1 else ifp = ifp + 1 end if end do end subroutine get_nzed_per_field_period subroutine sort_zed_by_field_period ( zed_ext , nzed_per_fp , nfp , zed_by_fp ) use constants , only : pi implicit none real , dimension (:), intent ( in ) :: zed_ext integer , dimension (:), intent ( in ) :: nzed_per_fp integer , intent ( in ) :: nfp real , dimension (:, :), intent ( out ) :: zed_by_fp integer :: ifp , llim , ulim ulim = 0 do ifp = 1 , size ( zed_by_fp , 2 ) llim = ulim + 1 ulim = llim + nzed_per_fp ( ifp ) - 1 zed_by_fp (: nzed_per_fp ( ifp ), ifp ) = modulo ( zed_ext ( llim : ulim ) - 10 0. * epsilon ( 0. ), 2. * pi / nfp ) end do ! avoid special case of setting zed = 0 to zed=2*pi/nfp zed_by_fp ( 1 , 1 ) = 0.0 end subroutine sort_zed_by_field_period subroutine get_sfincs_theta_zeta_grid_sizes ( nalpha_sfincs , nzed_sfincs , nfp ) use constants , only : pi use export_f , only : export_f_zeta implicit none integer , intent ( out ) :: nalpha_sfincs , nzed_sfincs , nfp ! if geometryScheme is 5, then using vmec geo ! and thus zed in stella is scaled zeta ! otherwise zed in stella is theta if ( geometryScheme == 5 ) then ! note that zeta grid in sfincs only covers one field period of the stellarator ! get the number of field periods from the sfincs zeta grid nfp = nint ( 2. * pi / ( export_f_zeta ( nzeta ) + export_f_zeta ( 2 ))) ! zed coordinate is zeta nzed_sfincs = nzeta + 1 ! alpha_like coordinate is theta = alpha + iota*zeta nalpha_sfincs = ntheta + 1 else nfp = 1 ! zed coordinate is theta nzed_sfincs = ntheta + 1 ! alpha_like coordinate is zeta = (theta-alpha)*q nalpha_sfincs = nzeta end if end subroutine get_sfincs_theta_zeta_grid_sizes subroutine get_sfincs_theta_zeta_grids ( alpha_like_sfincs , zed_sfincs ) use export_f , only : export_f_theta , export_f_zeta implicit none real , dimension (:), intent ( out ) :: zed_sfincs , alpha_like_sfincs if ( geometryScheme == 5 ) then ! zed is zeta.  it goes from 0 to 2*pi/nfp - dzeta in sfincs, ! where nfp is the number of field periods zed_sfincs (: nzeta ) = export_f_zeta (: nzeta ) ! add in point at 2*pi/nfp using periodicity zed_sfincs ( nzeta + 1 ) = zed_sfincs ( nzeta ) + zed_sfincs ( 2 ) ! alpha-like coordinate is theta.  it goes from 0 to 2*pi-dtheta in sfincs alpha_like_sfincs (: ntheta ) = export_f_theta (: ntheta ) ! add in point at 2*pi using periodicity alpha_like_sfincs ( ntheta + 1 ) = export_f_theta ( ntheta ) + export_f_theta ( 2 ) else ! zed is theta.  it goes from 0 to 2*pi-dtheta in sfincs zed_sfincs (: ntheta ) = export_f_theta (: ntheta ) ! add in point at 2*pi using periodicity zed_sfincs ( ntheta + 1 ) = export_f_theta ( ntheta ) + export_f_theta ( 2 ) ! alpha-like coordinate is zeta.  there should only be 1 zeta for tokamak calculation alpha_like_sfincs (: nzeta ) = export_f_zeta (: nzeta ) end if end subroutine get_sfincs_theta_zeta_grids subroutine get_sfincs_field_theta_zeta ( field_in , field_out ) implicit none real , dimension (:, :), intent ( in ) :: field_in real , dimension (:, :), intent ( out ) :: field_out integer :: itheta , izeta ! want phi from sfincs such that alpha-like coordinate ! appears in first index and zed coordinate in second index if ( geometryScheme == 5 ) then ! get phi on sfincs (theta,zeta) grid field_out (: ntheta , : nzeta ) = field_in ! use periodicity in theta to add point at theta=2*pi field_out ( ntheta + 1 , : nzeta ) = field_out ( 1 , : nzeta ) ! use periodicity in zeta to add point at zeta = 2*pi/nfp field_out (:, nzeta + 1 ) = field_out (:, 1 ) else ! get phi on sfincs (zeta,theta) grid do izeta = 1 , nzeta do itheta = 1 , ntheta field_out ( izeta , itheta ) = field_in ( itheta , izeta ) end do end do ! use periodicity in theta to add point at 2*pi field_out (:, ntheta + 1 ) = field_out (:, 1 ) end if end subroutine get_sfincs_field_theta_zeta subroutine get_field_on_stella_zed_grid ( field_sfincs , nfp_stella , nfp , nzed_per_field_period , & nalpha_sfincs , zed_sfincs , zed_stella_by_field_period , field_stella_zgrid ) use constants , only : pi use splines , only : linear_interp_periodic implicit none real , dimension (:, :), intent ( in ) :: field_sfincs integer , intent ( in ) :: nfp_stella , nfp , nalpha_sfincs integer , dimension (:), intent ( in ) :: nzed_per_field_period real , dimension (:), intent ( in ) :: zed_sfincs real , dimension (:, :), intent ( in ) :: zed_stella_by_field_period real , dimension (:, :), intent ( out ) :: field_stella_zgrid integer :: ialpha , ifp integer :: llim , ulim do ialpha = 1 , nalpha_sfincs ulim = 0 do ifp = 1 , nfp_stella llim = ulim + 1 ulim = llim + nzed_per_field_period ( ifp ) - 1 call linear_interp_periodic ( zed_sfincs , field_sfincs ( ialpha , :), & zed_stella_by_field_period (: nzed_per_field_period ( ifp ), ifp ), & field_stella_zgrid ( ialpha , llim : ulim ), 2. * pi / nfp ) end do end do end subroutine get_field_on_stella_zed_grid subroutine get_field_stella ( field_stella_zgrid , alpha_like_sfincs , alpha_like_stella , field_stella ) use splines , only : linear_interp_periodic use zgrid , only : nz2pi implicit none real , dimension (:, :), intent ( in ) :: field_stella_zgrid real , dimension (:), intent ( in ) :: alpha_like_sfincs real , dimension (:, :), intent ( in ) :: alpha_like_stella real , dimension (:, :), intent ( out ) :: field_stella integer :: iz do iz = 1 , nz2pi call linear_interp_periodic ( alpha_like_sfincs , field_stella_zgrid (:, iz ), & alpha_like_stella (:, iz ), field_stella (:, iz )) end do end subroutine get_field_stella subroutine get_field_on_extended_zed ( field_stella , field_neoclassical ) use zgrid , only : nzgrid , nz2pi , nperiod use kt_grids , only : nalpha implicit none real , dimension (:, :), intent ( in ) :: field_stella real , dimension (:, - nzgrid :), intent ( out ) :: field_neoclassical integer :: ialpha integer :: iz_low , iz_up integer :: ip ! need to account for cases with nperiod > 1 do ialpha = 1 , nalpha iz_low = - nzgrid iz_up = - nzgrid + nz2pi - 1 field_neoclassical ( ialpha , iz_low : iz_up ) = field_stella ( ialpha , :) ! if nperiod > 1 need to make copies of ! neoclassical potential for other 2pi segments if ( nperiod > 1 ) then do ip = 2 , 2 * nperiod - 1 iz_low = iz_up + 1 iz_up = iz_low + nz2pi - 2 field_neoclassical ( ialpha , iz_low : iz_up ) = field_stella ( ialpha , 2 :) end do end if end do end subroutine get_field_on_extended_zed subroutine sfincs_vspace_to_stella_vspace ( ialpha , iz , is , h_stella , phi_neoclassical , f_neoclassical ) use constants , only : pi use species , only : spec use vpamu_grids , only : nvpa , nvgrid , nmu use vpamu_grids , only : vpa , vperp2 use vpamu_grids , only : maxwell_mu , maxwell_vpa use globalVariables , only : nxi_sfincs => nxi use globalVariables , only : nx_sfincs => nx use globalVariables , only : x_sfincs => x use xGrid , only : xGrid_k implicit none integer , intent ( in ) :: ialpha , iz , is real , dimension (:, :), intent ( in ) :: h_stella real , intent ( in ) :: phi_neoclassical real , dimension (:, :), intent ( out ) :: f_neoclassical integer :: iv , imu , ixi real , dimension ( 1 ) :: x_stella integer , dimension ( 2 ) :: sgnvpa integer :: nxi_stella real , dimension (:), allocatable :: xi_stella , hstella real , dimension (:, :), allocatable :: xsfincs_to_xstella , legpoly real , dimension (:), allocatable :: htmp ! each (vpa,mu) pair in stella specifies a speed ! on each speed arc, there are two (vpa,mu) pairs: ! one each corresponding to a given +/- vpa nxi_stella = 2 allocate ( xi_stella ( nxi_stella )) allocate ( hstella ( nxi_stella )) allocate ( legpoly ( nxi_stella , 0 : nxi_sfincs - 1 )) allocate ( htmp ( nxi_sfincs )) allocate ( xsfincs_to_xstella ( 1 , nx_sfincs )) sgnvpa ( 1 ) = 1 ; sgnvpa ( 2 ) = - 1 ! h_stella is on the sfincs energy grid ! but is spectral in pitch-angle do imu = 1 , nmu ! loop over positive vpa values ! negative vpa values will be treated inside loop using symmetry do iv = nvgrid + 1 , nvpa ! x_stella is the speed ! corresponding to this (vpa,mu) grid point x_stella = sqrt ( vpa ( iv ) ** 2 + vperp2 ( ialpha , iz , imu )) ! xi_stella contains the two pitch angles (+/-)vpa/v ! corresponding to this (vpa,mu) grid point xi_stella = sgnvpa * vpa ( iv ) / x_stella ( 1 ) ! set up matrix that interpolates from sfincs speed grid ! to the speed corresponding to this (vpa,mu) grid point call polynomialInterpolationMatrix ( nx_sfincs , 1 , & x_sfincs , x_stella , exp ( - x_sfincs * x_sfincs ) * ( x_sfincs ** xGrid_k ), & exp ( - x_stella * x_stella ) * ( x_stella ** xGrid_k ), xsfincs_to_xstella ) ! do the interpolation do ixi = 1 , nxi_sfincs htmp ( ixi ) = sum ( h_stella ( ixi , :) * xsfincs_to_xstella ( 1 , :)) end do ! next need to Legendre transform in pitch-angle ! first evaluate Legendre polynomials at requested pitch angles call legendre ( xi_stella , legpoly ) ! then do the transforms call legendre_transform ( legpoly , htmp , hstella ) f_neoclassical ( nvpa - iv + 1 , imu ) = hstella ( 2 ) f_neoclassical ( iv , imu ) = hstella ( 1 ) end do ! h_sfincs is H_nc / (nref/vt_ref&#94;3), with H_nc the non-Boltzmann part of F_nc ! NB: n_ref, etc. is fixed in stella to be the reference density ! at the central sfincs simulation; i.e., it does not vary with radius ! to be consistent with stella distribution functions, ! want H_nc / (n_s / vt_s&#94;3 * pi&#94;(3/2)) / exp(-v&#94;2/vts&#94;2) f_neoclassical (:, imu ) = f_neoclassical (:, imu ) & * pi ** 1.5 * spec ( is )% stm ** 3 / spec ( is )% dens ! phi_sfincs is e phi / Tref as long as alpha=1 (default) ! need to multiply by Z_s * Tref/T_s f_neoclassical (:, imu ) = f_neoclassical (:, imu ) & - phi_neoclassical * spec ( is )% zt * maxwell_vpa * maxwell_mu ( ialpha , iz , imu ) end do deallocate ( xi_stella , hstella , legpoly ) deallocate ( xsfincs_to_xstella ) deallocate ( htmp ) end subroutine sfincs_vspace_to_stella_vspace subroutine get_dfield_dalpha ( field , alpha_like_sfincs , dfield_dalpha ) use zgrid , only : nz2pi implicit none real , dimension (:, :), intent ( in ) :: field real , dimension (:), intent ( in ) :: alpha_like_sfincs real , dimension (:, :), intent ( out ) :: dfield_dalpha integer :: iz do iz = 1 , nz2pi call get_periodic_derivative ( field (:, iz ), alpha_like_sfincs , dfield_dalpha (:, iz )) end do end subroutine get_dfield_dalpha ! 4th order accurate, centered differences, assumes ! first and last elements of f are equal (periodic) subroutine get_periodic_derivative ( f , x , dfdx ) implicit none real , dimension (:), intent ( in ) :: f , x real , dimension (:), intent ( out ) :: dfdx integer :: i , n real , dimension (:), allocatable :: fp n = size ( x ) allocate ( fp ( - 1 : n + 2 )) ! extend f using periodicity, as these additional points ! required near boundaries for finite differences fp ( 1 : n ) = f fp ( - 1 : 0 ) = f ( n - 1 : n ) fp ( n + 1 : n + 2 ) = f ( 1 : 2 ) do i = 1 , n dfdx ( i ) = ( 0.25 * ( fp ( i - 2 ) - fp ( i + 2 )) + 2.0 * ( fp ( i + 1 ) - fp ( i - 1 ))) / 3.0 end do deallocate ( fp ) end subroutine get_periodic_derivative !   subroutine bilinear_interpolation (alpha_in, zed_in, phi_in, alpha_out, zed_out, phi_out) !     use zgrid, only: nz2pi !     implicit none !     real, dimension (:,:), intent (in) :: alpha_sfincs, phi_sfincs !     real, dimension (:), intent (in) :: zed_sfincs !     real, dimension (:), intent (in) :: alpha_stella, zed_stella !     real, dimension (:,:), intent (out) :: phi_stella !     integer :: ialpha, iz !     do ialpha = 1, nalpha !        do iz = 1, nz2pi !           call find_sfincs_cell (alpha_stella(ialpha), zed_stella(iz), alpha_sfincs, zed_sfincs, & !                alpha_grids, zed_grids) !        end do !     end do !   contains !     subroutine find_sfincs_cell (alpha_target, zed_target, alpha, zed, ialpha_out, ized_out) !       use zgrid, only: nz2pi !       implicit none !       real, intent (in) :: alpha_target, zed_target !       real, dimension (:,:), intent (in) :: alpha !       real, dimension (:), intent (in) :: zed !       integer, dimension (2), intent (out) :: ialpha_out, ized_out !       integer :: iz, ia !       do iz = 1, nz2pi !          do ia = 1, size(alpha,1) !             if ( !          end do !       end do !     end subroutine find_sfincs_cell !   end subroutine bilinear_interpolation ! returns the Legendre polynomials (legp) ! on requested grid (x) subroutine legendre ( x , legp ) implicit none real , dimension (:), intent ( in ) :: x real , dimension (:, 0 :), intent ( out ) :: legp integer :: n , idx n = size ( legp , 2 ) - 1 legp (:, 0 ) = 1.0 legp (:, 1 ) = x do idx = 2 , n legp (:, idx ) = (( 2. * idx - 1. ) * x * legp (:, idx - 1 ) + ( 1. - idx ) * legp (:, idx - 2 )) / idx end do end subroutine legendre subroutine legendre_transform ( legp , coefs , func ) implicit none real , dimension (:, 0 :), intent ( in ) :: legp real , dimension (:), intent ( in ) :: coefs real , dimension (:), intent ( out ) :: func integer :: i func = 0. do i = 1 , size ( coefs ) func = func + legp (:, i - 1 ) * coefs ( i ) end do end subroutine legendre_transform subroutine broadcast_sfincs_output ( fneo , phineo ) use mp , only : broadcast use zgrid , only : nzgrid implicit none real , dimension ( - nzgrid :, :, :, :, :), intent ( in out ) :: fneo real , dimension ( - nzgrid :, :), intent ( in out ) :: phineo call broadcast ( fneo ) call broadcast ( phineo ) end subroutine broadcast_sfincs_output subroutine write_sfincs ( irad , nrad_max ) use species , only : nspec use globalVariables , only : Phi1Hat use export_f , only : export_f_zeta , export_f_theta use export_f , only : delta_f implicit none integer , intent ( in ) :: irad , nrad_max integer :: unit = 999 integer :: izeta , itheta , is , i , j character ( 1 ) :: irad_str write ( irad_str , '(i0)' ) irad + min ( nrad_max , 1 ) open ( unit = unit , file = 'sfincs.output.rad' // irad_str , status = 'replace' , action = 'write' ) do izeta = 1 , nzeta do itheta = 1 , ntheta write ( unit , '(a8,3e13.5,i3)' ) 'Phi1Hat' , export_f_theta ( itheta ), export_f_zeta ( izeta ), Phi1Hat ( itheta , izeta ), irad end do write ( unit , * ) end do write ( unit , * ) do is = 1 , nspec do i = 1 , size ( delta_f , 5 ) do j = 1 , size ( delta_f , 4 ) do izeta = 1 , nzeta do itheta = 1 , ntheta write ( unit , '(a8,3e13.5,4i5)' ) 'delta_f' , export_f_theta ( itheta ), export_f_zeta ( izeta ), & delta_f ( is , itheta , izeta , j , i ), i , j , is , irad end do write ( unit , * ) end do end do end do end do write ( unit , * ) close ( unit ) end subroutine write_sfincs subroutine read_sfincs_output ( irad , nrad_max ) use species , only : nspec use globalVariables , only : Phi1Hat use export_f , only : export_f_zeta , export_f_theta use export_f , only : delta_f implicit none integer , intent ( in ) :: irad , nrad_max integer :: unit = 999 integer :: izeta , itheta , is , i , j character ( 8 ) :: dum character ( 1 ) :: irad_str write ( irad_str , '(i0)' ) irad + nrad_max open ( unit = unit , file = 'sfincs.output.rad' // irad_str , status = 'old' , action = 'read' ) do izeta = 1 , nzeta do itheta = 1 , ntheta read ( unit , * ) dum , export_f_theta ( itheta ), export_f_zeta ( izeta ), Phi1Hat ( itheta , izeta ), dum end do read ( unit , * ) end do read ( unit , * ) do is = 1 , nspec do i = 1 , size ( delta_f , 5 ) do j = 1 , size ( delta_f , 4 ) do izeta = 1 , nzeta do itheta = 1 , ntheta read ( unit , * ) dum , export_f_theta ( itheta ), export_f_zeta ( izeta ), & delta_f ( is , itheta , izeta , j , i ), dum , dum , dum , dum end do read ( unit , * ) end do end do end do end do read ( unit , * ) close ( unit ) end subroutine read_sfincs_output # endif end module sfincs_interface","tags":"","loc":"sourcefile/sfincs_interface.fpp.html"},{"title":"response_matrix.fpp â€“ stella","text":"Contents Modules response_matrix Source Code response_matrix.fpp Source Code module response_matrix use netcdf use mpi implicit none public :: init_response_matrix , finish_response_matrix public :: read_response_matrix public :: response_matrix_initialized private logical :: response_matrix_initialized = . false . integer , parameter :: mat_unit = 70 #if defined MPI && defined ISO_C_BINDING integer :: window = MPI_WIN_NULL #endif contains subroutine init_response_matrix use linear_solve , only : lu_decomposition use fields_arrays , only : response_matrix use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx , is_idx use kt_grids , only : naky use extended_zgrid , only : iz_low , iz_up use extended_zgrid , only : neigen , ikxmod use extended_zgrid , only : nsegments use extended_zgrid , only : nzed_segment use extended_zgrid , only : periodic use job_manage , only : time_message use mp , only : proc0 , job , mp_abort use run_parameters , only : mat_gen , lu_option_switch use run_parameters , only : lu_option_none , lu_option_local , lu_option_global use system_fortran , only : systemf #if defined MPI && defined ISO_C_BINDING use , intrinsic :: iso_c_binding , only : c_ptr , c_f_pointer use mp , only : curr_focus , sgproc0 , mp_comm , sharedsubprocs , scope , barrier use mp , only : real_size , nbytes_real use mpi #endif implicit none integer :: iky , ie , iseg , iz integer :: ikx integer :: nz_ext , nresponse integer :: idx integer :: izl_offset , izup #if defined MPI && defined ISO_C_BINDING integer :: prior_focus , ierr integer :: disp_unit = 1 integer ( kind = MPI_ADDRESS_KIND ) :: win_size integer * 8 :: cur_pos type ( c_ptr ) :: bptr , cptr #endif real :: dum complex , dimension (:), allocatable :: phiext complex , dimension (:, :), allocatable :: gext logical :: debug = . false . character ( 100 ) :: message_dgdphi , message_QN , message_lu real , dimension ( 2 ) :: time_response_matrix_dgdphi real , dimension ( 2 ) :: time_response_matrix_QN real , dimension ( 2 ) :: time_response_matrix_lu ! Related to the saving of the the matrices in netcdf format character ( len = 15 ) :: fmt , job_str character ( len = 100 ) :: file_name integer :: istatus istatus = 0 if ( proc0 . and . debug ) then write ( * , * ) \" \" write ( * , '(A)' ) \"    ############################################################\" write ( * , '(A)' ) \"                         RESPONSE MATRIX\" write ( * , '(A)' ) \"    ############################################################\" end if message_dgdphi = '     calculate dgdphi: ' message_QN = '     calculate QN:     ' message_lu = '     calculate LU:     ' time_response_matrix_dgdphi = 0 time_response_matrix_QN = 0 time_response_matrix_lu = 0 !   All matrices handled by processor i_proc and job are stored !   on a single file named: response_mat_job.iproc fmt = '(I5.5)' if ( proc0 . and . mat_gen ) then call systemf ( 'mkdir -p mat' ) write ( job_str , '(I1.1)' ) job file_name = './mat/response_mat_' // trim ( job_str ) open ( unit = mat_unit , status = 'replace' , file = file_name , & position = 'rewind' , action = 'write' , form = 'unformatted' ) write ( unit = mat_unit ) naky end if if ( response_matrix_initialized ) return response_matrix_initialized = . true . if (. not . allocated ( response_matrix )) allocate ( response_matrix ( naky )) #if defined ISO_C_BINDING && defined MPI !   Create a single shared memory window for all the response matrices and !   permutation arrays. !   Creating a window for each matrix/array would lead to performance !   degradation on some clusters if ( window == MPI_WIN_NULL ) then prior_focus = curr_focus call scope ( sharedsubprocs ) win_size = 0 if ( sgproc0 ) then do iky = 1 , naky do ie = 1 , neigen ( iky ) if ( periodic ( iky )) then nresponse = nsegments ( ie , iky ) * nzed_segment else nresponse = nsegments ( ie , iky ) * nzed_segment + 1 end if win_size = win_size & + int ( nresponse , MPI_ADDRESS_KIND ) * 4_MPI_ADDRESS_KIND & + int ( nresponse ** 2 , MPI_ADDRESS_KIND ) * 2 * real_size end do end do end if call mpi_win_allocate_shared ( win_size , disp_unit , MPI_INFO_NULL , mp_comm , & bptr , window , ierr ) if (. not . sgproc0 ) then !make sure all the procs have the right memory address call mpi_win_shared_query ( window , 0 , win_size , disp_unit , bptr , ierr ) end if call mpi_win_fence ( 0 , window , ierr ) !the following is a hack that allows us to perform pointer arithmetic in Fortran cur_pos = transfer ( bptr , cur_pos ) call scope ( prior_focus ) end if #endif ! for a given ky and set of connected kx values ! give a unit impulse to phi at each zed location ! in the extended domain and solve for h(zed_extended,(vpa,mu,s)) do iky = 1 , naky if ( proc0 . and . mat_gen ) THEN write ( unit = mat_unit ) iky , neigen ( iky ) end if ! the response matrix for each ky has neigen(ky) ! independent sets of connected kx values if (. not . associated ( response_matrix ( iky )% eigen )) & allocate ( response_matrix ( iky )% eigen ( neigen ( iky ))) if ( proc0 . and . debug ) then call time_message (. false ., time_response_matrix_dgdphi , message_dgdphi ) end if ! loop over the sets of connected kx values do ie = 1 , neigen ( iky ) ! number of zeds x number of segments nz_ext = nsegments ( ie , iky ) * nzed_segment + 1 ! treat zonal mode specially to avoid double counting ! as it is periodic if ( periodic ( iky )) then nresponse = nz_ext - 1 else nresponse = nz_ext end if if ( proc0 . and . mat_gen ) then write ( unit = mat_unit ) ie , nresponse end if #if !defined ISO_C_BINDING || !defined MPI ! for each ky and set of connected kx values, ! must have a response matrix that is N x N ! with N = number of zeds per 2pi segment x number of 2pi segments if (. not . associated ( response_matrix ( iky )% eigen ( ie )% zloc )) & allocate ( response_matrix ( iky )% eigen ( ie )% zloc ( nresponse , nresponse )) ! response_matrix%idx is needed to keep track of permutations ! to the response matrix made during LU decomposition ! it will be input to LU back substitution during linear solve if (. not . associated ( response_matrix ( iky )% eigen ( ie )% idx )) & allocate ( response_matrix ( iky )% eigen ( ie )% idx ( nresponse )) #else !exploit MPIs shared memory framework to reduce memory consumption of !response matrices if (. not . associated ( response_matrix ( iky )% eigen ( ie )% zloc )) then cptr = transfer ( cur_pos , cptr ) call c_f_pointer ( cptr , response_matrix ( iky )% eigen ( ie )% zloc , ( / nresponse , nresponse / )) cur_pos = cur_pos + nresponse ** 2 * 2 * nbytes_real end if if (. not . associated ( response_matrix ( iky )% eigen ( ie )% idx )) then cptr = transfer ( cur_pos , cptr ) call c_f_pointer ( cptr , response_matrix ( iky )% eigen ( ie )% idx , ( / nresponse / )) cur_pos = cur_pos + nresponse * 4 end if #endif allocate ( gext ( nz_ext , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) allocate ( phiext ( nz_ext )) ! idx is the index in the extended zed domain ! that we are giving a unit impulse idx = 0 ! loop over segments, starting with 1 ! first segment is special because it has ! one more unique zed value than all others ! since domain is [z0-pi:z0+pi], including both endpoints ! i.e., one endpoint is shared with the previous segment iseg = 1 ! ikxmod gives the kx corresponding to iseg,ie,iky ikx = ikxmod ( iseg , ie , iky ) izl_offset = 0 ! avoid double-counting of periodic points for zonal mode (and other periodic modes) if ( periodic ( iky )) then izup = iz_up ( iseg ) - 1 else izup = iz_up ( iseg ) end if ! no need to obtain response to impulses at negative kx values do iz = iz_low ( iseg ), izup idx = idx + 1 call get_dgdphi_matrix_column ( iky , ikx , iz , ie , idx , nz_ext , nresponse , phiext , gext ) end do ! once we have used one segments, remaining segments ! have one fewer unique zed point izl_offset = 1 if ( nsegments ( ie , iky ) > 1 ) then do iseg = 2 , nsegments ( ie , iky ) ikx = ikxmod ( iseg , ie , iky ) do iz = iz_low ( iseg ) + izl_offset , iz_up ( iseg ) idx = idx + 1 call get_dgdphi_matrix_column ( iky , ikx , iz , ie , idx , nz_ext , nresponse , phiext , gext ) end do if ( izl_offset == 0 ) izl_offset = 1 end do end if deallocate ( gext , phiext ) end do !DSO - This ends parallelization over velocity space. !      At this point every processor has int dv dgdphi for a given ky !      and so the quasineutrality solve and LU decomposition can be !      parallelized locally if need be. !      This is preferable to parallelization over ky as the LU !      decomposition (and perhaps QN) will be dominated by the !      ky with the most connections if ( proc0 . and . debug ) then call time_message (. true ., time_response_matrix_dgdphi , message_dgdphi ) call time_message (. false ., time_response_matrix_QN , message_QN ) end if #ifdef ISO_C_BINDING call mpi_win_fence ( 0 , window , ierr ) #endif ! solve quasineutrality ! for local stella, this is a diagonal process, but global stella ! may require something more sophisticated ! loop over the sets of connected kx values do ie = 1 , neigen ( iky ) #if defined ISO_C_BINDING && defined MPI if ( sgproc0 ) then #endif ! number of zeds x number of segments nz_ext = nsegments ( ie , iky ) * nzed_segment + 1 ! treat zonal mode specially to avoid double counting ! as it is periodic if ( periodic ( iky )) then nresponse = nz_ext - 1 else nresponse = nz_ext end if allocate ( phiext ( nz_ext )) do idx = 1 , nresponse phiext ( nz_ext ) = 0.0 phiext (: nresponse ) = response_matrix ( iky )% eigen ( ie )% zloc (:, idx ) call get_fields_for_response_matrix ( phiext , iky , ie ) ! next need to create column in response matrix from phiext ! negative sign because matrix to be inverted in streaming equation ! is identity matrix - response matrix ! add in contribution from identity matrix phiext ( idx ) = phiext ( idx ) - 1.0 response_matrix ( iky )% eigen ( ie )% zloc (:, idx ) = - phiext (: nresponse ) end do deallocate ( phiext ) #if defined ISO_C_BINDING && defined MPI end if #endif end do #ifdef ISO_C_BINDING call mpi_win_fence ( 0 , window , ierr ) #endif if ( proc0 . and . debug ) then call time_message (. true ., time_response_matrix_QN , message_QN ) call time_message (. false ., time_response_matrix_lu , message_lu ) end if !now we have the full response matrix. Finally, perform its LU decomposition #ifdef MPI select case ( lu_option_switch ) case ( lu_option_global ) call parallel_LU_decomposition_global ( iky ) case ( lu_option_local ) #ifdef ISO_C_BINDING call parallel_LU_decomposition_local ( iky ) #else call mp_abort ( 'Stella must be built with HAS_ISO_BINDING in order to use local parallel LU decomposition.' ) #endif case default #endif do ie = 1 , neigen ( iky ) #ifdef ISO_C_BINDING if ( sgproc0 ) then #endif ! now that we have the reponse matrix for this ky and set of connected kx values !get the LU decomposition so we are ready to solve the linear system call lu_decomposition ( response_matrix ( iky )% eigen ( ie )% zloc , & response_matrix ( iky )% eigen ( ie )% idx , dum ) #ifdef ISO_C_BINDING end if #endif end do #ifdef MPI end select #endif if ( proc0 . and . debug ) then call time_message (. true ., time_response_matrix_lu , message_lu ) end if time_response_matrix_dgdphi = 0 time_response_matrix_QN = 0 time_response_matrix_lu = 0 do ie = 1 , neigen ( iky ) if ( proc0 . and . mat_gen ) then write ( unit = mat_unit ) response_matrix ( iky )% eigen ( ie )% idx write ( unit = mat_unit ) response_matrix ( iky )% eigen ( ie )% zloc end if end do !if(proc0)  write (*,*) 'job', iky, iproc, response_matrix(iky)%eigen(1)%zloc(5,:) end do #ifdef ISO_C_BINDING call mpi_win_fence ( 0 , window , ierr ) #endif if ( proc0 . and . mat_gen ) then close ( unit = mat_unit ) end if if ( proc0 . and . debug ) then write ( * , '(A)' ) \"    ############################################################\" write ( * , '(A)' ) \" \" end if end subroutine init_response_matrix subroutine read_response_matrix use fields_arrays , only : response_matrix use common_types , only : response_matrix_type use kt_grids , only : naky use extended_zgrid , only : neigen use extended_zgrid , only : nsegments use extended_zgrid , only : nzed_segment use extended_zgrid , only : periodic use mp , only : proc0 , job , broadcast , mp_abort implicit none integer :: iky , ie , nz_ext integer :: iky_dump , neigen_dump , naky_dump , nresponse_dump integer :: nresponse character ( len = 15 ) :: fmt , job_str character ( len = 100 ) :: file_name integer :: istatus , ie_dump , istat logical , parameter :: debug = . false . istatus = 0 !   All matrices handled for the job i_job are read !   from a single file named: responst_mat.ijob by that !   jobs root process if ( proc0 ) then fmt = '(I5.5)' write ( job_str , '(I1.1)' ) job file_name = './mat/response_mat.' // trim ( job_str ) open ( unit = mat_unit , status = 'old' , file = file_name , & action = 'read' , form = 'unformatted' , iostat = istat ) if ( istat /= 0 ) then print * , 'Error opening response_matrix by root processor for job ' , job_str end if read ( unit = mat_unit ) naky_dump if ( naky /= naky_dump ) call mp_abort ( 'mismatch in naky and naky_dump' ) end if if (. not . allocated ( response_matrix )) allocate ( response_matrix ( naky )) do iky = 1 , naky if ( proc0 ) then read ( unit = mat_unit ) iky_dump , neigen_dump if ( iky_dump /= iky . or . neigen_dump /= neigen ( iky )) & call mp_abort ( 'mismatch in iky_dump/neigen_dump' ) end if if (. not . associated ( response_matrix ( iky )% eigen )) & allocate ( response_matrix ( iky )% eigen ( neigen ( iky ))) ! loop over the sets of connected kx values do ie = 1 , neigen ( iky ) ! number of zeds x number of segments nz_ext = nsegments ( ie , iky ) * nzed_segment + 1 ! treat zonal mode specially to avoid double counting ! as it is periodic if ( periodic ( iky )) then nresponse = nz_ext - 1 else nresponse = nz_ext end if if ( proc0 ) then read ( unit = mat_unit ) ie_dump , nresponse_dump if ( ie_dump /= ie . or . nresponse /= nresponse_dump ) & call mp_abort ( 'mismatch in ie/nresponse_dump' ) end if ! for each ky and set of connected kx values, ! must have a response matrix that is N x N ! with N = number of zeds per 2pi segment x number of 2pi segments if (. not . associated ( response_matrix ( iky )% eigen ( ie )% zloc )) & allocate ( response_matrix ( iky )% eigen ( ie )% zloc ( nresponse , nresponse )) ! response_matrix%idx is needed to keep track of permutations ! to the response matrix made during LU decomposition ! it will be input to LU back substitution during linear solve if (. not . associated ( response_matrix ( iky )% eigen ( ie )% idx )) & allocate ( response_matrix ( iky )% eigen ( ie )% idx ( nresponse )) if ( proc0 ) then read ( unit = mat_unit ) response_matrix ( iky )% eigen ( ie )% idx read ( unit = mat_unit ) response_matrix ( iky )% eigen ( ie )% zloc end if call broadcast ( response_matrix ( iky )% eigen ( ie )% idx ) call broadcast ( response_matrix ( iky )% eigen ( ie )% zloc ) end do end do if ( proc0 ) close ( mat_unit ) if ( debug ) then print * , 'File' , file_name , ' successfully read by root proc for job: ' , job_str end if end subroutine read_response_matrix subroutine get_dgdphi_matrix_column ( iky , ikx , iz , ie , idx , nz_ext , nresponse , phiext , gext ) use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx , imu_idx , is_idx use stella_time , only : code_dt use zgrid , only : delzed , nzgrid use extended_zgrid , only : periodic use species , only : spec use stella_geometry , only : gradpar , dbdzed use vpamu_grids , only : vpa , mu use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use fields_arrays , only : response_matrix use gyro_averages , only : aj0x use run_parameters , only : driftkinetic_implicit use run_parameters , only : maxwellian_inside_zed_derivative use parallel_streaming , only : stream_tridiagonal_solve use parallel_streaming , only : stream_sign use run_parameters , only : zed_upwind , time_upwind #if defined ISO_C_BINDING && defined MPI use mp , only : sgproc0 #endif implicit none integer , intent ( in ) :: iky , ikx , iz , ie , idx , nz_ext , nresponse complex , dimension (:), intent ( in out ) :: phiext complex , dimension (:, vmu_lo % llim_proc :), intent ( in out ) :: gext integer :: ivmu , iv , imu , is , ia integer :: izp , izm real :: mu_dbdzed_p , mu_dbdzed_m real :: fac , fac0 , fac1 , gyro_fac ia = 1 if (. not . maxwellian_inside_zed_derivative ) then ! get -vpa*b.gradz*Ze/T*F0*d<phi>/dz corresponding to unit impulse in phi do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc ! initialize g to zero everywhere along extended zed domain gext (:, ivmu ) = 0.0 iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) ! give unit impulse to phi at this zed location ! and compute -vpa*b.gradz*Ze/T*d<phi>/dz*F0 (RHS of streaming part of GKE) ! NB:  assuming equal spacing in zed below ! here, fac = -dt*(1+alph_t)/2*vpa*Ze/T*F0*J0/dz ! b.gradz left out because needs to be centred in zed if ( driftkinetic_implicit ) then gyro_fac = 1.0 else gyro_fac = aj0x ( iky , ikx , iz , ivmu ) end if ! 0.125 to account for two linear interpolations fac = - 0.125 * ( 1. + time_upwind ) * code_dt * vpa ( iv ) * spec ( is )% stm_psi0 & * gyro_fac * spec ( is )% zt / delzed ( 0 ) * maxwell_vpa ( iv , is ) * maxwell_fac ( is ) ! In the following, gradpar and maxwell_mu are interpolated separately ! to ensure consistency to what is done in parallel_streaming.f90 ! stream_sign < 0 corresponds to positive advection speed if ( stream_sign ( iv ) < 0 ) then if ( iz > - nzgrid ) then ! fac0 is the factor multiplying delphi on the RHS ! of the homogeneous GKE at this zed index fac0 = fac * (( 1. + zed_upwind ) * gradpar ( iz ) & + ( 1. - zed_upwind ) * gradpar ( iz - 1 )) & * (( 1. + zed_upwind ) * maxwell_mu ( ia , iz , imu , is ) & + ( 1. - zed_upwind ) * maxwell_mu ( ia , iz - 1 , imu , is )) ! fac1 is the factor multiplying delphi on the RHS ! of the homogeneous GKE at the zed index to the right of ! this one if ( iz < nzgrid ) then fac1 = fac * (( 1. + zed_upwind ) * gradpar ( iz + 1 ) & + ( 1. - zed_upwind ) * gradpar ( iz )) & * (( 1. + zed_upwind ) * maxwell_mu ( ia , iz + 1 , imu , is ) & + ( 1. - zed_upwind ) * maxwell_mu ( ia , iz , imu , is )) else fac1 = fac * (( 1. + zed_upwind ) * gradpar ( - nzgrid + 1 ) & + ( 1. - zed_upwind ) * gradpar ( nzgrid )) & * (( 1. + zed_upwind ) * maxwell_mu ( ia , - nzgrid + 1 , imu , is ) & + ( 1. - zed_upwind ) * maxwell_mu ( ia , nzgrid , imu , is )) end if else ! fac0 is the factor multiplying delphi on the RHS ! of the homogeneous GKE at this zed index fac0 = fac * (( 1. + zed_upwind ) * gradpar ( iz ) & + ( 1. - zed_upwind ) * gradpar ( nzgrid - 1 )) & * (( 1. + zed_upwind ) * maxwell_mu ( ia , iz , imu , is ) & + ( 1. - zed_upwind ) * maxwell_mu ( ia , nzgrid - 1 , imu , is )) ! fac1 is the factor multiplying delphi on the RHS ! of the homogeneous GKE at the zed index to the right of ! this one fac1 = fac * (( 1. + zed_upwind ) * gradpar ( iz + 1 ) & + ( 1. - zed_upwind ) * gradpar ( iz )) & * (( 1. + zed_upwind ) * maxwell_mu ( ia , iz + 1 , imu , is ) & + ( 1. - zed_upwind ) * maxwell_mu ( ia , iz , imu , is )) end if gext ( idx , ivmu ) = fac0 if ( idx < nz_ext ) gext ( idx + 1 , ivmu ) = - fac1 ! zonal mode BC is periodic instead of zero, so must ! treat specially if ( periodic ( iky )) then if ( idx == 1 ) then gext ( nz_ext , ivmu ) = fac0 else if ( idx == nz_ext - 1 ) then gext ( 1 , ivmu ) = - fac1 end if end if else if ( iz < nzgrid ) then ! fac0 is the factor multiplying delphi on the RHS ! of the homogeneous GKE at this zed index fac0 = fac * (( 1. + zed_upwind ) * gradpar ( iz ) & + ( 1. - zed_upwind ) * gradpar ( iz + 1 )) & * (( 1. + zed_upwind ) * maxwell_mu ( ia , iz , imu , is ) & + ( 1. - zed_upwind ) * maxwell_mu ( ia , iz + 1 , imu , is )) ! fac1 is the factor multiplying delphi on the RHS ! of the homogeneous GKE at the zed index to the left of ! this one if ( iz > - nzgrid ) then fac1 = fac * (( 1. + zed_upwind ) * gradpar ( iz - 1 ) & + ( 1. - zed_upwind ) * gradpar ( iz )) & * (( 1. + zed_upwind ) * maxwell_mu ( ia , iz - 1 , imu , is ) & + ( 1. - zed_upwind ) * maxwell_mu ( ia , iz , imu , is )) else fac1 = fac * (( 1. + zed_upwind ) * gradpar ( nzgrid - 1 ) & + ( 1. - zed_upwind ) * gradpar ( iz )) & * (( 1. + zed_upwind ) * maxwell_mu ( ia , nzgrid - 1 , imu , is ) & + ( 1. - zed_upwind ) * maxwell_mu ( ia , iz , imu , is )) end if else ! fac0 is the factor multiplying delphi on the RHS ! of the homogeneous GKE at this zed index fac0 = fac * (( 1. + zed_upwind ) * gradpar ( iz ) & + ( 1. - zed_upwind ) * gradpar ( - nzgrid + 1 )) & * (( 1. + zed_upwind ) * maxwell_mu ( ia , iz , imu , is ) & + ( 1. - zed_upwind ) * maxwell_mu ( ia , - nzgrid + 1 , imu , is )) ! fac1 is the factor multiplying delphi on the RHS ! of the homogeneous GKE at the zed index to the left of ! this one fac1 = fac * (( 1. + zed_upwind ) * gradpar ( iz - 1 ) & + ( 1. - zed_upwind ) * gradpar ( iz )) & * (( 1. + zed_upwind ) * maxwell_mu ( ia , iz - 1 , imu , is ) & + ( 1. - zed_upwind ) * maxwell_mu ( ia , iz , imu , is )) end if gext ( idx , ivmu ) = - fac0 if ( idx > 1 ) gext ( idx - 1 , ivmu ) = fac1 ! zonal mode BC is periodic instead of zero, so must ! treat specially if ( periodic ( iky )) then if ( idx == 1 ) then gext ( nz_ext , ivmu ) = - fac0 gext ( nz_ext - 1 , ivmu ) = fac1 else if ( idx == 2 ) then gext ( nz_ext , ivmu ) = fac1 end if end if end if ! hack for now (duplicates much of the effort from sweep_zed_zonal) if ( periodic ( iky )) then call sweep_zed_zonal_response ( iv , is , stream_sign ( iv ), gext (:, ivmu )) else ! invert parallel streaming equation to get g&#94;{n+1} on extended zed grid ! (I + (1+alph)/2*dt*vpa)*g_{inh}&#94;{n+1} = RHS = gext call stream_tridiagonal_solve ( iky , ie , iv , is , gext (:, ivmu )) end if end do else ! get -vpa*b.gradz*Ze/T*F0*d<phi>/dz corresponding to unit impulse in phi do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc ! initialize g to zero everywhere along extended zed domain gext (:, ivmu ) = 0.0 iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) ! give unit impulse to phi at this zed location ! and compute -vpa*b.gradz*Ze/T*d<phi>/dz*F0 (RHS of streaming part of GKE) ! NB:  assuming equal spacing in zed below ! here, fac = -dt*(1+alph_t)/2*vpa*Ze/T*F0*J0/dz ! b.gradz left out because needs to be centred in zed if ( driftkinetic_implicit ) then gyro_fac = 1.0 else gyro_fac = aj0x ( iky , ikx , iz , ivmu ) end if fac = - 0.25 * ( 1. + time_upwind ) * code_dt * vpa ( iv ) * spec ( is )% stm_psi0 & * gyro_fac * spec ( is )% zt * maxwell_vpa ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) * maxwell_fac ( is ) mu_dbdzed_p = 1. / delzed ( 0 ) + mu ( imu ) * dbdzed ( ia , iz ) * ( 1. + zed_upwind ) mu_dbdzed_m = 1. / delzed ( 0 ) + mu ( imu ) * dbdzed ( ia , iz ) * ( 1. - zed_upwind ) ! stream_sign < 0 corresponds to positive advection speed if ( stream_sign ( iv ) < 0 ) then if ( iz > - nzgrid ) then ! fac0 is the factor multiplying delphi on the RHS ! of the homogeneous GKE at this zed index fac0 = fac * (( 1. + zed_upwind ) * gradpar ( iz ) & + ( 1. - zed_upwind ) * gradpar ( iz - 1 )) * mu_dbdzed_p ! fac1 is the factor multiplying delphi on the RHS ! of the homogeneous GKE at the zed index to the right of ! this one if ( iz < nzgrid ) then izp = iz + 1 else izp = - nzgrid + 1 end if fac1 = fac * (( 1. + zed_upwind ) * gradpar ( izp ) & + ( 1. - zed_upwind ) * gradpar ( iz )) * mu_dbdzed_m else ! fac0 is the factor multiplying delphi on the RHS ! of the homogeneous GKE at this zed index fac0 = fac * (( 1. + zed_upwind ) * gradpar ( iz ) & + ( 1. - zed_upwind ) * gradpar ( nzgrid - 1 )) * mu_dbdzed_p ! fac1 is the factor multiplying delphi on the RHS ! of the homogeneous GKE at the zed index to the right of ! this one fac1 = fac * (( 1. + zed_upwind ) * gradpar ( iz + 1 ) & + ( 1. - zed_upwind ) * gradpar ( iz )) * mu_dbdzed_m end if gext ( idx , ivmu ) = fac0 if ( idx < nz_ext ) gext ( idx + 1 , ivmu ) = - fac1 ! zonal mode BC is periodic instead of zero, so must ! treat specially if ( periodic ( iky )) then if ( idx == 1 ) then gext ( nz_ext , ivmu ) = fac0 else if ( idx == nz_ext - 1 ) then gext ( 1 , ivmu ) = - fac1 end if end if else if ( iz < nzgrid ) then ! fac0 is the factor multiplying delphi on the RHS ! of the homogeneous GKE at this zed index fac0 = fac * (( 1. + zed_upwind ) * gradpar ( iz ) & + ( 1. - zed_upwind ) * gradpar ( iz + 1 )) * mu_dbdzed_p ! fac1 is the factor multiplying delphi on the RHS ! of the homogeneous GKE at the zed index to the left of ! this one if ( iz > - nzgrid ) then izm = iz - 1 else izm = nzgrid - 1 end if fac1 = fac * (( 1. + zed_upwind ) * gradpar ( izm ) & + ( 1. - zed_upwind ) * gradpar ( iz )) * mu_dbdzed_m else ! fac0 is the factor multiplying delphi on the RHS ! of the homogeneous GKE at this zed index fac0 = fac * (( 1. + zed_upwind ) * gradpar ( iz ) & + ( 1. - zed_upwind ) * gradpar ( - nzgrid + 1 )) * mu_dbdzed_p ! fac1 is the factor multiplying delphi on the RHS ! of the homogeneous GKE at the zed index to the left of ! this one fac1 = fac * (( 1. + zed_upwind ) * gradpar ( iz - 1 ) & + ( 1. - zed_upwind ) * gradpar ( iz )) * mu_dbdzed_m end if gext ( idx , ivmu ) = - fac0 if ( idx > 1 ) gext ( idx - 1 , ivmu ) = fac1 ! zonal mode BC is periodic instead of zero, so must ! treat specially if ( periodic ( iky )) then if ( idx == 1 ) then gext ( nz_ext , ivmu ) = - fac0 gext ( nz_ext - 1 , ivmu ) = fac1 else if ( idx == 2 ) then gext ( nz_ext , ivmu ) = fac1 end if end if end if ! hack for now (duplicates much of the effort from sweep_zed_zonal) if ( periodic ( iky )) then call sweep_zed_zonal_response ( iv , is , stream_sign ( iv ), gext (:, ivmu )) else ! invert parallel streaming equation to get g&#94;{n+1} on extended zed grid ! (I + (1+alph)/2*dt*vpa)*g_{inh}&#94;{n+1} = RHS = gext call stream_tridiagonal_solve ( iky , ie , iv , is , gext (:, ivmu )) end if end do end if ! we now have g on the extended zed domain at this ky and set of connected kx values ! corresponding to a unit impulse in phi at this location ! now integrate over velocities to get a square response matrix ! (this ends the parallelization over velocity space, so every core should have a !  copy of phiext) call integrate_over_velocity ( gext , phiext , iky , ie ) #if !defined ISO_C_BINDING || !defined MPI response_matrix ( iky )% eigen ( ie )% zloc (:, idx ) = phiext (: nresponse ) #else if ( sgproc0 ) response_matrix ( iky )% eigen ( ie )% zloc (:, idx ) = phiext (: nresponse ) #endif end subroutine get_dgdphi_matrix_column ! subroutine get_phi_matrix ! end subroutine get_phi_matrix subroutine sweep_zed_zonal_response ( iv , is , sgn , g ) use zgrid , only : nzgrid , delzed , nztot use run_parameters , only : zed_upwind , time_upwind use parallel_streaming , only : stream_c implicit none integer , intent ( in ) :: iv , is , sgn complex , dimension (:), intent ( in out ) :: g integer :: iz , iz1 , iz2 real :: fac1 , fac2 complex , dimension (:), allocatable :: gcf , gpi allocate ( gpi ( - nzgrid : nzgrid )) allocate ( gcf ( - nzgrid : nzgrid )) ! ky=0 is 2pi periodic (no extended zgrid) ! decompose into complementary function + particular integral ! zero BC for particular integral ! unit BC for complementary function (no source) if ( sgn < 0 ) then iz1 = - nzgrid ; iz2 = nzgrid else iz1 = nzgrid ; iz2 = - nzgrid end if gpi ( iz1 ) = 0. ; gcf ( iz1 ) = 1. do iz = iz1 - sgn , iz2 , - sgn fac1 = 1.0 + zed_upwind + sgn * ( 1.0 + time_upwind ) * stream_c ( iz , iv , is ) / delzed ( 0 ) fac2 = 1.0 - zed_upwind - sgn * ( 1.0 + time_upwind ) * stream_c ( iz , iv , is ) / delzed ( 0 ) gpi ( iz ) = ( - gpi ( iz + sgn ) * fac2 + 2.0 * g ( iz + nzgrid + 1 )) / fac1 gcf ( iz ) = - gcf ( iz + sgn ) * fac2 / fac1 end do ! g = g_PI + (g_PI(pi)/(1-g_CF(pi))) * g_CF g = gpi + ( spread ( gpi ( iz2 ), 1 , nztot ) / ( 1. - gcf ( iz2 ))) * gcf deallocate ( gpi , gcf ) end subroutine sweep_zed_zonal_response subroutine integrate_over_velocity ( g , phi , iky , ie ) use stella_layouts , only : vmu_lo use species , only : nspec , spec use extended_zgrid , only : iz_low , iz_up use extended_zgrid , only : ikxmod use extended_zgrid , only : nsegments use vpamu_grids , only : integrate_species use gyro_averages , only : gyro_average use mp , only : sum_allreduce implicit none complex , dimension (:, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:), intent ( out ) :: phi integer , intent ( in ) :: iky , ie integer :: idx , iseg , ikx , iz , ia integer :: izl_offset real , dimension ( nspec ) :: wgt complex , dimension (:), allocatable :: g0 ia = 1 allocate ( g0 ( vmu_lo % llim_proc : vmu_lo % ulim_alloc )) wgt = spec % z * spec % dens_psi0 phi = 0. idx = 0 ; izl_offset = 0 iseg = 1 ikx = ikxmod ( iseg , ie , iky ) do iz = iz_low ( iseg ), iz_up ( iseg ) idx = idx + 1 call gyro_average ( g ( idx , :), iky , ikx , iz , g0 ) call integrate_species ( g0 , iz , wgt , phi ( idx ), reduce_in = . false .) end do izl_offset = 1 if ( nsegments ( ie , iky ) > 1 ) then do iseg = 2 , nsegments ( ie , iky ) ikx = ikxmod ( iseg , ie , iky ) do iz = iz_low ( iseg ) + izl_offset , iz_up ( iseg ) idx = idx + 1 call gyro_average ( g ( idx , :), iky , ikx , iz , g0 ) call integrate_species ( g0 , iz , wgt , phi ( idx ), reduce_in = . false .) end do if ( izl_offset == 0 ) izl_offset = 1 end do end if call sum_allreduce ( phi ) end subroutine integrate_over_velocity subroutine get_fields_for_response_matrix ( phi , iky , ie ) use stella_layouts , only : vmu_lo use species , only : spec use species , only : has_electron_species use stella_geometry , only : dl_over_b use extended_zgrid , only : iz_low , iz_up use extended_zgrid , only : ikxmod use extended_zgrid , only : nsegments use kt_grids , only : zonal_mode , akx use fields_arrays , only : gamtot , gamtot3 use physics_flags , only : adiabatic_option_switch use physics_flags , only : adiabatic_option_fieldlineavg implicit none complex , dimension (:), intent ( inout ) :: phi integer , intent ( in ) :: iky , ie integer :: idx , iseg , ikx , iz , ia integer :: izl_offset complex , dimension (:), allocatable :: g0 complex :: tmp ia = 1 allocate ( g0 ( vmu_lo % llim_proc : vmu_lo % ulim_alloc )) idx = 0 ; izl_offset = 0 iseg = 1 ikx = ikxmod ( iseg , ie , iky ) if ( zonal_mode ( iky ) . and . abs ( akx ( ikx )) < epsilon ( 0. )) then phi (:) = 0.0 return end if do iz = iz_low ( iseg ), iz_up ( iseg ) idx = idx + 1 phi ( idx ) = phi ( idx ) / gamtot ( iky , ikx , iz ) end do izl_offset = 1 if ( nsegments ( ie , iky ) > 1 ) then do iseg = 2 , nsegments ( ie , iky ) ikx = ikxmod ( iseg , ie , iky ) do iz = iz_low ( iseg ) + izl_offset , iz_up ( iseg ) idx = idx + 1 phi ( idx ) = phi ( idx ) / gamtot ( iky , ikx , iz ) end do if ( izl_offset == 0 ) izl_offset = 1 end do end if if (. not . has_electron_species ( spec ) . and . & adiabatic_option_switch == adiabatic_option_fieldlineavg ) then if ( zonal_mode ( iky )) then ! no connections for ky = 0 iseg = 1 tmp = sum ( dl_over_b ( ia , :) * phi ) phi = phi + tmp * gamtot3 ( ikxmod ( 1 , ie , iky ), :) end if end if deallocate ( g0 ) end subroutine get_fields_for_response_matrix subroutine finish_response_matrix use fields_arrays , only : response_matrix #if !defined ISO_C_BINDING implicit none #else use mpi implicit none integer :: ierr if ( window /= MPI_WIN_NULL ) call mpi_win_free ( window , ierr ) #endif if ( allocated ( response_matrix )) deallocate ( response_matrix ) response_matrix_initialized = . false . end subroutine finish_response_matrix #ifdef MPI !----------------------------------------------------------! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! ! !!!!!!!!!!!!!!PARALLEL LU DECOMPOSITIONS!!!!!!!!!!!!!!!! ! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !----------------------------------------------------------! #ifdef ISO_C_BINDING !this subroutine parallelizes the LU decomposition on a single !node using MPIs shared memory interface !It also splits up jtwist the independent matrices across nodes !Ideal speed up: cores_per_node*min(jtwist,ncores) subroutine parallel_LU_decomposition_local ( iky ) use , intrinsic :: iso_c_binding , only : c_ptr , c_f_pointer use fields_arrays , only : response_matrix use mp , only : barrier , broadcast , sum_allreduce use mp , only : mp_comm , scope , allprocs , sharedprocs , curr_focus use mp , only : scrossdomprocs , sgproc0 , mp_abort , real_size use mp , only : job , iproc , proc0 , nproc , numnodes , inode use mp_lu_decomposition , only : lu_decomposition_local use job_manage , only : njobs use extended_zgrid , only : neigen use mpi implicit none integer , intent ( in ) :: iky integer , dimension (:, :), allocatable :: eig_limits integer , dimension (:), allocatable :: job_list integer , dimension (:), allocatable :: row_limits logical , dimension (:, :), allocatable :: node_jobs complex , dimension (:, :), pointer :: lu type ( c_ptr ) :: bptr logical :: needs_send = . false . integer :: prior_focus , nodes_on_job integer :: ijob , j , ie , n , ediv , emod integer :: jroot , neig , ierr , win , nroot integer ( kind = MPI_ADDRESS_KIND ) :: win_size integer :: disp_unit = 1 real :: dmax prior_focus = curr_focus call scope ( sharedprocs ) allocate ( node_jobs ( numnodes , njobs )); node_jobs = . false . allocate ( job_list ( nproc )); job_list = 0 allocate ( row_limits ( 0 : nproc )) allocate ( eig_limits ( 0 : numnodes , njobs )); eig_limits = 0 job_list ( iproc + 1 ) = job call sum_allreduce ( job_list ) if ( proc0 ) then do j = 1 , nproc node_jobs ( inode + 1 , job_list ( j ) + 1 ) = . true . !create a map of which nodes have which jobs end do end if !make sure all processors have this map call scope ( allprocs ) call mpi_allreduce & ( MPI_IN_PLACE , node_jobs , size ( node_jobs ), MPI_LOGICAL , MPI_LOR , mp_comm , ierr ) call scope ( sharedprocs ) do ijob = 0 , njobs - 1 jroot = - 1 do j = 1 , nproc if ( job_list ( j ) == ijob ) then jroot = j - 1 !the first processor on this job will be the root process exit end if end do if ( jroot == - 1 ) cycle !no processors on this node are on this job if ( iproc == jroot ) neig = neigen ( iky ) ! broadcast number of matrices call broadcast ( neig , jroot ) ! split up neig across nodes that have the current job nodes_on_job = count ( node_jobs (:, ijob + 1 )) ediv = neig / nodes_on_job emod = mod ( neig , nodes_on_job ) eig_limits ( 0 , ijob + 1 ) = 1 do j = 1 , numnodes if ( node_jobs ( j , ijob + 1 )) then eig_limits ( j , ijob + 1 ) = eig_limits ( j - 1 , ijob + 1 ) + ediv if ( emod > 0 ) then eig_limits ( j , ijob + 1 ) = eig_limits ( j , ijob + 1 ) + 1 emod = emod - 1 end if else eig_limits ( j , ijob + 1 ) = eig_limits ( j - 1 , ijob + 1 ) end if end do do ie = eig_limits ( inode , ijob + 1 ), eig_limits ( inode + 1 , ijob + 1 ) - 1 win_size = 0 if ( iproc == jroot ) then needs_send = . true . n = size ( response_matrix ( iky )% eigen ( ie )% idx ) win_size = int ( n * n , MPI_ADDRESS_KIND ) * 2 * real_size !complex size end if !broadcast size of matrix call broadcast ( n , jroot ) !allocate the window call mpi_win_allocate_shared ( win_size , disp_unit , MPI_INFO_NULL , mp_comm , bptr , win , ierr ) if ( iproc /= jroot ) then !make sure all the procs have the right memory address call mpi_win_shared_query ( win , jroot , win_size , disp_unit , bptr , ierr ) end if ! bind this c_ptr to our fortran matrix call c_f_pointer ( bptr , lu , ( / n , n / )) !load the matrix if ( iproc == jroot ) lu = response_matrix ( iky )% eigen ( ie )% zloc !syncronize the processors call mpi_win_fence ( 0 , win , ierr ) ! All the processors have the matrix. ! Now perform LU decomposition call lu_decomposition_local ( mp_comm , jroot , win , lu , & response_matrix ( iky )% eigen ( ie )% idx , dmax ) !copy the decomposed matrix over if ( iproc == jroot ) response_matrix ( iky )% eigen ( ie )% zloc = lu call mpi_win_free ( win , ierr ) end do end do call scope ( scrossdomprocs ) !copy all the matrices across all nodes if ( sgproc0 ) then do ie = 1 , neigen ( iky ) nroot = 0 if ( needs_send . and . & ( ie >= eig_limits ( inode , job + 1 ) . and . ie < eig_limits ( inode + 1 , job + 1 ))) nroot = iproc !first let processors know who is sending the data call sum_allreduce ( nroot ) !now send the data call broadcast ( response_matrix ( iky )% eigen ( ie )% zloc , nroot ) call broadcast ( response_matrix ( iky )% eigen ( ie )% idx , nroot ) end do end if call scope ( prior_focus ) deallocate ( node_jobs , job_list , row_limits , eig_limits ) end subroutine parallel_LU_decomposition_local #endif /* ISO_C_BINDING */ !this subroutine parallelizes the LU decomposition across !all cores. Ideal speed up: ncores subroutine parallel_LU_decomposition_global ( iky ) use fields_arrays , only : response_matrix use mp , only : barrier , broadcast , sum_allreduce use mp , only : mp_comm , scope , allprocs , sharedprocs , curr_focus use mp , only : job , iproc , proc0 , nproc , mpicmplx #ifdef ISO_C_BINDING use mp , only : sgproc0 , scrossdomprocs #endif use job_manage , only : njobs use extended_zgrid , only : neigen use mpi use linear_solve , only : imaxloc implicit none integer , intent ( in ) :: iky integer , dimension (:), allocatable :: job_roots , eig_roots integer , dimension (:), allocatable :: row_limits , eig_limits integer , dimension ( MPI_STATUS_SIZE ) :: status real , parameter :: zero = 1.0e-20 integer , dimension (:), allocatable :: idx complex , dimension (:, :), allocatable :: lu real , dimension (:), allocatable :: vv complex , dimension (:), allocatable :: dum integer :: sproc logical :: sproc0 integer :: eig_comm , ceig_comm !c for 'cross' integer :: ieig_core , ceig_core , eig_cores integer :: ncomm integer :: prior_focus integer :: ie , ie_hi , r_lo , r_hi integer :: ijob , i , j , k , n , n_send , rsize integer :: imax , neig , ierr integer :: istage , nstage integer :: rdiv , rmod integer :: ediv , emod real :: dmax , tmp prior_focus = curr_focus sproc = iproc sproc0 = proc0 call scope ( allprocs ) allocate ( job_roots ( 0 : njobs - 1 )); job_roots = 0 if ( sproc0 ) job_roots ( job ) = iproc call sum_allreduce ( job_roots ) do ijob = 0 , njobs - 1 if ( job == ijob . and . sproc0 ) then neig = neigen ( iky ) end if ! broadcast number of matrices for this job call broadcast ( neig , job_roots ( ijob )) !set up communicator for cores working on a single matrix call mpi_comm_split ( mp_comm , mod ( iproc , neig ), iproc , eig_comm , ierr ) call mpi_comm_size ( eig_comm , eig_cores , ierr ) call mpi_comm_rank ( eig_comm , ieig_core , ierr ) !set up a communicator that crosses the previous one call mpi_comm_split ( mp_comm , ieig_core , iproc , ceig_comm , ierr ) call mpi_comm_rank ( ceig_comm , ceig_core , ierr ) call mpi_bcast ( ceig_core , 1 , MPI_INT , 0 , eig_comm , ierr ) ncomm = min ( neig , nproc ) !number of communicators allocate ( eig_roots ( 0 : ncomm - 1 )); eig_roots = 0 allocate ( eig_limits ( 0 : ncomm )) allocate ( row_limits ( 0 : eig_cores )) if ( ieig_core == 0 ) eig_roots ( ceig_core ) = iproc call sum_allreduce ( eig_roots ) ! split up neigen across cores ediv = neig / ncomm emod = mod ( neig , ncomm ) !how many stages will the LU decomposition take? nstage = ediv if ( emod > 0 ) nstage = nstage + 1 !determine which parts of neigen this communicator processes eig_limits ( 0 ) = 1 do j = 1 , ncomm eig_limits ( j ) = eig_limits ( j - 1 ) + ediv if ( j <= emod ) then eig_limits ( j ) = eig_limits ( j ) + 1 end if end do do istage = 0 , nstage - 1 !transfer the data from job root to root of subcommunicator do j = 0 , ncomm - 1 ie = eig_limits ( j ) + istage ie_hi = eig_limits ( j + 1 ) - 1 if ( ie > ie_hi ) cycle if ( iproc == job_roots ( ijob ) . and . iproc == eig_roots ( j )) then !no need for data transfer n = size ( response_matrix ( iky )% eigen ( ie )% idx ) allocate ( lu ( n , n )) lu = response_matrix ( iky )% eigen ( ie )% zloc else if ( iproc == job_roots ( ijob )) then !send data to subroots !send size of matrix n_send = size ( response_matrix ( iky )% eigen ( ie )% idx ) call mpi_send ( n_send , 1 , MPI_INT , eig_roots ( j ), j , mp_comm , ierr ) !send matrix call mpi_send ( response_matrix ( iky )% eigen ( ie )% zloc , & n_send * n_send , mpicmplx , eig_roots ( j ), nproc + j , mp_comm , ierr ) else if ( iproc == eig_roots ( j )) then !subroot gets the data !receive size of matrix call mpi_recv ( n , 1 , MPI_INT , job_roots ( ijob ), j , mp_comm , status , ierr ) allocate ( lu ( n , n )) !receive matrix call mpi_recv ( lu , n * n , mpicmplx , job_roots ( ijob ), nproc + j , mp_comm , status , ierr ) end if end do if ( istage >= ( eig_limits ( ceig_core + 1 ) - eig_limits ( ceig_core ))) cycle !nothing for this communicator to do !broadcast matrix and its size across the communicator call mpi_bcast ( n , 1 , MPI_INT , 0 , eig_comm , ierr ) if (. not . allocated ( lu )) allocate ( lu ( n , n )) if (. not . allocated ( vv )) allocate ( vv ( n )) call mpi_bcast ( lu , n * n , mpicmplx , 0 , eig_comm , ierr ) allocate ( dum ( n )) allocate ( idx ( n )) ! All the processors have the matrix. ! Now perform LU decomposition vv = maxval ( cabs ( lu ), dim = 2 ) if ( any ( vv == 0.0 )) & write ( * , * ) 'singular matrix in lu_decomposition on job ' , job , ', process ' , iproc vv = 1.0 / vv do j = 1 , n !divide up the work using row_limits rdiv = ( n - j ) / eig_cores rmod = mod ( n - j , eig_cores ) row_limits ( 0 ) = j + 1 if ( rdiv == 0 ) then row_limits ( rmod + 1 :) = - 1 do k = 1 , rmod row_limits ( k ) = row_limits ( k - 1 ) + 1 end do else do k = 1 , eig_cores row_limits ( k ) = row_limits ( k - 1 ) + rdiv if ( k <= rmod ) row_limits ( k ) = row_limits ( k ) + 1 end do end if !pivot if needed dmax = - 1.0 do k = j , n tmp = vv ( k ) * abs ( lu ( k , j )) if ( tmp > dmax ) then dmax = tmp imax = k end if end do !         imax = (j-1) + imaxloc(vv(j:n)*cabs(lu(j:n,j))) if ( j /= imax ) then dum = lu ( imax , :) lu ( imax , :) = lu ( j , :) lu ( j , :) = dum vv ( imax ) = vv ( j ) end if if ( ieig_core == 0 ) idx ( j ) = imax !get the lead multiplier if ( lu ( j , j ) == 0.0 ) lu ( j , j ) = zero do i = j + 1 , n lu ( i , j ) = lu ( i , j ) / lu ( j , j ) end do r_lo = row_limits ( ieig_core ) r_hi = row_limits ( ieig_core + 1 ) - 1 do k = r_lo , r_hi do i = j + 1 , n lu ( i , k ) = lu ( i , k ) - lu ( i , j ) * lu ( j , k ) end do end do do i = 0 , eig_cores - 1 r_lo = row_limits ( i ) r_hi = row_limits ( i + 1 ) - 1 rsize = ( r_hi - r_lo + 1 ) * ( n - j ) if ( r_lo > r_hi ) cycle !call mpi_bcast(lu(j+1:n,r_lo:r_hi),rsize,mpicmplx,i,eig_comm,ierr) do k = r_lo , r_hi call mpi_bcast ( lu ( j + 1 : n , k ), n - j , mpicmplx , i , eig_comm , ierr ) end do end do end do !LU decomposition ends here !copy the decomposed matrix over do j = 0 , ncomm - 1 ie = eig_limits ( j ) + istage ie_hi = eig_limits ( j + 1 ) - 1 if ( ie > ie_hi ) cycle if ( iproc == job_roots ( ijob ) . and . iproc == eig_roots ( j )) then !no need for data transfer response_matrix ( iky )% eigen ( ie )% zloc = lu response_matrix ( iky )% eigen ( ie )% idx = idx else if ( iproc == eig_roots ( j )) then !subroot sends the data !send indices call mpi_send ( idx , n , MPI_INT , job_roots ( ijob ), j , mp_comm , ierr ) !send matrix call mpi_send ( lu , n * n , mpicmplx , job_roots ( ijob ), nproc + j , mp_comm , ierr ) else if ( iproc == job_roots ( ijob )) then !receive data from subroot !receive indices call mpi_recv ( response_matrix ( iky )% eigen ( ie )% idx , & n , MPI_INT , eig_roots ( j ), j , mp_comm , status , ierr ) !receive matrix call mpi_recv ( response_matrix ( iky )% eigen ( ie )% zloc , & n * n , mpicmplx , eig_roots ( j ), nproc + j , mp_comm , status , ierr ) end if end do deallocate ( vv , lu , idx , dum ) end do deallocate ( eig_roots , eig_limits , row_limits ) end do #ifdef ISO_C_BINDING if ( sgproc0 ) then call scope ( scrossdomprocs ) !copy all the matrices across all nodes do ie = 1 , neigen ( iky ) call broadcast ( response_matrix ( iky )% eigen ( ie )% zloc ) call broadcast ( response_matrix ( iky )% eigen ( ie )% idx ) end do end if call scope ( prior_focus ) #else call scope ( prior_focus ) !copy all the matrices across all nodes do ie = 1 , neigen ( iky ) call broadcast ( response_matrix ( iky )% eigen ( ie )% zloc ) call broadcast ( response_matrix ( iky )% eigen ( ie )% idx ) end do #endif deallocate ( job_roots ) end subroutine parallel_LU_decomposition_global #endif /* MPI */ end module response_matrix","tags":"","loc":"sourcefile/response_matrix.fpp.html"},{"title":"zgrid.f90 â€“ stella","text":"Contents Modules zgrid Source Code zgrid.f90 Source Code module zgrid implicit none public :: init_zgrid , finish_zgrid public :: nzed , nzgrid , nperiod , ntubes public :: nztot , nz2pi public :: zed public :: delzed public :: zed_equal_arc public :: get_total_arc_length public :: get_arc_length_grid public :: shat_zero public :: grad_x_grad_y_zero public :: twist_shift_option_switch public :: twist_shift_option_std public :: twist_shift_option_stellarator public :: twist_shift_option_periodic public :: boundary_option_switch public :: boundary_option_zero public :: boundary_option_self_periodic public :: boundary_option_linked private integer :: nzed , nzgrid , nztot , nz2pi integer :: nperiod , ntubes logical :: zed_equal_arc real :: shat_zero , grad_x_grad_y_zero real , dimension (:), allocatable :: zed , delzed integer :: boundary_option_switch integer , parameter :: boundary_option_zero = 1 , & boundary_option_self_periodic = 2 , & boundary_option_linked = 3 integer :: twist_shift_option_switch integer , parameter :: twist_shift_option_std = 1 , & twist_shift_option_stellarator = 2 , & twist_shift_option_periodic = 3 logical :: zgridinit = . false . contains subroutine init_zgrid use mp , only : proc0 use constants , only : pi implicit none integer :: i if ( zgridinit ) return zgridinit = . true . if ( proc0 ) then call read_parameters end if call broadcast_parameters if (. not . allocated ( zed )) allocate ( zed ( - nzgrid : nzgrid )) if (. not . allocated ( delzed )) allocate ( delzed ( - nzgrid : nzgrid )) zed = ( / ( i * pi / real ( nzed / 2 ), i =- nzgrid , nzgrid ) / ) delzed (: nzgrid - 1 ) = zed ( - nzgrid + 1 :) - zed (: nzgrid - 1 ) delzed ( nzgrid ) = delzed ( - nzgrid ) nztot = 2 * nzgrid + 1 ! number of zed in a 2*pi segment, including points at +/- pi nz2pi = 2 * ( nzed / 2 ) + 1 end subroutine init_zgrid subroutine read_parameters use file_utils , only : input_unit_exist , error_unit use text_options , only : text_option , get_option_value use physics_flags , only : full_flux_surface implicit none integer :: in_file , ierr logical :: exist type ( text_option ), dimension ( 6 ), parameter :: boundaryopts = & ( / text_option ( 'default' , boundary_option_zero ), & text_option ( 'zero' , boundary_option_zero ), & text_option ( 'unconnected' , boundary_option_zero ), & text_option ( 'self-periodic' , boundary_option_self_periodic ), & text_option ( 'periodic' , boundary_option_self_periodic ), & text_option ( 'linked' , boundary_option_linked ) / ) character ( 20 ) :: boundary_option type ( text_option ), dimension ( 3 ), parameter :: twistshiftopts = & ( / text_option ( 'standard' , twist_shift_option_std ), & text_option ( 'stellarator' , twist_shift_option_stellarator ), & text_option ( 'periodic' , twist_shift_option_periodic ) / ) character ( 20 ) :: twist_shift_option namelist / zgrid_parameters / nzed , nperiod , ntubes , & shat_zero , boundary_option , zed_equal_arc , & boundary_option , zed_equal_arc , grad_x_grad_y_zero , twist_shift_option nzed = 24 nperiod = 1 ntubes = 1 boundary_option = 'default' twist_shift_option = 'standard' ! if zed_equal_arc = T, then zed is chosen to be arc length ! if zed_equal_arc = F, then zed is poloidal (axisymmetric) ! or zeta (toroidal) angle zed_equal_arc = . false . ! set minimum shat value below which we assume ! periodic BC shat_zero = 1.e-5 ! set the minimum nabla x . nabla value at the end of the FT which we assume ! periodic BC instead of the stellarator symmetric ones grad_x_grad_y_zero = 1.e-5 in_file = input_unit_exist ( \"zgrid_parameters\" , exist ) if ( exist ) read ( unit = in_file , nml = zgrid_parameters ) ierr = error_unit () call get_option_value & ( boundary_option , boundaryopts , boundary_option_switch , & ierr , \"boundary_option in dist_fn_knobs\" ) call get_option_value & ( twist_shift_option , twistshiftopts , twist_shift_option_switch , & ierr , \"twist_shift_option in dist_fn_knobs\" ) ! note that boundary_option may be changed to self-periodic later ! if magnetic shear or nabla x \\cdot nabla y is smaller than shat_zero or grad_x_grad_y_zero ! cannot do this here as these quantities have yet to be input nzgrid = nzed / 2 + ( nperiod - 1 ) * nzed ! force use of equal arc grid to ensure gradpar alpha-independent ! necessary to obtain efficient numerical solution of parallel streaming if ( full_flux_surface ) zed_equal_arc = . true . end subroutine read_parameters subroutine broadcast_parameters use mp , only : broadcast implicit none call broadcast ( nzed ) call broadcast ( nzgrid ) call broadcast ( nperiod ) call broadcast ( ntubes ) call broadcast ( zed_equal_arc ) call broadcast ( shat_zero ) call broadcast ( boundary_option_switch ) call broadcast ( twist_shift_option_switch ) call broadcast ( grad_x_grad_y_zero ) end subroutine broadcast_parameters subroutine finish_zgrid implicit none if ( allocated ( zed )) deallocate ( zed ) if ( allocated ( delzed )) deallocate ( delzed ) zgridinit = . false . end subroutine finish_zgrid subroutine get_total_arc_length ( nz , gp , dz , length ) implicit none integer , intent ( in ) :: nz real , dimension ( - nz :), intent ( in ) :: gp real , intent ( in ) :: dz real , intent ( out ) :: length call integrate_zed ( nz , dz , 1. / gp , length ) end subroutine get_total_arc_length subroutine get_arc_length_grid ( nz_max , nzext_max , zboundary , gp , dz , zarc ) implicit none integer , intent ( in ) :: nz_max , nzext_max real , intent ( in ) :: zboundary real , dimension ( - nzext_max :), intent ( in ) :: gp real , intent ( in ) :: dz real , dimension ( - nzext_max :), intent ( out ) :: zarc integer :: iz zarc ( - nz_max ) = zboundary if ( nz_max /= nzext_max ) then do iz = - nzext_max , - nz_max - 1 call integrate_zed ( nzext_max , dz , 1. / gp ( iz : - nz_max ), zarc ( iz )) zarc ( iz ) = zarc ( - nz_max ) - zarc ( iz ) end do end if ! this seems very inefficient -- could just add incremental change at each zed, ! rather than recomputing from the boundary each time do iz = - nz_max + 1 , nzext_max call integrate_zed ( nz_max , dz , 1. / gp ( - nz_max : iz ), zarc ( iz )) zarc ( iz ) = zarc ( - nz_max ) + zarc ( iz ) end do end subroutine get_arc_length_grid ! trapezoidal rule to integrate in zed subroutine integrate_zed ( nz , dz , f , intf ) implicit none integer , intent ( in ) :: nz real , intent ( in ) :: dz real , dimension ( - nz :), intent ( in ) :: f real , intent ( out ) :: intf integer :: iz , iz_max iz_max = - nz + size ( f ) - 1 intf = 0. do iz = - nz + 1 , iz_max intf = intf + dz * ( f ( iz - 1 ) + f ( iz )) end do intf = 0.5 * intf end subroutine integrate_zed end module zgrid","tags":"","loc":"sourcefile/zgrid.f90.html"},{"title":"stella_diagnostics.f90 â€“ stella","text":"Contents Modules stella_diagnostics Source Code stella_diagnostics.f90 Source Code !> Routines for calculating and writing various physical diagnostics module stella_diagnostics implicit none public :: init_stella_diagnostics , finish_stella_diagnostics public :: diagnose_stella public :: nsave private integer :: ntg_out integer :: nwrite , nsave , navg , nc_mult integer :: stdout_unit , fluxes_unit , omega_unit logical :: save_for_restart logical :: write_omega logical :: write_moments logical :: write_phi_vs_time logical :: write_gvmus logical :: write_gzvs logical :: write_kspectra logical :: write_radial_fluxes logical :: write_radial_moments logical :: write_fluxes_kxkyz logical :: flux_norm !> Arrays needed for averaging in x,y,z real , dimension (:), allocatable :: pflux_avg , vflux_avg , qflux_avg , heat_avg real , dimension (:, :, :), allocatable :: pflux , vflux , qflux , exchange !> Needed for calculating growth rates and frequencies complex , dimension (:, :, :), allocatable :: omega_vs_time !> Current maximum index of the time dimension in the netCDF file integer :: nout = 1 !> Has this module been initialised? logical :: diagnostics_initialized = . false . !> Debugging logical :: debug = . false . contains !> Initialise the [[stella_diagnostics]] module !> !> Broadcast the parameters from the namelist \"stella_diagnostics_knobs\" !> and open/append the netcdf file and the ascii files. subroutine init_stella_diagnostics ( restart , tstart ) use zgrid , only : init_zgrid use kt_grids , only : init_kt_grids use physics_parameters , only : init_physics_parameters use run_parameters , only : init_run_parameters use species , only : init_species use dist_fn , only : init_dist_fn use init_g , only : init_init_g use stella_io , only : init_stella_io , get_nout use mp , only : broadcast , proc0 implicit none !> Has this simulation been restarted? logical , intent ( in ) :: restart !> Current simulation time real , intent ( in ) :: tstart ! Only initialize the diagnostics once if ( diagnostics_initialized ) return diagnostics_initialized = . true . ! Only debug on the first processor debug = debug . and . proc0 !> Make sure the other routines are intialized call init_zgrid call init_physics_parameters call init_kt_grids call init_run_parameters call init_species call init_init_g call init_dist_fn !> Read the namelist \"stella_diagnostics_knobs\" in the input file call read_parameters call allocate_arrays !> Broadcast the variables to all processors call broadcast ( nwrite ) call broadcast ( navg ) call broadcast ( nsave ) call broadcast ( nc_mult ) call broadcast ( save_for_restart ) call broadcast ( write_omega ) call broadcast ( write_kspectra ) call broadcast ( write_moments ) call broadcast ( write_phi_vs_time ) call broadcast ( write_gvmus ) call broadcast ( write_gzvs ) call broadcast ( write_radial_fluxes ) call broadcast ( write_radial_moments ) call broadcast ( write_fluxes_kxkyz ) call broadcast ( flux_norm ) !> Initiate the netcdf file with extension '.out.nc' call init_stella_io ( restart , write_phi_vs_time , write_kspectra , & write_gvmus , write_gzvs , write_moments , write_omega , & write_radial_fluxes , write_radial_moments , write_fluxes_kxkyz ) !> Open the '.out', '.fluxes' and '.omega' file if ( proc0 ) call open_loop_ascii_files ( restart ) !> Get the final position [[nout]] of the time axis in the netcdf file if ( proc0 ) call get_nout ( tstart , nout ) call broadcast ( nout ) end subroutine init_stella_diagnostics !> Read the diagnostic input parameters from the input file !> !> Namelist: `stella_diagnostics_knobs` subroutine read_parameters use mp , only : proc0 use file_utils , only : input_unit_exist use zgrid , only : nperiod , nzed use physics_flags , only : radial_variation implicit none logical :: exist integer :: in_file namelist / stella_diagnostics_knobs / nwrite , navg , nsave , & save_for_restart , write_phi_vs_time , write_gvmus , write_gzvs , & write_omega , write_kspectra , write_moments , write_radial_fluxes , & write_radial_moments , write_fluxes_kxkyz , flux_norm , nc_mult if ( proc0 ) then nwrite = 50 navg = 50 nsave = - 1 save_for_restart = . false . write_omega = . false . write_phi_vs_time = . false . write_gvmus = . false . write_gzvs = . false . write_kspectra = . false . write_moments = . false . write_radial_fluxes = radial_variation write_radial_moments = radial_variation write_fluxes_kxkyz = . false . nc_mult = 1 flux_norm = . true . in_file = input_unit_exist ( \"stella_diagnostics_knobs\" , exist ) if ( exist ) read ( unit = in_file , nml = stella_diagnostics_knobs ) if (. not . save_for_restart ) nsave = - 1 end if ntg_out = nzed / 2 + ( nperiod - 1 ) * nzed end subroutine read_parameters !> Allocate the module-level arrays subroutine allocate_arrays use species , only : nspec use kt_grids , only : nakx , naky implicit none if (. not . allocated ( pflux )) allocate ( pflux ( nakx , naky , nspec )); pflux = 0. if (. not . allocated ( qflux )) allocate ( qflux ( nakx , naky , nspec )); qflux = 0. if (. not . allocated ( vflux )) allocate ( vflux ( nakx , naky , nspec )); vflux = 0. if (. not . allocated ( exchange )) allocate ( exchange ( nakx , naky , nspec )); exchange = 0. if (. not . allocated ( pflux_avg )) allocate ( pflux_avg ( nspec )); pflux_avg = 0. if (. not . allocated ( qflux_avg )) allocate ( qflux_avg ( nspec )); qflux_avg = 0. if (. not . allocated ( vflux_avg )) allocate ( vflux_avg ( nspec )); vflux_avg = 0. if (. not . allocated ( heat_avg )) allocate ( heat_avg ( nspec )); heat_avg = 0. if (. not . allocated ( omega_vs_time )) then if ( write_omega ) then allocate ( omega_vs_time ( navg , naky , nakx )) omega_vs_time = 0. else allocate ( omega_vs_time ( 1 , 1 , 1 )) navg = 1 end if end if end subroutine allocate_arrays !> Open the '.out' and the '.fluxes' file. !> !> When running a new simulation, create a new file or replace an old file. !> When restarting a simulation, append the old files. subroutine open_loop_ascii_files ( restart ) use file_utils , only : open_output_file use species , only : nspec implicit none logical , intent ( in ) :: restart character ( 3 ) :: nspec_str character ( 100 ) :: str logical :: overwrite ! Do not overwrite, but append files, when we restart the simulation. overwrite = . not . restart ! Open the '.out' and the '.fluxes' files. call open_output_file ( stdout_unit , '.out' , overwrite ) call open_output_file ( fluxes_unit , '.fluxes' , overwrite ) ! Create the header for the .fluxes file. ! Every column is made up of 12 spaces, so make sure the headers ! are placed correctly since we have the following columns for nspec=3: ! #time pflx1 pflx2 pflx3 vflx1 vflx2 vflx32 qflx1 qflx2 qflx3 if (. not . restart ) then write ( nspec_str , '(i3)' ) nspec * 12 str = trim ( '(2a12,2a' // trim ( nspec_str ) // ')' ) write ( fluxes_unit , str ) '#time' , 'pflx' , 'vflx' , 'qflx' end if ! Open the '.omega' file and create its header. if ( write_omega ) then call open_output_file ( omega_unit , '.omega' , overwrite ) if (. not . restart ) then write ( omega_unit , '(7a12)' ) '#time' , 'ky' , 'kx' , & 'Re[om]' , 'Im[om]' , 'Re[omavg]' , 'Im[omavg]' end if end if end subroutine open_loop_ascii_files !> Close the text files opened by [[open_loop_ascii_files]] subroutine close_loop_ascii_files use file_utils , only : close_output_file implicit none call close_output_file ( stdout_unit ) call close_output_file ( fluxes_unit ) if ( write_omega ) call close_output_file ( omega_unit ) end subroutine close_loop_ascii_files !> Calculate and write diagnostics subroutine diagnose_stella ( istep ) use mp , only : proc0 use constants , only : zi use redistribute , only : scatter use fields_arrays , only : phi , apar use fields_arrays , only : phi_old , phi_corr_QN use fields , only : fields_updated , advance_fields use dist_fn_arrays , only : gvmu , gnew use g_tofrom_h , only : g_to_h use stella_io , only : write_time_nc use stella_io , only : write_phi2_nc use stella_io , only : write_phi_nc use stella_io , only : write_gvmus_nc use stella_io , only : write_gzvs_nc use stella_io , only : write_kspectra_nc use stella_io , only : write_moments_nc use stella_io , only : write_omega_nc use stella_io , only : write_radial_fluxes_nc use stella_io , only : write_radial_moments_nc use stella_io , only : write_fluxes_kxkyz_nc use stella_io , only : sync_nc use stella_time , only : code_time , code_dt use zgrid , only : nztot , nzgrid , ntubes use vpamu_grids , only : nmu , nvpa use species , only : nspec use kt_grids , only : naky , nakx , ikx_max , ny use dist_redistribute , only : kxkyz2vmu use physics_flags , only : radial_variation , full_flux_surface use volume_averages , only : volume_average , fieldline_average use run_parameters , only : fphi implicit none !> The current timestep integer , intent ( in ) :: istep real :: phi2 , apar2 real :: zero real , dimension (:, :, :), allocatable :: gvmus real , dimension (:, :, :, :), allocatable :: gzvs !    real, dimension (:,:,:), allocatable :: pflx_zvpa, vflx_zvpa, qflx_zvpa real , dimension (:), allocatable :: part_flux , mom_flux , heat_flux real , dimension (:, :), allocatable :: part_flux_x , mom_flux_x , heat_flux_x real , dimension (:, :), allocatable :: dens_x , upar_x , temp_x real , dimension (:, :), allocatable :: phi2_vs_kxky real , dimension (:, :, :, :, :), allocatable :: pflx_kxkyz , vflx_kxkyz , qflx_kxkyz complex , dimension (:, :, :, :, :), allocatable :: density , upar , temperature , spitzer2 complex , dimension (:, :), allocatable :: omega_avg complex , dimension (:, :), allocatable :: phiavg , phioldavg complex , dimension (:, :, :, :), allocatable :: phi_out !> needed when simulating a full flux surface complex , dimension (:, :, :, :), allocatable :: dens_ffs , upar_ffs , pres_ffs ! calculation of omega requires computation of omega more ! frequently than every nwrite time steps if ( write_omega . and . proc0 ) then zero = 10 0. * epsilon ( 0. ) if ( istep > 0 ) then allocate ( phiavg ( naky , nakx )) allocate ( phioldavg ( naky , nakx )) call fieldline_average ( phi , phiavg ) call fieldline_average ( phi_old , phioldavg ) where ( abs ( phiavg ) < zero . or . abs ( phioldavg ) < zero ) omega_vs_time ( mod ( istep , navg ) + 1 , :, :) = 0.0 elsewhere omega_vs_time ( mod ( istep , navg ) + 1 , :, :) = log ( phiavg / phioldavg ) * zi / code_dt end where deallocate ( phiavg , phioldavg ) end if end if !> only write data to file every nwrite time steps if ( mod ( istep , nwrite ) /= 0 ) return if ( radial_variation ) fields_updated = . false . !> get the updated fields corresponding to gnew call advance_fields ( gnew , phi , apar , dist = 'gbar' ) allocate ( phi_out ( naky , nakx , - nzgrid : nzgrid , ntubes )) phi_out = phi if ( radial_variation ) then phi_out = phi_out + phi_corr_QN end if allocate ( part_flux ( nspec )) allocate ( mom_flux ( nspec )) allocate ( heat_flux ( nspec )) allocate ( pflx_kxkyz ( naky , nakx , nztot , ntubes , nspec )) allocate ( vflx_kxkyz ( naky , nakx , nztot , ntubes , nspec )) allocate ( qflx_kxkyz ( naky , nakx , nztot , ntubes , nspec )) if ( write_radial_fluxes ) then allocate ( part_flux_x ( nakx , nspec )) allocate ( mom_flux_x ( nakx , nspec )) allocate ( heat_flux_x ( nakx , nspec )) end if if ( full_flux_surface ) then allocate ( dens_ffs ( ny , ikx_max , - nzgrid : nzgrid , nspec )) allocate ( upar_ffs ( ny , ikx_max , - nzgrid : nzgrid , nspec )) allocate ( pres_ffs ( ny , ikx_max , - nzgrid : nzgrid , nspec )) end if !> obtain turbulent fluxes if ( radial_variation . or . write_radial_fluxes ) then !     handle g_to_h in get_fluxes_vmulo to eliminate x&#94;2 terms !     call g_to_h (gnew, phi, fphi, phi_corr_QN) call get_fluxes_vmulo ( gnew , phi_out , part_flux , mom_flux , heat_flux , & part_flux_x , mom_flux_x , heat_flux_x ) !     call g_to_h (gnew, phi, -fphi, phi_corr_QN) else if ( full_flux_surface ) then !> calculate the particle density, parallel flow and pressure in (y,kx,z) space !> for all species call get_moments_ffs ( gnew , dens_ffs , upar_ffs , pres_ffs ) !> calculate the (ky,kx) contributions to the particle, parallel momentum and energy fluxes call get_fluxes_ffs ( dens_ffs , upar_ffs , pres_ffs , part_flux , mom_flux , heat_flux , & pflx_kxkyz , vflx_kxkyz , qflx_kxkyz ) else !> redistribute data so that data for each vpa and mu are guaranteed to be on each processor call scatter ( kxkyz2vmu , gnew , gvmu ) !> get_fluxes assumes the non-Boltzmann part of the distribution, h, is passed in; !> convert from <delta f> = g to h call g_to_h ( gvmu , phi , fphi ) !> compute the fluxes call get_fluxes ( gvmu , part_flux , mom_flux , heat_flux , & pflx_kxkyz , vflx_kxkyz , qflx_kxkyz ) !> convert back from h to g call g_to_h ( gvmu , phi , - fphi ) end if if ( proc0 ) then if ( write_omega ) then allocate ( omega_avg ( naky , nakx )) omega_avg = sum ( omega_vs_time , dim = 1 ) / real ( navg ) else allocate ( omega_avg ( 1 , 1 )) end if call volume_average ( phi_out , phi2 ) call volume_average ( apar , apar2 ) ! Print information to stella.out, the header is printed in stella.f90 write ( * , '(A2,I7,A2,ES12.4,A2,ES12.4,A2,ES12.4)' ) \" \" , istep , \" \" , code_time , \" \" , code_dt , \" \" , phi2 call write_loop_ascii_files ( istep , phi2 , apar2 , part_flux , mom_flux , heat_flux , & omega_vs_time ( mod ( istep , navg ) + 1 , :, :), omega_avg ) ! do not need omega_avg again this time step deallocate ( omega_avg ) end if if ( mod ( istep , nwrite * nc_mult ) == 0 ) then if ( proc0 ) then if ( debug ) write ( * , * ) 'stella_diagnostics::write_time_nc' call write_time_nc ( nout , code_time ) if ( write_omega ) call write_omega_nc ( nout , omega_vs_time ( mod ( istep , navg ) + 1 , :, :)) call write_phi2_nc ( nout , phi2 ) if ( write_phi_vs_time ) then if ( debug ) write ( * , * ) 'stella_diagnostics::diagnose_stella::write_phi_nc' call write_phi_nc ( nout , phi_out ) end if if ( write_kspectra ) then if ( debug ) write ( * , * ) 'stella_diagnostics::diagnose_stella::write_kspectra' allocate ( phi2_vs_kxky ( naky , nakx )) call fieldline_average ( real ( phi_out * conjg ( phi_out )), phi2_vs_kxky ) call write_kspectra_nc ( nout , phi2_vs_kxky ) deallocate ( phi2_vs_kxky ) end if if ( write_radial_fluxes ) then call write_radial_fluxes_nc ( nout , part_flux_x , mom_flux_x , heat_flux_x ) end if end if if ( write_moments . or . write_radial_moments ) then if ( debug ) write ( * , * ) 'stella_diagnostics::diagnose_stella::write_moments' allocate ( density ( naky , nakx , nztot , ntubes , nspec )) allocate ( upar ( naky , nakx , nztot , ntubes , nspec )) allocate ( temperature ( naky , nakx , nztot , ntubes , nspec )) allocate ( spitzer2 ( naky , nakx , nztot , ntubes , nspec )) if ( write_radial_moments ) then allocate ( dens_x ( nakx , nspec )) allocate ( upar_x ( nakx , nspec )) allocate ( temp_x ( nakx , nspec )) end if call get_moments ( gnew , density , upar , temperature , dens_x , upar_x , temp_x , spitzer2 ) if ( proc0 . and . write_moments ) call write_moments_nc ( nout , density , upar , temperature , spitzer2 ) if ( proc0 . and . write_radial_moments ) call write_radial_moments_nc ( nout , dens_x , upar_x , temp_x ) deallocate ( density , upar , temperature , spitzer2 ) if ( allocated ( dens_x )) deallocate ( dens_x ) if ( allocated ( upar_x )) deallocate ( upar_x ) if ( allocated ( temp_x )) deallocate ( temp_x ) end if if ( write_fluxes_kxkyz ) then if ( debug ) write ( * , * ) 'stella_diagnostics::diagnose_stella::write_fluxes_kxkyz' if ( proc0 ) call write_fluxes_kxkyz_nc ( nout , pflx_kxkyz , vflx_kxkyz , qflx_kxkyz ) end if if ( write_gvmus ) then allocate ( gvmus ( nvpa , nmu , nspec )) if ( debug ) write ( * , * ) 'stella_diagnostics::diagnose_stella::get_gvmus' ! note that gvmus is h at this point call get_gvmus ( gvmu , gvmus ) if ( debug ) write ( * , * ) 'stella_diagnostics::diagnose_stella::write_gvmus_nc' if ( proc0 ) call write_gvmus_nc ( nout , gvmus ) deallocate ( gvmus ) end if if ( write_gzvs ) then allocate ( gzvs ( ntubes , nztot , nvpa , nspec )) if ( debug ) write ( * , * ) 'stella_diagnostics::diagnose_stella::get_gzvs' call get_gzvs ( gnew , gzvs ) if ( debug ) write ( * , * ) 'stella_diagnostics::diagnose_stella::write_gzvs_nc' if ( proc0 ) call write_gzvs_nc ( nout , gzvs ) deallocate ( gzvs ) end if if ( proc0 ) call sync_nc nout = nout + 1 end if deallocate ( part_flux , mom_flux , heat_flux ) deallocate ( pflx_kxkyz , vflx_kxkyz , qflx_kxkyz ) deallocate ( phi_out ) if ( allocated ( part_flux_x )) deallocate ( part_flux_x ) if ( allocated ( mom_flux_x )) deallocate ( mom_flux_x ) if ( allocated ( heat_flux_x )) deallocate ( heat_flux_x ) if ( allocated ( dens_ffs )) deallocate ( dens_ffs ) if ( allocated ( upar_ffs )) deallocate ( upar_ffs ) if ( allocated ( pres_ffs )) deallocate ( pres_ffs ) !    nout = nout + 1 end subroutine diagnose_stella !> Calculate fluxes !> !> Assumes that the non-Boltzmann part of df is passed in (aka h) subroutine get_fluxes ( g , pflx , vflx , qflx , & pflx_vs_kxkyz , vflx_vs_kxkyz , qflx_vs_kxkyz ) use mp , only : sum_reduce use constants , only : zi use fields_arrays , only : phi , apar use stella_layouts , only : kxkyz_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , it_idx , is_idx use species , only : spec , nspec use stella_geometry , only : jacob , grho , bmag , btor use stella_geometry , only : gds21 , gds22 use stella_geometry , only : geo_surf use zgrid , only : delzed , nzgrid , ntubes use vpamu_grids , only : nvpa , nmu use vpamu_grids , only : vperp2 , vpa use run_parameters , only : fphi , fapar use kt_grids , only : aky , theta0 use gyro_averages , only : gyro_average , gyro_average_j1 implicit none complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( in ) :: g real , dimension (:), intent ( out ) :: pflx , vflx , qflx real , dimension (:, :, - nzgrid :, :, :), intent ( out ) :: pflx_vs_kxkyz , vflx_vs_kxkyz , qflx_vs_kxkyz integer :: ikxkyz , iky , ikx , iz , it , is , ia real , dimension (:), allocatable :: flx_norm real :: flx_norm_partial complex , dimension (:, :), allocatable :: gtmp1 , gtmp2 , gtmp3 allocate ( flx_norm ( - nzgrid : nzgrid )) allocate ( gtmp1 ( nvpa , nmu ), gtmp2 ( nvpa , nmu ), gtmp3 ( nvpa , nmu )) pflx = 0. ; vflx = 0. ; qflx = 0. pflx_vs_kxkyz = 0. ; vflx_vs_kxkyz = 0. ; qflx_vs_kxkyz = 0. flx_norm = jacob ( 1 , :) * delzed flx_norm ( - nzgrid ) = 0.5 * flx_norm ( - nzgrid ) flx_norm ( nzgrid ) = 0.5 * flx_norm ( nzgrid ) if ( flux_norm ) then ! Flux definition with an extra factor 1/<\\nabla\\rho> in front. flx_norm_partial = sum ( flx_norm ) / sum ( flx_norm * grho ( 1 , :)) flx_norm = flx_norm / sum ( flx_norm * grho ( 1 , :)) else ! Flux definition without the extra factor. flx_norm_partial = 1.0 flx_norm = flx_norm / sum ( flx_norm ) end if ia = 1 ! get electrostatic contributions to fluxes if ( fphi > epsilon ( 0.0 )) then do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) ! get particle flux call gyro_average ( g (:, :, ikxkyz ), ikxkyz , gtmp1 ) call get_one_flux ( iky , iz , flx_norm ( iz ), gtmp1 , phi ( iky , ikx , iz , it ), pflx ( is )) call get_one_flux ( iky , iz , flx_norm_partial , gtmp1 , phi ( iky , ikx , iz , it ), pflx_vs_kxkyz ( iky , ikx , iz , it , is )) ! get heat flux ! NEEDS TO BE MODIFIED TO TREAT ENERGY = ENERGY(ALPHA) gtmp1 = gtmp1 * ( spread ( vpa ** 2 , 2 , nmu ) + spread ( vperp2 ( 1 , iz , :), 1 , nvpa )) call get_one_flux ( iky , iz , flx_norm ( iz ), gtmp1 , phi ( iky , ikx , iz , it ), qflx ( is )) call get_one_flux ( iky , iz , flx_norm_partial , gtmp1 , phi ( iky , ikx , iz , it ), qflx_vs_kxkyz ( iky , ikx , iz , it , is )) ! get momentum flux ! parallel component gtmp1 = g (:, :, ikxkyz ) * spread ( vpa , 2 , nmu ) * geo_surf % rmaj * btor ( iz ) / bmag ( ia , iz ) call gyro_average ( gtmp1 , ikxkyz , gtmp2 ) gtmp1 = - g (:, :, ikxkyz ) * zi * aky ( iky ) * spread ( vperp2 ( ia , iz , :), 1 , nvpa ) * geo_surf % rhoc & * ( gds21 ( ia , iz ) + theta0 ( iky , ikx ) * gds22 ( ia , iz )) * spec ( is )% smz & / ( geo_surf % qinp * geo_surf % shat * bmag ( ia , iz ) ** 2 ) call gyro_average_j1 ( gtmp1 , ikxkyz , gtmp3 ) gtmp1 = gtmp2 + gtmp3 call get_one_flux ( iky , iz , flx_norm ( iz ), gtmp1 , phi ( iky , ikx , iz , it ), vflx ( is )) call get_one_flux ( iky , iz , flx_norm_partial , gtmp1 , phi ( iky , ikx , iz , it ), vflx_vs_kxkyz ( iky , ikx , iz , it , is )) end do end if if ( fapar > epsilon ( 0.0 )) then ! particle flux do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) ! Apar contribution to particle flux gtmp1 = - g (:, :, ikxkyz ) * spec ( is )% stm * spread ( vpa , 2 , nmu ) call gyro_average ( gtmp1 , ikxkyz , gtmp2 ) call get_one_flux ( iky , iz , flx_norm ( iz ), gtmp2 , apar ( iky , ikx , iz , it ), pflx ( is )) ! Apar contribution to heat flux gtmp2 = gtmp2 * ( spread ( vpa ** 2 , 2 , nmu ) + spread ( vperp2 ( ia , iz , :), 1 , nvpa )) call get_one_flux ( iky , iz , flx_norm ( iz ), gtmp2 , apar ( iky , ikx , iz , it ), qflx ( is )) ! Apar contribution to momentum flux ! parallel component gtmp1 = - spread ( vpa ** 2 , 2 , nmu ) * spec ( is )% stm * g (:, :, ikxkyz ) & * geo_surf % rmaj * btor ( iz ) / bmag ( 1 , iz ) call gyro_average ( gtmp1 , ikxkyz , gtmp2 ) ! perp component gtmp1 = spread ( vpa , 2 , nmu ) * spec ( is )% stm * g (:, :, ikxkyz ) & * zi * aky ( iky ) * spread ( vperp2 ( ia , iz , :), 1 , nvpa ) * geo_surf % rhoc & * ( gds21 ( ia , iz ) + theta0 ( iky , ikx ) * gds22 ( ia , iz )) * spec ( is )% smz & / ( geo_surf % qinp * geo_surf % shat * bmag ( ia , iz ) ** 2 ) call gyro_average_j1 ( gtmp1 , ikxkyz , gtmp3 ) ! FLAG -- NEED TO ADD IN CONTRIBUTION FROM BOLTZMANN PIECE !! gtmp1 = gtmp2 + gtmp3 call get_one_flux ( iky , iz , flx_norm ( iz ), gtmp1 , apar ( iky , ikx , iz , it ), vflx ( is )) end do end if call sum_reduce ( pflx , 0 ); pflx = pflx * spec % dens_psi0 call sum_reduce ( qflx , 0 ); qflx = qflx * spec % dens_psi0 * spec % temp_psi0 call sum_reduce ( vflx , 0 ); vflx = vflx * spec % dens_psi0 * sqrt ( spec % mass * spec % temp_psi0 ) ! normalise to account for contributions from multiple flux tubes ! in flux tube train pflx = pflx / real ( ntubes ) qflx = qflx / real ( ntubes ) vflx = vflx / real ( ntubes ) call sum_reduce ( pflx_vs_kxkyz , 0 ) call sum_reduce ( qflx_vs_kxkyz , 0 ) call sum_reduce ( vflx_vs_kxkyz , 0 ) do is = 1 , nspec pflx_vs_kxkyz (:, :, :, :, is ) = pflx_vs_kxkyz (:, :, :, :, is ) * spec ( is )% dens_psi0 qflx_vs_kxkyz (:, :, :, :, is ) = qflx_vs_kxkyz (:, :, :, :, is ) * spec ( is )% dens_psi0 * spec ( is )% temp_psi0 vflx_vs_kxkyz (:, :, :, :, is ) = vflx_vs_kxkyz (:, :, :, :, is ) * spec ( is )% dens_psi0 * sqrt ( spec ( is )% mass * spec ( is )% temp_psi0 ) end do deallocate ( gtmp1 , gtmp2 , gtmp3 ) deallocate ( flx_norm ) end subroutine get_fluxes !============================================== !============ GET FLUXES VMULO ================ !============================================== subroutine get_fluxes_vmulo ( g , phi , pflx , vflx , qflx , pflx_x , vflx_x , qflx_x ) use mp , only : sum_reduce use constants , only : zi use dist_fn_arrays , only : g1 , g2 , kperp2 , dkperp2dr use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx , imu_idx , is_idx use species , only : spec use stella_geometry , only : grho_norm , bmag , btor use stella_geometry , only : drhodpsi use stella_geometry , only : gds21 , gds22 use stella_geometry , only : dgds21dr , dgds22dr use stella_geometry , only : geo_surf use stella_geometry , only : dBdrho , dIdrho use zgrid , only : nzgrid , ntubes use vpamu_grids , only : vperp2 , vpa , mu use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use run_parameters , only : fphi use kt_grids , only : aky , theta0 , naky , nakx , multiply_by_rho use physics_flags , only : radial_variation use gyro_averages , only : gyro_average , gyro_average_j1 , aj0x , aj1x implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: phi real , dimension (:), intent ( out ) :: pflx , vflx , qflx real , dimension (:, :), intent ( out ) :: pflx_x , vflx_x , qflx_x integer :: ivmu , imu , iv , iz , it , is , ia real :: flx_norm complex , dimension (:, :), allocatable :: g0k , g1k pflx = 0. ; vflx = 0. ; qflx = 0. pflx_x = 0. ; vflx_x = 0. ; qflx_x = 0. ia = 1 if ( flux_norm ) then flx_norm = 1. / grho_norm else flx_norm = 1. end if allocate ( g0k ( naky , nakx )) allocate ( g1k ( naky , nakx )) ! if(radial_variation) then !   where (dl_over_b(ia,:) .gt. epsilon(0.0)) !     dflx_norm = d_dl_over_b_drho(ia,:)/dl_over_b(ia,:) !   elsewhere !     dflx_norm = 0. !   endwhere ! endif ! FLAG - electrostatic for now ! get electrostatic contributions to fluxes if ( fphi > epsilon ( 0.0 )) then ia = 1 !get particle flux do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) call gyro_average ( g (:, :, :, :, ivmu ), ivmu , g1 (:, :, :, :, ivmu )) do it = 1 , ntubes do iz = - nzgrid , nzgrid if ( radial_variation ) then g0k = g1 (:, :, iz , it , ivmu ) & * ( - 0.5 * aj1x (:, :, iz , ivmu ) / aj0x (:, :, iz , ivmu ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 (:, :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) & + dBdrho ( iz ) / bmag ( ia , iz )) call multiply_by_rho ( g0k ) g1 (:, :, iz , it , ivmu ) = g1 (:, :, iz , it , ivmu ) + g0k end if !subtract adiabatic contribution part of g g0k = spec ( is )% zt * fphi * phi (:, :, iz , it ) * aj0x (:, :, iz , ivmu ) ** 2 & * maxwell_vpa ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) * maxwell_fac ( is ) if ( radial_variation ) then g1k = g0k * ( - spec ( is )% tprim * ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu ) - 2.5 ) & - spec ( is )% fprim - 2.0 * dBdrho ( iz ) * mu ( imu ) & - aj1x (:, :, iz , ivmu ) / aj0x (:, :, iz , ivmu ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 (:, :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) & + dBdrho ( iz ) / bmag ( ia , iz )) call multiply_by_rho ( g1k ) g0k = g0k + g1k end if g1 (:, :, iz , it , ivmu ) = g1 (:, :, iz , it , ivmu ) + g0k end do end do end do call get_one_flux_vmulo ( flx_norm * spec % dens_psi0 , g1 , phi , pflx ) if ( write_radial_fluxes ) then call get_one_flux_radial ( flx_norm * spec % dens_psi0 , g1 , phi , pflx_x ) end if !get heat flux do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) call gyro_average ( g (:, :, :, :, ivmu ), ivmu , g1 (:, :, :, :, ivmu )) do it = 1 , ntubes do iz = - nzgrid , nzgrid g1 (:, :, iz , it , ivmu ) = g1 (:, :, iz , it , ivmu ) * ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu )) if ( radial_variation ) then g0k = g1 (:, :, iz , it , ivmu ) & * ( - 0.5 * aj1x (:, :, iz , ivmu ) / aj0x (:, :, iz , ivmu ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 (:, :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) & + dBdrho ( iz ) / bmag ( ia , iz ) & + 2.0 * mu ( imu ) * dBdrho ( iz ) / ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu ))) call multiply_by_rho ( g0k ) g1 (:, :, iz , it , ivmu ) = g1 (:, :, iz , it , ivmu ) + g0k end if !subtract adiabatic contribution part of g g0k = spec ( is )% zt * fphi * phi (:, :, iz , it ) * aj0x (:, :, iz , ivmu ) ** 2 & * ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu )) & * maxwell_vpa ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) * maxwell_fac ( is ) if ( radial_variation ) then g1k = g0k * ( - spec ( is )% tprim * ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu ) - 2.5 ) & - spec ( is )% fprim - 2.0 * dBdrho ( iz ) * mu ( imu ) & - aj1x (:, :, iz , ivmu ) / aj0x (:, :, iz , ivmu ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 (:, :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) & + dBdrho ( iz ) / bmag ( ia , iz ) & + 2.0 * mu ( imu ) * dBdrho ( iz ) / ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu ))) call multiply_by_rho ( g1k ) g0k = g0k + g1k end if g1 (:, :, iz , it , ivmu ) = g1 (:, :, iz , it , ivmu ) + g0k end do end do end do call get_one_flux_vmulo ( flx_norm * spec % dens_psi0 * spec % temp_psi0 , g1 , phi , qflx ) if ( write_radial_fluxes ) then call get_one_flux_radial ( flx_norm * spec % dens_psi0 * spec % temp_psi0 , g1 , phi , qflx_x ) end if ! get momentum flux do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) do it = 1 , ntubes do iz = - nzgrid , nzgrid ! parallel component g0k = g (:, :, iz , it , ivmu ) * vpa ( iv ) * geo_surf % rmaj * btor ( iz ) / bmag ( ia , iz ) call gyro_average ( g0k , iz , ivmu , g1 (:, :, iz , it , ivmu )) if ( radial_variation ) then g0k = g1 (:, :, iz , it , ivmu ) & * ( - 0.5 * aj1x (:, :, iz , ivmu ) / aj0x (:, :, iz , ivmu ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 (:, :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) & + dIdrho / ( geo_surf % rmaj * btor ( iz ))) call multiply_by_rho ( g0k ) g1 (:, :, iz , it , ivmu ) = g1 (:, :, iz , it , ivmu ) + g0k end if !subtract adiabatic contribution part of g g0k = spec ( is )% zt * fphi * phi (:, :, iz , it ) * aj0x (:, :, iz , ivmu ) ** 2 & * vpa ( iv ) * geo_surf % rmaj * btor ( iz ) / bmag ( ia , iz ) & * maxwell_vpa ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) * maxwell_fac ( is ) if ( radial_variation ) then g1k = g0k * ( - spec ( is )% tprim * ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu ) - 2.5 ) & - spec ( is )% fprim - 2.0 * dBdrho ( iz ) * mu ( imu ) & - aj1x (:, :, iz , ivmu ) / aj0x (:, :, iz , ivmu ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 (:, :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) & + dIdrho / ( geo_surf % rmaj * btor ( iz ))) call multiply_by_rho ( g1k ) g0k = g0k + g1k end if g1 (:, :, iz , it , ivmu ) = g1 (:, :, iz , it , ivmu ) + g0k ! perpendicular component g0k = - g (:, :, iz , it , ivmu ) * zi * spread ( aky , 2 , nakx ) * vperp2 ( ia , iz , imu ) * geo_surf % rhoc & * ( gds21 ( ia , iz ) + theta0 * gds22 ( ia , iz )) * spec ( is )% smz & / ( geo_surf % qinp * geo_surf % shat * bmag ( ia , iz ) ** 2 ) call gyro_average_j1 ( g0k , iz , ivmu , g2 (:, :, iz , it , ivmu )) if ( radial_variation ) then g0k = - g (:, :, iz , it , ivmu ) * zi * spread ( aky , 2 , nakx ) * vperp2 ( ia , iz , imu ) * geo_surf % rhoc & * ( dgds21dr ( ia , iz ) + theta0 * dgds22dr ( ia , iz )) * aj1x (:, :, iz , ivmu ) * spec ( is )% smz & / ( geo_surf % qinp * geo_surf % shat * bmag ( ia , iz ) ** 2 ) g0k = g0k - g (:, :, iz , it , ivmu ) * zi * spread ( aky , 2 , nakx ) * vperp2 ( ia , iz , imu ) * geo_surf % rhoc & * ( gds21 ( ia , iz ) + theta0 * gds22 ( ia , iz )) * spec ( is )% smz & / ( geo_surf % qinp * geo_surf % shat * bmag ( ia , iz ) ** 2 ) & * ( 0.5 * aj0x (:, :, iz , ivmu ) - aj1x (:, :, iz , ivmu )) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) g0k = g0k + g2 (:, :, iz , it , ivmu ) & * ( - geo_surf % d2qdr2 * geo_surf % rhoc / ( geo_surf % shat * geo_surf % qinp ) & - geo_surf % d2psidr2 * drhodpsi ) call multiply_by_rho ( g0k ) g2 (:, :, iz , it , ivmu ) = g2 (:, :, iz , it , ivmu ) + g0k end if !subtract adiabatic contribution part of g g0k = - spec ( is )% zt * fphi * phi (:, :, iz , it ) * aj0x (:, :, iz , ivmu ) * aj1x (:, :, iz , ivmu ) & * maxwell_vpa ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) * maxwell_fac ( is ) & * zi * spread ( aky , 2 , nakx ) * vperp2 ( ia , iz , imu ) * geo_surf % rhoc & * ( gds21 ( ia , iz ) + theta0 * gds22 ( ia , iz )) * spec ( is )% smz & / ( geo_surf % qinp * geo_surf % shat * bmag ( ia , iz ) ** 2 ) if ( radial_variation ) then g1k = - spec ( is )% zt * fphi * phi (:, :, iz , it ) * aj0x (:, :, iz , ivmu ) * aj1x (:, :, iz , ivmu ) & * maxwell_vpa ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) * maxwell_fac ( is ) & * zi * spread ( aky , 2 , nakx ) * vperp2 ( ia , iz , imu ) * geo_surf % rhoc & * ( dgds21dr ( ia , iz ) + theta0 * dgds22dr ( ia , iz )) * spec ( is )% smz & / ( geo_surf % qinp * geo_surf % shat * bmag ( ia , iz ) ** 2 ) g1k = g1k - spec ( is )% zt * fphi * phi (:, :, iz , it ) * aj0x (:, :, iz , ivmu ) & * maxwell_vpa ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) * maxwell_fac ( is ) & * zi * spread ( aky , 2 , nakx ) * vperp2 ( ia , iz , imu ) * geo_surf % rhoc & * ( gds21 ( ia , iz ) + theta0 * gds22 ( ia , iz )) * spec ( is )% smz & / ( geo_surf % qinp * geo_surf % shat * bmag ( ia , iz ) ** 2 ) & * ( 0.5 * aj0x (:, :, iz , ivmu ) - aj1x (:, :, iz , ivmu )) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) g1k = g1k + & g0k * ( - spec ( is )% tprim * ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu ) - 2.5 ) & - spec ( is )% fprim - 2.0 * dBdrho ( iz ) * mu ( imu ) & - 0.5 * aj1x (:, :, iz , ivmu ) / aj0x (:, :, iz , ivmu ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 (:, :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) & - geo_surf % d2qdr2 * geo_surf % rhoc / ( geo_surf % shat * geo_surf % qinp ) & - geo_surf % d2psidr2 * drhodpsi ) call multiply_by_rho ( g1k ) g0k = g0k + g1k end if g2 (:, :, iz , it , ivmu ) = g2 (:, :, iz , it , ivmu ) + g0k end do end do end do g1 = g1 + g2 call get_one_flux_vmulo ( flx_norm * spec % dens_psi0 * sqrt ( spec % mass * spec % temp_psi0 ), g1 , phi , vflx ) if ( write_radial_fluxes ) then call get_one_flux_radial ( flx_norm * spec % dens_psi0 * sqrt ( spec % mass * spec % temp_psi0 ), g1 , phi , vflx_x ) end if end if if ( allocated ( g0k )) deallocate ( g0k ) if ( allocated ( g1k )) deallocate ( g1k ) end subroutine get_fluxes_vmulo !> Calculate the total particle, momentum and heat fluxes (pflx, vflx, qflx) !> and the contributions from a given (kx,ky,z) location (pflx_kxkyz, vflx_kxkyz, qflx_kxkyz) !> inputs are the particle density (dens), parallel flow (upar) and pressure (pres) subroutine get_fluxes_ffs ( dens , upar , pres , pflx , vflx , qflx , & pflx_vs_kxkyz , vflx_vs_kxkyz , qflx_vs_kxkyz ) use constants , only : zi use species , only : nspec use zgrid , only : nzgrid , delzed use kt_grids , only : naky , nakx , ny use kt_grids , only : aky , dy use fields_arrays , only : phi use stella_geometry , only : grad_x , jacob implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: dens , upar , pres real , dimension (:), intent ( out ) :: pflx , vflx , qflx real , dimension (:, :, - nzgrid :, :, :), intent ( out ) :: pflx_vs_kxkyz , vflx_vs_kxkyz , qflx_vs_kxkyz integer :: iky , it real :: flux_surface_area , gradx_fsa real :: flxfac complex , dimension (:, :, :), allocatable :: dphidy !> assume a single flux annulus it = 1 allocate ( dphidy ( naky , nakx , - nzgrid : nzgrid )) !> obtain the y-component of the electric field that appears as a factor !> in the flux expression due to the radial component of the ExB velocity do iky = 1 , naky dphidy ( iky , :, :) = zi * aky ( iky ) * conjg ( phi ( iky , :, :, it )) end do !> compute the flux surface area = int dy dz (dalpha/dy)*(dpsi/dx)  / (B . grad z) flux_surface_area = sum ( spread ( delzed * dy , 1 , ny ) * jacob ) !> compute the flux surface average of |grad x| gradx_fsa = sum ( grad_x * jacob * spread ( delzed * dy , 1 , ny )) / flux_surface_area !> flxfac is pre-factor in front of fluxes flxfac = 0.5 / ( flux_surface_area * gradx_fsa ) call get_one_flux_ffs ( dens , dphidy , flxfac , pflx , pflx_vs_kxkyz (:, :, :, it , :)) call get_one_flux_ffs ( pres , dphidy , flxfac , qflx , qflx_vs_kxkyz (:, :, :, it , :)) call get_one_flux_ffs ( upar , dphidy , flxfac , vflx , vflx_vs_kxkyz (:, :, :, it , :)) deallocate ( dphidy ) end subroutine get_fluxes_ffs subroutine get_one_flux_ffs ( mom , dphidy , flxfac , flx , flx_vs_kxkyz ) use species , only : nspec use zgrid , only : nzgrid , delzed use kt_grids , only : naky , nakx use volume_averages , only : mode_fac implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: mom complex , dimension (:, :, - nzgrid :), intent ( in ) :: dphidy real , intent ( in ) :: flxfac real , dimension (:), intent ( out ) :: flx real , dimension (:, :, - nzgrid :, :), intent ( out ) :: flx_vs_kxkyz integer :: iky , ikx , iz , is complex , dimension (:, :, :, :), allocatable :: mom_ky allocate ( mom_ky ( naky , nakx , - nzgrid : nzgrid , nspec )) flx = 0.0 !> divide the input density by the magnetic field strength (due to Jacobian in flux-surfacee avg) !> and Fourier transform in y to get mom_ky = (density/B)(ky,kx,z,spec) call get_modified_fourier_coefficient ( mom , mom_ky ) do is = 1 , nspec !> pflx_vs_kxkyz is the particle flux before summing over (kx,ky) and integrating over z flx_vs_kxkyz (:, :, :, is ) = flxfac * aimag ( mom_ky (:, :, :, is ) * dphidy ) !> calculate the volume average of the particle flux !> note that the factor of 1/B that appears in the Jacobian has already been taken into account !> in the numerator of the flux surface average do iz = - nzgrid , nzgrid do ikx = 1 , nakx do iky = 1 , naky flx ( is ) = flx ( is ) + mode_fac ( iky ) * flx_vs_kxkyz ( iky , ikx , iz , is ) * delzed ( iz ) end do end do end do end do deallocate ( mom_ky ) end subroutine get_one_flux_ffs subroutine get_modified_fourier_coefficient ( moment , moment_ky ) use species , only : nspec use zgrid , only : nzgrid use kt_grids , only : ikx_max , naky_all , ny use kt_grids , only : swap_kxky_back use stella_geometry , only : bmag use stella_transforms , only : transform_y2ky implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: moment complex , dimension (:, :, - nzgrid :, :), intent ( out ) :: moment_ky integer :: ikx , iz , is complex , dimension (:, :), allocatable :: tmp_kykx complex , dimension (:, :), allocatable :: tmp_ykx allocate ( tmp_kykx ( naky_all , ikx_max )) allocate ( tmp_ykx ( ny , ikx_max )) do is = 1 , nspec do iz = - nzgrid , nzgrid do ikx = 1 , ikx_max !> divide the input moment by the magnetic field strength !> to account for Jacobian in flux-surface average tmp_ykx (:, ikx ) = moment (:, ikx , iz , is ) / bmag (:, iz ) end do !> transform the B-modified input moment from y to ky space call transform_y2ky ( tmp_ykx , tmp_kykx ) !> swap from all ky and kx >= 0 to all kx and ky >= 0 call swap_kxky_back ( tmp_kykx , moment_ky (:, :, iz , is )) end do end do deallocate ( tmp_kykx , tmp_ykx ) end subroutine get_modified_fourier_coefficient !============================================== !=============== GET ONE FLUX ================= !============================================== subroutine get_one_flux ( iky , iz , norm , gin , fld , flxout ) use vpamu_grids , only : integrate_vmu use volume_averages , only : mode_fac use kt_grids , only : aky implicit none integer , intent ( in ) :: iky , iz real , intent ( in ) :: norm complex , dimension (:, :), intent ( in ) :: gin complex , intent ( in ) :: fld real , intent ( in out ) :: flxout complex :: flx call integrate_vmu ( gin , iz , flx ) flxout = flxout & + 0.5 * mode_fac ( iky ) * aky ( iky ) * aimag ( flx * conjg ( fld )) * norm end subroutine get_one_flux !============================================== !============ GET ONE FLUX VMULO ============== !============================================== subroutine get_one_flux_vmulo ( weights , gin , fld , flxout ) use vpamu_grids , only : integrate_vmu use stella_layouts , only : vmu_lo use kt_grids , only : aky , nakx , naky , boundary_size use zgrid , only : nzgrid , ntubes use species , only : nspec use volume_averages , only : mode_fac use stella_geometry , only : dVolume use stella_transforms , only : transform_kx2x_unpadded use physics_flags , only : radial_variation implicit none real , dimension (:), intent ( in ) :: weights complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: gin complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: fld real , dimension (:), intent ( in out ) :: flxout complex , dimension (:, :, :, :, :), allocatable :: totals complex , dimension (:, :), allocatable :: g0x , g1x integer :: ia , is , it , iz , ikx real , dimension ( nspec ) :: flux_sum real :: volume allocate ( totals ( naky , nakx , - nzgrid : nzgrid , ntubes , nspec )) ia = 1 flux_sum = 0. call integrate_vmu ( gin , weights , totals ) if ( radial_variation ) then !do it in real-space allocate ( g0x ( naky , nakx )) allocate ( g1x ( naky , nakx )) do is = 1 , nspec volume = 0. do it = 1 , ntubes do iz = - nzgrid , nzgrid call transform_kx2x_unpadded ( totals (:, :, iz , it , is ), g0x ) call transform_kx2x_unpadded ( fld (:, :, iz , it ), g1x ) do ikx = boundary_size + 1 , nakx - boundary_size flux_sum ( is ) = flux_sum ( is ) + & sum ( 0.5 * mode_fac * aky * aimag ( g0x (:, ikx ) * conjg ( g1x (:, ikx ))) * dVolume ( ia , ikx , iz )) volume = volume + dVolume ( ia , ikx , iz ) end do end do end do end do deallocate ( g0x , g1x ) else do is = 1 , nspec volume = 0. do it = 1 , ntubes do iz = - nzgrid , nzgrid do ikx = 1 , nakx flux_sum ( is ) = flux_sum ( is ) + & sum ( 0.5 * mode_fac * aky * aimag ( totals (:, ikx , iz , it , is ) * conjg ( fld (:, ikx , iz , it ))) * dVolume ( ia , ikx , iz )) volume = volume + dVolume ( ia , ikx , iz ) end do end do end do end do end if flxout = flxout + flux_sum / volume deallocate ( totals ) end subroutine get_one_flux_vmulo !============================================== !=========== GET ONE FLUX RADIAL ============== !============================================== subroutine get_one_flux_radial ( weights , gin , fld , flxout ) use vpamu_grids , only : integrate_vmu use stella_geometry , only : dVolume use stella_layouts , only : vmu_lo use kt_grids , only : aky , nakx , naky use zgrid , only : nzgrid , ntubes use species , only : nspec use volume_averages , only : mode_fac use stella_transforms , only : transform_kx2x_unpadded implicit none real , dimension (:), intent ( in ) :: weights complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: gin complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: fld real , dimension (:, :), intent ( in out ) :: flxout real , dimension (:), allocatable :: dV_rad complex , dimension (:, :, :, :, :), allocatable :: totals complex , dimension (:, :), allocatable :: g0x , g1x integer :: ia , is , it , iz , ikx allocate ( dV_rad ( nakx )) allocate ( g0x ( naky , nakx )) allocate ( g1x ( naky , nakx )) allocate ( totals ( naky , nakx , - nzgrid : nzgrid , ntubes , nspec )) ia = 1 dV_rad = sum ( sum ( dVolume , 3 ), 1 ) * ntubes ! NB: this returns the flux-surface-averaged radial fluxes. Keep in mind that the !     volume element in a flux-surface, dV, may not be uniform across surfaces, so !     one cannot simply sum across the radius here to get the total flux; rather, one !     would have to multiply by dV/V across the radius first call integrate_vmu ( gin , weights , totals ) do is = 1 , nspec do it = 1 , ntubes do iz = - nzgrid , nzgrid call transform_kx2x_unpadded ( totals (:, :, iz , it , is ), g0x ) call transform_kx2x_unpadded ( fld (:, :, iz , it ), g1x ) do ikx = 1 , nakx flxout ( ikx , is ) = flxout ( ikx , is ) & + sum ( 0.5 * mode_fac * aky * aimag ( g0x (:, ikx ) * conjg ( g1x (:, ikx ))) * dVolume ( ia , ikx , iz ) / dV_rad ( ikx )) end do end do end do end do deallocate ( dV_rad , g0x , g1x , totals ) end subroutine get_one_flux_radial !============================================== !=============== GET MOMENTS ================== !============================================== subroutine get_moments ( g , dens , upar , temp , dens_x , upar_x , temp_x , spitzer2 ) use zgrid , only : nzgrid , ntubes use species , only : spec , nspec use vpamu_grids , only : integrate_vmu use vpamu_grids , only : vpa , vperp2 , mu use vpamu_grids , only : maxwell_mu , ztmax , maxwell_fac use kt_grids , only : naky , nakx , multiply_by_rho , rho_d_clamped use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx , imu_idx , is_idx use dist_fn_arrays , only : g1 , g2 , kperp2 , dkperp2dr use stella_geometry , only : bmag , dBdrho use stella_geometry , only : dl_over_b , d_dl_over_b_drho use gyro_averages , only : aj0x , aj1x , gyro_average use fields_arrays , only : phi , phi_corr_QN , phi_proj use run_parameters , only : fphi use physics_flags , only : radial_variation , full_flux_surface use stella_transforms , only : transform_kx2x_unpadded implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :, :), intent ( out ) :: dens , upar , temp , spitzer2 real , dimension (:, :), intent ( out ) :: dens_x , upar_x , temp_x complex , dimension (:, :), allocatable :: g0k , g1k , g1x real :: zero integer :: ivmu , iv , imu , is , ia integer :: iz , it if ( radial_variation ) then allocate ( g0k ( naky , nakx )) if ( write_radial_moments ) then allocate ( g1k ( 1 , nakx )) allocate ( g1x ( 1 , nakx )) end if end if ! Hack below. Works since J0&#94;2 - 1 and its derivative are zero at the origin zero = 10 0. * epsilon ( 0. ) ! h is gyrophase independent, but is in gyrocenter coordinates, ! so requires a J_0 to get to particle coordinates ! <f>_r = h J_0 - Ze*phi/T * F0 ! g     = h     - Ze*<phi>_R/T * F0 ! <f>_r = g J_0 + Ze*(J_0<phi>_R-phi)/T * F0 ! calculate the integrand appearing in the integral for the density ia = 1 do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) ! obtain the gyro-average of g that appears in the density integral call gyro_average ( g (:, :, :, :, ivmu ), ivmu , g1 (:, :, :, :, ivmu )) ! FLAG -- AJ0X NEEDS DEALING WITH BELOW g2 (:, :, :, :, ivmu ) = g1 (:, :, :, :, ivmu ) + ztmax ( iv , is ) & * spread ( spread ( spread ( maxwell_mu ( ia , :, imu , is ), 1 , naky ), 2 , nakx ) & * maxwell_fac ( is ) * ( aj0x (:, :, :, ivmu ) ** 2 - 1.0 ), 4 , ntubes ) * fphi * phi if ( radial_variation ) then do it = 1 , ntubes do iz = - nzgrid , nzgrid !phi g0k = ztmax ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) & * maxwell_fac ( is ) * ( aj0x (:, :, iz , ivmu ) ** 2 - 1.0 ) * fphi * phi (:, :, iz , it ) & * ( - spec ( is )% tprim * ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu ) - 2.5 ) & - spec ( is )% fprim + ( dBdrho ( iz ) / bmag ( ia , iz )) * ( 1.0 - 2.0 * mu ( imu ) * bmag ( ia , iz )) & - aj1x (:, :, iz , ivmu ) * aj0x (:, :, iz , ivmu ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 (:, :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) & / ( aj0x (:, :, iz , ivmu ) ** 2 - 1.0 + zero )) !g g0k = g0k + g1 (:, :, iz , it , ivmu ) & * ( - 0.5 * aj1x (:, :, iz , ivmu ) / aj0x (:, :, iz , ivmu ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 (:, :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) & + dBdrho ( iz ) / bmag ( ia , iz )) call multiply_by_rho ( g0k ) ! g0k(1,1) = 0.0 !phi QN g0k = g0k + ztmax ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) * fphi & * maxwell_fac ( is ) * ( aj0x (:, :, iz , ivmu ) ** 2 - 1.0 ) * phi_corr_QN (:, :, iz , it ) g2 (:, :, iz , it , ivmu ) = g2 (:, :, iz , it , ivmu ) + g0k end do end do end if end do call integrate_vmu ( g2 , spec % dens_psi0 , dens ) if ( write_radial_moments ) then dens_x = 0.0 do is = 1 , nspec do it = 1 , ntubes do iz = - nzgrid , nzgrid g1k ( 1 , :) = dens ( 1 , :, iz , it , is ) - phi_proj (:, 1 , it ) call transform_kx2x_unpadded ( g1k , g1x ) dens_x (:, is ) = dens_x (:, is ) & + real ( g1x ( 1 , :) * ( dl_over_b ( ia , iz ) + rho_d_clamped * d_dl_over_b_drho ( ia , iz ))) end do end do end do dens_x = naky * dens_x / ntubes end if do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) g2 (:, :, :, :, ivmu ) = ( g1 (:, :, :, :, ivmu ) + ztmax ( iv , is ) & * spread ( spread ( spread ( maxwell_mu ( ia , :, imu , is ), 1 , naky ), 2 , nakx ) & * maxwell_fac ( is ) * ( aj0x (:, :, :, ivmu ) ** 2 - 1.0 ), 4 , ntubes ) * phi * fphi ) & * ( vpa ( iv ) ** 2 + spread ( spread ( spread ( vperp2 ( 1 , :, imu ), 1 , naky ), 2 , nakx ), 4 , ntubes ) - 1.5 ) / 1.5 if ( radial_variation ) then do it = 1 , ntubes do iz = - nzgrid , nzgrid !phi g0k = ztmax ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) * maxwell_fac ( is ) & * ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu ) - 1.5 ) / 1.5 & * ( aj0x (:, :, iz , ivmu ) ** 2 - 1.0 ) * phi (:, :, iz , it ) * fphi & * ( - spec ( is )% tprim * ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu ) - 2.5 ) & - spec ( is )% fprim + ( dBdrho ( iz ) / bmag ( ia , iz )) * ( 1.0 - 2.0 * mu ( imu ) * bmag ( ia , iz )) & - aj1x (:, :, iz , ivmu ) * aj0x (:, :, iz , ivmu ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 (:, :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) & / ( aj0x (:, :, iz , ivmu ) ** 2 - 1.0 + zero ) & + 2.0 * mu ( imu ) * dBdrho ( iz ) / ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu ) - 1.5 )) !g g0k = g0k + g1 (:, :, iz , it , ivmu ) * ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu ) - 1.5 ) / 1.5 & * ( - 0.5 * aj1x (:, :, iz , ivmu ) / aj0x (:, :, iz , ivmu ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 (:, :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) & + dBdrho ( iz ) / bmag ( ia , iz ) & + 2.0 * mu ( imu ) * dBdrho ( iz ) / ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu ) - 1.5 )) call multiply_by_rho ( g0k ) !phi QN g0k = g0k + fphi * ztmax ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) & * ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu ) - 1.5 ) / 1.5 & * maxwell_fac ( is ) * ( aj0x (:, :, iz , ivmu ) ** 2 - 1.0 ) * phi_corr_QN (:, :, iz , it ) g2 (:, :, iz , it , ivmu ) = g2 (:, :, iz , it , ivmu ) + g0k end do end do end if end do ! integrate to get dTs/Tr !    call integrate_vmu (g2, spec%temp, temp) call integrate_vmu ( g2 , spec % temp_psi0 * spec % dens_psi0 , temp ) if ( write_radial_moments ) then temp_x = 0.0 do is = 1 , nspec do it = 1 , ntubes do iz = - nzgrid , nzgrid g1k ( 1 , :) = temp ( 1 , :, iz , it , is ) call transform_kx2x_unpadded ( g1k , g1x ) temp_x (:, is ) = temp_x (:, is ) & + real ( g1x ( 1 , :) * ( dl_over_b ( ia , iz ) + rho_d_clamped * d_dl_over_b_drho ( ia , iz ))) end do end do end do temp_x = naky * temp_x / ntubes end if ! for Spitzer problem tests of the collision operator do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) g2 (:,:,:,:, ivmu ) = g (:,:,:,:, ivmu ) * ( vpa ( iv ) * ( vpa ( iv ) ** 2 + spread ( spread ( spread ( vperp2 ( 1 ,:, imu ), 1 , naky ), 2 , nakx ), 4 , ntubes )) - 5. / 2. * vpa ( iv ) ) end do call integrate_vmu ( g2 , spec % stm , spitzer2 ) ! AVB: stm is the thermal speed do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) g2 (:, :, :, :, ivmu ) = vpa ( iv ) * g1 (:, :, :, :, ivmu ) if ( radial_variation ) then do it = 1 , ntubes do iz = - nzgrid , nzgrid !g g0k = vpa ( iv ) * g1 (:, :, iz , it , ivmu ) & * ( - 0.5 * aj1x (:, :, iz , ivmu ) / aj0x (:, :, iz , ivmu ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 (:, :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) & + dBdrho ( iz ) / bmag ( ia , iz )) call multiply_by_rho ( g0k ) g2 (:, :, iz , it , ivmu ) = g2 (:, :, iz , it , ivmu ) + g0k end do end do end if end do call integrate_vmu ( g2 , spec % stm_psi0 , upar ) if ( write_radial_moments ) then upar_x = 0.0 do is = 1 , nspec do it = 1 , ntubes do iz = - nzgrid , nzgrid g1k ( 1 , :) = upar ( 1 , :, iz , it , is ) call transform_kx2x_unpadded ( g1k , g1x ) upar_x (:, is ) = upar_x (:, is ) & + real ( g1x ( 1 , :) * ( dl_over_b ( ia , iz ) + rho_d_clamped * d_dl_over_b_drho ( ia , iz ))) end do end do end do upar_x = naky * upar_x / ntubes end if if ( allocated ( g0k )) deallocate ( g0k ) if ( allocated ( g1k )) deallocate ( g1k ) if ( allocated ( g1x )) deallocate ( g1x ) end subroutine get_moments subroutine get_moments_ffs ( g , dens , upar , pres ) use stella_layouts , only : vmu_lo , iv_idx , imu_idx use species , only : spec , nspec use zgrid , only : nzgrid use vpamu_grids , only : integrate_vmu_ffs use vpamu_grids , only : vpa , vperp2 use kt_grids , only : naky_all , ikx_max , ny use kt_grids , only : swap_kxky use dist_fn_arrays , only : g0 , g1 use gyro_averages , only : gyro_average , j0_ffs use fields_arrays , only : phi use stella_transforms , only : transform_ky2y implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( out ) :: dens , upar , pres real , dimension (:), allocatable :: dens_wgts , upar_wgts , pres_wgts !> f_swap will contain delta f(ky,kx) on a grid with all kys and kx >= 0 complex , dimension (:, :), allocatable :: f_swap !> fy will contain delta f(y,kx) on a grid with kx >= 0 complex , dimension (:, :, :), allocatable :: fy !> integrand will contain the integrand in the velocity moment integrals complex , dimension (:), allocatable :: integrand integer :: iy , ikx , iz , it integer :: ivmu , iv , imu !> species-dependent factor by which velocity moments must be multiplied !> to get density, pressure, etc. allocate ( dens_wgts ( nspec )) allocate ( upar_wgts ( nspec )) allocate ( pres_wgts ( nspec )) !> the guiding centre distribution function, normalized by !> the equilibrium Maxwellian, is passed in as g. !> to obtain moments such as density, flow and pressure, !> we need to take moments of the distribution function, f, !> which is related to g via !> f/F0 = g + (Ze/T)*(<phi>_R - phi) !> obtain g0=f/F0 in Fourier space call g_to_f ( g , phi , g0 ) !> calculate the Fourier components of the gyro-average f at fixed particle position !> g0=f/F0 is passed in, along with j0_ffs = the Fourier coefficients of J0 !> g1=<f/F0>_r is returned call gyro_average ( g0 , g1 , j0_ffs ) allocate ( f_swap ( naky_all , ikx_max )) allocate ( fy ( ny , ikx_max , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) allocate ( integrand ( vmu_lo % llim_proc : vmu_lo % ulim_alloc )) !> assume only a single flux annulus it = 1 do iz = - nzgrid , nzgrid do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc !> for every (z,vpa,mu,spec) point !> switch from ky >= 0 and kx = [-kxmax, kxmax] !> to ky = [-kymax, kymax] and kx >= 0 call swap_kxky ( g1 (:, :, iz , it , ivmu ), f_swap ) !> for every (z,vpa,mu,spec) point, Fourier tranform from ky to y space to get !> the kx component of <f(y,x)>_r call transform_ky2y ( f_swap , fy (:, :, ivmu )) end do !> set species-dependent factors needed for density, parallel flow and pressure dens_wgts = spec % dens upar_wgts = spec % stm pres_wgts = spec % dens * spec % temp do ikx = 1 , ikx_max do iy = 1 , ny !> the integrand for the density moment is the distribution function integrand = fy ( iy , ikx , :) !> integrate over v-space to get the density, normalised by the reference density. call integrate_vmu_ffs ( integrand , dens_wgts , iy , iz , dens ( iy , ikx , iz , :)) !> the integrand for the pressure moment is the energy-weighted distribution function do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) integrand ( ivmu ) = fy ( iy , ikx , ivmu ) * ( vpa ( iv ) ** 2 + vperp2 ( iy , iz , imu )) end do !> integrate over v-space to get the pressure, normalised by the reference pressure. call integrate_vmu_ffs ( integrand , pres_wgts , iy , iz , pres ( iy , ikx , iz , :)) !> the integrand for the parallel flow moment is the parallel velocity do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) integrand ( ivmu ) = fy ( iy , ikx , ivmu ) * vpa ( iv ) end do !> integrate over v-space to get the parallel flow, normalised by the reference thermal speed. call integrate_vmu_ffs ( integrand , upar_wgts , iy , iz , upar ( iy , ikx , iz , :)) end do end do end do deallocate ( dens_wgts , upar_wgts , pres_wgts ) deallocate ( f_swap , fy ) deallocate ( integrand ) end subroutine get_moments_ffs !> the Fourier components of the guiding centre distribution function !> normalized by the equilibrium Maxwellian is passed in as g, !> along with the Fourier components of the electrostatic potential, phi. !> g_to_f calculates the Maxwellian-normalized distribution function f, !> which is related to g via !> f = g + (Ze/T)*(<phi>_R - phi) subroutine g_to_f ( g , phi , f ) use stella_layouts , only : vmu_lo , is_idx use species , only : spec use zgrid , only : nzgrid use gyro_averages , only : gyro_average , j0_ffs implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: phi complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( out ) :: f integer :: ivmu , is do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc !> compute <phi>_R and store in f !> j0_ffs are the fourier coefficients of J0(k_perp(y)) call gyro_average ( phi , f (:, :, :, :, ivmu ), j0_ffs (:, :, :, ivmu )) !> calculate the normalized f, given phi and <phi>_R (temporarily stored in f) is = is_idx ( vmu_lo , ivmu ) f (:, :, :, :, ivmu ) = g (:, :, :, :, ivmu ) + spec ( is )% zt * ( f (:, :, :, :, ivmu ) - phi ) end do end subroutine g_to_f !============================================== !================ GET GVMUS =================== !============================================== ! get_gvmus takes g(kx,ky,z) and returns average over z of int dxdy g(x,y,z)&#94;2 ! SHOULD MODIFY TO TAKE ADVANTAGE OF FACT THAT G(KY,KX,Z) LOCAL IS AVAILABLE subroutine get_gvmus ( g , gv ) use mp , only : nproc , sum_reduce use stella_layouts , only : kxkyz_lo use stella_layouts , only : is_idx , iky_idx , iz_idx use zgrid , only : ntubes use vpamu_grids , only : nvpa , nmu use stella_geometry , only : dl_over_b use volume_averages , only : mode_fac implicit none complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( in ) :: g real , dimension (:, :, :), intent ( out ) :: gv integer :: ikxkyz , iv , is , imu , iz , iky , ia !, ivp ia = 1 ! when doing volume averages, note the following: ! int dxdy g(x,y)&#94;2 = sum_ky |g(ky=0,kx)|&#94;2 + 2 * sum_{kx,ky} |g(ky>0,kx)|&#94;2 ! factor of 2 accounted for in fac gv = 0. do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc is = is_idx ( kxkyz_lo , ikxkyz ) iky = iky_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) do imu = 1 , nmu do iv = 1 , nvpa gv ( iv , imu , is ) = gv ( iv , imu , is ) + real ( g ( iv , imu , ikxkyz ) * conjg ( g ( iv , imu , ikxkyz ))) * mode_fac ( iky ) * dl_over_b ( ia , iz ) end do end do end do gv = gv / real ( ntubes ) if ( nproc > 1 ) call sum_reduce ( gv , 0 ) end subroutine get_gvmus !============================================== !================= GET GVZS =================== !============================================== ! get_gzvs takes g(kx,ky,z,vpa,mu,s) and returns int dmudxdy g(x,y,z,vpa,mu,s)&#94;2 subroutine get_gzvs ( g , gz ) use stella_layouts , only : vmu_lo use zgrid , only : nzgrid , ntubes use vpamu_grids , only : integrate_mu use kt_grids , only : nakx , naky use volume_averages , only : mode_fac implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g real , dimension (:, :, :, :), intent ( out ) :: gz integer :: ivmu , iz , it , ikx , iky , izp real , dimension (:, :, :), allocatable :: gtmp allocate ( gtmp ( - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) ! when doing volume averages, note the following: ! int dxdy g(x,y)&#94;2 = sum_kx |g(kx,ky=0)|&#94;2 + 2 * sum_{kx,ky} |g(kx,ky>0)|&#94;2 ! factor of 2 accounted for in mode_fac gtmp = 0. do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do ikx = 1 , nakx do iky = 1 , naky gtmp (:, :, ivmu ) = gtmp (:, :, ivmu ) + real ( g ( iky , ikx , :, :, ivmu ) * conjg ( g ( iky , ikx , :, :, ivmu ))) * mode_fac ( iky ) end do end do end do do it = 1 , ntubes do iz = - nzgrid , nzgrid izp = iz + nzgrid + 1 call integrate_mu ( iz , gtmp ( iz , it , :), gz ( it , izp , :, :)) end do end do deallocate ( gtmp ) end subroutine get_gzvs !============================================== !======== FINISH STELLA DIAGNOSTIC ============ !============================================== subroutine finish_stella_diagnostics ( istep ) use mp , only : proc0 use redistribute , only : scatter use stella_io , only : finish_stella_io use stella_time , only : code_dt , code_time use stella_save , only : stella_save_for_restart use dist_redistribute , only : kxkyz2vmu use dist_fn_arrays , only : gnew , gvmu implicit none integer :: istatus integer , intent ( in ) :: istep if ( proc0 ) then call write_final_ascii_files call close_loop_ascii_files end if if ( save_for_restart ) then call scatter ( kxkyz2vmu , gnew , gvmu ) call stella_save_for_restart ( gvmu , istep , code_time , code_dt , istatus , . true .) end if call finish_stella_io call deallocate_arrays nout = 1 diagnostics_initialized = . false . end subroutine finish_stella_diagnostics !============================================== !========= WRITE LOOP ASCII FILES ============= !============================================== subroutine write_loop_ascii_files ( istep , phi2 , apar2 , pflx , vflx , qflx , om , om_avg ) use stella_time , only : code_time use species , only : nspec use kt_grids , only : naky , nakx use kt_grids , only : aky , akx implicit none integer , intent ( in ) :: istep real , intent ( in ) :: phi2 , apar2 real , dimension (:), intent ( in ) :: pflx , vflx , qflx complex , dimension (:, :), intent ( in ) :: om , om_avg character ( 3 ) :: nspec_str character ( 100 ) :: str integer :: ikx , iky write ( stdout_unit , '(a7,i7,a6,e12.4,a10,e12.4,a11,e12.4)' ) 'istep=' , istep , & 'time=' , code_time , '|phi|&#94;2=' , phi2 , '|apar|&#94;2= ' , apar2 call flush ( stdout_unit ) write ( nspec_str , '(i3)' ) 3 * nspec + 1 str = trim ( '(' // trim ( nspec_str ) // 'es15.4e3)' ) write ( fluxes_unit , str ) code_time , pflx , vflx , qflx call flush ( stdout_unit ) call flush ( fluxes_unit ) if ( write_omega . and . istep > 0 ) then do iky = 1 , naky do ikx = 1 , nakx write ( omega_unit , '(7e16.8)' ) code_time , aky ( iky ), akx ( ikx ), & real ( om ( iky , ikx )), aimag ( om ( iky , ikx )), & real ( om_avg ( iky , ikx )), aimag ( om_avg ( iky , ikx )) end do if ( nakx > 1 ) write ( omega_unit , * ) end do if ( naky > 1 ) write ( omega_unit , * ) call flush ( omega_unit ) end if end subroutine write_loop_ascii_files !============================================== !========= WRITE FINAL ASCII FILES ============ !============================================== subroutine write_final_ascii_files use file_utils , only : open_output_file , close_output_file use fields_arrays , only : phi , apar use zgrid , only : nzgrid , ntubes use zgrid , only : zed use kt_grids , only : naky , nakx use kt_grids , only : aky , akx , zed0 use stella_geometry , only : zed_eqarc USE dist_fn_arrays , ONLY : kperp2 implicit none integer :: tmpunit integer :: iky , ikx , iz , it call open_output_file ( tmpunit , '.final_fields' ) write ( tmpunit , '(10a14)' ) '# z' , 'z-zed0' , 'aky' , 'akx' , & 'real(phi)' , 'imag(phi)' , 'real(apar)' , 'imag(apar)' , & 'z_eqarc-zed0' , 'kperp2' do iky = 1 , naky do ikx = 1 , nakx do it = 1 , ntubes do iz = - nzgrid , nzgrid write ( tmpunit , '(10es15.4e3,i3)' ) zed ( iz ), zed ( iz ) - zed0 ( iky , ikx ), aky ( iky ), akx ( ikx ), & real ( phi ( iky , ikx , iz , it )), aimag ( phi ( iky , ikx , iz , it )), & real ( apar ( iky , ikx , iz , it )), aimag ( apar ( iky , ikx , iz , it )), zed_eqarc ( iz ) - zed0 ( iky , ikx ), & kperp2 ( iky , ikx , it , iz ), it end do write ( tmpunit , * ) end do end do end do call close_output_file ( tmpunit ) end subroutine write_final_ascii_files !============================================== !============ DEALLCOATE ARRAYS =============== !============================================== subroutine deallocate_arrays implicit none if ( allocated ( pflux )) deallocate ( pflux ) if ( allocated ( qflux )) deallocate ( qflux ) if ( allocated ( vflux )) deallocate ( vflux ) if ( allocated ( exchange )) deallocate ( exchange ) if ( allocated ( pflux_avg )) deallocate ( pflux_avg ) if ( allocated ( qflux_avg )) deallocate ( qflux_avg ) if ( allocated ( vflux_avg )) deallocate ( vflux_avg ) if ( allocated ( heat_avg )) deallocate ( heat_avg ) if ( allocated ( omega_vs_time )) deallocate ( omega_vs_time ) end subroutine deallocate_arrays end module stella_diagnostics","tags":"","loc":"sourcefile/stella_diagnostics.f90.html"},{"title":"stella.f90 â€“ stella","text":"Contents Programs stella Source Code stella.f90 Source Code program stella use redistribute , only : scatter use job_manage , only : time_message , checkstop , job_fork use run_parameters , only : nstep , tend , fphi , fapar use stella_time , only : update_time , code_time , code_dt use dist_redistribute , only : kxkyz2vmu use time_advance , only : advance_stella use stella_diagnostics , only : diagnose_stella , nsave use stella_save , only : stella_save_for_restart use dist_fn_arrays , only : gnew , gvmu use file_utils , only : error_unit , flush_output_file use git_version , only : get_git_version , get_git_date implicit none logical :: debug = . false . logical :: stop_stella = . false . logical :: mpi_initialized = . false . integer :: istep0 , istep , ierr integer :: istatus real , dimension ( 2 ) :: time_init = 0. real , dimension ( 2 ) :: time_diagnostics = 0. real , dimension ( 2 ) :: time_total = 0. call parse_command_line () !> Initialize stella call init_stella ( istep0 , get_git_version (), get_git_date ()) !> Diagnose stella if ( debug ) write ( * , * ) 'stella::diagnose_stella' if ( istep0 == 0 ) call diagnose_stella ( istep0 ) !> Advance stella until istep=nstep if ( debug ) write ( * , * ) 'stella::advance_stella' istep = istep0 + 1 do while (( code_time <= tend . AND . tend > 0 ) . OR . ( istep <= nstep . AND . nstep > 0 )) if ( debug ) write ( * , * ) 'istep = ' , istep if ( mod ( istep , 10 ) == 0 ) call checkstop ( stop_stella ) if ( stop_stella ) exit call advance_stella ( istep ) call update_time if ( nsave > 0 . and . mod ( istep , nsave ) == 0 ) then call scatter ( kxkyz2vmu , gnew , gvmu ) call stella_save_for_restart ( gvmu , istep , code_time , code_dt , istatus ) end if call time_message (. false ., time_diagnostics , ' diagnostics' ) call diagnose_stella ( istep ) call time_message (. false ., time_diagnostics , ' diagnostics' ) ierr = error_unit () call flush_output_file ( ierr ) istep = istep + 1 end do !> Finish stella if ( debug ) write ( * , * ) 'stella::finish_stella' call finish_stella ( last_call = . true .) contains !> Initialise stella !> !> Calls the initialisation routines for all the geometry, physics, and !> diagnostic modules subroutine init_stella ( istep0 , VERNUM , VERDATE ) use mp , only : init_mp , broadcast , sum_allreduce use mp , only : proc0 , job , scope , subprocs , crossdomprocs use file_utils , only : init_file_utils use file_utils , only : runtype_option_switch , runtype_multibox use file_utils , only : run_name , init_job_name use file_utils , only : flush_output_file , error_unit use job_manage , only : checktime , time_message , njobs use physics_parameters , only : init_physics_parameters use physics_flags , only : init_physics_flags , radial_variation use run_parameters , only : init_run_parameters use run_parameters , only : avail_cpu_time , nstep , rng_seed , delt use run_parameters , only : stream_implicit , driftkinetic_implicit use run_parameters , only : delt_option_switch , delt_option_auto use run_parameters , only : mat_gen , mat_read use species , only : init_species , read_species_knobs use species , only : nspec , communicate_species_multibox use zgrid , only : init_zgrid use zgrid , only : nzgrid , ntubes use stella_geometry , only : init_geometry , communicate_geo_multibox use stella_geometry , only : finish_init_geometry use stella_layouts , only : init_stella_layouts , init_dist_fn_layouts use response_matrix , only : init_response_matrix , read_response_matrix use init_g , only : ginit , init_init_g , phiinit , scale_to_phiinit use init_g , only : tstart use fields , only : init_fields , advance_fields , get_radial_correction , fields_updated use stella_time , only : init_tstart , init_delt use stella_diagnostics , only : init_stella_diagnostics use fields_arrays , only : phi , apar use dist_fn_arrays , only : gnew , gvmu use dist_fn , only : init_gxyz , init_dist_fn use dist_redistribute , only : init_redistribute use time_advance , only : init_time_advance use extended_zgrid , only : init_extended_zgrid use kt_grids , only : init_kt_grids , read_kt_grids_parameters , communicate_ktgrids_multibox use kt_grids , only : naky , nakx , ny , nx , nalpha use vpamu_grids , only : init_vpamu_grids , read_vpamu_grids_parameters use vpamu_grids , only : nvgrid , nmu use stella_transforms , only : init_transforms use stella_save , only : init_dt use multibox , only : read_multibox_parameters , init_multibox , rhoL , rhoR use multibox , only : communicate_multibox_parameters , multibox_communicate use multibox , only : use_dirichlet_BC , apply_radial_boundary_conditions use ran , only : get_rnd_seed_length , init_ranf use dissipation , only : init_dissipation use sources , only : init_sources use volume_averages , only : init_volume_averages , volume_average implicit none !> Starting timestep: zero unless the simulation has been restarted integer , intent ( out ) :: istep0 !> stella version number character ( len =* ), intent ( in ) :: VERNUM !> Release date character ( len = 10 ), intent ( in ) :: VERDATE logical :: exit , list , restarted , needs_transforms character ( 500 ), target :: cbuff integer , dimension (:), allocatable :: seed integer :: i , n , ierr real :: delt_saved , phi2 , rescale !> initialize mpi message passing if (. not . mpi_initialized ) call init_mp mpi_initialized = . true . debug = debug . and . proc0 !> initialize timer if ( debug ) write ( * , * ) 'stella::init_stella::check_time' call checktime ( avail_cpu_time , exit ) if ( proc0 ) then !> write message to screen with useful info regarding start of simulation if ( debug ) write ( * , * ) 'stella::init_stella::write_start_message' call write_start_message ( VERNUM , VERDATE ) !> initialize file i/o if ( debug ) write ( * , * ) 'stella::init_stella::init_file_utils' call init_file_utils ( list ) end if call broadcast ( list ) call broadcast ( runtype_option_switch ) if ( list ) call job_fork !proc0 may have changed debug = debug . and . proc0 if ( proc0 ) then call time_message (. false ., time_total , ' Total' ) call time_message (. false ., time_init , ' Initialization' ) end if if ( proc0 ) cbuff = trim ( run_name ) call broadcast ( cbuff ) if (. not . proc0 ) call init_job_name ( cbuff ) !> read the physics_flags namelist from the input file if ( debug ) write ( 6 , * ) \"stella::init_stella::init_physics_flags\" call init_physics_flags !> read the physics_parameters namelist from the input file if ( debug ) write ( 6 , * ) \"stella::init_stella::init_physics_parameters\" call init_physics_parameters !> read the zgrid_parameters namelist from the input file and setup the z grid if ( debug ) write ( 6 , * ) \"stella::init_stella::init_zgrid\" call init_zgrid !> read the species_knobs namelist from the input file if ( debug ) write ( 6 , * ) \"stella::init_stella::read_species_knobs\" call read_species_knobs !> read the grid option from the kt_grids_knobs namelist in the input file; !> depending on the grid option chosen, read the corresponding kt_grids_XXXX_parameters !> namelist from the input file and allocate some kx and ky arrays if ( debug ) write ( 6 , * ) \"stella::init_stella::read_kt_grids_parameters\" call read_kt_grids_parameters !> read the vpamu_grids_parameters namelist from the input file if ( debug ) write ( 6 , * ) \"stella::init_stella::read_vpamu_grids_parameters\" call read_vpamu_grids_parameters if ( debug ) write ( 6 , * ) \"stella::init_stella::read_multibox_parameters\" call read_multibox_parameters !> setup the various data layouts for the distribution function; !> e.g., vmu_lo is the layout in which vpa, mu and species may be distributed !> amongst processors, depending on the number of phase space points and processors if ( debug ) write ( 6 , * ) \"stella::init_stella::init_dist_fn_layouts\" call init_dist_fn_layouts ( nzgrid , ntubes , naky , nakx , nvgrid , nmu , nspec , ny , nx , nalpha ) !> needs_transforms indicates whether or not FFTs will be needed in the simulation call check_transforms ( needs_transforms ) !> if FFTs are needed, init_transforms sets up the various FFTW plans !> and allocates the necessary arrays if ( needs_transforms ) then if ( debug ) write ( * , * ) \"stella::init_stella::init_transforms\" call init_transforms end if !> read in the geometry option and any necessary magnetic geometry info !> and use it to calculate all of the required geometric coefficients if ( debug ) write ( 6 , * ) \"stella::init_stella::init_geometry\" call init_geometry ( nalpha , naky ) !> read species_parameters from input file and use the info to, e.g., !> determine if a modified Boltzmann response is to be used if ( debug ) write ( 6 , * ) 'stella::init_stella::init_species' call init_species !> read init_g_knobs namelist from the input file !> and prepare for reading in from restart file if requested if ( debug ) write ( 6 , * ) \"stella::init_stella::init_init_g\" call init_init_g !> read knobs namelist from the input file !> and the info to determine the mixture of implicit and explicit time advance if ( debug ) write ( 6 , * ) \"stella::init_stella::init_run_parameters\" call init_run_parameters if ( debug ) write ( 6 , * ) \"stella::init_stella::init_ranf\" n = get_rnd_seed_length () allocate ( seed ( n )) if ( rng_seed < 0 ) then call init_ranf (. true ., seed , job + 2 ) else seed = rng_seed + 37 * ( / ( i - 1 , i = 1 , n ) / ) call init_ranf (. false ., seed , job + 2 ) end if deallocate ( seed ) !> read layouts_knobs namelist from the input file, !> which determines the order of parallelisation within the different layouts if ( debug ) write ( 6 , * ) 'stella::init_stella::init_stella_layouts' call init_stella_layouts !> setup the (kx,ky) grids and (x,y) grids, if applicable if ( debug ) write ( 6 , * ) 'stella::init_stella::init_kt_grids' call init_kt_grids !> MAB: could multibox/radial variation code below be tidied away !> so that only one or two subroutine calls need appear here? if ( debug ) write ( 6 , * ) 'stella::init_stella::init_multibox' call init_multibox if ( proc0 . and . runtype_option_switch == runtype_multibox & . and . ( job == 1 ) . and . radial_variation ) then if ( debug ) write ( 6 , * ) 'stella::init_stella::init_multibox_geo' call communicate_geo_multibox ( rhoL , rhoR ) if ( debug ) write ( 6 , * ) 'stella::init_stella::init_multibox_spec' call communicate_species_multibox ( rhoL , rhoR ) end if if ( runtype_option_switch == runtype_multibox . and . ( job == 1 )) then call communicate_multibox_parameters end if if ( runtype_option_switch == runtype_multibox . and . radial_variation ) then if ( debug ) write ( 6 , * ) 'stella::init_stella::init_multibox_ktgrid' call communicate_ktgrids_multibox end if !> not sure that it needs to be separated from init_geometry, but !> finish_init_geometry deallocates various geometric arrays that !> were defined locally within the millerlocal module when using Miller geometry if ( debug ) write ( 6 , * ) 'stella::init_stella::finish_init_geometry' call finish_init_geometry !> setup the (vpa,mu) grids and associated integration weights if ( debug ) write ( 6 , * ) 'stella::init_stella::init_vpamu_grids' call init_vpamu_grids !> set up all of the logic needed to do calculations on an extended grid in z. !> this extended grid could be due to use of a ballooning angle so that !> z goes from -N*pi to N*pi, or it could be due to the coupling of different !> kx modes arising from the twist-and-shift boundary condition if ( debug ) write ( 6 , * ) 'stella::init_stella::init_extended_zgrid' call init_extended_zgrid !> when doing a volume average using Fourier coefficients, the !> ky=0 mode gets a different weighting than finite ky modes, due !> to the reality condition being imposed; init_volume_averages accounts for this if ( debug ) write ( 6 , * ) 'stella::init_stella::init_volume_averages' call init_volume_averages !> allocates and initialises kperp2, vperp2 and arrays needed !> for gyro-averaging (j0 and j1 or equivalents) if ( debug ) write ( 6 , * ) \"stella::init_stella::init_dist_fn\" call init_dist_fn !> sets up the mappings between different layouts, needed !> to redistribute data when going from one layout to another if ( debug ) write ( 6 , * ) \"stella::init_stella::init_redistribute\" call init_redistribute !> read dissipation namelist from the input file and print information !> about chosen options to stdout if ( debug ) write ( 6 , * ) 'stella::init_stella::init_dissipation' call init_dissipation if ( debug ) write ( 6 , * ) 'stella::init_stella::init_sources' call init_sources !> allocate and initialise time-independent arrays needed to !> solve the field equations; e.g., sum_s (Z_s&#94;2 n_s / T_s)*(1-Gamma0_s) if ( debug ) write ( 6 , * ) 'stella::init_stella::init_fields' call init_fields !> initialise the distribution function in the kxkyz_lo and store in gvmu if ( debug ) write ( 6 , * ) \"stella::init_stella::ginit\" call ginit ( restarted , istep0 ) !> use mapping from kxkyz_lo to vmu_lo to get a copy of g that has ky, kx and z local to each core; !> stored in gnew and copied to gold if ( debug ) write ( 6 , * ) \"stella::init_stella::init_gxyz\" call init_gxyz ( restarted ) !> if initializing from restart file, set the initial time step size appropriately if ( restarted . and . delt_option_switch == delt_option_auto ) then delt_saved = delt if ( debug ) write ( 6 , * ) \"stella::init_stella::init_dt\" call init_dt ( delt_saved , istatus ) if ( istatus == 0 ) delt = delt_saved end if !> set the internal time step size variable code_dt from the input variable delt if ( debug ) write ( 6 , * ) \"stella::init_stella::init_delt\" call init_delt ( delt ) !> allocate and calculate arrays needed for the mirror, parallel streaming, !> magnetic drifts, gradient drive, etc. terms during time advance if ( debug ) write ( 6 , * ) 'stella::init_stella::init_time_advance' call init_time_advance if ( stream_implicit . or . driftkinetic_implicit ) then if ( mat_read ) then if ( debug ) write ( 6 , * ) \"stella::init_stella::read_response_matrix\" call read_response_matrix else if ( debug ) write ( 6 , * ) \"stella::init_stella::init_response_matrix\" call init_response_matrix end if end if !> get initial field from initial distribution function if ( debug ) write ( 6 , * ) 'stella::init_stella::advance_fields' call advance_fields ( gnew , phi , apar , dist = 'gbar' ) if ( radial_variation ) then if ( debug ) write ( 6 , * ) 'stella::init_stella::get_radial_correction' call get_radial_correction ( gnew , phi , dist = 'gbar' ) end if if ( runtype_option_switch == runtype_multibox ) then if ( debug ) write ( 6 , * ) 'stella::init_stella:multibox_communicate' call multibox_communicate ( gnew ) if ( job == 1 ) then fields_updated = . false . call advance_fields ( gnew , phi , apar , dist = 'gbar' ) end if else if ( use_dirichlet_BC ) then if ( debug ) write ( 6 , * ) 'stella::init_stella:multibox_radial_BC' call apply_radial_boundary_conditions ( gnew ) fields_updated = . false . call advance_fields ( gnew , phi , apar , dist = 'gbar' ) end if ! FLAG - the following code should probably go elsewhere if (. not . restarted . and . scale_to_phiinit ) then call volume_average ( phi , phi2 ) if ( runtype_option_switch == runtype_multibox ) then call scope ( crossdomprocs ) call sum_allreduce ( phi2 ) call scope ( subprocs ) phi2 = phi2 / njobs end if rescale = phiinit / sqrt ( phi2 ) phi = rescale * phi gnew = rescale * gnew gvmu = rescale * gvmu end if !> read stella_diagnostics_knob namelist from the input file, !> open ascii output files and initialise the neetcdf file with extension .out.nc if ( debug ) write ( 6 , * ) 'stella::init_stella::init_stella_diagnostics' call init_stella_diagnostics ( restarted , tstart ) !> initialise the code_time if ( debug ) write ( 6 , * ) 'stella::init_stella::init_tstart' call init_tstart ( tstart ) ierr = error_unit () if ( proc0 ) call flush_output_file ( ierr ) !> Add a header to the output file call print_header !> stop the timing of the initialization if ( proc0 ) call time_message (. false ., time_init , ' Initialization' ) end subroutine init_stella !> check_transforms checks the various physics flag choices !> to determine if FFTs are needed for the simulation subroutine check_transforms ( needs_transforms ) use file_utils , only : runtype_option_switch , runtype_multibox use physics_flags , only : nonlinear , include_parallel_nonlinearity use physics_flags , only : radial_variation , full_flux_surface use physics_flags , only : hammett_flow_shear use physics_parameters , only : g_exb , g_exbfac implicit none logical , intent ( out ) :: needs_transforms needs_transforms = . false . !> if ExB or parallel nonlinearity included in the simulations, need FFTs if ( nonlinear . or . include_parallel_nonlinearity ) needs_transforms = . true . !> if 'global' in radial or bi-normal directions, need FFTs if ( radial_variation . or . full_flux_surface ) needs_transforms = . true . !> if running in multibox mode, need FFTs if ( runtype_option_switch == runtype_multibox ) needs_transforms = . true . !> if including flow shear using anything other than wavenumber re-mapping, need FFTs if ( abs ( g_exb * g_exbfac ) > epsilon ( 0. ) . and . . not . hammett_flow_shear ) & needs_transforms = . true . end subroutine check_transforms !> Write the start message to screen subroutine write_start_message ( VERNUM , VERDATE ) use mp , only : proc0 , nproc implicit none !> stella version number character ( len =* ), intent ( in ) :: VERNUM !> Release date character ( len = 10 ), intent ( in ) :: VERDATE character ( len = 23 ) :: str character ( len = 50 ) :: version_format integer :: version_text_length if ( proc0 ) then version_text_length = 60 - ( len ( \"Version \" ) + len_trim ( VERNUM ) + 1 ) write ( version_format , '(\"('' '', \", i2, \"x, ''Version '', a)\")' ) version_text_length / 2 write ( * , * ) ' ' write ( * , * ) ' ' write ( * , * ) \"            I8            ,dPYb, ,dPYb,            \" write ( * , * ) \"            I8            IP'`Yb IP'`Yb            \" write ( * , * ) \"         88888888         I8  8I I8  8I            \" write ( * , * ) \"            I8            I8  8' I8  8'            \" write ( * , * ) \"   ,g,      I8    ,ggg,   I8 dP  I8 dP    ,gggg,gg \" write ( * , * ) \"  ,8'8,     I8   i8' '8i  I8dP   I8dP    dP'  'Y8I \" write ( * , * ) \" ,8'  Yb   ,I8,  I8, ,8I  I8P    I8P    i8'    ,8I \" write ( * , * ) \",8'_   8) ,d88b, `YbadP' ,d8b,_ ,d8b,_ ,d8,   ,d8b,\" write ( * , * ) 'P` \"YY8P8P8P\"\"Y8888P\"Y8888P`\"Y888P`\"Y88P\"Y8888P\"`Y8' write ( * , * ) ' ' write ( * , * ) ' ' write ( * , version_format ) VERNUM write ( * , * ) '                        ' , VERDATE write ( * , * ) ' ' write ( * , * ) '                     The stella team' write ( * , * ) ' ' write ( * , * ) '                   University of Oxford' write ( * , * ) ' ' write ( * , * ) ' ' write ( * , '(A)' ) \"############################################################\" write ( * , '(A)' ) \"                     PARALLEL COMPUTING\" write ( * , '(A)' ) \"############################################################\" if ( nproc == 1 ) then write ( str , '(I10, A)' ) nproc , \" processor.\" write ( * , '(A,A,A)' ) \" Running on \" , adjustl ( trim ( str )) else write ( str , '(I10, A)' ) nproc , \" processors.\" write ( * , '(A,A,A)' ) \" Running on \" , adjustl ( trim ( str )) end if write ( * , * ) end if end subroutine write_start_message subroutine print_header use mp , only : proc0 implicit none if ( proc0 ) then write ( * , '(A)' ) \"############################################################\" write ( * , '(A)' ) \"                OVERVIEW OF THE SIMULATION\" write ( * , '(A)' ) \"############################################################\" write ( * , '(A)' ) \" \" write ( * , '(A)' ) \"    istep       time           dt         |phi|&#94;2\" write ( * , '(A)' ) \"------------------------------------------------------------\" end if end subroutine print_header !> Parse some basic command line arguments. Currently just 'version' and 'help'. !> !> This should be called before anything else, but especially before initialising MPI. subroutine parse_command_line () use git_version , only : get_git_version integer :: arg_count , arg_n integer :: arg_length character ( len = :), allocatable :: argument character ( len =* ), parameter :: endl = new_line ( 'a' ) arg_count = command_argument_count () do arg_n = 0 , arg_count call get_command_argument ( 1 , length = arg_length ) if ( allocated ( argument )) deallocate ( argument ) allocate ( character ( len = arg_length ) :: argument ) call get_command_argument ( 1 , argument ) if (( argument == \"--version\" ) . or . ( argument == \"-v\" )) then write ( * , '(\"stella version \", a)' ) get_git_version () stop else if (( argument == \"--help\" ) . or . ( argument == \"-h\" )) then write ( * , '(a)' ) \"stella [--version|-v] [--help|-h] [input file]\" // endl // endl // & \"stella is a flux tube gyrokinetic code for micro-stability and turbulence \" // & \"simulations of strongly magnetised plasma\" // endl // & \"For more help, see the documentation at https://stellagk.github.io/stella/\" // endl // & \"or create an issue https://github.com/stellaGK/stella/issues/new\" // endl // & endl // & \"  -h, --help     Print this message\" // endl // & \"  -v, --version  Print the stella version\" stop end if end do end subroutine parse_command_line !> Finish a simulation, call the finialisation routines of all modules subroutine finish_stella ( last_call ) use mp , only : finish_mp use mp , only : proc0 use file_utils , only : finish_file_utils use job_manage , only : time_message use physics_parameters , only : finish_physics_parameters use physics_flags , only : finish_physics_flags use run_parameters , only : finish_run_parameters use zgrid , only : finish_zgrid use species , only : finish_species use time_advance , only : time_gke , time_parallel_nl use time_advance , only : finish_time_advance use parallel_streaming , only : time_parallel_streaming use mirror_terms , only : time_mirror use dissipation , only : time_collisions use sources , only : finish_sources , time_sources use init_g , only : finish_init_g use dist_fn , only : finish_dist_fn use dist_redistribute , only : finish_redistribute use fields , only : finish_fields use fields , only : time_field_solve use stella_diagnostics , only : finish_stella_diagnostics use response_matrix , only : finish_response_matrix use stella_geometry , only : finish_geometry use extended_zgrid , only : finish_extended_zgrid use vpamu_grids , only : finish_vpamu_grids use kt_grids , only : finish_kt_grids use volume_averages , only : finish_volume_averages use multibox , only : finish_multibox , time_multibox implicit none logical , intent ( in ), optional :: last_call if ( debug ) write ( * , * ) 'stella::finish_stella::finish_stella_diagnostics' call finish_stella_diagnostics ( istep ) if ( debug ) write ( * , * ) 'stella::finish_stella::finish_response_matrix' call finish_response_matrix if ( debug ) write ( * , * ) 'stella::finish_stella::finish_fields' call finish_fields if ( debug ) write ( * , * ) 'stella::finish_stella::finish_time_advance' call finish_time_advance if ( debug ) write ( * , * ) 'stella::finish_stella::finish_sources' call finish_sources if ( debug ) write ( * , * ) 'stella::finish_stella::finish_volume_averages' call finish_volume_averages if ( debug ) write ( * , * ) 'stella::finish_stella::finish_extended_zgrid' call finish_extended_zgrid if ( debug ) write ( * , * ) 'stella::finish_stella::finish_multibox' call finish_multibox if ( debug ) write ( * , * ) 'stella::finish_stella::finish_dist_fn' call finish_dist_fn if ( debug ) write ( * , * ) 'stella::finish_stella::finish_redistribute' call finish_redistribute if ( debug ) write ( * , * ) 'stella::finish_stella::finish_init_g' call finish_init_g if ( debug ) write ( * , * ) 'stella::finish_stella::finish_vpamu_grids' call finish_vpamu_grids if ( debug ) write ( * , * ) 'stella::finish_stella::finish_kt_grids' call finish_kt_grids if ( debug ) write ( * , * ) 'stella::finish_stella::finish_run_parameters' call finish_run_parameters if ( debug ) write ( * , * ) 'stella::finish_stella::finish_species' call finish_species if ( debug ) write ( * , * ) 'stella::finish_stella::finish_physics_flags' call finish_physics_flags if ( debug ) write ( * , * ) 'stella::finish_stella::finish_physics_parameters' call finish_physics_parameters if ( debug ) write ( * , * ) 'stella::finish_stella::finish_geometry' call finish_geometry if ( debug ) write ( * , * ) 'stella::finish_stella::finish_zgrid' call finish_zgrid if ( debug ) write ( * , * ) 'stella::finish_stella::finish_file_utils' if ( proc0 ) then call finish_file_utils call time_message (. false ., time_total , ' Total' ) write ( * , * ) write ( * , '(A)' ) \"############################################################\" write ( * , '(A)' ) \"                        ELAPSED TIME\" write ( * , '(A)' ) \"############################################################\" write ( * , fmt = 101 ) 'initialization:' , time_init ( 1 ) / 6 0. , 'min' write ( * , fmt = 101 ) 'diagnostics:' , time_diagnostics ( 1 ) / 6 0. , 'min' write ( * , fmt = 101 ) 'fields:' , time_field_solve ( 1 , 1 ) / 6 0. , 'min' write ( * , fmt = 101 ) '(redistribute):' , time_field_solve ( 1 , 2 ) / 6 0. , 'min' write ( * , fmt = 101 ) '(int_dv_g):' , time_field_solve ( 1 , 3 ) / 6 0. , 'min' write ( * , fmt = 101 ) '(get_phi):' , time_field_solve ( 1 , 4 ) / 6 0. , 'min' write ( * , fmt = 101 ) '(phi_adia_elec):' , time_field_solve ( 1 , 5 ) / 6 0. , 'min' write ( * , fmt = 101 ) 'mirror:' , time_mirror ( 1 , 1 ) / 6 0. , 'min' write ( * , fmt = 101 ) '(redistribute):' , time_mirror ( 1 , 2 ) / 6 0. , 'min' write ( * , fmt = 101 ) 'stream:' , time_parallel_streaming ( 1 ) / 6 0. , 'min' write ( * , fmt = 101 ) 'dgdx:' , time_gke ( 1 , 5 ) / 6 0. , 'min' write ( * , fmt = 101 ) 'dgdy:' , time_gke ( 1 , 4 ) / 6 0. , 'min' write ( * , fmt = 101 ) 'wstar:' , time_gke ( 1 , 6 ) / 6 0. , 'min' write ( * , fmt = 101 ) 'collisions:' , time_collisions ( 1 , 1 ) / 6 0. , 'min' write ( * , fmt = 101 ) '(redistribute):' , time_collisions ( 1 , 2 ) / 6 0. , 'min' write ( * , fmt = 101 ) 'sources:' , time_sources ( 1 , 1 ) / 6 0. , 'min' write ( * , fmt = 101 ) '(redistribute):' , time_sources ( 1 , 2 ) / 6 0. , 'min' write ( * , fmt = 101 ) 'ExB nonlin:' , time_gke ( 1 , 7 ) / 6 0. , 'min' write ( * , fmt = 101 ) 'parallel nonlin:' , time_parallel_nl ( 1 , 1 ) / 6 0. , 'min' write ( * , fmt = 101 ) '(redistribute):' , time_parallel_nl ( 1 , 2 ) / 6 0. , 'min' write ( * , fmt = 101 ) 'radial var:' , time_gke ( 1 , 10 ) / 6 0. , 'min' write ( * , fmt = 101 ) 'multibox comm:' , time_multibox ( 1 , 1 ) / 6 0. , 'min' write ( * , fmt = 101 ) 'multibox krook:' , time_multibox ( 1 , 2 ) / 6 0. , 'min' write ( * , fmt = 101 ) 'total implicit: ' , time_gke ( 1 , 9 ) / 6 0. , 'min' write ( * , fmt = 101 ) 'total explicit: ' , time_gke ( 1 , 8 ) / 6 0. , 'min' write ( * , fmt = 101 ) 'total:' , time_total ( 1 ) / 6 0. , 'min' write ( * , * ) end if 101 format ( a17 , 0 pf8 . 2 , a4 ) if ( debug ) write ( * , * ) 'stella::finish_stella::finish_mp' ! finish (clean up) mpi message passing if ( present ( last_call )) then call finish_mp mpi_initialized = . false . end if end subroutine finish_stella ! subroutine test_redistribute !   use stella_layouts, only: kxyz_lo, vmu_lo !   use zgrid, only: nzgrid, ntubes !   use vpamu_grids, only: nvpa, nmu !   use kt_grids, only: ny, ikx_max !   use dist_redistribute, only: kxyz2vmu !   use redistribute, only: scatter !   implicit none !   complex, dimension (:,:,:), allocatable :: g_kxyz_lo !   complex, dimension (:,:,:,:,:), allocatable :: g_vmu_lo !   allocate (g_kxyz_lo(nvpa,nmu,kxyz_lo%llim_proc:kxyz_lo%ulim_alloc)) !   allocate (g_vmu_lo(ny,ikx_max,-nzgrid:nzgrid,ntubes,vmu_lo%llim_proc:vmu_lo%ulim_alloc)) !   g_kxyz_lo = 1.0 !   g_vmu_lo = 2.0 !   call scatter (kxyz2vmu, g_vmu_lo, g_kxyz_lo) !   write (*,*) 'g_vmu_lo', maxval(cabs(g_vmu_lo)), minval(cabs(g_vmu_lo)) !   write (*,*) 'g_kxyz_lo', maxval(cabs(g_kxyz_lo)), minval(cabs(g_kxyz_lo)) !   deallocate (g_vmu_lo, g_kxyz_lo) ! end subroutine test_redistribute end program stella","tags":"","loc":"sourcefile/stella.f90.html"},{"title":"sources.fpp â€“ stella","text":"Contents Modules sources Source Code sources.fpp Source Code module sources #if defined MPI && defined ISO_C_BINDING use mpi #endif implicit none public :: init_sources , finish_sources public :: init_quasineutrality_source public :: init_source_timeaverage public :: update_quasineutrality_source public :: include_qn_source public :: include_krook_operator , update_tcorr_krook public :: remove_zero_projection , project_out_zero public :: add_krook_operator public :: tcorr_source , exclude_boundary_regions , exp_fac public :: int_krook , int_proj public :: qn_source_initialized public :: time_sources private logical :: include_krook_operator , remove_zero_projection logical :: krook_odd , exclude_boundary_regions logical :: from_zero logical :: conserve_momentum , conserve_density integer :: ikxmax_source real :: nu_krook , tcorr_source , int_krook , int_proj real :: exp_fac logical :: qn_source_initialized , include_qn_source logical :: debug = . false . #if defined MPI && defined ISO_C_BINDING logical :: qn_window_initialized = . false . #endif real , dimension ( 2 , 2 ) :: time_sources = 0. contains subroutine init_sources use mp , only : job , proc0 use run_parameters , only : fphi use run_parameters , only : ky_solve_radial , ky_solve_real use kt_grids , only : naky , nakx , zonal_mode use zgrid , only : nzgrid , ntubes use stella_layouts , only : vmu_lo use dist_fn_arrays , only : g_krook , g_proj , g_symm use fields_arrays , only : phi_proj , phi_proj_stage use physics_flags , only : radial_variation use species , only : spec , has_electron_species use physics_flags , only : adiabatic_option_switch use physics_flags , only : adiabatic_option_fieldlineavg use file_utils , only : runtype_option_switch , runtype_multibox implicit none logical :: has_elec , adia_elec real :: fac debug = debug . and . proc0 call read_parameters if ( include_krook_operator . and . . not . allocated ( g_krook )) then allocate ( g_krook ( nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) g_krook = 0. end if if ( remove_zero_projection . and . . not . allocated ( g_proj )) then allocate ( g_proj ( nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) g_proj = 0. end if if (. not . allocated ( phi_proj )) then allocate ( phi_proj ( nakx , - nzgrid : nzgrid , ntubes )); phi_proj = 0. end if if (. not . allocated ( phi_proj_stage )) then allocate ( phi_proj_stage ( nakx , - nzgrid : nzgrid , ntubes )); phi_proj_stage = 0. end if if (( conserve_momentum . or . conserve_density ) . and . . not . allocated ( g_symm )) then allocate ( g_symm ( naky , nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) end if fac = 1. if ( from_zero ) fac = 0. if ( int_krook < 0. ) int_krook = fac * tcorr_source if ( int_proj < 0. ) int_proj = fac * tcorr_source include_qn_source = . false . if ( fphi > epsilon ( 0.0 ) . and . radial_variation . and . ky_solve_radial > 0 ) then has_elec = has_electron_species ( spec ) adia_elec = . not . has_elec . and . zonal_mode ( 1 ) & . and . adiabatic_option_switch == adiabatic_option_fieldlineavg if ( adia_elec ) then if ( runtype_option_switch /= runtype_multibox . or . ( job == 1 . and . . not . ky_solve_real )) then include_qn_source = . true . end if end if end if end subroutine init_sources subroutine read_parameters use file_utils , only : input_unit_exist use physics_flags , only : full_flux_surface , radial_variation use mp , only : proc0 , broadcast use kt_grids , only : ikx_max , periodic_variation use fields_arrays , only : tcorr_source_qn , exclude_boundary_regions_qn implicit none namelist / sources / & include_krook_operator , nu_krook , tcorr_source , remove_zero_projection , & ikxmax_source , krook_odd , exclude_boundary_regions , & tcorr_source_qn , exclude_boundary_regions_qn , from_zero , & conserve_momentum , conserve_density integer :: in_file logical :: dexist if ( proc0 ) then include_krook_operator = . false . exclude_boundary_regions = radial_variation . and . . not . periodic_variation exclude_boundary_regions_qn = exclude_boundary_regions remove_zero_projection = . false . nu_krook = 0.05 tcorr_source = 0.02 tcorr_source_qn = - 1.0 ikxmax_source = 1 ! kx=0 if ( periodic_variation ) ikxmax_source = 2 ! kx=0 and kx=1 krook_odd = . true . ! damp only the odd mode that can affect profiles from_zero = . true . conserve_momentum = . false . conserve_density = . false . in_file = input_unit_exist ( \"sources\" , dexist ) if ( dexist ) read ( unit = in_file , nml = sources ) if ( tcorr_source_qn < 0 ) tcorr_source_qn = tcorr_source end if ikxmax_source = min ( ikxmax_source , ikx_max ) int_proj = - 1. int_krook = - 1. call broadcast ( include_krook_operator ) call broadcast ( exclude_boundary_regions ) call broadcast ( exclude_boundary_regions_qn ) call broadcast ( nu_krook ) call broadcast ( tcorr_source ) call broadcast ( tcorr_source_qn ) call broadcast ( ikxmax_source ) call broadcast ( remove_zero_projection ) call broadcast ( krook_odd ) call broadcast ( from_zero ) call broadcast ( conserve_momentum ) call broadcast ( conserve_density ) end subroutine read_parameters subroutine init_source_timeaverage use stella_time , only : code_dt use fields_arrays , only : tcorr_source_qn , exp_fac_qn implicit none exp_fac = exp ( - code_dt / tcorr_source ) exp_fac_qn = exp ( - code_dt / tcorr_source_qn ) end subroutine init_source_timeaverage subroutine finish_sources use dist_fn_arrays , only : g_krook , g_proj , g_symm use fields_arrays , only : phi_proj , phi_proj_stage #if defined MPI && defined ISO_C_BINDING use fields_arrays , only : qn_zf_window #else use fields_arrays , only : phizf_solve , phi_ext #endif implicit none integer :: ierr if ( allocated ( g_krook )) deallocate ( g_krook ) if ( allocated ( g_proj )) deallocate ( g_proj ) if ( allocated ( g_symm )) deallocate ( g_symm ) if ( allocated ( phi_proj )) deallocate ( phi_proj ) if ( allocated ( phi_proj_stage )) deallocate ( phi_proj_stage ) #if defined MPI && defined ISO_C_BINDING if ( qn_zf_window /= MPI_WIN_NULL ) then call mpi_win_free ( qn_zf_window , ierr ) qn_window_initialized = . false . end if #else if ( associated ( phizf_solve % zloc )) deallocate ( phizf_solve % zloc ) if ( associated ( phizf_solve % idx )) deallocate ( phizf_solve % idx ) if ( associated ( phi_ext )) deallocate ( phi_ext ) #endif end subroutine finish_sources subroutine add_krook_operator ( g , gke_rhs ) use mp , only : proc0 use job_manage , only : time_message use zgrid , only : nzgrid , ntubes use constants , only : pi , zi use kt_grids , only : naky , akx , nakx , zonal_mode , boundary_size use stella_layouts , only : vmu_lo use stella_time , only : code_dt use dist_fn_arrays , only : g_krook , g_symm use stella_transforms , only : transform_kx2x_unpadded , transform_x2kx_unpadded use physics_flags , only : radial_variation implicit none complex :: tmp integer :: ikx , jkx , iz , it , ia , ivmu , npts complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ), target :: g complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: gke_rhs complex , dimension (:, :, :, :, :), pointer :: g_work complex , dimension (:, :), allocatable :: g0k , g0x , g1x real , dimension (:), allocatable :: basis_func ia = 1 if (. not . zonal_mode ( 1 )) return if ( proc0 ) call time_message (. false ., time_sources (:, 1 ), ' sources' ) g_work => g if ( conserve_momentum . or . conserve_density ) then g_work => g_symm g_work = g end if if ( conserve_momentum ) call enforce_momentum_conservation ( g_work ) if ( conserve_density ) call enforce_density_conservation ( g_work ( 1 , :, :, :, :)) if ( exclude_boundary_regions ) then npts = nakx - 2 * boundary_size allocate ( g0k ( 1 , nakx )) allocate ( g0x ( 1 , nakx )) allocate ( g1x ( 1 , nakx )) allocate ( basis_func ( npts )) do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid g0k ( 1 , :) = g_work ( 1 , :, iz , it , ivmu ) g1x = 0. call transform_kx2x_unpadded ( g0k , g0x ) do ikx = 1 , ikxmax_source if ( ikx == 1 ) then basis_func = 1.0 tmp = sum ( g0x ( 1 , ( boundary_size + 1 ):( nakx - boundary_size ))) / real ( npts ) else do jkx = 1 , npts basis_func ( jkx ) = sin ( 2.0 * pi * ( ikx - 1 ) * jkx / real ( npts + 1 )) end do tmp = 2.0 * sum ( basis_func * g0x ( 1 , ( boundary_size + 1 ):( nakx - boundary_size ))) / real ( npts + 1 ) end if if ( tcorr_source > epsilon ( 0.0 )) then tmp = ( code_dt * tmp + exp_fac * int_krook * g_krook ( ikx , iz , it , ivmu )) & / ( code_dt + exp_fac * int_krook ) end if do jkx = 1 , npts g1x ( 1 , boundary_size + jkx ) = g1x ( 1 , boundary_size + jkx ) + tmp * basis_func ( jkx ) end do end do call transform_x2kx_unpadded ( g1x , g0k ) gke_rhs ( 1 , :, iz , it , ivmu ) = gke_rhs ( 1 , :, iz , it , ivmu ) - code_dt * nu_krook * g0k ( 1 , :) end do end do end do deallocate ( g0k , g0x , g1x , basis_func ) else do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid do ikx = 1 , nakx if ( abs ( akx ( ikx )) > akx ( ikxmax_source )) cycle tmp = g_work ( 1 , ikx , iz , it , ivmu ) if ( krook_odd . and . abs ( akx ( ikx )) > epsilon ( 0.0 )) tmp = zi * aimag ( tmp ) if ( tcorr_source <= epsilon ( 0.0 )) then gke_rhs ( 1 , ikx , iz , it , ivmu ) = gke_rhs ( 1 , ikx , iz , it , ivmu ) - code_dt * nu_krook * tmp else gke_rhs ( 1 , ikx , iz , it , ivmu ) = gke_rhs ( 1 , ikx , iz , it , ivmu ) - code_dt * nu_krook & * ( code_dt * tmp + exp_fac * int_krook * g_krook ( ikx , iz , it , ivmu )) & / ( code_dt + exp_fac * int_krook ) end if end do end do end do end do end if if ( proc0 ) call time_message (. false ., time_sources (:, 1 ), ' sources' ) end subroutine add_krook_operator subroutine update_tcorr_krook ( g ) use mp , only : proc0 use job_manage , only : time_message use constants , only : pi , zi use dist_fn_arrays , only : g_krook , g_symm use zgrid , only : nzgrid , ntubes use kt_grids , only : akx , nakx , zonal_mode , boundary_size use stella_layouts , only : vmu_lo use stella_time , only : code_dt use stella_transforms , only : transform_kx2x_unpadded , transform_x2kx_unpadded implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), target , intent ( in ) :: g complex , dimension (:, :), allocatable :: g0k , g0x complex , dimension (:, :, :, :, :), pointer :: g_work integer :: ivmu , iz , it , ikx , jkx , ia , npts real :: int_krook_old complex :: tmp if (. not . zonal_mode ( 1 )) return if ( proc0 ) call time_message (. false ., time_sources (:, 1 ), ' sources' ) ia = 1 g_work => g if ( conserve_momentum . or . conserve_density ) then g_work => g_symm g_work = g end if if ( conserve_momentum ) call enforce_momentum_conservation ( g_work ) if ( conserve_density ) call enforce_density_conservation ( g_work ( 1 , :, :, :, :)) int_krook_old = int_krook int_krook = code_dt + exp_fac * int_krook_old if ( exclude_boundary_regions ) then npts = nakx - 2 * boundary_size allocate ( g0k ( 1 , nakx )) allocate ( g0x ( 1 , nakx )) do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid g0k ( 1 , :) = g_work ( 1 , :, iz , it , ivmu ) call transform_kx2x_unpadded ( g0k , g0x ) do ikx = 1 , ikxmax_source if ( ikx == 1 ) then tmp = sum ( g0x ( 1 , ( boundary_size + 1 ):( nakx - boundary_size ))) / real ( npts ) else tmp = 0. do jkx = 1 , npts tmp = tmp + sin ( 2.0 * pi * ( ikx - 1 ) * jkx / real ( npts + 1 )) * g0x ( 1 , boundary_size + jkx ) end do tmp = 2.0 * tmp / real ( npts + 1 ) end if g_krook ( ikx , iz , it , ivmu ) = ( code_dt * tmp + exp_fac * int_krook_old * g_krook ( ikx , iz , it , ivmu )) & / int_krook end do end do end do end do deallocate ( g0k , g0x ) else do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid do ikx = 1 , nakx tmp = g ( 1 , ikx , iz , it , ivmu ) if ( krook_odd . and . abs ( akx ( ikx )) > epsilon ( 0.0 )) tmp = zi * aimag ( tmp ) g_krook ( ikx , iz , it , ivmu ) = ( code_dt * tmp + exp_fac * int_krook_old * g_krook ( ikx , iz , it , ivmu )) / int_krook end do end do end do end do end if if ( proc0 ) call time_message (. false ., time_sources (:, 1 ), ' sources' ) end subroutine update_tcorr_krook subroutine enforce_momentum_conservation ( g_work ) use mp , only : proc0 use job_manage , only : time_message use redistribute , only : scatter , gather use stella_layouts , only : vmu_lo , kxkyz_lo use stella_layouts , only : imu_idx , is_idx , iv_idx use vpamu_grids , only : nvgrid , nvpa , nmu use dist_redistribute , only : kxkyz2vmu use dist_fn_arrays , only : gvmu use zgrid , only : nzgrid implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( inout ) :: g_work integer :: ikxkyz , imu , iv , iv2 complex :: tmp if ( proc0 ) call time_message (. false ., time_sources (:, 2 ), ' source_redist' ) call scatter ( kxkyz2vmu , g_work , gvmu ) if ( proc0 ) call time_message (. false ., time_sources (:, 2 ), ' source_redist' ) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc do imu = 1 , nmu do iv = 1 , nvgrid iv2 = nvpa - iv + 1 tmp = 0.5 * ( gvmu ( iv , imu , ikxkyz ) + gvmu ( iv2 , imu , ikxkyz )) gvmu ( iv , imu , ikxkyz ) = tmp gvmu ( iv2 , imu , ikxkyz ) = tmp end do end do end do if ( proc0 ) call time_message (. false ., time_sources (:, 2 ), ' source_redist' ) call gather ( kxkyz2vmu , gvmu , g_work ) if ( proc0 ) call time_message (. false ., time_sources (:, 2 ), ' source_redist' ) end subroutine enforce_momentum_conservation subroutine enforce_density_conservation ( g_work ) use mp , only : sum_allreduce use species , only : spec , nspec use physics_flags , only : radial_variation use vpamu_grids , only : integrate_species , mu , vpa , vperp2 use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use kt_grids , only : nakx , rho_d_clamped use stella_layouts , only : vmu_lo , imu_idx , is_idx , iv_idx use stella_geometry , only : bmag , dBdrho , dl_over_b , d_dl_over_b_drho use gyro_averages , only : gyro_average , aj0x , aj1x use dist_fn_arrays , only : kperp2 , dkperp2dr use zgrid , only : nzgrid , ntubes use stella_transforms , only : transform_kx2x_unpadded , transform_x2kx_unpadded implicit none complex , dimension (:, - nzgrid :, :, vmu_lo % llim_proc :), intent ( inout ) :: g_work integer :: ia , ikx , it , iz , imu , iv , ivmu , is complex , dimension (:, :), allocatable :: gyro_g , g0k , g0x complex , dimension (:), allocatable :: g_fsa real :: energy ia = 1 allocate ( gyro_g ( nakx , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) allocate ( g0k ( 1 , nakx )) allocate ( g0x ( 1 , nakx )) allocate ( g_fsa ( nakx )); g_fsa = 0. do it = 1 , ntubes do iz = - nzgrid , nzgrid do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) iv = iv_idx ( vmu_lo , ivmu ) gyro_g (:, ivmu ) = g_work (:, iz , it , ivmu ) * aj0x ( 1 , :, iz , ivmu ) g0k = 0.0 if ( radial_variation ) then g0k ( 1 , :) = gyro_g (:, ivmu ) & * ( - 0.5 * aj1x ( 1 , :, iz , ivmu ) / aj0x ( 1 , :, iz , ivmu ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 ( 1 , :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr ( 1 , :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) & + dBdrho ( iz ) / bmag ( ia , iz )) call transform_kx2x_unpadded ( g0k , g0x ) g0x ( 1 , :) = rho_d_clamped * g0x ( 1 , :) call transform_x2kx_unpadded ( g0x , g0k ) end if gyro_g (:, ivmu ) = gyro_g (:, ivmu ) + g0k ( 1 , :) end do do ikx = 1 , nakx call integrate_species ( gyro_g ( ikx , :), iz , spec % dens_psi0 , g0k ( 1 , ikx ), reduce_in = . false .) end do call sum_allreduce ( g0k ) !we now have delta n. Flux surface average call transform_kx2x_unpadded ( g0k , g0x ) g_fsa = g_fsa + dl_over_b ( ia , iz ) * g0x ( 1 , :) if ( radial_variation ) g_fsa = g_fsa + d_dl_over_b_drho ( ia , iz ) * rho_d_clamped * g0x ( 1 , :) end do end do g_fsa = g_fsa / ntubes do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) iv = iv_idx ( vmu_lo , ivmu ) do it = 1 , ntubes do iz = - nzgrid , nzgrid g0x ( 1 , :) = g_fsa !multiply by f0 g0x ( 1 , :) = g0x ( 1 , :) * maxwell_vpa ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) * maxwell_fac ( is ) if ( radial_variation ) then !variation in the density cancels energy = ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu )) * ( spec ( is )% temp_psi0 / spec ( is )% temp ) g0x ( 1 , :) = g0x ( 1 , :) * ( 1.0 - rho_d_clamped * ( spec ( is )% tprim * ( energy - 1.5 ) + 2. * mu ( imu ) * dBdrho ( iz ))) end if call transform_x2kx_unpadded ( g0x , g0k ) g_work (:, iz , it , ivmu ) = g_work (:, iz , it , ivmu ) - g0k ( 1 , :) end do end do end do deallocate ( gyro_g , g0k , g0x , g_fsa ) end subroutine enforce_density_conservation subroutine project_out_zero ( gold , gnew ) use mp , only : proc0 use job_manage , only : time_message use zgrid , only : nzgrid , ntubes use constants , only : pi , zi use kt_grids , only : zonal_mode , akx , nakx , boundary_size use stella_layouts , only : vmu_lo use stella_time , only : code_dt use dist_fn_arrays , only : g_proj , g_symm use stella_transforms , only : transform_kx2x_unpadded , transform_x2kx_unpadded implicit none complex :: tmp integer :: ikx , jkx , iz , it , ia , ivmu , npts complex , dimension (:, :), allocatable :: g0k , g0x , g1x real , dimension (:), allocatable :: basis_func complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: gold complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( inout ) :: gnew complex , allocatable , dimension (:, :, :, :) :: g ia = 1 if (. not . zonal_mode ( 1 )) return if ( proc0 ) call time_message (. false ., time_sources (:, 1 ), ' sources' ) allocate ( g ( nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) !divide by code_dt to ensure time averaging is performed correctly if ( conserve_momentum ) then g_symm = ( gnew - gold ) / code_dt call enforce_momentum_conservation ( g_symm ) g = g_symm ( 1 , :, :, :, :) else g = ( gnew ( 1 , :, :, :, :) - gold ( 1 , :, :, :, :)) / code_dt end if if ( conserve_density ) call enforce_density_conservation ( g ) if ( exclude_boundary_regions ) then npts = nakx - 2 * boundary_size allocate ( g0k ( 1 , nakx )) allocate ( g0x ( 1 , nakx )) allocate ( g1x ( 1 , nakx )) allocate ( basis_func ( npts )) do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid g0k ( 1 , :) = g (:, iz , it , ivmu ) g1x = 0. call transform_kx2x_unpadded ( g0k , g0x ) do ikx = 1 , ikxmax_source !physical region should have an odd number of collocation points if ( ikx == 1 ) then basis_func = 1.0 tmp = sum ( g0x ( 1 , ( boundary_size + 1 ):( nakx - boundary_size ))) / real ( npts ) else ! here we use a Fourier basis due to periodicity, ! though we could use Legendre polynomials ! NB: Only a constant or linear function (or nearly linear, i.e. first ! sine harmonic) make physical sense as sources, so ikxmax_source <= 2 do jkx = 1 , npts basis_func ( jkx ) = sin ( 2.0 * pi * ( ikx - 1 ) * jkx / real ( npts + 1 )) end do tmp = 2.0 * sum ( basis_func * g0x ( 1 , ( boundary_size + 1 ):( nakx - boundary_size ))) / real ( npts + 1 ) end if if ( tcorr_source > epsilon ( 0. )) then tmp = ( code_dt * tmp + exp_fac * int_proj * g_proj ( ikx , iz , it , ivmu )) & / ( code_dt + exp_fac * int_proj ) g_proj ( ikx , iz , it , ivmu ) = tmp end if do jkx = 1 , npts g1x ( 1 , boundary_size + jkx ) = g1x ( 1 , boundary_size + jkx ) + tmp * basis_func ( jkx ) end do end do call transform_x2kx_unpadded ( g1x , g0k ) g (:, iz , it , ivmu ) = g0k ( 1 , :) end do end do end do deallocate ( g0k , g0x , g1x , basis_func ) else do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid do ikx = 1 , nakx if ( abs ( akx ( ikx )) > akx ( ikxmax_source )) then g ( ikx , iz , it , ivmu ) = 0.0 else tmp = g ( ikx , iz , it , ivmu ) if ( krook_odd . and . abs ( akx ( ikx )) > epsilon ( 0.0 )) tmp = zi * aimag ( tmp ) if ( tcorr_source <= epsilon ( 0. )) then g ( ikx , iz , it , ivmu ) = tmp else g ( ikx , iz , it , ivmu ) = ( code_dt * tmp + exp_fac * int_proj * g_proj ( ikx , iz , it , ivmu )) & / ( code_dt + exp_fac * int_proj ) end if end if if ( krook_odd . and . abs ( akx ( ikx )) > epsilon ( 0.0 )) then g_proj ( ikx , iz , it , ivmu ) = zi * aimag ( g ( ikx , iz , it , ivmu )) else g_proj ( ikx , iz , it , ivmu ) = g ( ikx , iz , it , ivmu ) end if end do end do end do end do end if int_proj = code_dt + exp_fac * int_proj gnew ( 1 , :, :, :, :) = gnew ( 1 , :, :, :, :) - code_dt * g deallocate ( g ) if ( proc0 ) call time_message (. false ., time_sources (:, 1 ), ' sources' ) end subroutine project_out_zero subroutine init_quasineutrality_source #if defined MPI && defined ISO_C_BINDING use , intrinsic :: iso_c_binding , only : c_ptr , c_f_pointer use fields_arrays , only : qn_zf_window use mp , only : sgproc0 , curr_focus , mp_comm , sharedsubprocs , comm_sgroup use mp , only : scope , real_size , nbytes_real use mp_lu_decomposition , only : lu_decomposition_local , lu_inverse_local use mpi #endif use physics_flags , only : radial_variation use stella_geometry , only : dl_over_b , d_dl_over_b_drho use stella_transforms , only : transform_kx2x_unpadded , transform_x2kx_unpadded use zgrid , only : nzgrid , nztot use kt_grids , only : naky , nakx , rho_d_clamped , boundary_size use linear_solve , only : lu_decomposition use fields_arrays , only : phizf_solve , c_mat , theta , phi_ext use fields_arrays , only : tcorr_source_qn , exclude_boundary_regions_qn , exp_fac_qn implicit none integer :: iz , ikx , ia , jkx , jz integer :: inmat , jnmat , nmat_zf real :: dum #if defined MPI && ISO_C_BINDING integer :: prior_focus , ierr , temp_window integer :: disp_unit = 1 integer * 8 :: cur_pos integer ( kind = MPI_ADDRESS_KIND ) :: win_size type ( c_ptr ) :: cptr complex , dimension (:, :), pointer :: temp_mat #endif complex , dimension (:, :), allocatable :: g0k , g0x , g1k ia = 1 if ( qn_source_initialized ) return qn_source_initialized = . true . if ( include_qn_source ) then nmat_zf = nakx * ( nztot - 1 ) #if defined MPI && ISO_C_BINDING if ((. not . qn_window_initialized ) . or . ( qn_zf_window == MPI_WIN_NULL )) then prior_focus = curr_focus call scope ( sharedsubprocs ) win_size = 0 if ( sgproc0 ) then win_size = int ( nmat_zf , MPI_ADDRESS_KIND ) * 4_MPI_ADDRESS_KIND & + int ( nmat_zf * ( nmat_zf + 1 ), MPI_ADDRESS_KIND ) * 2 * real_size !complex size end if if ( debug ) write ( 6 , * ) 'sources::init_quasineutrality_source::win_allocate' call mpi_win_allocate_shared ( win_size , disp_unit , MPI_INFO_NULL , & mp_comm , cptr , qn_zf_window , ierr ) if (. not . sgproc0 ) then !make sure all the procs have the right memory address call mpi_win_shared_query ( qn_zf_window , 0 , win_size , disp_unit , cptr , ierr ) end if call mpi_win_fence ( 0 , qn_zf_window , ierr ) cur_pos = transfer ( cptr , cur_pos ) !allocate the memory if (. not . associated ( phizf_solve % zloc )) then cptr = transfer ( cur_pos , cptr ) call c_f_pointer ( cptr , phizf_solve % zloc , ( / nmat_zf , nmat_zf / )) end if cur_pos = cur_pos + nmat_zf ** 2 * 2 * nbytes_real if (. not . associated ( phi_ext )) then cptr = transfer ( cur_pos , cptr ) call c_f_pointer ( cptr , phi_ext , ( / nmat_zf / )) end if cur_pos = cur_pos + nmat_zf * 2 * nbytes_real if (. not . associated ( phizf_solve % idx )) then cptr = transfer ( cur_pos , cptr ) call c_f_pointer ( cptr , phizf_solve % idx , ( / nmat_zf / )) end if call mpi_win_fence ( 0 , qn_zf_window , ierr ) call scope ( prior_focus ) qn_window_initialized = . true . end if #else if ( debug ) write ( 6 , * ) 'sources::init_quasineutrality_source::allocate_phizf' if (. not . associated ( phizf_solve % zloc )) allocate ( phizf_solve % zloc ( nmat_zf , nmat_zf )) if (. not . associated ( phizf_solve % idx )) allocate ( phizf_solve % idx ( nmat_zf )) if (. not . associated ( phi_ext )) allocate ( phi_ext ( nmat_zf )) #endif #if defined MPI && ISO_C_BINDING if ( sgproc0 ) then #endif allocate ( g0k ( 1 , nakx )) allocate ( g0x ( 1 , nakx )) allocate ( g1k ( 1 , nakx )) phizf_solve % zloc = 0. !get the big matrix do jz = - nzgrid , nzgrid - 1 do jkx = 1 , nakx jnmat = jkx + nakx * ( jz + nzgrid ) ! C.phi do ikx = 1 , nakx inmat = ikx + nakx * ( jz + nzgrid ) phizf_solve % zloc ( inmat , jnmat ) = phizf_solve % zloc ( inmat , jnmat ) + c_mat ( ikx , jkx ) end do ! -C.<phi>_\\psi g0k = 0.0 ; g0k ( 1 , jkx ) = 1.0 call transform_kx2x_unpadded ( g0k , g0x ) g0x ( 1 , :) = ( dl_over_b ( ia , jz ) + d_dl_over_b_drho ( ia , jz ) * rho_d_clamped ) * g0x ( 1 , :) call transform_x2kx_unpadded ( g0x , g0k ) !set the gauge potential if ( jkx == 1 ) g0k ( 1 , 1 ) = 0. do ikx = 1 , nakx g1k ( 1 , ikx ) = sum ( c_mat ( ikx , :) * g0k ( 1 , :)) end do do iz = - nzgrid , nzgrid - 1 do ikx = 1 , nakx inmat = ikx + nakx * ( iz + nzgrid ) phizf_solve % zloc ( inmat , jnmat ) = phizf_solve % zloc ( inmat , jnmat ) - g1k ( 1 , ikx ) end do end do ! get theta.phi g1k ( 1 , :) = theta (:, jkx , jz ) ! +theta.phi do ikx = 1 , nakx inmat = ikx + nakx * ( jz + nzgrid ) phizf_solve % zloc ( inmat , jnmat ) = phizf_solve % zloc ( inmat , jnmat ) + g1k ( 1 , ikx ) end do ! -<<theta.phi>_psi>_T call transform_kx2x_unpadded ( g1k , g0x ) g0x ( 1 , :) = ( dl_over_b ( ia , jz ) + d_dl_over_b_drho ( ia , jz ) * rho_d_clamped ) * g0x ( 1 , :) if ( exclude_boundary_regions_qn ) then g0x ( 1 , :) = sum ( g0x ( 1 , ( boundary_size + 1 ):( nakx - boundary_size ))) & / ( nakx - 2 * boundary_size ) g0x ( 1 , 1 : boundary_size ) = 0.0 g0x ( 1 , ( nakx - boundary_size + 1 ):) = 0.0 else g0x ( 1 , :) = sum ( g0x ( 1 , :)) / nakx end if call transform_x2kx_unpadded ( g0x , g0k ) if ( tcorr_source_qn > epsilon ( 0. )) then g0k = ( 1. - exp_fac_qn ) * g0k end if do iz = - nzgrid , nzgrid - 1 do ikx = 1 , nakx inmat = ikx + nakx * ( iz + nzgrid ) phizf_solve % zloc ( inmat , jnmat ) = phizf_solve % zloc ( inmat , jnmat ) & - g0k ( 1 , ikx ) end do end do end do end do deallocate ( g0k , g1k , g0x ) #if defined MPI && ISO_C_BINDING end if call mpi_win_fence ( 0 , qn_zf_window , ierr ) if ( debug ) write ( 6 , * ) 'sources::init_quasineutrality_source::lu_decomposition' call lu_decomposition_local ( comm_sgroup , 0 , qn_zf_window , & phizf_solve % zloc , phizf_solve % idx , dum ) call mpi_win_fence ( 0 , qn_zf_window , ierr ) if ( debug ) write ( 6 , * ) 'sources::init_quasineutrality_source::temp_mat' call scope ( sharedsubprocs ) win_size = 0 if ( sgproc0 ) then win_size = int ( nmat_zf ** 2 , MPI_ADDRESS_KIND ) * 2 * real_size !complex size end if if ( debug ) write ( 6 , * ) 'sources::init_quasineutrality_source::win_allocate' call mpi_win_allocate_shared ( win_size , disp_unit , MPI_INFO_NULL , & mp_comm , cptr , temp_window , ierr ) if (. not . sgproc0 ) then !make sure all the procs have the right memory address call mpi_win_shared_query ( temp_window , 0 , win_size , disp_unit , cptr , ierr ) end if call mpi_win_fence ( 0 , temp_window , ierr ) !DSO - not sure if this fence is necessary call c_f_pointer ( cptr , temp_mat , ( / nmat_zf , nmat_zf / )) if ( sgproc0 ) temp_mat = phizf_solve % zloc call mpi_win_fence ( 0 , temp_window , ierr ) call scope ( prior_focus ) ! inverse is calculated since it is more straightforward to parallelize ! inverse calculation/matrix multiplication than the lu back substitution if ( debug ) write ( 6 , * ) 'sources::init_quasineutrality_source::lu_inverse' call lu_inverse_local ( comm_sgroup , qn_zf_window , & temp_mat , phizf_solve % idx , phizf_solve % zloc ) call mpi_win_free ( temp_window , ierr ) #else if ( debug ) write ( 6 , * ) 'sources::init_quasineutrality_source::lu_decomposition' call lu_decomposition ( phizf_solve % zloc , phizf_solve % idx , dum ) #endif end if end subroutine init_quasineutrality_source subroutine update_quasineutrality_source use fields_arrays , only : phi_proj , phi_proj_stage use fields_arrays , only : tcorr_source_qn , exp_fac_qn implicit none if ( tcorr_source_qn < epsilon ( 0. )) then phi_proj = phi_proj_stage else phi_proj = exp_fac_qn * phi_proj + ( 1. - exp_fac_qn ) * phi_proj_stage end if end subroutine update_quasineutrality_source end module sources","tags":"","loc":"sourcefile/sources.fpp.html"},{"title":"mirror_terms.f90 â€“ stella","text":"Contents Modules mirror_terms Source Code mirror_terms.f90 Source Code module mirror_terms implicit none public :: mirror_initialized public :: init_mirror , finish_mirror public :: mirror public :: advance_mirror_explicit , advance_mirror_implicit public :: add_mirror_radial_variation public :: time_mirror private !  interface checksum !     module procedure checksum_field !     module procedure checksum_dist !  end interface logical :: mirror_initialized = . false . real , dimension ( 2 , 2 ) :: time_mirror = 0. integer , dimension (:, :), allocatable :: mirror_sign real , dimension (:, :, :, :), allocatable :: mirror real , dimension (:, :, :, :), allocatable :: mirror_rad_var real , dimension (:, :, :), allocatable :: mirror_tri_a , mirror_tri_b , mirror_tri_c real , dimension (:, :, :), allocatable :: mirror_int_fac real , dimension (:, :, :, :), allocatable :: mirror_interp_loc integer , dimension (:, :, :, :), allocatable :: mirror_interp_idx_shift contains subroutine init_mirror use stella_time , only : code_dt use species , only : spec , nspec use vpamu_grids , only : nmu use vpamu_grids , only : mu use zgrid , only : nzgrid , nztot use kt_grids , only : nalpha use stella_geometry , only : dbdzed , b_dot_grad_z , gfac use stella_geometry , only : d2Bdrdth , dgradpardrho use neoclassical_terms , only : include_neoclassical_terms use neoclassical_terms , only : dphineo_dzed use run_parameters , only : mirror_implicit , mirror_semi_lagrange use physics_flags , only : include_mirror , radial_variation implicit none integer :: iz , ia , imu real , dimension (:, :), allocatable :: neoclassical_term if ( mirror_initialized ) return mirror_initialized = . true . if (. not . allocated ( mirror )) allocate ( mirror ( nalpha , - nzgrid : nzgrid , nmu , nspec )); mirror = 0. if (. not . allocated ( mirror_sign )) allocate ( mirror_sign ( nalpha , - nzgrid : nzgrid )); mirror_sign = 0 allocate ( neoclassical_term ( - nzgrid : nzgrid , nspec )) if ( include_neoclassical_terms ) then neoclassical_term = spread ( dphineo_dzed ( 1 , :), 2 , nspec ) * spread ( spec % zt_psi0 , 1 , nztot ) * 0.5 else neoclassical_term = 0. end if !> mirror has sign consistent with being on RHS of GKE; !> it is the factor multiplying dg/dvpa in the mirror term if ( include_mirror ) then do imu = 1 , nmu do ia = 1 , nalpha do iz = - nzgrid , nzgrid mirror ( ia , iz , imu , :) = code_dt * spec % stm_psi0 * b_dot_grad_z ( ia , iz ) & * ( mu ( imu ) * dbdzed ( ia , iz ) + neoclassical_term ( iz , :)) end do end do end do else mirror = 0. end if deallocate ( neoclassical_term ) if ( radial_variation ) then if (. not . allocated ( mirror_rad_var )) then allocate ( mirror_rad_var ( nalpha , - nzgrid : nzgrid , nmu , nspec )); mirror_rad_var = 0. end if !FLAG should include neoclassical corrections here? do imu = 1 , nmu do ia = 1 , nalpha do iz = - nzgrid , nzgrid mirror_rad_var ( ia , iz , imu , :) = code_dt * spec % stm_psi0 * mu ( imu ) * gfac & * ( dgradpardrho ( iz ) * dbdzed ( ia , iz ) & + b_dot_grad_z ( ia , iz ) * d2Bdrdth ( iz )) end do end do end do end if do ia = 1 , nalpha !> mirror_sign set to +/- 1 depending on the sign of the mirror term. !> NB: mirror_sign = -1 corresponds to positive advection velocity do iz = - nzgrid , nzgrid mirror_sign ( ia , iz ) = int ( sign ( 1.0 , mirror ( ia , iz , 1 , 1 ))) end do end do if ( mirror_implicit ) then if ( mirror_semi_lagrange ) then call init_mirror_semi_lagrange else !> set up the tridiagonal matrix that must be inverted !> for the implicit treatment of the mirror operator call init_invert_mirror_operator end if end if end subroutine init_mirror subroutine init_mirror_semi_lagrange use zgrid , only : nzgrid use vpamu_grids , only : nmu , dvpa use species , only : nspec use kt_grids , only : nalpha implicit none if (. not . allocated ( mirror_interp_idx_shift )) & allocate ( mirror_interp_idx_shift ( nalpha , - nzgrid : nzgrid , nmu , nspec )) if (. not . allocated ( mirror_interp_loc )) & allocate ( mirror_interp_loc ( nalpha , - nzgrid : nzgrid , nmu , nspec )) mirror_interp_idx_shift = int ( mirror / dvpa ) mirror_interp_loc = abs ( mod ( mirror , dvpa )) / dvpa ! f at shifted vpa ! is f(iv+idx_shift)*(1-mirror_interp_loc) ! + f(iv+idx_shift + mirror_sign)*mirror_interp_loc end subroutine init_mirror_semi_lagrange subroutine init_invert_mirror_operator use mp , only : mp_abort use stella_layouts , only : kxkyz_lo , kxyz_lo , vmu_lo use stella_layouts , only : iz_idx , is_idx , imu_idx , iv_idx , iy_idx use zgrid , only : nzgrid use vpamu_grids , only : dvpa , vpa , mu use vpamu_grids , only : nvpa , nmu use physics_flags , only : full_flux_surface use species , only : spec use kt_grids , only : nalpha use stella_geometry , only : dbdzed use neoclassical_terms , only : include_neoclassical_terms use neoclassical_terms , only : dphineo_dzed use run_parameters , only : vpa_upwind , time_upwind implicit none integer :: sgn integer :: iy , iz , is , imu , iv integer :: ivmu , ikxkyz , ikxyz integer :: llim , ulim real :: tupwndfac , zero real , dimension (:, :), allocatable :: a , b , c zero = 10 0. * epsilon ( 0. ) !> mirror_int_fac = exp(vpa&#94;2 * (mu*dB/dz)/(mu*dB/dz + Z*e*dpihnc/dz)) !> is the integrating factor needed to turn the dg/dvpa part of the GKE advance !> into an advection equation if (. not . allocated ( mirror_int_fac )) then if ( include_neoclassical_terms ) then allocate ( mirror_int_fac ( nalpha , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) do iy = 1 , nalpha where ( abs ( mu ( imu ) * dbdzed ( iy , :)) > zero ) mirror_int_fac ( iy , :, ivmu ) = exp ( vpa ( iv ) ** 2 * mu ( imu ) * dbdzed ( iy , :) & / ( mu ( imu ) * dbdzed ( iy , :) + spec ( is )% zt_psi0 * dphineo_dzed ( 1 , :) * 0.5 )) elsewhere mirror_int_fac ( iy , :, ivmu ) = 1.0 end where end do end do else ! mirror_int_fac should never be used in this case allocate ( mirror_int_fac ( 1 , 1 , 1 )); mirror_int_fac = 0. end if end if !> a, b and c contain the sub-, main- and super-diagonal terms, respectively allocate ( a ( nvpa , - 1 : 1 )); a = 0. allocate ( b ( nvpa , - 1 : 1 )); b = 0. allocate ( c ( nvpa , - 1 : 1 )); c = 0. if (. not . allocated ( mirror_tri_a )) then !> if running in full-flux-surface mode, solve mirror advance !> in y-space rather than ky-space due to alpha-dependence of coefficients if ( full_flux_surface ) then llim = kxyz_lo % llim_proc ulim = kxyz_lo % ulim_alloc else llim = kxkyz_lo % llim_proc ulim = kxkyz_lo % ulim_alloc end if allocate ( mirror_tri_a ( nvpa , nmu , llim : ulim )); mirror_tri_a = 0. allocate ( mirror_tri_b ( nvpa , nmu , llim : ulim )); mirror_tri_b = 0. allocate ( mirror_tri_c ( nvpa , nmu , llim : ulim )); mirror_tri_c = 0. end if !> corresponds to sign of mirror term positive on RHS of equation a ( 2 :, 1 ) = - 0.5 * ( 1.0 - vpa_upwind ) / dvpa b ( 2 :, 1 ) = - vpa_upwind / dvpa c ( 2 : nvpa - 1 , 1 ) = 0.5 * ( 1.0 + vpa_upwind ) / dvpa !> must treat boundary carefully !> treatment of boundary seems inconsistent !> implicit piece below is pure upwind, while !> explicit piece in fd_variable_upwind_vpa is mixed !> with assumed zero BC at extremes in both +/- vpa b ( 1 , 1 ) = - 1.0 / dvpa c ( 1 , 1 ) = 1.0 / dvpa !> corresponds to sign of mirror term negative on RHS of equation a ( 2 : nvpa - 1 , - 1 ) = - 0.5 * ( 1.0 + vpa_upwind ) / dvpa b (: nvpa - 1 , - 1 ) = vpa_upwind / dvpa c (: nvpa - 1 , - 1 ) = 0.5 * ( 1.0 - vpa_upwind ) / dvpa !> must treat boundary carefully a ( nvpa , - 1 ) = - 1.0 / dvpa b ( nvpa , - 1 ) = 1. / dvpa !> time_upwind = 0.0 corresponds to centered in time !> time_upwind = 1.0 corresponds to fully implicit (upwinded) tupwndfac = 0.5 * ( 1.0 + time_upwind ) a = a * tupwndfac c = c * tupwndfac ! NB: b must be treated a bit differently -- see below if ( full_flux_surface ) then !> account for fact that we have expanded d(gnorm)/dvpa, where gnorm = g/exp(-v&#94;s); !> this gives rise to d(gnorm*exp(-vpa&#94;2))/dvpa + 2*vpa*gnorm*exp(-vpa&#94;2) term !> we solve for gnorm*exp(-vpa&#94;2) and later multiply by exp(vpa&#94;2) to get gnorm b = b + spread ( 2.0 * vpa , 2 , 3 ) do ikxyz = kxyz_lo % llim_proc , kxyz_lo % ulim_proc iy = iy_idx ( kxyz_lo , ikxyz ) iz = iz_idx ( kxyz_lo , ikxyz ) is = is_idx ( kxyz_lo , ikxyz ) sgn = mirror_sign ( iy , iz ) do imu = 1 , nmu do iv = 1 , nvpa mirror_tri_a ( iv , imu , ikxyz ) = - a ( iv , sgn ) * mirror ( iy , iz , imu , is ) mirror_tri_b ( iv , imu , ikxyz ) = 1.0 - b ( iv , sgn ) * mirror ( iy , iz , imu , is ) * tupwndfac mirror_tri_c ( iv , imu , ikxyz ) = - c ( iv , sgn ) * mirror ( iy , iz , imu , is ) end do end do end do else !> multiply by mirror coefficient do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iy = 1 iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) sgn = mirror_sign ( iy , iz ) do imu = 1 , nmu do iv = 1 , nvpa mirror_tri_a ( iv , imu , ikxkyz ) = - a ( iv , sgn ) * mirror ( iy , iz , imu , is ) mirror_tri_b ( iv , imu , ikxkyz ) = 1.0 - b ( iv , sgn ) * mirror ( iy , iz , imu , is ) * tupwndfac mirror_tri_c ( iv , imu , ikxkyz ) = - c ( iv , sgn ) * mirror ( iy , iz , imu , is ) end do end do end do end if deallocate ( a , b , c ) end subroutine init_invert_mirror_operator !> advance_mirror_explicit calculates the contribution to the RHS of the gyrokinetic equation !> due to the mirror force term; it treats all terms explicitly in time subroutine advance_mirror_explicit ( g , gout ) use mp , only : proc0 use redistribute , only : gather , scatter use dist_fn_arrays , only : gvmu use job_manage , only : time_message use stella_layouts , only : kxyz_lo , kxkyz_lo , vmu_lo use stella_layouts , only : iv_idx , is_idx use stella_transforms , only : transform_ky2y use zgrid , only : nzgrid , ntubes use physics_flags , only : full_flux_surface use kt_grids , only : nakx , naky , naky_all , ny , ikx_max use kt_grids , only : swap_kxky use vpamu_grids , only : nvpa , nmu use vpamu_grids , only : vpa , maxwell_vpa use run_parameters , only : fields_kxkyz use dist_redistribute , only : kxkyz2vmu , kxyz2vmu implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: gout complex , dimension (:, :, :), allocatable :: g0v complex , dimension (:, :, :, :, :), allocatable :: g0x complex , dimension (:, :), allocatable :: dgdv , g_swap integer :: ikxyz , iz , it integer :: ivmu , iv , imu , is !> start the timer for this subroutine if ( proc0 ) call time_message (. false ., time_mirror (:, 1 ), ' Mirror advance' ) if ( full_flux_surface ) then !> assume we are simulating a single flux surface it = 1 allocate ( g0v ( nvpa , nmu , kxyz_lo % llim_proc : kxyz_lo % ulim_alloc )) allocate ( g0x ( ny , ikx_max , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) allocate ( dgdv ( nvpa , nmu )) allocate ( g_swap ( naky_all , ikx_max )) do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do iz = - nzgrid , nzgrid !> swap from ky >= 0 and all kx to kx >= 0 and all ky !> needed for ky2y transform below call swap_kxky ( g (:, :, iz , it , ivmu ), g_swap ) !> for upwinding of vpa, need to evaluate dg/dvpa in y-space !> this is necessary because the advection speed contains dB/dz, which depends on y !> first must take g(ky,kx) and transform to g(y,kx) call transform_ky2y ( g_swap , g0x (:, :, iz , it , ivmu )) end do end do !> remap g so velocities are local call scatter ( kxyz2vmu , g0x , g0v ) !> next, calculate dg/dvpa; !> we enforce a boundary condition on <f>, but with full_flux_surface = T, !> g = <f> / F, so we use the chain rule to get two terms: !> one with exp(vpa&#94;2)*d<f>/dvpa and another that is proportional to exp(vpa&#94;2) * <f>/F * d ln F /dvpa do ikxyz = kxyz_lo % llim_proc , kxyz_lo % ulim_proc is = is_idx ( kxyz_lo , ikxyz ) !> remove exp(-vpa&#94;2) normalisation from g before differentiating do imu = 1 , nmu dgdv (:, imu ) = g0v (:, imu , ikxyz ) * maxwell_vpa (:, is ) end do !> get d <f> / dvpa call get_dgdvpa_ffs ( dgdv , ikxyz ) do iv = 1 , nvpa g0v ( iv , :, ikxyz ) = dgdv ( iv , :) / maxwell_vpa ( iv , is ) + 2.0 * vpa ( iv ) * g0v ( iv , :, ikxyz ) end do end do !> then take the results and remap again so y,kx,z local. call gather ( kxyz2vmu , g0v , g0x ) !> finally add the mirror term to the RHS of the GK eqn call add_mirror_term_ffs ( g0x , gout ) deallocate ( dgdv , g_swap ) else allocate ( g0v ( nvpa , nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) allocate ( g0x ( naky , nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) if (. not . fields_kxkyz ) then if ( proc0 ) call time_message (. false ., time_mirror (:, 2 ), ' mirror_redist' ) call scatter ( kxkyz2vmu , g , gvmu ) if ( proc0 ) call time_message (. false ., time_mirror (:, 2 ), ' mirror_redist' ) end if ! get dg/dvpa and store in g0v g0v = gvmu call get_dgdvpa_explicit ( g0v ) ! swap layouts so that (z,kx,ky) are local if ( proc0 ) call time_message (. false ., time_mirror (:, 2 ), ' mirror_redist' ) call gather ( kxkyz2vmu , g0v , g0x ) if ( proc0 ) call time_message (. false ., time_mirror (:, 2 ), ' mirror_redist' ) ! get mirror term and add to source call add_mirror_term ( g0x , gout ) end if deallocate ( g0x , g0v ) if ( proc0 ) call time_message (. false ., time_mirror (:, 1 ), ' Mirror advance' ) end subroutine advance_mirror_explicit subroutine add_mirror_radial_variation ( g , gout ) use mp , only : proc0 use redistribute , only : gather , scatter use dist_fn_arrays , only : gvmu use job_manage , only : time_message use stella_layouts , only : kxkyz_lo , vmu_lo use stella_layouts , only : is_idx , imu_idx use zgrid , only : nzgrid , ntubes use physics_flags , only : full_flux_surface use vpamu_grids , only : nvpa , nmu use run_parameters , only : fields_kxkyz use dist_redistribute , only : kxkyz2vmu implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: gout complex , dimension (:, :, :), allocatable :: g0v integer :: iz , it , imu , is , ivmu , ia allocate ( g0v ( nvpa , nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) !if (proc0) call time_message(.false.,time_mirror(:,1),' Mirror global variation advance') ia = 1 ! the mirror term is most complicated of all when doing full flux surface if ( full_flux_surface ) then ! FLAG DSO - Someday one should be able to do full global else if (. not . fields_kxkyz ) then if ( proc0 ) call time_message (. false ., time_mirror (:, 2 ), ' mirror_redist' ) call scatter ( kxkyz2vmu , g , gvmu ) if ( proc0 ) call time_message (. false ., time_mirror (:, 2 ), ' mirror_redist' ) end if ! get dg/dvpa and store in g0v g0v = gvmu call get_dgdvpa_explicit ( g0v ) ! swap layouts so that (z,kx,ky) are local if ( proc0 ) call time_message (. false ., time_mirror (:, 2 ), ' mirror_redist' ) call gather ( kxkyz2vmu , g0v , gout ) if ( proc0 ) call time_message (. false ., time_mirror (:, 2 ), ' mirror_redist' ) ! get mirror term and add to source do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) do it = 1 , ntubes do iz = - nzgrid , nzgrid gout (:, :, iz , it , ivmu ) = gout (:, :, iz , it , ivmu ) & * mirror_rad_var ( ia , iz , imu , is ) end do end do end do end if deallocate ( g0v ) !if (proc0) call time_message(.false.,time_mirror(:,1),' Mirror global variation advance') end subroutine add_mirror_radial_variation subroutine get_dgdvpa_ffs ( g , ikxyz ) use finite_differences , only : third_order_upwind use stella_layouts , only : kxyz_lo , iz_idx , iy_idx , is_idx use vpamu_grids , only : nvpa , nmu , dvpa implicit none complex , dimension (:, :), intent ( in out ) :: g integer , intent ( in ) :: ikxyz integer :: imu , iz , iy , is complex , dimension (:), allocatable :: tmp allocate ( tmp ( nvpa )) iz = iz_idx ( kxyz_lo , ikxyz ) iy = iy_idx ( kxyz_lo , ikxyz ) is = is_idx ( kxyz_lo , ikxyz ) do imu = 1 , nmu ! tmp is dg/dvpa call third_order_upwind ( 1 , g (:, imu ), dvpa , mirror_sign ( iy , iz ), tmp ) g (:, imu ) = tmp end do deallocate ( tmp ) end subroutine get_dgdvpa_ffs subroutine get_dgdvpa_explicit ( g ) use finite_differences , only : third_order_upwind use stella_layouts , only : kxkyz_lo , iz_idx , is_idx use vpamu_grids , only : nvpa , nmu , dvpa implicit none complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( in out ) :: g integer :: ikxkyz , imu , iz , is complex , dimension (:), allocatable :: tmp allocate ( tmp ( nvpa )) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) do imu = 1 , nmu call third_order_upwind ( 1 , g (:, imu , ikxkyz ), dvpa , mirror_sign ( 1 , iz ), tmp ) g (:, imu , ikxkyz ) = tmp end do end do deallocate ( tmp ) end subroutine get_dgdvpa_explicit subroutine add_mirror_term ( g , src ) use stella_layouts , only : vmu_lo use stella_layouts , only : imu_idx , is_idx use zgrid , only : nzgrid , ntubes use kt_grids , only : nakx implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: src integer :: imu , is , ivmu integer :: it , iz , ikx do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) do it = 1 , ntubes do iz = - nzgrid , nzgrid do ikx = 1 , nakx src (:, ikx , iz , it , ivmu ) = src (:, ikx , iz , it , ivmu ) + mirror ( 1 , iz , imu , is ) * g (:, ikx , iz , it , ivmu ) end do end do end do end do end subroutine add_mirror_term subroutine add_mirror_term_ffs ( g , src ) use stella_layouts , only : vmu_lo use stella_layouts , only : imu_idx , is_idx use zgrid , only : nzgrid , ntubes use kt_grids , only : ikx_max implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: src integer :: imu , is , ivmu integer :: it , iz , ikx do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) do it = 1 , ntubes do iz = - nzgrid , nzgrid do ikx = 1 , ikx_max src (:, ikx , iz , it , ivmu ) = src (:, ikx , iz , it , ivmu ) + mirror (:, iz , imu , is ) * g (:, ikx , iz , it , ivmu ) end do end do end do end do end subroutine add_mirror_term_ffs ! advance mirror implicit solve dg/dt = mu/m * bhat . grad B (dg/dvpa + m*vpa/T * g) subroutine advance_mirror_implicit ( collisions_implicit , g ) use constants , only : zi use mp , only : proc0 use job_manage , only : time_message use redistribute , only : gather , scatter use finite_differences , only : fd_variable_upwinding_vpa use stella_layouts , only : vmu_lo , kxyz_lo , kxkyz_lo use stella_layouts , only : iz_idx , is_idx , iv_idx , imu_idx use stella_transforms , only : transform_ky2y , transform_y2ky use zgrid , only : nzgrid , ntubes use dist_fn_arrays , only : gvmu use physics_flags , only : full_flux_surface use kt_grids , only : ny , nakx use vpamu_grids , only : nvpa , nmu use vpamu_grids , only : dvpa , maxwell_vpa use neoclassical_terms , only : include_neoclassical_terms use run_parameters , only : vpa_upwind , time_upwind use run_parameters , only : mirror_semi_lagrange use dist_redistribute , only : kxkyz2vmu , kxyz2vmu implicit none logical , intent ( in ) :: collisions_implicit complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: g integer :: ikxyz , ikxkyz , ivmu integer :: iv , imu , iz , is , ikx , it real :: tupwnd complex , dimension (:, :, :), allocatable :: g0v complex , dimension (:, :, :, :, :), allocatable :: g0x if ( proc0 ) call time_message (. false ., time_mirror (:, 1 ), ' Mirror advance' ) tupwnd = ( 1.0 - time_upwind ) * 0.5 ! FLAG -- STILL NEED TO IMPLEMENT VARIABLE TIME UPWINDING ! FOR FULL_FLUX_SURFACE ! now that we have g&#94;{*}, need to solve ! g&#94;{n+1} = g&#94;{*} - dt*mu*bhat . grad B d((h&#94;{n+1}+h&#94;{*})/2)/dvpa ! define A_0&#94;{-1} = dt*mu*bhat.gradB/2 ! so that (A_0 + I)h&#94;{n+1} = (A_0-I)h&#94;{*} ! will need (I-A_0&#94;{-1})h&#94;{*} in Sherman-Morrison approach ! to invert and obtain h&#94;{n+1} if ( full_flux_surface ) then ! if implicit treatment of collisions, then already have updated gvmu in kxkyz_lo if (. not . collisions_implicit ) then ! get g&#94;{*} with v-space on processor if ( proc0 ) call time_message (. false ., time_mirror (:, 2 ), ' mirror_redist' ) call scatter ( kxkyz2vmu , g , gvmu ) if ( proc0 ) call time_message (. false ., time_mirror (:, 2 ), ' mirror_redist' ) end if allocate ( g0v ( nvpa , nmu , kxyz_lo % llim_proc : kxyz_lo % ulim_alloc )) allocate ( g0x ( ny , nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) ! for upwinding, need to evaluate dg&#94;{*}/dvpa in y-space ! first must take g&#94;{*}(ky) and transform to g&#94;{*}(y) call transform_ky2y ( g , g0x ) write ( * , * ) 'WARNING: full_flux_surface not working in implicit_mirror advance!' ! convert g to g*(integrating factor), as this is what is being advected ! integrating factor = exp(m*vpa&#94;2/2T * (mu*dB/dz) / (mu*dB/dz + Z*e*dphinc/dz)) ! if dphinc/dz=0, simplifies to exp(m*vpa&#94;2/2T) if ( include_neoclassical_terms ) then do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid do ikx = 1 , nakx g0x (:, ikx , iz , it , ivmu ) = g0x (:, ikx , iz , it , ivmu ) * mirror_int_fac (:, iz , ivmu ) end do end do end do end do else do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) g0x (:, :, :, :, ivmu ) = g0x (:, :, :, :, ivmu ) / maxwell_vpa ( iv , is ) end do end if ! second, remap g so velocities are local call scatter ( kxyz2vmu , g0x , g0v ) do ikxyz = kxyz_lo % llim_proc , kxyz_lo % ulim_proc do imu = 1 , nmu call invert_mirror_operator ( imu , ikxyz , g0v (:, imu , ikxyz )) end do end do ! then take the results and remap again so y,kx,z local. call gather ( kxyz2vmu , g0v , g0x ) ! convert back from g*(integrating factor) to g ! integrating factor = exp(m*vpa&#94;2/2T * (mu*dB/dz) / (mu*dB/dz + Z*e*dphinc/dz)) ! if dphinc/dz=0, simplifies to exp(m*vpa&#94;2/2T) if ( include_neoclassical_terms ) then do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid do ikx = 1 , nakx g0x (:, ikx , iz , it , ivmu ) = g0x (:, ikx , iz , it , ivmu ) / mirror_int_fac (:, iz , ivmu ) end do end do end do end do else do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) g0x (:, :, :, :, ivmu ) = g0x (:, :, :, :, ivmu ) * maxwell_vpa ( iv , is ) end do end if ! finally transform back from y to ky space call transform_y2ky ( g0x , g ) else ! if implicit treatment of collisions, then already have updated gvmu in kxkyz_lo if (. not . collisions_implicit ) then ! get g&#94;{*} with v-space on processor if ( proc0 ) call time_message (. false ., time_mirror (:, 2 ), ' mirror_redist' ) call scatter ( kxkyz2vmu , g , gvmu ) if ( proc0 ) call time_message (. false ., time_mirror (:, 2 ), ' mirror_redist' ) end if allocate ( g0v ( nvpa , nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) allocate ( g0x ( 1 , 1 , 1 , 1 , 1 )) if ( mirror_semi_lagrange ) then call vpa_interpolation ( gvmu , g0v ) else do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) do imu = 1 , nmu ! calculate dg/dvpa call fd_variable_upwinding_vpa ( 1 , gvmu (:, imu , ikxkyz ), dvpa , & mirror_sign ( 1 , iz ), vpa_upwind , g0v (:, imu , ikxkyz )) ! construct RHS of GK equation for mirror advance; ! i.e., (1-(1+alph)/2*dt*mu/m*b.gradB*(d/dv+m*vpa/T))*g&#94;{n+1} ! = RHS = (1+(1-alph)/2*dt*mu/m*b.gradB*(d/dv+m*vpa/T))*g&#94;{n} g0v (:, imu , ikxkyz ) = gvmu (:, imu , ikxkyz ) + tupwnd * mirror ( 1 , iz , imu , is ) * g0v (:, imu , ikxkyz ) ! invert_mirror_operator takes rhs of equation and ! returns g&#94;{n+1} call invert_mirror_operator ( imu , ikxkyz , g0v (:, imu , ikxkyz )) end do end do end if ! then take the results and remap again so ky,kx,z local. if ( proc0 ) call time_message (. false ., time_mirror (:, 2 ), ' mirror_redist' ) call gather ( kxkyz2vmu , g0v , g ) if ( proc0 ) call time_message (. false ., time_mirror (:, 2 ), ' mirror_redist' ) end if deallocate ( g0x , g0v ) if ( proc0 ) call time_message (. false ., time_mirror , ' Mirror advance' ) end subroutine advance_mirror_implicit subroutine vpa_interpolation ( grid , interp ) use vpamu_grids , only : nvpa , nmu use stella_layouts , only : kxkyz_lo use stella_layouts , only : iz_idx , is_idx use run_parameters , only : mirror_linear_interp implicit none complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( in ) :: grid complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( out ) :: interp integer :: ikxkyz , iz , is , iv , imu integer :: shift , sgn , llim , ulim real :: fac0 , fac1 , fac2 , fac3 real :: tmp0 , tmp1 , tmp2 , tmp3 if ( mirror_linear_interp ) then do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) do imu = 1 , nmu shift = mirror_interp_idx_shift ( 1 , iz , imu , is ) sgn = mirror_sign ( 1 , iz ) if ( sgn > 0 ) then llim = 1 ulim = nvpa - 1 - shift else llim = nvpa ulim = 2 - shift end if fac1 = 1.0 - mirror_interp_loc ( 1 , iz , imu , is ) fac2 = mirror_interp_loc ( 1 , iz , imu , is ) do iv = llim , ulim , sgn interp ( iv , imu , ikxkyz ) = grid ( iv + shift , imu , ikxkyz ) * fac1 & + grid ( iv + shift + sgn , imu , ikxkyz ) * fac2 end do ! either assume BC for g is zero beyond grid extrema ! or dg/dvpa is zero beyond grid extrema ! at boundary cell, use zero incoming BC for point just beyond boundary interp ( ulim + sgn , imu , ikxkyz ) = grid ( ulim + shift + sgn , imu , ikxkyz ) * fac1 ! use zero incoming BC for cells beyond +/- nvgrid if ( shift > 0 ) then !                   interp(nvpa-shift+1:,imu,ikxkyz) = 0. do iv = nvpa - shift , nvpa interp ( iv , imu , ikxkyz ) = grid ( nvpa , imu , ikxkyz ) * real ( nvpa - iv ) / real ( shift + 1 ) end do else if ( shift < 0 ) then !                   interp(:-shift,imu,ikxkyz) = 0. do iv = 1 , - shift interp ( iv , imu , ikxkyz ) = grid ( 1 , imu , ikxkyz ) * real ( iv - 1 ) / real ( - shift ) end do end if end do end do else do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) do imu = 1 , nmu tmp0 = mirror_interp_loc ( 1 , iz , imu , is ) tmp1 = tmp0 - 2.0 tmp2 = tmp0 - 1.0 tmp3 = tmp0 + 1.0 shift = mirror_interp_idx_shift ( 1 , iz , imu , is ) sgn = mirror_sign ( 1 , iz ) if ( shift == 0 ) then ! deal with boundary point near outgoing BC ! using 2-point (linear) interpolation ! could do 3-point to improve accuracy fac1 = 1.0 - tmp0 fac2 = tmp0 if ( sgn > 0 ) then llim = 2 ulim = nvpa - 2 - shift else llim = nvpa - 1 ulim = 3 - shift end if iv = llim - sgn interp ( iv , imu , ikxkyz ) = grid ( iv + shift , imu , ikxkyz ) * fac1 & + grid ( iv + shift + sgn , imu , ikxkyz ) * fac2 else if ( sgn > 0 ) then llim = 1 ulim = nvpa - 2 - shift else llim = nvpa ulim = 3 - shift end if end if ! if llim > ulim (for sgn > 0) or llim < ulim (for sgn < 0) ! then there are no elements to be interpolated if ( sgn * ulim < sgn * llim ) then interp (:, imu , ikxkyz ) = 0. else ! coefficient multiplying g_{iv-1} fac0 = - tmp0 * tmp1 * tmp2 ! coefficient multiplying g_{iv} fac1 = 3. * tmp1 * tmp2 * tmp3 ! coefficient multiplying g_{iv+1} fac2 = - 3. * tmp0 * tmp1 * tmp3 ! coefficient multiplying g_{iv+2} fac3 = tmp0 * tmp2 * tmp3 do iv = llim , ulim , sgn interp ( iv , imu , ikxkyz ) = ( grid ( iv + shift - sgn , imu , ikxkyz ) * fac0 & + grid ( iv + shift , imu , ikxkyz ) * fac1 & + grid ( iv + shift + sgn , imu , ikxkyz ) * fac2 & + grid ( iv + shift + 2 * sgn , imu , ikxkyz ) * fac3 ) / 6. end do ! at boundary cell, use zero incoming BC for point just beyond boundary interp ( ulim + sgn , imu , ikxkyz ) = ( grid ( ulim + shift , imu , ikxkyz ) * fac0 & + grid ( ulim + shift + sgn , imu , ikxkyz ) * fac1 & + grid ( ulim + shift + 2 * sgn , imu , ikxkyz ) * fac2 ) / 6. interp ( ulim + 2 * sgn , imu , ikxkyz ) = ( grid ( ulim + shift + sgn , imu , ikxkyz ) * fac0 & + grid ( ulim + shift + 2 * sgn , imu , ikxkyz ) * fac1 ) / 6. ! use zero incoming BC for cells beyond +/- nvgrid if ( shift > 0 ) then interp ( nvpa - shift + 1 :, imu , ikxkyz ) = 0. else if ( shift < 0 ) then interp (: - shift , imu , ikxkyz ) = 0. end if end if end do end do end if end subroutine vpa_interpolation subroutine invert_mirror_operator ( imu , ilo , g ) use finite_differences , only : tridag implicit none integer , intent ( in ) :: imu , ilo complex , dimension (:), intent ( in out ) :: g call tridag ( 1 , mirror_tri_a (:, imu , ilo ), mirror_tri_b (:, imu , ilo ), mirror_tri_c (:, imu , ilo ), g ) end subroutine invert_mirror_operator subroutine finish_mirror use run_parameters , only : mirror_implicit , mirror_semi_lagrange implicit none if ( allocated ( mirror )) deallocate ( mirror ) if ( allocated ( mirror_sign )) deallocate ( mirror_sign ) if ( allocated ( mirror_rad_var )) deallocate ( mirror_rad_var ) if ( mirror_implicit ) then if ( mirror_semi_lagrange ) then call finish_mirror_semi_lagrange else call finish_invert_mirror_operator end if end if mirror_initialized = . false . end subroutine finish_mirror subroutine finish_mirror_semi_lagrange implicit none if ( allocated ( mirror_interp_loc )) deallocate ( mirror_interp_loc ) if ( allocated ( mirror_interp_idx_shift )) deallocate ( mirror_interp_idx_shift ) end subroutine finish_mirror_semi_lagrange subroutine finish_invert_mirror_operator implicit none if ( allocated ( mirror_tri_a )) then deallocate ( mirror_tri_a ) deallocate ( mirror_tri_b ) deallocate ( mirror_tri_c ) end if if ( allocated ( mirror_int_fac )) deallocate ( mirror_int_fac ) end subroutine finish_invert_mirror_operator ! subroutine checksum_field (field, total) !   use zgrid, only: nzgrid, ntubes !   use kt_grids, only: naky !   use extended_zgrid, only: neigen, nsegments, ikxmod !   use extended_zgrid, only: iz_low, iz_up !   implicit none !   complex, dimension (:,:,-nzgrid:,:), intent (in) :: field !   real, intent (out) :: total !   integer :: it, iky, ie, iseg !   integer :: ikx !   total = 0. !   do iky = 1, naky !      do it = 1, ntubes !         do ie = 1, neigen(iky) !            iseg = 1 !            ikx = ikxmod(iseg,ie,iky) !            total = total + sum(cabs(field(iky,ikx,iz_low(iseg):iz_up(iseg),it))) !            if (nsegments(ie,iky) > 1) then !               do iseg = 2, nsegments(ie,iky) !                  ikx = ikxmod(iseg,ie,iky) !                  total = total + sum(cabs(field(iky,ikx,iz_low(iseg)+1:iz_up(iseg),it))) !               end do !            end if !         end do !      end do !   end do ! end subroutine checksum_field ! subroutine checksum_dist (dist, total, norm) !   use mp, only: sum_allreduce !   use zgrid, only: nzgrid, ntubes !   use stella_layouts, only: vmu_lo, iv_idx, imu_idx, is_idx !   use kt_grids, only: naky, nakx !   use vpamu_grids, only: maxwell_vpa, maxwell_mu !   implicit none !   complex, dimension (:,:,-nzgrid:,:,vmu_lo%llim_proc:), intent (in) :: dist !   real, intent (out) :: total !   logical, intent (in), optional :: norm !   integer :: ivmu, iv, imu, is !   integer :: iky, ikx, it !   real :: subtotal !   complex, dimension (:,:,:,:), allocatable :: dist_single !   total = 0. !   allocate (dist_single(naky,nakx,-nzgrid:nzgrid,ntubes)) !   do ivmu = vmu_lo%llim_proc, vmu_lo%ulim_proc !      dist_single = dist(:,:,:,:,ivmu) !      if (present(norm)) then !         if (norm) then !            iv = iv_idx(vmu_lo,ivmu) !            imu = imu_idx(vmu_lo,ivmu) !            is = is_idx(vmu_lo,ivmu) !            do it = 1, ntubes !               do ikx = 1, nakx !                  do iky = 1, naky !                     dist_single(iky,ikx,:,it) = dist_single(iky,ikx,:,it) * maxwell_vpa(iv,is) * maxwell_mu(1,:,imu,is) !                  end do !               end do !            end do !         else !         end if !      end if !      call checksum (dist_single, subtotal) !      total = total + subtotal !   end do !   deallocate (dist_single) !   call sum_allreduce (total) ! end subroutine checksum_dist end module mirror_terms","tags":"","loc":"sourcefile/mirror_terms.f90.html"},{"title":"init_g.f90 â€“ stella","text":"Contents Modules init_g Source Code init_g.f90 Source Code !> This module contains the subroutines which set the initial value of the !! fields and the distribution function. module init_g implicit none public :: ginit public :: init_init_g , finish_init_g public :: width0 public :: scale_to_phiinit , phiinit public :: tstart public :: reset_init private ! knobs integer :: ginitopt_switch integer , parameter :: ginitopt_default = 1 , & ginitopt_noise = 2 , ginitopt_restart_many = 3 , & ginitopt_kpar = 4 , ginitopt_nltest = 5 , & ginitopt_kxtest = 6 , ginitopt_rh = 7 , & ginitopt_remap = 8 real :: width0 , phiinit , imfac , refac , zf_init real :: den0 , upar0 , tpar0 , tperp0 real :: den1 , upar1 , tpar1 , tperp1 real :: den2 , upar2 , tpar2 , tperp2 real :: tstart , scale , kxmax , kxmin logical :: chop_side , left , even , scale_to_phiinit character ( 300 ), public :: restart_file character ( len = 150 ) :: restart_dir logical :: initialized = . false . logical :: exist contains subroutine init_init_g use stella_save , only : init_save , read_many use stella_layouts , only : init_stella_layouts use system_fortran , only : systemf use mp , only : proc0 , broadcast implicit none integer :: ind_slash if ( initialized ) return initialized = . true . call init_stella_layouts if ( proc0 ) call read_parameters ! prepend restart_dir to restart_file ! append trailing slash if not exists if ( restart_dir ( len_trim ( restart_dir ):) /= \"/\" ) & restart_dir = trim ( restart_dir ) // \"/\" if ( proc0 ) call systemf ( 'mkdir -p ' // trim ( restart_dir )) !Determine if restart file contains \"/\" if so split on this point to give DIR//FILE !so restart files are created in DIR//restart_dir//FILE ind_slash = index ( restart_file , \"/\" , . true .) if ( ind_slash == 0 ) then !No slash present restart_file = trim ( restart_dir ) // trim ( restart_file ) else !Slash present restart_file = trim ( restart_file ( 1 : ind_slash )) // trim ( restart_dir ) // trim ( restart_file ( ind_slash + 1 :)) end if call broadcast ( ginitopt_switch ) call broadcast ( width0 ) call broadcast ( refac ) call broadcast ( imfac ) call broadcast ( den0 ) call broadcast ( upar0 ) call broadcast ( tpar0 ) call broadcast ( tperp0 ) call broadcast ( den1 ) call broadcast ( upar1 ) call broadcast ( tpar1 ) call broadcast ( tperp1 ) call broadcast ( den2 ) call broadcast ( upar2 ) call broadcast ( tpar2 ) call broadcast ( tperp2 ) call broadcast ( phiinit ) call broadcast ( zf_init ) call broadcast ( kxmax ) call broadcast ( kxmin ) call broadcast ( tstart ) call broadcast ( chop_side ) call broadcast ( even ) call broadcast ( left ) call broadcast ( restart_file ) call broadcast ( read_many ) call broadcast ( scale_to_phiinit ) call broadcast ( scale ) call init_save ( restart_file ) end subroutine init_init_g subroutine ginit ( restarted , istep0 ) use stella_save , only : init_tstart use physics_flags , only : full_flux_surface logical , intent ( out ) :: restarted integer , intent ( out ) :: istep0 integer :: istatus restarted = . false . istep0 = 0 select case ( ginitopt_switch ) case ( ginitopt_default ) call ginit_default case ( ginitopt_noise ) call ginit_noise case ( ginitopt_kpar ) call ginit_kpar case ( ginitopt_rh ) call ginit_rh case ( ginitopt_remap ) call ginit_remap case ( ginitopt_restart_many ) call ginit_restart_many call init_tstart ( tstart , istep0 , istatus ) restarted = . true . scale = 1. !    case (ginitopt_nltest) !       call ginit_nltest !    case (ginitopt_kxtest) !       call ginit_kxtest end select !> if simulating a full flux surface, g is normalized by F0 (which is not the case otherwise) !> unless reading in g from a restart file, normalise g by F0 for a full flux surface simulation if ( full_flux_surface . and . ginitopt_switch /= ginitopt_restart_many ) then call normalize_by_maxwellian end if end subroutine ginit subroutine read_parameters use file_utils , only : input_unit , error_unit , run_name , input_unit_exist use text_options , only : text_option , get_option_value use stella_save , only : read_many implicit none type ( text_option ), dimension ( 8 ), parameter :: ginitopts = & ( / text_option ( 'default' , ginitopt_default ), & text_option ( 'noise' , ginitopt_noise ), & text_option ( 'many' , ginitopt_restart_many ), & text_option ( 'nltest' , ginitopt_nltest ), & text_option ( 'kxtest' , ginitopt_kxtest ), & text_option ( 'kpar' , ginitopt_kpar ), & text_option ( 'rh' , ginitopt_rh ), & text_option ( 'remap' , ginitopt_remap ) & / ) character ( 20 ) :: ginit_option namelist / init_g_knobs / ginit_option , width0 , phiinit , chop_side , & restart_file , restart_dir , read_many , left , scale , tstart , zf_init , & den0 , upar0 , tpar0 , tperp0 , imfac , refac , even , & den1 , upar1 , tpar1 , tperp1 , & den2 , upar2 , tpar2 , tperp2 , & kxmax , kxmin , scale_to_phiinit integer :: ierr , in_file tstart = 0. scale = 1.0 ginit_option = \"default\" width0 = - 3.5 refac = 1. imfac = 0. den0 = 1. upar0 = 0. tpar0 = 0. tperp0 = 0. den1 = 0. upar1 = 0. tpar1 = 0. tperp1 = 0. den2 = 0. upar2 = 0. tpar2 = 0. tperp2 = 0. phiinit = 1.0 zf_init = 1.0 kxmax = 1.e100 kxmin = 0. chop_side = . false . scale_to_phiinit = . false . left = . true . even = . true . restart_file = trim ( run_name ) // \".nc\" restart_dir = \"./\" in_file = input_unit_exist ( \"init_g_knobs\" , exist ) !    if (exist) read (unit=input_unit(\"init_g_knobs\"), nml=init_g_knobs) if ( exist ) read ( unit = in_file , nml = init_g_knobs ) ierr = error_unit () call get_option_value & ( ginit_option , ginitopts , ginitopt_switch , & ierr , \"ginit_option in ginit_knobs\" , stop_on_error = . true .) end subroutine read_parameters subroutine ginit_default use constants , only : zi use species , only : spec use zgrid , only : nzgrid , zed use kt_grids , only : naky , nakx use kt_grids , only : theta0 use kt_grids , only : reality , zonal_mode use vpamu_grids , only : nvpa , nmu use vpamu_grids , only : vpa use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use dist_fn_arrays , only : gvmu use stella_layouts , only : kxkyz_lo , iz_idx , ikx_idx , iky_idx , is_idx use ran , only : ranf implicit none complex , dimension ( naky , nakx , - nzgrid : nzgrid ) :: phi logical :: right integer :: ikxkyz integer :: iz , iky , ikx , is , ia right = . not . left do iz = - nzgrid , nzgrid phi (:, :, iz ) = exp ( - (( zed ( iz ) - theta0 ) / width0 ) ** 2 ) * cmplx ( 1.0 , 1.0 ) end do ! this is a messy way of doing things ! could tidy it up a bit if ( sum ( cabs ( phi )) < epsilon ( 0. )) then do iz = - nzgrid , nzgrid phi (:, :, iz ) = exp ( - ( zed ( iz ) / width0 ) ** 2 ) * cmplx ( 1.0 , 1.0 ) end do end if if ( chop_side ) then if ( left ) phi (:, :, : - 1 ) = 0.0 if ( right ) phi (:, :, 1 :) = 0.0 end if if ( reality . and . zonal_mode ( 1 )) phi ( 1 , :, :) = 0.0 ia = 1 gvmu = 0. do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iz = iz_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iky = iky_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) gvmu (:, :, ikxkyz ) = phiinit * phi ( iky , ikx , iz ) / abs ( spec ( is )% z ) & * ( den0 + 2.0 * zi * spread ( vpa , 2 , nmu ) * upar0 ) & * spread ( maxwell_mu ( ia , iz , :, is ), 1 , nvpa ) * spread ( maxwell_vpa (:, is ), 2 , nmu ) * maxwell_fac ( is ) end do end subroutine ginit_default ! initialize two kys and kx=0 !   subroutine ginit_nltest !     use mp, only: proc0 !     use species, only: spec !     use zgrid, only: nzgrid, bmag !     use kt_grids, only: naky, ntheta0 !     use vpamu_grids, only: nvgrid, vpa, mu !     use dist_fn_arrays, only: gnew, gold !     use stella_layouts, only: gxyz_lo, iv_idx, is_idx, imu_idx !     implicit none !     complex, dimension (-nzgrid:nzgrid,ntheta0,naky) :: phi !     logical :: right !     integer :: iglo !     integer :: ig, ik, it, is, iv, imu !     right = .not. left !     if (naky < 4 .or. ntheta0 < 2) then !        if (proc0) write (*,*) 'must have at least 2 kxs and 4 kys to use nltest init option. aborting.' !        stop !     end if !     phi = 0.0 !     do ig = -nzgrid, nzgrid !        phi(ig,2,2) = 1.0!exp(-((theta(ig)-theta0(2,2))/width0)**2)*cmplx(1.0,1.0) !     end do !     gnew = 0.0 !     do iglo = gxyz_lo%llim_proc, gxyz_lo%ulim_proc !        iv = iv_idx(gxyz_lo,iglo) !        is = is_idx(gxyz_lo,iglo) !        imu = imu_idx(gxyz_lo,iglo) !        it = 1 !        do ik = 2, 3 !           gnew(:,it,ik,iglo) = exp(-2.0*mu(imu)*bmag)*phi(:,it,ik) & !                *spec(is)%z*phiinit*exp(-vpa(iv)**2) !        end do !     end do !     gold = gnew !   end subroutine ginit_nltest !   subroutine ginit_kxtest !     use constants, only: zi !     use species, only: spec !     use zgrid, only: itor_over_b !     use kt_grids, only: ntheta0, akx, naky !     use vpamu_grids, only: nvgrid, energy, vpa !     use dist_fn_arrays, only: gnew, gold !     use stella_layouts, only: gxyz_lo, iv_idx, is_idx, imu_idx !     implicit none !     integer :: iglo !     integer :: ik, it, is, imu, iv !     do iglo = gxyz_lo%llim_proc, gxyz_lo%ulim_proc !        iv = iv_idx(gxyz_lo,iglo) !        is = is_idx(gxyz_lo,iglo) !        imu = imu_idx(gxyz_lo,iglo) !        do it = 1, ntheta0 !           do ik = 1, naky !              gnew(:,it,ik,iglo) = exp(-zi*akx(it)*itor_over_B*vpa(iv)/spec(is)%zstm) & !                   *exp(-energy(:,iv,imu))*spec(is)%z*phiinit !           end do !        end do !     end do !     gold = gnew !   end subroutine ginit_kxtest !   !> Initialise with only the kparallel = 0 mode. !   subroutine single_initial_kx(phi) !     use zgrid, only: nzgrid !     use kt_grids, only: naky, ntheta0 !     use mp, only: mp_abort !     implicit none !     complex, dimension (-nzgrid:nzgrid,ntheta0,naky), intent(inout) :: phi !     real :: a, b !     integer :: ig, ik, it !     if (ikx_init  < 2 .or. ikx_init > (ntheta0+1)/2) then !       call mp_abort(\"The subroutine single_initial_kx should only be called when 1 < ikx_init < (ntheta0+1)/2\") !     end if !     do it = 1, ntheta0 !       if (it .ne. ikx_init) then !          do ik = 1, naky !             do ig = -nzgrid, nzgrid !                a = 0.0 !                b = 0.0 !                phi(ig,it,ik) = cmplx(a,b) !              end do !          end do !        end if !     end do !   end subroutine single_initial_kx !> Initialise the distribution function with random noise. This is the default !! initialisation option. Each different mode is given a random amplitude !! between zero and one. subroutine ginit_noise use mp , only : proc0 , broadcast use dist_fn_arrays , only : kperp2 use species , only : spec use zgrid , only : nzgrid , ntubes use extended_zgrid , only : ikxmod , nsegments , neigen use extended_zgrid , only : it_right use extended_zgrid , only : periodic use kt_grids , only : naky , nakx , reality , zonal_mode use vpamu_grids , only : nvpa , nmu use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use dist_fn_arrays , only : gvmu use stella_layouts , only : kxkyz_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , it_idx , is_idx use mp , only : proc0 , broadcast , max_allreduce use mp , only : scope , crossdomprocs , subprocs use file_utils , only : runtype_option_switch , runtype_multibox use ran implicit none complex , dimension ( naky , nakx , - nzgrid : nzgrid , ntubes ) :: phi real :: a , b , kmin integer :: ikxkyz , iz , it , iky , ikx , is , ie , iseg , ia integer :: itmod if ( naky == 1 . and . nakx == 1 ) then if ( proc0 ) then write ( * , * ) 'noise initialization option is not suited for single mode simulations.' write ( * , * ) 'using default initialization option' end if call ginit_default return else ! zero out ky=kx=0 mode phi ( 1 , 1 , :, :) = 0.0 end if ia = 1 if ( proc0 ) then phi ( 1 , 1 , :, :) = 0.0 kmin = 1.e6 if ( naky > 1 ) kmin = minval ( kperp2 ( 2 , 1 , ia , :)) if ( nakx > 1 ) kmin = min ( kmin , minval ( kperp2 ( 1 , 2 , ia , :))) if ( runtype_option_switch == runtype_multibox ) then call scope ( crossdomprocs ) call max_allreduce ( kmin ) call scope ( subprocs ) end if ! keep old (ikx, iky) loop order to get old results exactly: !Fill phi with random (complex) numbers between -0.5 and 0.5 do ikx = 1 , nakx do iky = 1 , naky do it = 1 , ntubes do iz = - nzgrid , nzgrid a = ranf () - 0.5 b = ranf () - 0.5 ! do not populate high k modes with large amplitudes if (( ikx > 1 . or . iky > 1 ) . and . ( kperp2 ( iky , ikx , ia , iz ) >= kmin )) then !the following as an extra factor of kmin to offset the Gamma-1 in quasineutrality phi ( iky , ikx , iz , it ) = cmplx ( a , b ) * kmin * kmin / kperp2 ( iky , ikx , ia , iz ) else phi ( iky , ikx , iz , it ) = 0.0 end if end do if ( chop_side ) then if ( left ) then phi ( iky , ikx , : - 1 , it ) = 0.0 else phi ( iky , ikx , 1 :, it ) = 0.0 end if end if end do end do end do ! enforce periodicity where required do iky = 1 , naky if ( periodic ( iky )) then phi ( 1 , :, nzgrid , :) = phi ( 1 , :, - nzgrid , :) end if end do ! zero out the kx=ky=0 mode and apply optional ! scaliing factor to all zonal modes if ( zonal_mode ( 1 )) then !Apply scaling factor phi ( 1 , :, :, :) = phi ( 1 , :, :, :) * zf_init !Set ky=kx=0.0 mode to zero in amplitude phi ( 1 , 1 , :, :) = 0.0 end if !Apply reality condition (i.e. -kx mode is conjugate of +kx mode) if ( reality ) then do ikx = nakx / 2 + 2 , nakx phi ( 1 , ikx , :, :) = conjg ( phi ( 1 , nakx - ikx + 2 , :, :)) end do end if end if do iky = 1 , naky do ie = 1 , neigen ( iky ) ! enforce zero BC at ends of domain, unless periodic if (. not . periodic ( iky )) then phi ( iky , ikxmod ( 1 , ie , iky ), - nzgrid , :) = 0.0 phi ( iky , ikxmod ( nsegments ( ie , iky ), ie , iky ), nzgrid , :) = 0.0 end if ! enforce equality of g values at duplicate zed points if ( nsegments ( ie , iky ) > 1 ) then do it = 1 , ntubes itmod = it do iseg = 2 , nsegments ( ie , iky ) phi ( iky , ikxmod ( iseg , ie , iky ), - nzgrid , it_right ( itmod )) = phi ( iky , ikxmod ( iseg - 1 , ie , iky ), nzgrid , itmod ) itmod = it_right ( itmod ) end do end do end if end do end do call broadcast ( phi ) !Now set g using data in phi do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iky = iky_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) gvmu (:, :, ikxkyz ) = spec ( is )% z * phiinit * phi ( iky , ikx , iz , it ) & * spread ( maxwell_vpa (:, is ), 2 , nmu ) * spread ( maxwell_mu ( ia , iz , :, is ), 1 , nvpa ) * maxwell_fac ( is ) end do end subroutine ginit_noise subroutine ginit_kpar !    use species, only: spec, has_electron_species use zgrid , only : nzgrid , zed use kt_grids , only : naky , nakx , theta0 use vpamu_grids , only : nvpa , nmu use vpamu_grids , only : vpa , vperp2 use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use dist_fn_arrays , only : gvmu use stella_layouts , only : kxkyz_lo , iky_idx , ikx_idx , iz_idx , is_idx use constants , only : zi implicit none complex , dimension ( naky , nakx , - nzgrid : nzgrid ) :: phi , odd real , dimension ( - nzgrid : nzgrid ) :: dfac , ufac , tparfac , tperpfac integer :: ikxkyz integer :: iz , iky , ikx , imu , iv , ia , is phi = 0. odd = 0. if ( width0 > 0. ) then do iz = - nzgrid , nzgrid phi (:, :, iz ) = exp ( - (( zed ( iz ) - theta0 ) / width0 ) ** 2 ) * cmplx ( refac , imfac ) end do else do iz = - nzgrid , nzgrid phi (:, :, iz ) = cmplx ( refac , imfac ) end do end if if ( chop_side ) then if ( left ) then phi (:, :, : - 1 ) = 0.0 else phi (:, :, 1 :) = 0.0 end if end if odd = zi * phi dfac = den0 + den1 * cos ( zed ) + den2 * cos ( 2. * zed ) ufac = upar0 + upar1 * sin ( zed ) + upar2 * sin ( 2. * zed ) tparfac = tpar0 + tpar1 * cos ( zed ) + tpar2 * cos ( 2. * zed ) tperpfac = tperp0 + tperp1 * cos ( zed ) + tperp2 * cos ( 2. * zed ) ia = 1 ! charge dependence keeps initial Phi from being too small do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) do imu = 1 , nmu do iv = 1 , nvpa gvmu ( iv , imu , ikxkyz ) = phiinit & * ( dfac ( iz ) * phi ( iky , ikx , iz ) & + 2.0 * vpa ( iv ) * ufac ( iz ) * odd ( iky , ikx , iz ) & + ( vpa ( iv ) ** 2 - 0.5 ) * tparfac ( iz ) * phi ( iky , ikx , iz ) & + tperpfac ( iz ) * ( vperp2 ( ia , iz , imu ) - 1. ) * phi ( iky , ikx , iz )) end do end do gvmu (:, :, ikxkyz ) = gvmu (:, :, ikxkyz ) & * spread ( maxwell_vpa (:, is ), 2 , nmu ) * spread ( maxwell_mu ( ia , iz , :, is ), 1 , nvpa ) * maxwell_fac ( is ) end do ! FLAG -- should be uncommented, which means I need to fix flae !    if (has_electron_species(spec)) then !       call flae (gold, gnew) !       gold = gold - gnew !    end if !    gnew = gold end subroutine ginit_kpar subroutine ginit_rh use species , only : spec use dist_fn_arrays , only : gvmu , kperp2 use stella_layouts , only : kxkyz_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , is_idx use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use vpamu_grids , only : nvpa , nmu use kt_grids , only : akx implicit none integer :: ikxkyz , iky , ikx , iz , is , ia ! initialize g to be a Maxwellian with a constant density perturbation gvmu = 0. ia = 1 do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ); if ( iky /= 1 ) cycle ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) if ( abs ( akx ( ikx )) < kxmax . and . abs ( akx ( ikx )) > kxmin ) then gvmu (:, :, ikxkyz ) = spec ( is )% z * 0.5 * phiinit * kperp2 ( iky , ikx , ia , iz ) & * spread ( maxwell_vpa (:, is ), 2 , nmu ) * spread ( maxwell_mu ( ia , iz , :, is ), 1 , nvpa ) * maxwell_fac ( is ) end if end do end subroutine ginit_rh subroutine ginit_remap use species , only : spec use dist_fn_arrays , only : gvmu use stella_layouts , only : kxkyz_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , is_idx use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use vpamu_grids , only : nvpa , nmu implicit none integer :: ikxkyz , iky , ikx , iz , is , ia ! initialize g to be a Maxwellian with a constant density perturbation gvmu = 0. ia = 1 do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) !if((ikx.eq.15.and.iky.eq.5).or.((ikx-nakx).eq.-12.and.iky.eq.3)) then if (( ikx == 1 . and . iky == 2 )) then gvmu (:, :, ikxkyz ) = spec ( is )% z * phiinit & * spread ( maxwell_vpa (:, is ), 2 , nmu ) * spread ( maxwell_mu ( ia , iz , :, is ), 1 , nvpa ) * maxwell_fac ( is ) end if end do end subroutine ginit_remap subroutine ginit_restart_many use dist_fn_arrays , only : gvmu use stella_save , only : stella_restore use mp , only : proc0 use file_utils , only : error_unit implicit none integer :: istatus , ierr ! should really check if profile_variation=T here but need ! to move profile_variation to module that is accessible here call stella_restore ( gvmu , scale , istatus ) if ( istatus /= 0 ) then ierr = error_unit () if ( proc0 ) write ( ierr , * ) \"Error reading file: \" , trim ( restart_file ) gvmu = 0. end if end subroutine ginit_restart_many subroutine normalize_by_maxwellian use stella_layouts , only : kxkyz_lo , is_idx , iz_idx use dist_fn_arrays , only : gvmu use vpamu_grids , only : nmu use vpamu_grids , only : maxwell_mu , maxwell_vpa , maxwell_fac implicit none integer :: ia , imu integer :: ikxkyz , iz , is !> gvmu is initialised with a Maxwellian weighting for flux tube simulations, !> with the Maxwellian evaluated at ia = 1 !> we are undoing that weighting here, so also need to use ia = 1 ia = 1 do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) do imu = 1 , nmu gvmu (:, imu , ikxkyz ) = gvmu (:, imu , ikxkyz ) / ( maxwell_mu ( ia , iz , imu , is ) * maxwell_vpa (:, is ) * maxwell_fac ( is )) end do end do end subroutine normalize_by_maxwellian subroutine reset_init ginitopt_switch = ginitopt_restart_many end subroutine reset_init !   subroutine flae (g, gavg) !     use species, only: spec, electron_species !     use zgrid, only: nzgrid, delthet, jacob !     use kt_grids, only: aky, ntheta0 !     use vpamu_grids, only: nvgrid !     use stella_layouts, only: gxyz_lo, is_idx !     complex, dimension (-nzgrid:,:,:,gxyz_lo%llim_proc:), intent (in) :: g !     complex, dimension (-nzgrid:,:,:,gxyz_lo%llim_proc:), intent (out) :: gavg !     real :: wgt !     integer :: iglo, it, ik !     gavg = 0. !     wgt = 1./sum(delthet*jacob) !     do iglo = gxyz_lo%llim_proc, gxyz_lo%ulim_proc !        if (spec(is_idx(gxyz_lo, iglo))%type /= electron_species) cycle !        ik = 1 !        if (aky(ik) > epsilon(0.)) cycle !        do it = 1, ntheta0 !           gavg(:,it,ik,iglo) = sum(g(:,it,ik,iglo)*delthet*jacob)*wgt !        end do !     end do !   end subroutine flae subroutine finish_init_g use stella_save , only : finish_save implicit none initialized = . false . call finish_save end subroutine finish_init_g end module init_g","tags":"","loc":"sourcefile/init_g.f90.html"},{"title":"volume_averages.f90 â€“ stella","text":"Contents Modules volume_averages Source Code volume_averages.f90 Source Code module volume_averages public :: init_volume_averages , finish_volume_averages public :: fieldline_average public :: volume_average public :: flux_surface_average_ffs public :: mode_fac private interface fieldline_average module procedure fieldline_average_real module procedure fieldline_average_complex end interface real , dimension (:), allocatable :: mode_fac !> Fourier coefficients in y of the Jacobian; !> needed for full flux surface simulations complex , dimension (:, :), allocatable :: jacobian_ky contains subroutine init_volume_averages use zgrid , only : nzgrid , nztot , ntubes , delzed use kt_grids , only : nalpha , aky , nakx , naky , rho_d_clamped use stella_geometry , only : geo_surf , drhodpsi use stella_geometry , only : geo_surf , jacob , djacdrho , q_as_x , dVolume use physics_flags , only : full_flux_surface , radial_variation implicit none real :: dqdrho if (. not . allocated ( mode_fac )) then allocate ( mode_fac ( naky )); mode_fac = 2.0 if ( aky ( 1 ) < epsilon ( 0. )) mode_fac ( 1 ) = 1.0 end if if ( full_flux_surface ) then call init_flux_surface_average_ffs end if dqdrho = geo_surf % shat * geo_surf % qinp / geo_surf % rhoc if (. not . allocated ( dVolume )) allocate ( dVolume ( nalpha , nakx , - nzgrid : nzgrid )) !dVolume contains the volume element jacob, which may vary with x or alpha ! NB: dVolume does not contain the factor dx, as this should always be uniform dVolume = spread ( jacob * spread ( delzed , 1 , nalpha ), 2 , nakx ) if ( q_as_x ) then dVolume = dVolume / ( dqdrho * drhodpsi ) end if if ( radial_variation ) then if ( q_as_x ) then dVolume = dVolume * ( 1. + spread ( spread ( rho_d_clamped , 1 , nalpha ), 3 , nztot ) & * ( spread ( djacdrho / jacob , 2 , nakx ) - geo_surf % d2qdr2 / dqdrho & + geo_surf % d2psidr2 * drhodpsi )) else dVolume = dVolume * ( 1. + spread ( spread ( rho_d_clamped , 1 , nalpha ), 3 , nztot ) & * spread ( djacdrho / jacob , 2 , nakx )) end if end if if ( full_flux_surface ) then !something should go here end if !avoid the double counting at the zed boundaries dVolume (:, :, - nzgrid ) = 0.5 * dVolume (:, :, - nzgrid ) dVolume (:, :, nzgrid ) = 0.5 * dVolume (:, :, nzgrid ) end subroutine init_volume_averages subroutine finish_volume_averages use stella_geometry , only : dVolume use physics_flags , only : full_flux_surface implicit none if ( allocated ( mode_fac )) deallocate ( mode_fac ) if ( allocated ( dVolume )) deallocate ( dVolume ) if ( full_flux_surface ) then if ( allocated ( jacobian_ky )) deallocate ( jacobian_ky ) end if end subroutine finish_volume_averages !============================================== !============ FIELD LINE AVERAGE ============== !============================================== subroutine fieldline_average_real ( unavg , avg ) use zgrid , only : nzgrid , ntubes use kt_grids , only : nakx , naky use stella_geometry , only : dl_over_b implicit none real , dimension (:, :, - nzgrid :, :), intent ( in ) :: unavg real , dimension (:, :), intent ( out ) :: avg integer :: it , ia ia = 1 avg = 0.0 do it = 1 , ntubes avg = avg + sum ( spread ( spread ( dl_over_b ( ia , :), 1 , naky ), 2 , nakx ) * unavg (:, :, :, it ), dim = 3 ) end do avg = avg / real ( ntubes ) end subroutine fieldline_average_real subroutine fieldline_average_complex ( unavg , avg ) use zgrid , only : nzgrid , ntubes use kt_grids , only : nakx , naky use stella_geometry , only : dl_over_b implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: unavg complex , dimension (:, :), intent ( out ) :: avg integer :: it , ia ia = 1 avg = 0.0 do it = 1 , ntubes avg = avg + sum ( spread ( spread ( dl_over_b ( ia , :), 1 , naky ), 2 , nakx ) * unavg (:, :, :, it ), dim = 3 ) end do avg = avg / real ( ntubes ) end subroutine fieldline_average_complex !============================================== !============== VOLUME AVERAGE ================ !============================================== subroutine volume_average ( unavg , avg ) use zgrid , only : nzgrid , ntubes use kt_grids , only : naky , nakx use stella_geometry , only : dl_over_b implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: unavg real , intent ( out ) :: avg integer :: iky , ikx , iz , it , ia ia = 1 avg = 0. do it = 1 , ntubes do iz = - nzgrid , nzgrid do ikx = 1 , nakx do iky = 1 , naky avg = avg + real ( unavg ( iky , ikx , iz , it ) * conjg ( unavg ( iky , ikx , iz , it ))) * mode_fac ( iky ) * dl_over_b ( ia , iz ) end do end do end do end do avg = avg / real ( ntubes ) end subroutine volume_average subroutine init_flux_surface_average_ffs use zgrid , only : nzgrid use kt_grids , only : naky use stella_geometry , only : jacob use stella_transforms , only : transform_alpha2kalpha implicit none integer :: iz if (. not . allocated ( jacobian_ky )) allocate ( jacobian_ky ( naky , - nzgrid : nzgrid )) !> calculate the Fourier coefficients in y of the Jacobian !> this is needed in the computation of the flux surface average of phi do iz = - nzgrid , nzgrid call transform_alpha2kalpha ( jacob (:, iz ), jacobian_ky (:, iz )) end do end subroutine init_flux_surface_average_ffs subroutine flux_surface_average_ffs ( no_fsa , fsa ) use zgrid , only : nzgrid , delzed use stella_geometry , only : jacob use kt_grids , only : naky , naky_all , nalpha use kt_grids , only : dy implicit none complex , dimension (:, - nzgrid :), intent ( in ) :: no_fsa complex , intent ( out ) :: fsa integer :: iky , ikymod real :: area ! the normalising factor int dy dz Jacobian area = sum ( spread ( delzed * dy , 1 , nalpha ) * jacob ) fsa = 0.0 ! get contribution from negative ky values ! for no_fsa, iky=1 corresponds to -kymax, and iky=naky-1 to -dky do iky = 1 , naky - 1 ! jacobian_ky only defined for positive ky values ! use reality of the jacobian to fill in negative ky values ! i.e., jacobian_ky(-ky) = conjg(jacobian_ky(ky)) ! ikymod runs from naky down to 2, which corresponds ! to ky values in jacobian_ky from kymax down to dky ikymod = naky - iky + 1 ! for each ky, add the integral over zed fsa = fsa + sum ( delzed * no_fsa ( iky , :) * jacobian_ky ( ikymod , :)) end do ! get contribution from zero and positive ky values ! iky = naky correspond to ky=0 for no_fsa and iky=naky_all to ky=kymax do iky = naky , naky_all ! ikymod runs from 1 to naky ! ikymod = 1 corresponds to ky=0 for jacobian_ky and ikymod=naky to ky=kymax ikymod = iky - naky + 1 ! for each ky, add the integral over zed fsa = fsa + sum ( delzed * no_fsa ( iky , :) * conjg ( jacobian_ky ( ikymod , :))) end do ! normalise by the flux surface area fsa = fsa / area end subroutine flux_surface_average_ffs end module volume_averages","tags":"","loc":"sourcefile/volume_averages.f90.html"},{"title":"run_parameters.f90 â€“ stella","text":"Contents Modules run_parameters Source Code run_parameters.f90 Source Code !> This module is basically a store for the input parameters that are specified in the namelists \\a knobs and \\a parameters. In general, the names of the public variables in this module are the same as the name of the input parameter they correspond to. module run_parameters implicit none public :: init_run_parameters , finish_run_parameters public :: fphi , fapar , fbpar public :: code_delt_max public :: nstep , tend , delt public :: cfl_cushion , delt_adjust public :: avail_cpu_time public :: stream_implicit , mirror_implicit public :: drifts_implicit public :: driftkinetic_implicit public :: fully_explicit public :: ky_solve_radial , ky_solve_real public :: maxwellian_inside_zed_derivative public :: stream_matrix_inversion public :: mirror_semi_lagrange , mirror_linear_interp public :: zed_upwind , vpa_upwind , time_upwind public :: fields_kxkyz , mat_gen , mat_read public :: rng_seed private real :: cfl_cushion , delt_adjust real :: fphi , fapar , fbpar real :: delt , tend , code_delt_max real :: zed_upwind , vpa_upwind , time_upwind logical :: stream_implicit , mirror_implicit logical :: driftkinetic_implicit logical :: fully_explicit , drifts_implicit logical :: maxwellian_inside_zed_derivative logical :: stream_matrix_inversion logical :: mirror_semi_lagrange , mirror_linear_interp logical :: fields_kxkyz , mat_gen , mat_read logical :: ky_solve_real real :: avail_cpu_time integer :: nstep , ky_solve_radial integer :: rng_seed integer , public :: delt_option_switch , lu_option_switch integer , public , parameter :: delt_option_hand = 1 , delt_option_auto = 2 integer , public , parameter :: lu_option_none = 1 , & lu_option_local = 2 , & lu_option_global = 3 logical :: initialized = . false . logical :: knexist contains subroutine init_run_parameters implicit none if ( initialized ) return initialized = . true . call read_parameters end subroutine init_run_parameters subroutine read_parameters use file_utils , only : input_unit , error_unit , input_unit_exist use mp , only : proc0 , broadcast use text_options , only : text_option , get_option_value use physics_flags , only : include_mirror , full_flux_surface implicit none type ( text_option ), dimension ( 3 ), parameter :: deltopts = & ( / text_option ( 'default' , delt_option_auto ), & text_option ( 'set_by_hand' , delt_option_hand ), & text_option ( 'check_restart' , delt_option_auto ) / ) type ( text_option ), dimension ( 4 ), parameter :: lu_opts = & ( / text_option ( 'default' , lu_option_none ), & text_option ( 'none' , lu_option_none ), & text_option ( 'local' , lu_option_local ), & text_option ( 'global' , lu_option_global ) / ) character ( 20 ) :: delt_option , lu_option integer :: ierr , in_file namelist / knobs / fphi , fapar , fbpar , delt , nstep , tend , & delt_option , lu_option , & avail_cpu_time , cfl_cushion , delt_adjust , & stream_implicit , mirror_implicit , driftkinetic_implicit , & drifts_implicit , & stream_matrix_inversion , maxwellian_inside_zed_derivative , & mirror_semi_lagrange , mirror_linear_interp , & zed_upwind , vpa_upwind , time_upwind , & fields_kxkyz , mat_gen , mat_read , rng_seed , & ky_solve_radial , ky_solve_real if ( proc0 ) then fphi = 1.0 fapar = 1.0 fbpar = - 1.0 fields_kxkyz = . false . stream_implicit = . true . mirror_implicit = . true . drifts_implicit = . false . driftkinetic_implicit = . false . maxwellian_inside_zed_derivative = . false . mirror_semi_lagrange = . true . mirror_linear_interp = . false . stream_matrix_inversion = . false . delt_option = 'default' lu_option = 'default' zed_upwind = 0.02 vpa_upwind = 0.02 time_upwind = 0.02 avail_cpu_time = 1.e10 cfl_cushion = 0.5 delt_adjust = 2.0 rng_seed = - 1 !negative values use current time as seed ky_solve_radial = 0 ky_solve_real = . false . mat_gen = . true . mat_read = . false . tend = - 1.0 nstep = - 1 in_file = input_unit_exist ( \"knobs\" , knexist ) if ( knexist ) read ( unit = in_file , nml = knobs ) ierr = error_unit () call get_option_value & ( delt_option , deltopts , delt_option_switch , ierr , & \"delt_option in knobs\" ) call get_option_value & ( lu_option , lu_opts , lu_option_switch , ierr , & \"lu_option in knobs\" ) if ( tend < 0 . and . nstep < 0 ) then ierr = error_unit () write ( ierr , * ) '' write ( ierr , * ) 'Please specify either <nstep> or <tend> in the <knobs> namelist.' write ( ierr , * ) 'Aborting.' write ( * , * ) '' write ( * , * ) 'Please specify either <nstep> or <tend> in the <knobs> namelist.' write ( * , * ) 'Aborting.' stop end if end if call broadcast ( fields_kxkyz ) call broadcast ( delt_option_switch ) call broadcast ( delt ) call broadcast ( lu_option_switch ) call broadcast ( cfl_cushion ) call broadcast ( delt_adjust ) call broadcast ( fphi ) call broadcast ( fapar ) call broadcast ( fbpar ) call broadcast ( stream_implicit ) call broadcast ( mirror_implicit ) call broadcast ( drifts_implicit ) call broadcast ( driftkinetic_implicit ) call broadcast ( maxwellian_inside_zed_derivative ) call broadcast ( mirror_semi_lagrange ) call broadcast ( mirror_linear_interp ) call broadcast ( stream_matrix_inversion ) call broadcast ( zed_upwind ) call broadcast ( vpa_upwind ) call broadcast ( time_upwind ) call broadcast ( nstep ) call broadcast ( tend ) call broadcast ( avail_cpu_time ) call broadcast ( rng_seed ) call broadcast ( ky_solve_radial ) call broadcast ( ky_solve_real ) call broadcast ( mat_gen ) call broadcast ( mat_read ) if (. not . include_mirror ) mirror_implicit = . false . code_delt_max = delt if ( driftkinetic_implicit ) then stream_implicit = . false . else if ( stream_implicit . and . full_flux_surface ) then stream_implicit = . false . write ( * , * ) write ( * , * ) \"!!!WARNING!!!\" write ( * , * ) \"The option stream_implicit=T is not supported for full_flux_surface=T.\" write ( * , * ) \"Setting driftkinetic_implicit=T instead.\" write ( * , * ) \"!!!WARNING!!!\" write ( * , * ) driftkinetic_implicit = . true . end if if ( mirror_implicit . or . stream_implicit . or . driftkinetic_implicit . or . drifts_implicit ) then fully_explicit = . false . else fully_explicit = . true . end if !> print warning messages and override inconsistent or unsupported options for full_flux_surface = T if ( full_flux_surface ) then if ( fields_kxkyz ) then write ( * , * ) write ( * , * ) '!!!WARNING!!!' write ( * , * ) 'The option fields_kxkyz=T is not currently supported for full_flux_surface=T.' write ( * , * ) 'Forcing fields_kxkyz=F.' write ( * , * ) '!!!WARNING!!!' write ( * , * ) fields_kxkyz = . false . end if if ( mirror_semi_lagrange ) then write ( * , * ) write ( * , * ) '!!!WARNING!!!' write ( * , * ) 'The option mirror_semi_lagrange=T is not consistent with full_flux_surface=T.' write ( * , * ) 'Forcing mirror_semi_lagrange=F.' write ( * , * ) '!!!WARNING!!!' end if end if end subroutine read_parameters subroutine finish_run_parameters implicit none initialized = . false . end subroutine finish_run_parameters end module run_parameters","tags":"","loc":"sourcefile/run_parameters.f90.html"},{"title":"species.f90 â€“ stella","text":"Contents Modules species Source Code species.f90 Source Code module species use common_types , only : spec_type implicit none public :: init_species , finish_species public :: read_species_knobs public :: reinit_species public :: communicate_species_multibox !public :: init_trin_species public :: nspec , spec , pfac public :: ion_species , electron_species , slowing_down_species , tracer_species public :: has_electron_species , has_slowing_down_species public :: ions , electrons , impurity public :: modified_adiabatic_electrons , adiabatic_electrons private integer , parameter :: ion_species = 1 integer , parameter :: electron_species = 2 ! for collision operator integer , parameter :: slowing_down_species = 3 ! slowing-down distn integer , parameter :: tracer_species = 4 ! for test particle diffusion studies integer :: species_option_switch integer , parameter :: species_option_stella = 1 integer , parameter :: species_option_inputprofs = 2 integer , parameter :: species_option_euterpe = 3 integer , parameter :: species_option_multibox = 4 integer :: nspec logical :: read_profile_variation , write_profile_variation logical :: ecoll_zeff logical :: modified_adiabatic_electrons , adiabatic_electrons type ( spec_type ), dimension (:), allocatable :: spec integer :: ions , electrons , impurity real :: pfac !  integer :: ntspec_trin !  real, dimension (:), allocatable :: dens_trin, temp_trin, fprim_trin, tprim_trin, nu_trin character ( 20 ) :: species_option logical :: initialized = . false . contains subroutine init_species !    use mp, only: trin_flag use mp , only : proc0 , broadcast use physics_parameters , only : vnew_ref , zeff use physics_flags , only : include_pressure_variation use physics_flags , only : adiabatic_option_switch , adiabatic_option_fieldlineavg use inputprofiles_interface , only : read_inputprof_spec use euterpe_interface , only : read_species_euterpe implicit none integer :: is , is2 if ( initialized ) return initialized = . true . allocate ( spec ( nspec )) if ( proc0 ) then select case ( species_option_switch ) case ( species_option_stella ) call read_species_stella case ( species_option_inputprofs ) call read_species_stella call read_inputprof_spec ( nspec , spec ) case ( species_option_euterpe ) call read_species_stella call read_species_euterpe ( nspec , spec ) case ( species_option_multibox ) call read_species_stella !this will be called by the central box in stella.f90 after !ktgrids is set up as we need to know the radial box size call communicate_species_multibox end select if ( ecoll_zeff ) then ! AVB: only intra-species collisions, account for e-i and e-impurity collisions using zeff do is = 1 , nspec ! initialize nu_ss' = 0 for all s' spec ( is )% vnew = 0. ! FLAG -- only contains self-collisions at the moment spec ( is )% vnew ( is ) = vnew_ref * spec ( is )% dens * spec ( is )% z ** 4 & / ( sqrt ( spec ( is )% mass ) * spec ( is )% temp ** 1.5 ) ! include electron-ion collisions if ( spec ( is )% type == electron_species ) then spec ( is )% vnew ( is ) = spec ( is )% vnew ( is ) * ( 1. + zeff ) end if end do else ! AVB: full intra- and inter-species collision frequencies do is = 1 , nspec do is2 = 1 , nspec if ( spec ( is )% type == electron_species ) then spec ( is )% vnew ( is2 ) = vnew_ref * spec ( is2 )% dens * spec ( is )% z ** 2 * spec ( is2 )% z ** 2 & / ( sqrt ( spec ( is )% mass ) * spec ( is )% temp ** 1.5 ) else if (( spec ( is )% type == ion_species ) . and . ( spec ( is2 )% type == ion_species )) then spec ( is )% vnew ( is2 ) = vnew_ref * spec ( is2 )% dens * spec ( is )% z ** 2 * spec ( is2 )% z ** 2 & / ( sqrt ( spec ( is )% mass ) * spec ( is )% temp ** 1.5 ) else if (( spec ( is )% type == ion_species ) . and . ( spec ( is2 )% type == electron_species )) then spec ( is )% vnew ( is2 ) = vnew_ref * spec ( is2 )% dens * spec ( is )% z ** 2 * spec ( is2 )% z ** 2 & / ( sqrt ( spec ( is )% mass ) * spec ( is )% temp ** 1.5 ) end if end do end do end if call dump_species_input end if pfac = 1.0 if (. not . include_pressure_variation ) pfac = 0.0 call broadcast_parameters ! set flag adiabatic_electrons to true if no kinetic electron species evolved adiabatic_electrons = . not . has_electron_species ( spec ) ! set flag modified_adiabatic_electrons to true if no kinetic electron species evolved ! and field-line-avg chosen as the adiabatic option modified_adiabatic_electrons = adiabatic_electrons & . and . adiabatic_option_switch == adiabatic_option_fieldlineavg !    if (trin_flag) call reinit_species (ntspec_trin, dens_trin, & !         temp_trin, fprim_trin, tprim_trin, nu_trin) end subroutine init_species subroutine read_species_knobs use mp , only : proc0 , job , broadcast use file_utils , only : error_unit , input_unit_exist use file_utils , only : runtype_option_switch , runtype_multibox use physics_flags , only : radial_variation use text_options , only : text_option , get_option_value implicit none integer :: ierr , in_file logical :: exist namelist / species_knobs / nspec , species_option , & read_profile_variation , & write_profile_variation , & ecoll_zeff type ( text_option ), dimension ( 4 ), parameter :: specopts = ( / & text_option ( 'default' , species_option_stella ), & text_option ( 'stella' , species_option_stella ), & text_option ( 'input.profiles' , species_option_inputprofs ), & text_option ( 'euterpe' , species_option_euterpe ) / ) if ( proc0 ) then nspec = 2 read_profile_variation = . false . write_profile_variation = . false . species_option = 'stella' ecoll_zeff = . false . in_file = input_unit_exist ( \"species_knobs\" , exist ) if ( exist ) read ( unit = in_file , nml = species_knobs ) ierr = error_unit () call get_option_value ( species_option , specopts , species_option_switch , & ierr , \"species_option in species_knobs\" ) if ( runtype_option_switch == runtype_multibox . and . ( job /= 1 ) . and . radial_variation ) then !will need to readjust the species parameters in the left/right boxes species_option_switch = species_option_multibox end if if ( nspec < 1 ) then ierr = error_unit () write ( unit = ierr , & fmt = \"('Invalid nspec in species_knobs: ', i5)\" ) nspec stop end if end if call broadcast ( nspec ) call broadcast ( read_profile_variation ) call broadcast ( write_profile_variation ) call broadcast ( ecoll_zeff ) call broadcast ( species_option_switch ) end subroutine read_species_knobs subroutine read_species_stella use file_utils , only : error_unit , get_indexed_namelist_unit use text_options , only : text_option , get_option_value use stella_geometry , only : geo_surf implicit none real :: z , mass , dens , temp , tprim , fprim , d2ndr2 , d2Tdr2 , dr , bess_fac integer :: ierr , unit , is character ( len = 128 ) :: filename character ( 20 ) :: type type ( text_option ), dimension ( 9 ), parameter :: typeopts = ( / & text_option ( 'default' , ion_species ), & text_option ( 'ion' , ion_species ), & text_option ( 'electron' , electron_species ), & text_option ( 'e' , electron_species ), & text_option ( 'beam' , slowing_down_species ), & text_option ( 'fast' , slowing_down_species ), & text_option ( 'alpha' , slowing_down_species ), & text_option ( 'slowing-down' , slowing_down_species ), & text_option ( 'trace' , tracer_species ) / ) namelist / species_parameters / z , mass , dens , temp , & tprim , fprim , d2ndr2 , d2Tdr2 , bess_fac , type do is = 1 , nspec call get_indexed_namelist_unit ( unit , \"species_parameters\" , is ) z = 1 mass = 1.0 dens = 1.0 temp = 1.0 tprim = - 99 9.9 fprim = - 99 9.9 d2ndr2 = 0.0 d2Tdr2 = 0.0 bess_fac = 1.0 type = \"default\" read ( unit = unit , nml = species_parameters ) close ( unit = unit ) spec ( is )% z = z spec ( is )% mass = mass spec ( is )% dens = dens spec ( is )% temp = temp spec ( is )% tprim = tprim spec ( is )% fprim = fprim ! this is (1/n_s)*d&#94;2 n_s / drho&#94;2 spec ( is )% d2ndr2 = d2ndr2 ! this is (1/T_s)*d&#94;2 T_s / drho&#94;2 spec ( is )% d2Tdr2 = d2Tdr2 spec ( is )% dens_psi0 = dens spec ( is )% temp_psi0 = temp spec ( is )% bess_fac = bess_fac if ( write_profile_variation ) then write ( filename , \"(A,I1)\" ) \"specprof_\" , is open ( 1002 , file = filename , status = 'unknown' ) write ( 1002 , '(6e13.5)' ) dens , temp , fprim , tprim , d2ndr2 , d2Tdr2 close ( 1002 ) end if if ( read_profile_variation ) then write ( filename , \"(A,I1)\" ) \"specprof_\" , is open ( 1002 , file = filename , status = 'unknown' ) read ( 1002 , '(6e13.5)' ) dens , temp , fprim , tprim , d2ndr2 , d2Tdr2 close ( 1002 ) dr = geo_surf % rhoc - geo_surf % rhoc_psi0 spec ( is )% dens = dens * ( 1.0 - dr * fprim ) ! + 0.5*dr**2*d2ndr2) spec ( is )% temp = temp * ( 1.0 - dr * tprim ) ! + 0.5*dr**2*d2Tdr2) spec ( is )% fprim = ( fprim - dr * d2ndr2 ) * ( dens / spec ( is )% dens ) spec ( is )% tprim = ( tprim - dr * d2Tdr2 ) * ( temp / spec ( is )% temp ) !spec(is)%dens = 1.0 !spec(is)%temp = 1.0 end if ierr = error_unit () call get_option_value ( type , typeopts , spec ( is )% type , ierr , \"type in species_parameters_x\" ) end do end subroutine read_species_stella subroutine broadcast_parameters use mp , only : broadcast implicit none integer :: is do is = 1 , nspec call broadcast ( spec ( is )% z ) call broadcast ( spec ( is )% mass ) call broadcast ( spec ( is )% dens ) call broadcast ( spec ( is )% temp ) call broadcast ( spec ( is )% tprim ) call broadcast ( spec ( is )% fprim ) call broadcast ( spec ( is )% vnew ) call broadcast ( spec ( is )% d2ndr2 ) call broadcast ( spec ( is )% d2Tdr2 ) call broadcast ( spec ( is )% dens_psi0 ) call broadcast ( spec ( is )% temp_psi0 ) call broadcast ( spec ( is )% bess_fac ) call broadcast ( spec ( is )% type ) spec ( is )% stm = sqrt ( spec ( is )% temp / spec ( is )% mass ) spec ( is )% zstm = spec ( is )% z / sqrt ( spec ( is )% temp * spec ( is )% mass ) spec ( is )% tz = spec ( is )% temp / spec ( is )% z spec ( is )% zt = spec ( is )% z / spec ( is )% temp spec ( is )% smz = abs ( sqrt ( spec ( is )% temp * spec ( is )% mass ) / spec ( is )% z ) spec ( is )% stm_psi0 = sqrt ( spec ( is )% temp_psi0 / spec ( is )% mass ) spec ( is )% zstm_psi0 = spec ( is )% z / sqrt ( spec ( is )% temp_psi0 * spec ( is )% mass ) spec ( is )% tz_psi0 = spec ( is )% temp_psi0 / spec ( is )% z spec ( is )% zt_psi0 = spec ( is )% z / spec ( is )% temp_psi0 spec ( is )% smz_psi0 = abs ( sqrt ( spec ( is )% temp_psi0 * spec ( is )% mass ) / spec ( is )% z ) end do end subroutine broadcast_parameters pure function has_electron_species ( spec ) use common_types , only : spec_type implicit none type ( spec_type ), dimension (:), intent ( in ) :: spec logical :: has_electron_species has_electron_species = any ( spec % type == electron_species ) end function has_electron_species pure function has_slowing_down_species ( spec ) use common_types , only : spec_type implicit none type ( spec_type ), dimension (:), intent ( in ) :: spec logical :: has_slowing_down_species has_slowing_down_species = any ( spec % type == slowing_down_species ) end function has_slowing_down_species subroutine finish_species implicit none deallocate ( spec ) initialized = . false . end subroutine finish_species subroutine reinit_species ( ntspec , dens , temp , fprim , tprim , bess_fac ) use mp , only : broadcast , proc0 implicit none integer , intent ( in ) :: ntspec real , dimension (:), intent ( in ) :: dens , fprim , temp , tprim , bess_fac integer :: is logical , save :: first = . true . if ( first ) then if ( nspec == 1 ) then ions = 1 electrons = 0 impurity = 0 else ! if 2 or more species in GS2 calculation, figure out which is main ion ! and which is electron via mass (main ion mass assumed to be one) do is = 1 , nspec if ( abs ( spec ( is )% mass - 1.0 ) <= epsilon ( 0.0 )) then ions = is else if ( spec ( is )% mass < 0.3 ) then ! for electrons, assuming electrons are at least a factor of 3 less massive ! than main ion and other ions are no less than 30% the mass of the main ion electrons = is else if ( spec ( is )% mass > 1.0 + epsilon ( 0.0 )) then impurity = is else if ( proc0 ) write ( * , * ) & \"Error: TRINITY requires the main ions to have mass 1\" , & \"and the secondary ions to be impurities (mass > 1)\" stop end if end do end if first = . false . end if if ( proc0 ) then nspec = ntspec ! Species are passed in following order: main ion, electron, impurity (if present) if ( nspec == 1 ) then spec ( 1 )% dens = dens ( 1 ) spec ( 1 )% temp = temp ( 1 ) spec ( 1 )% fprim = fprim ( 1 ) spec ( 1 )% tprim = tprim ( 1 ) spec ( 1 )% bess_fac = bess_fac ( 1 ) else spec ( ions )% dens = dens ( 1 ) spec ( ions )% temp = temp ( 1 ) spec ( ions )% fprim = fprim ( 1 ) spec ( ions )% tprim = tprim ( 1 ) spec ( ions )% bess_fac = bess_fac ( 1 ) spec ( electrons )% dens = dens ( 2 ) spec ( electrons )% temp = temp ( 2 ) spec ( electrons )% fprim = fprim ( 2 ) spec ( electrons )% tprim = tprim ( 2 ) spec ( electrons )% bess_fac = bess_fac ( 2 ) if ( nspec > 2 ) then spec ( impurity )% dens = dens ( 3 ) spec ( impurity )% temp = temp ( 3 ) spec ( impurity )% fprim = fprim ( 3 ) spec ( impurity )% tprim = tprim ( 3 ) spec ( impurity )% bess_fac = bess_fac ( 3 ) end if end if do is = 1 , nspec spec ( is )% stm = sqrt ( spec ( is )% temp / spec ( is )% mass ) spec ( is )% zstm = spec ( is )% z / sqrt ( spec ( is )% temp * spec ( is )% mass ) spec ( is )% tz = spec ( is )% temp / spec ( is )% z spec ( is )% zt = spec ( is )% z / spec ( is )% temp spec ( is )% smz = abs ( sqrt ( spec ( is )% temp * spec ( is )% mass ) / spec ( is )% z ) !          write (*,100) 'reinit_species', rhoc_ms, spec(is)%temp, spec(is)%fprim, & !               spec(is)%tprim, spec(is)%vnewk, real(is) end do call dump_species_input end if !100 format (a15,9(1x,1pg18.11)) call broadcast ( nspec ) do is = 1 , nspec call broadcast ( spec ( is )% dens ) call broadcast ( spec ( is )% temp ) call broadcast ( spec ( is )% fprim ) call broadcast ( spec ( is )% tprim ) call broadcast ( spec ( is )% bess_fac ) call broadcast ( spec ( is )% stm ) call broadcast ( spec ( is )% zstm ) call broadcast ( spec ( is )% tz ) call broadcast ( spec ( is )% zt ) call broadcast ( spec ( is )% smz ) end do end subroutine reinit_species subroutine communicate_species_multibox ( dr_m , dr_p ) use job_manage , only : njobs use mp , only : job , scope , mp_abort , & crossdomprocs , subprocs , & send , receive implicit none real , optional , intent ( in ) :: dr_m , dr_p real , dimension (:), allocatable :: dens , ldens , ltemp , lfprim , ltprim real , dimension (:), allocatable :: temp , rdens , rtemp , rfprim , rtprim integer :: i allocate ( dens ( nspec )) allocate ( temp ( nspec )) allocate ( ldens ( nspec )) allocate ( ltemp ( nspec )) allocate ( lfprim ( nspec )) allocate ( ltprim ( nspec )) allocate ( rdens ( nspec )) allocate ( rtemp ( nspec )) allocate ( rfprim ( nspec )) allocate ( rtprim ( nspec )) if ( job == 1 ) then ! recall that fprim and tprim are the negative gradients ldens = spec % dens * ( 1.0 - dr_m * spec % fprim ) ! + 0.5*dr_m**2*spec%d2ndr2) ltemp = spec % temp * ( 1.0 - dr_m * spec % tprim ) ! + 0.5*dr_m**2*spec%d2Tdr2) lfprim = ( spec % fprim - dr_m * spec % d2ndr2 ) * ( spec % dens / ldens ) ltprim = ( spec % tprim - dr_m * spec % d2Tdr2 ) * ( spec % temp / ltemp ) rdens = spec % dens * ( 1.0 - dr_p * spec % fprim ) ! + 0.5*dr_p**2*spec%d2ndr2) rtemp = spec % temp * ( 1.0 - dr_p * spec % tprim ) ! + 0.5*dr_p**2*spec%d2Tdr2) rfprim = ( spec % fprim - dr_p * spec % d2ndr2 ) * ( spec % dens / rdens ) rtprim = ( spec % tprim - dr_p * spec % d2Tdr2 ) * ( spec % temp / rtemp ) do i = 1 , nspec if ( ldens ( i ) < 0 . or . ltemp ( i ) < 0 . or . & rdens ( i ) < 0 . or . rtemp ( i ) < 0 ) then call mp_abort ( 'Negative n/T encountered. Try reducing rhostar.' ) end if end do end if call scope ( crossdomprocs ) if ( job == 1 ) then call send ( ldens , 0 , 120 ) call send ( ltemp , 0 , 121 ) call send ( lfprim , 0 , 122 ) call send ( ltprim , 0 , 123 ) call send ( spec % dens , 0 , 124 ) call send ( spec % temp , 0 , 125 ) call send ( rdens , njobs - 1 , 130 ) call send ( rtemp , njobs - 1 , 131 ) call send ( rfprim , njobs - 1 , 132 ) call send ( rtprim , njobs - 1 , 133 ) call send ( spec % dens , njobs - 1 , 134 ) call send ( spec % temp , njobs - 1 , 135 ) elseif ( job == 0 ) then call receive ( ldens , 1 , 120 ) call receive ( ltemp , 1 , 121 ) call receive ( lfprim , 1 , 122 ) call receive ( ltprim , 1 , 123 ) call receive ( dens , 1 , 124 ) call receive ( temp , 1 , 125 ) spec % dens = ldens spec % temp = ltemp spec % fprim = lfprim spec % tprim = ltprim spec % dens_psi0 = dens spec % temp_psi0 = temp elseif ( job == njobs - 1 ) then call receive ( rdens , 1 , 130 ) call receive ( rtemp , 1 , 131 ) call receive ( rfprim , 1 , 132 ) call receive ( rtprim , 1 , 133 ) call receive ( dens , 1 , 134 ) call receive ( temp , 1 , 135 ) spec % dens = rdens spec % temp = rtemp spec % fprim = rfprim spec % tprim = rtprim spec % dens_psi0 = dens spec % temp_psi0 = temp end if call scope ( subprocs ) deallocate ( dens ) deallocate ( temp ) deallocate ( ldens ) deallocate ( ltemp ) deallocate ( lfprim ) deallocate ( ltprim ) deallocate ( rdens ) deallocate ( rtemp ) deallocate ( rfprim ) deallocate ( rtprim ) end subroutine communicate_species_multibox subroutine dump_species_input use file_utils , only : run_name implicit none integer :: is character ( 300 ) :: filename filename = trim ( trim ( run_name ) // '.species.input' ) open ( 1003 , file = filename , status = 'unknown' ) write ( 1003 , '(9a12,a9)' ) '#1.z' , '2.mass' , '3.dens' , & '4.temp' , '5.tprim' , '6.fprim' , '7.vnewss' , & '8.dens_psi0' , '9.temp_psi0' , '11.type' do is = 1 , nspec write ( 1003 , '(9e12.4,i9)' ) spec ( is )% z , spec ( is )% mass , & spec ( is )% dens , spec ( is )% temp , spec ( is )% tprim , & spec ( is )% fprim , spec ( is )% vnew ( is ), & spec ( is )% dens_psi0 , spec ( is )% temp_psi0 , & spec ( is )% type end do close ( 1003 ) end subroutine dump_species_input !   subroutine init_trin_species (ntspec_in, dens_in, temp_in, fprim_in, tprim_in, nu_in) !     implicit none !     integer, intent (in) :: ntspec_in !     real, dimension (:), intent (in) :: dens_in, fprim_in, temp_in, tprim_in, nu_in !     if (.not. allocated(temp_trin)) then !        allocate (dens_trin(size(dens_in))) !        allocate (fprim_trin(size(fprim_in))) !        allocate (temp_trin(size(temp_in))) !        allocate (tprim_trin(size(tprim_in))) !        allocate (nu_trin(size(nu_in))) !     end if !     ntspec_trin = ntspec_in !     dens_trin = dens_in !     temp_trin = temp_in !     fprim_trin = fprim_in !     tprim_trin = tprim_in !     nu_trin = nu_in !   end subroutine init_trin_species end module species","tags":"","loc":"sourcefile/species.f90.html"},{"title":"multibox.fpp â€“ stella","text":"Contents Modules multibox Source Code multibox.fpp Source Code module multibox use fft_work , only : fft_type implicit none public :: read_multibox_parameters public :: init_multibox public :: finish_multibox public :: multibox_communicate public :: apply_radial_boundary_conditions public :: init_mb_get_phi public :: mb_get_phi public :: communicate_multibox_parameters public :: add_multibox_krook public :: bs_fullgrid public :: xL , xR public :: rhoL , rhoR public :: kx0_L , kx0_R public :: RK_step , comm_at_init public :: include_multibox_krook public :: time_multibox public :: phi_buffer0 , phi_buffer1 public :: use_dirichlet_BC private complex , dimension (:), allocatable :: g_buffer0 , g_buffer1 , phi_buffer0 , phi_buffer1 complex , dimension (:), allocatable :: fsa_x real , dimension (:), allocatable :: copy_mask_left , copy_mask_right real , dimension (:), allocatable :: krook_mask_left , krook_mask_right real , dimension (:), allocatable :: krook_fac real , dimension (:), allocatable :: b_mat real , dimension (:), allocatable :: x_mb , rho_mb , rho_mb_clamped real , dimension ( 2 , 2 ) :: time_multibox = 0. real :: dx_mb complex , dimension (:, :), allocatable :: fft_kxky , fft_xky real , dimension (:, :), allocatable :: fft_xy ! for the unpadded FFTs type ( fft_type ) :: yf_fft , yb_fft type ( fft_type ) :: xf_fft , xb_fft complex , dimension (:), allocatable :: fft_x_k , fft_x_x complex , dimension (:), allocatable :: fft_y_k real , dimension (:), allocatable :: fft_y_y logical :: mb_transforms_initialized = . false . logical :: get_phi_initialized = . false . logical :: use_multibox integer :: temp_ind = 0 integer :: bs_fullgrid integer :: mb_debug_step integer :: x_fft_size integer :: phi_bound , phi_pow integer :: ikymin real :: xL = 0. , xR = 0. real :: rhoL = 0. , rhoR = 0. real :: kx0_L , kx0_R !real :: efac_l, efacp_l real :: nu_krook_mb , krook_exponent , krook_efold logical :: smooth_ZFs , use_dirichlet_BC logical :: RK_step , include_multibox_krook , comm_at_init integer :: krook_option_switch integer , parameter :: krook_option_default = 1 , & krook_option_flat = 0 , & krook_option_linear = 1 , & krook_option_exp = 2 , & krook_option_exp_rev = 3 integer :: mb_zf_option_switch integer , parameter :: mb_zf_option_default = 0 , & mb_zf_option_skip_ky0 = 1 , & mb_zf_option_zero_ky0 = 2 , & mb_zf_option_zero_fsa = 3 integer :: LR_debug_switch integer , parameter :: LR_debug_option_default = 0 , & LR_debug_option_L = 1 , & LR_debug_option_R = 2 contains subroutine read_multibox_parameters use file_utils , only : input_unit_exist , error_unit use file_utils , only : runtype_option_switch , runtype_multibox use text_options , only : text_option , get_option_value use mp , only : broadcast , proc0 use kt_grids , only : nx , nakx , boundary_size , copy_size , krook_size use job_manage , only : njobs use mp , only : scope , crossdomprocs , subprocs , & send , receive , job implicit none integer :: in_file , ierr integer :: nakxl , nxl , nakxr , nxr , fac logical exist type ( text_option ), dimension ( 5 ), parameter :: krook_opts = & ( / text_option ( 'default' , krook_option_default ), & text_option ( 'flat' , krook_option_flat ), & text_option ( 'linear' , krook_option_linear ), & text_option ( 'exp' , krook_option_exp ), & text_option ( 'exp_reverse' , krook_option_exp_rev ) / ) type ( text_option ), dimension ( 4 ), parameter :: mb_zf_opts = & ( / text_option ( 'default' , mb_zf_option_default ), & text_option ( 'skip_ky0' , mb_zf_option_skip_ky0 ), & text_option ( 'zero_ky0' , mb_zf_option_zero_ky0 ), & text_option ( 'zero_fsa' , mb_zf_option_zero_fsa ) / ) type ( text_option ), dimension ( 3 ), parameter :: LR_db_opts = & ( / text_option ( 'default' , LR_debug_option_default ), & text_option ( 'L' , LR_debug_option_L ), & text_option ( 'R' , LR_debug_option_R ) / ) character ( 30 ) :: zf_option , krook_option , LR_debug_option namelist / multibox_parameters / boundary_size , krook_size , & smooth_ZFs , zf_option , LR_debug_option , & krook_option , RK_step , nu_krook_mb , & mb_debug_step , krook_exponent , comm_at_init , & phi_bound , phi_pow , krook_efold , use_dirichlet_BC !   if(runtype_option_switch /= runtype_multibox) then !     boundary_size = 0; krook_size = 0; copy_size = 0 !     return !   endif boundary_size = 4 krook_size = 0 phi_bound = 0 phi_pow = 0 krook_exponent = 0.0 krook_efold = 3.0 nu_krook_mb = 0.0 mb_debug_step = 1000 smooth_ZFs = . false . comm_at_init = . false . RK_step = . false . zf_option = 'default' krook_option = 'default' LR_debug_option = 'default' use_dirichlet_BC = . false . if ( proc0 ) then in_file = input_unit_exist ( \"multibox_parameters\" , exist ) if ( exist ) read ( in_file , nml = multibox_parameters ) ierr = error_unit () call get_option_value & ( krook_option , krook_opts , krook_option_switch , & ierr , \"krook_option in multibox_parameters\" ) call get_option_value & ( zf_option , mb_zf_opts , mb_zf_option_switch , & ierr , \"zf_option in multibox_parameters\" ) call get_option_value & ( LR_debug_option , LR_db_opts , LR_debug_switch , & ierr , \"LR_debug_option in multibox_parameters\" ) if ( krook_size > boundary_size ) krook_size = boundary_size end if call broadcast ( boundary_size ) call broadcast ( krook_size ) call broadcast ( nu_krook_mb ) call broadcast ( smooth_ZFs ) call broadcast ( mb_zf_option_switch ) call broadcast ( krook_option_switch ) call broadcast ( krook_exponent ) call broadcast ( krook_efold ) call broadcast ( LR_debug_switch ) call broadcast ( RK_step ) call broadcast ( mb_debug_step ) call broadcast ( comm_at_init ) call broadcast ( phi_bound ) call broadcast ( phi_pow ) call broadcast ( use_dirichlet_BC ) if ( runtype_option_switch == runtype_multibox ) then call scope ( crossdomprocs ) if ( job == 1 ) then call receive ( nakxl , 0 ) call receive ( nxl , 0 ) call receive ( nakxr , njobs - 1 ) call receive ( nxr , njobs - 1 ) ! the following assumes nx in the center domain is some ! integer multiple of nx in the left or right domain. ! Also assumes dx is the same in every domain, which should ! be the case fac = nx / nxl x_fft_size = nakxl * fac else call send ( nakx , 1 ) call send ( nx , 1 ) x_fft_size = nakx end if call scope ( subprocs ) else x_fft_size = nakx end if if (( runtype_option_switch == runtype_multibox ) . or . use_dirichlet_bc ) then use_multibox = . true . else use_multibox = . false . end if if ( abs ( nu_krook_mb ) > epsilon ( 0.0 ) . and . use_multibox ) then include_multibox_krook = . true . end if copy_size = boundary_size - krook_size end subroutine read_multibox_parameters subroutine init_multibox use constants , only : pi use stella_layouts , only : vmu_lo use stella_geometry , only : geo_surf , q_as_x , get_x_to_rho use stella_geometry , only : drhodpsi , dxdXcoord use zgrid , only : nzgrid , ntubes use kt_grids , only : nakx , naky , akx , aky , nx , x , x_d , x0 use kt_grids , only : centered_in_rho , rho_clamped , rho_d , rho_d_clamped use kt_grids , only : periodic_variation use kt_grids , only : boundary_size , krook_size use file_utils , only : runtype_option_switch , runtype_multibox use job_manage , only : njobs use physics_parameters , only : rhostar use mp , only : scope , crossdomprocs , subprocs , & send , receive , job implicit none integer :: g_buff_size integer :: phi_buff_size integer :: i , pfac real , dimension (:), allocatable :: x_clamped , x_d_clamped , x_mb_clamped real :: db , x_shift , dqdrho if (. not . use_multibox ) return bs_fullgrid = nint (( 3.0 * boundary_size ) / 2.0 ) ikymin = 1 if ( mb_zf_option_switch == mb_zf_option_skip_ky0 ) ikymin = 2 pfac = 1 if ( periodic_variation ) pfac = 2 phi_buff_size = pfac * boundary_size * naky * ntubes * ( 2 * nzgrid + 1 ) g_buff_size = phi_buff_size * ( vmu_lo % ulim_alloc - vmu_lo % llim_proc + 1 ) if (. not . allocated ( g_buffer0 )) allocate ( g_buffer0 ( g_buff_size )) if (. not . allocated ( g_buffer1 )) allocate ( g_buffer1 ( g_buff_size )) if (. not . allocated ( phi_buffer0 )) allocate ( phi_buffer0 ( phi_buff_size )) if (. not . allocated ( phi_buffer1 )) allocate ( phi_buffer1 ( phi_buff_size )) if (. not . allocated ( fsa_x ) . and . ( mb_zf_option_switch == mb_zf_option_zero_fsa )) then allocate ( fsa_x ( nakx )); fsa_x = 0.0 end if if (. not . allocated ( copy_mask_left )) allocate ( copy_mask_left ( pfac * boundary_size )); copy_mask_left = 1.0 if (. not . allocated ( copy_mask_right )) allocate ( copy_mask_right ( pfac * boundary_size )); copy_mask_right = 1.0 if (. not . allocated ( krook_mask_left )) allocate ( krook_mask_left ( pfac * boundary_size )); krook_mask_left = 0.0 if (. not . allocated ( krook_mask_right )) allocate ( krook_mask_right ( pfac * boundary_size )); krook_mask_right = 0.0 g_buffer0 = 0. g_buffer1 = 0. phi_buffer0 = 0. phi_buffer1 = 0. if ( krook_size > 0 ) then select case ( krook_option_switch ) case ( krook_option_flat ) do i = 1 , krook_size krook_mask_right ( i ) = 1.0 copy_mask_right ( i ) = 0.0 end do case ( krook_option_linear ) db = 1.0 / krook_size do i = 1 , krook_size krook_mask_right ( i ) = i * db copy_mask_right ( i ) = 0.0 end do case ( krook_option_exp ) db = krook_efold / krook_size do i = 1 , krook_size krook_mask_right ( i ) = 1.0 - ( 1.0 - exp ( - ( krook_size - i ) * db )) / ( 1.0 - exp ( - krook_efold )) copy_mask_right ( i ) = 0.0 end do case ( krook_option_exp_rev ) db = krook_efold / krook_size do i = 1 , krook_size krook_mask_right ( i ) = ( 1.0 - exp ( - i * db )) / ( 1.0 - exp ( - krook_efold )) copy_mask_right ( i ) = 0.0 end do end select end if if ( periodic_variation ) then do i = 1 , boundary_size copy_mask_right ( i + boundary_size ) = copy_mask_right ( boundary_size - i + 1 ) krook_mask_right ( i + boundary_size ) = krook_mask_right ( boundary_size - i + 1 ) end do copy_mask_left = copy_mask_right krook_mask_left = krook_mask_right else do i = 1 , boundary_size copy_mask_left ( i ) = copy_mask_right ( boundary_size - i + 1 ) krook_mask_left ( i ) = krook_mask_right ( boundary_size - i + 1 ) end do end if if (. not . allocated ( krook_fac )) allocate ( krook_fac ( naky )) krook_fac = 1.0 do i = 2 , naky krook_fac ( i ) = ( aky ( i ) / aky ( 2 )) ** krook_exponent end do call init_mb_transforms if (. not . allocated ( x_mb )) allocate ( x_mb ( x_fft_size )) if (. not . allocated ( rho_mb )) allocate ( rho_mb ( x_fft_size )) if (. not . allocated ( rho_mb_clamped )) allocate ( rho_mb_clamped ( x_fft_size )) if ( runtype_option_switch /= runtype_multibox ) then x_mb = x_d rho_mb = rho_d rho_mb_clamped = rho_d_clamped return end if #ifdef MPI call scope ( crossdomprocs ) dx_mb = ( 2 * pi * x0 ) / x_fft_size if ( job == 1 ) then x_shift = pi * x0 if ( centered_in_rho ) then if ( q_as_x ) then dqdrho = geo_surf % shat * geo_surf % qinp / geo_surf % rhoc x_shift = pi * x0 * ( 1.0 & - 0.5 * rhostar * pi * x0 * geo_surf % d2qdr2 / ( pfac * dqdrho ** 2 * dxdXcoord )) else x_shift = pi * x0 * ( 1.0 & - 0.5 * rhostar * pi * x0 * geo_surf % d2psidr2 * drhodpsi ** 2 / ( pfac * dxdXcoord )) end if end if do i = 1 , x_fft_size if ( periodic_variation ) then if ( i <= ( x_fft_size / 2 )) then x_mb ( i ) = ( i - 1 ) * dx_mb - 0.5 * x_shift else x_mb ( i ) = x_mb ( x_fft_size - i + 1 ) end if else x_mb ( i ) = ( i - 0.5 ) * dx_mb - x_shift end if end do call get_x_to_rho ( 1 , x_mb , rho_mb ) xL = x_mb ( boundary_size ) xR = x_mb ( x_fft_size / pfac - boundary_size + 1 ) rhoL = rho_mb ( boundary_size ) rhoR = rho_mb ( x_fft_size / pfac - boundary_size + 1 ) allocate ( x_clamped ( nx )) allocate ( x_d_clamped ( nakx )) allocate ( x_mb_clamped ( x_fft_size )) if ( LR_debug_switch == LR_debug_option_L ) then x_clamped = xL x_d_clamped = xL x_mb_clamped = xL else if ( LR_debug_switch == LR_debug_option_R ) then x_clamped = xR x_d_clamped = xR x_mb_clamped = xR else x_clamped = x x_d_clamped = x_d x_mb_clamped = x_mb do i = 1 , nx if ( x_clamped ( i ) < xL ) x_clamped ( i ) = xL if ( x_clamped ( i ) > xR ) x_clamped ( i ) = xR end do do i = 1 , x_fft_size if ( x_mb_clamped ( i ) < xL ) x_mb_clamped ( i ) = xL if ( x_mb_clamped ( i ) > xR ) x_mb_clamped ( i ) = xR end do do i = 1 , nakx if ( x_d_clamped ( i ) < xL ) x_d_clamped ( i ) = xL if ( x_d_clamped ( i ) > xR ) x_d_clamped ( i ) = xR end do end if call get_x_to_rho ( 1 , x_clamped , rho_clamped ) call get_x_to_rho ( 1 , x_d_clamped , rho_d_clamped ) call get_x_to_rho ( 1 , x_mb_clamped , rho_mb_clamped ) deallocate ( x_clamped , x_d_clamped ) elseif ( job == 0 ) then do i = 1 , x_fft_size x_mb ( i ) = ( i - 1 ) * dx_mb end do call receive ( xL , 1 ) call send ( akx ( 2 ), 1 ) elseif ( job == njobs - 1 ) then do i = 1 , x_fft_size x_mb ( i ) = ( i - 1 ) * dx_mb end do call receive ( xR , 1 ) call send ( akx ( 2 ), 1 ) end if call scope ( subprocs ) #endif end subroutine init_multibox subroutine communicate_multibox_parameters use job_manage , only : njobs use mp , only : scope , crossdomprocs , subprocs , & send , receive , job implicit none #ifdef MPI if ( job == 1 ) then call scope ( crossdomprocs ) call send ( xL , 0 ) call send ( xR , njobs - 1 ) call receive ( kx0_L , 0 ) call receive ( kx0_R , njobs - 1 ) call scope ( subprocs ) end if #endif end subroutine communicate_multibox_parameters subroutine finish_multibox implicit none if ( allocated ( g_buffer0 )) deallocate ( g_buffer0 ) if ( allocated ( g_buffer1 )) deallocate ( g_buffer1 ) if ( allocated ( phi_buffer0 )) deallocate ( phi_buffer0 ) if ( allocated ( phi_buffer1 )) deallocate ( phi_buffer1 ) if ( allocated ( fsa_x )) deallocate ( fsa_x ) if ( allocated ( copy_mask_left )) deallocate ( copy_mask_left ) if ( allocated ( copy_mask_right )) deallocate ( copy_mask_right ) if ( allocated ( krook_mask_left )) deallocate ( krook_mask_left ) if ( allocated ( krook_mask_right )) deallocate ( krook_mask_right ) if ( allocated ( krook_fac )) deallocate ( krook_fac ) if ( allocated ( fft_kxky )) deallocate ( fft_kxky ) if ( allocated ( fft_xky )) deallocate ( fft_xky ) if ( allocated ( fft_xy )) deallocate ( fft_xy ) if ( allocated ( x_mb )) deallocate ( x_mb ) if ( allocated ( rho_mb )) deallocate ( rho_mb ) if ( allocated ( rho_mb_clamped )) deallocate ( rho_mb_clamped ) call finish_mb_transforms end subroutine finish_multibox subroutine multibox_communicate ( gin ) use constants , only : zi use kt_grids , only : nakx , naky , naky_all , akx , aky , nx , ny , dx , dy , zonal_mode use kt_grids , only : periodic_variation , boundary_size use file_utils , only : runtype_option_switch , runtype_multibox use file_utils , only : get_unused_unit use fields_arrays , only : phi , phi_corr_QN , shift_state use job_manage , only : njobs , time_message use physics_flags , only : radial_variation , prp_shear_enabled , hammett_flow_shear use physics_parameters , only : g_exb , g_exbfac use stella_layouts , only : vmu_lo use stella_geometry , only : dl_over_b use zgrid , only : nzgrid use mp , only : job , scope , mp_abort , & crossdomprocs , subprocs , allprocs , & ssend , receive , proc0 implicit none integer :: num , ia , ix , iix , iky , iz , it , iv integer :: offset integer :: ii , jj , temp_unit , pfac real :: afacx , afacy character ( len = 512 ) :: filename complex , dimension (:, :), allocatable :: prefac complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( inout ) :: gin #ifndef MPI return #else if ( runtype_option_switch /= runtype_multibox ) return if ( LR_debug_switch /= LR_debug_option_default ) return if ( njobs /= 3 ) call mp_abort ( \"Multibox only supports 3 domains at the moment.\" ) if ( proc0 ) call time_message (. false ., time_multibox (:, 1 ), ' mb_comm' ) allocate ( prefac ( naky , x_fft_size )); prefac = 1.0 pfac = 1 if ( periodic_variation ) pfac = 2 if ( prp_shear_enabled . and . hammett_flow_shear ) then prefac = exp ( - zi * g_exb * g_exbfac * spread ( x_mb , 1 , naky ) * spread ( aky * shift_state , 2 , x_fft_size )) end if if ( mod ( temp_ind , mb_debug_step ) == 0 . and . proc0 ) then ! call get_unused_unit(temp_unit) temp_unit = 3023 + job afacx = real ( nx ) / real ( x_fft_size ) afacy = real ( ny ) / real ( 2 * naky - 1 ) fft_kxky = phi (:, :, 0 , 1 ) if ( radial_variation ) then fft_kxky = fft_kxky + phi_corr_QN (:, :, 0 , 1 ) end if call transform_kx2x ( fft_kxky , fft_xky ) fft_xky = fft_xky * prefac call transform_ky2y ( fft_xky , fft_xy ) write ( filename , \"(A,I1,A,I0.6)\" ) \"phiout\" , job , \"_\" , temp_ind open ( unit = temp_unit , file = filename , status = \"replace\" , & action = \"write\" , form = \"unformatted\" , access = \"stream\" ) write ( temp_unit ) real ( x_fft_size , 4 ) do ii = 1 , x_fft_size write ( temp_unit ) real ( afacx * dx * ( ii - 1 ), 4 ) end do do ii = 1 , naky_all write ( temp_unit ) real ( afacy * dy * ( ii - 1 ), 4 ) do jj = 1 , x_fft_size write ( temp_unit ) real ( fft_xy ( ii , jj ), 4 ) end do end do close ( unit = temp_unit ) end if ! DSO - change communicator call scope ( crossdomprocs ) ia = 1 if ( job == 0 . or . job == ( njobs - 1 )) then if ( periodic_variation ) then offset = - boundary_size else offset = 0 ; ! DSO the next line might seem backwards, but this makes it easier to stitch together imaages ! FLAG DSO - might do something weird with magnetic shear if ( job == njobs - 1 ) offset = nakx - boundary_size end if !first g num = 1 do iv = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , vmu_lo % ntubes !this is where the FSA goes if ( zonal_mode ( 1 ) . and . mb_zf_option_switch == mb_zf_option_zero_fsa ) then do ix = 1 , nakx fsa_x ( ix ) = sum ( dl_over_b ( ia , :) * gin ( 1 , ix , :, it , iv )) end do end if do iz = - vmu_lo % nzgrid , vmu_lo % nzgrid fft_kxky = gin (:, :, iz , it , iv ) if ( zonal_mode ( 1 )) then if ( mb_zf_option_switch == mb_zf_option_zero_ky0 ) then fft_kxky ( 1 , :) = 0.0 elseif ( mb_zf_option_switch == mb_zf_option_zero_fsa ) then fft_kxky ( 1 , :) = fft_kxky ( 1 , :) - fsa_x end if end if call transform_kx2x ( fft_kxky , fft_xky ) fft_xky = fft_xky * prefac do ix = 1 , pfac * boundary_size iix = ix + offset if ( iix <= 0 ) iix = iix + nakx do iky = ikymin , naky !DSO if in the future the grids can have different naky, one will !have to divide by naky here, and multiply on the receiving end g_buffer0 ( num ) = fft_xky ( iky , iix ) num = num + 1 end do end do end do end do end do call ssend ( g_buffer0 , 1 , 43 + job ) !now phi num = 1 do it = 1 , vmu_lo % ntubes !this is where the FSA goes if ( zonal_mode ( 1 ) . and . mb_zf_option_switch == mb_zf_option_zero_fsa ) then do ix = 1 , nakx fsa_x ( ix ) = sum ( dl_over_b ( ia , :) * phi ( 1 , ix , :, it )) end do end if do iz = - vmu_lo % nzgrid , vmu_lo % nzgrid fft_kxky = spread (( zi * akx ) ** phi_pow , 1 , naky ) * phi (:, :, iz , it ) if ( zonal_mode ( 1 )) then if ( mb_zf_option_switch == mb_zf_option_zero_ky0 ) then fft_kxky ( 1 , :) = 0.0 elseif ( mb_zf_option_switch == mb_zf_option_zero_fsa ) then fft_kxky ( 1 , :) = fft_kxky ( 1 , :) - fsa_x end if end if call transform_kx2x ( fft_kxky , fft_xky ) fft_xky = fft_xky * prefac do iky = ikymin , naky do ix = 1 , pfac * boundary_size iix = ix + offset if ( iix <= 0 ) iix = iix + nakx !DSO if in the future the grids can have different naky, one will !have to divide by naky here, and multiply on the receiving end phi_buffer0 ( num ) = fft_xky ( iky , iix ) num = num + 1 end do end do end do end do ! DSO - send data call ssend ( phi_buffer0 , 1 , 143 + job ) else ! DSO - receive the data ! left call receive ( g_buffer0 , 0 , 43 ) call receive ( phi_buffer0 , 0 , 143 ) ! right call receive ( g_buffer1 , njobs - 1 , 43 + njobs - 1 ) call receive ( phi_buffer1 , njobs - 1 , 143 + njobs - 1 ) !apply the BCs call apply_radial_boundary_conditions ( gin ) end if ! DSO - change communicator call scope ( subprocs ) temp_ind = temp_ind + 1 deallocate ( prefac ) if ( proc0 ) call time_message (. false ., time_multibox (:, 1 ), ' mb_comm' ) #endif end subroutine multibox_communicate subroutine apply_radial_boundary_conditions ( gin ) use kt_grids , only : nakx , naky , zonal_mode use kt_grids , only : periodic_variation , boundary_size use stella_layouts , only : vmu_lo use zgrid , only : nzgrid implicit none integer :: num , ix , iky , iz , it , iv , iL , iR integer :: offsetL , offsetR , pfac complex :: dzm , dzp complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( inout ) :: gin pfac = 1 if ( periodic_variation ) pfac = 2 offsetL = 0 offsetR = x_fft_size - boundary_size if ( periodic_variation ) then offsetL = - boundary_size offsetR = x_fft_size / 2 - boundary_size + 1 end if num = 1 do iv = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , vmu_lo % ntubes do iz = - vmu_lo % nzgrid , vmu_lo % nzgrid call transform_kx2x ( gin (:, :, iz , it , iv ), fft_xky ) do ix = 1 , pfac * boundary_size iL = ix + offsetL iR = ix + offsetR if ( iL <= 0 ) iL = iL + x_fft_size if ( iR <= 0 ) iR = iR + x_fft_size do iky = ikymin , naky fft_xky ( iky , iL ) = fft_xky ( iky , iL ) * ( 1 - copy_mask_left ( ix )) & + g_buffer0 ( num ) * copy_mask_left ( ix ) fft_xky ( iky , iR ) = fft_xky ( iky , iR ) * ( 1 - copy_mask_right ( ix )) & + g_buffer1 ( num ) * copy_mask_right ( ix ) num = num + 1 end do end do if ( smooth_ZFs ) then dzm = fft_xky ( 1 , boundary_size + 1 ) - fft_xky ( 1 , boundary_size ) dzp = fft_xky ( 1 , x_fft_size - boundary_size + 1 ) - fft_xky ( 1 , x_fft_size - boundary_size ) do ix = 1 , pfac * boundary_size iL = ix + offsetL iR = ix + offsetR if ( iL <= 0 ) iL = iL + x_fft_size if ( iR <= 0 ) iR = iR + x_fft_size fft_xky ( 1 , iL ) = fft_xky ( 1 , iL ) + dzm fft_xky ( 1 , iR ) = fft_xky ( 1 , iR ) - dzp end do end if if ( zonal_mode ( 1 )) fft_xky ( 1 , :) = real ( fft_xky ( 1 , :)) call transform_x2kx ( fft_xky , gin (:, :, iz , it , iv )) end do end do end do end subroutine apply_radial_boundary_conditions subroutine add_multibox_krook ( g , rhs ) use stella_time , only : code_dt use stella_layouts , only : vmu_lo use kt_grids , only : nakx , naky , periodic_variation , boundary_size use zgrid , only : nzgrid , ntubes use mp , only : job , proc0 use job_manage , only : time_message implicit none integer :: iky , ix , iL , iR , iz , it , ivmu , num , offsetL , offsetR integer :: pfac complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: rhs complex , allocatable , dimension (:, :) :: g0x , g0k if ( job /= 1 . and . . not . use_dirichlet_BC ) return if ( proc0 ) call time_message (. false ., time_multibox (:, 2 ), ' mb_krook' ) allocate ( g0k ( naky , nakx )) allocate ( g0x ( naky , x_fft_size )) if ( periodic_variation ) then offsetL = - boundary_size offsetR = x_fft_size / 2 - boundary_size + 1 else offsetL = 0 offsetR = x_fft_size - boundary_size end if pfac = 1 if ( periodic_variation ) pfac = 2 num = 1 do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid g0x = 0.0 call transform_kx2x ( g (:, :, iz , it , ivmu ), fft_xky ) do ix = 1 , pfac * boundary_size iL = ix + offsetL iR = ix + offsetR if ( iL <= 0 ) iL = iL + x_fft_size if ( iR <= 0 ) iR = iR + x_fft_size do iky = ikymin , naky g0x ( iky , iL ) = ( fft_xky ( iky , iL ) - g_buffer0 ( num )) * krook_mask_left ( ix ) g0x ( iky , iR ) = ( fft_xky ( iky , iR ) - g_buffer1 ( num )) * krook_mask_right ( ix ) num = num + 1 end do end do call transform_x2kx ( g0x , g0k ) rhs (:, :, iz , it , ivmu ) = rhs (:, :, iz , it , ivmu ) & - code_dt * nu_krook_mb * spread ( krook_fac , 2 , nakx ) * g0k end do end do end do deallocate ( g0k , g0x ) if ( proc0 ) call time_message (. false ., time_multibox (:, 2 ), ' mb_krook' ) end subroutine add_multibox_krook !! !!>DSO - The following subroutines solve for phi in the _physical_ region of space !!       It is done here because the radial grid may include an extra point subroutine init_mb_get_phi ( has_elec , adiabatic_elec , efac , efacp ) use kt_grids , only : nakx , naky , boundary_size use zgrid , only : nzgrid use physics_flags , only : radial_variation use stella_geometry , only : dl_over_b , d_dl_over_b_drho use run_parameters , only : ky_solve_radial use fields_arrays , only : phi_solve , phizf_solve , gamtot , dgamtotdr use linear_solve , only : lu_decomposition , lu_inverse implicit none logical , intent ( in ) :: has_elec , adiabatic_elec real , intent ( in ) :: efac , efacp integer :: ia , iz , iky , ikx , b_solve real :: dum complex , dimension (:, :), allocatable :: g0k , g1k , g0x , a_inv , a_fsa if (. not . radial_variation ) return !this does not depend on the timestep, so only do once if ( get_phi_initialized ) return get_phi_initialized = . true . !efac_l  = efac !efacp_l = efacp_l ia = 1 b_solve = boundary_size - phi_bound allocate ( g0k ( 1 , nakx )) allocate ( g1k ( 1 , nakx )) allocate ( g0x ( 1 , x_fft_size )) if (. not . allocated ( phi_solve )) allocate ( phi_solve ( min ( ky_solve_radial , naky ), - nzgrid : nzgrid )) do iky = 1 , min ( ky_solve_radial , naky ) do iz = - nzgrid , nzgrid if (. not . associated ( phi_solve ( iky , iz )% zloc )) & allocate ( phi_solve ( iky , iz )% zloc ( x_fft_size - 2 * b_solve , x_fft_size - 2 * b_solve )) if (. not . associated ( phi_solve ( iky , iz )% idx )) & allocate ( phi_solve ( iky , iz )% idx ( x_fft_size - 2 * b_solve )) phi_solve ( iky , iz )% zloc = 0.0 phi_solve ( iky , iz )% idx = 0 do ikx = 1 + b_solve , x_fft_size - b_solve g0x ( 1 , :) = 0.0 g0x ( 1 , ikx ) = 1.0 call transform_x2kx ( g0x , g0k ) g1k ( 1 , :) = g0k ( 1 , :) * gamtot ( iky , :, iz ) call transform_kx2x ( g1k , g0x ) !row column phi_solve ( iky , iz )% zloc (:, ikx - b_solve ) = g0x ( 1 , ( 1 + b_solve ):( x_fft_size - b_solve )) g1k ( 1 , :) = g0k ( 1 , :) * dgamtotdr ( iky , :, iz ) call transform_kx2x ( g1k , g0x ) g0x ( 1 , :) = rho_mb_clamped * g0x ( 1 , :) phi_solve ( iky , iz )% zloc (:, ikx - b_solve ) = phi_solve ( iky , iz )% zloc (:, ikx - b_solve ) & + g0x ( 1 , ( 1 + b_solve ):( x_fft_size - b_solve )) end do call lu_decomposition ( phi_solve ( iky , iz )% zloc , phi_solve ( iky , iz )% idx , dum ) !       call zgetrf(nakx,nakx,phi_solve(iky,iz)%zloc,nakx,phi_solve(iky,iz)%idx,info) end do end do if (. not . has_elec ) then if (. not . allocated ( b_mat )) allocate ( b_mat ( x_fft_size - 2 * b_solve )); b_mat = 0.0 do ikx = 1 + b_solve , x_fft_size - b_solve !row column b_mat ( ikx - b_solve ) = efac + efacp * rho_mb_clamped ( ikx ) end do end if if ( adiabatic_elec ) then allocate ( a_inv ( x_fft_size - 2 * b_solve , x_fft_size - 2 * b_solve )) allocate ( a_fsa ( x_fft_size - 2 * b_solve , x_fft_size - 2 * b_solve )); a_fsa = 0.0 if (. not . associated ( phizf_solve % zloc )) & allocate ( phizf_solve % zloc ( x_fft_size - 2 * b_solve , x_fft_size - 2 * b_solve )); phizf_solve % zloc = 0.0 if (. not . associated ( phizf_solve % idx )) allocate ( phizf_solve % idx ( x_fft_size - 2 * b_solve )); !get inverse of A do iz = - nzgrid , nzgrid call lu_inverse ( phi_solve ( 1 , iz )% zloc , phi_solve ( 1 , iz )% idx , a_inv ) !flux surface average it do ikx = 1 , x_fft_size - 2 * b_solve a_fsa (:, ikx ) = a_fsa (:, ikx ) + ( dl_over_b ( ia , iz ) + d_dl_over_b_drho ( ia , iz ) & * rho_mb_clamped (( 1 + b_solve ):( x_fft_size - b_solve ))) * a_inv (:, ikx ) end do end do ! calculate I - <A&#94;-1>B do ikx = 1 , x_fft_size - 2 * b_solve phizf_solve % zloc ( ikx , :) = - a_fsa ( ikx , :) * b_mat phizf_solve % zloc ( ikx , ikx ) = 1.0 + phizf_solve % zloc ( ikx , ikx ) end do call lu_decomposition ( phizf_solve % zloc , phizf_solve % idx , dum ) deallocate ( a_inv , a_fsa ) end if deallocate ( g0k , g1k , g0x ) end subroutine init_mb_get_phi subroutine mb_get_phi ( phi , has_elec , adiabatic_elec ) use constants , only : zi use kt_grids , only : akx , nakx , naky , zonal_mode , boundary_size use zgrid , only : nzgrid , ntubes use stella_geometry , only : dl_over_b , d_dl_over_b_drho use run_parameters , only : ky_solve_radial use fields_arrays , only : gamtot , dgamtotdr , phi_solve , phizf_solve use linear_solve , only : lu_back_substitution implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in out ) :: phi logical , intent ( in ) :: has_elec , adiabatic_elec integer :: ia , it , iz , ix , iky , ind , b_solve complex , dimension (:, :), allocatable :: g0k , g1k , g0x , g1x , g0z complex , dimension (:), allocatable :: g_fsa , pb_fsa real :: tmp ia = 1 b_solve = boundary_size - phi_bound allocate ( g0k ( 1 , nakx )) allocate ( g1k ( 1 , nakx )) allocate ( g0x ( 1 , x_fft_size )) allocate ( g1x ( 1 , x_fft_size )) if ( adiabatic_elec . and . zonal_mode ( 1 )) then allocate ( g0z ( x_fft_size , - nzgrid : nzgrid )) allocate ( g_fsa ( x_fft_size - 2 * b_solve )) allocate ( pb_fsa ( x_fft_size - 2 * b_solve )) end if do it = 1 , ntubes if ( adiabatic_elec . and . zonal_mode ( 1 )) pb_fsa = 0.0 do iz = - nzgrid , nzgrid do iky = 1 , naky if ( iky > ky_solve_radial ) then phi ( iky , :, iz , it ) = phi ( iky , :, iz , it ) / gamtot ( iky , :, iz ) else g0x = 0.0 tmp = 0 ind = boundary_size * ( iky - 1 + naky * ( iz + nzgrid + ( 2 * nzgrid + 1 ) * ( it - 1 ))) do ix = 1 , b_solve g0x ( 1 , ix ) = phi_buffer0 ( ind + ix ) g0x ( 1 , x_fft_size + 1 - ix ) = phi_buffer1 ( ind + boundary_size + 1 - ix ) end do if ( iky == 1 ) tmp = sum ( real ( g0x ( 1 , :))) call transform_x2kx ( g0x , g0k ) if ( phi_pow /= 0 ) then g0k ( 1 , :) = g0k ( 1 , :) / (( zi * akx ) ** phi_pow ) if ( iky == 1 ) g0k ( 1 , 1 ) = 0.0 end if g0x = 0.0 if (. not . has_elec . and . phi_pow /= 0 ) then g1k ( 1 , :) = g0k ( 1 , :) call transform_kx2x ( g1k , g0x ) g0x ( 1 , ( b_solve + 1 ):( x_fft_size - b_solve )) = & - g0x ( 1 , ( b_solve + 1 ):( x_fft_size - b_solve )) * b_mat if ( adiabatic_elec . and . iky == 1 ) then pb_fsa = pb_fsa + ( dl_over_b ( ia , iz ) + d_dl_over_b_drho ( ia , iz ) & * rho_mb_clamped (( 1 + b_solve ):( x_fft_size - b_solve ))) & * g0x ( 1 , ( 1 + b_solve ):( x_fft_size - b_solve )) end if end if g1k ( 1 , :) = g0k ( 1 , :) * gamtot ( iky , :, iz ) call transform_kx2x ( g1k , g1x ) g0x = g0x + g1x g1k ( 1 , :) = g0k ( 1 , :) * dgamtotdr ( iky , :, iz ) call transform_kx2x ( g1k , g1x ) g1x ( 1 , :) = rho_mb_clamped * g1x ( 1 , :) + g0x ( 1 , :) g0k ( 1 , :) = phi ( iky , :, iz , it ) call transform_kx2x ( g0k , g0x ) g0x = g0x - g1x call lu_back_substitution ( phi_solve ( iky , iz )% zloc , phi_solve ( iky , iz )% idx , & g0x ( 1 , ( b_solve + 1 ):( x_fft_size - b_solve ))) if ( iky == 1 ) then tmp = ( tmp + & sum ( real ( g0x ( 1 , ( b_solve + 1 ):( x_fft_size - b_solve ))))) & / ( 2 * b_solve ) end if if ( phi_pow /= 0 ) then do ix = 1 , b_solve g0x ( 1 , ix ) = 0.0 g0x ( 1 , x_fft_size + 1 - ix ) = 0.0 end do call transform_x2kx ( g0x , g0k ) g0k ( 1 , :) = g0k ( 1 , :) * ( zi * akx ) ** phi_pow call transform_kx2x ( g0k , g0x ) end if do ix = 1 , b_solve g0x ( 1 , ix ) = phi_buffer0 ( ind + ix ) !- tmp g0x ( 1 , x_fft_size + 1 - ix ) = phi_buffer1 ( ind + boundary_size + 1 - ix ) !- tmp end do call transform_x2kx ( g0x , g0k ) if ( phi_pow /= 0 ) then g0k ( 1 , :) = g0k ( 1 , :) / ( zi * akx ) ** phi_pow if ( iky == 1 ) g0k ( 1 , 1 ) = 0. end if phi ( iky , :, iz , it ) = g0k ( 1 , :) end if end do end do if ( ky_solve_radial == 0 . and . any ( gamtot ( 1 , 1 , :) < epsilon ( 0. ))) phi ( 1 , 1 , :, it ) = 0.0 if ( adiabatic_elec . and . zonal_mode ( 1 )) then !get A_p&#94;-1.(g - A_b.phi_b) in real space do iz = - nzgrid , nzgrid g0k ( 1 , :) = phi ( 1 , :, iz , it ) call transform_kx2x ( g0k , g0x ) g0z (:, iz ) = g0x ( 1 , :) if ( phi_pow /= 0 ) then call lu_back_substitution ( phi_solve ( 1 , iz )% zloc , phi_solve ( 1 , iz )% idx , pb_fsa ) g0z (( 1 + b_solve ):( x_fft_size - b_solve ), iz ) = & g0z (( 1 + b_solve ):( x_fft_size - b_solve ), iz ) + pb_fsa end if end do ! get <A_p&#94;-1.(g- - A_b.phi_b)>_psi g_fsa = 0.0 do iz = - nzgrid , nzgrid g_fsa = g_fsa + ( dl_over_b ( ia , iz ) + d_dl_over_b_drho ( ia , iz ) & * rho_mb_clamped (( 1 + b_solve ):( x_fft_size - b_solve ))) & * g0z (( 1 + b_solve ):( x_fft_size - b_solve ), iz ) end do call lu_back_substitution ( phizf_solve % zloc , phizf_solve % idx , g_fsa ) g1x ( 1 , ( 1 + b_solve ):( x_fft_size - b_solve )) = b_mat * g_fsa do iz = - nzgrid , nzgrid g_fsa = g1x ( 1 , ( 1 + b_solve ):( x_fft_size - b_solve )) call lu_back_substitution ( phi_solve ( 1 , iz )% zloc , phi_solve ( 1 , iz )% idx , g_fsa ) g0z (( 1 + b_solve ):( x_fft_size - b_solve ), iz ) = & g0z (( 1 + b_solve ):( x_fft_size - b_solve ), iz ) + g_fsa g0x ( 1 , :) = g0z (:, iz ) call transform_x2kx ( g0x , g0k ) phi ( 1 , :, iz , it ) = g0k ( 1 , :) end do end if end do deallocate ( g0k , g1k , g0x , g1x ) if ( allocated ( g0z )) deallocate ( g0z ) if ( allocated ( g_fsa )) deallocate ( g_fsa ) if ( allocated ( pb_fsa )) deallocate ( pb_fsa ) end subroutine mb_get_phi !!>DSO - The following subroutines are the _ analogues of the ones found in ! stella_transforms.f90. ! The ones uses here ensure that the grid spacing in real space is consistent between ! domains (since we do not keep the checkboard mode) subroutine init_mb_transforms use stella_layouts , only : init_stella_layouts use kt_grids , only : nakx , naky , naky_all implicit none if ( mb_transforms_initialized ) return mb_transforms_initialized = . true . if (. not . allocated ( fft_kxky )) allocate ( fft_kxky ( naky , nakx )) if (. not . allocated ( fft_xky )) allocate ( fft_xky ( naky , x_fft_size )) if (. not . allocated ( fft_xy )) allocate ( fft_xy ( naky_all , x_fft_size )) call init_x_fft call init_y_fft end subroutine init_mb_transforms subroutine init_x_fft use fft_work , only : init_ccfftw , FFT_BACKWARD , FFT_FORWARD implicit none if (. not . allocated ( fft_x_k )) allocate ( fft_x_k ( x_fft_size )) if (. not . allocated ( fft_x_x )) allocate ( fft_x_x ( x_fft_size )) call init_ccfftw ( xf_fft , FFT_BACKWARD , x_fft_size , fft_x_k , fft_x_x ) call init_ccfftw ( xb_fft , FFT_FORWARD , x_fft_size , fft_x_x , fft_x_k ) end subroutine init_x_fft subroutine init_y_fft use kt_grids , only : naky , naky_all use fft_work , only : init_crfftw , init_rcfftw , FFT_BACKWARD , FFT_FORWARD implicit none if (. not . allocated ( fft_y_k )) allocate ( fft_y_k ( naky )) if (. not . allocated ( fft_y_y )) allocate ( fft_y_y ( naky_all )) call init_crfftw ( yf_fft , FFT_BACKWARD , naky_all , fft_y_k , fft_y_y ) call init_rcfftw ( yb_fft , FFT_FORWARD , naky_all , fft_y_y , fft_y_k ) end subroutine init_y_fft ! !> transform routines start here ! subroutine transform_kx2x ( gkx , gx ) use kt_grids , only : ikx_max implicit none complex , dimension (:, :), intent ( in ) :: gkx complex , dimension (:, :), intent ( out ) :: gx integer :: iy do iy = 1 , size ( gkx , 1 ) fft_x_k = 0. fft_x_k (: ikx_max ) = gkx ( iy , : ikx_max ) fft_x_k (( x_fft_size - ikx_max + 2 ):) = gkx ( iy , ikx_max + 1 :) call dfftw_execute_dft ( xf_fft % plan , fft_x_k , fft_x_x ) gx ( iy , :) = fft_x_x * xf_fft % scale end do end subroutine transform_kx2x subroutine transform_x2kx ( gx , gkx ) use kt_grids , only : ikx_max implicit none complex , dimension (:, :), intent ( in ) :: gx complex , dimension (:, :), intent ( out ) :: gkx integer :: iy do iy = 1 , size ( gx , 1 ) fft_x_x = gx ( iy , :) call dfftw_execute_dft ( xb_fft % plan , fft_x_x , fft_x_k ) gkx ( iy , : ikx_max ) = fft_x_k (: ikx_max ) * xb_fft % scale gkx ( iy , ikx_max + 1 :) = fft_x_k (( x_fft_size - ikx_max + 2 ):) * xb_fft % scale end do end subroutine transform_x2kx subroutine transform_ky2y ( gky , gy ) implicit none complex , dimension (:, :), intent ( in ) :: gky real , dimension (:, :), intent ( out ) :: gy integer :: ikx do ikx = 1 , size ( gky , 2 ) fft_y_k = gky (:, ikx ) call dfftw_execute_dft_c2r ( yf_fft % plan , fft_y_k , fft_y_y ) gy (:, ikx ) = fft_y_y * yf_fft % scale end do end subroutine transform_ky2y !   subroutine transform_y2ky (gy, gky) ! !    implicit none ! !    real, dimension (:,:), intent (in out) :: gy !    complex, dimension (:,:), intent (out) :: gky ! !    integer :: ikx ! !    do ikx = 1, size(gy,2) !       fft_y_k = gy(:,ikx) !       call dfftw_execute_dft_r2c(yb_fft%plan, fft_y_y, fft_y_k) !       gky(:,ikx) = fft_y_y*yb_fft%scale !    end do ! !  end subroutine transform_y2ky subroutine finish_mb_transforms implicit none call dfftw_destroy_plan ( yf_fft % plan ) call dfftw_destroy_plan ( yb_fft % plan ) call dfftw_destroy_plan ( xf_fft % plan ) call dfftw_destroy_plan ( xb_fft % plan ) if ( allocated ( fft_y_k )) deallocate ( fft_y_k ) if ( allocated ( fft_y_y )) deallocate ( fft_y_y ) if ( allocated ( fft_x_k )) deallocate ( fft_x_k ) if ( allocated ( fft_x_x )) deallocate ( fft_x_x ) if ( allocated ( fft_xky )) deallocate ( fft_xky ) if ( allocated ( fft_xy )) deallocate ( fft_xy ) mb_transforms_initialized = . false . end subroutine finish_mb_transforms end module multibox","tags":"","loc":"sourcefile/multibox.fpp.html"},{"title":"dist_fn_arrays.f90 â€“ stella","text":"Contents Modules dist_fn_arrays Source Code dist_fn_arrays.f90 Source Code !> A container for the arrays that are used to store the distribution function among other things. !!  These need to be accessible at a lower dependency level than the dist_fn module itself. !! These arrays are allocated in the function dist_fn::allocate_arrays. module dist_fn_arrays public :: gnew , gold , g_symm public :: g0 , g1 , g2 , g3 public :: g_krook , g_proj public :: gvmu public :: kperp2 , dkperp2dr public :: wstar , wstarp public :: wdriftx_g , wdrifty_g public :: wdriftx_phi , wdrifty_phi public :: wdriftpx_g , wdriftpy_g public :: wdriftpx_phi , wdriftpy_phi ! dist fn complex , dimension (:, :, :, :, :), allocatable :: gnew , gold ! (naky, nakx, -nzgrid:nzgrid, ntubes, -vmu-layout-) complex , dimension (:, :, :, :, :), target , allocatable :: g_symm ! (naky, nakx, -nzgrid:nzgrid, ntubes, -vmu-layout-) complex , dimension (:, :, :, :, :), allocatable :: g0 , g1 , g2 , g3 ! (naky, nakx, -nzgrid:nzgrid, ntubes, -vmu-layout-) ! needed to implement time-delayed source when using Krook operator complex , dimension (:, :, :, :), allocatable :: g_krook ! (nakx, -nzgrid:nzgrid, ntubes, -vmu-layout-) ! needed to implement time-delayed source when using projection method complex , dimension (:, :, :, :), allocatable :: g_proj ! (nakx, -nzgrid:nzgrid, ntubes, -vmu-layout-) complex , dimension (:, :, :), allocatable :: gvmu ! (nvpa, nmu, -kxkyz-layout-) real , dimension (:, :, :), allocatable :: wstar , wstarp ! (nalpha, -nzgrid:nzgrid, -vmu-layout-) real , dimension (:, :, :), allocatable :: wdriftx_g , wdrifty_g real , dimension (:, :, :), allocatable :: wdriftx_phi , wdrifty_phi real , dimension (:, :, :), allocatable :: wdriftpx_g , wdriftpy_g real , dimension (:, :, :), allocatable :: wdriftpx_phi , wdriftpy_phi ! (nalpha, -nzgrid:nzgrid, -vmu-layout-) !> dkperp2dr will contain the radial variation of kperp2 real , dimension (:, :, :, :), allocatable :: kperp2 , dkperp2dr ! (naky, nakx, nalpha, -nzgrid:nzgrid) ! note: dkperp2dr is divided by kperp2 end module dist_fn_arrays","tags":"","loc":"sourcefile/dist_fn_arrays.f90.html"},{"title":"parallel_streaming.f90 â€“ stella","text":"Contents Modules parallel_streaming Source Code parallel_streaming.f90 Source Code module parallel_streaming implicit none public :: init_parallel_streaming , finish_parallel_streaming public :: advance_parallel_streaming_explicit public :: advance_parallel_streaming_implicit public :: add_parallel_streaming_radial_variation public :: stream_tridiagonal_solve public :: parallel_streaming_initialized public :: stream , stream_c , stream_sign public :: time_parallel_streaming public :: stream_rad_var1 public :: stream_rad_var2 private interface center_zed module procedure center_zed_segment_real module procedure center_zed_extended end interface logical :: parallel_streaming_initialized = . false . integer , dimension (:), allocatable :: stream_sign real , dimension (:, :, :, :), allocatable :: stream real , dimension (:, :, :), allocatable :: stream_c real , dimension (:, :, :), allocatable :: stream_rad_var1 real , dimension (:, :, :), allocatable :: stream_rad_var2 real , dimension (:, :), allocatable :: stream_tri_a1 , stream_tri_a2 real , dimension (:, :), allocatable :: stream_tri_b1 , stream_tri_b2 real , dimension (:, :), allocatable :: stream_tri_c1 , stream_tri_c2 real , dimension (:, :), allocatable :: gradpar_c real , dimension ( 2 ) :: time_parallel_streaming contains subroutine init_parallel_streaming use finite_differences , only : fd3pt use stella_time , only : code_dt use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx , imu_idx , is_idx use species , only : spec , nspec , pfac use vpamu_grids , only : nvpa , nvpa use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use vpamu_grids , only : vperp2 , vpa , mu use kt_grids , only : nalpha use zgrid , only : nzgrid , nztot use stella_geometry , only : gradpar , dgradpardrho , dBdrho , gfac , b_dot_grad_z use run_parameters , only : stream_implicit , driftkinetic_implicit use physics_flags , only : include_parallel_streaming , radial_variation implicit none integer :: iv , imu , is , ivmu integer :: ia , iz real , dimension (:), allocatable :: energy if ( parallel_streaming_initialized ) return parallel_streaming_initialized = . true . if (. not . allocated ( stream )) allocate ( stream ( nalpha , - nzgrid : nzgrid , nvpa , nspec )); stream = 0. if (. not . allocated ( stream_sign )) allocate ( stream_sign ( nvpa )); stream_sign = 0 ! sign of stream corresponds to appearing on RHS of GK equation ! i.e., this is the factor multiplying dg/dz on RHS of equation if ( include_parallel_streaming ) then do iv = 1 , nvpa do iz = - nzgrid , nzgrid do ia = 1 , nalpha stream ( ia , iz , iv , :) = - code_dt * b_dot_grad_z ( ia , iz ) * vpa ( iv ) * spec % stm_psi0 end do end do end do else stream = 0.0 end if if ( radial_variation ) then allocate ( energy ( - nzgrid : nzgrid )) if (. not . allocated ( stream_rad_var1 )) then allocate ( stream_rad_var1 ( - nzgrid : nzgrid , nvpa , nspec )) end if if (. not . allocated ( stream_rad_var2 )) then allocate ( stream_rad_var2 ( nalpha , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) stream_rad_var2 = 0.0 end if ia = 1 stream_rad_var1 = - code_dt * spread ( spread ( spec % stm_psi0 , 1 , nztot ), 2 , nvpa ) & * gfac * spread ( spread ( vpa , 1 , nztot ) * spread ( dgradpardrho , 2 , nvpa ), 3 , nspec ) do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) iv = iv_idx ( vmu_lo , ivmu ) energy = ( vpa ( iv ) ** 2 + vperp2 ( ia , :, imu )) * ( spec ( is )% temp_psi0 / spec ( is )% temp ) stream_rad_var2 ( ia , :, ivmu ) = & + code_dt * spec ( is )% stm_psi0 * vpa ( iv ) * gradpar & * spec ( is )% zt * maxwell_vpa ( iv , is ) * maxwell_mu ( ia , :, imu , is ) * maxwell_fac ( is ) & * ( pfac * ( spec ( is )% fprim + spec ( is )% tprim * ( energy - 2.5 )) & + gfac * 2 * mu ( imu ) * dBdrho ) end do deallocate ( energy ) end if !> stream_sign set to +/- 1 depending on the sign of the parallel streaming term. !> NB: stream_sign = -1 corresponds to positive advection velocity !> only need to consider ia=1, iz=0 and is=1 because alpha, z and species dependences !> do not lead to change in sign of the streaming pre-factor do iv = 1 , nvpa stream_sign ( iv ) = int ( sign ( 1.0 , stream ( 1 , 0 , iv , 1 ))) end do if ( stream_implicit . or . driftkinetic_implicit ) then call init_invert_stream_operator if (. not . allocated ( stream_c )) allocate ( stream_c ( - nzgrid : nzgrid , nvpa , nspec )) stream_c = stream ( 1 , :, :, :) do is = 1 , nspec do iv = 1 , nvpa call center_zed ( iv , stream_c (:, iv , is )) end do end do if (. not . allocated ( gradpar_c )) allocate ( gradpar_c ( - nzgrid : nzgrid , - 1 : 1 )) gradpar_c = spread ( gradpar , 2 , 3 ) !> get gradpar centred in zed for negative vpa (affects upwinding) call center_zed ( 1 , gradpar_c (:, - stream_sign ( 1 ))) !> get gradpar centred in zed for positive vpa (affects upwinding) call center_zed ( nvpa , gradpar_c (:, - stream_sign ( nvpa ))) stream = spread ( stream_c , 1 , nalpha ) end if end subroutine init_parallel_streaming subroutine init_invert_stream_operator use zgrid , only : delzed use extended_zgrid , only : iz_low , iz_up use extended_zgrid , only : nsegments use run_parameters , only : zed_upwind , time_upwind implicit none integer :: nz , nseg_max nz = maxval ( iz_up - iz_low ) nseg_max = maxval ( nsegments ) if (. not . allocated ( stream_tri_a1 )) then allocate ( stream_tri_a1 ( nz * nseg_max + 1 , - 1 : 1 )); stream_tri_a1 = 0. allocate ( stream_tri_a2 ( nz * nseg_max + 1 , - 1 : 1 )); stream_tri_a2 = 0. allocate ( stream_tri_b1 ( nz * nseg_max + 1 , - 1 : 1 )); stream_tri_b1 = 1. allocate ( stream_tri_b2 ( nz * nseg_max + 1 , - 1 : 1 )); stream_tri_b2 = 0. allocate ( stream_tri_c1 ( nz * nseg_max + 1 , - 1 : 1 )); stream_tri_c1 = 0. allocate ( stream_tri_c2 ( nz * nseg_max + 1 , - 1 : 1 )); stream_tri_c2 = 0. end if ! corresponds to sign of stream term positive on RHS of equation ! i.e., negative parallel advection speed ! NB: assumes equal spacing in zed stream_tri_b1 (:, 1 ) = 0.5 * ( 1.0 + zed_upwind ) stream_tri_b2 (:, 1 ) = - 1.0 / delzed ( 0 ) stream_tri_c1 (: nz * nseg_max , 1 ) = 0.5 * ( 1.0 - zed_upwind ) stream_tri_c2 (: nz * nseg_max , 1 ) = 1.0 / delzed ( 0 ) ! corresponds to sign of stream term negative on RHS of equation ! NB: assumes equal spacing in zed stream_tri_b1 (:, - 1 ) = 0.5 * ( 1.0 + zed_upwind ) stream_tri_b2 (:, - 1 ) = 1.0 / delzed ( 0 ) stream_tri_a1 ( 2 :, - 1 ) = 0.5 * ( 1.0 - zed_upwind ) stream_tri_a2 ( 2 :, - 1 ) = - 1.0 / delzed ( 0 ) stream_tri_a2 = 0.5 * ( 1.0 + time_upwind ) * stream_tri_a2 stream_tri_b2 = 0.5 * ( 1.0 + time_upwind ) * stream_tri_b2 stream_tri_c2 = 0.5 * ( 1.0 + time_upwind ) * stream_tri_c2 end subroutine init_invert_stream_operator subroutine advance_parallel_streaming_explicit ( g , phi , gout ) use mp , only : proc0 use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx , imu_idx , is_idx use job_manage , only : time_message use stella_transforms , only : transform_ky2y use zgrid , only : nzgrid , ntubes use kt_grids , only : naky , naky_all , nakx , ikx_max , ny use kt_grids , only : swap_kxky use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use species , only : spec use physics_flags , only : full_flux_surface use gyro_averages , only : gyro_average use run_parameters , only : driftkinetic_implicit implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: phi complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: gout integer :: ivmu , iv , imu , is , ia , iz , it complex , dimension (:, :, :, :), allocatable :: g0 , dgphi_dz complex , dimension (:, :, :, :), allocatable :: g0y , g1y complex , dimension (:, :), allocatable :: g0_swap !> if flux tube simulation parallel streaming stays in ky,kx,z space with ky,kx,z local !> if full flux surface (flux annulus), will need to calculate in y space !> start the timer for the parallel streaming part of the time advance if ( proc0 ) call time_message (. false ., time_parallel_streaming , ' Stream advance' ) !> allocate arrays needed for intermmediate calculations allocate ( g0 ( naky , nakx , - nzgrid : nzgrid , ntubes )) allocate ( dgphi_dz ( naky , nakx , - nzgrid : nzgrid , ntubes )) !> if simulating a full flux surface, will also need version of the above arrays !> that is Fourier transformed to y-space if ( full_flux_surface ) then allocate ( g0_swap ( naky_all , ikx_max )) allocate ( g0y ( ny , ikx_max , - nzgrid : nzgrid , ntubes )) allocate ( g1y ( ny , ikx_max , - nzgrid : nzgrid , ntubes )) end if do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc !> get (iv,imu,is) indices corresponding to ivmu super-index iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) !> obtain <phi> (or <phi>-phi if driftkinetic_implicit=T) call gyro_average ( phi , ivmu , g0 (:, :, :, :)) if ( driftkinetic_implicit ) g0 (:, :, :, :) = g0 (:, :, :, :) - phi !> get d<phi>/dz, with z the parallel coordinate and store in dgphi_dz !> note that this should be a centered difference to avoid numerical !> unpleasantness to do with inexact cancellations in later velocity integration !> see appendix of the stella JCP 2019 for details call get_dgdz_centered ( g0 , ivmu , dgphi_dz ) !> if driftkinetic_implicit=T, then only want to treat vpar . grad (<phi>-phi)*F0 term explicitly; !> in this case, zero out dg/dz term (or d(g/F)/dz for full-flux-surface) if ( driftkinetic_implicit ) then g0 = 0. else !> compute dg/dz in k-space and store in g0 call get_dgdz ( g (:, :, :, :, ivmu ), ivmu , g0 ) !> if simulating a full flux surface, need to obtain the contribution from parallel streaming !> in y-space, so FFT d(g/F)/dz from ky to y if ( full_flux_surface ) then do it = 1 , ntubes do iz = - nzgrid , nzgrid call swap_kxky ( g0 (:, :, iz , it ), g0_swap ) call transform_ky2y ( g0_swap , g0y (:, :, iz , it )) end do end do end if ! ! if simulating a full flux surface, must calculate F * d/dz (g/F) rather than dg/dz ! ! since F=F(y) in this case, avoid multiple Fourier transforms by applying chain rule ! ! to z derivative: F * d/dz (g/F) = dg/dz - g * d ln F / dz = dg/dz + g * mu/T * dB/dz ! if (full_flux_surface) then !    ! transform g and dg/dz from ky to y space and store in g0y and g1y, respectively !    g1y = g(:,:,:,:,ivmu) !    do it = 1, ntubes !       do iz = -nzgrid, nzgrid !          call transform_ky2y (g1y(:,:,iz,it), g0y(:,:,iz,it)) !          ! no longer need g1y so re-use as FFT of dg/dz (g0) !          call transform_ky2y (g0(:,:,iz,it), g1y(:,:,iz,it)) !       end do !    end do !    ! overwrite g0y with dg/dz + g * mu/T * dB/dz !    g0y = g1y + 2.0*mu(imu)*spread(spread(dBdzed,2,nakx),4,ntubes) * g0y !    ! g1y no longer needed so can over-write with d<phi>/dz below ! end if end if if ( full_flux_surface ) then !> transform d<phi>/dz (fully explicit) or d(<phi>-phi)/dz (if driftkinetic_implicit) !> from kalpha (ky) to alpha (y) space and store in g1y do it = 1 , ntubes do iz = - nzgrid , nzgrid call swap_kxky ( dgphi_dz (:, :, iz , it ), g0_swap ) call transform_ky2y ( g0_swap , g1y (:, :, iz , it )) end do end do !> over-write g0y with d/dz (g/F) + Ze/T * d<phi>/dz (or <phi>-phi for driftkinetic_implicit). g0y (:, :, :, :) = g0y (:, :, :, :) + g1y (:, :, :, :) * spec ( is )% zt ! ! over-write g0y with F * d/dz (g/F) + ZeF/T * d<phi>/dz (or <phi>-phi for driftkinetic_implicit). ! g0y(:,:,:,:) = g0y(:,:,:,:) + g1y(:,:,:,:)*spec(is)%zt*maxwell_fac(is) & !      * maxwell_vpa(iv,is)*spread(spread(maxwell_mu(:,:,imu,is),2,nakx),4,ntubes)*maxwell_fac(is) !> multiply d(g/F)/dz and d<phi>/dz terms with vpa*(b . grad z) and add to source (RHS of GK equation) call add_stream_term_ffs ( g0y , ivmu , gout (:, :, :, :, ivmu )) else ia = 1 g0 (:, :, :, :) = g0 (:, :, :, :) + dgphi_dz (:, :, :, :) * spec ( is )% zt * maxwell_fac ( is ) & * maxwell_vpa ( iv , is ) * spread ( spread ( spread ( maxwell_mu ( ia , :, imu , is ), 1 , naky ), 2 , nakx ), 4 , ntubes ) ! multiply dg/dz with vpa*(b . grad z) and add to source (RHS of GK equation) call add_stream_term ( g0 , ivmu , gout (:, :, :, :, ivmu )) end if end do !> deallocate intermediate arrays used in this subroutine deallocate ( g0 , dgphi_dz ) if ( full_flux_surface ) deallocate ( g0y , g1y , g0_swap ) !> finish timing the subroutine if ( proc0 ) call time_message (. false ., time_parallel_streaming , ' Stream advance' ) end subroutine advance_parallel_streaming_explicit subroutine add_parallel_streaming_radial_variation ( g , gout , rhs ) use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx , imu_idx , is_idx use job_manage , only : time_message use zgrid , only : nzgrid , ntubes use kt_grids , only : naky , nakx use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use species , only : spec use gyro_averages , only : gyro_average , gyro_average_j1 use fields_arrays , only : phi , phi_corr_QN , phi_corr_GA implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: gout !the next input/output is for quasineutrality and gyroaveraging corrections !that go directly in the RHS (since they don't require further FFTs) complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: rhs integer :: ivmu , iv , imu , is , it , ia , iz complex , dimension (:, :, :, :), allocatable :: g0 , g1 , g2 , g3 complex , dimension (:, :), allocatable :: g0k allocate ( g0 ( naky , nakx , - nzgrid : nzgrid , ntubes )) allocate ( g1 ( naky , nakx , - nzgrid : nzgrid , ntubes )) allocate ( g2 ( naky , nakx , - nzgrid : nzgrid , ntubes )) allocate ( g3 ( naky , nakx , - nzgrid : nzgrid , ntubes )) allocate ( g0k ( naky , nakx )); g0k = 0 ! parallel streaming stays in ky,kx,z space with ky,kx,z local ia = 1 do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc ! obtain <phi> ! get d<phi>/dz, with z the parallel coordinate and store in g1 call gyro_average ( phi , ivmu , g0 ) call get_dgdz_centered ( g0 , ivmu , g1 ) ! get variation in gyroaveraging and store in g2 call get_dgdz_centered ( phi_corr_GA (:, :, :, :, ivmu ), ivmu , g2 ) ! get variation in quasineutrality and store in g3 call gyro_average ( phi_corr_QN , ivmu , g0 ) call get_dgdz_centered ( g0 , ivmu , g3 ) call get_dgdz ( g (:, :, :, :, ivmu ), ivmu , g0 ) iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) do it = 1 , ntubes do iz = - nzgrid , nzgrid !!#1 - variation in gradpar g0k = g0 (:, :, iz , it ) & + g1 (:, :, iz , it ) * spec ( is )% zt * maxwell_vpa ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) * maxwell_fac ( is ) g0k = g0k * stream_rad_var1 ( iz , iv , is ) !!#2 - variation in F_s/T_s g0k = g0k + g1 (:, :, iz , it ) * stream_rad_var2 ( ia , iz , ivmu ) gout (:, :, iz , it , ivmu ) = gout (:, :, iz , it , ivmu ) + g0k !!#3 - variation in the gyroaveraging and quasineutrality of phi !!     These variations already have the linear part calculated, so !!     ad it into the rhs directly g0k = spec ( is )% zt * stream ( 1 , iz , iv , is ) * maxwell_vpa ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) * maxwell_fac ( is ) & * ( g2 (:, :, iz , it ) + g3 (:, :, iz , it )) rhs (:, :, iz , it , ivmu ) = rhs (:, :, iz , it , ivmu ) + g0k end do end do end do deallocate ( g0 , g1 , g2 , g3 , g0k ) end subroutine add_parallel_streaming_radial_variation subroutine get_dgdz ( g , ivmu , dgdz ) use finite_differences , only : third_order_upwind_zed use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx use zgrid , only : nzgrid , delzed , ntubes use extended_zgrid , only : neigen , nsegments use extended_zgrid , only : iz_low , iz_up use extended_zgrid , only : ikxmod use extended_zgrid , only : fill_zed_ghost_zones use extended_zgrid , only : periodic use kt_grids , only : naky implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( out ) :: dgdz integer , intent ( in ) :: ivmu integer :: iseg , ie , it , iky , iv complex , dimension ( 2 ) :: gleft , gright ! FLAG -- assuming delta zed is equally spaced below! iv = iv_idx ( vmu_lo , ivmu ) do iky = 1 , naky do it = 1 , ntubes do ie = 1 , neigen ( iky ) do iseg = 1 , nsegments ( ie , iky ) ! first fill in ghost zones at boundaries in g(z) call fill_zed_ghost_zones ( it , iseg , ie , iky , g (:, :, :, :), gleft , gright ) ! now get dg/dz call third_order_upwind_zed ( iz_low ( iseg ), iseg , nsegments ( ie , iky ), & g ( iky , ikxmod ( iseg , ie , iky ), iz_low ( iseg ): iz_up ( iseg ), it ), & delzed ( 0 ), stream_sign ( iv ), gleft , gright , periodic ( iky ), & dgdz ( iky , ikxmod ( iseg , ie , iky ), iz_low ( iseg ): iz_up ( iseg ), it )) end do end do end do end do end subroutine get_dgdz subroutine get_dgdz_centered ( g , ivmu , dgdz ) use finite_differences , only : second_order_centered_zed use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx use zgrid , only : nzgrid , delzed , ntubes use extended_zgrid , only : neigen , nsegments use extended_zgrid , only : iz_low , iz_up use extended_zgrid , only : ikxmod use extended_zgrid , only : fill_zed_ghost_zones use extended_zgrid , only : periodic use kt_grids , only : naky implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( out ) :: dgdz integer , intent ( in ) :: ivmu integer :: iseg , ie , iky , iv , it complex , dimension ( 2 ) :: gleft , gright ! FLAG -- assuming delta zed is equally spaced below! iv = iv_idx ( vmu_lo , ivmu ) do iky = 1 , naky do it = 1 , ntubes do ie = 1 , neigen ( iky ) do iseg = 1 , nsegments ( ie , iky ) ! first fill in ghost zones at boundaries in g(z) call fill_zed_ghost_zones ( it , iseg , ie , iky , g (:, :, :, :), gleft , gright ) ! now get dg/dz call second_order_centered_zed ( iz_low ( iseg ), iseg , nsegments ( ie , iky ), & g ( iky , ikxmod ( iseg , ie , iky ), iz_low ( iseg ): iz_up ( iseg ), it ), & delzed ( 0 ), stream_sign ( iv ), gleft , gright , periodic ( iky ), & dgdz ( iky , ikxmod ( iseg , ie , iky ), iz_low ( iseg ): iz_up ( iseg ), it )) end do end do end do end do end subroutine get_dgdz_centered ! subroutine get_dgdz_variable (g, ivmu, dgdz) !    use finite_differences, only: fd_variable_upwinding_zed !    use stella_layouts, only: vmu_lo !    use stella_layouts, only: iv_idx !    use zgrid, only: nzgrid, delzed, ntubes !    use extended_zgrid, only: neigen, nsegments !    use extended_zgrid, only: iz_low, iz_up !    use extended_zgrid, only: ikxmod !    use extended_zgrid, only: fill_zed_ghost_zones !    use extended_zgrid, only: periodic !    use run_parameters, only: zed_upwind !    use kt_grids, only: naky !    implicit none !    complex, dimension (:,:,-nzgrid:,:), intent (in) :: g !    complex, dimension (:,:,-nzgrid:,:), intent (out) :: dgdz !    integer, intent (in) :: ivmu !    integer :: iseg, ie, iky, iv, it !    complex, dimension (2) :: gleft, gright !    ! FLAG -- assuming delta zed is equally spaced below! !     iv = iv_idx(vmu_lo,ivmu) !     do iky = 1, naky !       do it = 1, ntubes !         do ie = 1, neigen(iky) !           do iseg = 1, nsegments(ie,iky) !              ! first fill in ghost zones at boundaries in g(z) !              call fill_zed_ghost_zones (it, iseg, ie, iky, g(:,:,:,:), gleft, gright) ! now get dg/dz !              call fd_variable_upwinding_zed (iz_low(iseg), iseg, nsegments(ie,iky), & !                   g(iky,ikxmod(iseg,ie,iky),iz_low(iseg):iz_up(iseg),it), & !                   delzed(0), stream_sign(iv), zed_upwind,gleft, gright, periodic(iky), & !                   dgdz(iky,ikxmod(iseg,ie,iky),iz_low(iseg):iz_up(iseg),it)) !           end do !         end do !       enddo !     end do ! end subroutine get_dgdz_variable subroutine add_stream_term ( g , ivmu , src ) use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx , is_idx use zgrid , only : nzgrid implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( in out ) :: src integer , intent ( in ) :: ivmu integer :: iz , iv , is iv = iv_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) do iz = - nzgrid , nzgrid src (:, :, iz , :) = src (:, :, iz , :) + stream ( 1 , iz , iv , is ) * g (:, :, iz , :) end do end subroutine add_stream_term subroutine add_stream_term_ffs ( g , ivmu , src ) use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx , is_idx use zgrid , only : nzgrid use kt_grids , only : ny implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( in out ) :: src integer , intent ( in ) :: ivmu integer :: iz , iy , iv , is iv = iv_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) do iz = - nzgrid , nzgrid do iy = 1 , ny src ( iy , :, iz , :) = src ( iy , :, iz , :) + stream ( iy , iz , iv , is ) * g ( iy , :, iz , :) end do end do end subroutine add_stream_term_ffs subroutine advance_parallel_streaming_implicit ( g , phi , apar ) use mp , only : proc0 use job_manage , only : time_message use stella_layouts , only : vmu_lo , iv_idx use zgrid , only : nzgrid , ntubes use kt_grids , only : naky , nakx use dist_fn_arrays , only : g1 use run_parameters , only : stream_matrix_inversion use fields , only : advance_fields , fields_updated implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( in out ) :: phi , apar integer :: ivmu , iv complex , dimension (:, :, :, :), allocatable :: phi1 if ( proc0 ) call time_message (. false ., time_parallel_streaming , ' Stream advance' ) allocate ( phi1 ( naky , nakx , - nzgrid : nzgrid , ntubes )) ! save the incoming g and phi, as they will be needed later g1 = g phi1 = phi do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) ! obtain RHS of inhomogeneous GK eqn; ! i.e., (1+(1+alph)/2*dt*vpa*gradpar*d/dz)g_{inh}&#94;{n+1} ! = (1-(1-alph)/2*dt*vpa*gradpar*d/dz)g&#94;{n} ! + (1-alph)/2*dt*Ze*dlnF0/dE*exp(-vpa&#94;2)*vpa*b.gradz*d<phi&#94;{n}>/dz call get_gke_rhs ( ivmu , g1 (:, :, :, :, ivmu ), phi1 , phi , g (:, :, :, :, ivmu ), eqn = 'inhomogeneous' ) if ( stream_matrix_inversion ) then ! solve (I + (1+alph)/2*dt*vpa . grad)g_{inh}&#94;{n+1} = RHS ! g = RHS is input and overwritten by g = g_{inh}&#94;{n+1} call invert_parstream ( ivmu , g (:, :, :, :, ivmu )) else call sweep_g_zed ( ivmu , g (:, :, :, :, ivmu )) end if end do fields_updated = . false . ! we now have g_{inh}&#94;{n+1} ! calculate associated fields (phi_{inh}&#94;{n+1}) call advance_fields ( g , phi , apar , dist = 'gbar' ) ! solve response_matrix*phi&#94;{n+1} = phi_{inh}&#94;{n+1} ! phi = phi_{inh}&#94;{n+1} is input and overwritten by phi = phi&#94;{n+1} call invert_parstream_response ( phi ) do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) ! now have phi&#94;{n+1} for non-negative kx ! obtain RHS of GK eqn; ! i.e., (1+(1+alph)/2*dt*vpa*gradpar*d/dz)g&#94;{n+1} ! = (1-(1-alph)/2*dt*vpa*gradpar*d/dz)g&#94;{n} ! + dt*Ze*dlnF0/dE*exp(-vpa&#94;2)*vpa*b.gradz*d/dz((1+alph)/2*<phi&#94;{n+1}>+(1-alph)/2*<phi&#94;{n}>) call get_gke_rhs ( ivmu , g1 (:, :, :, :, ivmu ), phi1 , phi , g (:, :, :, :, ivmu ), eqn = 'full' ) if ( stream_matrix_inversion ) then ! solve (1+(1+alph)/2*dt*vpa*gradpar*d/dz)g&#94;{n+1} = RHS ! g = RHS is input and overwritten by g = g&#94;{n+1} call invert_parstream ( ivmu , g (:, :, :, :, ivmu )) else call sweep_g_zed ( ivmu , g (:, :, :, :, ivmu )) end if end do deallocate ( phi1 ) if ( proc0 ) call time_message (. false ., time_parallel_streaming , ' Stream advance' ) end subroutine advance_parallel_streaming_implicit subroutine get_gke_rhs ( ivmu , gold , phiold , phi , g , eqn ) use stella_time , only : code_dt use zgrid , only : nzgrid , ntubes use species , only : spec use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx , imu_idx , is_idx use kt_grids , only : naky , nakx use gyro_averages , only : gyro_average use vpamu_grids , only : vpa , mu use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use stella_geometry , only : dbdzed use neoclassical_terms , only : include_neoclassical_terms use neoclassical_terms , only : dfneo_dvpa use run_parameters , only : time_upwind use run_parameters , only : driftkinetic_implicit use run_parameters , only : maxwellian_inside_zed_derivative implicit none integer , intent ( in ) :: ivmu complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: gold complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: phiold , phi complex , dimension (:, :, - nzgrid :, :), intent ( in out ) :: g character ( * ), intent ( in ) :: eqn integer :: iv , imu , is , iz , ia real :: tupwnd1 , tupwnd2 , fac real , dimension (:), allocatable :: vpadf0dE_fac real , dimension (:), allocatable :: gp complex , dimension (:, :, :, :), allocatable :: dgdz , dphidz complex , dimension (:, :, :, :), allocatable :: field allocate ( vpadf0dE_fac ( - nzgrid : nzgrid )) allocate ( gp ( - nzgrid : nzgrid )) allocate ( dgdz ( naky , nakx , - nzgrid : nzgrid , ntubes )) allocate ( dphidz ( naky , nakx , - nzgrid : nzgrid , ntubes )) ia = 1 tupwnd1 = 0.5 * ( 1.0 - time_upwind ) if ( eqn == 'full' ) then tupwnd2 = 0.5 * ( 1.0 + time_upwind ) else tupwnd2 = 0.0 end if ! now have phi&#94;{n+1} for non-negative kx ! obtain RHS of GK eqn; ! i.e., (1+(1+alph)/2*dt*vpa*gradpar*d/dz)g&#94;{n+1} ! = (1-(1-alph)/2*dt*vpa*gradpar*d/dz)g&#94;{n} ! + dt*Ze*dlnF0/dE*exp(-vpa&#94;2)*vpa*b.gradz*d/dz((1+alph)/2*<phi&#94;{n+1}>+(1-alph)/2*<phi&#94;{n}> iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) ! obtain dg&#94;{n}/dz and store in dgdz ! NB: could eliminate this calculation at the expense of memory ! as this was calculated previously call get_dzed ( iv , gold , dgdz ) allocate ( field ( naky , nakx , - nzgrid : nzgrid , ntubes )) ! get <phi> = (1+alph)/2*<phi&#94;{n+1}> + (1-alph)/2*<phi&#94;{n}> field = tupwnd1 * phiold + tupwnd2 * phi ! set g to be phi or <phi> depending on whether parallel streaming is ! implicit or only implicit in the kperp = 0 (drift kinetic) piece if ( driftkinetic_implicit ) then g = field else call gyro_average ( field , ivmu , g ) end if deallocate ( field ) if ( maxwellian_inside_zed_derivative ) then ! obtain d(exp(-mu*B/T)*<phi>)/dz and store in dphidz g = g * spread ( spread ( spread ( maxwell_mu ( ia , :, imu , is ) * maxwell_fac ( is ), 1 , naky ), 2 , nakx ), 4 , ntubes ) call get_dzed ( iv , g , dphidz ) ! get <phi>*exp(-mu*B/T)*dB/dz at cell centres g = g * spread ( spread ( spread ( dbdzed ( ia , :), 1 , naky ), 2 , nakx ), 4 , ntubes ) call center_zed ( iv , g ) ! construct d(<phi>*exp(-mu*B/T))/dz + 2*mu*<phi>*exp(-mu*B/T)*dB/dz ! = d<phi>/dz * exp(-mu*B/T) dphidz = dphidz + 2.0 * mu ( imu ) * g else ! obtain d<phi>/dz and store in dphidz call get_dzed ( iv , g , dphidz ) ! center Maxwellian factor in mu ! and store in dummy variable gp gp = maxwell_mu ( ia , :, imu , is ) * maxwell_fac ( is ) call center_zed ( iv , gp ) ! multiply by Maxwellian factor dphidz = dphidz * spread ( spread ( spread ( gp , 1 , naky ), 2 , nakx ), 4 , ntubes ) end if ! NB: could do this once at beginning of simulation to speed things up ! this is vpa*Z/T*exp(-vpa&#94;2) vpadf0dE_fac = vpa ( iv ) * spec ( is )% zt * maxwell_vpa ( iv , is ) ! if including neoclassical correction to equilibrium distribution function ! then must also account for -vpa*dF_neo/dvpa*Z/T ! CHECK TO ENSURE THAT DFNEO_DVPA EXCLUDES EXP(-MU*B/T) FACTOR !! if ( include_neoclassical_terms ) then do iz = - nzgrid , nzgrid vpadf0dE_fac ( iz ) = vpadf0dE_fac ( iz ) - 0.5 * dfneo_dvpa ( 1 , iz , ivmu ) * spec ( is )% zt end do call center_zed ( iv , vpadf0dE_fac ) end if g = gold call center_zed ( iv , g ) if ( stream_sign ( iv ) > 0 ) then gp = gradpar_c (:, - 1 ) else gp = gradpar_c (:, 1 ) end if ! construct RHS of GK eqn fac = code_dt * spec ( is )% stm_psi0 do iz = - nzgrid , nzgrid g (:, :, iz , :) = g (:, :, iz , :) - fac * gp ( iz ) & * ( tupwnd1 * vpa ( iv ) * dgdz (:, :, iz , :) + vpadf0dE_fac ( iz ) * dphidz (:, :, iz , :)) end do deallocate ( vpadf0dE_fac , gp ) deallocate ( dgdz , dphidz ) end subroutine get_gke_rhs ! solve (I + (1+alph)/2*dt*vpa . grad)g&#94;{n+1} = RHS ! g = RHS is input and overwritten by g = g&#94;{n+1} subroutine invert_parstream ( ivmu , g ) use zgrid , only : nzgrid , ntubes use extended_zgrid , only : neigen use extended_zgrid , only : nsegments use extended_zgrid , only : nzed_segment use extended_zgrid , only : map_to_extended_zgrid use extended_zgrid , only : map_from_extended_zgrid use extended_zgrid , only : periodic use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx , is_idx use kt_grids , only : naky implicit none integer , intent ( in ) :: ivmu complex , dimension (:, :, - nzgrid :, :), intent ( in out ) :: g integer :: iv , is integer :: iky , ie , it integer :: ulim , sgn complex , dimension (:), allocatable :: gext iv = iv_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) sgn = stream_sign ( iv ) do iky = 1 , naky if ( periodic ( iky )) then call sweep_zed_zonal ( iv , is , sgn , g ( iky , :, :, :)) else do it = 1 , ntubes do ie = 1 , neigen ( iky ) allocate ( gext ( nsegments ( ie , iky ) * nzed_segment + 1 )) ! get g on extended domain in zed call map_to_extended_zgrid ( it , ie , iky , g ( iky , :, :, :), gext , ulim ) ! solve (I + (1+alph)/2*dt*vpa . grad)g_{inh}&#94;{n+1} = RHS call stream_tridiagonal_solve ( iky , ie , iv , is , gext (: ulim )) ! extract g from extended domain in zed call map_from_extended_zgrid ( it , ie , iky , gext , g ( iky , :, :, :)) deallocate ( gext ) end do end do end if end do end subroutine invert_parstream subroutine stream_tridiagonal_solve ( iky , ie , iv , is , g ) use finite_differences , only : tridag use extended_zgrid , only : iz_low , iz_up use extended_zgrid , only : nsegments use extended_zgrid , only : nzed_segment implicit none integer , intent ( in ) :: iky , ie , iv , is complex , dimension (:), intent ( in out ) :: g integer :: iseg , llim , ulim , n integer :: nz , nseg_max , sgn , n_ext integer :: ia real , dimension (:), allocatable :: a , b , c ia = 1 ! avoid double-counting at boundaries between 2pi segments nz = nzed_segment nseg_max = nsegments ( ie , iky ) sgn = stream_sign ( iv ) n_ext = nseg_max * nz + 1 allocate ( a ( n_ext )) allocate ( b ( n_ext )) allocate ( c ( n_ext )) iseg = 1 llim = 1 ; ulim = nz + 1 a ( llim : ulim ) = stream_tri_a1 ( llim : ulim , sgn ) & - stream ( ia , iz_low ( iseg ): iz_up ( iseg ), iv , is ) * stream_tri_a2 ( llim : ulim , sgn ) b ( llim : ulim ) = stream_tri_b1 ( llim : ulim , sgn ) & - stream ( ia , iz_low ( iseg ): iz_up ( iseg ), iv , is ) * stream_tri_b2 ( llim : ulim , sgn ) c ( llim : ulim ) = stream_tri_c1 ( llim : ulim , sgn ) & - stream ( ia , iz_low ( iseg ): iz_up ( iseg ), iv , is ) * stream_tri_c2 ( llim : ulim , sgn ) if ( nsegments ( ie , iky ) > 1 ) then do iseg = 2 , nsegments ( ie , iky ) llim = ulim + 1 ulim = llim + nz - 1 a ( llim : ulim ) = stream_tri_a1 ( llim : ulim , sgn ) & - stream ( ia , iz_low ( iseg ) + 1 : iz_up ( iseg ), iv , is ) * stream_tri_a2 ( llim : ulim , sgn ) b ( llim : ulim ) = stream_tri_b1 ( llim : ulim , sgn ) & - stream ( ia , iz_low ( iseg ) + 1 : iz_up ( iseg ), iv , is ) * stream_tri_b2 ( llim : ulim , sgn ) c ( llim : ulim ) = stream_tri_c1 ( llim : ulim , sgn ) & - stream ( ia , iz_low ( iseg ) + 1 : iz_up ( iseg ), iv , is ) * stream_tri_c2 ( llim : ulim , sgn ) end do end if n = size ( stream_tri_a1 , 1 ) a ( ulim ) = stream_tri_a1 ( n , sgn ) - stream ( ia , iz_up ( nsegments ( ie , iky )), iv , is ) * stream_tri_a2 ( n , sgn ) b ( ulim ) = stream_tri_b1 ( n , sgn ) - stream ( ia , iz_up ( nsegments ( ie , iky )), iv , is ) * stream_tri_b2 ( n , sgn ) c ( ulim ) = 0. ! this line should not be necessary, as c(ulim) should not be accessed by tridag call tridag ( 1 , a (: ulim ), b (: ulim ), c (: ulim ), g ) deallocate ( a , b , c ) end subroutine stream_tridiagonal_solve ! g= RHS of gke is input ! g = g&#94;{n+1} is output subroutine sweep_g_zed ( ivmu , g ) use zgrid , only : nzgrid , delzed , ntubes use extended_zgrid , only : neigen , nsegments , nzed_segment use extended_zgrid , only : map_to_extended_zgrid use extended_zgrid , only : map_from_extended_zgrid use extended_zgrid , only : periodic use kt_grids , only : naky use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx , is_idx use run_parameters , only : zed_upwind , time_upwind implicit none integer , intent ( in ) :: ivmu complex , dimension (:, :, - nzgrid :, :), intent ( in out ) :: g integer :: iv , is integer :: iky , ie , it integer :: ulim , sgn integer :: iz , izext , iz1 , iz2 real :: fac1 , fac2 complex , dimension (:), allocatable :: gext iv = iv_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) sgn = stream_sign ( iv ) ! will sweep to right (positive vpa) or left (negative vpa) ! and solve for g on the extended z-grid do iky = 1 , naky if ( periodic ( iky )) then call sweep_zed_zonal ( iv , is , sgn , g ( iky , :, :, :)) else do it = 1 , ntubes do ie = 1 , neigen ( iky ) allocate ( gext ( nsegments ( ie , iky ) * nzed_segment + 1 )) ! get g on extended domain in zed call map_to_extended_zgrid ( it , ie , iky , g ( iky , :, :, :), gext , ulim ) if ( sgn < 0 ) then iz1 = 1 ; iz2 = ulim else iz1 = ulim ; iz2 = 1 end if izext = iz1 ; iz = sgn * nzgrid fac1 = 1.0 + zed_upwind + sgn * ( 1.0 + time_upwind ) * stream_c ( iz , iv , is ) / delzed ( 0 ) gext ( izext ) = gext ( izext ) * 2.0 / fac1 do izext = iz1 - sgn , iz2 , - sgn if ( iz == - sgn * nzgrid ) then iz = sgn * nzgrid - sgn else iz = iz - sgn end if fac1 = 1.0 + zed_upwind + sgn * ( 1.0 + time_upwind ) * stream_c ( iz , iv , is ) / delzed ( 0 ) fac2 = 1.0 - zed_upwind - sgn * ( 1.0 + time_upwind ) * stream_c ( iz , iv , is ) / delzed ( 0 ) gext ( izext ) = ( - gext ( izext + sgn ) * fac2 + 2.0 * gext ( izext )) / fac1 end do ! extract g from extended domain in zed call map_from_extended_zgrid ( it , ie , iky , gext , g ( iky , :, :, :)) deallocate ( gext ) end do end do end if end do end subroutine sweep_g_zed subroutine sweep_zed_zonal ( iv , is , sgn , g ) use zgrid , only : nzgrid , delzed , nztot , ntubes use kt_grids , only : nakx use run_parameters , only : zed_upwind , time_upwind implicit none integer , intent ( in ) :: iv , is , sgn complex , dimension (:, - nzgrid :, :), intent ( in out ) :: g integer :: iz , iz1 , iz2 real :: fac1 , fac2 complex , dimension (:), allocatable :: gcf complex , dimension (:, :, :), allocatable :: gpi allocate ( gpi ( nakx , - nzgrid : nzgrid , ntubes )) allocate ( gcf ( - nzgrid : nzgrid )) ! ky=0 is 2pi periodic (no extended zgrid) ! decompose into complementary function + particular integral ! zero BC for particular integral ! unit BC for complementary function (no source) if ( sgn < 0 ) then iz1 = - nzgrid ; iz2 = nzgrid else iz1 = nzgrid ; iz2 = - nzgrid end if gpi (:, iz1 , :) = 0. ; gcf ( iz1 ) = 1. do iz = iz1 - sgn , iz2 , - sgn fac1 = 1.0 + zed_upwind + sgn * ( 1.0 + time_upwind ) * stream_c ( iz , iv , is ) / delzed ( 0 ) fac2 = 1.0 - zed_upwind - sgn * ( 1.0 + time_upwind ) * stream_c ( iz , iv , is ) / delzed ( 0 ) gpi (:, iz , :) = ( - gpi (:, iz + sgn , :) * fac2 + 2.0 * g (:, iz , :)) / fac1 gcf ( iz ) = - gcf ( iz + sgn ) * fac2 / fac1 end do ! g = g_PI + (g_PI(pi)/(1-g_CF(pi))) * g_CF g = gpi + ( spread ( gpi (:, iz2 , :), 2 , nztot ) / ( 1. - gcf ( iz2 ))) * spread ( spread ( gcf , 1 , nakx ), 3 , ntubes ) deallocate ( gpi , gcf ) end subroutine sweep_zed_zonal subroutine invert_parstream_response ( phi ) use linear_solve , only : lu_back_substitution use zgrid , only : nzgrid , ntubes use extended_zgrid , only : neigen use extended_zgrid , only : nsegments use extended_zgrid , only : nzed_segment use extended_zgrid , only : map_to_extended_zgrid use extended_zgrid , only : map_from_extended_zgrid use extended_zgrid , only : ikxmod use extended_zgrid , only : periodic use kt_grids , only : naky use fields_arrays , only : response_matrix implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in out ) :: phi integer :: iky , ie , it , ulim integer :: ikx complex , dimension (:), allocatable :: gext ! need to put the fields into extended zed grid do iky = 1 , naky ! avoid double counting of periodic endpoints for zonal (and any other periodic) modes if ( periodic ( iky )) then do it = 1 , ntubes do ie = 1 , neigen ( iky ) ikx = ikxmod ( 1 , ie , iky ) call lu_back_substitution ( response_matrix ( iky )% eigen ( ie )% zloc , & response_matrix ( iky )% eigen ( ie )% idx , phi ( iky , ikx , : nzgrid - 1 , it )) phi ( iky , ikx , nzgrid , it ) = phi ( iky , ikx , - nzgrid , it ) end do end do else do it = 1 , ntubes do ie = 1 , neigen ( iky ) ! solve response_matrix*phi&#94;{n+1} = phi_{inh}&#94;{n+1} allocate ( gext ( nsegments ( ie , iky ) * nzed_segment + 1 )) call map_to_extended_zgrid ( it , ie , iky , phi ( iky , :, :, :), gext , ulim ) call lu_back_substitution ( response_matrix ( iky )% eigen ( ie )% zloc , & response_matrix ( iky )% eigen ( ie )% idx , gext ) call map_from_extended_zgrid ( it , ie , iky , gext , phi ( iky , :, :, :)) deallocate ( gext ) end do end do end if end do end subroutine invert_parstream_response subroutine get_dzed ( iv , g , dgdz ) use finite_differences , only : fd_cell_centres_zed use kt_grids , only : naky use zgrid , only : nzgrid , delzed , ntubes use extended_zgrid , only : neigen , nsegments use extended_zgrid , only : iz_low , iz_up use extended_zgrid , only : ikxmod use extended_zgrid , only : fill_zed_ghost_zones implicit none integer , intent ( in ) :: iv complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( out ) :: dgdz integer :: iky , ie , iseg , it complex , dimension ( 2 ) :: gleft , gright do it = 1 , ntubes do iky = 1 , naky do ie = 1 , neigen ( iky ) do iseg = 1 , nsegments ( ie , iky ) ! first fill in ghost zones at boundaries in g(z) call fill_zed_ghost_zones ( it , iseg , ie , iky , g , gleft , gright ) ! get finite difference approximation for dg/dz at cell centres ! iv > nvgrid corresponds to positive vpa, iv <= nvgrid to negative vpa call fd_cell_centres_zed ( iz_low ( iseg ), & g ( iky , ikxmod ( iseg , ie , iky ), iz_low ( iseg ): iz_up ( iseg ), it ), & delzed ( 0 ), stream_sign ( iv ), gleft ( 2 ), gright ( 1 ), & dgdz ( iky , ikxmod ( iseg , ie , iky ), iz_low ( iseg ): iz_up ( iseg ), it )) end do end do end do end do end subroutine get_dzed subroutine center_zed_extended ( iv , g ) use finite_differences , only : cell_centres_zed use kt_grids , only : naky , nakx use zgrid , only : nzgrid , ntubes use extended_zgrid , only : neigen , nsegments use extended_zgrid , only : iz_low , iz_up use extended_zgrid , only : ikxmod use extended_zgrid , only : fill_zed_ghost_zones use run_parameters , only : zed_upwind implicit none integer , intent ( in ) :: iv complex , dimension (:, :, - nzgrid :, :), intent ( in out ) :: g integer :: iky , ie , iseg , it complex , dimension ( 2 ) :: gleft , gright complex , dimension (:, :, :), allocatable :: gc allocate ( gc ( nakx , - nzgrid : nzgrid , ntubes )) do iky = 1 , naky do it = 1 , ntubes do ie = 1 , neigen ( iky ) do iseg = 1 , nsegments ( ie , iky ) ! first fill in ghost zones at boundaries in g(z) call fill_zed_ghost_zones ( it , iseg , ie , iky , g , gleft , gright ) ! get cell centres values call cell_centres_zed ( iz_low ( iseg ), & g ( iky , ikxmod ( iseg , ie , iky ), iz_low ( iseg ): iz_up ( iseg ), it ), & zed_upwind , stream_sign ( iv ), gleft ( 2 ), gright ( 1 ), & gc ( ikxmod ( iseg , ie , iky ), iz_low ( iseg ): iz_up ( iseg ), it )) end do end do end do g ( iky , :, :, :) = gc end do deallocate ( gc ) end subroutine center_zed_extended subroutine center_zed_segment_real ( iv , g ) use zgrid , only : nzgrid use run_parameters , only : zed_upwind integer , intent ( in ) :: iv real , dimension ( - nzgrid :), intent ( in out ) :: g if ( stream_sign ( iv ) > 0 ) then g (: nzgrid - 1 ) = 0.5 * (( 1. + zed_upwind ) * g (: nzgrid - 1 ) + ( 1. - zed_upwind ) * g ( - nzgrid + 1 :)) g ( nzgrid ) = g ( - nzgrid ) else g ( - nzgrid + 1 :) = 0.5 * (( 1. - zed_upwind ) * g (: nzgrid - 1 ) + ( 1. + zed_upwind ) * g ( - nzgrid + 1 :)) g ( - nzgrid ) = g ( nzgrid ) end if end subroutine center_zed_segment_real subroutine finish_parallel_streaming use run_parameters , only : stream_implicit , driftkinetic_implicit implicit none if ( allocated ( stream )) deallocate ( stream ) if ( allocated ( stream_c )) deallocate ( stream_c ) if ( allocated ( stream_sign )) deallocate ( stream_sign ) if ( allocated ( gradpar_c )) deallocate ( gradpar_c ) if ( allocated ( stream_rad_var1 )) deallocate ( stream_rad_var1 ) if ( allocated ( stream_rad_var2 )) deallocate ( stream_rad_var2 ) if ( stream_implicit . or . driftkinetic_implicit ) call finish_invert_stream_operator parallel_streaming_initialized = . false . end subroutine finish_parallel_streaming subroutine finish_invert_stream_operator implicit none if ( allocated ( stream_tri_a1 )) then deallocate ( stream_tri_a1 ) deallocate ( stream_tri_a2 ) deallocate ( stream_tri_b1 ) deallocate ( stream_tri_b2 ) deallocate ( stream_tri_c1 ) deallocate ( stream_tri_c2 ) end if end subroutine finish_invert_stream_operator end module parallel_streaming","tags":"","loc":"sourcefile/parallel_streaming.f90.html"},{"title":"stella_time.f90 â€“ stella","text":"Contents Modules stella_time Source Code stella_time.f90 Source Code module stella_time implicit none private real :: code_dt real :: cfl_dt = - 1. real :: code_dt_min , code_dt_max ! added May 18, 2009 to take care of problems ! in exb_shear calculation after change in time step size real :: code_dt_old = 0. real :: code_time = 0. public :: code_dt , update_time , code_dt_old public :: code_time public :: save_dt_min , save_dt , save_dt_cfl , write_dt public :: init_tstart , init_delt public :: cfl_dt public :: code_dt_min , code_dt_max contains subroutine init_tstart ( tstart ) real , intent ( in ) :: tstart code_time = tstart end subroutine init_tstart subroutine init_delt ( delt ) real , intent ( in ) :: delt code_dt = delt ! do not allow code_dt to increase beyond input value code_dt_max = code_dt end subroutine init_delt subroutine update_time ! MAB+CMR, 21/5/09: set code_dt_old to code_dt BEFORE any changes in timestep code_dt_old = code_dt code_time = code_time + code_dt end subroutine update_time subroutine save_dt_cfl ( delt_cfl ) real , intent ( in ) :: delt_cfl cfl_dt = delt_cfl end subroutine save_dt_cfl subroutine save_dt_min ( dt_min ) real , intent ( in ) :: dt_min code_dt_min = dt_min end subroutine save_dt_min subroutine save_dt ( delt ) real , intent ( in ) :: delt code_dt = delt end subroutine save_dt subroutine write_dt if ( cfl_dt > 0. . and . cfl_dt < 1.e7 ) & write ( * , * ) 'TIME STEP:' write ( * , '(A12, ES10.2E2)' ) \"   cfl_dt:\" // repeat ( ' ' , 50 ), cfl_dt write ( * , '(A12, ES10.2E2)' ) \"   code_dt:\" // repeat ( ' ' , 50 ), code_dt end subroutine write_dt end module stella_time","tags":"","loc":"sourcefile/stella_time.f90.html"},{"title":"vpamu_grids.f90 â€“ stella","text":"Contents Modules vpamu_grids Source Code vpamu_grids.f90 Source Code module vpamu_grids implicit none public :: init_vpamu_grids , finish_vpamu_grids public :: read_vpamu_grids_parameters public :: calculate_velocity_integrals public :: integrate_vmu , integrate_species public :: integrate_species_ffs , integrate_vmu_ffs public :: integrate_mu public :: vpa , nvgrid , nvpa public :: wgts_vpa , dvpa public :: mu , nmu , wgts_mu , wgts_mu_bare , dmu public :: dmu_ghost , dmu_cell , mu_cell public :: maxwell_vpa , maxwell_mu , ztmax public :: maxwell_fac public :: int_unit , int_vpa2 , int_vperp2 , int_vfrth public :: vperp2 public :: equally_spaced_mu_grid public :: set_vpa_weights logical :: vpamu_initialized = . false . integer :: nvgrid , nvpa integer :: nmu real :: vpa_max , vperp_max ! arrays that are filled in vpamu_grids real , dimension (:), allocatable :: vpa , wgts_vpa , wgts_vpa_default , wgts_mu_bare real , dimension (:), allocatable :: mu , maxwell_fac real , dimension (:, :), allocatable :: maxwell_vpa real , dimension (:, :, :), allocatable :: int_unit , int_vpa2 , int_vperp2 , int_vfrth real , dimension (:, :, :), allocatable :: wgts_mu real , dimension (:, :, :, :), allocatable :: maxwell_mu real , dimension (:, :), allocatable :: ztmax real :: dvpa real , dimension (:), allocatable :: dmu real , dimension (:), allocatable :: dmu_ghost , dmu_cell , mu_cell complex , dimension (:), allocatable :: rbuffer logical :: equally_spaced_mu_grid , conservative_wgts_vpa ! vpa-mu related arrays that are declared here ! but allocated and filled elsewhere because they depend on z, etc. real , dimension (:, :, :), allocatable :: vperp2 interface integrate_species !     module procedure integrate_species_vmu module procedure integrate_species_vmu_single module procedure integrate_species_vmu_single_real module procedure integrate_species_vmu_block_complex module procedure integrate_species_vmu_block_real !     module procedure integrate_species_local_complex !     module procedure integrate_species_local_real end interface interface integrate_vmu module procedure integrate_vmu_local_real module procedure integrate_vmu_local_complex module procedure integrate_vmu_vmulo_complex module procedure integrate_vmu_vmulo_ivmu_only_real end interface interface integrate_mu module procedure integrate_mu_local module procedure integrate_mu_nonlocal end interface contains subroutine read_vpamu_grids_parameters use file_utils , only : input_unit_exist use mp , only : proc0 , broadcast implicit none namelist / vpamu_grids_parameters / nvgrid , nmu , vpa_max , vperp_max , & equally_spaced_mu_grid , conservative_wgts_vpa integer :: in_file logical :: exist if ( proc0 ) then nvgrid = 24 vpa_max = 3.0 nmu = 12 vperp_max = 3.0 equally_spaced_mu_grid = . false . conservative_wgts_vpa = . false . in_file = input_unit_exist ( \"vpamu_grids_parameters\" , exist ) if ( exist ) read ( unit = in_file , nml = vpamu_grids_parameters ) end if call broadcast ( nvgrid ) call broadcast ( vpa_max ) call broadcast ( nmu ) call broadcast ( vperp_max ) call broadcast ( equally_spaced_mu_grid ) call broadcast ( conservative_wgts_vpa ) nvpa = 2 * nvgrid end subroutine read_vpamu_grids_parameters subroutine init_vpamu_grids use species , only : spec , nspec implicit none if ( vpamu_initialized ) return vpamu_initialized = . true . !> set up the vpa grid points and integration weights call init_vpa_grid !> set up the mu grid points and integration weights call init_mu_grid if (. not . allocated ( maxwell_fac )) then allocate ( maxwell_fac ( nspec )); maxwell_fac = 1.0 end if !> maxwell_fac = 1 unless radially global maxwell_fac = spec % dens / spec % dens_psi0 * ( spec % temp_psi0 / spec % temp ) ** 1.5 end subroutine init_vpamu_grids subroutine init_vpa_grid use mp , only : mp_abort use constants , only : pi use species , only : spec , nspec implicit none integer :: iv , idx , iseg , nvpa_seg real :: del if (. not . allocated ( vpa )) then !> vpa is the parallel velocity at grid points allocate ( vpa ( nvpa )); vpa = 0.0 !> wgts_vpa are the integration weights assigned !> to the parallel velocity grid points allocate ( wgts_vpa ( nvpa )); wgts_vpa = 0.0 allocate ( wgts_vpa_default ( nvpa )); wgts_vpa_default = 0.0 !> this is the Maxwellian in vpa allocate ( maxwell_vpa ( nvpa , nspec )); maxwell_vpa = 0.0 allocate ( ztmax ( nvpa , nspec )); ztmax = 0.0 end if !> parallel velocity grid goes from -vpa_max to vpa_max, !> with no point at vpa = 0; !> the lack of a point at vpa=0 avoids treating !> the vpa=z=0 phase space location, which !> is isolated from all other phase space points !> in the absence of collisions !> equal grid spacing in vpa dvpa = 2. * vpa_max / ( nvpa - 1 ) !> obtain vpa grid for vpa > 0 do iv = nvgrid + 1 , nvpa vpa ( iv ) = real ( iv - nvgrid - 0.5 ) * dvpa end do !> fill in vpa grid for vpa < 0 vpa (: nvgrid ) = - vpa ( nvpa : nvgrid + 1 : - 1 ) !> maxwell_vpa is the equilibrium Maxwellian in vpa maxwell_vpa = exp ( - spread ( vpa * vpa , 2 , nspec ) * spread ( spec % temp_psi0 / spec % temp , 1 , nvpa )) !> ztmax is the Maxwellian in vpa, multipliedd by charge number over normalized temperature ztmax = spread ( spec % zt , 1 , nvpa ) * maxwell_vpa !> get integration weights corresponding to vpa grid points !> for now use Simpson's rule; !> i.e. subdivide grid into 3-point segments, with each segment spanning vpa_low to vpa_up !> then the contribution of each segment to the integral is !> (vpa_up - vpa_low) * (f1 + 4*f2 + f3) / 6 !> inner boundary points are used in two segments, so they get double the weight if ( nvpa < 6 ) & call mp_abort ( 'stella does not currently support nvgrid < 3.  aborting.' ) !> use simpson 3/8 rule at lower boundary and composite Simpson elsewhere del = 0.375 * dvpa wgts_vpa ( 1 ) = del wgts_vpa ( 2 : 3 ) = 3. * del wgts_vpa ( 4 ) = del !> composite simpson nvpa_seg = ( nvpa - 4 ) / 2 del = dvpa / 3. do iseg = 1 , nvpa_seg idx = 2 * ( iseg - 1 ) + 4 wgts_vpa ( idx ) = wgts_vpa ( idx ) + del wgts_vpa ( idx + 1 ) = wgts_vpa ( idx + 1 ) + 4. * del wgts_vpa ( idx + 2 ) = wgts_vpa ( idx + 2 ) + del end do !> for the sake of symmetry, do the same thing with 3/8 rule at upper boundary !> and composite elsewhere. del = 0.375 * dvpa wgts_vpa ( nvpa - 3 ) = wgts_vpa ( nvpa - 3 ) + del wgts_vpa ( nvpa - 2 : nvpa - 1 ) = wgts_vpa ( nvpa - 2 : nvpa - 1 ) + 3. * del wgts_vpa ( nvpa ) = wgts_vpa ( nvpa ) + del nvpa_seg = ( nvpa - 4 ) / 2 del = dvpa / 3. do iseg = 1 , nvpa_seg idx = 2 * ( iseg - 1 ) + 1 wgts_vpa ( idx ) = wgts_vpa ( idx ) + del wgts_vpa ( idx + 1 ) = wgts_vpa ( idx + 1 ) + 4. * del wgts_vpa ( idx + 2 ) = wgts_vpa ( idx + 2 ) + del end do !> divide by 2 to account for double-counting wgts_vpa = 0.5 * wgts_vpa / sqrt ( pi ) wgts_vpa_default = wgts_vpa end subroutine init_vpa_grid subroutine set_vpa_weights ( conservative ) use constants , only : pi implicit none logical , intent ( in ) :: conservative if ( conservative ) then wgts_vpa = dvpa / sqrt ( pi ) else if ( conservative_wgts_vpa ) then ! AVB: added option for density conserving form of collision operator wgts_vpa = dvpa / sqrt ( pi ) else if ((. not . conservative_wgts_vpa ) . and . (. not . conservative )) then wgts_vpa = wgts_vpa_default end if end subroutine set_vpa_weights subroutine integrate_mu_local ( iz , g , total ) use species , only : nspec implicit none integer , intent ( in ) :: iz real , dimension (:, :), intent ( in ) :: g real , dimension (:), intent ( out ) :: total integer :: is , imu , ia total = 0. ia = 1 do is = 1 , nspec ! sum over mu do imu = 1 , nmu total ( is ) = total ( is ) + wgts_mu ( ia , iz , imu ) * g ( imu , is ) end do end do end subroutine integrate_mu_local subroutine integrate_mu_nonlocal ( iz , g , total ) use mp , only : nproc , sum_reduce use stella_layouts , only : vmu_lo use stella_layouts , only : is_idx , imu_idx , iv_idx implicit none integer , intent ( in ) :: iz real , dimension ( vmu_lo % llim_proc :), intent ( in ) :: g real , dimension (:, :), intent ( out ) :: total integer :: is , imu , iv , ivmu , ia total = 0. ia = 1 do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) iv = iv_idx ( vmu_lo , ivmu ) total ( iv , is ) = total ( iv , is ) + wgts_mu ( ia , iz , imu ) * g ( ivmu ) end do if ( nproc > 1 ) call sum_reduce ( total , 0 ) end subroutine integrate_mu_nonlocal subroutine integrate_vmu_local_real ( g , iz , total ) implicit none real , dimension (:, :), intent ( in ) :: g integer , intent ( in ) :: iz real , intent ( out ) :: total integer :: iv , imu , ia total = 0. ia = 1 do imu = 1 , nmu do iv = 1 , nvpa total = total + wgts_mu ( ia , iz , imu ) * wgts_vpa ( iv ) * g ( iv , imu ) end do end do end subroutine integrate_vmu_local_real subroutine integrate_vmu_local_complex ( g , iz , total ) implicit none complex , dimension (:, :), intent ( in ) :: g integer , intent ( in ) :: iz complex , intent ( out ) :: total integer :: iv , imu , ia total = 0. ia = 1 do imu = 1 , nmu do iv = 1 , nvpa total = total + wgts_mu ( ia , iz , imu ) * wgts_vpa ( iv ) * g ( iv , imu ) end do end do end subroutine integrate_vmu_local_complex ! integrave over v-space in vmu_lo subroutine integrate_vmu_vmulo_complex ( g , weights , total ) use mp , only : sum_allreduce use stella_layouts , only : vmu_lo , iv_idx , imu_idx , is_idx use zgrid , only : nzgrid implicit none integer :: ivmu , iv , iz , is , imu , ia complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g real , dimension (:), intent ( in ) :: weights complex , dimension (:, :, - nzgrid :, :, :), intent ( out ) :: total total = 0. ia = 1 do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) do iz = - nzgrid , nzgrid total (:, :, iz , :, is ) = total (:, :, iz , :, is ) + & wgts_mu ( ia , iz , imu ) * wgts_vpa ( iv ) * g (:, :, iz , :, ivmu ) * weights ( is ) end do end do call sum_allreduce ( total ) end subroutine integrate_vmu_vmulo_complex ! integrave over v-space in vmu_lo subroutine integrate_vmu_vmulo_ivmu_only_real ( g , ia , iz , total ) use mp , only : sum_allreduce use stella_layouts , only : vmu_lo , iv_idx , imu_idx , is_idx implicit none integer :: ivmu , iv , is , imu real , dimension ( vmu_lo % llim_proc :), intent ( in ) :: g integer , intent ( in ) :: ia , iz real , dimension (:), intent ( out ) :: total total = 0. do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) total ( is ) = total ( is ) + & wgts_mu ( ia , iz , imu ) * wgts_vpa ( iv ) * g ( ivmu ) end do call sum_allreduce ( total ) end subroutine integrate_vmu_vmulo_ivmu_only_real !   subroutine integrate_species_local_real (g, weights, iz, total) !     use species, only: nspec !     use stella_geometry, only: bmag !     implicit none !     real, dimension (:,:,:), intent (in) :: g !     real, dimension (:), intent (in) :: weights !     integer, intent (in) :: iz !     real, intent (out) :: total !     integer :: iv, imu, is !     total = 0. !     do is = 1, nspec !        do imu = 1, nmu !           do iv = 1, nvpa !              total = total + wgts_mu(imu)*wgts_vpa(iv)*bmag(1,iz)*g(iv,imu,is)*weights(is) !           end do !        end do !     end do !   end subroutine integrate_species_local_real !   subroutine integrate_species_local_complex (g, weights, iz, total) !     use species, only: nspec !     use stella_geometry, only: bmag !     implicit none !     complex, dimension (:,:,:), intent (in) :: g !     real, dimension (:), intent (in) :: weights !     integer, intent (in) :: iz !     complex, intent (out) :: total !     integer :: iv, imu, is !     total = 0. !     do is = 1, nspec !        do imu = 1, nmu !           do iv = 1, nvpa !              total = total + wgts_mu(imu)*wgts_vpa(iv)*bmag(1,iz)*g(iv,imu,is)*weights(is) !           end do !        end do !     end do !   end subroutine integrate_species_local_complex !   ! integrave over v-space and sum over species !   subroutine integrate_species_vmu (g, weights, total) !     use mp, only: sum_allreduce !     use stella_layouts, only: vmu_lo, iv_idx, imu_idx, is_idx !     use zgrid, only: nzgrid !     use stella_geometry, only: bmag !     implicit none !     integer :: ivmu, iv, iz, is, imu !     complex, dimension (:,:,-nzgrid:,vmu_lo%llim_proc:), intent (in) :: g !     real, dimension (:), intent (in) :: weights !     complex, dimension (:,:,-nzgrid:), intent (out) :: total !     total = 0. !     do ivmu = vmu_lo%llim_proc, vmu_lo%ulim_proc !        iv = iv_idx(vmu_lo,ivmu) !        imu = imu_idx(vmu_lo,ivmu) !        is = is_idx(vmu_lo,ivmu) !        do iz = -nzgrid, nzgrid !           total(:,:,iz) = total(:,:,iz) + & !                wgts_mu(imu)*wgts_vpa(iv)*bmag(1,iz)*g(:,:,iz,ivmu)*weights(is) !        end do !     end do !     call sum_allreduce (total) !   end subroutine integrate_species_vmu ! integrave over v-space and sum over species for given (ky,kx,z) point subroutine integrate_species_vmu_single ( g , iz , weights , total , ia_in , reduce_in ) use mp , only : sum_allreduce use stella_layouts , only : vmu_lo , iv_idx , imu_idx , is_idx implicit none integer :: ivmu , iv , is , imu , ia logical :: reduce complex , dimension ( vmu_lo % llim_proc :), intent ( in ) :: g integer , intent ( in ) :: iz real , dimension (:), intent ( in ) :: weights complex , intent ( out ) :: total integer , intent ( in ), optional :: ia_in logical , intent ( in ), optional :: reduce_in total = 0. if ( present ( ia_in )) then ia = ia_in else ia = 1 end if if ( present ( reduce_in )) then reduce = reduce_in else reduce = . true . end if do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) total = total + & wgts_mu ( ia , iz , imu ) * wgts_vpa ( iv ) * g ( ivmu ) * weights ( is ) end do if ( reduce ) call sum_allreduce ( total ) end subroutine integrate_species_vmu_single ! integrave over v-space and sum over species for given (ky,kx,z) point subroutine integrate_species_vmu_single_real ( g , iz , weights , total , ia_in , reduce_in ) use mp , only : sum_allreduce use stella_layouts , only : vmu_lo , iv_idx , imu_idx , is_idx implicit none integer :: ivmu , iv , is , imu , ia logical :: reduce real , dimension ( vmu_lo % llim_proc :), intent ( in ) :: g integer , intent ( in ) :: iz real , dimension (:), intent ( in ) :: weights real , intent ( out ) :: total integer , intent ( in ), optional :: ia_in logical , intent ( in ), optional :: reduce_in total = 0. if ( present ( ia_in )) then ia = ia_in else ia = 1 end if if ( present ( reduce_in )) then reduce = reduce_in else reduce = . true . end if do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) total = total + & wgts_mu ( ia , iz , imu ) * wgts_vpa ( iv ) * g ( ivmu ) * weights ( is ) end do if ( reduce ) call sum_allreduce ( total ) end subroutine integrate_species_vmu_single_real subroutine integrate_species_vmu_block_complex ( g , iz , weights , pout , ia_in , reduce_in ) use mp , only : sum_allreduce use stella_layouts , only : vmu_lo , iv_idx , imu_idx , is_idx implicit none integer :: ivmu , iv , is , imu , ia logical :: reduce complex , dimension (:, :, vmu_lo % llim_proc :), intent ( in ) :: g integer , intent ( in ) :: iz integer , intent ( in ), optional :: ia_in logical , intent ( in ), optional :: reduce_in real , dimension (:), intent ( in ) :: weights complex , dimension (:, :), intent ( out ) :: pout pout = 0. if ( present ( ia_in )) then ia = ia_in else ia = 1 end if if ( present ( reduce_in )) then reduce = reduce_in else reduce = . true . end if do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) pout = pout + wgts_mu ( ia , iz , imu ) * wgts_vpa ( iv ) * g (:, :, ivmu ) * weights ( is ) end do if ( reduce ) call sum_allreduce ( pout ) end subroutine integrate_species_vmu_block_complex subroutine integrate_species_vmu_block_real ( g , iz , weights , pout , ia_in , reduce_in ) use mp , only : sum_allreduce use stella_layouts , only : vmu_lo , iv_idx , imu_idx , is_idx implicit none integer :: ivmu , iv , is , imu , ia logical :: reduce real , dimension (:, :, vmu_lo % llim_proc :), intent ( in ) :: g integer , intent ( in ) :: iz integer , intent ( in ), optional :: ia_in logical , intent ( in ), optional :: reduce_in real , dimension (:), intent ( in ) :: weights real , dimension (:, :), intent ( out ) :: pout pout = 0. if ( present ( ia_in )) then ia = ia_in else ia = 1 end if if ( present ( reduce_in )) then reduce = reduce_in else reduce = . true . end if do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) pout = pout + wgts_mu ( ia , iz , imu ) * wgts_vpa ( iv ) * g (:, :, ivmu ) * weights ( is ) end do if ( reduce ) call sum_allreduce ( pout ) end subroutine integrate_species_vmu_block_real subroutine integrate_species_ffs ( g , weights , pout , reduce_in ) use mp , only : sum_allreduce use stella_layouts , only : vmu_lo , iv_idx , imu_idx , is_idx implicit none integer :: ivmu , iv , is , imu logical :: reduce complex , dimension (:, :, vmu_lo % llim_proc :), intent ( in ) :: g logical , intent ( in ), optional :: reduce_in real , dimension (:), intent ( in ) :: weights complex , dimension (:, :), intent ( out ) :: pout pout = 0. if ( present ( reduce_in )) then reduce = reduce_in else reduce = . true . end if do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) pout = pout + 2.0 * wgts_mu_bare ( imu ) * wgts_vpa ( iv ) * g (:, :, ivmu ) * weights ( is ) end do if ( reduce ) call sum_allreduce ( pout ) end subroutine integrate_species_ffs subroutine integrate_vmu_ffs ( g , weights , ia , iz , pout , reduce_in ) use mp , only : sum_allreduce use stella_layouts , only : vmu_lo , iv_idx , imu_idx , is_idx implicit none complex , dimension ( vmu_lo % llim_proc :), intent ( in ) :: g real , dimension (:), intent ( in ) :: weights integer , intent ( in ) :: ia , iz complex , dimension (:), intent ( out ) :: pout logical , intent ( in ), optional :: reduce_in integer :: ivmu , iv , is , imu logical :: reduce pout = 0. if ( present ( reduce_in )) then reduce = reduce_in else reduce = . true . end if !> NB: for FFS, assume that there is only one flux annulus !> the inclusion of the Maxwellian term below is due to the fact that !> g/F is evolved for FFS do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) pout ( is ) = pout ( is ) + wgts_mu ( ia , iz , imu ) * wgts_vpa ( iv ) * g ( ivmu ) * weights ( is ) & * maxwell_mu ( ia , iz , imu , is ) * maxwell_vpa ( iv , is ) end do if ( reduce ) call sum_allreduce ( pout ) end subroutine integrate_vmu_ffs subroutine finish_vpa_grid implicit none if ( allocated ( vpa )) deallocate ( vpa ) if ( allocated ( wgts_vpa )) deallocate ( wgts_vpa ) if ( allocated ( wgts_vpa_default )) deallocate ( wgts_vpa_default ) if ( allocated ( maxwell_vpa )) deallocate ( maxwell_vpa ) if ( allocated ( ztmax )) deallocate ( ztmax ) end subroutine finish_vpa_grid subroutine init_mu_grid use gauss_quad , only : get_laguerre_grids use zgrid , only : nzgrid , nztot use kt_grids , only : nalpha use species , only : spec , nspec use stella_geometry , only : bmag , bmag_psi0 implicit none integer :: imu real :: mu_max !> allocate arrays and initialize to zero if (. not . allocated ( mu )) then allocate ( mu ( nmu )); mu = 0.0 allocate ( wgts_mu ( nalpha , - nzgrid : nzgrid , nmu )); wgts_mu = 0.0 allocate ( wgts_mu_bare ( nmu )); wgts_mu_bare = 0.0 allocate ( maxwell_mu ( nalpha , - nzgrid : nzgrid , nmu , nspec )); maxwell_mu = 0.0 allocate ( dmu ( nmu - 1 )) allocate ( dmu_ghost ( nmu )) allocate ( mu_cell ( nmu )) allocate ( dmu_cell ( nmu )) end if !> dvpe * vpe = d(2*mu*B0) * B/2B0 if ( equally_spaced_mu_grid ) then !> first get equally spaced grid in mu with max value !> mu_max = vperp_max**2/(2*max(bmag)) mu_max = vperp_max ** 2 / ( 2. * maxval ( bmag_psi0 )) !> want first grid point at dmu/2 to avoid mu=0 special point !> dmu/2 + (nmu-1)*dmu = mu_max !> so dmu = mu_max/(nmu-1/2) dmu = mu_max / ( nmu - 0.5 ) mu ( 1 ) = 0.5 * dmu ( 1 ) do imu = 2 , nmu mu ( imu ) = mu ( 1 ) + ( imu - 1 ) * dmu ( 1 ) end do !> do simplest thing to start wgts_mu_bare = dmu ( 1 ) else !    ! use Gauss-Laguerre quadrature in 2*mu*bmag(z=0) ! use Gauss-Laguerre quadrature in 2*mu*min(bmag)*max( call get_laguerre_grids ( mu , wgts_mu_bare ) if ( vperp_max < 0 ) vperp_max = sqrt ( mu ( nmu )) wgts_mu_bare = wgts_mu_bare * exp ( mu ) / ( 2. * minval ( bmag_psi0 ) * mu ( nmu ) / vperp_max ** 2 ) !    mu = mu/(2.*bmag(1,0)) mu = mu / ( 2. * minval ( bmag_psi0 ) * mu ( nmu ) / vperp_max ** 2 ) dmu (: nmu - 1 ) = mu ( 2 :) - mu (: nmu - 1 ) !> leave dmu(nmu) uninitialized. should never be used, so want !> valgrind or similar to return error if it is end if !> maxwell_mu is the mu part of the v-space Maxwellian maxwell_mu = exp ( - 2. * spread ( spread ( spread ( mu , 1 , nalpha ), 2 , nztot ) * spread ( bmag , 3 , nmu ), 4 , nspec ) & * spread ( spread ( spread ( spec % temp_psi0 / spec % temp , 1 , nalpha ), 2 , nztot ), 3 , nmu )) !> factor of 2. necessary to account for 2pi from !> integration over gyro-angle and 1/pi&#94;(3/2) normalization !> of velocity space Jacobian wgts_mu = 2. * spread ( spread ( wgts_mu_bare , 1 , nalpha ), 2 , nztot ) * spread ( bmag , 3 , nmu ) !> add ghost cell at mu=0 and beyond mu_max for purposes of differentiation !> note assuming here that grid spacing for ghost cell is equal to !> grid spacing for last non-ghost cell dmu_ghost (: nmu - 1 ) = dmu ; dmu_ghost ( nmu ) = dmu ( nmu - 1 ) !> this is mu at cell centres (including to left and right of mu grid boundary points) mu_cell (: nmu - 1 ) = 0.5 * ( mu (: nmu - 1 ) + mu ( 2 :)) mu_cell ( nmu ) = mu ( nmu ) + 0.5 * dmu ( nmu - 1 ) !> this is mu_{j+1/2} - mu_{j-1/2} dmu_cell ( 1 ) = mu_cell ( 1 ) dmu_cell ( 2 :) = mu_cell ( 2 :) - mu_cell (: nmu - 1 ) end subroutine init_mu_grid subroutine finish_mu_grid implicit none if ( allocated ( mu )) deallocate ( mu ) if ( allocated ( mu_cell )) deallocate ( mu_cell ) if ( allocated ( wgts_mu )) deallocate ( wgts_mu ) if ( allocated ( wgts_mu_bare )) deallocate ( wgts_mu_bare ) if ( allocated ( maxwell_mu )) deallocate ( maxwell_mu ) if ( allocated ( dmu )) deallocate ( dmu ) if ( allocated ( dmu_cell )) deallocate ( dmu_cell ) if ( allocated ( dmu_ghost )) deallocate ( dmu_ghost ) if ( allocated ( rbuffer )) deallocate ( rbuffer ) end subroutine finish_mu_grid subroutine calculate_velocity_integrals use zgrid , only : nzgrid use species , only : nspec implicit none real , dimension ( nvpa , nmu ) :: moment integer :: ia , is , iz ia = 1 is = 1 if (. not . allocated ( int_unit )) allocate ( int_unit ( 1 , - nzgrid : nzgrid , nspec )) if (. not . allocated ( int_vpa2 )) allocate ( int_vpa2 ( 1 , - nzgrid : nzgrid , nspec )) if (. not . allocated ( int_vperp2 )) allocate ( int_vperp2 ( 1 , - nzgrid : nzgrid , nspec )) if (. not . allocated ( int_vfrth )) allocate ( int_vfrth ( 1 , - nzgrid : nzgrid , nspec )) do is = 1 , nspec do iz = - nzgrid , nzgrid moment = spread ( maxwell_mu ( ia , iz , :, is ), 1 , nvpa ) * spread ( maxwell_vpa (:, is ), 2 , nmu ) call integrate_vmu ( moment , iz , int_unit ( ia , iz , is )) moment = spread ( maxwell_mu ( ia , iz , :, is ), 1 , nvpa ) * spread ( vpa (:) ** 2 * maxwell_vpa (:, is ), 2 , nmu ) call integrate_vmu ( moment , iz , int_vpa2 ( ia , iz , is )) moment = spread ( vperp2 ( ia , iz , :) * maxwell_mu ( ia , iz , :, is ), 1 , nvpa ) * spread ( maxwell_vpa (:, is ), 2 , nmu ) call integrate_vmu ( moment , iz , int_vperp2 ( ia , iz , is )) moment = spread ( maxwell_mu ( ia , iz , :, is ), 1 , nvpa ) * spread ( maxwell_vpa (:, is ), 2 , nmu ) moment = moment * ( spread ( vpa ** 2 , 2 , nmu ) + spread ( vperp2 ( ia , iz , :), 1 , nvpa )) ** 2 call integrate_vmu ( moment , iz , int_vfrth ( ia , iz , is )) end do end do end subroutine calculate_velocity_integrals subroutine finish_vpamu_grids implicit none call finish_vpa_grid call finish_mu_grid if ( allocated ( maxwell_fac )) deallocate ( maxwell_fac ) if ( allocated ( int_unit )) deallocate ( int_unit ) if ( allocated ( int_vpa2 )) deallocate ( int_vpa2 ) if ( allocated ( int_vperp2 )) deallocate ( int_vperp2 ) if ( allocated ( int_vfrth )) deallocate ( int_vfrth ) vpamu_initialized = . false . end subroutine finish_vpamu_grids end module vpamu_grids","tags":"","loc":"sourcefile/vpamu_grids.f90.html"},{"title":"dist_fn.f90 â€“ stella","text":"Contents Modules dist_fn Source Code dist_fn.f90 Source Code module dist_fn implicit none public :: init_gxyz public :: init_dist_fn , finish_dist_fn private logical :: dist_fn_initialized = . false . logical :: gxyz_initialized = . false . logical :: kp2init = . false . logical :: vp2init = . false . logical :: debug = . false . contains subroutine init_gxyz ( restarted ) use dist_fn_arrays , only : gvmu , gold , gnew use redistribute , only : gather , scatter use dist_redistribute , only : kxkyz2vmu use physics_flags , only : radial_variation use stella_layouts , only : vmu_lo , iv_idx , imu_idx , is_idx use stella_transforms , only : transform_kx2x_xfirst , transform_x2kx_xfirst use kt_grids , only : nalpha , nakx , naky , multiply_by_rho use vpamu_grids , only : mu , vpa , vperp2 use zgrid , only : nzgrid , ntubes use species , only : spec , pfac use stella_geometry , only : dBdrho , gfac implicit none real :: corr integer :: ivmu , is , imu , iv , it , iz , ia real , dimension (:, :), allocatable :: energy complex , dimension (:, :), allocatable :: g0k logical , intent ( in ) :: restarted if ( gxyz_initialized ) return gxyz_initialized = . false . ! get version of g that has ky,kx,z local call gather ( kxkyz2vmu , gvmu , gnew ) ia = 1 !calculate radial corrections to F0 for use in Krook operator, as well as g1 from initialization if ( radial_variation ) then !init_g uses maxwellians, so account for variation in temperature, density, and B allocate ( energy ( nalpha , - nzgrid : nzgrid )) allocate ( g0k ( naky , nakx )) do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) iv = iv_idx ( vmu_lo , ivmu ) energy = ( vpa ( iv ) ** 2 + vperp2 (:, :, imu )) * ( spec ( is )% temp_psi0 / spec ( is )% temp ) do it = 1 , ntubes do iz = - nzgrid , nzgrid corr = - ( pfac * ( spec ( is )% fprim + spec ( is )% tprim * ( energy ( ia , iz ) - 1.5 )) & + 2 * gfac * mu ( imu ) * dBdrho ( iz )) if (. not . restarted ) then g0k = corr * gnew (:, :, iz , it , ivmu ) call multiply_by_rho ( g0k ) gnew (:, :, iz , it , ivmu ) = gnew (:, :, iz , it , ivmu ) + g0k end if end do end do end do deallocate ( energy , g0k ) if (. not . restarted ) call scatter ( kxkyz2vmu , gnew , gvmu ) end if gold = gnew end subroutine init_gxyz subroutine init_dist_fn use mp , only : proc0 use stella_layouts , only : init_dist_fn_layouts use gyro_averages , only : init_bessel implicit none if ( dist_fn_initialized ) return dist_fn_initialized = . true . debug = debug . and . proc0 if ( debug ) write ( * , * ) 'dist_fn::init_dist_fn::allocate_arrays' call allocate_arrays !> allocate and initialise kperp2 and dkperp2dr if ( debug ) write ( * , * ) 'dist_fn::init_dist_fn::init_kperp2' call init_kperp2 !> allocate and initialise vperp2 if ( debug ) write ( * , * ) 'dist_fn::init_dist_fn::init_vperp2' call init_vperp2 !> init_bessel sets up arrays needed for gyro-averaging; !> for a flux tube simulation, this is j0 and j1; !> for a flux annulus simulation, gyro-averaging is non-local in ky !> and so more effort is required if ( debug ) write ( * , * ) 'dist_fn::init_dist_fn::init_bessel' call init_bessel end subroutine init_dist_fn !> init_kperp2 allocates and initialises the kperp2 and dkperp2dr arrays !> @todo would be tidier if dkperp2dr were initialised separately in, e.g., init_dkperp2dr subroutine init_kperp2 use dist_fn_arrays , only : kperp2 , dkperp2dr use stella_geometry , only : gds2 , gds21 , gds22 use stella_geometry , only : dgds2dr , dgds21dr use stella_geometry , only : dgds22dr use stella_geometry , only : geo_surf , q_as_x use zgrid , only : nzgrid use kt_grids , only : naky , nakx , theta0 use kt_grids , only : akx , aky use kt_grids , only : zonal_mode use kt_grids , only : nalpha implicit none integer :: iky , ikx if ( kp2init ) return kp2init = . true . !> allocate the kperp2 array to contain |k_perp|&#94;2 allocate ( kperp2 ( naky , nakx , nalpha , - nzgrid : nzgrid )) !> @todo as dkperp2dr is only needed for radially global simulations !> should only allocate/compute it when needed allocate ( dkperp2dr ( naky , nakx , nalpha , - nzgrid : nzgrid )) do iky = 1 , naky if ( zonal_mode ( iky )) then do ikx = 1 , nakx if ( q_as_x ) then kperp2 ( iky , ikx , :, :) = akx ( ikx ) * akx ( ikx ) * gds22 where ( kperp2 ( iky , ikx , :, :) > epsilon ( 0.0 )) dkperp2dr ( iky , ikx , :, :) = akx ( ikx ) * akx ( ikx ) * dgds22dr / kperp2 ( iky , ikx , :, :) elsewhere dkperp2dr ( iky , ikx , :, :) = 0.0 end where else kperp2 ( iky , ikx , :, :) = akx ( ikx ) * akx ( ikx ) * gds22 / ( geo_surf % shat ** 2 ) where ( kperp2 ( iky , ikx , :, :) > epsilon ( 0.0 )) dkperp2dr ( iky , ikx , :, :) = akx ( ikx ) * akx ( ikx ) * dgds22dr / ( geo_surf % shat ** 2 * kperp2 ( iky , ikx , :, :)) elsewhere dkperp2dr ( iky , ikx , :, :) = 0.0 end where end if end do else do ikx = 1 , nakx kperp2 ( iky , ikx , :, :) = aky ( iky ) * aky ( iky ) & * ( gds2 + 2.0 * theta0 ( iky , ikx ) * gds21 & + theta0 ( iky , ikx ) * theta0 ( iky , ikx ) * gds22 ) dkperp2dr ( iky , ikx , :, :) = aky ( iky ) * aky ( iky ) & * ( dgds2dr + 2.0 * theta0 ( iky , ikx ) * dgds21dr & + theta0 ( iky , ikx ) * theta0 ( iky , ikx ) * dgds22dr ) dkperp2dr ( iky , ikx , :, :) = dkperp2dr ( iky , ikx , :, :) / kperp2 ( iky , ikx , :, :) if ( any ( kperp2 ( iky , ikx , :, :) < epsilon ( 0. ))) dkperp2dr ( iky , ikx , :, :) = 0. end do end if end do ! NB: should really avoid this by using higher resolution when reading in VMEC geometry and then ! NB: course-graining if necessary to map onto lower-resolution stella grid ! ensure kperp2 is positive everywhere (only might go negative if using full-flux-surface due to interpolation) where ( kperp2 < 0.0 ) kperp2 = 0.0 end where call enforce_single_valued_kperp2 end subroutine init_kperp2 subroutine enforce_single_valued_kperp2 use dist_fn_arrays , only : kperp2 use kt_grids , only : naky , nalpha use zgrid , only : nzgrid use extended_zgrid , only : neigen , nsegments , ikxmod implicit none integer :: iky , ie , iseg real , dimension (:), allocatable :: tmp allocate ( tmp ( nalpha )); tmp = 0.0 do iky = 1 , naky do ie = 1 , neigen ( iky ) if ( nsegments ( ie , iky ) > 1 ) then do iseg = 2 , nsegments ( ie , iky ) tmp = 0.5 * ( kperp2 ( iky , ikxmod ( iseg - 1 , ie , iky ), :, nzgrid ) + kperp2 ( iky , ikxmod ( iseg , ie , iky ), :, - nzgrid )) kperp2 ( iky , ikxmod ( iseg , ie , iky ), :, - nzgrid ) = tmp kperp2 ( iky , ikxmod ( iseg - 1 , ie , iky ), :, nzgrid ) = tmp end do end if end do end do deallocate ( tmp ) end subroutine enforce_single_valued_kperp2 subroutine allocate_arrays use stella_layouts , only : kxkyz_lo , vmu_lo use zgrid , only : nzgrid , ntubes use kt_grids , only : naky , nakx use vpamu_grids , only : nvpa , nmu use dist_fn_arrays , only : gnew , gold use dist_fn_arrays , only : gvmu implicit none if (. not . allocated ( gnew )) & allocate ( gnew ( naky , nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) gnew = 0. if (. not . allocated ( gold )) & allocate ( gold ( naky , nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) gold = 0. if (. not . allocated ( gvmu )) & allocate ( gvmu ( nvpa , nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) gvmu = 0. end subroutine allocate_arrays subroutine init_vperp2 use stella_geometry , only : bmag use zgrid , only : nzgrid use vpamu_grids , only : vperp2 use vpamu_grids , only : nmu , mu use kt_grids , only : nalpha implicit none integer :: imu if ( vp2init ) return vp2init = . true . if (. not . allocated ( vperp2 )) allocate ( vperp2 ( nalpha , - nzgrid : nzgrid , nmu )); vperp2 = 0. do imu = 1 , nmu vperp2 (:, :, imu ) = 2.0 * mu ( imu ) * bmag end do end subroutine init_vperp2 subroutine finish_dist_fn use gyro_averages , only : finish_bessel implicit none call finish_bessel call finish_kperp2 call finish_vperp2 call deallocate_arrays dist_fn_initialized = . false . gxyz_initialized = . false . end subroutine finish_dist_fn subroutine deallocate_arrays use dist_fn_arrays , only : gnew , gold , gvmu implicit none if ( allocated ( gnew )) deallocate ( gnew ) if ( allocated ( gold )) deallocate ( gold ) if ( allocated ( gvmu )) deallocate ( gvmu ) end subroutine deallocate_arrays subroutine finish_kperp2 use dist_fn_arrays , only : kperp2 , dkperp2dr implicit none if ( allocated ( kperp2 )) deallocate ( kperp2 ) if ( allocated ( dkperp2dr )) deallocate ( dkperp2dr ) kp2init = . false . end subroutine finish_kperp2 subroutine finish_vperp2 use vpamu_grids , only : vperp2 implicit none if ( allocated ( vperp2 )) deallocate ( vperp2 ) vp2init = . false . end subroutine finish_vperp2 end module dist_fn","tags":"","loc":"sourcefile/dist_fn.f90.html"},{"title":"g_tofrom_h.f90 â€“ stella","text":"Contents Modules g_tofrom_h Source Code g_tofrom_h.f90 Source Code module g_tofrom_h !  public :: gbar_to_g !  public :: gbar_to_h !  public :: gstar_to_g public :: g_to_h private !   interface gbar_to_g !      module procedure gbar_to_g_kxkyz !      module procedure gbar_to_g_vmu !   end interface !  interface gbar_to_h !     module procedure gbar_to_h_kxkyz !     module procedure gbar_to_h_vmu !  end interface interface g_to_h module procedure g_to_h_kxkyz module procedure g_to_h_vmu !     module procedure g_to_h_vmu_zext end interface contains !   subroutine gbar_to_h_vmu (g, phi, apar, facphi, facapar) !     use species, only: spec !     use zgrid, only: nzgrid !     use vpamu_grids, only: maxwell_vpa, maxwell_mu, vpa !     use stella_layouts, only: vmu_lo !     use stella_layouts, only: iv_idx, imu_idx, is_idx !     use kt_grids, only: naky, nakx !     use gyro_averages, only: aj0x !     implicit none !     complex, dimension (:,:,-nzgrid:,vmu_lo%llim_proc:), intent (in out) :: g !     complex, dimension (:,:,-nzgrid:), intent (in) :: phi, apar !     real, intent (in) :: facphi, facapar !     integer :: ivmu, iz, iky, ikx, is, imu, iv !     complex :: adj !     do ivmu = vmu_lo%llim_proc, vmu_lo%ulim_proc !        iv = iv_idx(vmu_lo,ivmu) !        imu = imu_idx(vmu_lo,ivmu) !        is = is_idx(vmu_lo,ivmu) !        do iz = -nzgrid, nzgrid !           do ikx = 1, nakx !              do iky = 1, naky !                 adj = aj0x(iky,ikx,iz,ivmu)*spec(is)%zt*maxwell_vpa(iv)*maxwell_mu(1,iz,imu) & !                      * ( facphi*phi(iky,ikx,iz) - facapar*vpa(iv)*spec(is)%stm*apar(iky,ikx,iz) ) !                 g(iky,ikx,iz,ivmu) = g(iky,ikx,iz,ivmu) + adj !              end do !           end do !        end do !     end do !   end subroutine gbar_to_h_vmu !   subroutine gbar_to_h_kxkyz (g, phi, apar, facphi, facapar) !     use species, only: spec !     use zgrid, only: nzgrid !     use vpamu_grids, only: maxwell_vpa, maxwell_mu, vpa !     use vpamu_grids, only: nvpa, nmu !     use stella_layouts, only: kxkyz_lo !     use stella_layouts, only: iky_idx, ikx_idx, iz_idx, is_idx !     use gyro_averages, only: aj0v !     implicit none !     complex, dimension (:,:,kxkyz_lo%llim_proc:), intent (in out) :: g !     complex, dimension (:,:,-nzgrid:), intent (in) :: phi, apar !     real, intent (in) :: facphi, facapar !     integer :: ikxkyz, iz, iky, ikx, is, imu, iv !     complex :: adj !     do ikxkyz = kxkyz_lo%llim_proc, kxkyz_lo%ulim_proc !        iz = iz_idx(kxkyz_lo,ikxkyz) !        ikx = ikx_idx(kxkyz_lo,ikxkyz) !        iky = iky_idx(kxkyz_lo,ikxkyz) !        is = is_idx(kxkyz_lo,ikxkyz) !        do imu = 1, nmu !           do iv = 1, nvpa !              adj = aj0v(imu,ikxkyz)*spec(is)%zt*maxwell_vpa(iv)*maxwell_mu(1,iz,imu) & !                   * ( facphi*phi(iky,ikx,iz) - facapar*vpa(iv)*spec(is)%stm*apar(iky,ikx,iz) ) !              g(iv,imu,ikxkyz) = g(iv,imu,ikxkyz) + adj !           end do !        end do !     end do !   end subroutine gbar_to_h_kxkyz !   subroutine gbar_to_g_vmu (g, apar, facapar) !     use species, only: spec !     use zgrid, only: nzgrid !     use vpamu_grids, only: maxwell_vpa, maxwell_mu, vpa !     use stella_layouts, only: vmu_lo !     use stella_layouts, only: iv_idx, imu_idx, is_idx !     use kt_grids, only: naky, nakx !     use gyro_averages, only: aj0x !     implicit none !     complex, dimension (:,:,-nzgrid:,vmu_lo%llim_proc:), intent (in out) :: g !     complex, dimension (:,:,-nzgrid:), intent (in) :: apar !     real, intent (in) :: facapar !     integer :: ivmu, iz, iky, ikx, is, imu, iv !     complex :: adj !     do ivmu = vmu_lo%llim_proc, vmu_lo%ulim_proc !        iv = iv_idx(vmu_lo,ivmu) !        imu = imu_idx(vmu_lo,ivmu) !        is = is_idx(vmu_lo,ivmu) !        do iz = -nzgrid, nzgrid !           do ikx = 1, nakx !              do iky = 1, naky !                 adj = -aj0x(iky,ikx,iz,ivmu)*spec(is)%zt*maxwell_vpa(iv)*maxwell_mu(1,iz,imu) & !                      * ( facapar*vpa(iv)*spec(is)%stm*apar(iky,ikx,iz) ) !                 g(iky,ikx,iz,ivmu) = g(iky,ikx,iz,ivmu) + adj !              end do !           end do !        end do !     end do !   end subroutine gbar_to_g_vmu !   subroutine gbar_to_g_kxkyz (g, apar, facapar) !     use species, only: spec !     use zgrid, only: nzgrid !     use vpamu_grids, only: maxwell_vpa, maxwell_mu, vpa !     use vpamu_grids, only: nvpa, nmu !     use stella_layouts, only: kxkyz_lo !     use stella_layouts, only: iky_idx, ikx_idx, iz_idx, is_idx !     use gyro_averages, only: aj0v !     implicit none !     complex, dimension (:,:,kxkyz_lo%llim_proc:), intent (in out) :: g !     complex, dimension (:,:,-nzgrid:), intent (in) :: apar !     real, intent (in) :: facapar !     integer :: ikxkyz, iz, iky, ikx, is, imu, iv !     complex :: adj !     do ikxkyz = kxkyz_lo%llim_proc, kxkyz_lo%ulim_proc !        iz = iz_idx(kxkyz_lo,ikxkyz) !        ikx = ikx_idx(kxkyz_lo,ikxkyz) !        iky = iky_idx(kxkyz_lo,ikxkyz) !        is = is_idx(kxkyz_lo,ikxkyz) !        do imu = 1, nmu !           do iv = 1, nvpa !              adj = -aj0v(imu,ikxkyz)*spec(is)%zt*maxwell_vpa(iv)*maxwell_mu(1,iz,imu) & !                   * ( facapar*vpa(iv)*spec(is)%stm*apar(iky,ikx,iz) ) !              g(iv,imu,ikxkyz) = g(iv,imu,ikxkyz) + adj !           end do !        end do !     end do !   end subroutine gbar_to_g_kxkyz subroutine g_to_h_vmu ( g , phi , facphi , phi_corr ) use species , only : spec use zgrid , only : nzgrid , ntubes use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx , imu_idx , is_idx use stella_geometry , only : bmag , dBdrho use dist_fn_arrays , only : kperp2 , dkperp2dr use kt_grids , only : naky , nakx , multiply_by_rho use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac , vperp2 , mu , vpa use stella_transforms , only : transform_kx2x_xfirst , transform_x2kx_xfirst use gyro_averages , only : gyro_average , aj0x , aj1x use physics_flags , only : radial_variation implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: phi complex , dimension (:, :, - nzgrid :, :), optional , intent ( in ) :: phi_corr real , intent ( in ) :: facphi integer :: ivmu , iz , it , is , imu , iv , ia complex , dimension (:, :), allocatable :: field , adjust , g0k allocate ( field ( naky , nakx )) allocate ( adjust ( naky , nakx )) if ( radial_variation ) then allocate ( g0k ( naky , nakx )) end if ia = 1 do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) do it = 1 , ntubes do iz = - nzgrid , nzgrid field = spec ( is )% zt * facphi * phi (:, :, iz , it ) & * maxwell_vpa ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) * maxwell_fac ( is ) if ( radial_variation . and . present ( phi_corr )) then g0k = field * ( - spec ( is )% tprim * ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu ) - 2.5 ) & - spec ( is )% fprim - 2.0 * dBdrho ( iz ) * mu ( imu ) & - 0.5 * aj1x (:, :, iz , ivmu ) / aj0x (:, :, iz , ivmu ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 (:, :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz ))) call multiply_by_rho ( g0k ) field = field + g0k & + phi_corr (:, :, iz , it ) * spec ( is )% zt * facphi & * maxwell_vpa ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) * maxwell_fac ( is ) end if call gyro_average ( field , iz , ivmu , adjust ) g (:, :, iz , it , ivmu ) = g (:, :, iz , it , ivmu ) + adjust end do end do end do deallocate ( field , adjust ) if ( allocated ( g0k )) deallocate ( g0k ) end subroutine g_to_h_vmu !   subroutine g_to_h_vmu_zext (gext, phiext, facphi, iky, ie) !     use species, only: spec !     use extended_zgrid, only: ikxmod !     use extended_zgrid, only: iz_low, iz_up !     use extended_zgrid, only: nsegments !     use vpamu_grids, only: maxwell_vpa, maxwell_mu !     use stella_layouts, only: vmu_lo !     use stella_layouts, only: iv_idx, imu_idx, is_idx !     use gyro_averages, only: aj0x !     implicit none !     complex, dimension (:,vmu_lo%llim_proc:), intent (in out) :: gext !     complex, dimension (:), intent (in) :: phiext !     real, intent (in) :: facphi !     integer, intent (in) :: iky, ie !     integer :: ivmu, iseg, iz, ikx, is, imu, iv !     integer :: idx !     complex :: adj !     do ivmu = vmu_lo%llim_proc, vmu_lo%ulim_proc !        iv = iv_idx(vmu_lo,ivmu) !        imu = imu_idx(vmu_lo,ivmu) !        is = is_idx(vmu_lo,ivmu) !        idx = 0 !        iseg = 1 !        ikx = ikxmod(iseg,ie,iky) !        do iz = iz_low(iseg), iz_up(iseg) !           idx = idx + 1 !           adj = aj0x(iky,ikx,iz,ivmu)*spec(is)%zt*maxwell_vpa(iv)*maxwell_mu(1,iz,imu) & !                * facphi*phiext(idx) !           gext(idx,ivmu) = gext(idx,ivmu) + adj !        end do !        if (nsegments(ie,iky) > 1) then !           do iseg = 2, nsegments(ie,iky) !              do iz = iz_low(iseg)+1, iz_up(iseg) !                 adj = aj0x(iky,ikx,iz,ivmu)*spec(is)%zt*maxwell_vpa(iv)*maxwell_mu(1,iz,imu) & !                      * facphi*phiext(idx) !                 gext(idx,ivmu) = gext(idx,ivmu) + adj !                 idx = idx + 1 !              end do !           end do !        end if !     end do !   end subroutine g_to_h_vmu_zext subroutine g_to_h_kxkyz ( g , phi , facphi ) use species , only : spec use zgrid , only : nzgrid use vpamu_grids , only : nvpa , nmu use vpamu_grids , only : maxwell_vpa , maxwell_mu use stella_layouts , only : kxkyz_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , it_idx , is_idx use gyro_averages , only : gyro_average implicit none complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( in out ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: phi real , intent ( in ) :: facphi integer :: ikxkyz , iz , it , iky , ikx , is , ia complex , dimension (:, :), allocatable :: field , adjust allocate ( field ( nvpa , nmu )) allocate ( adjust ( nvpa , nmu )) ia = 1 do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iky = iky_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) field = facphi * phi ( iky , ikx , iz , it ) * spec ( is )% zt & * spread ( maxwell_vpa (:, is ), 2 , nmu ) * spread ( maxwell_mu ( ia , iz , :, is ), 1 , nvpa ) call gyro_average ( field , ikxkyz , adjust ) g (:, :, ikxkyz ) = g (:, :, ikxkyz ) + adjust end do deallocate ( field , adjust ) end subroutine g_to_h_kxkyz !   subroutine gstar_to_g (g, phi, apar, facphi, facapar) !     use constants, only: zi !     use species, only: spec !     use zgrid, only: nzgrid !     use vpamu_grids, only: vpa !     use stella_layouts, only: vmu_lo !     use stella_layouts, only: iv_idx, is_idx !     use kt_grids, only: naky, nakx !     use kt_grids, only: aky !     use gyro_averages, only: aj0x !     implicit none !     complex, dimension (:,:,-nzgrid:,vmu_lo%llim_proc:), intent (in out) :: g !     complex, dimension (:,:,-nzgrid:), intent (in) :: phi, apar !     real, intent (in) :: facphi, facapar !     integer :: ivmu, iz, iky, ikx, is, iv !     complex :: adj !     do ivmu = vmu_lo%llim_proc, vmu_lo%ulim_proc !        iv = iv_idx(vmu_lo,ivmu) !        is = is_idx(vmu_lo,ivmu) !        do iz = -nzgrid, nzgrid !           do ikx = 1, nakx !              do iky = 1, naky !                 ! BACKWARDS DIFFERENCE FLAG ! !                adj = zi*aj0x(iky,ikx,iz,ivmu)*aky(iky)*wstar(iz,ivmu) & !                 adj = zi*aj0x(iky,ikx,iz,ivmu)*aky(iky)*2.0*wstar(1,iz,ivmu) & !                      * ( facphi*phi(iky,ikx,iz) - facapar*vpa(iv)*spec(is)%stm*apar(iky,ikx,iz) ) !                 g(iky,ikx,iz,ivmu) = g(iky,ikx,iz,ivmu) + adj !              end do !           end do !        end do !     end do !   end subroutine gstar_to_g end module g_tofrom_h","tags":"","loc":"sourcefile/g_tofrom_h.f90.html"},{"title":"common_types.f90 â€“ stella","text":"Contents Modules common_types Source Code common_types.f90 Source Code module common_types implicit none type :: kxkyz_layout_type sequence integer :: iproc integer :: nzgrid , nzed , ntubes , naky , nakx , nvgrid , nvpa , nmu , nspec integer :: llim_world , ulim_world , llim_proc , ulim_proc , ulim_alloc , blocksize end type kxkyz_layout_type type :: kxyz_layout_type sequence integer :: iproc integer :: nzgrid , nzed , ntubes , ny , naky , nakx , ikx_max , nvgrid , nvpa , nmu , nspec integer :: llim_world , ulim_world , llim_proc , ulim_proc , ulim_alloc , blocksize end type kxyz_layout_type type :: xyz_layout_type sequence integer :: iproc integer :: nzgrid , nzed , ntubes , ny , naky , nx , nakx , nvgrid , nvpa , nmu , nspec integer :: llim_world , ulim_world , llim_proc , ulim_proc , ulim_alloc , blocksize end type xyz_layout_type type :: vmu_layout_type sequence logical :: xyz integer :: iproc integer :: nzgrid , nzed , ntubes , nalpha , ny , naky , nx , nakx , nvgrid , nvpa , nmu , nspec integer :: llim_world , ulim_world , llim_proc , ulim_proc , ulim_alloc , blocksize end type vmu_layout_type type :: flux_surface_type real :: rmaj real :: rgeo real :: kappa real :: kapprim real :: tri real :: triprim real :: rhoc real :: dr real :: shift real :: qinp real :: shat real :: betaprim real :: betadbprim real :: d2qdr2 real :: d2psidr2 real :: dpsitordrho real :: d2psitordrho2 real :: rhotor real :: drhotordrho real :: psitor_lcfs real :: zed0_fac real :: rhoc_psi0 real :: qinp_psi0 real :: shat_psi0 end type flux_surface_type type spec_type integer :: nspec real :: z real :: mass real :: dens , temp real :: tprim , fprim real :: vnew_ref real :: stm , zstm , tz , smz , zt real :: d2ndr2 , d2Tdr2 real :: bess_fac ! 0 for argument of Bessel Functions equal to 0 ! pre-2003 Fortran does not support ! allocatable arrays within derived types ! so set size large enough that it should be a problem ! should be nspec large real , dimension ( 10 ) :: vnew integer :: type !the next few variables are for multibox simulations real :: dens_psi0 , temp_psi0 real :: stm_psi0 , zstm_psi0 , tz_psi0 , smz_psi0 , zt_psi0 end type spec_type type :: eigen_type complex , dimension (:, :), pointer :: zloc => null () integer , dimension (:), pointer :: idx => null () end type eigen_type type :: response_matrix_type type ( eigen_type ), dimension (:), pointer :: eigen => null () end type response_matrix_type type coupled_alpha_type integer :: max_idx complex , dimension (:), pointer :: fourier => null () end type coupled_alpha_type type gam0_ffs_type integer , dimension (:), pointer :: pivot_index => null () complex , dimension (:, :), pointer :: matrix => null () end type gam0_ffs_type end module common_types","tags":"","loc":"sourcefile/common_types.f90.html"},{"title":"stella_geometry.f90 â€“ stella","text":"Contents Modules stella_geometry Source Code stella_geometry.f90 Source Code module stella_geometry use common_types , only : flux_surface_type implicit none public :: init_geometry , finish_init_geometry , finish_geometry public :: communicate_geo_multibox public :: grho , grho_norm , grad_x public :: bmag , dbdzed , btor , bmag_psi0 public :: gradpar , gradpar_eqarc , b_dot_grad_z , zed_eqarc public :: cvdrift , cvdrift0 public :: gbdrift , gbdrift0 public :: dcvdriftdrho , dcvdrift0drho public :: dgbdriftdrho , dgbdrift0drho public :: gds2 , gds21 , gds22 , gds23 , gds24 , gds25 , gds26 public :: dgds2dr , dgds21dr , dgds22dr public :: exb_nonlin_fac , exb_nonlin_fac_p public :: jacob , djacdrho public :: drhodpsi , drhodpsi_psi0 public :: dl_over_b , d_dl_over_b_drho public :: dBdrho , d2Bdrdth , dgradpardrho , dIdrho public :: geo_surf public :: Rmajor public :: alpha public :: theta_vmec public :: zeta public :: zed_scalefac public :: dxdXcoord , dydalpha public :: aref , bref public :: twist_and_shift_geo_fac public :: q_as_x , get_x_to_rho , gfac public :: dVolume public :: grad_x_grad_y_end public :: x_displacement_fac private type ( flux_surface_type ) :: geo_surf real :: grad_x_grad_y_end real :: aref , bref real :: dxdXcoord , dydalpha real :: dqdrho real :: dIdrho real :: grho_norm real :: drhodpsi , drhodpsi_psi0 , shat , qinp real :: exb_nonlin_fac , exb_nonlin_fac_p real :: gradpar_eqarc real :: zed_scalefac real :: twist_and_shift_geo_fac , gfac real , dimension (:), allocatable :: zed_eqarc real , dimension (:), allocatable :: gradpar real , dimension (:, :), allocatable :: b_dot_grad_z real , dimension (:, :), allocatable :: bmag , bmag_psi0 , dbdzed real , dimension (:, :), allocatable :: twist_and_shift_geo_fac_full real , dimension (:, :), allocatable :: cvdrift , cvdrift0 real , dimension (:, :), allocatable :: gbdrift , gbdrift0 real , dimension (:, :), allocatable :: dcvdriftdrho , dcvdrift0drho real , dimension (:, :), allocatable :: dgbdriftdrho , dgbdrift0drho real , dimension (:, :), allocatable :: gds2 , gds21 , gds22 , gds23 , gds24 , gds25 , gds26 real , dimension (:, :), allocatable :: dgds2dr , dgds21dr real , dimension (:, :), allocatable :: dgds22dr real , dimension (:, :), allocatable :: theta_vmec real , dimension (:, :), allocatable :: jacob , djacdrho , grho , grad_x real , dimension (:, :), allocatable :: dl_over_b , d_dl_over_b_drho real , dimension (:, :, :), allocatable :: dVolume real , dimension (:, :), allocatable :: x_displacement_fac real , dimension (:), allocatable :: dBdrho , d2Bdrdth , dgradpardrho real , dimension (:), allocatable :: btor , Rmajor real , dimension (:), allocatable :: alpha real , dimension (:, :), allocatable :: zeta integer :: geo_option_switch integer , parameter :: geo_option_local = 1 integer , parameter :: geo_option_inputprof = 2 integer , parameter :: geo_option_vmec = 3 integer , parameter :: geo_option_multibox = 4 logical :: overwrite_geometry logical :: overwrite_bmag , overwrite_gradpar logical :: overwrite_gds2 , overwrite_gds21 , overwrite_gds22 logical :: overwrite_gds23 , overwrite_gds24 logical :: overwrite_gbdrift , overwrite_cvdrift , overwrite_gbdrift0 logical :: q_as_x character ( 100 ) :: geo_file logical :: vmec_chosen = . false . logical :: geoinit = . false . logical :: set_bmag_const contains subroutine init_geometry ( nalpha , naky ) use constants , only : pi use mp , only : proc0 use millerlocal , only : read_local_parameters , get_local_geo use millerlocal , only : communicate_parameters_multibox use vmec_geo , only : read_vmec_parameters , get_vmec_geo use inputprofiles_interface , only : read_inputprof_geo use zgrid , only : nzed , nzgrid use zgrid , only : zed , delzed use zgrid , only : shat_zero , zed_equal_arc use zgrid , only : grad_x_grad_y_zero use zgrid , only : boundary_option_switch , boundary_option_self_periodic use zgrid , only : twist_shift_option_switch , twist_shift_option_std , twist_shift_option_stellarator use zgrid , only : twist_shift_option_periodic use file_utils , only : get_unused_unit use physics_flags , only : include_geometric_variation , const_alpha_geo implicit none logical , parameter :: debug = . false . integer , intent ( in ) :: nalpha , naky real :: dpsidrho , dpsidrho_psi0 integer :: iy , ia , iz integer :: sign_torflux integer :: dxdXcoord_sign , dydalpha_sign real :: field_period_ratio , bmag_z0 real , dimension (:, :), allocatable :: grad_alpha_grad_alpha real , dimension (:, :), allocatable :: grad_alpha_grad_psi real , dimension (:, :), allocatable :: grad_psi_grad_psi real , dimension (:, :), allocatable :: gbdrift_alpha , cvdrift_alpha real , dimension (:, :), allocatable :: gbdrift0_psi , cvdrift0_psi if ( geoinit ) return geoinit = . true . ! B = grad alpha x grad psi ! for tokamak calculations, alpha = zeta - q * theta ! and psi = psi_poloidal ! for stellarator calculations, alpha = theta - iota * zeta ! and psi = -psi_toroidal ! default is no re-scaling of zed zed_scalefac = 1.0 if ( proc0 ) then call read_parameters select case ( geo_option_switch ) case ( geo_option_local ) ! read in Miller local parameters call read_local_parameters ( nzed , nzgrid , geo_surf ) ! allocate geometry arrays call allocate_arrays ( nalpha , nzgrid ) ! use Miller local parameters to get ! geometric coefficients needed by stella call get_local_geo ( nzed , nzgrid , zed , zed_equal_arc , & dpsidrho , dpsidrho_psi0 , dIdrho , grho ( 1 , :), & bmag ( 1 , :), bmag_psi0 ( 1 , :), & gds2 ( 1 , :), gds21 ( 1 , :), gds22 ( 1 , :), & gds23 ( 1 , :), gds24 ( 1 , :), gradpar , & gbdrift0 ( 1 , :), gbdrift ( 1 , :), cvdrift0 ( 1 , :), cvdrift ( 1 , :), & dBdrho , d2Bdrdth , dgradpardrho , btor , rmajor , & dcvdrift0drho ( 1 , :), dcvdriftdrho ( 1 , :), & dgbdrift0drho ( 1 , :), dgbdriftdrho ( 1 , :), & dgds2dr ( 1 , :), dgds21dr ( 1 , :), & dgds22dr ( 1 , :), djacdrho ( 1 , :)) !> b_dot_grad_z is the alpha-dependent b . grad z, !> and gradpar is the constant-in-alpha part of it. !> for axisymmetric systems, b_dot_grad_z is independent of alpha. b_dot_grad_z ( 1 , :) = gradpar ! note that psi here is the enclosed poloidal flux divided by 2pi drhodpsi = 1. / dpsidrho drhodpsi_psi0 = 1. / dpsidrho_psi0 ! dxdXcoord = a*Bref*dx/dpsi = sign(dx/dpsi) * a*q/r dxdXcoord_sign = 1 if ( q_as_x ) then dxdXcoord = dxdXcoord_sign * dpsidrho else dxdXcoord = dxdXcoord_sign * geo_surf % qinp_psi0 / geo_surf % rhoc_psi0 end if ! dydalpha = (dy/dalpha) / a = sign(dydalpha) * (dpsi/dr) / (a*Bref) dydalpha_sign = 1 dydalpha = dydalpha_sign * dpsidrho !> | grad x |  = dx/drho * | grad rho | = dx/dpsi * dpsi/drho * | grad rho | !> = q/rho * dpsidrho * grho grad_x = grho * dxdXcoord * dpsidrho_psi0 ! abs(twist_and_shift_geo_fac) is dkx/dky * jtwist ! minus its sign gives the direction of the shift in kx ! to be used for twist-and-shift BC if ( q_as_x ) then twist_and_shift_geo_fac = 2.0 * pi else twist_and_shift_geo_fac = 2.0 * pi * geo_surf % shat_psi0 end if ! aref and bref should not be needed, so set to 1 aref = 1.0 ; bref = 1.0 zeta ( 1 , :) = zed * geo_surf % qinp case ( geo_option_multibox ) ! read in Miller local parameters call read_local_parameters ( nzed , nzgrid , geo_surf ) ! allocate geometry arrays call allocate_arrays ( nalpha , nzgrid ) call communicate_parameters_multibox ( surf = geo_surf ) ! use Miller local parameters to get ! geometric coefficients needed by stella call get_local_geo ( nzed , nzgrid , zed , zed_equal_arc , & dpsidrho , dpsidrho_psi0 , dIdrho , grho ( 1 , :), & bmag ( 1 , :), bmag_psi0 ( 1 , :), & gds2 ( 1 , :), gds21 ( 1 , :), gds22 ( 1 , :), & gds23 ( 1 , :), gds24 ( 1 , :), gradpar , & gbdrift0 ( 1 , :), gbdrift ( 1 , :), cvdrift0 ( 1 , :), cvdrift ( 1 , :), & dBdrho , d2Bdrdth , dgradpardrho , btor , rmajor , & dcvdrift0drho ( 1 , :), dcvdriftdrho ( 1 , :), & dgbdrift0drho ( 1 , :), dgbdriftdrho ( 1 , :), & dgds2dr ( 1 , :), dgds21dr ( 1 , :), & dgds22dr ( 1 , :), djacdrho ( 1 , :)) !> b_dot_grad_z is the alpha-dependent b . grad z, !> and gradpar is the constant-in-alpha part of it. !> for axisymmetric systems, b_dot_grad_z is independent of alpha. b_dot_grad_z ( 1 , :) = gradpar ! note that psi here is the enclosed poloidal flux divided by 2pi drhodpsi = 1. / dpsidrho drhodpsi_psi0 = 1. / dpsidrho_psi0 ! dxdXcoord = a*Bref*dx/dpsi = sign(dx/dpsi) * a*q/r dxdXcoord_sign = 1 if ( q_as_x ) then dxdXcoord = dxdXcoord_sign / drhodpsi_psi0 else dxdXcoord = dxdXcoord_sign * geo_surf % qinp_psi0 / geo_surf % rhoc_psi0 end if ! dydalpha = (dy/dalpha) / a = sign(dydalpha) * (dpsi/dr) / (a*Bref) dydalpha_sign = 1 dydalpha = dydalpha_sign / drhodpsi_psi0 !> | grad x |  = dx/drho * | grad rho | = dx/dpsi * dpsi/drho * | grad rho | !> = q/rho * dpsidrho * grho grad_x = grho * dxdXcoord * dpsidrho_psi0 ! abs(twist_and_shift_geo_fac) is dkx/dky * jtwist ! minus its sign gives the direction of the shift in kx ! to be used for twist-and-shift BC if ( q_as_x ) then twist_and_shift_geo_fac = 2.0 * pi else twist_and_shift_geo_fac = 2.0 * pi * geo_surf % shat_psi0 end if ! aref and bref should not be needed, so set to 1 aref = 1.0 ; bref = 1.0 zeta ( 1 , :) = zed * geo_surf % qinp case ( geo_option_inputprof ) ! first read in some local parameters ! only thing needed really is rhoc call read_local_parameters ( nzed , nzgrid , geo_surf ) ! allocate geometry arrays call allocate_arrays ( nalpha , nzgrid ) ! now overwrite local parameters ! with those from input.profiles file ! use rhoc from input as surface call read_inputprof_geo ( geo_surf ) call get_local_geo ( nzed , nzgrid , zed , zed_equal_arc , & dpsidrho , dpsidrho_psi0 , dIdrho , grho ( 1 , :), & bmag ( 1 , :), bmag_psi0 ( 1 , :), & gds2 ( 1 , :), gds21 ( 1 , :), gds22 ( 1 , :), & gds23 ( 1 , :), gds24 ( 1 , :), gradpar , & gbdrift0 ( 1 , :), gbdrift ( 1 , :), cvdrift0 ( 1 , :), cvdrift ( 1 , :), & dBdrho , d2Bdrdth , dgradpardrho , btor , rmajor , & dcvdrift0drho ( 1 , :), dcvdriftdrho ( 1 , :), & dgbdrift0drho ( 1 , :), dgbdriftdrho ( 1 , :), & dgds2dr ( 1 , :), dgds21dr ( 1 , :), & dgds22dr ( 1 , :), djacdrho ( 1 , :)) !> b_dot_grad_z is the alpha-dependent b . grad z, !> and gradpar is the constant-in-alpha part of it. !> for axisymmetric systems, b_dot_grad_z is independent of alpha. b_dot_grad_z ( 1 , :) = gradpar ! psi here is enclosed poloidal flux divided by 2pi drhodpsi = 1. / dpsidrho drhodpsi_psi0 = 1. / dpsidrho_psi0 ! dxdXcoord = a*Bref*dx/dpsi = sign(dx/dpsi) * a*q/r dxdXcoord_sign = 1 dxdXcoord = dxdXcoord_sign * geo_surf % qinp / geo_surf % rhoc ! dydalpha = (dy/dalpha) / a = sign(dydalpha) * (dpsi/dr) / (a*Bref) dydalpha_sign = 1 dydalpha = dydalpha_sign * dpsidrho !> | grad x |  = dx/drho * | grad rho | = dx/dpsi * dpsi/drho * | grad rho | !> = q/rho * dpsidrho * grho grad_x = grho * dxdXcoord * dpsidrho_psi0 ! abs(twist_and_shift_geo_fac) is dkx/dky * jtwist ! minus its sign gives the direction of the shift in kx ! to be used for twist-and-shift BC twist_and_shift_geo_fac = 2.0 * pi * geo_surf % shat ! aref and bref should not be needed so set to 1 aref = 1.0 ; bref = 1.0 zeta ( 1 , :) = zed * geo_surf % qinp case ( geo_option_vmec ) vmec_chosen = . true . !> read in input parameters for vmec !> nalpha may be specified via input file if ( debug ) write ( * , * ) 'init_geometry::read_vmec_parameters' call read_vmec_parameters !> allocate geometry arrays if ( debug ) write ( * , * ) 'init_geometry::allocate_arrays' call allocate_arrays ( nalpha , nzgrid ) if ( debug ) write ( * , * ) 'init_geometry::allocate_temporary_arrays' call allocate_temporary_arrays ( nalpha , nzgrid ) !> get geometry coefficients from vmec if ( debug ) write ( * , * ) 'init_geometry::get_vmec_geo' call get_vmec_geo ( nzgrid , nalpha , naky , geo_surf , grho , bmag , gradpar , & b_dot_grad_z , grad_alpha_grad_alpha , & grad_alpha_grad_psi , grad_psi_grad_psi , & gds23 , gds24 , gds25 , gds26 , gbdrift_alpha , gbdrift0_psi , & cvdrift_alpha , cvdrift0_psi , sign_torflux , & theta_vmec , zed_scalefac , aref , bref , alpha , zeta , & field_period_ratio , x_displacement_fac ) !> Bref = 2*abs(psi_tor_LCFS)/a&#94;2 !> a*Bref*dx/dpsi_tor = sign(psi_tor)/rhotor !> psi = -psi_tor !> dxdXcoord = a*Bref*dx/dpsi = -a*Bref*dx/dpsi_tor = -sign(psi_tor)/rhotor dxdXcoord_sign = - 1 dxdXcoord = dxdXcoord_sign * sign_torflux / geo_surf % rhotor !> dydalpha = (dy/dalpha) / a = sign(dydalpha) * rhotor dydalpha_sign = 1 dydalpha = dydalpha_sign * geo_surf % rhotor !> if using vmec, rho = sqrt(psitor/psitor_lcfs) !> psiN = -psitor/(aref**2*Bref) !> so drho/dpsiN = -drho/d(rho**2) * (aref**2*Bref/psitor_lcfs) = -1.0/rho drhodpsi = dxdXcoord_sign * sign_torflux / geo_surf % rhotor drhodpsi_psi0 = drhodpsi bmag_psi0 = bmag !> abs(twist_and_shift_geo_fac) is dkx/dky * jtwist !> minus its sign gives the direction of the shift in kx !> to be used for twist-and-shift BC allocate ( twist_and_shift_geo_fac_full ( nalpha , - nzgrid : nzgrid )) grad_x_grad_y_end = grad_alpha_grad_psi ( 1 , nzgrid ) * ( aref * aref * bref ) select case ( twist_shift_option_switch ) case ( twist_shift_option_std ) ! to be used for std twist-and-shift BC ! twist_and_shift_geo_fac = ! -2.*pi*geo_surf%shat*geo_surf%qinp*drhodpsi*dydalpha/(dxdpsi*geo_surf%rhotor) write ( * , * ) 'Standard twist and shift BC selected' twist_and_shift_geo_fac_full = - 2. * pi * geo_surf % shat * drhodpsi * dydalpha / ( geo_surf % qinp * dxdXcoord * geo_surf % rhotor ) & * field_period_ratio if ( abs ( geo_surf % shat ) <= shat_zero ) & write ( * , * ) 'Using periodic boundary conditions as shat < shat_zero' write ( * , * ) case ( twist_shift_option_stellarator ) !to be used for stellarator symmetric twist-and-shift BC !twist_and_shift_geo_fac = -nabla x. nabla y /|nabla x|&#94;2 write ( * , * ) 'Stellarator symmetric twist and shift BC selected' twist_and_shift_geo_fac_full = - 4 * ( geo_surf % rhotor * geo_surf % rhotor * geo_surf % psitor_lcfs ) & * ( grad_alpha_grad_psi ) / ( grad_psi_grad_psi * aref * aref * bref ) * field_period_ratio if ( abs ( grad_x_grad_y_end ) <= grad_x_grad_y_zero ) & write ( * , * ) 'Using periodic boundary conditions as grad_x_grad_y_end < grad_x_grad_y_zero' write ( * , * ) end select twist_and_shift_geo_fac = twist_and_shift_geo_fac_full ( 1 , nzgrid ) deallocate ( twist_and_shift_geo_fac_full ) !> grad_x = | grad x | grad_x = sqrt ( abs ( grad_psi_grad_psi * dxdXcoord ** 2 )) !> gds2 = |grad y|&#94;2 = |grad alpha|&#94;2 * (dy/dalpha)&#94;2 !> note that rhotor = sqrt(psi/psi_LCFS) gds2 = grad_alpha_grad_alpha * dydalpha ** 2 !> gds21 = shat * grad x . grad y = shat * dx/dpsi_t * dy/dalpha * grad alpha . grad psi_t !> NB: psi = -psi_t and so dx/dpsi = = dx/dpsi_t, which is why there is a minus sign here gds21 = - grad_alpha_grad_psi * geo_surf % shat * dxdXcoord * dydalpha !> gds22 = shat&#94;2 * |grad x|&#94;2 = shat&#94;2 * |grad psi_t|&#94;2 * (dx/dpsi_t)&#94;2 gds22 = ( geo_surf % shat * grad_x ) ** 2 !gds22 = geo_surf%shat**2 * grad_psi_grad_psi * dxdXcoord**2 !> gbdrift_alpha and cvdrift_alpha contain !> the grad-B and curvature drifts projected onto !> the grad alpha direction !> need the projections on grad y gbdrift = gbdrift_alpha * dydalpha cvdrift = cvdrift_alpha * dydalpha !> gbdrift0_psi and cvdrift0_psi contain !> the grad-B and curvature drifts projected onto !> the grad psi direction !> need the projections on grad x gbdrift0 = gbdrift0_psi * dxdXcoord cvdrift0 = cvdrift0_psi * dxdXcoord call deallocate_temporary_arrays !> can test FFS implementation by setting all geometric coefficients !> to their values at a given alpha; i.e., make the system axisymmetric if ( const_alpha_geo ) call set_ffs_geo_coefs_constant ( nalpha ) end select if ( overwrite_geometry ) call overwrite_selected_geometric_coefficients ( nalpha ) ! exb_nonlin_fac is equivalent to kxfac/2 in gs2 if ( q_as_x ) then dqdrho = geo_surf % shat * geo_surf % qinp / geo_surf % rhoc exb_nonlin_fac = 0.5 * dxdXcoord * dydalpha * drhodpsi * dqdrho !the following will get multiplied by exb_nonlin_fac in advance_exb_nonlinearity exb_nonlin_fac_p = geo_surf % d2qdr2 / dqdrho - geo_surf % d2psidr2 * drhodpsi else exb_nonlin_fac = 0.5 * dxdXcoord * dydalpha exb_nonlin_fac_p = 0.0 end if end if if (. not . proc0 ) call allocate_arrays ( nalpha , nzgrid ) if ( debug . and . proc0 ) write ( * , * ) 'init_geometry::broadcast_arrays' call broadcast_arrays gfac = 1.0 if (. not . include_geometric_variation ) gfac = 0.0 ! should reduce to 2*pi*shat in axisymmetric case ! but not in non-axisymmetric case !    twist_and_shift_geo_fac = geo_surf%shat*(gds21(1,-nzgrid)/gds22(1,-nzgrid)-gds21(1,nzgrid)/gds22(1,nzgrid)) ! FLAG DSO - the followiing assumes a linear relation from q to rho, but this will !            not be correct if d2qdrho != 0 dqdrho = geo_surf % shat * geo_surf % qinp / geo_surf % rhoc ! this old definition of jacob should have been fine, as it was only ever used in both the numerator ! and denominator of averages -- and do any constant factors cancelled out !jacob = 1.0/abs(drhodpsi*spread(gradpar,1,nalpha)*bmag) !> jacob is the Jacobian from Cartesian coordinates to (y,x,z) coordinates !> is ((grad y x grad x) . grad z)&#94;(-1) = Lref*(dalpha/dy)*(dpsi/dx)/(Lref*Bref)*(B/Bref . grad z)&#94;(-1) !> Lref*(dalpha/dy) = 1/dydalpha; (dpsi/dx)/(Lref*Bref) = 1 / dxdXcoord ; (B/Bref . grad z) = gradpar*bmag jacob = 1.0 / ( dydalpha * dxdXcoord * b_dot_grad_z * bmag ) !    jacob = 1.0/(dydalpha*dxdXcoord*spread(gradpar,1,nalpha)*bmag) ! this is dl/B dl_over_b = spread ( delzed , 1 , nalpha ) * jacob ! the next line is to avoid double counting the end points for ky = 0 modes (which leads to destabilization ! of the zonal modes for certain input parameters) ! FLAG DSO - while this is correct for ky = 0 modes and sufficient for output, if dl_over_b is applied to ! non-zero ky modes, a more sophisticated approach will be required that takes into account the sign of ! v_parallel dl_over_b (:, nzgrid ) = 0. ! this is the correction to flux-surface-averaging for adiabatic electrons d_dl_over_b_drho = spread ( delzed , 1 , nalpha ) * djacdrho d_dl_over_b_drho (:, nzgrid ) = 0 d_dl_over_b_drho = d_dl_over_b_drho - dl_over_b & * spread ( sum ( d_dl_over_b_drho , dim = 2 ) / sum ( dl_over_b , dim = 2 ), 2 , 2 * nzgrid + 1 ) d_dl_over_b_drho = gfac * d_dl_over_b_drho / spread ( sum ( dl_over_b , dim = 2 ), 2 , 2 * nzgrid + 1 ) ! normalize dl/B by int dl/B dl_over_b = dl_over_b / spread ( sum ( dl_over_b , dim = 2 ), 2 , 2 * nzgrid + 1 ) ! this is what we use to normalize the fluxes grho_norm = sum ( dl_over_b ( 1 , :) * grho ( 1 , :)) ! would probably be better to compute this in the various ! geometry subroutine (Miller, vmec, etc.), as there ! B is likely calculated on a finer z-grid do iy = 1 , nalpha call get_dzed ( nzgrid , delzed , bmag ( iy , :), dbdzed ( iy , :)) end do ! if magnetic shear almost zero, override parallel ! boundary condition so that it is periodic if ( abs ( geo_surf % shat ) <= shat_zero ) & boundary_option_switch = boundary_option_self_periodic if ( vmec_chosen ) then select case ( twist_shift_option_switch ) case ( twist_shift_option_std ) ! if magnetic shear almost zero, override parallel ! boundary condition so that it is periodic if using the standard ! twist and shift bc, in which kx_shift is proportional to shat if ( abs ( geo_surf % shat ) <= shat_zero ) & twist_shift_option_switch = twist_shift_option_periodic case ( twist_shift_option_stellarator ) ! if magnetic nabla x. nabla y is almost zero, override parallel ! boundary condition so that it is periodic if using the stellarator ! symmetric twist and shift bc, in which kx_shift is proportional to nabla ! x. nabla y if ( abs ( grad_x_grad_y_end ) <= grad_x_grad_y_zero ) & twist_shift_option_switch = twist_shift_option_periodic end select end if ! theta_eqarc is parallel coordinate such that ! b . grad theta_eqarc = constant ! and theta_eqarc = theta at +/- pi ! b . grad theta_eqarc = b . grad theta dtheta_eqarc/dtheta ! --> dtheta_eqarc/dtheta = b . grad theta_eqarc / b . grad theta ! --> 2*pi = b . grad theta_eqarc * int_0&#94;{2pi} dtheta 1/(b.grad theta) ! this gives b . grad theta_eqarc, from which we get ! theta_eqarc = theta_min + int_{0}&#94;{theta} dtheta' b . grad theta_eqarc / b . grad theta' call get_gradpar_eqarc ( gradpar , zed , delzed , gradpar_eqarc ) call get_zed_eqarc ( gradpar , delzed , zed , gradpar_eqarc , zed_eqarc ) if ( proc0 ) call write_geometric_coefficients ( nalpha ) ! AVB: temporary, set bmag = constant in z for Spitzer problem if ( set_bmag_const ) then bmag_z0 = bmag ( 1 , 0 ) print * , '' print * , '! SETTING BMAG = CONSTANT IN Z' print * , '' do ia = 1 , nalpha do iz = - nzgrid , nzgrid bmag ( ia , iz ) = bmag_z0 end do end do end if contains subroutine allocate_temporary_arrays ( nalpha , nzgrid ) implicit none integer , intent ( in ) :: nalpha , nzgrid allocate ( grad_alpha_grad_alpha ( nalpha , - nzgrid : nzgrid )) allocate ( grad_alpha_grad_psi ( nalpha , - nzgrid : nzgrid )) allocate ( grad_psi_grad_psi ( nalpha , - nzgrid : nzgrid )) allocate ( gbdrift_alpha ( nalpha , - nzgrid : nzgrid )) allocate ( cvdrift_alpha ( nalpha , - nzgrid : nzgrid )) allocate ( gbdrift0_psi ( nalpha , - nzgrid : nzgrid )) allocate ( cvdrift0_psi ( nalpha , - nzgrid : nzgrid )) end subroutine allocate_temporary_arrays subroutine deallocate_temporary_arrays implicit none deallocate ( grad_alpha_grad_alpha ) deallocate ( grad_alpha_grad_psi ) deallocate ( grad_psi_grad_psi ) deallocate ( gbdrift_alpha ) deallocate ( cvdrift_alpha ) deallocate ( gbdrift0_psi ) deallocate ( cvdrift0_psi ) end subroutine deallocate_temporary_arrays subroutine overwrite_selected_geometric_coefficients ( nalpha ) use file_utils , only : get_unused_unit use zgrid , only : nzgrid implicit none integer , intent ( in ) :: nalpha integer :: geofile_unit character ( 100 ) :: dum_char real :: dum_real integer :: ia , iz real :: bmag_file , gradpar_file real :: gds2_file , gds21_file , gds22_file , gds23_file , gds24_file real :: gbdrift_file , cvdrift_file , gbdrift0_file call get_unused_unit ( geofile_unit ) open ( geofile_unit , file = trim ( geo_file ), status = 'old' , action = 'read' ) read ( geofile_unit , fmt =* ) dum_char read ( geofile_unit , fmt =* ) dum_char read ( geofile_unit , fmt =* ) dum_char ! overwrite bmag, gradpar, gds2, gds21, gds22, gds23, gds24, gbdrift, cvdrift, gbdrift0, and cvdrift0 ! with values from file do ia = 1 , nalpha do iz = - nzgrid , nzgrid read ( geofile_unit , fmt = '(13e12.4)' ) dum_real , dum_real , dum_real , bmag_file , gradpar_file , & gds2_file , gds21_file , gds22_file , gds23_file , & gds24_file , gbdrift_file , cvdrift_file , gbdrift0_file if ( overwrite_bmag ) bmag ( ia , iz ) = bmag_file if ( overwrite_gradpar ) gradpar ( iz ) = gradpar_file if ( overwrite_gds2 ) gds2 ( ia , iz ) = gds2_file if ( overwrite_gds21 ) gds21 ( ia , iz ) = gds21_file if ( overwrite_gds22 ) gds22 ( ia , iz ) = gds22_file if ( overwrite_gds23 ) gds23 ( ia , iz ) = gds23_file if ( overwrite_gds24 ) gds24 ( ia , iz ) = gds24_file if ( overwrite_gbdrift ) gbdrift ( ia , iz ) = gbdrift_file if ( overwrite_cvdrift ) cvdrift ( ia , iz ) = cvdrift_file if ( overwrite_gbdrift0 ) gbdrift0 ( ia , iz ) = gbdrift0_file end do end do cvdrift0 = gbdrift0 close ( geofile_unit ) end subroutine overwrite_selected_geometric_coefficients subroutine set_ffs_geo_coefs_constant ( nalpha ) implicit none integer , intent ( in ) :: nalpha call set_coef_constant ( gbdrift0 , nalpha ) call set_coef_constant ( cvdrift0 , nalpha ) call set_coef_constant ( gbdrift , nalpha ) call set_coef_constant ( cvdrift , nalpha ) call set_coef_constant ( grad_x , nalpha ) call set_coef_constant ( grho , nalpha ) call set_coef_constant ( bmag , nalpha ) call set_coef_constant ( bmag_psi0 , nalpha ) call set_coef_constant ( gds2 , nalpha ) call set_coef_constant ( gds21 , nalpha ) call set_coef_constant ( gds22 , nalpha ) call set_coef_constant ( gds23 , nalpha ) call set_coef_constant ( gds24 , nalpha ) call set_coef_constant ( gds25 , nalpha ) call set_coef_constant ( gds26 , nalpha ) call set_coef_constant ( theta_vmec , nalpha ) call set_coef_constant ( x_displacement_fac , nalpha ) call set_coef_constant ( zeta , nalpha ) call set_coef_constant ( b_dot_grad_z , nalpha ) ! following coefficients calculated later using above coefficients !      call set_coef_constant (dbdzed, nalpha) !      call set_coef_constant (jacob, nalpha) !      call set_coef_constant (dl_over_b, nalpha) end subroutine set_ffs_geo_coefs_constant subroutine set_coef_constant ( coef , nalpha ) implicit none real , dimension (:, - nzgrid :), intent ( in out ) :: coef integer , intent ( in ) :: nalpha coef = spread ( coef ( 1 , :), 1 , nalpha ) end subroutine set_coef_constant end subroutine init_geometry subroutine allocate_arrays ( nalpha , nzgrid ) implicit none integer , intent ( in ) :: nalpha , nzgrid if (. not . allocated ( bmag )) allocate ( bmag ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( bmag_psi0 )) allocate ( bmag_psi0 ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( gds2 )) allocate ( gds2 ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( gds21 )) allocate ( gds21 ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( gds22 )) allocate ( gds22 ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( gds23 )) allocate ( gds23 ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( gds24 )) allocate ( gds24 ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( gds25 )) allocate ( gds25 ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( gds26 )) allocate ( gds26 ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( dgds2dr )) allocate ( dgds2dr ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( dgds21dr )) allocate ( dgds21dr ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( dgds22dr )) allocate ( dgds22dr ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( gbdrift )) allocate ( gbdrift ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( gbdrift0 )) allocate ( gbdrift0 ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( cvdrift )) allocate ( cvdrift ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( cvdrift0 )) allocate ( cvdrift0 ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( dgbdriftdrho )) allocate ( dgbdriftdrho ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( dcvdriftdrho )) allocate ( dcvdriftdrho ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( dgbdrift0drho )) allocate ( dgbdrift0drho ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( dcvdrift0drho )) allocate ( dcvdrift0drho ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( dbdzed )) allocate ( dbdzed ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( theta_vmec )) allocate ( theta_vmec ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( jacob )) allocate ( jacob ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( djacdrho )) allocate ( djacdrho ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( grho )) allocate ( grho ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( grad_x )) allocate ( grad_x ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( dl_over_b )) allocate ( dl_over_b ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( d_dl_over_b_drho )) allocate ( d_dl_over_b_drho ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( b_dot_grad_z )) allocate ( b_dot_grad_z ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( gradpar )) allocate ( gradpar ( - nzgrid : nzgrid )) if (. not . allocated ( zed_eqarc )) allocate ( zed_eqarc ( - nzgrid : nzgrid )) if (. not . allocated ( btor )) allocate ( btor ( - nzgrid : nzgrid )) if (. not . allocated ( rmajor )) allocate ( rmajor ( - nzgrid : nzgrid )) if (. not . allocated ( dBdrho )) allocate ( dBdrho ( - nzgrid : nzgrid )) if (. not . allocated ( d2Bdrdth )) allocate ( d2Bdrdth ( - nzgrid : nzgrid )) if (. not . allocated ( dgradpardrho )) allocate ( dgradpardrho ( - nzgrid : nzgrid )) if (. not . allocated ( alpha )) allocate ( alpha ( nalpha )); alpha = 0. if (. not . allocated ( zeta )) allocate ( zeta ( nalpha , - nzgrid : nzgrid )); zeta = 0. if (. not . allocated ( x_displacement_fac )) allocate ( x_displacement_fac ( nalpha , - nzgrid : nzgrid )); x_displacement_fac = 0. end subroutine allocate_arrays subroutine read_parameters use text_options use file_utils , only : error_unit , input_unit_exist use file_utils , only : runtype_option_Switch , runtype_multibox use mp , only : job use physics_flags , only : radial_variation implicit none integer :: in_file , ierr logical :: exist character ( 20 ) :: geo_option type ( text_option ), dimension ( 5 ), parameter :: geoopts = ( / & text_option ( 'default' , geo_option_local ), & text_option ( 'miller' , geo_option_local ), & text_option ( 'local' , geo_option_local ), & text_option ( 'input.profiles' , geo_option_inputprof ), & text_option ( 'vmec' , geo_option_vmec ) / ) namelist / geo_knobs / geo_option , geo_file , overwrite_bmag , overwrite_gradpar , & overwrite_gds2 , overwrite_gds21 , overwrite_gds22 , overwrite_gds23 , overwrite_gds24 , & overwrite_gbdrift , overwrite_cvdrift , overwrite_gbdrift0 , q_as_x , set_bmag_const geo_option = 'local' overwrite_bmag = . false . overwrite_gradpar = . false . overwrite_gds2 = . false . overwrite_gds21 = . false . overwrite_gds22 = . false . overwrite_gds23 = . false . overwrite_gds24 = . false . overwrite_gbdrift = . false . overwrite_cvdrift = . false . overwrite_gbdrift0 = . false . set_bmag_const = . false . q_as_x = radial_variation !true by default in radial variation runs geo_file = 'input.geometry' in_file = input_unit_exist ( \"geo_knobs\" , exist ) if ( exist ) read ( unit = in_file , nml = geo_knobs ) ierr = error_unit () call get_option_value & ( geo_option , geoopts , geo_option_switch , & ierr , \"geo_option in geo_knobs\" ) if ( radial_variation . and . runtype_option_switch == runtype_multibox . and . job /= 1 ) then geo_option_switch = geo_option_multibox end if overwrite_geometry = overwrite_bmag . or . overwrite_gradpar & . or . overwrite_gds2 . or . overwrite_gds21 . or . overwrite_gds22 & . or . overwrite_gds23 . or . overwrite_gds24 & . or . overwrite_cvdrift . or . overwrite_gbdrift . or . overwrite_gbdrift0 end subroutine read_parameters subroutine broadcast_arrays use mp , only : broadcast implicit none call broadcast ( qinp ) call broadcast ( shat ) call broadcast ( drhodpsi ) call broadcast ( drhodpsi_psi0 ) call broadcast ( exb_nonlin_fac ) call broadcast ( exb_nonlin_fac_p ) call broadcast ( dIdrho ) call broadcast ( grho ) call broadcast ( grad_x ) call broadcast ( bmag ) call broadcast ( bmag_psi0 ) call broadcast ( btor ) call broadcast ( rmajor ) call broadcast ( gradpar ) call broadcast ( b_dot_grad_z ) call broadcast ( gds2 ) call broadcast ( gds21 ) call broadcast ( gds22 ) call broadcast ( gds23 ) call broadcast ( gds24 ) call broadcast ( gds25 ) call broadcast ( gds26 ) call broadcast ( dgds2dr ) call broadcast ( dgds21dr ) call broadcast ( dgds22dr ) call broadcast ( gbdrift0 ) call broadcast ( gbdrift ) call broadcast ( cvdrift0 ) call broadcast ( cvdrift ) call broadcast ( dgbdrift0drho ) call broadcast ( dgbdriftdrho ) call broadcast ( dcvdrift0drho ) call broadcast ( dcvdriftdrho ) call broadcast ( dBdrho ) call broadcast ( d2Bdrdth ) call broadcast ( dgradpardrho ) call broadcast ( djacdrho ) call broadcast ( geo_surf % rmaj ) call broadcast ( geo_surf % rgeo ) call broadcast ( geo_surf % kappa ) call broadcast ( geo_surf % kapprim ) call broadcast ( geo_surf % tri ) call broadcast ( geo_surf % triprim ) call broadcast ( geo_surf % rhoc ) call broadcast ( geo_surf % rhoc_psi0 ) call broadcast ( geo_surf % dr ) call broadcast ( geo_surf % shift ) call broadcast ( geo_surf % qinp ) call broadcast ( geo_surf % qinp_psi0 ) call broadcast ( geo_surf % shat ) call broadcast ( geo_surf % shat_psi0 ) call broadcast ( geo_surf % betaprim ) call broadcast ( geo_surf % betadbprim ) call broadcast ( geo_surf % d2qdr2 ) call broadcast ( geo_surf % d2psidr2 ) call broadcast ( geo_surf % dpsitordrho ) call broadcast ( geo_surf % rhotor ) call broadcast ( geo_surf % psitor_lcfs ) call broadcast ( geo_surf % drhotordrho ) call broadcast ( zed_scalefac ) call broadcast ( q_as_x ) call broadcast ( set_bmag_const ) call broadcast ( alpha ) call broadcast ( zeta ) call broadcast ( dxdXcoord ) call broadcast ( dydalpha ) call broadcast ( twist_and_shift_geo_fac ) call broadcast ( grad_x_grad_y_end ) call broadcast ( vmec_chosen ) call broadcast ( aref ) call broadcast ( bref ) end subroutine broadcast_arrays subroutine communicate_geo_multibox ( l_edge , r_edge ) use millerlocal , only : communicate_parameters_multibox use mp , only : proc0 implicit none real , intent ( in ) :: l_edge , r_edge if ( proc0 ) then call communicate_parameters_multibox ( geo_surf , gfac * l_edge , gfac * r_edge ) end if end subroutine communicate_geo_multibox ! given function f(z:-pi->pi), calculate z derivative ! second order accurate, with equal grid spacing assumed ! assumes periodic in z -- may need to change this in future subroutine get_dzed ( nz , dz , f , df ) implicit none integer , intent ( in ) :: nz real , dimension ( - nz :), intent ( in ) :: dz , f real , dimension ( - nz :), intent ( out ) :: df df ( - nz + 1 : nz - 1 ) = ( f ( - nz + 2 :) - f (: nz - 2 )) / ( dz (: nz - 2 ) + dz ( - nz + 1 : nz - 1 )) ! FLAG -- THIS MAY NEED TO BE CHANGED ! use periodicity at boundary df ( - nz ) = ( f ( - nz + 1 ) - f ( nz - 1 )) / ( dz ( - nz ) + dz ( nz - 1 )) df ( nz ) = df ( - nz ) end subroutine get_dzed subroutine get_gradpar_eqarc ( gp , z , dz , gp_eqarc ) use constants , only : pi use zgrid , only : nzgrid implicit none real , dimension ( - nzgrid :), intent ( in ) :: gp , z , dz real , intent ( out ) :: gp_eqarc ! first get int dz b . grad z call integrate_zed ( dz , 1. / gp , gp_eqarc ) ! then take (zmax-zmin)/int (dz b . gradz) ! to get b . grad z' gp_eqarc = ( z ( nzgrid ) - z ( - nzgrid )) / gp_eqarc end subroutine get_gradpar_eqarc subroutine get_zed_eqarc ( gp , dz , z , gp_eqarc , z_eqarc ) use zgrid , only : nzgrid implicit none real , dimension ( - nzgrid :), intent ( in ) :: gp , dz , z real , intent ( in ) :: gp_eqarc real , dimension ( - nzgrid :), intent ( out ) :: z_eqarc integer :: iz z_eqarc ( - nzgrid ) = z ( - nzgrid ) do iz = - nzgrid + 1 , nzgrid call integrate_zed ( dz (: iz ), 1. / gp (: iz ), z_eqarc ( iz )) end do z_eqarc ( - nzgrid + 1 :) = z ( - nzgrid ) + z_eqarc ( - nzgrid + 1 :) * gp_eqarc end subroutine get_zed_eqarc ! trapezoidal rule to integrate in zed subroutine integrate_zed ( dz , f , intf ) use zgrid , only : nzgrid implicit none real , dimension ( - nzgrid :), intent ( in ) :: dz real , dimension ( - nzgrid :), intent ( in ) :: f real , intent ( out ) :: intf integer :: iz , iz_max iz_max = - nzgrid + size ( dz ) - 1 intf = 0. do iz = - nzgrid + 1 , iz_max intf = intf + dz ( iz ) * ( f ( iz - 1 ) + f ( iz )) end do intf = 0.5 * intf end subroutine integrate_zed subroutine get_x_to_rho ( llim , x_in , rho_out ) use physics_parameters , only : rhostar implicit none integer , intent ( in ) :: llim real , dimension (:), intent ( in ) :: x_in real , dimension (:), intent ( out ) :: rho_out integer :: ix , ulim real :: a , b , c ulim = size ( x_in ) + llim - 1 if ( q_as_x ) then a = 0.5 * geo_surf % d2qdr2 / dqdrho b = 1.0 c = - rhostar / ( dqdrho * dxdXcoord ) else a = 0.5 * geo_surf % d2psidr2 * drhodpsi b = 1.0 c = - rhostar * drhodpsi / dxdXcoord end if do ix = llim , ulim if ( abs ( 4.0 * a * c * x_in ( ix )) < 1.e-6 ) then rho_out ( ix ) = - ( c * x_in ( ix )) / b - a * ( c * x_in ( ix )) ** 2 / b ** 3 else rho_out ( ix ) = ( - b + sqrt ( b ** 2 - 4. * a * c * x_in ( ix ))) / ( 2. * a ) end if end do end subroutine get_x_to_rho subroutine write_geometric_coefficients ( nalpha ) use file_utils , only : open_output_file , close_output_file use zgrid , only : nzgrid , zed implicit none integer , intent ( in ) :: nalpha integer :: geometry_unit integer :: ia , iz call open_output_file ( geometry_unit , '.geometry' ) write ( geometry_unit , '(a1,11a14)' ) '#' , 'rhoc' , 'qinp' , 'shat' , 'rhotor' , 'aref' , 'bref' , 'dxdXcoord' , 'dydalpha' , & 'exb_nonlin' , 'exb_nonlin_p' write ( geometry_unit , '(a1,11e14.4)' ) '#' , geo_surf % rhoc , geo_surf % qinp , geo_surf % shat , geo_surf % rhotor , aref , bref , & dxdXcoord , dydalpha , exb_nonlin_fac , exb_nonlin_fac_p * exb_nonlin_fac write ( geometry_unit , * ) write ( geometry_unit , '(15a12)' ) '# alpha' , 'zed' , 'zeta' , 'bmag' , 'bdot_grad_z' , 'gds2' , 'gds21' , 'gds22' , & 'gds23' , 'gds24' , 'gbdrift' , 'cvdrift' , 'gbdrift0' , 'bmag_psi0' , 'btor' do ia = 1 , nalpha do iz = - nzgrid , nzgrid !          write (geometry_unit,'(15e12.4)') alpha(ia), zed(iz), zeta(ia,iz), bmag(ia,iz), gradpar(iz), & write ( geometry_unit , '(15e12.4)' ) alpha ( ia ), zed ( iz ), zeta ( ia , iz ), bmag ( ia , iz ), b_dot_grad_z ( ia , iz ), & gds2 ( ia , iz ), gds21 ( ia , iz ), gds22 ( ia , iz ), gds23 ( ia , iz ), & gds24 ( ia , iz ), gbdrift ( ia , iz ), cvdrift ( ia , iz ), gbdrift0 ( ia , iz ), & bmag_psi0 ( ia , iz ), btor ( iz ) end do write ( geometry_unit , * ) end do call close_output_file ( geometry_unit ) end subroutine write_geometric_coefficients subroutine finish_init_geometry use mp , only : proc0 use millerlocal , only : finish_local_geo implicit none if ( proc0 ) then select case ( geo_option_switch ) case ( geo_option_local ) call finish_local_geo case ( geo_option_multibox ) call finish_local_geo case ( geo_option_inputprof ) call finish_local_geo case ( geo_option_vmec ) end select end if end subroutine finish_init_geometry subroutine finish_geometry implicit none if ( allocated ( zed_eqarc )) deallocate ( zed_eqarc ) if ( allocated ( grho )) deallocate ( grho ) if ( allocated ( grad_x )) deallocate ( grad_x ) if ( allocated ( bmag )) deallocate ( bmag ) if ( allocated ( bmag_psi0 )) deallocate ( bmag_psi0 ) if ( allocated ( btor )) deallocate ( btor ) if ( allocated ( rmajor )) deallocate ( rmajor ) if ( allocated ( dbdzed )) deallocate ( dbdzed ) if ( allocated ( jacob )) deallocate ( jacob ) if ( allocated ( djacdrho )) deallocate ( djacdrho ) if ( allocated ( gradpar )) deallocate ( gradpar ) if ( allocated ( b_dot_grad_z )) deallocate ( b_dot_grad_z ) if ( allocated ( dl_over_b )) deallocate ( dl_over_b ) if ( allocated ( d_dl_over_b_drho )) deallocate ( d_dl_over_b_drho ) if ( allocated ( gds2 )) deallocate ( gds2 ) if ( allocated ( gds21 )) deallocate ( gds21 ) if ( allocated ( gds22 )) deallocate ( gds22 ) if ( allocated ( gds23 )) deallocate ( gds23 ) if ( allocated ( gds24 )) deallocate ( gds24 ) if ( allocated ( gds25 )) deallocate ( gds25 ) if ( allocated ( gds26 )) deallocate ( gds26 ) if ( allocated ( dgds2dr )) deallocate ( dgds2dr ) if ( allocated ( dgds21dr )) deallocate ( dgds21dr ) if ( allocated ( dgds22dr )) deallocate ( dgds22dr ) if ( allocated ( gbdrift )) deallocate ( gbdrift ) if ( allocated ( gbdrift0 )) deallocate ( gbdrift0 ) if ( allocated ( cvdrift )) deallocate ( cvdrift ) if ( allocated ( cvdrift0 )) deallocate ( cvdrift0 ) if ( allocated ( dgbdriftdrho )) deallocate ( dgbdriftdrho ) if ( allocated ( dcvdriftdrho )) deallocate ( dcvdriftdrho ) if ( allocated ( dgbdrift0drho )) deallocate ( dgbdrift0drho ) if ( allocated ( dcvdrift0drho )) deallocate ( dcvdrift0drho ) if ( allocated ( dBdrho )) deallocate ( dBdrho ) if ( allocated ( d2Bdrdth )) deallocate ( d2Bdrdth ) if ( allocated ( dgradpardrho )) deallocate ( dgradpardrho ) if ( allocated ( theta_vmec )) deallocate ( theta_vmec ) if ( allocated ( alpha )) deallocate ( alpha ) if ( allocated ( zeta )) deallocate ( zeta ) if ( allocated ( x_displacement_fac )) deallocate ( x_displacement_fac ) geoinit = . false . end subroutine finish_geometry end module stella_geometry","tags":"","loc":"sourcefile/stella_geometry.f90.html"},{"title":"inputprofiles_interface.f90 â€“ stella","text":"Contents Modules inputprofiles_interface Source Code inputprofiles_interface.f90 Source Code module inputprofiles_interface implicit none public :: read_inputprof_geo , read_inputprof_spec private integer :: n_exp real , dimension (:), allocatable :: rhotor , rmin , rmaj_in , qinp , kappa real , dimension (:), allocatable :: delta , Te , ne , z_eff , omega0 real , dimension (:), allocatable :: ni , Ti real , dimension (:), allocatable :: dr real , dimension (:), allocatable :: rhoc , rmaj , shift real , dimension (:), allocatable :: shat , d2qdr2 real , dimension (:), allocatable :: tri , triprim real , dimension (:), allocatable :: kapprim real , dimension (:), allocatable :: neprim , Teprim real , dimension (:), allocatable :: niprim , Tiprim real , dimension (:), allocatable :: nedbprim , Tedbprim real , dimension (:), allocatable :: nidbprim , Tidbprim real , dimension (:), allocatable :: betaprim , betadbprim real , dimension (:), allocatable :: psitor real , dimension (:), allocatable :: drhotordrho , dpsitordrho , d2psitordrho2 real , dimension (:), allocatable :: pres_tot real , dimension (:), allocatable :: loglam real :: bref , omega_ref , rho_ref real :: bunit contains subroutine read_inputprof_geo ( surf ) use constants , only : pi use common_types , only : flux_surface_type use finite_differences , only : fd3pt , d2_3pt use splines , only : geo_spline use millerlocal , only : local implicit none type ( flux_surface_type ), intent ( in out ) :: surf integer :: in_unit = 101 character ( 10 ) :: dum character ( 500 ) :: line real :: bt_exp real :: arho_exp real :: aref real :: mu0 integer :: ir open ( unit = in_unit , file = 'input.profiles' , status = 'old' , action = 'read' ) ! read in header and ignore read ( in_unit , * ) line read ( in_unit , * ) line read ( in_unit , * ) line read ( in_unit , * ) line read ( in_unit , * ) line read ( in_unit , * ) dum , n_exp read ( in_unit , * ) dum , bt_exp read ( in_unit , * ) dum , arho_exp call allocate_arrays_geo ! read in more headers read ( in_unit , * ) line read ( in_unit , * ) line do ir = 1 , n_exp read ( in_unit , * ) rhotor ( ir ), rmin ( ir ), rmaj_in ( ir ), qinp ( ir ), kappa ( ir ) end do ! aref is stella reference length (device minor radius) aref = rmin ( n_exp ) rhoc = rmin / aref rmaj = rmaj_in / aref ! read in more headers read ( in_unit , * ) line read ( in_unit , * ) line do ir = 1 , n_exp read ( in_unit , * ) delta ( ir ), Te ( ir ), ne ( ir ), line end do ! stella redefines delat to be ArcSin(delta_miller) tri = asin ( delta ) ! read in more headers read ( in_unit , * ) line read ( in_unit , * ) line ! read in some stuff we don't need to use at the moment do ir = 1 , n_exp read ( in_unit , * ) line end do ! read in more headers read ( in_unit , * ) line read ( in_unit , * ) line ! read in some stuff we don't need to use at the moment do ir = 1 , n_exp read ( in_unit , * ) line end do ! read in more headers read ( in_unit , * ) line read ( in_unit , * ) line do ir = 1 , n_exp read ( in_unit , * ) ni ( ir ), line end do ! read in more headers read ( in_unit , * ) line read ( in_unit , * ) line do ir = 1 , n_exp read ( in_unit , * ) Ti ( ir ), line end do close ( in_unit ) dr = rhoc ( 2 :) - rhoc (: n_exp - 1 ) ! obtain s_hat call fd3pt ( qinp , shat , dr ) shat = rhoc * shat / qinp ! obtain d2q/dr2 call d2_3pt ( qinp , d2qdr2 , dr ) ! obtain d (kappa) / drho call fd3pt ( kappa , kapprim , dr ) ! obtain d (ArcSin(delta_miller)) / drho call fd3pt ( tri , triprim , dr ) ! obtain dR/drho call fd3pt ( rmaj , shift , dr ) pres_tot = ne * Te + ni * Ti call fd3pt ( pres_tot , betaprim , dr ) call d2_3pt ( pres_tot , betadbprim , dr ) mu0 = 4. * pi * 1.e-7 betaprim = - mu0 * betaprim * 1.6022e3 / bt_exp ** 2 betadbprim = - mu0 * betadbprim * 1.6022e3 / bt_exp ** 2 ! this is psi_toroidal/(Bref aref**2)/2pi ! assumption here is that Bref = BT_EXP psitor = 0.5 * rhotor * rhotor * ( arho_exp / aref ) ** 2 ! get drhotordr call fd3pt ( rhotor , drhotordrho , dr ) call fd3pt ( psitor , dpsitordrho , dr ) call d2_3pt ( psitor , d2psitordrho2 , dr ) ! this sets the reference B-field to be bt_exp !    dpsitordrho = rhotor*drhotordrho*(arho_exp/aref)**2 ! next need to pick out the correct flux surface ! and assign various local% values call geo_spline ( rhoc , rmaj , local % rhoc , local % rmaj ) call geo_spline ( rhoc , dpsitordrho , local % rhoc , local % dpsitordrho ) call geo_spline ( rhoc , d2psitordrho2 , local % rhoc , local % d2psitordrho2 ) call geo_spline ( rhoc , shift , local % rhoc , local % shift ) call geo_spline ( rhoc , kappa , local % rhoc , local % kappa ) call geo_spline ( rhoc , kapprim , local % rhoc , local % kapprim ) call geo_spline ( rhoc , qinp , local % rhoc , local % qinp ) call geo_spline ( rhoc , shat , local % rhoc , local % shat ) call geo_spline ( rhoc , d2qdr2 , local % rhoc , local % d2qdr2 ) call geo_spline ( rhoc , tri , local % rhoc , local % tri ) call geo_spline ( rhoc , triprim , local % rhoc , local % triprim ) call geo_spline ( rhoc , betaprim , local % rhoc , local % betaprim ) call geo_spline ( rhoc , betadbprim , local % rhoc , local % betadbprim ) call geo_spline ( rhoc , rhotor , local % rhoc , local % rhotor ) call geo_spline ( rhoc , drhotordrho , local % rhoc , local % drhotordrho ) local % psitor_lcfs = psitor ( n_exp ) local % zed0_fac = 1.0 surf = local call deallocate_arrays_geo end subroutine read_inputprof_geo subroutine read_inputprof_spec ( nspec , spec ) use mp , only : mp_abort use finite_differences , only : fd3pt , d2_3pt use splines , only : geo_spline use common_types , only : spec_type use millerlocal , only : local use physics_parameters , only : vnew_ref , rhostar implicit none integer , intent ( in ) :: nspec type ( spec_type ), dimension (:), intent ( in out ) :: spec integer , parameter :: electron_species = 2 integer :: in_unit = 102 character ( 10 ) :: dum character ( 500 ) :: line real :: bt_exp real :: arho_exp real :: aref real :: mref , nref , tref real :: vtref , local_loglam integer :: ir , is open ( unit = in_unit , file = 'input.profiles' , status = 'old' , action = 'read' ) ! read in header and ignore read ( in_unit , * ) line read ( in_unit , * ) line read ( in_unit , * ) line read ( in_unit , * ) line read ( in_unit , * ) line read ( in_unit , * ) dum , n_exp read ( in_unit , * ) dum , bt_exp read ( in_unit , * ) dum , arho_exp call allocate_arrays_spec ! read in more headers read ( in_unit , * ) line read ( in_unit , * ) line do ir = 1 , n_exp read ( in_unit , * ) rhotor ( ir ), rmin ( ir ), line end do ! aref is stella reference length (device minor radius) aref = rmin ( n_exp ) rhoc = rmin / aref ! read in more headers read ( in_unit , * ) line read ( in_unit , * ) line do ir = 1 , n_exp read ( in_unit , * ) dum , Te ( ir ), ne ( ir ), z_eff ( ir ), omega0 ( ir ) end do ! read in more headers read ( in_unit , * ) line read ( in_unit , * ) line ! read in some stuff we don't need to use at the moment do ir = 1 , n_exp read ( in_unit , * ) line end do ! read in more headers read ( in_unit , * ) line read ( in_unit , * ) line ! read in some stuff we don't need to use at the moment do ir = 1 , n_exp read ( in_unit , * ) line end do ! read in more headers read ( in_unit , * ) line read ( in_unit , * ) line do ir = 1 , n_exp read ( in_unit , * ) ni ( ir ), line end do ! read in more headers read ( in_unit , * ) line read ( in_unit , * ) line do ir = 1 , n_exp read ( in_unit , * ) Ti ( ir ), line end do close ( in_unit ) dr = rhoc ( 2 :) - rhoc (: n_exp - 1 ) ! obtain -d ln(ne) / drho call fd3pt ( ne , neprim , dr ) call d2_3pt ( ne , nedbprim , dr ) neprim = - neprim / ne nedbprim = nedbprim / ne ! obtain -d ln(Te) / drho call fd3pt ( Te , Teprim , dr ) call d2_3pt ( Te , Tedbprim , dr ) Teprim = - Teprim / Te Tedbprim = Tedbprim / Te ! obtain -d ln(ni) / drho call fd3pt ( ni , niprim , dr ) call d2_3pt ( ni , nidbprim , dr ) niprim = - niprim / ni nidbprim = nidbprim / ni ! obtain -d ln(Ti) / drho call fd3pt ( Ti , Tiprim , dr ) call d2_3pt ( Ti , Tidbprim , dr ) Tiprim = - Tiprim / Ti Tidbprim = Tidbprim / Ti ! next need to pick out the correct flux surface ! and assign various local% values ! choose first species as reference species is = 1 spec ( is )% dens = 1.0 spec ( is )% temp = 1.0 ! get reference density and temperature if ( spec ( is )% type == electron_species ) then call geo_spline ( rhoc , Te , local % rhoc , tref ) call geo_spline ( rhoc , ne , local % rhoc , nref ) ! only needed for collisions -- reference mass in units of proton mass ! and is only included for clarity -- factors of mref cancel in the end mref = 5.44625e-4 else call geo_spline ( rhoc , Ti , local % rhoc , tref ) call geo_spline ( rhoc , ni , local % rhoc , nref ) ! only needed for collisions -- reference mass in units of proton mass ! and is only included for clarity -- factors of mref cancel in the end mref = 2.0 end if ! next get the normalized density and temperature for all other species if ( nspec == 2 ) then do is = 2 , nspec if ( spec ( is )% type == electron_species ) then call geo_spline ( rhoc , Te / tref , local % rhoc , spec ( is )% temp ) call geo_spline ( rhoc , ne / nref , local % rhoc , spec ( is )% dens ) else call geo_spline ( rhoc , Ti / tref , local % rhoc , spec ( is )% temp ) call geo_spline ( rhoc , ni / tref , local % rhoc , spec ( is )% dens ) end if end do else if ( nspec > 2 ) then call mp_abort ( 'multiple ion species not currently supported for input.profiles. aborting.' ) end if ! now get the density and temperature gradients at the requested flux surface do is = 1 , nspec if ( spec ( is )% type == electron_species ) then call geo_spline ( rhoc , Teprim , local % rhoc , spec ( is )% tprim ) call geo_spline ( rhoc , Tedbprim , local % rhoc , spec ( is )% d2Tdr2 ) call geo_spline ( rhoc , neprim , local % rhoc , spec ( is )% fprim ) call geo_spline ( rhoc , nedbprim , local % rhoc , spec ( is )% d2ndr2 ) else call geo_spline ( rhoc , Tiprim , local % rhoc , spec ( is )% tprim ) call geo_spline ( rhoc , Tidbprim , local % rhoc , spec ( is )% d2Tdr2 ) call geo_spline ( rhoc , niprim , local % rhoc , spec ( is )% fprim ) call geo_spline ( rhoc , nidbprim , local % rhoc , spec ( is )% d2ndr2 ) end if end do ! get collisionalities for stella loglam = 2 4.0 - log ( 1e4 * sqrt ( 0.1 * ne ) / te ) call geo_spline ( rhoc , loglam , local % rhoc , local_loglam ) ! vtref = sqrt(2*Tref/mref), with Tref and mref in SI units ! so vtref has dimensions of meters / second ! note that tref below is T in units of keV and mref is in units of proton mass vtref = 3.09497e5 * sqrt ( 2. * tref / mref ) ! reference collision frequency for stella ! uses the mass, density and temperature of the reference species, ! along with the proton charge in the expression ! vnew_ref = (aref/vtref)*(4/3)sqrt(2pi)/(4pi*epsilon_0)**2 * nref * e**4 * loglam / sqrt(mref) / Tref**1.5 ! note that all quantities are given in SI units and epsilon_0 is permittivity of vacuum vnew_ref = 2 8.5134 * ( aref / vtref ) * local_loglam * nref / ( sqrt ( mref ) * tref ** 1.5 ) bref = bt_exp omega_ref = 9.5791e7 * bref / mref rho_ref = vtref / omega_ref rhostar = rho_ref / aref ! I think this is incorrect -- MAB bunit = ( bref * arho_exp ** 2 ) / ( local % rhotor / aref / local % rhoc ) * local % drhotordrho !    vnewki = 9.21e-5*aref*zi**4/sqrt(2.)*loglam*ni/ti**2 !    vnewke = 3.95e-3*aref*zi**2*sqrt(0.5*mi)*loglam*ne & !         /(sqrt(ti)*te**1.5) call deallocate_arrays_spec end subroutine read_inputprof_spec subroutine allocate_arrays_geo implicit none allocate ( rhotor ( n_exp )) allocate ( psitor ( n_exp )) allocate ( rmin ( n_exp )) allocate ( rmaj_in ( n_exp )) allocate ( qinp ( n_exp )) allocate ( kappa ( n_exp )) allocate ( rhoc ( n_exp )) allocate ( rmaj ( n_exp )) allocate ( delta ( n_exp )) allocate ( tri ( n_exp )) allocate ( ne ( n_exp )) allocate ( Te ( n_exp )) allocate ( ni ( n_exp )) allocate ( Ti ( n_exp )) allocate ( dr ( n_exp - 1 )) allocate ( shat ( n_exp )) allocate ( d2qdr2 ( n_exp )) allocate ( kapprim ( n_exp )) allocate ( triprim ( n_exp )) allocate ( shift ( n_exp )) allocate ( betaprim ( n_exp )) allocate ( betadbprim ( n_exp )) allocate ( pres_tot ( n_exp )) allocate ( drhotordrho ( n_exp )) allocate ( dpsitordrho ( n_exp )) allocate ( d2psitordrho2 ( n_exp )) end subroutine allocate_arrays_geo subroutine allocate_arrays_spec implicit none allocate ( rhotor ( n_exp )) allocate ( rmin ( n_exp )) allocate ( rhoc ( n_exp )) allocate ( Te ( n_exp )) allocate ( ne ( n_exp )) allocate ( z_eff ( n_exp )) allocate ( omega0 ( n_exp )) allocate ( ni ( n_exp )) allocate ( Ti ( n_exp )) allocate ( dr ( n_exp - 1 )) allocate ( neprim ( n_exp )) allocate ( nedbprim ( n_exp )) allocate ( Teprim ( n_exp )) allocate ( Tedbprim ( n_exp )) allocate ( niprim ( n_exp )) allocate ( nidbprim ( n_exp )) allocate ( Tiprim ( n_exp )) allocate ( Tidbprim ( n_exp )) allocate ( loglam ( n_exp )) !    allocate (vnewki(n_exp)) !    allocate (vnewke(n_exp)) end subroutine allocate_arrays_spec subroutine deallocate_arrays_geo implicit none deallocate ( rhotor ) deallocate ( rmin ) deallocate ( rmaj_in ) deallocate ( rmaj ) deallocate ( qinp ) deallocate ( kappa ) deallocate ( rhoc ) deallocate ( delta ) deallocate ( Te ) deallocate ( ne ) deallocate ( tri ) deallocate ( ni ) deallocate ( Ti ) deallocate ( dr ) deallocate ( shat ) deallocate ( d2qdr2 ) deallocate ( kapprim ) deallocate ( triprim ) deallocate ( shift ) deallocate ( betaprim ) deallocate ( betadbprim ) deallocate ( pres_tot ) deallocate ( drhotordrho ) deallocate ( dpsitordrho ) deallocate ( d2psitordrho2 ) end subroutine deallocate_arrays_geo subroutine deallocate_arrays_spec implicit none deallocate ( rhotor ) deallocate ( rmin ) deallocate ( rhoc ) deallocate ( Te ) deallocate ( ne ) deallocate ( z_eff ) deallocate ( omega0 ) deallocate ( ni ) deallocate ( Ti ) deallocate ( dr ) deallocate ( neprim ) deallocate ( nedbprim ) deallocate ( Teprim ) deallocate ( Tedbprim ) deallocate ( niprim ) deallocate ( nidbprim ) deallocate ( Tiprim ) deallocate ( Tidbprim ) deallocate ( loglam ) !    deallocate (vnewki) !    deallocate (vnewke) end subroutine deallocate_arrays_spec end module inputprofiles_interface","tags":"","loc":"sourcefile/inputprofiles_interface.f90.html"},{"title":"vmec_geo.f90 â€“ stella","text":"Contents Modules vmec_geo Source Code vmec_geo.f90 Source Code module vmec_geo implicit none public :: read_vmec_parameters public :: get_vmec_geo real :: alpha0 integer :: zgrid_refinement_factor real :: zgrid_scalefac integer :: surface_option real :: nfield_periods real :: zeta_center , torflux logical :: verbose character ( 2000 ) :: vmec_filename contains subroutine read_vmec_parameters use file_utils , only : input_unit_exist use mp , only : mp_abort use zgrid , only : zed_equal_arc implicit none integer :: in_file logical :: exist namelist / vmec_parameters / alpha0 , zeta_center , nfield_periods , & torflux , zgrid_scalefac , zgrid_refinement_factor , surface_option , verbose , vmec_filename call init_vmec_defaults in_file = input_unit_exist ( \"vmec_parameters\" , exist ) if ( exist ) read ( unit = in_file , nml = vmec_parameters ) if ( zgrid_scalefac < 1.0 - epsilon ( 0. )) then write ( * , * ) 'zgrid_scalefac = ' , zgrid_scalefac call mp_abort ( 'zgrid_scalefac should always be >= 1.0.  aborting' ) else if (. not . zed_equal_arc ) then if ( zgrid_scalefac > 1.0 + epsilon ( 0. )) then write ( * , * ) 'There is no reason to use zgrid_scalefac different from 1.0 unless zed_equal_arc=T' write ( * , * ) 'Setting zgrid_scalefac = 1.0' zgrid_scalefac = 1.0 else if ( zgrid_refinement_factor > 1 ) then write ( * , * ) 'There is no reason to use zgrid_refinement_factor > 1 unless zed_equal_arc=T' write ( * , * ) 'Setting zgrid_refinement_factor = 1' zgrid_refinement_factor = 1 end if end if end subroutine read_vmec_parameters subroutine init_vmec_defaults use zgrid , only : zed_equal_arc implicit none vmec_filename = 'equilibria/wout_w7x_standardConfig.nc' alpha0 = 0.0 zeta_center = 0.0 nfield_periods = - 1.0 torflux = 0.6354167d+0 surface_option = 0 verbose = . true . ! originally planned to make gradpar independent of alpha ! for full flux surface simulations. this required ! the code to obtain vmec geo quantities ! on a zeta grid that is longer than ! will ultimately be used in simulation ! this is unlikely to be needed in the future, ! but leaving in as an option until sure it is not needed. zgrid_scalefac = 1.0 if ( zed_equal_arc ) then zgrid_refinement_factor = 4 else zgrid_refinement_factor = 1 end if end subroutine init_vmec_defaults subroutine get_vmec_geo ( nzgrid , nalpha , naky , surf , grho , bmag , gradpar , & b_dot_grad_z , grad_alpha_grad_alpha , & grad_alpha_grad_psi , grad_psi_grad_psi , & gds23 , gds24 , gds25 , gds26 , gbdrift_alpha , gbdrift0_psi , cvdrift_alpha , & cvdrift0_psi , sign_torflux , & theta_vmec , zed_scalefac , L_reference , B_reference , alpha , zeta , & field_period_ratio , x_displacement_fac ) use constants , only : pi use common_types , only : flux_surface_type use splines , only : geo_spline use physics_flags , only : full_flux_surface , const_alpha_geo use vmec_to_stella_geometry_interface_mod , only : vmec_to_stella_geometry_interface use vmec_to_stella_geometry_interface_mod , only : read_vmec_equilibrium use zgrid , only : zed_equal_arc , get_total_arc_length , get_arc_length_grid use zgrid , only : zed use file_utils , only : open_output_file implicit none integer , intent ( in ) :: nzgrid , nalpha , naky type ( flux_surface_type ), intent ( out ) :: surf real , dimension ( - nzgrid :), intent ( out ) :: gradpar real , dimension (:, - nzgrid :), intent ( out ) :: grho , bmag , b_dot_grad_z , & grad_alpha_grad_alpha , grad_alpha_grad_psi , grad_psi_grad_psi , & gds23 , gds24 , gds25 , gds26 , gbdrift_alpha , gbdrift0_psi , & cvdrift_alpha , cvdrift0_psi , theta_vmec , zeta , & ! JCP x_displacement_fac real , dimension (:), intent ( out ) :: alpha real , intent ( out ) :: zed_scalefac , L_reference , B_reference integer , intent ( out ) :: sign_torflux real , intent ( out ) :: field_period_ratio logical , parameter :: debug = . false . integer :: tmpunit integer :: i , j , ia , iz integer :: nzgrid_vmec integer :: zetamax_idx real :: nfp real , dimension (:), allocatable :: zeta_vmec real , dimension (:, :), allocatable :: thetamod_vmec real , dimension ( nalpha , - nzgrid : nzgrid ) :: B_sub_theta_vmec , B_sub_zeta ! JFP real , dimension (:, :), allocatable :: B_sub_theta_vmec_mod , B_sub_zeta_mod ! JFP real , dimension (:, :), allocatable :: bmag_vmec , gradpar_vmec , gradpar_zeta real , dimension (:, :), allocatable :: grad_alpha_grad_alpha_vmec real , dimension (:, :), allocatable :: grad_alpha_grad_psi_vmec real , dimension (:, :), allocatable :: grad_psi_grad_psi_vmec real , dimension (:, :), allocatable :: gds23_vmec , gds24_vmec , gds25_vmec , gds26_vmec real , dimension (:, :), allocatable :: gbdrift_alpha_vmec , gbdrift0_psi_vmec real , dimension (:, :), allocatable :: cvdrift_alpha_vmec , cvdrift0_psi_vmec real , dimension (:, :), allocatable :: x_displacement_fac_vmec real , dimension (:), allocatable :: zed_domain_size real , dimension (:, :), allocatable :: arc_length real :: dzeta_vmec , zmin , zmax real , dimension ( nalpha , - nzgrid : nzgrid ) :: theta !> first read in equilibrium information from vmec file !> this is stored as a set of global variables in read_wout_mod !> in mini_libstell.  it will be accessible if ( debug ) write ( * , * ) 'get_vmec_geo::read_vmec_equilibrium' call read_vmec_equilibrium ( vmec_filename ) ! !> nzgrid_vmec is the number of positive/negative zeta locations ! !> at which to get geometry data from vmec ! !> can be > than nzgrid for full_flux_surface case ! !> where z(zeta_max)-z(zeta_min) varies with alpha ! !> and thus a larger than usual range of zeta_max/min ! !> values are needed to avoid extrapolation ! if (zed_equal_arc) then !    if (debug) write (*,*) 'get_vmec_geo::get_modified_vmec_zeta_grid' !    call get_modified_vmec_zeta_grid (nzgrid_vmec, dzeta_vmec) ! else !    nzgrid_vmec = nzgrid ! end if !> if desired, increase number of sampled zeta grid points in VMEC data !> to increase accuracy of later integration in zeta and interpolation !> onto stella zed grid nzgrid_vmec = nzgrid * zgrid_refinement_factor !> allocate vmec geometry arrays of size 2*nzgrid_vmec+1 allocate ( zeta_vmec ( - nzgrid_vmec : nzgrid_vmec )) allocate ( thetamod_vmec ( nalpha , - nzgrid_vmec : nzgrid_vmec )) allocate ( B_sub_zeta_mod ( nalpha , - nzgrid_vmec : nzgrid_vmec )) ! JFP allocate ( B_sub_theta_vmec_mod ( nalpha , - nzgrid_vmec : nzgrid_vmec )) ! JFP allocate ( bmag_vmec ( nalpha , - nzgrid_vmec : nzgrid_vmec )) allocate ( gradpar_vmec ( nalpha , - nzgrid_vmec : nzgrid_vmec )) allocate ( grad_alpha_grad_alpha_vmec ( nalpha , - nzgrid_vmec : nzgrid_vmec )) allocate ( grad_alpha_grad_psi_vmec ( nalpha , - nzgrid_vmec : nzgrid_vmec )) allocate ( grad_psi_grad_psi_vmec ( nalpha , - nzgrid_vmec : nzgrid_vmec )) allocate ( gds23_vmec ( nalpha , - nzgrid_vmec : nzgrid_vmec )) allocate ( gds24_vmec ( nalpha , - nzgrid_vmec : nzgrid_vmec )) allocate ( gds25_vmec ( nalpha , - nzgrid_vmec : nzgrid_vmec )) allocate ( gds26_vmec ( nalpha , - nzgrid_vmec : nzgrid_vmec )) allocate ( gbdrift_alpha_vmec ( nalpha , - nzgrid_vmec : nzgrid_vmec )) allocate ( gbdrift0_psi_vmec ( nalpha , - nzgrid_vmec : nzgrid_vmec )) allocate ( cvdrift_alpha_vmec ( nalpha , - nzgrid_vmec : nzgrid_vmec )) allocate ( cvdrift0_psi_vmec ( nalpha , - nzgrid_vmec : nzgrid_vmec )) allocate ( x_displacement_fac_vmec ( nalpha , - nzgrid_vmec : nzgrid_vmec )) allocate ( arc_length ( nalpha , - nzgrid_vmec : nzgrid_vmec )) if ( debug ) write ( * , * ) 'get_vmec_geo::vmec_to_stella_geometry_interface' call vmec_to_stella_geometry_interface ( nalpha , alpha0 , & nzgrid_vmec , zeta_center , nfield_periods * zgrid_scalefac , torflux , & surface_option , verbose , & surf % rhoc , surf % qinp , surf % shat , L_reference , B_reference , nfp , & sign_torflux , alpha , zeta_vmec , & bmag_vmec , gradpar_vmec , grad_alpha_grad_alpha_vmec , & grad_alpha_grad_psi_vmec , grad_psi_grad_psi_vmec , & gds23_vmec , gds24_vmec , & gds25_vmec , gds26_vmec , gbdrift_alpha_vmec , gbdrift0_psi_vmec , & cvdrift_alpha_vmec , & cvdrift0_psi_vmec , thetamod_vmec , B_sub_zeta_mod , B_sub_theta_vmec_mod , & x_displacement_fac_vmec ) !> get ratio of number of simulated field periods to the number of field periods of the device field_period_ratio = nfield_periods / real ( nfp ) dzeta_vmec = zeta_vmec ( 1 ) - zeta_vmec ( 0 ) allocate ( zed_domain_size ( nalpha )) !    if (nzgrid_vmec /= nzgrid) then if ( zed_equal_arc ) then !> must interpolate geometric quantities from (zeta,alpha) grid to !> (zed,alpha) grid, with zed the normalised arc-length !> first need to get zed(zeta,alpha) !> defined via H(alpha) = b . grad z = b . grad zeta * dz/dzeta !> and z_min = zeta_min, z_max = zeta_max (independent of alpha). !> note that nzgrid*zgrid_refinement_factor gives index !> for the max zeta of the nominal zeta grid !zetamax_idx = nzgrid*zgrid_refinement_factor zetamax_idx = nzgrid_vmec if ( debug ) write ( * , * ) 'get_vmec_geo::get_total_arc_length' do ia = 1 , nalpha !> zed_domain_size is z(zeta_max) - z(zeta_min) for nominal zeta domain call get_total_arc_length ( zetamax_idx , gradpar_vmec ( ia , - zetamax_idx : zetamax_idx ), & dzeta_vmec , zed_domain_size ( ia )) !> z(zeta_min) should be zeta_min zmin = - zed_domain_size ( ia ) * 0.5 call get_arc_length_grid ( zetamax_idx , nzgrid_vmec , zmin , & gradpar_vmec ( ia , :), dzeta_vmec , arc_length ( ia , :)) !> b_dot_grad_z is the total arc-length for one toroidal turn, !> multiplied by 2*pi b_dot_grad_z ( ia , :) = 2.0 * pi / zed_domain_size ( ia ) end do !> now that we know the min/max values of z corresponding to min/max values !> of the nominal zeta at each of the alphas, construct a regular z grid !> set the max z value on this regular grid to the maximum over all alpha !> of z(zeta_max,alpha) zmax = maxval ( zed_domain_size ) * 0.5 !> scale zed so that it is arc-length compressed (or expanded) !> to the range [-pi:pi] !zed_scalefac = pi/zmax arc_length = 2.0 * pi * arc_length / spread ( zed_domain_size , 2 , 2 * nzgrid_vmec + 1 ) zed_scalefac = 1.0 !       arc_length = arc_length*zed_scalefac if (. not . allocated ( gradpar_zeta )) allocate ( gradpar_zeta ( nalpha , - nzgrid : nzgrid )) if ( debug ) write ( * , * ) 'get_vmec_geo::geo_spline' do ia = 1 , nalpha !> now that we have z(alpha,zeta), interpolate from regular zeta grid (which is irregular in z) !> to regular zed grid (irregular in zeta) call geo_spline ( arc_length ( ia , :), zeta_vmec , zed , zeta ( ia , :)) call geo_spline ( arc_length ( ia , :), gradpar_vmec ( ia , :), zed , gradpar_zeta ( ia , :)) call geo_spline ( arc_length ( ia , :), bmag_vmec ( ia , :), zed , bmag ( ia , :)) call geo_spline ( arc_length ( ia , :), grad_alpha_grad_alpha_vmec ( ia , :), zed , grad_alpha_grad_alpha ( ia , :)) call geo_spline ( arc_length ( ia , :), grad_alpha_grad_psi_vmec ( ia , :), zed , grad_alpha_grad_psi ( ia , :)) call geo_spline ( arc_length ( ia , :), grad_psi_grad_psi_vmec ( ia , :), zed , grad_psi_grad_psi ( ia , :)) call geo_spline ( arc_length ( ia , :), gds23_vmec ( ia , :), zed , gds23 ( ia , :)) call geo_spline ( arc_length ( ia , :), gds24_vmec ( ia , :), zed , gds24 ( ia , :)) call geo_spline ( arc_length ( ia , :), gds25_vmec ( ia , :), zed , gds25 ( ia , :)) call geo_spline ( arc_length ( ia , :), gds26_vmec ( ia , :), zed , gds26 ( ia , :)) call geo_spline ( arc_length ( ia , :), gbdrift_alpha_vmec ( ia , :), zed , gbdrift_alpha ( ia , :)) call geo_spline ( arc_length ( ia , :), gbdrift0_psi_vmec ( ia , :), zed , gbdrift0_psi ( ia , :)) call geo_spline ( arc_length ( ia , :), cvdrift_alpha_vmec ( ia , :), zed , cvdrift_alpha ( ia , :)) call geo_spline ( arc_length ( ia , :), cvdrift0_psi_vmec ( ia , :), zed , cvdrift0_psi ( ia , :)) call geo_spline ( arc_length ( ia , :), thetamod_vmec ( ia , :), zed , theta_vmec ( ia , :)) call geo_spline ( arc_length ( ia , :), B_sub_zeta_mod ( ia , :), zed , B_sub_zeta ( ia , :)) ! JFP call geo_spline ( arc_length ( ia , :), B_sub_theta_vmec_mod ( ia , :), zed , B_sub_theta_vmec ( ia , :)) ! JFP call geo_spline ( arc_length ( ia , :), x_displacement_fac_vmec ( ia , :), zed , x_displacement_fac ( ia , :)) !B_sub_zeta = B_sub_zeta_mod !B_sub_theta_vmec = B_sub_theta_vmec_mod !> gradpar at this point is b . grad zeta !> but want it to be b . grad z = b . grad zeta * dz/dzeta. !> we have constructed b_dot_grad_z = b . grad to be a function purely of alpha, !> so dz/dzeta = b_dot_grad_z(alpha) / b_dot_grad_zeta(alpha,zeta) !          ! we have constructed z so that b . grad z = 1 !          ! so dz/dzeta = 1 / b . grad zeta !> gds23 and gds24 involve grad z factors !> but currently calculated in terms of grad zeta !> so convert via multiplication with dz/dzeta gds23 ( ia , :) = gds23 ( ia , :) * b_dot_grad_z ( ia , :) / gradpar_zeta ( ia , :) gds24 ( ia , :) = gds24 ( ia , :) * b_dot_grad_z ( ia , :) / gradpar_zeta ( ia , :) end do ! gradpar = 1.0 !> define gradpar to be the average value of b_dot_grad_z in alpha gradpar = sum ( b_dot_grad_z , 1 ) / size ( b_dot_grad_z , 1 ) !> we now have geometric coefficients on an alpha-grid. !> as we will be multiplying this with functions of g and phi, !> we must take care to avoid aliasing. !> this is accomplished by filtering out the highest third of !> the wavenumber spectra if ( debug ) write ( * , * ) 'get_vmec_geo::filter_geo_coef' if ( full_flux_surface . and . . not . const_alpha_geo ) then do iz = - nzgrid , nzgrid call filter_geo_coef ( naky , bmag (:, iz )) call filter_geo_coef ( naky , grad_alpha_grad_alpha (:, iz )) call filter_geo_coef ( naky , grad_alpha_grad_psi (:, iz )) call filter_geo_coef ( naky , grad_psi_grad_psi (:, iz )) call filter_geo_coef ( naky , gds23 (:, iz )) call filter_geo_coef ( naky , gds24 (:, iz )) call filter_geo_coef ( naky , gds25 (:, iz )) call filter_geo_coef ( naky , gds26 (:, iz )) call filter_geo_coef ( naky , gbdrift_alpha (:, iz )) call filter_geo_coef ( naky , gbdrift0_psi (:, iz )) call filter_geo_coef ( naky , cvdrift_alpha (:, iz )) call filter_geo_coef ( naky , cvdrift0_psi (:, iz )) call filter_geo_coef ( naky , b_dot_grad_z (:, iz )) end do end if else !> if zed_equal_arc = F, zed coordinate is the same as VMEC's zeta coordinate, !> so no need to interpolate onto a new grid zeta = spread ( zeta_vmec , 1 , nalpha ) bmag = bmag_vmec gradpar = gradpar_vmec ( 1 , :) b_dot_grad_z = gradpar_vmec grad_alpha_grad_alpha = grad_alpha_grad_alpha_vmec grad_alpha_grad_psi = grad_alpha_grad_psi_vmec grad_psi_grad_psi = grad_psi_grad_psi_vmec gds23 = gds23_vmec gds24 = gds24_vmec gds25 = gds25_vmec gds26 = gds26_vmec gbdrift_alpha = gbdrift_alpha_vmec gbdrift0_psi = gbdrift0_psi_vmec cvdrift_alpha = cvdrift_alpha_vmec cvdrift0_psi = cvdrift0_psi_vmec x_displacement_fac = x_displacement_fac_vmec theta_vmec = thetamod_vmec B_sub_theta_vmec = B_sub_theta_vmec_mod ! JFP B_sub_zeta = B_sub_zeta_mod ! JFP ! scale zed so that it is zeta compressed (or expanded) ! to the range [-pi,pi] ! this is 1/p from stella JCP paper zed_scalefac = real ( nfp ) / nfield_periods end if !> gradpar is b . grad zed (or its alpha-average, in the case of full_flux_surface=T), !> with zed = zeta or normalised arc-length, both scaled to run from -pi to pi gradpar = gradpar * zed_scalefac gds23 = gds23 * zed_scalefac gds24 = gds24 * zed_scalefac ! arrays over extended zeta-grid no longer needed, so deallocate deallocate ( zed_domain_size ) deallocate ( zeta_vmec ) deallocate ( thetamod_vmec ) deallocate ( B_sub_theta_vmec_mod ) deallocate ( B_sub_zeta_mod ) deallocate ( bmag_vmec , gradpar_vmec ) if ( allocated ( gradpar_zeta )) deallocate ( gradpar_zeta ) deallocate ( grad_alpha_grad_alpha_vmec , grad_alpha_grad_psi_vmec , grad_psi_grad_psi_vmec ) deallocate ( gds23_vmec , gds24_vmec , gds25_vmec , gds26_vmec ) deallocate ( gbdrift_alpha_vmec , gbdrift0_psi_vmec ) deallocate ( cvdrift_alpha_vmec , cvdrift0_psi_vmec ) deallocate ( x_displacement_fac_vmec ) deallocate ( arc_length ) ! vmec_to_stella_geometry_interface returns psitor/psitor_lcfs as rhoc ! stella uses rhoc = sqrt(psitor/psitor_lcfs) = rhotor surf % rhoc = sqrt ( surf % rhoc ) surf % rhotor = surf % rhoc ! rho = sqrt(psi_t / psi_{t,LCFS}) ! Bref = 2|psi_LCFS|/a&#94;2 ! grho = a * |grad rho| = a * |drho/dpsi_t| * |grad psi_t| ! = |drho/dpsi_t|*(a&#94;2*Bref) * |grad psi_t|/(a*Bref) ! = a&#94;2*Bref/(2*rho)/|psi_LCFS| * sqrt(grad_psi_grad_psi) ! = 1/rho * sqrt(grad_psi_grad_psi) grho = sqrt ( grad_psi_grad_psi ) / surf % rhotor ! grho = |grad rho| = |drho/dx| * |grad x| ! |drho/dx| = L_reference ! gds22 = shat&#94;2 * |grad x|&#94;2 !    grho = sqrt(gds22/surf%shat**2)/L_reference surf % drhotordrho = 1.0 surf % psitor_lcfs = 0.5 * sign_torflux ! this is zeta0 that appears everywhere in tandem with zeta-zeta0 ! converted to the zed coordinate (which is possibly arc-length ! and is compressed to fit on the range -pi,pi) surf % zed0_fac = - zed ( nzgrid ) / zeta ( 1 , nzgrid ) * surf % qinp ! scale the vmec output ! alpha = theta_pest - iota*zeta ! theta_pest = theta_vmec + Lambda(psi,alpha,theta_vmec) ! with theta_pest a straight-field-line angle ! but not theta_vmec ! so theta is theta_pest up to constant (alpha) !    theta = zeta/nfp/surf%qinp theta = spread ( alpha , 2 , 2 * nzgrid + 1 ) + zeta / surf % qinp ! this is the vmec theta (not straight-field-line coordinate) ! scaled to run between -pi and pi theta_vmec = theta_vmec / nfp call open_output_file ( tmpunit , '.vmec.geo' ) write ( tmpunit , '(6a12)' ) '#rhotor' , 'qinp' , 'shat' , 'aref' , 'Bref' , 'z_scalefac' write ( tmpunit , '(6e12.4)' ) surf % rhoc , surf % qinp , surf % shat , L_reference , B_reference , zed_scalefac write ( tmpunit , '(17a12)' ) '#    alpha' , 'zeta' , 'bmag' , 'gradpar' , 'bdot_grad_z' , 'grad_alpha2' , & 'gd_alph_psi' , 'grad_psi2' , 'gds23' , 'gds24' , 'gbdriftalph' , 'gbdrift0psi' , 'cvdriftalph' , & 'cvdrift0psi' , 'theta_vmec' , 'B_sub_theta' , 'B_sub_zeta' ! JFP adding B_poloidal and B_toroidal Apr21 do j = - nzgrid , nzgrid do i = 1 , nalpha write ( tmpunit , '(17e12.4)' ) alpha ( i ), zeta ( i , j ), bmag ( i , j ), gradpar ( j ), b_dot_grad_z ( i , j ), & grad_alpha_grad_alpha ( i , j ), grad_alpha_grad_psi ( i , j ), grad_psi_grad_psi ( i , j ), & gds23 ( i , j ), gds24 ( i , j ), & gbdrift_alpha ( i , j ), gbdrift0_psi ( i , j ), cvdrift_alpha ( i , j ), cvdrift0_psi ( i , j ), theta_vmec ( i , j ), B_sub_theta_vmec ( i , j ), B_sub_zeta ( i , j ) ! JFP end do write ( tmpunit , * ) end do close ( tmpunit ) end subroutine get_vmec_geo subroutine filter_geo_coef ( naky , geocoef ) use stella_transforms , only : transform_alpha2kalpha , transform_kalpha2alpha implicit none integer , intent ( in ) :: naky real , dimension (:), intent ( in out ) :: geocoef complex , dimension (:), allocatable :: fourier allocate ( fourier ( naky )) ! filtering and padding are built-in to the ! Fourier transform routines below call transform_alpha2kalpha ( geocoef , fourier ) call transform_kalpha2alpha ( fourier , geocoef ) deallocate ( fourier ) end subroutine filter_geo_coef subroutine get_modified_vmec_zeta_grid ( nzgrid_modified , dzeta_modified ) use zgrid , only : nzgrid use vmec_to_stella_geometry_interface_mod , only : get_nominal_vmec_zeta_grid implicit none integer , intent ( out ) :: nzgrid_modified integer :: nzgrid_excess real :: nfield_periods_device real :: zeta_max , excess_zeta real :: tmp , dzeta , dzeta_modified real , dimension (:), allocatable :: zeta !> need to extend the maximum and minimum zeta values !> by zgrid_scalefac to ensure that we have information !> about geometric coefficients everywhere on a fixed !> equal-arc grid in zed !> first figure out how many extra zeta grid points are !> required at the nominal grid spacing to get out !> to the ends of the extended zeta domain !> first calculate the nominal zeta grid used for vmec if (. not . allocated ( zeta )) allocate ( zeta ( - nzgrid : nzgrid )) !> note that nfield_periods is the number of field periods !> sampled in stella, while nfield_periods_device !> is the number of field periods in the device !> nfield_periods may be reasonably bigger than nfield_periods_device !> as the former is sampled while keeping alpha fixed (rather than theta) call get_nominal_vmec_zeta_grid ( nzgrid , zeta_center , nfield_periods , & nfield_periods_device , zeta ) !> maximum zeta value for nominal zeta grid zeta_max = zeta ( nzgrid ) !> excess_zeta is difference between expanded zeta_max and nominal zeta_max excess_zeta = zeta_max * ( zgrid_scalefac - 1.0 ) !> assumes equal grid spacing in zeta dzeta = zeta ( 1 ) - zeta ( 0 ) tmp = excess_zeta / dzeta !> nzgrid_excess is the number of additional zeta grid points needed to !> cover at least excess_zeta if ( abs ( tmp - nint ( tmp )) < 0.1 ) then nzgrid_excess = nint ( tmp ) else nzgrid_excess = nint ( tmp ) + 1 end if !> now refine the zeta grid by desired amount in !> preparation for interpolation nzgrid_modified = ( nzgrid + nzgrid_excess ) * zgrid_refinement_factor dzeta_modified = dzeta / real ( zgrid_refinement_factor ) if ( allocated ( zeta )) deallocate ( zeta ) end subroutine get_modified_vmec_zeta_grid end module vmec_geo","tags":"","loc":"sourcefile/vmec_geo.f90.html"},{"title":"millerlocal.f90 â€“ stella","text":"Contents Modules millerlocal Source Code millerlocal.f90 Source Code module millerlocal use common_types , only : flux_surface_type implicit none public :: init_local_defaults public :: read_local_parameters public :: communicate_parameters_multibox public :: get_local_geo public :: finish_local_geo public :: local private integer :: nzed_local real :: rhoc , rmaj , shift real :: kappa , kapprim real :: tri , triprim real :: betaprim , betadbprim real :: qinp , shat , d2qdr2 real :: rgeo real :: dpsidrho , d2psidr2 , dpsidrho_psi0 real :: psitor_lcfs real :: rhotor , drhotordrho , dIdrho , dI real :: rhoc0 logical :: write_profile_variation , read_profile_variation logical :: load_psi0_variables integer :: nz , nz2pi real :: bi , dqdr , d2Idr2 real , dimension (:), allocatable :: grho , bmag , grho_psi0 , bmag_psi0 , gradpar real , dimension (:), allocatable :: gradpararc , arc real , dimension (:), allocatable :: gds2 , gds21 , gds22 real , dimension (:), allocatable :: gds23 , gds24 real , dimension (:), allocatable :: gbdrift0 , gbdrift real , dimension (:), allocatable :: cvdrift0 , cvdrift real , dimension (:), allocatable :: d2Rdth2 , d2Zdth2 , d2Rdrdth , d2Zdrdth real , dimension (:), allocatable :: gpsi , dBdrho , d2Bdrdth real , dimension (:), allocatable :: dgradpardrho , dgradparBdrho , dBdth , gradparb real , dimension (:), allocatable :: dcvdrift0drho , dgbdrift0drho , theta real , dimension (:), allocatable :: varthet , dvarthdr , gradrho_gradthet , cross , d2varthdr2 real , dimension (:), allocatable :: gradthet2 , gradalph_gradthet , gradrho_gradalph , gradalph2 real , dimension (:), allocatable :: d2Bdr2 , d2Rdr2 , d2Zdr2 , drz , drzdth real , dimension (:), allocatable :: d2Rdr2dth , d2Zdr2dth , d2gpsidr2 , dcrossdr real , dimension (:), allocatable :: dcvdriftdrho , dgbdriftdrho real , dimension (:), allocatable :: dgds2dr , dgds21dr , dgds22dr real , dimension (:), allocatable :: dgr2dr , dgpsi2dr real , dimension (:), allocatable :: dgrgt , dgt2 , dgagr , dgagt , dga2 real , dimension (:, :), allocatable :: Rr , Zr real , dimension (:), allocatable :: jacrho , delthet , djacdrho , djacrdrho real , dimension (:), allocatable :: d2jacdr2 , dRdrho , dZdrho , dRdth , dZdth real , dimension (:), allocatable :: d2R , d2Z type ( flux_surface_type ) :: local logical :: defaults_initialized = . false . contains subroutine init_local_defaults implicit none if ( defaults_initialized ) return defaults_initialized = . true . nzed_local = 128 rhoc = 0.5 rhoc0 = 0.5 rmaj = 3.0 rgeo = 3.0 qinp = 1.4 shat = 0.8 shift = 0.0 kappa = 0.0 kapprim = 0.0 tri = 0.0 triprim = 0.0 ! betaprim = -(4pi/Bref&#94;2)*d(ptot)/drho betaprim = 0.0 ! betadbprim = -(4pi/Bref&#94;2)*d&#94;2ptot/drho&#94;2 betadbprim = 0.0 d2qdr2 = 0.0 d2psidr2 = 0.0 read_profile_variation = . false . write_profile_variation = . false . load_psi0_variables = . true . ! only needed for sfincs when not using ! geo info from file rhotor = rhoc psitor_lcfs = 1.0 drhotordrho = 1.0 end subroutine init_local_defaults subroutine read_local_parameters ( nzed , nzgrid , local_out ) use file_utils , only : input_unit_exist use common_types , only : flux_surface_type implicit none type ( flux_surface_type ), intent ( out ) :: local_out integer , intent ( in ) :: nzed , nzgrid real :: dum integer :: in_file , np , j logical :: exist namelist / millergeo_parameters / rhoc , rmaj , shift , qinp , shat , & kappa , kapprim , tri , triprim , rgeo , betaprim , & betadbprim , d2qdr2 , d2psidr2 , & nzed_local , read_profile_variation , write_profile_variation call init_local_defaults in_file = input_unit_exist ( \"millergeo_parameters\" , exist ) if ( exist ) read ( unit = in_file , nml = millergeo_parameters ) local % rhoc = rhoc local % rmaj = rmaj local % rgeo = rgeo local % shift = shift local % kappa = kappa local % kapprim = kapprim local % qinp = qinp local % shat = shat local % tri = tri local % triprim = triprim local % betaprim = betaprim local % betadbprim = betadbprim local % d2qdr2 = d2qdr2 local % d2psidr2 = d2psidr2 local % zed0_fac = 1.0 ! following two variables are not inputs local % dr = 1.e-3 * ( rhoc / rmaj ) local % rhotor = rhotor local % psitor_lcfs = psitor_lcfs local % drhotordrho = drhotordrho local % dpsitordrho = 0.0 local % d2psitordrho2 = 0.0 ! the next three variablaes are for multibox simulations ! with radial variation local % rhoc_psi0 = rhoc local % qinp_psi0 = qinp local % shat_psi0 = shat ! first get nperiod corresponding to input number of grid points nz2pi = nzed / 2 np = ( nzgrid - nz2pi ) / nzed + 1 ! now switch to using (possible higher resolution) local grid nz2pi = nzed_local / 2 ! this is the equivalent of nzgrid on the local grid nz = nz2pi + nzed_local * ( np - 1 ) ! initialize to zero ! will be overwritten if reading in from file ! only relevant for profile variation tests ! these needs to be deallocated somewhere allocate ( d2R ( - nz : nz )) allocate ( d2Z ( - nz : nz )) allocate ( bmag_psi0 ( - nz : nz )) allocate ( grho_psi0 ( - nz : nz )) d2R = 0. ; d2Z = 0. ; dI = 0. if ( read_profile_variation ) then open ( 1002 , file = 'RZ.in' , status = 'old' ) read ( 1002 , '(12e13.5)' ) rhoc0 , dI , qinp , shat , d2qdr2 , kappa , kapprim , tri , triprim , & betaprim , betadbprim , dpsidrho_psi0 do j = - nz , nz read ( 1002 , '(5e13.5)' ) dum , d2R ( j ), d2Z ( j ), bmag_psi0 ( j ), grho_psi0 ( j ) end do close ( 1002 ) local % qinp = qinp + shat * qinp / rhoc0 * ( local % rhoc - rhoc0 ) & + 0.5 * ( local % rhoc - rhoc0 ) ** 2 * d2qdr2 local % shat = ( local % rhoc / local % qinp ) & * ( shat * qinp / rhoc0 + ( local % rhoc - rhoc0 ) * d2qdr2 ) local % kappa = kappa + kapprim * ( local % rhoc - rhoc0 ) local % tri = tri + triprim * ( local % rhoc - rhoc0 ) local % betaprim = betaprim + betadbprim * ( local % rhoc - rhoc0 ) local % rhoc_psi0 = rhoc0 local % qinp_psi0 = qinp local % shat_psi0 = shat load_psi0_variables = . false . end if local_out = local end subroutine read_local_parameters subroutine communicate_parameters_multibox ( surf , drl , drr ) use mp , only : job , scope , mp_abort , & crossdomprocs , subprocs , & send , receive use job_manage , only : njobs use common_types , only : flux_surface_type implicit none real , optional , intent ( in ) :: drl , drr type ( flux_surface_type ), intent ( inout ) :: surf real :: lrhoc , lqinp , lshat , lkappa , ltri , lbetaprim real :: rrhoc , rqinp , rshat , rkappa , rtri , rbetaprim real :: dqdr real :: rhoc_psi0 , qinp_psi0 , shat_psi0 !FLAG DSO -  I think d2psidrho2 needs to be communicated, but !            I'm unsure what quantity needs to be updated if ( job == 1 ) then dqdr = local % shat * local % qinp / local % rhoc lrhoc = local % rhoc + drl lqinp = local % qinp + drl * dqdr + 0.5 * drl ** 2 * local % d2qdr2 lshat = ( lrhoc / lqinp ) * ( dqdr + drl * local % d2qdr2 ) lkappa = kappa + drl * kapprim ltri = tri + drl * triprim lbetaprim = betaprim + drl * betadbprim rrhoc = local % rhoc + drr rqinp = local % qinp + drr * dqdr + 0.5 * drr ** 2 * local % d2qdr2 rshat = ( rrhoc / rqinp ) * ( dqdr + drr * local % d2qdr2 ) rkappa = kappa + drr * kapprim rtri = tri + drr * triprim rbetaprim = betaprim + drr * betadbprim end if call scope ( crossdomprocs ) if ( job == 1 ) then call send ( lrhoc , 0 , 120 ) call send ( lqinp , 0 , 121 ) call send ( lshat , 0 , 122 ) call send ( lkappa , 0 , 123 ) call send ( ltri , 0 , 124 ) call send ( lbetaprim , 0 , 125 ) call send ( local % rhoc , 0 , 126 ) call send ( d2R , 0 , 127 ) call send ( d2Z , 0 , 128 ) call send ( dIdrho , 0 , 129 ) call send ( rhoc , 0 , 130 ) call send ( qinp , 0 , 131 ) call send ( shat , 0 , 132 ) call send ( dpsidrho , 0 , 133 ) call send ( bmag , 0 , 134 ) call send ( grho , 0 , 135 ) call send ( rrhoc , njobs - 1 , 220 ) call send ( rqinp , njobs - 1 , 221 ) call send ( rshat , njobs - 1 , 222 ) call send ( rkappa , njobs - 1 , 223 ) call send ( rtri , njobs - 1 , 224 ) call send ( rbetaprim , njobs - 1 , 225 ) call send ( local % rhoc , njobs - 1 , 226 ) call send ( d2R , njobs - 1 , 227 ) call send ( d2Z , njobs - 1 , 228 ) call send ( dIdrho , njobs - 1 , 229 ) call send ( rhoc , njobs - 1 , 230 ) call send ( qinp , njobs - 1 , 231 ) call send ( shat , njobs - 1 , 232 ) call send ( dpsidrho , njobs - 1 , 233 ) call send ( bmag , njobs - 1 , 234 ) call send ( grho , njobs - 1 , 235 ) rhoc_psi0 = rhoc qinp_psi0 = qinp shat_psi0 = shat local % rhoc_psi0 = rhoc_psi0 local % qinp_psi0 = qinp_psi0 local % shat_psi0 = shat_psi0 elseif ( job == 0 ) then call receive ( rhoc , 1 , 120 ) call receive ( qinp , 1 , 121 ) call receive ( shat , 1 , 122 ) call receive ( kappa , 1 , 123 ) call receive ( tri , 1 , 124 ) call receive ( betaprim , 1 , 125 ) call receive ( rhoc0 , 1 , 126 ) call receive ( d2R , 1 , 127 ) call receive ( d2Z , 1 , 128 ) call receive ( dI , 1 , 129 ) call receive ( rhoc_psi0 , 1 , 130 ) call receive ( qinp_psi0 , 1 , 131 ) call receive ( shat_psi0 , 1 , 132 ) call receive ( dpsidrho_psi0 , 1 , 133 ) call receive ( bmag_psi0 , 1 , 134 ) call receive ( grho_psi0 , 1 , 135 ) local % rhoc = rhoc local % qinp = qinp local % shat = shat local % kappa = kappa local % tri = tri local % betaprim = betaprim local % rhoc_psi0 = rhoc_psi0 local % qinp_psi0 = qinp_psi0 local % shat_psi0 = shat_psi0 load_psi0_variables = . false . elseif ( job == njobs - 1 ) then call receive ( rhoc , 1 , 220 ) call receive ( qinp , 1 , 221 ) call receive ( shat , 1 , 222 ) call receive ( kappa , 1 , 223 ) call receive ( tri , 1 , 224 ) call receive ( betaprim , 1 , 225 ) call receive ( rhoc0 , 1 , 226 ) call receive ( d2R , 1 , 227 ) call receive ( d2Z , 1 , 228 ) call receive ( dI , 1 , 229 ) call receive ( rhoc_psi0 , 1 , 230 ) call receive ( qinp_psi0 , 1 , 231 ) call receive ( shat_psi0 , 1 , 232 ) call receive ( dpsidrho_psi0 , 1 , 233 ) call receive ( bmag_psi0 , 1 , 234 ) call receive ( grho_psi0 , 1 , 235 ) local % rhoc = rhoc local % qinp = qinp local % shat = shat local % kappa = kappa local % tri = tri local % betaprim = betaprim local % rhoc_psi0 = rhoc_psi0 local % qinp_psi0 = qinp_psi0 local % shat_psi0 = shat_psi0 load_psi0_variables = . false . end if surf % rhoc = local % rhoc surf % qinp = local % qinp surf % shat = local % shat surf % kappa = local % kappa surf % tri = local % tri surf % betaprim = local % betaprim surf % rhoc_psi0 = rhoc_psi0 surf % qinp_psi0 = qinp_psi0 surf % shat_psi0 = shat_psi0 call scope ( subprocs ) end subroutine communicate_parameters_multibox subroutine get_local_geo ( nzed , nzgrid , zed_in , zed_equal_arc , & dpsidrho_out , dpsidrho_psi0_out , dIdrho_out , grho_out , & bmag_out , bmag_psi0_out , & gds2_out , gds21_out , gds22_out , gds23_out , gds24_out , gradpar_out , & gbdrift0_out , gbdrift_out , cvdrift0_out , cvdrift_out , & dBdrho_out , d2Bdrdth_out , dgradpardrho_out , & btor_out , rmajor_out , & dcvdrift0drho_out , dcvdriftdrho_out , & dgbdrift0drho_out , dgbdriftdrho_out , & dgds2dr_out , dgds21dr_out , & dgds22dr_out , djacdrho_out ) use constants , only : pi use splines , only : geo_spline use file_utils , only : run_name implicit none integer , intent ( in ) :: nzed , nzgrid real , dimension ( - nzgrid :), intent ( in ) :: zed_in logical , intent ( in ) :: zed_equal_arc real , intent ( out ) :: dpsidrho_out , dpsidrho_psi0_out , dIdrho_out real , dimension ( - nzgrid :), intent ( out ) :: grho_out , & bmag_out , bmag_psi0_out , & gds2_out , gds21_out , gds22_out , gds23_out , gds24_out , & gradpar_out , gbdrift0_out , & gbdrift_out , cvdrift0_out , cvdrift_out , & dBdrho_out , d2Bdrdth_out , dgradpardrho_out , & btor_out , rmajor_out , & dcvdrift0drho_out , dcvdriftdrho_out , & dgbdrift0drho_out , dgbdriftdrho_out , & dgds2dr_out , dgds21dr_out , & dgds22dr_out , & djacdrho_out integer :: nr , np integer :: i , j real :: rmin , dum real , dimension ( 3 ) :: dr real , allocatable , dimension (:) :: zed_arc character ( len = 512 ) :: filename ! number of grid points used for radial derivatives nr = 3 ! first get nperiod corresponding to input number of grid points nz2pi = nzed / 2 np = ( nzgrid - nz2pi ) / nzed + 1 ! now switch to using (possible higher resolution) local grid nz2pi = nzed_local / 2 ! this is the equivalent of nzgrid on the local grid nz = nz2pi + nzed_local * ( np - 1 ) call allocate_arrays ( nr , nz ) dqdr = local % shat * local % qinp / local % rhoc dr ( 1 ) = - local % dr dr ( 2 ) = 0. dr ( 3 ) = local % dr do j = - nz , nz theta ( j ) = j * ( 2 * np - 1 ) * pi / real ( nz ) do i = 1 , 3 rmin = local % rhoc + dr ( i ) Rr ( i , j ) = Rpos ( rmin , theta ( j ), j ) Zr ( i , j ) = Zpos ( rmin , theta ( j ), j ) end do end do if (. not . allocated ( delthet )) allocate ( delthet ( - nz : nz - 1 )) ! get delta theta as a function of theta delthet = theta ( - nz + 1 :) - theta (: nz - 1 ) ! get dR/drho and dZ/drho call get_drho ( Rr , dRdrho ) call get_drho ( Zr , dZdrho ) ! get dR/dtheta and dZ/dtheta call get_dthet ( Rr ( 2 , :), dRdth ) call get_dthet ( Zr ( 2 , :), dZdth ) ! get second derivatives of R and Z with respect to theta call get_d2dthet2 ( Rr ( 2 , :), d2Rdth2 ) call get_d2dthet2 ( Zr ( 2 , :), d2Zdth2 ) ! get mixed theta and rho derivatives of R and Z call get_dthet ( dRdrho , d2Rdrdth ) call get_dthet ( dZdrho , d2Zdrdth ) ! get the Jacobian of the transformation from (rho,theta,zeta) to (R,Z,zeta) ! this is what I call jacr or jacrho in following comments ! as opposed to jacobian, which is for tranformation from (psi,theta,zeta) to (R,Z,zeta) call get_jacrho ! theta_integrate returns integral from 0 -> 2*pi ! note that dpsidrho here is an intermediary ! that requires manipulation to get final dpsidrho call theta_integrate ( jacrho ( - nz2pi : nz2pi ) / Rr ( 2 , - nz2pi : nz2pi ) ** 2 , dpsidrho ) dpsidrho = dpsidrho / ( 2. * pi ) ! get dpsinorm/drho = (I/2*pi*q)*int_0&#94;{2*pi} dthet jacrho/R**2 ! if using input.profiles, we are given ! dpsitordrho and must use it to compute rgeo if ( abs ( local % dpsitordrho ) > epsilon ( 0. )) then local % rgeo = local % dpsitordrho / dpsidrho dpsidrho = local % dpsitordrho / local % qinp local % d2psidr2 = ( local % d2psitordrho2 - local % dpsitordrho * local % shat / local % rhoc ) & / local % qinp ! I=Btor*R is a flux function ! bi = I/(Btor(psi,theta of Rgeo)*a) = Rgeo/a bi = local % rgeo else ! otherwise, we are given rgeo ! and must use it to compute dpsidrho ! I=Btor*R is a flux function ! bi = I/(Btor(psi,theta of Rgeo)*a) = Rgeo/a bi = local % rgeo + dI * ( rhoc - rhoc0 ) dpsidrho = dpsidrho * bi / local % qinp end if !    ! get dpsinorm/drho !    call get_dpsidrho (dpsidrho) ! get |grad rho| and |grad psi| call get_gradrho ( dpsidrho , grho ) ! quantity needed in calculation of dI/drho and djacrho/drho drz = ( dRdrho * dRdth + dZdrho * dZdth ) / jacrho call get_dthet ( drz , drzdth ) ! get dI/drho call get_dIdrho ( dpsidrho , grho , dIdrho ) dIdrho_out = dIdrho ! get djacobian/drho*dpsi/drho and djacr/drho call get_djacdrho ( dpsidrho , dIdrho , grho ) ! get d2R/drho2 and d2Z/drho2 call get_d2RZdr2 d2R = d2Rdr2 d2Z = d2Zdr2 ! get theta derivative of d2R/drho2 and d2Z/drho2 call get_dthet ( d2Rdr2 , d2Rdr2dth ) call get_dthet ( d2Zdr2 , d2Zdr2dth ) ! calculate the magnitude of B (normalized by B(psi,theta corresponding to Rgeo)) ! B/B0 = sqrt(I**2 + |grad psi|**2)/R bmag = sqrt ( bi ** 2 + gpsi ** 2 ) / Rr ( 2 , :) ! the next line is for multibox runs if ( load_psi0_variables ) then dpsidrho_psi0 = dpsidrho bmag_psi0 = bmag grho_psi0 = grho end if if ( write_profile_variation ) then open ( 1002 , file = 'RZ.out' , status = 'unknown' ) write ( 1002 , '(12e13.5)' ) local % rhoc , dIdrho , local % qinp , local % shat , local % d2qdr2 , & local % kappa , local % kapprim , & local % tri , local % triprim , & local % betaprim , local % betadbprim , dpsidrho do j = - nz , nz write ( 1002 , '(5e13.5)' ) theta ( j ), d2Rdr2 ( j ), d2Zdr2 ( j ), bmag ( j ), grho ( j ) end do close ( 1002 ) end if ! get dB/dtheta call get_dthet ( bmag , dbdth ) ! calculate b . grad theta gradpar = dpsidrho / ( bmag * jacrho ) ! b . grad B gradparb = gradpar * dBdth ! get d|grad rho|&#94;2/drho and d|grad psi|&#94;2/drho call get_dgr2dr ( dpsidrho , grho ) ! get dB/drho and d2B/drho2 call get_dBdrho ( bmag , dIdrho ) ! d (b . grad theta) / drho dgradpardrho = - gradpar * ( dBdrho / bmag + djacdrho / jacrho ) ! get d/dtheta (dB/drho) call get_dthet ( dBdrho , d2Bdrdth ) ! d(b . grad B)/drho dgradparBdrho = dgradpardrho * dBdth + gradpar * d2Bdrdth ! obtain varthet = (I/(q*(dpsi/dr)) * int_0&#94;theta dtheta' jacrho/R&#94;2 call get_varthet ( dpsidrho ) ! obtain dvarthet/drho call get_dvarthdr ( dpsidrho , dIdrho ) ! get |grad theta|&#94;2, grad r . grad theta, grad alpha . grad theta, etc. call get_graddotgrad ( dpsidrho , grho ) call get_gds ( gds2 , gds21 , gds22 , gds23 , gds24 ) ! this is (grad alpha x B) . grad theta cross = dpsidrho * ( gradrho_gradalph * gradalph_gradthet - gradalph2 * gradrho_gradthet ) ! note that the definitions of gbdrift, gbdrift0, dgbdriftdr and dgbdrift0dr ! are such that it gets multiplied by vperp2, not mu.  This is in contrast to ! Michael's GS3 notes ! this is bhat/B x (grad B/B) . grad alpha * 2 * dpsiN/drho gbdrift = 2.0 * ( - dBdrho + cross * dBdth * dpsidrho / bmag ** 2 ) / bmag ! this is bhat/B x (bhat . grad bhat) . grad alpha * 2 * dpsiN/drho ! this is assuming betaprim = 4*pi*ptot/B0&#94;2 * (-d ln ptot / drho) cvdrift = ( gbdrift + 2.0 * local % betaprim / bmag ** 2 ) ! this is 2 *(bhat/B x grad B / B) . (grad q) * dpsiN/drho / (bhat . grad B) ! same as usual GS2 definition once bhat . grad B is added in below cvdrift0 = - 2. * bi * dqdr / bmag ** 2 ! this is 2*dpsiN/drho times the rho derivative (bhat/B x grad B / B) . (grad q) dcvdrift0drho = cvdrift0 * ( dgradparbdrho + gradparb * ( dIdrho / bi - 2. * dBdrho / bmag - local % d2psidr2 / dpsidrho )) & - 2. * bi * gradparb * local % d2qdr2 / bmag ** 2 ! this is 2*dpsiN/drho/B times the rho derivative of (bhat x gradB/B) . (grad q) ! note that there's an extra factor of 1/B that's not expanded due to v_perp -> mu dgbdrift0drho = cvdrift0 * ( dgradparbdrho + gradparb * ( dIdrho / bi - dBdrho / bmag - local % d2psidr2 / dpsidrho )) & - 2. * bi * gradparb * local % d2qdr2 / bmag ** 2 cvdrift0 = cvdrift0 * gradparb ! this is 2 * dpsiN/drho * (bhat/B x gradB/B) . (grad q) gbdrift0 = cvdrift0 ! get d&#94;2I/drho&#94;2 and d&#94;2 Jac / dr&#94;2 call get_d2Idr2_d2jacdr2 ( grho , dIdrho ) ! get d&#94;2varhteta/drho&#94;2 call get_d2varthdr2 ( dpsidrho , dIdrho ) ! get d2B/drho&#94;2 call get_d2Bdr2 ( bmag , dIdrho ) ! get d/dr [(grad alpha x B) . grad theta] call get_dcrossdr ( dpsidrho , dIdrho , grho ) ! dgbdriftdrho is d/drho [(bhat/B x (grad B) . grad alpha) * 2 * dpsiN/drho] / B ! note that there's an extra factor of 1/B that's not expanded due to v_perp -> mu dgbdriftdrho = 2.0 * ( local % d2psidr2 * dBdrho / dpsidrho - d2Bdr2 & + dpsidrho * ( dcrossdr * dBdth + cross * ( d2Bdrdth - 2. * dBdth * dBdrho / bmag )) / bmag ** 2 ) / bmag ! dcvdriftdrho is d/drho (bhat/B x [bhat . grad bhat] . grad alpha) * 2 * dpsiN/drho dcvdriftdrho = dgbdriftdrho - gbdrift * dBdrho / bmag & + 2.0 * local % betadbprim / bmag ** 2 - 4.0 * local % betaprim * dBdrho / bmag ** 3 & - 2.0 * local % betaprim * local % d2psidr2 / dpsidrho !the next two sets of lines are corrections needed for the side boxes in a multibox simulation !gbdrift  = gbdrift *(dpsidrho_psi0/dpsidrho)*(bmag/bmag_psi0) !gbdrift0 = gbdrift0*(dpsidrho_psi0/dpsidrho)*(bmag/bmag_psi0) gbdrift = gbdrift * ( dpsidrho_psi0 / dpsidrho ) gbdrift0 = gbdrift0 * ( dpsidrho_psi0 / dpsidrho ) cvdrift = cvdrift * ( dpsidrho_psi0 / dpsidrho ) cvdrift0 = cvdrift0 * ( dpsidrho_psi0 / dpsidrho ) !dgbdriftdrho  = dgbdriftdrho *(dpsidrho_psi0/dpsidrho)*(bmag/bmag_psi0) !dgbdrift0drho = dgbdrift0drho*(dpsidrho_psi0/dpsidrho)*(bmag/bmag_psi0) dgbdriftdrho = dgbdriftdrho * ( dpsidrho_psi0 / dpsidrho ) dgbdrift0drho = dgbdrift0drho * ( dpsidrho_psi0 / dpsidrho ) dcvdriftdrho = dcvdriftdrho * ( dpsidrho_psi0 / dpsidrho ) dcvdrift0drho = dcvdrift0drho * ( dpsidrho_psi0 / dpsidrho ) ! interpolate here if ( zed_equal_arc ) then call theta_integrate ( 1. / gradpar , dum ) gradpararc = ( theta ( nz ) - theta ( - nz )) / (( 2 * np - 1 ) * dum ) call theta_integrate_indef ( gradpararc / gradpar , arc ) allocate ( zed_arc ( - nzgrid : nzgrid )) call geo_spline ( arc , theta , zed_in , zed_arc ) call geo_spline ( theta , grho_psi0 , zed_arc , grho_out ) !grho is used to normalize fluxes call geo_spline ( theta , bmag , zed_arc , bmag_out ) call geo_spline ( theta , bmag_psi0 , zed_arc , bmag_psi0_out ) call geo_spline ( theta , gds2 , zed_arc , gds2_out ) call geo_spline ( theta , gds21 , zed_arc , gds21_out ) call geo_spline ( theta , gds22 , zed_arc , gds22_out ) call geo_spline ( theta , gds21 , zed_arc , gds23_out ) call geo_spline ( theta , gds21 , zed_arc , gds24_out ) call geo_spline ( theta , gradpararc , zed_arc , gradpar_out ) call geo_spline ( theta , gbdrift , zed_arc , gbdrift_out ) call geo_spline ( theta , gbdrift0 , zed_arc , gbdrift0_out ) call geo_spline ( theta , cvdrift , zed_arc , cvdrift_out ) call geo_spline ( theta , cvdrift0 , zed_arc , cvdrift0_out ) call geo_spline ( theta , dBdrho , zed_arc , dBdrho_out ) call geo_spline ( theta , d2Bdrdth , zed_arc , d2Bdrdth_out ) call geo_spline ( theta , dgradpardrho , zed_arc , dgradpardrho_out ) call geo_spline ( theta , Rr ( 2 , :), zed_arc , rmajor_out ) call geo_spline ( theta , dcvdriftdrho , zed_arc , dcvdriftdrho_out ) call geo_spline ( theta , dgbdriftdrho , zed_arc , dgbdriftdrho_out ) call geo_spline ( theta , dcvdrift0drho , zed_arc , dcvdrift0drho_out ) call geo_spline ( theta , dgbdrift0drho , zed_arc , dgbdrift0drho_out ) call geo_spline ( theta , dgds2dr , zed_arc , dgds2dr_out ) call geo_spline ( theta , dgds21dr , zed_arc , dgds21dr_out ) call geo_spline ( theta , dgds22dr , zed_arc , dgds22dr_out ) call geo_spline ( theta , djacdrho / dpsidrho , zed_arc , djacdrho_out ) deallocate ( zed_arc ) else call geo_spline ( theta , grho_psi0 , zed_in , grho_out ) !grho is used to normalize fluxes call geo_spline ( theta , bmag , zed_in , bmag_out ) call geo_spline ( theta , bmag_psi0 , zed_in , bmag_psi0_out ) call geo_spline ( theta , gds2 , zed_in , gds2_out ) call geo_spline ( theta , gds21 , zed_in , gds21_out ) call geo_spline ( theta , gds22 , zed_in , gds22_out ) call geo_spline ( theta , gds21 , zed_in , gds23_out ) call geo_spline ( theta , gds21 , zed_in , gds24_out ) call geo_spline ( theta , gradpar , zed_in , gradpar_out ) call geo_spline ( theta , gbdrift , zed_in , gbdrift_out ) call geo_spline ( theta , gbdrift0 , zed_in , gbdrift0_out ) call geo_spline ( theta , cvdrift , zed_in , cvdrift_out ) call geo_spline ( theta , cvdrift0 , zed_in , cvdrift0_out ) call geo_spline ( theta , dBdrho , zed_in , dBdrho_out ) call geo_spline ( theta , d2Bdrdth , zed_in , d2Bdrdth_out ) call geo_spline ( theta , dgradpardrho , zed_in , dgradpardrho_out ) call geo_spline ( theta , Rr ( 2 , :), zed_in , rmajor_out ) call geo_spline ( theta , dcvdriftdrho , zed_in , dcvdriftdrho_out ) call geo_spline ( theta , dgbdriftdrho , zed_in , dgbdriftdrho_out ) call geo_spline ( theta , dcvdrift0drho , zed_in , dcvdrift0drho_out ) call geo_spline ( theta , dgbdrift0drho , zed_in , dgbdrift0drho_out ) call geo_spline ( theta , dgds2dr , zed_in , dgds2dr_out ) call geo_spline ( theta , dgds21dr , zed_in , dgds21dr_out ) call geo_spline ( theta , dgds22dr , zed_in , dgds22dr_out ) call geo_spline ( theta , djacdrho / dpsidrho , zed_in , djacdrho_out ) end if ! get the toroidal component of the magnetic field ! btor = B_toroidal/Bref = I/R Bref = rgeo * a/R btor_out = bi / rmajor_out dpsidrho_out = dpsidrho dpsidrho_psi0_out = dpsidrho_psi0 filename = \"millerlocal.\" // trim ( run_name ) // \".input\" open ( 1002 , file = trim ( filename ), status = 'unknown' ) write ( 1002 , '(5a16)' ) '#1.rhoc' , '2.rmaj' , '3.rgeo' , '4.shift' , '5.qinp' write ( 1002 , '(5e16.8)' ) local % rhoc , local % rmaj , local % rgeo , local % shift , local % qinp write ( 1002 , * ) write ( 1002 , '(5a16)' ) '#6.shat' , '7.kappa' , '8.kapprim' , '9.tri' , '10.triprim' write ( 1002 , '(5e16.8)' ) local % shat , local % kappa , local % kapprim , local % tri , local % triprim write ( 1002 , * ) write ( 1002 , '(5a16)' ) '11.betaprim' , '12.dpsitordrho' , '13.rhotor' , & '14.drhotordrho' , '15.d2qdr2' write ( 1002 , '(5e16.8)' ) local % betaprim , local % dpsitordrho , local % rhotor , & local % drhotordrho , local % d2qdr2 write ( 1002 , * ) write ( 1002 , '(3a16)' ) '16.d2psidr2' , '17.betadbprim' , '18.psitor_lcfs' write ( 1002 , '(3e16.8)' ) local % d2psidr2 , local % betadbprim , local % psitor_lcfs close ( 1002 ) filename = \"millerlocal.\" // trim ( run_name ) // \".output\" open ( 1001 , file = trim ( filename ), status = 'unknown' ) write ( 1001 , '(a9,e18.9,a11,e18.9,a11,e18.9)' ) '#dI/dr: ' , dIdrho , 'd2I/dr2: ' , d2Idr2 , 'dpsi/dr: ' , dpsidrho write ( 1001 , '(58a15)' ) '#1.theta' , '2.R' , '3.dR/dr' , '4.d2Rdr2' , '5.dR/dth' , & '6.d2Rdrdth' , '7.dZ/dr' , '8.d2Zdr2' , '9.dZ/dth' , '10.d2Zdrdth' , & '11.bmag' , '12.dBdr' , '13.d2Bdr2' , '14.dB/dth' , '15.d2Bdrdth' , & '16.varthet' , '17.dvarthdr' , '18.d2varthdr2' , '19.jacr' , '20.djacrdr' , & '21.djacdrho' , '22.d2jacdr2' , '23.grho2' , '24.dgr2dr' , '25.gthet2' , & '26.dgt2' , '27.grgthet' , '28.dgrgt' , '29.galphgth' , '30.dgagt' , & '31.grgalph' , '32.dgagr' , '33.galph2' , '34.dga2' , '35.cross' , & '36.dcrossdr' , '37.gbdrift0' , '38.dgbdrift0' , '39.cvdrift0' , '40.dcvdrift0' , & '41.gbdrift' , '42.dgbdrift' , '43.cvdrift' , '44.dcvdrift' , '45.drzdth' , & '46.gradpar' , '47.dgpardr' , '48.gradparB' , '49.dgparBdr' , '50.gds2' , & '51.dgds2dr' , '52.gds21' , '53.dgds21dr' , '54.gds22' , '55.dgds22dr' , & '56.gds23' , '57.gds24' , '58.Zr' do i = - nz , nz write ( 1001 , '(59e18.9)' ) theta ( i ), Rr ( 2 , i ), dRdrho ( i ), d2Rdr2 ( i ), dRdth ( i ), & d2Rdrdth ( i ), dZdrho ( i ), d2Zdr2 ( i ), dZdth ( i ), d2Zdrdth ( i ), & bmag ( i ), dBdrho ( i ), d2Bdr2 ( i ), dBdth ( i ), d2Bdrdth ( i ), & varthet ( i ), dvarthdr ( i ), d2varthdr2 ( i ), jacrho ( i ), djacrdrho ( i ), & djacdrho ( i ), d2jacdr2 ( i ), grho ( i ) ** 2 , dgr2dr ( i ), gradthet2 ( i ), & dgt2 ( i ), gradrho_gradthet ( i ), dgrgt ( i ), gradalph_gradthet ( i ), dgagt ( i ), & gradrho_gradalph ( i ), dgagr ( i ), gradalph2 ( i ), dga2 ( i ), cross ( i ), & dcrossdr ( i ), gbdrift0 ( i ), dgbdrift0drho ( i ), cvdrift0 ( i ), dcvdrift0drho ( i ), & gbdrift ( i ), dgbdriftdrho ( i ), cvdrift ( i ), dcvdriftdrho ( i ), drzdth ( i ), & gradpar ( i ), dgradpardrho ( i ), gradparB ( i ), dgradparBdrho ( i ), gds2 ( i ), & dgds2dr ( i ), gds21 ( i ), dgds21dr ( i ), gds22 ( i ), dgds22dr ( i ), gds23 ( i ), gds24 ( i ), & Zr ( 2 , i ) end do close ( 1001 ) defaults_initialized = . false . end subroutine get_local_geo subroutine allocate_arrays ( nr , nz ) implicit none integer , intent ( in ) :: nr , nz ! periodic quantities can be computed on 2*pi grid and replicated allocate ( grho ( - nz : nz ), bmag ( - nz : nz ), gradpar ( - nz : nz )) allocate ( gds2 ( - nz : nz ), gds21 ( - nz : nz ), gds22 ( - nz : nz ), gds23 ( - nz : nz ), gds24 ( - nz : nz )) allocate ( gbdrift0 ( - nz : nz ), gbdrift ( - nz : nz )) allocate ( cvdrift0 ( - nz : nz ), cvdrift ( - nz : nz )) allocate ( Rr ( nr , - nz : nz ), Zr ( nr , - nz : nz )) allocate ( jacrho ( - nz : nz ), djacdrho ( - nz : nz ), djacrdrho ( - nz : nz ), d2jacdr2 ( - nz : nz )) allocate ( d2Rdrdth ( - nz : nz ), d2Zdrdth ( - nz : nz ), gpsi ( - nz : nz )) allocate ( dBdrho ( - nz : nz ), dgradpardrho ( - nz : nz )) allocate ( d2Bdrdth ( - nz : nz ), dgradparBdrho ( - nz : nz ), dBdth ( - nz : nz ), gradparb ( - nz : nz )) allocate ( dcvdrift0drho ( - nz : nz ), dgbdrift0drho ( - nz : nz )) allocate ( theta ( - nz : nz )) allocate ( gradpararc ( - nz : nz )) allocate ( arc ( - nz : nz )) allocate ( dRdrho ( - nz : nz ), dZdrho ( - nz : nz ), dRdth ( - nz : nz ), dZdth ( - nz : nz )) allocate ( gradrho_gradthet ( - nz : nz ), gradthet2 ( - nz : nz ), dgr2dr ( - nz : nz ), dgpsi2dr ( - nz : nz )) allocate ( dgrgt ( - nz : nz ), dgt2 ( - nz : nz ), dgagr ( - nz : nz ), dgagt ( - nz : nz ), dga2 ( - nz : nz )) allocate ( d2Rdr2 ( - nz : nz ), d2Zdr2 ( - nz : nz ), d2Bdr2 ( - nz : nz )) allocate ( drz ( - nz : nz ), drzdth ( - nz : nz ), d2Rdr2dth ( - nz : nz ), d2Zdr2dth ( - nz : nz )) allocate ( d2Rdth2 ( - nz : nz ), d2Zdth2 ( - nz : nz )) allocate ( d2gpsidr2 ( - nz : nz )) allocate ( gradalph_gradthet ( - nz : nz ), gradalph2 ( - nz : nz ), gradrho_gradalph ( - nz : nz )) allocate ( dgds2dr ( - nz : nz ), dgds21dr ( - nz : nz )) allocate ( dgds22dr ( - nz : nz )) allocate ( dcvdriftdrho ( - nz : nz ), dgbdriftdrho ( - nz : nz )) allocate ( varthet ( - nz : nz ), dvarthdr ( - nz : nz ), d2varthdr2 ( - nz : nz )) allocate ( cross ( - nz : nz )) allocate ( dcrossdr ( - nz : nz )) end subroutine allocate_arrays subroutine deallocate_arrays implicit none deallocate ( grho ) deallocate ( bmag ) deallocate ( gradpar ) deallocate ( gds2 ) deallocate ( gds21 ) deallocate ( gds22 ) deallocate ( gds23 ) deallocate ( gds24 ) deallocate ( gbdrift0 ) deallocate ( gbdrift ) deallocate ( cvdrift0 ) deallocate ( cvdrift ) deallocate ( Rr , Zr ) deallocate ( jacrho , djacdrho , djacrdrho , d2jacdr2 ) deallocate ( d2Rdrdth , d2Zdrdth , gpsi ) deallocate ( dBdrho , dgradpardrho ) deallocate ( d2Bdrdth , dgradparBdrho , dBdth , gradparb ) deallocate ( dcvdrift0drho , dgbdrift0drho ) deallocate ( theta ) deallocate ( gradpararc ) deallocate ( arc ) deallocate ( dRdrho , dZdrho , dRdth , dZdth ) deallocate ( gradrho_gradthet , gradthet2 , dgr2dr , dgpsi2dr ) deallocate ( dgrgt , dgt2 , dgagr , dgagt , dga2 ) deallocate ( d2Rdr2 , d2Zdr2 , d2Bdr2 ) deallocate ( drz , drzdth , d2Rdr2dth , d2Zdr2dth ) deallocate ( d2Rdth2 , d2Zdth2 ) deallocate ( d2gpsidr2 ) deallocate ( gradalph_gradthet , gradalph2 , gradrho_gradalph ) deallocate ( dgds2dr , dgds21dr ) deallocate ( dgds22dr ) deallocate ( dcvdriftdrho , dgbdriftdrho ) deallocate ( varthet , dvarthdr , d2varthdr2 ) deallocate ( cross ) deallocate ( dcrossdr ) deallocate ( d2R , d2Z ) if ( allocated ( delthet )) deallocate ( delthet ) if ( allocated ( bmag_psi0 )) deallocate ( bmag_psi0 ) if ( allocated ( grho_psi0 )) deallocate ( grho_psi0 ) end subroutine deallocate_arrays subroutine finish_local_geo implicit none call deallocate_arrays end subroutine finish_local_geo ! takes in f(r), with r given at three radial locations ! and returns df = df/dr at the middle radius subroutine get_drho ( f , df ) implicit none real , dimension (:, - nz :), intent ( in ) :: f real , dimension ( - nz :), intent ( out ) :: df df = 0.5 * ( f ( 3 , :) - f ( 1 , :)) / local % dr end subroutine get_drho ! given function f(theta), calculate second derivative ! of f with respect to theta ! second order accurate, with equal grid spacing assumed subroutine get_d2dthet2 ( f , d2f ) implicit none real , dimension ( - nz :), intent ( in ) :: f real , dimension ( - nz :), intent ( out ) :: d2f ! assuming equal grid spacing in theta here d2f ( - nz + 1 : nz - 1 ) = ( f (: nz - 2 ) - 2. * f ( - nz + 1 : nz - 1 ) + f ( - nz + 2 :)) / delthet ( - nz + 1 : nz - 1 ) ** 2 ! use periodicity at boundary d2f ( - nz ) = ( f ( nz - 1 ) - 2. * f ( - nz ) + f ( - nz + 1 )) / delthet ( - nz + 1 ) ** 2 d2f ( nz ) = d2f ( - nz ) end subroutine get_d2dthet2 ! given function f(theta:-pi->pi), calculate theta derivative ! second order accurate, with equal grid spacing assumed ! assumes periodic in theta -- may need to change this in future subroutine get_dthet ( f , df ) implicit none real , dimension ( - nz :), intent ( in ) :: f real , dimension ( - nz :), intent ( out ) :: df ! assuming equal grid spacing in theta here df ( - nz + 1 : nz - 1 ) = ( f ( - nz + 2 :) - f (: nz - 2 )) / ( delthet (: nz - 2 ) + delthet ( - nz + 1 :)) ! use periodicity at boundary df ( - nz ) = ( f ( - nz + 1 ) - f ( nz - 1 )) / ( delthet ( - nz ) + delthet ( nz - 1 )) df ( nz ) = df ( - nz ) end subroutine get_dthet subroutine get_jacrho implicit none ! jacrho = R*(dR/drho * dZ/dtheta - dR/dtheta * dZ/drho) jacrho = Rr ( 2 , :) * ( dRdrho * dZdth - dRdth * dZdrho ) end subroutine get_jacrho !   ! get dpsinorm/drho = (I/2*pi*q)*int_0&#94;{2*pi} dthet jacrho/R**2 !   subroutine get_dpsidrho (dpsidrho) !     use constants, only: pi !     implicit none !     real, intent (out) :: dpsidrho !     ! theta_integrate returns integral from 0 -> 2*pi !     call theta_integrate (jacrho(-nz2pi:nz2pi)/Rr(2,-nz2pi:nz2pi)**2, dpsidrho) !     ! integration done using trapezoidal rule !     dpsidrho = dpsidrho*bi/(2.*pi*local%qinp) !   end subroutine get_dpsidrho subroutine get_gradrho ( dpsidrho , grho ) implicit none real , intent ( in ) :: dpsidrho real , dimension ( - nz :), intent ( out ) :: grho grho = Rr ( 2 , :) * sqrt ( dRdth ** 2 + dZdth ** 2 ) / jacrho gpsi = grho * dpsidrho end subroutine get_gradrho subroutine get_dIdrho ( dpsidrho , grho , dIdrho ) use constants , only : pi implicit none real , intent ( in ) :: dpsidrho real , dimension ( - nz :), intent ( in ) :: grho real , intent ( out ) :: dIdrho real :: num1 , num2 , denom real , dimension (:), allocatable :: dum allocate ( dum ( - nz : nz )); dum = 0. dum = jacrho * ( 1.0 + ( bi / gpsi ) ** 2 ) / Rr ( 2 , :) ** 2 call theta_integrate ( dum ( - nz2pi : nz2pi ), denom ) dum = jacrho * ( 2. * dRdrho / Rr ( 2 , :) + dqdr / local % qinp ) / Rr ( 2 , :) ** 2 call theta_integrate ( dum ( - nz2pi : nz2pi ), num1 ) ! betaprim below is (4*pi*ptot/B0&#94;2)*(-d ln ptot / drho) dum = ( - 2. * ( dRdth * d2Rdrdth + dZdth * d2Zdrdth ) / jacrho & + drzdth + local % betaprim * jacrho / dpsidrho ** 2 ) / grho ** 2 call theta_integrate ( dum ( - nz2pi : nz2pi ), num2 ) dIdrho = bi * ( num1 + num2 ) / denom deallocate ( dum ) end subroutine get_dIdrho subroutine get_djacdrho ( dpsidrho , dIdrho , grho ) implicit none real , intent ( in ) :: dpsidrho , dIdrho real , dimension ( - nz :), intent ( in ) :: grho ! this is dpsi/dr * d/dr (jacobian) ! betaprim below is (4*pi*ptot/B0&#94;2)*(-d ln ptot / drho) djacdrho = ( Rr ( 2 , :) / grho ) ** 2 * ( 2. * ( dRdth * d2Rdrdth + dZdth * d2Zdrdth ) / jacrho & - drzdth + jacrho * ( bi * dIdrho / Rr ( 2 , :) ** 2 - local % betaprim ) / dpsidrho ** 2 ) ! this is d/dr (jacobian_r) djacrdrho = djacdrho + jacrho * local % d2psidr2 / dpsidrho end subroutine get_djacdrho subroutine get_d2RZdr2 implicit none ! get factor common to both d2R/drho2 and d2Z/drho2 d2Rdr2 = (( djacrdrho - jacrho * dRdrho / Rr ( 2 , :)) / Rr ( 2 , :) & - dRdrho * d2Zdrdth + dZdrho * d2Rdrdth ) / ( dRdth ** 2 + dZdth ** 2 ) d2Zdr2 = - d2Rdr2 * dRdth d2Rdr2 = d2Rdr2 * dZdth end subroutine get_d2RZdr2 subroutine get_dgr2dr ( dpsidrho , grho ) implicit none real , intent ( in ) :: dpsidrho real , dimension ( - nz :), intent ( in ) :: grho dgr2dr = 2. * ( grho ** 2 * ( dRdrho / Rr ( 2 , :) - djacrdrho / jacrho ) & + ( Rr ( 2 , :) / jacrho ) ** 2 * ( dRdth * d2Rdrdth + d2Zdrdth * dZdth )) dgpsi2dr = 2. * ( gpsi ** 2 * ( dRdrho / Rr ( 2 , :) - djacdrho / jacrho ) & + ( Rr ( 2 , :) / jacrho ) ** 2 * ( dRdth * d2Rdrdth + d2Zdrdth * dZdth ) * dpsidrho ** 2 ) end subroutine get_dgr2dr subroutine get_graddotgrad ( dpsidrho , grho ) implicit none real , intent ( in ) :: dpsidrho real , dimension ( - nz :), intent ( in ) :: grho ! grad theta . grad theta gradthet2 = ( Rr ( 2 , :) / jacrho ) ** 2 * ( dRdrho ** 2 + dZdrho ** 2 ) ! grad rho . grad theta gradrho_gradthet = - ( Rr ( 2 , :) / jacrho ) ** 2 * ( dRdrho * dRdth + dZdrho * dZdth ) ! grad alpha . grad theta gradalph_gradthet = - ( varthet * dqdr + local % qinp * dvarthdr ) * gradrho_gradthet & - bi * jacrho / ( dpsidrho * Rr ( 2 , :) ** 2 ) * gradthet2 ! grad rho . grad alpha gradrho_gradalph = - ( varthet * dqdr + local % qinp * dvarthdr ) * grho ** 2 & - bi * jacrho / ( dpsidrho * Rr ( 2 , :) ** 2 ) * gradrho_gradthet ! grad alpha . grad alpha gradalph2 = ( 1. / Rr ( 2 , :) ** 2 ) + (( varthet * dqdr + local % qinp * dvarthdr ) * grho ) ** 2 & + 2. * bi * jacrho * ( varthet * dqdr + local % qinp * dvarthdr ) * gradrho_gradthet / ( dpsidrho * Rr ( 2 , :) ** 2 ) & + ( bi * jacrho / ( dpsidrho * Rr ( 2 , :) ** 2 )) ** 2 * gradthet2 end subroutine get_graddotgrad subroutine get_gds ( gds2 , gds21 , gds22 , gds23 , gds24 ) implicit none real , dimension ( - nz :), intent ( out ) :: gds2 , gds21 , gds22 , gds23 , gds24 ! |grad alpha|&#94;2 * (dpsiN/drho)&#94;2 (dpsiN/drho factor accounts for ky normalization) gds2 = gradalph2 * dpsidrho_psi0 ** 2 ! (grad q . grad alpha) * (dpsiN/drho)&#94;2 gds21 = gradrho_gradalph * dqdr * dpsidrho_psi0 ** 2 ! |grad q|&#94;2 * (dpsiN/drho)&#94;2 gds22 = ( grho * dpsidrho_psi0 * dqdr ) ** 2 ! (grad rho . grad theta * |grad alpha|&#94;2 - grad alpha . grad theta * grad rho . grad alpha) * (dpsiN/drho)&#94;2 / B&#94;2 gds23 = ( gradrho_gradthet * gradalph2 - gradalph_gradthet * gradrho_gradalph ) * ( dpsidrho_psi0 / bmag ) ** 2 ! (grad rho . grad theta * grad rho . grad alpha - grad alpha . grad theta * |grad rho|&#94;2) * (dpsiN/drho)&#94;2 / B&#94;2 * q/rho gds24 = ( gradrho_gradthet * gradrho_gradalph - gradalph_gradthet * grho ** 2 ) & * ( dpsidrho_psi0 / bmag ) ** 2 * ( local % qinp_psi0 / local % rhoc_psi0 ) ! note that kperp2 = (n0/a)&#94;2*(drho/dpsiN)&#94;2*(gds2 + 2*theta0*gds21 + theta0&#94;2*gds22) ! theta0 = kx/(ky*shat) end subroutine get_gds subroutine get_dBdrho ( bmag , dIdrho ) implicit none real , dimension ( - nz :), intent ( in ) :: bmag real , intent ( in ) :: dIdrho ! dB/drho dBdrho = ( bi * dIdrho + 0.5 * dgpsi2dr ) / ( bmag * Rr ( 2 , :) ** 2 ) & - bmag * dRdrho / Rr ( 2 , :) end subroutine get_dBdrho subroutine get_varthet ( dpsidrho ) implicit none real , intent ( in ) :: dpsidrho call theta_integrate_indef ( jacrho / Rr ( 2 , :) ** 2 , varthet ) varthet = bi * varthet / ( dpsidrho * local % qinp ) end subroutine get_varthet subroutine get_dvarthdr ( dpsidrho , dIdrho ) implicit none real , intent ( in ) :: dpsidrho , dIdrho real , dimension ( - nz : nz ) :: dum dum = bi * jacrho * ( dIdrho / bi - dqdr / local % qinp + djacdrho / jacrho & - 2. * dRdrho / Rr ( 2 , :)) / Rr ( 2 , :) ** 2 call theta_integrate_indef ( dum , dvarthdr ) dvarthdr = dvarthdr / ( dpsidrho * local % qinp ) end subroutine get_dvarthdr subroutine get_d2Idr2_d2jacdr2 ( grho , dIdrho ) use constants , only : pi implicit none real , dimension ( - nz :), intent ( in ) :: grho real , intent ( in ) :: dIdrho real :: denom , num1 , num2 , num3 , num4 real , dimension ( - nz : nz ) :: tmp , tmp2 ! denom is the denominator in the expression for d&#94;2 I / dr&#94;2 tmp = jacrho / Rr ( 2 , :) ** 2 * ( 1.0 + ( bi / gpsi ) ** 2 ) call theta_integrate ( tmp ( - nz2pi : nz2pi ), denom ) denom = denom / bi d2jacdr2 = dIdrho * bi * jacrho / gpsi ** 2 & * ( dIdrho / bi + djacrdrho / jacrho - dgpsi2dr / gpsi ** 2 & - 2. * dRdrho / Rr ( 2 , :)) tmp = - d2jacdr2 / Rr ( 2 , :) ** 2 - dIdrho * jacrho / ( bi * Rr ( 2 , :) ** 2 ) & * ( djacrdrho / jacrho - dIdrho / bi - 2. * dRdrho / Rr ( 2 , :)) call theta_integrate ( tmp ( - nz2pi : nz2pi ), num1 ) ! tmp = -jacrho/(dpsidrho*Rr(2,:)**2)*(djacdrho/jacrho - 2.*dRdrho/Rr(2,:)) ! call theta_integrate (tmp(-nz2pi:nz2pi), num2) ! d2jacdr2 = d2jacdr2 - tmp*Rr(2,:)**2*local%d2psidr2 ! num2 = local%d2psidr2 * (2*pi*local%qinp/bi*(dqdr/local%qinp - dIdrho/bi) + num2) tmp = ( d2Rdr2 * dRdth + dRdrho * d2Rdrdth + d2Zdr2 * dZdth + dZdrho * d2Zdrdth ) / jacrho & - djacrdrho * ( dRdrho * dRdth + dZdrho * dZdth ) / jacrho ** 2 call get_dthet ( tmp , tmp2 ) tmp = ( tmp2 - 2. / jacrho * ( - djacrdrho / jacrho * ( dRdth * d2Rdrdth + dZdth * d2Zdrdth ) & + d2Rdrdth ** 2 + dRdth * d2Rdr2dth + d2Zdrdth ** 2 + dZdth * d2Zdr2dth )) / grho ** 2 & - dgr2dr * ( drzdth - 2. / jacrho * ( dRdth * d2Rdrdth + dZdth * d2Zdrdth )) / grho ** 4 call theta_integrate ( tmp ( - nz2pi : nz2pi ), num2 ) d2jacdr2 = d2jacdr2 - tmp * Rr ( 2 , :) ** 2 tmp = jacrho * ( local % betadbprim + local % betaprim * ( djacrdrho / jacrho - dgpsi2dr / gpsi ** 2 )) / gpsi ** 2 call theta_integrate ( tmp ( - nz2pi : nz2pi ), num3 ) !FLAG - next negative sign? d2jacdr2 = d2jacdr2 - tmp * Rr ( 2 , :) ** 2 tmp = jacrho / Rr ( 2 , :) ** 2 * ( 2. * d2Rdr2 / Rr ( 2 , :) - 2. * ( dRdrho / Rr ( 2 , :)) ** 2 & + local % d2qdr2 / local % qinp - ( dqdr / local % qinp ) ** 2 + ( 2 * dRdrho / Rr ( 2 , :) + dqdr / local % qinp ) & * ( djacrdrho / jacrho - 2. * dRdrho / Rr ( 2 , :))) call theta_integrate ( tmp ( - nz2pi : nz2pi ), num4 ) d2Idr2 = ( num1 + num2 + num3 + num4 ) / denom !    d2jacdr2 = d2jacdr2 + bi*jacrho/(gpsi*Rr(2,:))**2*d2Idr2 + 2.*djacdrho*dRdrho/Rr(2,:)**3 d2jacdr2 = d2jacdr2 + bi * jacrho / gpsi ** 2 * d2Idr2 + 2. * djacdrho * dRdrho / Rr ( 2 , :) end subroutine get_d2Idr2_d2jacdr2 subroutine get_d2varthdr2 ( dpsidrho , dIdrho ) implicit none real , intent ( in ) :: dpsidrho , dIdrho real , dimension ( - nz : nz ) :: dum dum = bi * jacrho / ( local % qinp * dpsidrho * Rr ( 2 , :) ** 2 ) * (( dIdrho / bi - dqdr / local % qinp & !    dum = bi*jacrho/(local%qinp*Rr(2,:)**2)*( (dIdrho/bi - dqdr/local%qinp & + djacdrho / jacrho - 2. * dRdrho / Rr ( 2 , :)) ** 2 & + d2Idr2 / bi - ( dIdrho / bi ) ** 2 - local % d2qdr2 / local % qinp & + ( dqdr / local % qinp ) ** 2 + d2jacdr2 / jacrho - ( djacdrho / jacrho ) ** 2 & - djacdrho * local % d2psidr2 / ( dpsidrho * jacrho ) & - 2. * d2Rdr2 / Rr ( 2 , :) + 2. * ( dRdrho / Rr ( 2 , :)) ** 2 ) call theta_integrate_indef ( dum , d2varthdr2 ) end subroutine get_d2varthdr2 subroutine get_d2Bdr2 ( bmag , dIdrho ) implicit none real , dimension ( - nz :), intent ( in ) :: bmag real , intent ( in ) :: dIdrho ! d2gpsidr2 = 2.*( dgr2dr*(dRdrho/Rr(2,:) - djacdrho/jacrho) & !      + grho**2*(d2Rdr2/Rr(2,:) - (dRdrho/Rr(2,:))**2 - d2jacdr2/jacrho & !      + djacdrho*djacrdrho/jacrho**2) + (Rr(2,:)/jacrho)**2 & !      * (dRdth**2 + dRdth*d2Rdr2dth + dZdth**2 + dZdth*d2Zdr2dth & !      + 2.*(dRdrho/Rr(2,:) - djacrdrho/jacrho)*(dRdth*d2Rdrdth+dZdth*d2Zdrdth)) ) d2gpsidr2 = 2. * ( dRdrho / Rr ( 2 , :) - djacdrho / jacrho ) * dgpsi2dr & + 2. * gpsi ** 2 * ( d2Rdr2 / Rr ( 2 , :) - ( dRdrho / Rr ( 2 , :)) ** 2 - d2jacdr2 / jacrho + djacdrho * djacrdrho / jacrho ** 2 ) & + 2. * ( Rr ( 2 , :) * gpsi / jacrho ) ** 2 * ( d2Rdrdth ** 2 + dRdth * d2Rdr2dth + d2Zdrdth ** 2 + dZdth * d2Zdr2dth & + 2. * ( dRdth * d2Rdrdth + dZdth * d2Zdrdth ) * ( dRdrho / Rr ( 2 , :) - djacdrho / jacrho )) ! d2gpsidr2 = 2.*(dpsidrho*Rr(2,:)/jacrho)**2 & !      * (2.*(dRdrho/Rr(2,:)-djacdrho/jacrho) & !      * ((dRdrho/Rr(2,:)-djacdrho/jacrho)*(dRdth**2+dZdth**2) & !      + 2.*(dRdth*d2Rdrdth+dZdth*d2Zdrdth)) & !      + (dRdth**2+dZdth**2)*(d2rdr2/Rr(2,:) - (dRdrho/Rr(2,:))**2 & !      - d2jacdr2/jacrho + (djacdrho/jacrho)**2) & !      + d2Rdrdth**2 + dRdth*d2Rdr2dth + d2Zdrdth**2 + dZdth*d2Zdr2dth) & !      + 4.*dpsidrho*local%d2psidr2*dgr2dr & !      + 2.*grho**2*(local%d2psidr2**2 + dpsidrho*local%d3psidr3) ! get d/drho (dB/drho) d2Bdr2 = - dBdrho * dRdrho / Rr ( 2 , :) + bmag * ( dRdrho / Rr ( 2 , :)) ** 2 & - bmag * d2Rdr2 / Rr ( 2 , :) + 0.5 * ( 2. * ( dIdrho ** 2 + bi * d2Idr2 ) & + d2gpsidr2 ) / ( bmag * Rr ( 2 , :) ** 2 ) & - ( dBdrho + bmag * dRdrho / Rr ( 2 , :)) * ( 2. * dRdrho / Rr ( 2 , :) + dBdrho / bmag ) end subroutine get_d2Bdr2 subroutine get_dcrossdr ( dpsidrho , dIdrho , grho ) implicit none real , intent ( in ) :: dpsidrho , dIdrho real , dimension ( - nz :), intent ( in ) :: grho ! dgr2 = d/drho (|grad rho|&#94;2) ! dgr2 = 2.*(Rr(2,:)/jacrho)**2*((dRdrho/Rr(2,:)-djacdrho/jacrho)*(dRdth**2+dZdth**2) & !      + dRdth*d2Rdrdth + dZdth*d2Zdrdth) ! dgrgt = d/drho (grad rho . grad theta) !    dgrgt = -(Rr(2,:)/jacrho)**2*(2.*(dRdrho/Rr(2,:)-djacdrho/jacrho)*(dRdrho*dRdth+dZdrho*dZdth) & !         + d2Rdr2*dRdth+dRdrho*d2Rdrdth+d2Zdr2*dZdth+dZdrho*d2Zdrdth) dgrgt = 2. * gradrho_gradthet * ( dRdrho / Rr ( 2 , :) - djacrdrho / jacrho ) & - ( Rr ( 2 , :) / jacrho ) ** 2 * ( d2Rdr2 * dRdth + dRdrho * d2Rdrdth + d2Zdr2 * dZdth + dZdrho * d2Zdrdth ) ! dgt2 = d/drho (|grad theta|&#94;2) dgt2 = 2. * ( Rr ( 2 , :) / jacrho ) ** 2 * (( dRdrho / Rr ( 2 , :) - djacrdrho / jacrho ) * ( dRdrho ** 2 + dZdrho ** 2 ) & + dRdrho * d2Rdr2 + dZdrho * d2Zdr2 ) ! this is d/drho (|grad alph|&#94;2) ! will later multiply it by 0.5*dpsidrho**2 dga2 = - 2 * dRdrho / Rr ( 2 , :) ** 3 + dgr2dr * ( varthet * dqdr + local % qinp * dvarthdr ) ** 2 & + ( 2.0 * grho ** 2 * ( varthet * dqdr + local % qinp * dvarthdr ) & + 2. * bi * jacrho * gradrho_gradthet / ( dpsidrho * Rr ( 2 , :) ** 2 )) & * ( local % d2qdr2 * varthet + 2. * dqdr * dvarthdr + local % qinp * d2varthdr2 ) & + 2. * ( varthet * dqdr + local % qinp * dvarthdr ) * bi * jacrho / ( dpsidrho * Rr ( 2 , :) ** 2 ) & * ( dgrgt + gradrho_gradthet * ( dIdrho / bi + djacdrho / jacrho - 2. * dRdrho / Rr ( 2 , :))) & + ( bi * jacrho / ( dpsidrho * Rr ( 2 , :) ** 2 )) ** 2 * ( dgt2 + 2. * gradthet2 * ( dIdrho / bi + djacdrho / jacrho & - 2. * dRdrho / Rr ( 2 , :))) ! dgagr = d/drho (grad alpha . grad rho) dgagr = - grho ** 2 * ( 2. * dvarthdr * dqdr + varthet * local % d2qdr2 + local % qinp * d2varthdr2 ) & - dgr2dr * ( varthet * dqdr + local % qinp * dvarthdr ) - bi * jacrho / ( dpsidrho * Rr ( 2 , :) ** 2 ) & * ( dgrgt + gradrho_gradthet * ( dIdrho / bi + djacdrho / jacrho - 2. * dRdrho / Rr ( 2 , :))) ! dgagt = d/drho (grad alpha . grad theta) dgagt = - gradrho_gradthet * ( 2. * dvarthdr * dqdr + varthet * local % d2qdr2 + local % qinp * d2varthdr2 ) & - dgrgt * ( varthet * dqdr + local % qinp * dvarthdr ) - bi * jacrho / ( dpsidrho * Rr ( 2 , :) ** 2 ) & * ( dgt2 + gradthet2 * ( dIdrho / bi + djacdrho / jacrho - 2. * dRdrho / Rr ( 2 , :))) ! dcrossdr = d/drho [(grad alpha x B) . grad theta)] dcrossdr = dpsidrho * ( dgagr * gradalph_gradthet + gradrho_gradalph * dgagt & - dga2 * gradrho_gradthet - gradalph2 * dgrgt ) + local % d2psidr2 * cross / dpsidrho ! this is (dpsi/drho)&#94;2*d|grad alpha|&#94;2/dr dgds2dr = dga2 * dpsidrho_psi0 ** 2 ! this is (dpsi/drho)&#94;2*d(grad alpha . grad q)/dr ! note that there will be multiplication by 2 in dist_fn.fpp dgds21dr = ( dgagr * dqdr + local % d2qdr2 * gradrho_gradalph ) * dpsidrho_psi0 ** 2 ! this is (dpsi/drho)&#94;2*d(|grad q|&#94;2)/dr dgds22dr = ( dqdr ** 2 * dgr2dr + 2. * grho ** 2 * dqdr * local % d2qdr2 ) * dpsidrho_psi0 ** 2 ! note that dkperp2/dr = (n0/a)&#94;2*(drho/dpsiN)&#94;2*(dgds2dr + 2*theta0*dgds21dr + theta0&#94;2*dgds22dr) end subroutine get_dcrossdr subroutine theta_integrate ( integrand , integral ) implicit none real , dimension ( - nz2pi :), intent ( in ) :: integrand real , intent ( out ) :: integral ! use trapezoidal rule to integrate in theta integral = 0.5 * sum ( delthet ( - nz2pi : nz2pi - 1 ) * ( integrand ( - nz2pi : nz2pi - 1 ) + integrand ( - nz2pi + 1 : nz2pi ))) end subroutine theta_integrate ! get indefinite integral of integrand subroutine theta_integrate_indef ( integrand , integral ) implicit none real , dimension ( - nz :), intent ( in ) :: integrand real , dimension ( - nz :), intent ( out ) :: integral integer :: i ! use trapezoidal rule to integrate in theta integral ( 0 ) = 0.0 do i = 1 , nz integral ( i ) = integral ( i - 1 ) + 0.5 * delthet ( i - 1 ) * ( integrand ( i - 1 ) + integrand ( i )) end do do i = - 1 , - nz , - 1 integral ( i ) = integral ( i + 1 ) - 0.5 * delthet ( i ) * ( integrand ( i + 1 ) + integrand ( i )) end do end subroutine theta_integrate_indef function Rpos ( r , theta , j ) use constants , only : pi integer , intent ( in ) :: j real , intent ( in ) :: r , theta real :: Rpos real :: g , gp , dr integer :: i dr = r - local % rhoc ! For Y Xiao: !    g = local%delp/local%rhoc + local%d * sin(theta)**2 !    Rpos = local%rmaj*(1.+r*(cos(theta)-g)-g*dr) g = cos ( theta + local % tri * sin ( theta )) gp = - sin ( theta + local % tri * sin ( theta )) & * local % triprim * sin ( theta ) ! allow for strange specification of R_psi if ( j == nz + 1 ) then i = - nz else i = j end if ! second line here is (1/2)*(r-r0)**2*d2R/dr|_r0 ! note that d2R=0 unless read_profile_variation = T in input file Rpos = local % rmaj + local % shift * dr + g * local % rhoc + ( g + local % rhoc * gp ) * dr & + 0.5 * ( r - rhoc0 ) ** 2 * d2R ( i ) end function Rpos function Zpos ( r , theta , j ) integer , intent ( in ) :: j real , intent ( in ) :: r , theta real :: Zpos , dr integer :: i ! allow for strange specification of Z_psi if ( j == nz + 1 ) then i = - nz else i = j end if dr = r - local % rhoc ! note that d2Z=0 unless read_profile_variation=T in input file Zpos = local % kappa * sin ( theta ) * local % rhoc + ( local % rhoc * local % kapprim + local % kappa ) * sin ( theta ) * dr & + 0.5 * ( r - rhoc0 ) ** 2 * d2Z ( i ) end function Zpos function mod2pi ( theta ) real , intent ( in ) :: theta real :: pi , th , mod2pi real , parameter :: theta_tol = 1.e-6 logical :: out pi = 2. * acos ( 0. ) if ( theta <= pi . and . theta >= - pi ) then mod2pi = theta return end if if ( theta - theta_tol <= pi . and . theta >= - pi ) then mod2pi = pi return end if if ( theta <= pi . and . theta + theta_tol >= - pi ) then mod2pi = - pi return end if th = theta out = . true . do while ( out ) if ( th > pi ) th = th - 2. * pi if ( th < - pi ) th = th + 2. * pi if ( th <= pi . and . th >= - pi ) out = . false . end do mod2pi = th end function mod2pi end module millerlocal","tags":"","loc":"sourcefile/millerlocal.f90.html"},{"title":"vmec_to_stella_geometry_interface.f90 â€“ stella","text":"Contents Modules vmec_to_stella_geometry_interface_mod Source Code vmec_to_stella_geometry_interface.f90 Source Code ! vmec_to_stella_geometry_interface.f90 ! Initial code written by Matt Landreman, University of Maryland in August 2017. ! Skip down ~25 lines for detailed description of the input and output parameters. ! Modified 2018-2019 by Michael Barnes module vmec_to_stella_geometry_interface_mod implicit none private public :: vmec_to_stella_geometry_interface public :: get_nominal_vmec_zeta_grid public :: read_vmec_equilibrium real :: theta_pest_target , zeta0 real , dimension ( 2 ) :: vmec_radial_weight_full , vmec_radial_weight_half integer , dimension ( 2 ) :: vmec_radial_index_full , vmec_radial_index_half logical :: lasym integer :: nfp , isigng integer :: ns , mnmax , mnmax_nyq integer :: mpol , ntor real :: Aminor real , dimension (:), allocatable :: xm , xn real , dimension (:), allocatable :: xm_nyq , xn_nyq real , dimension (:, :), allocatable :: rmnc , rmns real , dimension (:, :), allocatable :: lmnc , lmns real , dimension (:, :), allocatable :: zmnc , zmns real , dimension (:, :), allocatable :: bmnc , bmns real , dimension (:, :), allocatable :: gmnc , gmns real , dimension (:, :), allocatable :: bsupumnc , bsupumns real , dimension (:, :), allocatable :: bsupvmnc , bsupvmns real , dimension (:, :), allocatable :: bsubumnc , bsubumns real , dimension (:, :), allocatable :: bsubvmnc , bsubvmns real , dimension (:, :), allocatable :: bsubsmnc , bsubsmns real , dimension (:), allocatable :: phi , phip , iotas , iotaf , presf contains subroutine read_vmec_equilibrium ( vmec_filename ) use read_wout_mod , only : read_wout_file , read_wout_deallocate use read_wout_mod , only : nfp_vmec => nfp use read_wout_mod , only : lasym_vmec => lasym use read_wout_mod , only : isigng_vmec => isigng use read_wout_mod , only : Aminor_vmec => Aminor use read_wout_mod , only : ns_vmec => ns use read_wout_mod , only : mnmax_nyq_vmec => mnmax_nyq use read_wout_mod , only : mnmax_vmec => mnmax use read_wout_mod , only : mpol_vmec => mpol use read_wout_mod , only : ntor_vmec => ntor use read_wout_mod , only : xm_vmec => xm use read_wout_mod , only : xn_vmec => xn use read_wout_mod , only : xm_nyq_vmec => xm_nyq use read_wout_mod , only : xn_nyq_vmec => xn_nyq use read_wout_mod , only : phi_vmec => phi use read_wout_mod , only : phip_vmec => phip use read_wout_mod , only : lmnc_vmec => lmnc use read_wout_mod , only : lmns_vmec => lmns use read_wout_mod , only : rmnc_vmec => rmnc use read_wout_mod , only : rmns_vmec => rmns use read_wout_mod , only : zmnc_vmec => zmnc use read_wout_mod , only : zmns_vmec => zmns use read_wout_mod , only : bmnc_vmec => bmnc use read_wout_mod , only : bmns_vmec => bmns use read_wout_mod , only : gmnc_vmec => gmnc use read_wout_mod , only : gmns_vmec => gmns use read_wout_mod , only : bsupumnc_vmec => bsupumnc use read_wout_mod , only : bsupvmnc_vmec => bsupvmnc use read_wout_mod , only : bsupumns_vmec => bsupumns use read_wout_mod , only : bsupvmns_vmec => bsupvmns use read_wout_mod , only : bsubumnc_vmec => bsubumnc use read_wout_mod , only : bsubvmnc_vmec => bsubvmnc use read_wout_mod , only : bsubumns_vmec => bsubumns use read_wout_mod , only : bsubvmns_vmec => bsubvmns use read_wout_mod , only : bsubsmnc_vmec => bsubsmnc use read_wout_mod , only : bsubsmns_vmec => bsubsmns use read_wout_mod , only : iotas_vmec => iotas use read_wout_mod , only : iotaf_vmec => iotaf use read_wout_mod , only : presf_vmec => presf implicit none ! vmec_filename is the vmec wout_* file that will be read. character ( * ), intent ( in ) :: vmec_filename integer :: ierr , iopen !********************************************************************* ! Read in everything from the vmec wout file using libstell. !********************************************************************* write ( * , '(A)' ) \"############################################################\" write ( * , '(A)' ) \"                       MAGNETIC FIELD\" write ( * , '(A)' ) \"############################################################\" write ( * , * ) \"About to read VMEC wout file: '\" , trim ( vmec_filename ), \"'.\" call read_wout_file ( vmec_filename , ierr , iopen ) if ( iopen /= 0 ) stop 'error opening wout file' if ( ierr /= 0 ) stop 'error reading wout file' write ( * , * ) \"Successfully read VMEC data from '\" , trim ( vmec_filename ), \"'.\" nfp = nfp_vmec lasym = lasym_vmec isigng = isigng_vmec aminor = aminor_vmec ns = ns_vmec mnmax = mnmax_vmec mnmax_nyq = mnmax_nyq_vmec mpol = mpol_vmec ntor = ntor_vmec write ( * , * ) \" \" write ( * , * ) \"  Characteristics of the magnetic field:\" write ( * , '(A44, I1)' ) \"      Number of field periods (nfp):\" // repeat ( ' ' , 50 ), nfp write ( * , '(A44, L1)' ) \"      Stellarator-asymmetric? (lasym):\" // repeat ( ' ' , 50 ), lasym if (. not . allocated ( rmnc )) then allocate ( xm ( mnmax )); xm = xm_vmec allocate ( xn ( mnmax )); xn = xn_vmec allocate ( xm_nyq ( mnmax_nyq )); xm_nyq = xm_nyq_vmec allocate ( xn_nyq ( mnmax_nyq )); xn_nyq = xn_nyq_vmec allocate ( rmnc ( mnmax , ns )); rmnc = rmnc_vmec allocate ( lmns ( mnmax , ns )); lmns = lmns_vmec allocate ( zmns ( mnmax , ns )); zmns = zmns_vmec allocate ( bmnc ( mnmax_nyq , ns )); bmnc = bmnc_vmec allocate ( gmnc ( mnmax_nyq , ns )); gmnc = gmnc_vmec allocate ( bsupumnc ( mnmax_nyq , ns )); bsupumnc = bsupumnc_vmec allocate ( bsupvmnc ( mnmax_nyq , ns )); bsupvmnc = bsupvmnc_vmec allocate ( bsubumnc ( mnmax_nyq , ns )); bsubumnc = bsubumnc_vmec allocate ( bsubvmnc ( mnmax_nyq , ns )); bsubvmnc = bsubvmnc_vmec allocate ( bsubsmns ( mnmax_nyq , ns )); bsubsmns = bsubsmns_vmec allocate ( phi ( ns )); phi = phi_vmec allocate ( phip ( ns )); phip = phip_vmec allocate ( iotas ( ns )); iotas = iotas_vmec allocate ( iotaf ( ns )); iotaf = iotaf_vmec allocate ( presf ( ns )); presf = presf_vmec if ( lasym ) then allocate ( rmns ( mnmax , ns )); rmns = rmns_vmec allocate ( lmnc ( mnmax , ns )); lmnc = lmnc_vmec allocate ( zmnc ( mnmax , ns )); zmnc = zmnc_vmec allocate ( bmns ( mnmax_nyq , ns )); bmns = bmns_vmec allocate ( gmns ( mnmax_nyq , ns )); gmns = gmns_vmec allocate ( bsupumns ( mnmax_nyq , ns )); bsupumns = bsupumns_vmec allocate ( bsupvmns ( mnmax_nyq , ns )); bsupvmns = bsupvmns_vmec allocate ( bsubumns ( mnmax_nyq , ns )); bsubumns = bsubumns_vmec allocate ( bsubvmns ( mnmax_nyq , ns )); bsubvmns = bsubvmns_vmec allocate ( bsubsmnc ( mnmax_nyq , ns )); bsubsmnc = bsubsmnc_vmec end if end if ! deallocate all arrays opened externally in read_wout_mod call read_wout_deallocate end subroutine read_vmec_equilibrium subroutine get_nominal_vmec_zeta_grid ( nzgrid , zeta_center , number_of_field_periods_stella , & number_of_field_periods_device , zeta ) implicit none ! 2*nzgrid+1 is the number of zeta grid points for the nominal zeta grid integer , intent ( in ) :: nzgrid ! The zeta domain is centered at zeta_center. Setting zeta_center = 2*pi*N/nfp for any integer N should ! yield identical results to setting zeta_center = 0, where nfp is the number of field periods (as in VMEC). real , intent ( in ) :: zeta_center ! number_of_field_periods_device is the number of field periods sampled by stella real , intent ( in out ) :: number_of_field_periods_stella ! number_of_field_periods_device is the number of field periods for the device real , intent ( out ) :: number_of_field_periods_device ! On exit, zeta holds the nominal grid points in the toroidal angle zeta real , dimension ( - nzgrid :), intent ( out ) :: zeta real , parameter :: pi = 3.1415926535897932d+0 integer :: j number_of_field_periods_device = nfp if ( number_of_field_periods_stella < 0.0 ) & number_of_field_periods_stella = number_of_field_periods_device zeta = [( zeta_center + ( pi * j * number_of_field_periods_stella ) / ( nfp * nzgrid ), j =- nzgrid , nzgrid )] end subroutine get_nominal_vmec_zeta_grid subroutine vmec_to_stella_geometry_interface ( nalpha , alpha0 , nzgrid , & zeta_center , number_of_field_periods_to_include , & desired_normalized_toroidal_flux , vmec_surface_option , verbose , & normalized_toroidal_flux_used , safety_factor_q , shat , L_reference , B_reference , nfp_out , & sign_toroidal_flux , & alpha , zeta , bmag , gradpar_zeta , grad_alpha_grad_alpha , & grad_alpha_grad_psi , grad_psi_grad_psi , gds23 , gds24 , gds25 , gds26 , & gbdrift_alpha , gbdrift0_psi , cvdrift_alpha , cvdrift0_psi , & theta_vmec , B_sub_zeta , B_sub_theta_vmec , x_displacement_fac ) use fzero_mod , only : fzero implicit none !********************************************************************* ! Input parameters !********************************************************************* ! nalpha is the number of grid points in the alpha coordinate: integer , intent ( in ) :: nalpha ! alpha0 is the first alpha value to include in the alpha grid real , intent ( in ) :: alpha0 ! The zeta grid has nzgrid*2+1 points, including the \"repeated\" point at index -nzgrid and +nzgrid. integer , intent ( in ) :: nzgrid ! The zeta domain is centered at zeta_center. Setting zeta_center = 2*pi*N/nfp for any integer N should ! yield identical results to setting zeta_center = 0, where nfp is the number of field periods (as in VMEC). real , intent ( in ) :: zeta_center ! If number_of_field_periods_to_include is > 0, then this parameter does what you think: ! the extent of the toroidal in zeta will be 2*pi*number_of_field_periods_to_include/nfp. ! If number_of_field_periods_to_include is <= 0, the entire 2*pi toroidal domain will be included. real , intent ( in ) :: number_of_field_periods_to_include ! The parameter desired_normalized_toroidal_flux determines which flux surface from the VMEC file will be used ! for the computation. This parameter should lie in the interval [0,1]. real , intent ( in ) :: desired_normalized_toroidal_flux ! If vmec_surface_option = 0, the magnetic surface specified by desired_normalized_toroidal_flux will be used, ! by interpolating between the surfaces available in the vmec file. ! If vmec_surface_option = 1, the magnetic surface on vmec's HALF radial mesh will be used that is closest to desired_normalized_toroidal_flux. ! If vmec_surface_option = 2, the magnetic surface on vmec's FULL radial mesh will be used that is closest to desired_normalized_toroidal_flux. ! Other values of vmec_surface_option will cause the program to abort with an error. integer , intent ( in ) :: vmec_surface_option ! If verbose is .true. in the vmec_parameters namelist, lots of diagnostic information is printed. logical , intent ( in ) :: verbose !********************************************************************* ! Output quantities !********************************************************************* ! On exit, normalized_toroidal_flux_used holds the flux surface that was actually used for the geometry, ! as measured by psi_toroidal / psi_{toroidal,edge} real , intent ( out ) :: normalized_toroidal_flux_used ! Safety factor q = 1/iota real , intent ( out ) :: safety_factor_q ! Magnetic shear shat = (x/q) * (d q / d x) where x = Aminor_p * sqrt(psi_toroidal / psi_{toroidal,edge}) ! and Aminor_p is the minor radius calculated by VMEC. real , intent ( out ) :: shat ! L_reference is the reference length used for stella normalization, in meters. real , intent ( out ) :: L_reference ! B_reference is the reference magnetic field strength used for stella normalization, in Tesla. real , intent ( out ) :: B_reference ! nfp is the number of field periods given by VMEC real , intent ( out ) :: nfp_out integer , intent ( out ) :: sign_toroidal_flux ! On exit, alpha holds the grid points in alpha = theta_p - iota * zeta, where theta_p is the PEST toroidal angle real , dimension (:), intent ( out ) :: alpha ! On exit, zeta holds the grid points in the toroidal angle zeta real , dimension ( - nzgrid :), intent ( out ) :: zeta real , dimension (:, - nzgrid :), intent ( out ) :: theta_vmec real , dimension (:, - nzgrid :), intent ( out ) :: bmag ! gradpar_zeta = b . grad zeta, with zeta the physical toroidal angle ! taken to increase in the counter-clockwise direction real , dimension (:, - nzgrid :), intent ( out ) :: gradpar_zeta ! grad alpha . grad alpha in units of 1/L_ref&#94;2, with alpha = theta_pest - iota * zeta real , dimension (:, - nzgrid :), intent ( out ) :: grad_alpha_grad_alpha ! grad alpha . grad psi_t in units of B_ref, with alpha = theta_pest - iota * zeta real , dimension (:, - nzgrid :), intent ( out ) :: grad_alpha_grad_psi ! grad psi_t . grad psi_t in units of (a*B_ref)&#94;2, with alpha = theta_pest - iota * zeta real , dimension (:, - nzgrid :), intent ( out ) :: grad_psi_grad_psi ! 2 * bhat/B x (grad B / B) . grad alpha * B_ref * L_ref&#94;2 real , dimension (:, - nzgrid :), intent ( out ) :: gbdrift_alpha ! 2 * bhat/B x (bhat . grad bhat) . grad alpha * B_ref * L_ref&#94;2 real , dimension (:, - nzgrid :), intent ( out ) :: cvdrift_alpha real , dimension (:, - nzgrid :), intent ( out ) :: gds23 , gds24 , gds25 , gds26 !    real, dimension (:,-nzgrid:), intent (out) :: gbdrift, gbdrift0, cvdrift, cvdrift0 real , dimension (:, - nzgrid :), intent ( out ) :: gbdrift0_psi , cvdrift0_psi real , dimension (:, - nzgrid :), intent ( out ) :: B_sub_theta_vmec , B_sub_zeta real , dimension (:, - nzgrid :), intent ( out ) :: x_displacement_fac !********************************************************************* ! Variables used internally by this subroutine !********************************************************************* real , parameter :: pi = 3.1415926535897932d+0 real , parameter :: zero = 0.0d+0 real , parameter :: one = 1.0d+0 real , parameter :: mu_0 = 4 * pi * ( 1.0d-7 ) integer :: j , index , izeta , ialpha , isurf , m , n , imn , imn_nyq real :: angle , sin_angle , cos_angle , temp , edge_toroidal_flux_over_2pi !    integer :: fzero_flag real :: number_of_field_periods_to_include_final real :: dphi , iota , min_dr2 , ds , d_pressure_d_s , d_iota_d_s , scale_factor real :: theta_vmec_min , theta_vmec_max , sqrt_s real , dimension (:), allocatable :: dr2 , normalized_toroidal_flux_full_grid , normalized_toroidal_flux_half_grid real , dimension (:), allocatable :: d_pressure_d_s_on_half_grid , d_iota_d_s_on_half_grid !    real :: root_solve_absolute_tolerance, root_solve_relative_tolerance logical :: non_Nyquist_mode_available , found_imn real , dimension (:, :), allocatable :: R , Z real , dimension (:, :), allocatable :: B , sqrt_g , B_dot_grad_theta_pest_over_B_dot_grad_zeta , temp2D real , dimension (:, :), allocatable :: d_B_d_theta_vmec , d_B_d_zeta , d_B_d_s real , dimension (:, :), allocatable :: d_R_d_theta_vmec , d_R_d_zeta , d_R_d_s real , dimension (:, :), allocatable :: d_Z_d_theta_vmec , d_Z_d_zeta , d_Z_d_s real , dimension (:, :), allocatable :: d_X_d_theta_vmec , d_X_d_zeta , d_X_d_s real , dimension (:, :), allocatable :: d_Y_d_theta_vmec , d_Y_d_zeta , d_Y_d_s real , dimension (:, :), allocatable :: d_Lambda_d_theta_vmec , d_Lambda_d_zeta , d_Lambda_d_s !real, dimension(:,:), allocatable :: B_sub_s, B_sub_theta_vmec, B_sub_zeta real , dimension (:, :), allocatable :: B_sub_s real , dimension (:, :), allocatable :: B_sup_theta_vmec , B_sup_zeta real , dimension (:), allocatable :: d_B_d_s_mnc , d_B_d_s_mns real , dimension (:), allocatable :: d_R_d_s_mnc , d_R_d_s_mns real , dimension (:), allocatable :: d_Z_d_s_mnc , d_Z_d_s_mns real , dimension (:), allocatable :: d_Lambda_d_s_mnc , d_Lambda_d_s_mns real , dimension (:, :), allocatable :: grad_s_X , grad_s_Y , grad_s_Z real , dimension (:, :), allocatable :: grad_theta_vmec_X , grad_theta_vmec_Y , grad_theta_vmec_Z real , dimension (:, :), allocatable :: grad_theta_pest_X , grad_theta_pest_Y , grad_theta_pest_Z real , dimension (:, :), allocatable :: grad_zeta_X , grad_zeta_Y , grad_zeta_Z real , dimension (:, :), allocatable :: grad_psi_X , grad_psi_Y , grad_psi_Z real , dimension (:, :), allocatable :: grad_alpha_X , grad_alpha_Y , grad_alpha_Z real , dimension (:, :), allocatable :: B_cross_grad_B_dot_grad_alpha , B_cross_grad_B_dot_grad_alpha_alternate real , dimension (:, :), allocatable :: B_cross_grad_s_dot_grad_alpha , B_cross_grad_s_dot_grad_alpha_alternate real , dimension (:, :), allocatable :: grad_B_X , grad_B_Y , grad_B_Z real , dimension (:, :), allocatable :: B_X , B_Y , B_Z real , dimension (:, :), allocatable :: gradzeta_grady , gradzeta_gradx real , dimension (:, :), allocatable :: gradtheta_grady , gradtheta_gradx logical :: theta_converged !********************************************************************* ! VMEC variables of interest: ! ns = number of flux surfaces used by VMEC ! nfp = number of field periods, e.g. 5 for W7-X, 4 for HSX ! iotas = rotational transform (1/q) on the half grid. ! iotaf = rotational transform on the full grid. ! presf = pressure on the full grid. ! ! All VMEC quantities (B, pressure, etc) are in SI units. ! ! In VMEC, quantities on the half grid have the same number of array elements (ns) as quantities on the full grid, ! but the first array element is 0. ! !********************************************************************* !********************************************************************* ! Beginning of executable statements. !********************************************************************* !    if (verbose) print *,\"Entering subroutine vmec_to_stella_geometry_interface.\" !********************************************************************* ! Do some validation. !********************************************************************* if ( nalpha < 1 ) then print * , \"Error! nalpha must be >= 1. Instead it is\" , nalpha stop end if if ( nzgrid < 1 ) then print * , \"Error! nzgrid must be >= 1. Instead it is\" , nzgrid stop end if if ( desired_normalized_toroidal_flux <= 0 ) then print * , \"Error! desired_normalized_toroidal_flux must be >0. Instead it is\" , desired_normalized_toroidal_flux stop end if if ( desired_normalized_toroidal_flux > 1 ) then print * , \"Error! desired_normalized_toroidal_flux must be <= 1. Instead it is\" , desired_normalized_toroidal_flux stop end if nfp_out = nfp ! There is a bug in libstell read_wout_file for ASCII-format wout files, in which the xm_nyq and xn_nyq arrays are sometimes ! not populated. The next few lines here provide a workaround: if ( maxval ( abs ( xm_nyq )) < 1 . and . maxval ( abs ( xn_nyq )) < 1 ) then if ( mnmax_nyq == mnmax ) then if ( verbose ) print * , \"xm_nyq and xn_nyq arrays are not populated in the wout file. Using xm and xn instead.\" xm_nyq = xm xn_nyq = xn else print * , \"Error! xm_nyq and xn_nyq arrays are not populated in the wout file, and mnmax_nyq != mnmax.\" stop end if end if edge_toroidal_flux_over_2pi = phi ( ns ) / ( 2 * pi ) * isigng ! isigns is called signgs in the wout*.nc file. Why is this signgs here? ! this gives the sign of the edge toroidal flux sign_toroidal_flux = int ( sign ( 1.1 , edge_toroidal_flux_over_2pi )) if ( verbose ) write ( * , '(A43, I2)' ) \"      Sign of the toroidal flux from VMEC:\" // repeat ( ' ' , 50 ), sign_toroidal_flux ! Set reference length and magnetic field for stella's normalization, ! using the choices made by Pavlos Xanthopoulos in GIST: L_reference = Aminor ! Note that 'Aminor' in read_wout_mod is called 'Aminor_p' in the wout*.nc file. !    B_reference = 2 * edge_toroidal_flux_over_2pi / (L_reference * L_reference) B_reference = 2 * abs ( edge_toroidal_flux_over_2pi ) / ( L_reference * L_reference ) if ( verbose ) then write ( * , * ) \"  \" write ( * , * ) \"  Reference values for the stella normalization:\" write ( * , '(A42, F15.12, A7)' ) \"      Reference length (minor radius a):\" // repeat ( ' ' , 50 ), L_reference , \" meters\" write ( * , '(A42, F15.12, A6)' ) \"      Reference magnetic field strength:\" // repeat ( ' ' , 50 ), B_reference , \" Tesla\" end if ! -------------------------------------------------------------------------------- ! Do some sanity checking to ensure the VMEC arrays have some expected properties. ! -------------------------------------------------------------------------------- ! 'phi' is vmec's array of the toroidal flux (not divided by 2pi!) on vmec's radial grid. if ( abs ( phi ( 1 )) > 1 d - 14 ) then print * , \"Error! VMEC phi array does not begin with 0.\" print * , \"phi:\" , phi stop end if dphi = phi ( 2 ) - phi ( 1 ) do j = 3 , ns if ( abs ( phi ( j ) - phi ( j - 1 ) - dphi ) > 1 d - 11 ) then print * , \"Error! VMEC phi array is not uniformly spaced.\" print * , \"phi:\" , phi stop end if end do ! The variable called 'phips' in the wout file is called just 'phip' in read_wout_mod.F. ! phips is on the half-mesh, so skip first point. do j = 2 , ns if ( abs ( phip ( j ) + phi ( ns ) / ( 2 * pi )) > 1 d - 11 ) then print * , \"Error! VMEC phips array is not constant and equal to -phi(ns)/(2*pi).\" print * , \"phip(s):\" , phip stop end if end do ! The first mode in the m and n arrays should be m=n=0: if ( xm ( 1 ) /= 0 ) stop \"First element of xm in the wout file should be 0.\" if ( xn ( 1 ) /= 0 ) stop \"First element of xn in the wout file should be 0.\" if ( xm_nyq ( 1 ) /= 0 ) stop \"First element of xm_nyq in the wout file should be 0.\" if ( xn_nyq ( 1 ) /= 0 ) stop \"First element of xn_nyq in the wout file should be 0.\" ! Lambda should be on the half mesh, so its value at radial index 1 should be 0 for all (m,n) if ( maxval ( abs ( lmns (:, 1 ))) > 0 ) then print * , \"Error! Expected lmns to be on the half mesh, but its value at radial index 1 is nonzero.\" print * , \"Here comes lmns(:,1):\" , lmns (:, 1 ) stop end if if ( lasym ) then if ( maxval ( abs ( lmnc (:, 1 ))) > 0 ) then print * , \"Error! Expected lmnc to be on the half mesh, but its value at radial index 1 is nonzero.\" print * , \"Here comes lmnc(:,1):\" , lmnc (:, 1 ) stop end if end if ! -------------------------------------------------------------------------------- ! End of sanity checks. ! -------------------------------------------------------------------------------- allocate ( normalized_toroidal_flux_full_grid ( ns )) normalized_toroidal_flux_full_grid = [( real ( j - 1 ) / ( ns - 1 ), j = 1 , ns )] ! Build an array of the half grid points: allocate ( normalized_toroidal_flux_half_grid ( ns - 1 )) do j = 1 , ns - 1 normalized_toroidal_flux_half_grid ( j ) = ( normalized_toroidal_flux_full_grid ( j ) + normalized_toroidal_flux_full_grid ( j + 1 )) * ( 0.5d+0 ) end do !********************************************************************* ! Determine which flux surface to use, based on ! desired_normalized_toroidal_flux and vmec_surface_option. !********************************************************************* ! Possible values of vmec_surface_option: ! 0 = Use the exact radius requested. ! 1 = Use the nearest value of the VMEC half grid. ! 2 = Use the nearest value of the VMEC full grid. select case ( vmec_surface_option ) case ( 0 ) ! Use exact radius requested. normalized_toroidal_flux_used = desired_normalized_toroidal_flux case ( 1 ) ! Use nearest value of the VMEC half grid ! Compute differences allocate ( dr2 ( ns - 1 )) dr2 = ( normalized_toroidal_flux_half_grid - desired_normalized_toroidal_flux ) ** 2 index = 1 min_dr2 = dr2 ( 1 ) ! Find the index of minimum error: do j = 2 , ns - 1 if ( dr2 ( j ) < min_dr2 ) then index = j min_dr2 = dr2 ( j ) end if end do normalized_toroidal_flux_used = normalized_toroidal_flux_half_grid ( index ) deallocate ( dr2 ) case ( 2 ) ! Use nearest value of the VMEC full grid ! Compute differences allocate ( dr2 ( ns )) dr2 = ( normalized_toroidal_flux_full_grid - desired_normalized_toroidal_flux ) ** 2 index = 1 min_dr2 = dr2 ( 1 ) ! Find the index of minimum error: do j = 2 , ns if ( dr2 ( j ) < min_dr2 ) then index = j min_dr2 = dr2 ( j ) end if end do normalized_toroidal_flux_used = normalized_toroidal_flux_full_grid ( index ) deallocate ( dr2 ) case default print * , \"Error! vmec_surface_option must be 0, 1, or 2. It is instead \" , vmec_surface_option stop end select ! -------------------------------------------------------------------------------- ! Done choosing the actual radius to use. ! -------------------------------------------------------------------------------- ! In general, we get quantities for stella by linear interpolation, taking a weighted average of the quantity from ! 2 surfaces in the VMEC file. Sometimes the weights are 0 and 1, i.e. no interpolation is needed. ! For any VMEC quantity Q on the full grid, the value used in stella will be !  Q_stella = Q(vmec_radial_index_full(1))*vmec_radial_weight_full(1) + Q(vmec_radial_index_full(2))*vmec_radial_weight_full(2) ! For any VMEC quantity Q on the half grid, the value used in stella will be !  Q_stella = Q(vmec_radial_index_half(1))*vmec_radial_weight_half(1) + Q(vmec_radial_index_half(2))*vmec_radial_weight_half(2) ! Handle quantities for the full grid if ( normalized_toroidal_flux_used > 1 ) then stop \"Error! normalized_toroidal_flux_used cannot be >1\" elseif ( normalized_toroidal_flux_used < 0 ) then stop \"Error! normalized_toroidal_flux_used cannot be <0\" elseif ( normalized_toroidal_flux_used == 1 ) then vmec_radial_index_full ( 1 ) = ns - 1 vmec_radial_index_full ( 2 ) = ns vmec_radial_weight_full ( 1 ) = zero else ! normalized_toroidal_flux_used is >= 0 and <1 ! This is the most common case. vmec_radial_index_full ( 1 ) = floor ( normalized_toroidal_flux_used * ( ns - 1 )) + 1 vmec_radial_index_full ( 2 ) = vmec_radial_index_full ( 1 ) + 1 vmec_radial_weight_full ( 1 ) = vmec_radial_index_full ( 1 ) - normalized_toroidal_flux_used * ( ns - one ) end if vmec_radial_weight_full ( 2 ) = one - vmec_radial_weight_full ( 1 ) ! Handle quantities for the half grid if ( normalized_toroidal_flux_used < normalized_toroidal_flux_half_grid ( 1 )) then print * , \"Warning: extrapolating beyond the end of VMEC's half grid.\" print * , \"(Extrapolating towards the magnetic axis.) Results are likely to be inaccurate.\" ! We start at element 2 since element 1 is always 0 for quantities on the half grid. vmec_radial_index_half ( 1 ) = 2 vmec_radial_index_half ( 2 ) = 3 vmec_radial_weight_half ( 1 ) = ( normalized_toroidal_flux_half_grid ( 2 ) - normalized_toroidal_flux_used ) / ( normalized_toroidal_flux_half_grid ( 2 ) - normalized_toroidal_flux_half_grid ( 1 )) elseif ( normalized_toroidal_flux_used > normalized_toroidal_flux_half_grid ( ns - 1 )) then print * , \"Warning: extrapolating beyond the end of VMEC's half grid.\" print * , \"(Extrapolating towards the last closed flux surface.) Results may be inaccurate.\" vmec_radial_index_half ( 1 ) = ns - 1 vmec_radial_index_half ( 2 ) = ns vmec_radial_weight_half ( 1 ) = ( normalized_toroidal_flux_half_grid ( ns - 1 ) - normalized_toroidal_flux_used ) & / ( normalized_toroidal_flux_half_grid ( ns - 1 ) - normalized_toroidal_flux_half_grid ( ns - 2 )) elseif ( normalized_toroidal_flux_used == normalized_toroidal_flux_half_grid ( ns - 1 )) then ! We are exactly at the last point of the half grid vmec_radial_index_half ( 1 ) = ns - 1 vmec_radial_index_half ( 2 ) = ns vmec_radial_weight_half ( 1 ) = zero else ! normalized_toroidal_flux_used is inside the half grid. ! This is the most common case. vmec_radial_index_half ( 1 ) = floor ( normalized_toroidal_flux_used * ( ns - 1 ) + 0.5d+0 ) + 1 if ( vmec_radial_index_half ( 1 ) < 2 ) then ! This can occur sometimes due to roundoff error. vmec_radial_index_half ( 1 ) = 2 end if vmec_radial_index_half ( 2 ) = vmec_radial_index_half ( 1 ) + 1 vmec_radial_weight_half ( 1 ) = vmec_radial_index_half ( 1 ) - normalized_toroidal_flux_used * ( ns - one ) - ( 0.5d+0 ) end if vmec_radial_weight_half ( 2 ) = one - vmec_radial_weight_half ( 1 ) !     if (verbose) then !        if (abs(vmec_radial_weight_half(1)) < 1e-14) then !           print \"(a,i4,a,i4,a)\",\"   Using radial index \",vmec_radial_index_half(2),\" of \",ns,\" from vmec's half mesh.\" !        elseif (abs(vmec_radial_weight_half(2)) < 1e-14) then !           print \"(a,i4,a,i4,a)\",\"   Using radial index \",vmec_radial_index_half(1),\" of \",ns,\" from vmec's half mesh.\" !        else !           print \"(a,i4,a,i4,a,i4,a)\", \"   Interpolating using radial indices \",vmec_radial_index_half(1),\" and \",vmec_radial_index_half(2),& !                \" of \",ns,\" from vmec's half mesh.\" !           print \"(a,f17.14,a,f17.14)\", \"   Weights for half mesh = \",vmec_radial_weight_half(1),\" and \",vmec_radial_weight_half(2) !           print \"(a,i4,a,i4,a,i4,a)\", \"   Interpolating using radial indices \",vmec_radial_index_full(1),\" and \",vmec_radial_index_full(2),& !                \" of \",ns,\" from vmec's full mesh.\" !           print \"(a,f17.14,a,f17.14)\", \"   Weights for full mesh = \",vmec_radial_weight_full(1),\" and \",vmec_radial_weight_full(2) !        end if !     end if !********************************************************************* ! Evaluate several radial-profile functions at the flux surface ! we ended up choosing. !********************************************************************* if ( verbose ) write ( * , * ) \" \" if ( verbose ) write ( * , * ) \"  Radial-profile functions at the chosen flux surface:\" iota = iotas ( vmec_radial_index_half ( 1 )) * vmec_radial_weight_half ( 1 ) & + iotas ( vmec_radial_index_half ( 2 )) * vmec_radial_weight_half ( 2 ) if ( verbose ) write ( * , '(A21, F15.12)' ) \"      iota:\" // repeat ( ' ' , 50 ), iota safety_factor_q = 1 / iota allocate ( d_iota_d_s_on_half_grid ( ns )) d_iota_d_s_on_half_grid = 0 ds = normalized_toroidal_flux_full_grid ( 2 ) - normalized_toroidal_flux_full_grid ( 1 ) if ( verbose ) write ( * , '(A21, ES20.12E3)' ) \"      ds:\" // repeat ( ' ' , 50 ), ds d_iota_d_s_on_half_grid ( 2 : ns ) = ( iotaf ( 2 : ns ) - iotaf ( 1 : ns - 1 )) / ds d_iota_d_s = & d_iota_d_s_on_half_grid ( vmec_radial_index_half ( 1 )) * vmec_radial_weight_half ( 1 ) & + d_iota_d_s_on_half_grid ( vmec_radial_index_half ( 2 )) * vmec_radial_weight_half ( 2 ) deallocate ( d_iota_d_s_on_half_grid ) if ( verbose ) write ( * , '(A21, ES20.12E3)' ) \"      diota/ds:\" // repeat ( ' ' , 50 ), d_iota_d_s ! shat = (r/q)(dq/dr) where r = a sqrt(s). !      = - (r/iota) (d iota / d r) = -2 (s/iota) (d iota / d s) shat = ( - 2 * normalized_toroidal_flux_used / iota ) * d_iota_d_s allocate ( d_pressure_d_s_on_half_grid ( ns )) d_pressure_d_s_on_half_grid = 0 ds = normalized_toroidal_flux_full_grid ( 2 ) - normalized_toroidal_flux_full_grid ( 1 ) d_pressure_d_s_on_half_grid ( 2 : ns ) = ( presf ( 2 : ns ) - presf ( 1 : ns - 1 )) / ds d_pressure_d_s = & d_pressure_d_s_on_half_grid ( vmec_radial_index_half ( 1 )) * vmec_radial_weight_half ( 1 ) & + d_pressure_d_s_on_half_grid ( vmec_radial_index_half ( 2 )) * vmec_radial_weight_half ( 2 ) deallocate ( d_pressure_d_s_on_half_grid ) if ( verbose ) write ( * , '(A21, ES20.12E3)' ) \"      dpressure/ds:\" // repeat ( ' ' , 50 ), d_pressure_d_s if ( verbose ) write ( * , * ) \" \" !********************************************************************* ! Set up the coordinate grids. !********************************************************************* alpha = [( alpha0 + (( j - 1 ) * 2 * pi ) / nalpha , j = 1 , nalpha )] !!$    if (number_of_field_periods_to_include > nfp) then !!$       print *,\"Error! number_of_field_periods_to_include > nfp\" !!$       print *,\"  number_of_field_periods_to_include =\",number_of_field_periods_to_include !!$       print *,\"  nfp =\",nfp !!$       stop !!$    end if number_of_field_periods_to_include_final = number_of_field_periods_to_include if ( number_of_field_periods_to_include <= 0 ) then number_of_field_periods_to_include_final = nfp if ( verbose ) print * , \"   Since number_of_field_periods_to_include was <= 0, it is being reset to nfp =\" , nfp end if zeta = [( zeta_center + ( pi * j * number_of_field_periods_to_include_final ) / ( nfp * nzgrid ), j =- nzgrid , nzgrid )] !********************************************************************* ! We know theta_pest = alpha + iota * zeta, but we need to determine ! theta_vmec = theta_pest - Lambda. !********************************************************************* if ( verbose ) print * , \"Beginning root solves to determine theta_vmec.\" do izeta = - nzgrid , nzgrid zeta0 = zeta ( izeta ) do ialpha = 1 , nalpha theta_pest_target = alpha ( ialpha ) + iota * zeta0 ! Guess that theta_vmec will be within 0.3 radians of theta_pest: theta_vmec_min = theta_pest_target - 0.3 theta_vmec_max = theta_pest_target + 0.3 call get_root ( theta_vmec_min , theta_vmec_max , theta_vmec ( ialpha , izeta ), theta_converged ) ! In the 4th argument, we are telling the root-finder (fzero) to use theta_pest as the initial guess for theta_vmec. !          call fzero(fzero_residual, theta_vmec_min, theta_vmec_max, theta_pest_target, & !               root_solve_relative_tolerance, root_solve_absolute_tolerance, fzero_flag) ! Note: fzero returns its answer in theta_vmec_min. !          theta_vmec(ialpha,izeta) = theta_vmec_min !          if (fzero_flag == 4) then !             stop \"ERROR: fzero returned error 4: no sign change in residual\" !          else if (fzero_flag > 2) then !             print *,\"WARNING: fzero returned an error code:\",fzero_flag !          end if if (. not . theta_converged ) then write ( * , * ) \"ERROR: could not find root needed to compute theta_vmec. aborting\" stop end if end do end do !    if (verbose) then !       do izeta = -nzgrid, nzgrid !          do ialpha = 1, nalpha !             write (*,*) 'theta_vmec', alpha(ialpha), zeta(izeta), theta_vmec(ialpha,izeta) !          end do !          write (*,*) !       end do !    end if !********************************************************************* ! Initialize geometry arrays !********************************************************************* bmag = 0 gradpar_zeta = 0 grad_alpha_grad_alpha = 0.0 grad_alpha_grad_psi = 0.0 grad_psi_grad_psi = 0.0 gds23 = 0.0 gds24 = 0.0 gds25 = 0.0 gds26 = 0.0 gbdrift_alpha = 0 gbdrift0_psi = 0 cvdrift_alpha = 0 cvdrift0_psi = 0 B_sub_theta_vmec = 0 B_sub_zeta = 0 allocate ( B ( nalpha , - nzgrid : nzgrid )) allocate ( temp2D ( nalpha , - nzgrid : nzgrid )) allocate ( sqrt_g ( nalpha , - nzgrid : nzgrid )) allocate ( R ( nalpha , - nzgrid : nzgrid )) allocate ( Z ( nalpha , - nzgrid : nzgrid )) allocate ( d_B_d_theta_vmec ( nalpha , - nzgrid : nzgrid )) allocate ( d_B_d_zeta ( nalpha , - nzgrid : nzgrid )) allocate ( d_B_d_s ( nalpha , - nzgrid : nzgrid )) allocate ( d_R_d_theta_vmec ( nalpha , - nzgrid : nzgrid )) allocate ( d_R_d_zeta ( nalpha , - nzgrid : nzgrid )) allocate ( d_R_d_s ( nalpha , - nzgrid : nzgrid )) allocate ( d_Z_d_theta_vmec ( nalpha , - nzgrid : nzgrid )) allocate ( d_Z_d_zeta ( nalpha , - nzgrid : nzgrid )) allocate ( d_Z_d_s ( nalpha , - nzgrid : nzgrid )) allocate ( d_Lambda_d_theta_vmec ( nalpha , - nzgrid : nzgrid )) allocate ( d_Lambda_d_zeta ( nalpha , - nzgrid : nzgrid )) allocate ( d_Lambda_d_s ( nalpha , - nzgrid : nzgrid )) allocate ( B_sub_s ( nalpha , - nzgrid : nzgrid )) !allocate(B_sub_theta_vmec(nalpha,-nzgrid:nzgrid)) !allocate(B_sub_zeta(nalpha,-nzgrid:nzgrid)) allocate ( B_sup_theta_vmec ( nalpha , - nzgrid : nzgrid )) allocate ( B_sup_zeta ( nalpha , - nzgrid : nzgrid )) allocate ( d_B_d_s_mnc ( ns )) allocate ( d_B_d_s_mns ( ns )) allocate ( d_R_d_s_mnc ( ns )) allocate ( d_R_d_s_mns ( ns )) allocate ( d_Z_d_s_mnc ( ns )) allocate ( d_Z_d_s_mns ( ns )) allocate ( d_Lambda_d_s_mnc ( ns )) allocate ( d_Lambda_d_s_mns ( ns )) allocate ( d_X_d_s ( nalpha , - nzgrid : nzgrid )) allocate ( d_X_d_theta_vmec ( nalpha , - nzgrid : nzgrid )) allocate ( d_X_d_zeta ( nalpha , - nzgrid : nzgrid )) allocate ( d_Y_d_s ( nalpha , - nzgrid : nzgrid )) allocate ( d_Y_d_theta_vmec ( nalpha , - nzgrid : nzgrid )) allocate ( d_Y_d_zeta ( nalpha , - nzgrid : nzgrid )) allocate ( grad_s_X ( nalpha , - nzgrid : nzgrid )) allocate ( grad_s_Y ( nalpha , - nzgrid : nzgrid )) allocate ( grad_s_Z ( nalpha , - nzgrid : nzgrid )) allocate ( grad_theta_vmec_X ( nalpha , - nzgrid : nzgrid )) allocate ( grad_theta_vmec_Y ( nalpha , - nzgrid : nzgrid )) allocate ( grad_theta_vmec_Z ( nalpha , - nzgrid : nzgrid )) allocate ( grad_theta_pest_X ( nalpha , - nzgrid : nzgrid )) allocate ( grad_theta_pest_Y ( nalpha , - nzgrid : nzgrid )) allocate ( grad_theta_pest_Z ( nalpha , - nzgrid : nzgrid )) allocate ( grad_zeta_X ( nalpha , - nzgrid : nzgrid )) allocate ( grad_zeta_Y ( nalpha , - nzgrid : nzgrid )) allocate ( grad_zeta_Z ( nalpha , - nzgrid : nzgrid )) allocate ( grad_psi_X ( nalpha , - nzgrid : nzgrid )) allocate ( grad_psi_Y ( nalpha , - nzgrid : nzgrid )) allocate ( grad_psi_Z ( nalpha , - nzgrid : nzgrid )) allocate ( grad_alpha_X ( nalpha , - nzgrid : nzgrid )) allocate ( grad_alpha_Y ( nalpha , - nzgrid : nzgrid )) allocate ( grad_alpha_Z ( nalpha , - nzgrid : nzgrid )) allocate ( B_X ( nalpha , - nzgrid : nzgrid )) allocate ( B_Y ( nalpha , - nzgrid : nzgrid )) allocate ( B_Z ( nalpha , - nzgrid : nzgrid )) allocate ( grad_B_X ( nalpha , - nzgrid : nzgrid )) allocate ( grad_B_Y ( nalpha , - nzgrid : nzgrid )) allocate ( grad_B_Z ( nalpha , - nzgrid : nzgrid )) allocate ( B_cross_grad_B_dot_grad_alpha ( nalpha , - nzgrid : nzgrid )) allocate ( B_cross_grad_B_dot_grad_alpha_alternate ( nalpha , - nzgrid : nzgrid )) allocate ( B_cross_grad_s_dot_grad_alpha ( nalpha , - nzgrid : nzgrid )) allocate ( B_cross_grad_s_dot_grad_alpha_alternate ( nalpha , - nzgrid : nzgrid )) allocate ( gradzeta_grady ( nalpha , - nzgrid : nzgrid )) allocate ( gradzeta_gradx ( nalpha , - nzgrid : nzgrid )) allocate ( gradtheta_grady ( nalpha , - nzgrid : nzgrid )) allocate ( gradtheta_gradx ( nalpha , - nzgrid : nzgrid )) B = 0 sqrt_g = 0 R = 0.0 Z = 0.0 d_B_d_theta_vmec = 0 d_B_d_zeta = 0 d_B_d_s = 0 d_R_d_theta_vmec = 0 d_R_d_zeta = 0 d_R_d_s = 0 d_Z_d_theta_vmec = 0 d_Z_d_zeta = 0 d_Z_d_s = 0 d_Lambda_d_theta_vmec = 0 d_Lambda_d_zeta = 0 d_Lambda_d_s = 0 B_sub_s = 0 B_sub_theta_vmec = 0 B_sub_zeta = 0 B_sup_theta_vmec = 0 B_sup_zeta = 0 !********************************************************************* ! Now that we know the grid points in theta_vmec, we can evaluate ! all the geometric quantities on the grid points. !********************************************************************* do imn_nyq = 1 , mnmax_nyq ! All the quantities we need except R, Z, and Lambda use the _nyq mode numbers. m = int ( xm_nyq ( imn_nyq )) n = int ( xn_nyq ( imn_nyq ) / nfp ) if ( abs ( m ) >= mpol . or . abs ( n ) > ntor ) then non_Nyquist_mode_available = . false . else non_Nyquist_mode_available = . true . ! Find the imn in the non-Nyquist arrays that corresponds to the same m and n. found_imn = . false . do imn = 1 , mnmax if ( xm ( imn ) == m . and . xn ( imn ) == n * nfp ) then found_imn = . true . exit end if end do if (( xm ( imn ) /= m ) . or . ( xn ( imn ) /= n * nfp )) stop \"Something went wrong!\" if (. not . found_imn ) stop \"Error! imn could not be found matching the given imn_nyq.\" end if ! All quantities are multiplied by a variable scale_factor which can in principle depend on m and n. ! For now we just set scale_factor = 1. In the future, scale_factor could be used to lower the ! symmetry-breaking Fourier components, or filter out certain Fourier components in some way. scale_factor = 1 ! ----------------------------------------------------- ! First, consider just the stellarator-symmetric terms: ! ----------------------------------------------------- ! Evaluate the radial derivatives we will need: ! B and Lambda are on the half mesh, so their radial derivatives are on the full mesh. ! R and Z are on the full mesh, so their radial derivatives are on the half mesh. d_B_d_s_mnc ( 2 : ns - 1 ) = ( bmnc ( imn_nyq , 3 : ns ) - bmnc ( imn_nyq , 2 : ns - 1 )) / ds ! Simplistic extrapolation at the endpoints: d_B_d_s_mnc ( 1 ) = d_B_d_s_mnc ( 2 ) d_B_d_s_mnc ( ns ) = d_B_d_s_mnc ( ns - 1 ) if ( non_Nyquist_mode_available ) then ! R is on the full mesh: d_R_d_s_mnc ( 2 : ns ) = ( rmnc ( imn , 2 : ns ) - rmnc ( imn , 1 : ns - 1 )) / ds d_R_d_s_mnc ( 1 ) = 0 ! Z is on the full mesh: d_Z_d_s_mns ( 2 : ns ) = ( zmns ( imn , 2 : ns ) - zmns ( imn , 1 : ns - 1 )) / ds d_Z_d_s_mns ( 1 ) = 0 ! Lambda is on the half mesh: d_Lambda_d_s_mns ( 2 : ns - 1 ) = ( lmns ( imn , 3 : ns ) - lmns ( imn , 2 : ns - 1 )) / ds ! Simplistic extrapolation at the endpoints: d_Lambda_d_s_mns ( 1 ) = d_Lambda_d_s_mns ( 2 ) d_Lambda_d_s_mns ( ns ) = d_Lambda_d_s_mns ( ns - 1 ) else d_R_d_s_mnc = 0 d_Z_d_s_mns = 0 d_Lambda_d_s_mns = 0 end if ! End of evaluating radial derivatives. do ialpha = 1 , nalpha do izeta = - nzgrid , nzgrid angle = m * theta_vmec ( ialpha , izeta ) - n * nfp * zeta ( izeta ) cos_angle = cos ( angle ) sin_angle = sin ( angle ) do isurf = 1 , 2 ! Handle |B|: temp = bmnc ( imn_nyq , vmec_radial_index_half ( isurf )) * vmec_radial_weight_half ( isurf ) temp = temp * scale_factor B ( ialpha , izeta ) = B ( ialpha , izeta ) + temp * cos_angle d_B_d_theta_vmec ( ialpha , izeta ) = d_B_d_theta_vmec ( ialpha , izeta ) - m * temp * sin_angle d_B_d_zeta ( ialpha , izeta ) = d_B_d_zeta ( ialpha , izeta ) + n * nfp * temp * sin_angle ! Handle Jacobian: temp = gmnc ( imn_nyq , vmec_radial_index_half ( isurf )) * vmec_radial_weight_half ( isurf ) temp = temp * scale_factor sqrt_g ( ialpha , izeta ) = sqrt_g ( ialpha , izeta ) + temp * cos_angle ! Handle B sup theta: temp = bsupumnc ( imn_nyq , vmec_radial_index_half ( isurf )) * vmec_radial_weight_half ( isurf ) temp = temp * scale_factor B_sup_theta_vmec ( ialpha , izeta ) = B_sup_theta_vmec ( ialpha , izeta ) + temp * cos_angle ! Handle B sup zeta: temp = bsupvmnc ( imn_nyq , vmec_radial_index_half ( isurf )) * vmec_radial_weight_half ( isurf ) temp = temp * scale_factor B_sup_zeta ( ialpha , izeta ) = B_sup_zeta ( ialpha , izeta ) + temp * cos_angle ! Handle B sub theta: temp = bsubumnc ( imn_nyq , vmec_radial_index_half ( isurf )) * vmec_radial_weight_half ( isurf ) temp = temp * scale_factor B_sub_theta_vmec ( ialpha , izeta ) = B_sub_theta_vmec ( ialpha , izeta ) + temp * cos_angle ! Handle B sub zeta: temp = bsubvmnc ( imn_nyq , vmec_radial_index_half ( isurf )) * vmec_radial_weight_half ( isurf ) temp = temp * scale_factor B_sub_zeta ( ialpha , izeta ) = B_sub_zeta ( ialpha , izeta ) + temp * cos_angle ! Handle B sub psi. ! Unlike the other components of B, this one is on the full mesh. temp = bsubsmns ( imn_nyq , vmec_radial_index_full ( isurf )) * vmec_radial_weight_full ( isurf ) temp = temp * scale_factor B_sub_s ( ialpha , izeta ) = B_sub_s ( ialpha , izeta ) + temp * sin_angle ! Handle d B / d s ! Since bmnc is on the half mesh, its radial derivative is on the full mesh. temp = d_B_d_s_mnc ( vmec_radial_index_full ( isurf )) * vmec_radial_weight_full ( isurf ) temp = temp * scale_factor d_B_d_s ( ialpha , izeta ) = d_B_d_s ( ialpha , izeta ) + temp * cos_angle ! Handle arrays that use xm and xn instead of xm_nyq and xn_nyq. if ( non_Nyquist_mode_available ) then ! Handle R, which is on the full mesh temp = rmnc ( imn , vmec_radial_index_full ( isurf )) * vmec_radial_weight_full ( isurf ) temp = temp * scale_factor R ( ialpha , izeta ) = R ( ialpha , izeta ) + temp * cos_angle d_R_d_theta_vmec ( ialpha , izeta ) = d_R_d_theta_vmec ( ialpha , izeta ) - temp * m * sin_angle d_R_d_zeta ( ialpha , izeta ) = d_R_d_zeta ( ialpha , izeta ) + temp * n * nfp * sin_angle ! Handle Z, which is on the full mesh temp = zmns ( imn , vmec_radial_index_full ( isurf )) * vmec_radial_weight_full ( isurf ) temp = temp * scale_factor Z ( ialpha , izeta ) = Z ( ialpha , izeta ) + temp * sin_angle !Z(ialpha,izeta) = Z(ialpha,izeta) + temp * sin_angle  ! We don't actually need Z itself, only derivatives of Z. d_Z_d_theta_vmec ( ialpha , izeta ) = d_Z_d_theta_vmec ( ialpha , izeta ) + temp * m * cos_angle d_Z_d_zeta ( ialpha , izeta ) = d_Z_d_zeta ( ialpha , izeta ) - temp * n * nfp * cos_angle ! Handle Lambda: temp = lmns ( imn , vmec_radial_index_half ( isurf )) * vmec_radial_weight_half ( isurf ) temp = temp * scale_factor ! We don't need Lambda itself, just its derivatives. d_Lambda_d_theta_vmec ( ialpha , izeta ) = d_Lambda_d_theta_vmec ( ialpha , izeta ) + m * temp * cos_angle d_Lambda_d_zeta ( ialpha , izeta ) = d_Lambda_d_zeta ( ialpha , izeta ) - n * nfp * temp * cos_angle ! Handle d R / d s ! Since R is on the full mesh, its radial derivative is on the half mesh. temp = d_R_d_s_mnc ( vmec_radial_index_half ( isurf )) * vmec_radial_weight_half ( isurf ) temp = temp * scale_factor d_R_d_s ( ialpha , izeta ) = d_R_d_s ( ialpha , izeta ) + temp * cos_angle ! Handle d Z / d s ! Since Z is on the full mesh, its radial derivative is on the half mesh. temp = d_Z_d_s_mns ( vmec_radial_index_half ( isurf )) * vmec_radial_weight_half ( isurf ) temp = temp * scale_factor d_Z_d_s ( ialpha , izeta ) = d_Z_d_s ( ialpha , izeta ) + temp * sin_angle ! Handle d Lambda / d s ! Since Lambda is on the half mesh, its radial derivative is on the full mesh. temp = d_Lambda_d_s_mns ( vmec_radial_index_full ( isurf )) * vmec_radial_weight_full ( isurf ) temp = temp * scale_factor d_Lambda_d_s ( ialpha , izeta ) = d_Lambda_d_s ( ialpha , izeta ) + temp * sin_angle end if end do end do end do ! ----------------------------------------------------- ! Now consider the stellarator-asymmetric terms. ! ----------------------------------------------------- if ( lasym ) then ! Evaluate the radial derivatives we will need: ! B and Lambda are on the half mesh, so their radial derivatives are on the full mesh. ! R and Z are on the full mesh, so their radial derivatives are on the half mesh. d_B_d_s_mns ( 2 : ns - 1 ) = ( bmns ( imn_nyq , 3 : ns ) - bmns ( imn_nyq , 2 : ns - 1 )) / ds ! Simplistic extrapolation at the endpoints: d_B_d_s_mns ( 1 ) = d_B_d_s_mns ( 2 ) d_B_d_s_mns ( ns ) = d_B_d_s_mns ( ns - 1 ) if ( non_Nyquist_mode_available ) then ! R is on the full mesh: d_R_d_s_mns ( 2 : ns ) = ( rmns ( imn , 2 : ns ) - rmns ( imn , 1 : ns - 1 )) / ds d_R_d_s_mns ( 1 ) = 0 ! Z is on the full mesh: d_Z_d_s_mnc ( 2 : ns ) = ( zmnc ( imn , 2 : ns ) - zmnc ( imn , 1 : ns - 1 )) / ds d_Z_d_s_mnc ( 1 ) = 0 ! Lambda is on the half mesh: d_Lambda_d_s_mnc ( 2 : ns - 1 ) = ( lmnc ( imn_nyq , 3 : ns ) - lmnc ( imn_nyq , 2 : ns - 1 )) / ds ! Simplistic extrapolation at the endpoints: d_Lambda_d_s_mnc ( 1 ) = d_Lambda_d_s_mnc ( 2 ) d_Lambda_d_s_mnc ( ns ) = d_Lambda_d_s_mnc ( ns - 1 ) else d_R_d_s_mns = 0 d_Z_d_s_mnc = 0 d_Lambda_d_s_mnc = 0 end if ! End of evaluating radial derivatives. do ialpha = 1 , nalpha do izeta = - nzgrid , nzgrid angle = m * theta_vmec ( ialpha , izeta ) - n * nfp * zeta ( izeta ) cos_angle = cos ( angle ) sin_angle = sin ( angle ) do isurf = 1 , 2 ! Handle |B|: temp = bmns ( imn_nyq , vmec_radial_index_half ( 1 )) * vmec_radial_weight_half ( 1 ) temp = temp * scale_factor B ( ialpha , izeta ) = B ( ialpha , izeta ) + temp * sin_angle d_B_d_theta_vmec ( ialpha , izeta ) = d_B_d_theta_vmec ( ialpha , izeta ) + m * temp * cos_angle d_B_d_zeta ( ialpha , izeta ) = d_B_d_zeta ( ialpha , izeta ) - n * nfp * temp * cos_angle ! Handle Jacobian: temp = gmns ( imn_nyq , vmec_radial_index_half ( isurf )) * vmec_radial_weight_half ( isurf ) temp = temp * scale_factor sqrt_g ( ialpha , izeta ) = sqrt_g ( ialpha , izeta ) + temp * sin_angle ! Handle B sup theta: temp = bsupumns ( imn_nyq , vmec_radial_index_half ( isurf )) * vmec_radial_weight_half ( isurf ) temp = temp * scale_factor B_sup_theta_vmec ( ialpha , izeta ) = B_sup_theta_vmec ( ialpha , izeta ) + temp * sin_angle ! Handle B sup zeta: temp = bsupvmns ( imn_nyq , vmec_radial_index_half ( isurf )) * vmec_radial_weight_half ( isurf ) temp = temp * scale_factor B_sup_zeta ( ialpha , izeta ) = B_sup_zeta ( ialpha , izeta ) + temp * sin_angle ! Handle B sub theta: temp = bsubumns ( imn_nyq , vmec_radial_index_half ( isurf )) * vmec_radial_weight_half ( isurf ) temp = temp * scale_factor B_sub_theta_vmec ( ialpha , izeta ) = B_sub_theta_vmec ( ialpha , izeta ) + temp * sin_angle ! Handle B sub zeta: temp = bsubvmns ( imn_nyq , vmec_radial_index_half ( isurf )) * vmec_radial_weight_half ( isurf ) temp = temp * scale_factor B_sub_zeta ( ialpha , izeta ) = B_sub_zeta ( ialpha , izeta ) + temp * sin_angle ! Handle B sub psi. ! Unlike the other components of B, this one is on the full mesh. temp = bsubsmnc ( imn_nyq , vmec_radial_index_full ( isurf )) * vmec_radial_weight_full ( isurf ) temp = temp * scale_factor B_sub_s ( ialpha , izeta ) = B_sub_s ( ialpha , izeta ) + temp * cos_angle ! Handle d B / d s. ! Since bmns is on the half mesh, its radial derivative is on the full mesh. temp = d_B_d_s_mns ( vmec_radial_index_full ( isurf )) * vmec_radial_weight_full ( isurf ) temp = temp * scale_factor d_B_d_s ( ialpha , izeta ) = d_B_d_s ( ialpha , izeta ) + temp * sin_angle ! Handle arrays that use xm and xn instead of xm_nyq and xn_nyq. if ( non_Nyquist_mode_available ) then ! Handle R, which is on the full mesh temp = rmns ( imn , vmec_radial_index_full ( isurf )) * vmec_radial_weight_full ( isurf ) temp = temp * scale_factor R ( ialpha , izeta ) = R ( ialpha , izeta ) + temp * sin_angle d_R_d_theta_vmec ( ialpha , izeta ) = d_R_d_theta_vmec ( ialpha , izeta ) + temp * m * cos_angle d_R_d_zeta ( ialpha , izeta ) = d_R_d_zeta ( ialpha , izeta ) - temp * n * nfp * cos_angle ! Handle Z, which is on the full mesh temp = zmnc ( imn , vmec_radial_index_full ( isurf )) * vmec_radial_weight_full ( isurf ) temp = temp * scale_factor Z ( ialpha , izeta ) = Z ( ialpha , izeta ) + temp * cos_angle ! We don't actually need Z itself, only derivatives of Z. d_Z_d_theta_vmec ( ialpha , izeta ) = d_Z_d_theta_vmec ( ialpha , izeta ) - temp * m * sin_angle d_Z_d_zeta ( ialpha , izeta ) = d_Z_d_zeta ( ialpha , izeta ) + temp * n * nfp * sin_angle ! Handle Lambda, which is on the half mesh temp = lmnc ( imn , vmec_radial_index_half ( isurf )) * vmec_radial_weight_half ( isurf ) temp = temp * scale_factor ! We don't actually need Lambda itself, only derivatives of Lambda. d_Lambda_d_theta_vmec ( ialpha , izeta ) = d_Lambda_d_theta_vmec ( ialpha , izeta ) - temp * m * sin_angle d_Lambda_d_zeta ( ialpha , izeta ) = d_Lambda_d_zeta ( ialpha , izeta ) + temp * n * nfp * sin_angle ! Handle d R / d s. ! Since R is on the full mesh, its radial derivative is on the half mesh. temp = d_R_d_s_mns ( vmec_radial_index_half ( isurf )) * vmec_radial_weight_half ( isurf ) temp = temp * scale_factor d_R_d_s ( ialpha , izeta ) = d_R_d_s ( ialpha , izeta ) + temp * sin_angle ! Handle d Z / d s. ! Since Z is on the full mesh, its radial derivative is on the half mesh. temp = d_Z_d_s_mnc ( vmec_radial_index_half ( isurf )) * vmec_radial_weight_half ( isurf ) temp = temp * scale_factor d_Z_d_s ( ialpha , izeta ) = d_Z_d_s ( ialpha , izeta ) + temp * cos_angle ! Handle d Lambda / d s. ! Since Lambda is on the half mesh, its radial derivative is on the full mesh. temp = d_Lambda_d_s_mnc ( vmec_radial_index_full ( isurf )) * vmec_radial_weight_full ( isurf ) temp = temp * scale_factor d_Lambda_d_s ( ialpha , izeta ) = d_Lambda_d_s ( ialpha , izeta ) + temp * cos_angle end if end do end do end do end if end do !********************************************************************* ! Sanity check: If the conversion to theta_pest has been done ! correctly, we should find that ! (B dot grad theta_pest) / (B dot grad zeta) = iota. ! Let's verify this: !********************************************************************* allocate ( B_dot_grad_theta_pest_over_B_dot_grad_zeta ( nalpha , - nzgrid : nzgrid )) ! Compute (B dot grad theta_pest) / (B dot grad zeta): B_dot_grad_theta_pest_over_B_dot_grad_zeta = ( B_sup_theta_vmec * ( 1 + d_Lambda_d_theta_vmec ) + B_sup_zeta * d_Lambda_d_zeta ) / B_sup_zeta temp2D = iota call test_arrays ( B_dot_grad_theta_pest_over_B_dot_grad_zeta , temp2D , . false ., 0.01 , 'iota' ) deallocate ( B_dot_grad_theta_pest_over_B_dot_grad_zeta ) !********************************************************************* ! Using R(theta,zeta) and Z(theta,zeta), compute the Cartesian ! components of the gradient basis vectors using the dual relations: !********************************************************************* do izeta = - nzgrid , nzgrid cos_angle = cos ( zeta ( izeta )) sin_angle = sin ( zeta ( izeta )) ! X = R * cos(zeta) d_X_d_theta_vmec (:, izeta ) = d_R_d_theta_vmec (:, izeta ) * cos_angle d_X_d_zeta (:, izeta ) = d_R_d_zeta (:, izeta ) * cos_angle - R (:, izeta ) * sin_angle d_X_d_s (:, izeta ) = d_R_d_s (:, izeta ) * cos_angle ! Y = R * sin(zeta) d_Y_d_theta_vmec (:, izeta ) = d_R_d_theta_vmec (:, izeta ) * sin_angle d_Y_d_zeta (:, izeta ) = d_R_d_zeta (:, izeta ) * sin_angle + R (:, izeta ) * cos_angle d_Y_d_s (:, izeta ) = d_R_d_s (:, izeta ) * sin_angle !!$       ! Y = -R * sin(zeta) !!$       d_Y_d_theta_vmec(:,izeta) = -d_R_d_theta_vmec(:,izeta) * sin_angle !!$       d_Y_d_zeta(:,izeta) = -(d_R_d_zeta(:,izeta) * sin_angle + R(:,izeta) * cos_angle) !!$       d_Y_d_s(:,izeta) = -d_R_d_s(:,izeta) * sin_angle end do ! Use the dual relations to get the Cartesian components of grad s, grad theta_vmec, and grad zeta: grad_s_X = ( d_Y_d_theta_vmec * d_Z_d_zeta - d_Z_d_theta_vmec * d_Y_d_zeta ) / sqrt_g grad_s_Y = ( d_Z_d_theta_vmec * d_X_d_zeta - d_X_d_theta_vmec * d_Z_d_zeta ) / sqrt_g grad_s_Z = ( d_X_d_theta_vmec * d_Y_d_zeta - d_Y_d_theta_vmec * d_X_d_zeta ) / sqrt_g grad_theta_vmec_X = ( d_Y_d_zeta * d_Z_d_s - d_Z_d_zeta * d_Y_d_s ) / sqrt_g grad_theta_vmec_Y = ( d_Z_d_zeta * d_X_d_s - d_X_d_zeta * d_Z_d_s ) / sqrt_g grad_theta_vmec_Z = ( d_X_d_zeta * d_Y_d_s - d_Y_d_zeta * d_X_d_s ) / sqrt_g grad_zeta_X = ( d_Y_d_s * d_Z_d_theta_vmec - d_Z_d_s * d_Y_d_theta_vmec ) / sqrt_g grad_zeta_Y = ( d_Z_d_s * d_X_d_theta_vmec - d_X_d_s * d_Z_d_theta_vmec ) / sqrt_g grad_zeta_Z = ( d_X_d_s * d_Y_d_theta_vmec - d_Y_d_s * d_X_d_theta_vmec ) / sqrt_g ! End of the dual relations. ! next get grad_theta_pest = grad (theta_vmec + Lambda) grad_theta_pest_X = ( 1.0 + d_Lambda_d_theta_vmec ) * grad_theta_vmec_X & + d_Lambda_d_zeta * grad_zeta_X + d_Lambda_d_s * grad_s_X grad_theta_pest_Y = ( 1.0 + d_Lambda_d_theta_vmec ) * grad_theta_vmec_Y & + d_Lambda_d_zeta * grad_zeta_Y + d_Lambda_d_s * grad_s_Y grad_theta_pest_Z = ( 1.0 + d_Lambda_d_theta_vmec ) * grad_theta_vmec_Z & + d_Lambda_d_zeta * grad_zeta_Z + d_Lambda_d_s * grad_s_Z ! Sanity check: grad_zeta_X should be -sin(zeta) / R: do izeta = - nzgrid , nzgrid temp2D (:, izeta ) = - sin ( zeta ( izeta )) / R (:, izeta ) end do call test_arrays ( grad_zeta_X , temp2D , . false ., 1.0e-2 , 'grad_zeta_X' ) grad_zeta_X = temp2D ! We might as well use the exact value, which is in temp2D. ! Sanity check: grad_zeta_Y should be cos(zeta) / R: do izeta = - nzgrid , nzgrid temp2D (:, izeta ) = cos ( zeta ( izeta )) / R (:, izeta ) end do call test_arrays ( grad_zeta_Y , temp2D , . false ., 1.0e-2 , 'grad_zeta_Y' ) grad_zeta_Y = temp2D ! We might as well use the exact value, which is in temp2D. ! grad_zeta_Z should be 0: call test_arrays ( grad_zeta_Z , temp2D , . true ., 1.0e-14 , 'grad_zeta_Z' ) grad_zeta_Z = 0 !********************************************************************* ! Compute the Cartesian components of other quantities we need: !********************************************************************* grad_psi_X = grad_s_X * edge_toroidal_flux_over_2pi grad_psi_Y = grad_s_Y * edge_toroidal_flux_over_2pi grad_psi_Z = grad_s_Z * edge_toroidal_flux_over_2pi ! Form grad alpha = grad (theta_vmec + Lambda - iota * zeta) do izeta = - nzgrid , nzgrid grad_alpha_X (:, izeta ) = ( d_Lambda_d_s (:, izeta ) - zeta ( izeta ) * d_iota_d_s ) * grad_s_X (:, izeta ) grad_alpha_Y (:, izeta ) = ( d_Lambda_d_s (:, izeta ) - zeta ( izeta ) * d_iota_d_s ) * grad_s_Y (:, izeta ) grad_alpha_Z (:, izeta ) = ( d_Lambda_d_s (:, izeta ) - zeta ( izeta ) * d_iota_d_s ) * grad_s_Z (:, izeta ) end do grad_alpha_X = grad_alpha_X + ( 1 + d_Lambda_d_theta_vmec ) * grad_theta_vmec_X + ( - iota + d_Lambda_d_zeta ) * grad_zeta_X grad_alpha_Y = grad_alpha_Y + ( 1 + d_Lambda_d_theta_vmec ) * grad_theta_vmec_Y + ( - iota + d_Lambda_d_zeta ) * grad_zeta_Y grad_alpha_Z = grad_alpha_Z + ( 1 + d_Lambda_d_theta_vmec ) * grad_theta_vmec_Z + ( - iota + d_Lambda_d_zeta ) * grad_zeta_Z grad_B_X = d_B_d_s * grad_s_X + d_B_d_theta_vmec * grad_theta_vmec_X + d_B_d_zeta * grad_zeta_X grad_B_Y = d_B_d_s * grad_s_Y + d_B_d_theta_vmec * grad_theta_vmec_Y + d_B_d_zeta * grad_zeta_Y grad_B_Z = d_B_d_s * grad_s_Z + d_B_d_theta_vmec * grad_theta_vmec_Z + d_B_d_zeta * grad_zeta_Z !temp2D = edge_toroidal_flux_over_2pi * ((1 + d_Lambda_d_theta_vmec) * d_R_d_zeta + (iota - d_Lambda_d_zeta) * d_R_d_theta_vmec) / sqrt_g !!$    do izeta = -nzgrid,nzgrid !!$       !B_X(:,izeta) = temp2D(:,izeta) * cos(zeta(izeta)) !!$       !B_Y(:,izeta) = temp2D(:,izeta) * sin(zeta(izeta)) !!$       sin_angle = sin(zeta(izeta)) !!$       cos_angle = cos(zeta(izeta)) !!$       B_X(:,izeta) = edge_toroidal_flux_over_2pi * ((1 + d_Lambda_d_theta_vmec(:,izeta)) * (d_R_d_zeta(:,izeta)*cos_angle - R(:,izeta)*sin_angle) & !!$            + (iota - d_Lambda_d_zeta(:,izeta)) * d_R_d_theta_vmec(:,izeta)*cos_angle) / sqrt_g(:,izeta) !!$       B_Y(:,izeta) = edge_toroidal_flux_over_2pi * ((1 + d_Lambda_d_theta_vmec(:,izeta)) * (d_R_d_zeta(:,izeta)*sin_angle + R(:,izeta)*cos_angle) & !!$            + (iota - d_Lambda_d_zeta(:,izeta)) * d_R_d_theta_vmec(:,izeta)*sin_angle) / sqrt_g(:,izeta) !!$    end do B_X = edge_toroidal_flux_over_2pi * (( 1 + d_Lambda_d_theta_vmec ) * d_X_d_zeta + ( iota - d_Lambda_d_zeta ) * d_X_d_theta_vmec ) / sqrt_g B_Y = edge_toroidal_flux_over_2pi * (( 1 + d_Lambda_d_theta_vmec ) * d_Y_d_zeta + ( iota - d_Lambda_d_zeta ) * d_Y_d_theta_vmec ) / sqrt_g B_Z = edge_toroidal_flux_over_2pi * (( 1 + d_Lambda_d_theta_vmec ) * d_Z_d_zeta + ( iota - d_Lambda_d_zeta ) * d_Z_d_theta_vmec ) / sqrt_g sqrt_s = sqrt ( normalized_toroidal_flux_used ) !********************************************************************* ! Sanity tests: Verify that the Jacobian equals the appropriate ! cross product of the basis vectors. !********************************************************************* temp2D = 0 & + d_X_d_s * d_Y_d_theta_vmec * d_Z_d_zeta & + d_Y_d_s * d_Z_d_theta_vmec * d_X_d_zeta & + d_Z_d_s * d_X_d_theta_vmec * d_Y_d_zeta & - d_Z_d_s * d_Y_d_theta_vmec * d_X_d_zeta & - d_X_d_s * d_Z_d_theta_vmec * d_Y_d_zeta & - d_Y_d_s * d_X_d_theta_vmec * d_Z_d_zeta call test_arrays ( sqrt_g , temp2D , . false ., 3.0e-3 , 'sqrt_g' ) temp2D = 0 & + grad_s_X * grad_theta_vmec_Y * grad_zeta_Z & + grad_s_Y * grad_theta_vmec_Z * grad_zeta_X & + grad_s_Z * grad_theta_vmec_X * grad_zeta_Y & - grad_s_Z * grad_theta_vmec_Y * grad_zeta_X & - grad_s_X * grad_theta_vmec_Z * grad_zeta_Y & - grad_s_Y * grad_theta_vmec_X * grad_zeta_Z call test_arrays ( 1 / sqrt_g , temp2D , . false ., 1.0e-2 , '1/sqrt_g' ) !********************************************************************* ! Sanity tests: Verify that ! \\vec{B} dot (each of the covariant and contravariant basis vectors) ! matches the corresponding term from VMEC. !********************************************************************* call test_arrays ( B_X * d_X_d_theta_vmec + B_Y * d_Y_d_theta_vmec + B_Z * d_Z_d_theta_vmec , B_sub_theta_vmec , . false ., 1.0e-2 , 'B_sub_theta_vmec' ) call test_arrays ( B_X * d_X_d_s + B_Y * d_Y_d_s + B_Z * d_Z_d_s , B_sub_s , . false ., 1.0e-2 , 'B_sub_s' ) call test_arrays ( B_X * d_X_d_zeta + B_Y * d_Y_d_zeta + B_Z * d_Z_d_zeta , B_sub_zeta , . false ., 1.0e-2 , 'B_sub_zeta' ) call test_arrays ( B_X * grad_s_X + B_Y * grad_s_Y + B_Z * grad_s_Z , temp2D , . true ., 1.0e-2 , 'B_sup_s' ) call test_arrays ( B_X * grad_zeta_X + B_Y * grad_zeta_Y + B_Z * grad_zeta_Z , B_sup_zeta , . false ., 1.0e-2 , 'B_sup_zeta' ) call test_arrays ( B_X * grad_theta_vmec_X + B_Y * grad_theta_vmec_Y + B_Z * grad_theta_vmec_Z , B_sup_theta_vmec , . false ., 1.0e-2 , 'B_sup_theta_vmec' ) !********************************************************************* ! For gbdrift, we need \\vect{B} cross grad |B| dot grad alpha. ! For cvdrift, we also need \\vect{B} cross grad s dot grad alpha. ! Let us compute both of these quantities 2 ways, and make sure the two ! approaches give the same answer (within some tolerance). !********************************************************************* B_cross_grad_s_dot_grad_alpha = ( B_sub_zeta * ( 1 + d_Lambda_d_theta_vmec ) & - B_sub_theta_vmec * ( d_Lambda_d_zeta - iota )) / sqrt_g B_cross_grad_s_dot_grad_alpha_alternate = 0 & + B_X * grad_s_Y * grad_alpha_Z & + B_Y * grad_s_Z * grad_alpha_X & + B_Z * grad_s_X * grad_alpha_Y & - B_Z * grad_s_Y * grad_alpha_X & - B_X * grad_s_Z * grad_alpha_Y & - B_Y * grad_s_X * grad_alpha_Z call test_arrays ( B_cross_grad_s_dot_grad_alpha , B_cross_grad_s_dot_grad_alpha_alternate , & . false ., 1.0e-2 , 'B_cross_grad_s_dot_grad_alpha' ) do izeta = - nzgrid , nzgrid B_cross_grad_B_dot_grad_alpha (:, izeta ) = 0 & + ( B_sub_s (:, izeta ) * d_B_d_theta_vmec (:, izeta ) * ( d_Lambda_d_zeta (:, izeta ) - iota ) & + B_sub_theta_vmec (:, izeta ) * d_B_d_zeta (:, izeta ) * ( d_Lambda_d_s (:, izeta ) - zeta ( izeta ) * d_iota_d_s ) & + B_sub_zeta (:, izeta ) * d_B_d_s (:, izeta ) * ( 1 + d_Lambda_d_theta_vmec (:, izeta )) & - B_sub_zeta (:, izeta ) * d_B_d_theta_vmec (:, izeta ) * ( d_Lambda_d_s (:, izeta ) - zeta ( izeta ) * d_iota_d_s ) & - B_sub_theta_vmec (:, izeta ) * d_B_d_s (:, izeta ) * ( d_Lambda_d_zeta (:, izeta ) - iota ) & - B_sub_s (:, izeta ) * d_B_d_zeta (:, izeta ) * ( 1 + d_Lambda_d_theta_vmec (:, izeta ))) / sqrt_g (:, izeta ) end do B_cross_grad_B_dot_grad_alpha_alternate = 0 & + B_X * grad_B_Y * grad_alpha_Z & + B_Y * grad_B_Z * grad_alpha_X & + B_Z * grad_B_X * grad_alpha_Y & - B_Z * grad_B_Y * grad_alpha_X & - B_X * grad_B_Z * grad_alpha_Y & - B_Y * grad_B_X * grad_alpha_Z call test_arrays ( B_cross_grad_B_dot_grad_alpha , B_cross_grad_B_dot_grad_alpha_alternate , & . false ., 1.0e-2 , 'B_cross_grad_B_dot_grad_alpha' ) !********************************************************************* ! Finally, assemble the quantities needed for stella. !********************************************************************* ! See the latex note gs2_full_surface_stellarator_geometry in the \"doc\" directory for a derivation of the formulae that follow. bmag = B / B_reference gradpar_zeta = L_reference * B_sup_zeta / B ! grad alpha . grad alpha in units of 1/L_ref&#94;2, with alpha = theta_pest - iota * zeta grad_alpha_grad_alpha = L_reference * L_reference * ( grad_alpha_X * grad_alpha_X + grad_alpha_Y * grad_alpha_Y + grad_alpha_Z * grad_alpha_Z ) ! this is grad alpha . grad psi_t in units of B_reference grad_alpha_grad_psi = ( grad_alpha_X * grad_psi_X + grad_alpha_Y * grad_psi_Y + grad_alpha_Z * grad_psi_Z ) / B_reference ! this is grad psi_t . grad psi_t in units of (B_reference*L_reference)&#94;2 grad_psi_grad_psi = ( grad_psi_X * grad_psi_X + grad_psi_Y * grad_psi_Y + grad_psi_Z * grad_psi_Z ) & / ( L_reference * L_reference * B_reference * B_reference ) ! dx/dpsitor = sign_torflux/rhotor/Lref/Bref ! dy/dalpha = Lref*rhotor ! this is shat * grad x . grad y = shat * (grad psi_tor . grad alpha) * dx/dpsi_tor * dy/dalpha ! = sign_torflux * shat * (grad psi_tor . grad alpha) / Bref !    gds21 = (grad_alpha_X * grad_psi_X + grad_alpha_Y * grad_psi_Y + grad_alpha_Z * grad_psi_Z) & !         * sign_toroidal_flux * shat / B_reference ! this is shat&#94;2 * | grad x | &#94;2 = shat&#94;2 * |grad psi_tor|&#94;2 * (dx/dpsitor)&#94;2 ! = shat&#94;2 * |grad psi_tor|&#94;2 * / rhotor&#94;2 / Lref&#94;2 / Bref&#94;2 !    gds22 = (grad_psi_X * grad_psi_X + grad_psi_Y * grad_psi_Y + grad_psi_Z * grad_psi_Z) & !         * shat * shat / (L_reference * L_reference * B_reference * B_reference * normalized_toroidal_flux_used) ! this is (grad zeta . grad x_stella) / bmag&#94;2 = (grad zeta . grad psitor) * dx/dpsitor / bmag&#94;2 ! = (grad zeta . grad psitor) * sign_torflux/rhotor/Lref/Bref/ bmag&#94;2 gradzeta_gradx = sign_toroidal_flux & * ( grad_zeta_X * grad_psi_X + grad_zeta_Y * grad_psi_Y + grad_zeta_Z * grad_psi_Z ) & / ( L_reference * B_reference * sqrt ( normalized_toroidal_flux_used ) * bmag ** 2 ) ! this is (grad zeta . grad y_stella) / bmag&#94;2 = (grad zeta . grad alpha) * dy/dalpha / bmag&#94;2 ! = (grad zeta . grad alpha) * Lref * rhotor / bmag&#94;2 gradzeta_grady = ( grad_zeta_X * grad_alpha_X + grad_zeta_Y * grad_alpha_Y + grad_zeta_Z * grad_alpha_Z ) & * L_reference * sqrt ( normalized_toroidal_flux_used ) / bmag ** 2 ! this is (grad theta_pest . grad x_stella) / bmag&#94;2 gradtheta_gradx = ( grad_theta_pest_X * grad_psi_X + grad_theta_pest_Y * grad_psi_Y & + grad_theta_pest_Z * grad_psi_Z ) & / ( L_reference * B_reference * sqrt ( normalized_toroidal_flux_used ) * bmag ** 2 ) ! this is (grad theta_pest . grad y_stella) / bmag&#94;2 gradtheta_grady = ( grad_theta_pest_X * grad_alpha_X + grad_theta_pest_Y * grad_alpha_Y & + grad_theta_pest_Z * grad_alpha_Z ) & * L_reference * sqrt ( normalized_toroidal_flux_used ) / bmag ** 2 ! this is psitor/|psitor|*((grad y_stella . grad zeta)*(grad x_stella . grad y_stella) ! - (grad x_stella . grad zeta)*|grad y_stella|&#94;2) / (B/Bref)&#94;2 gds23 = sign_toroidal_flux * ( gradzeta_grady * sign_toroidal_flux * grad_alpha_grad_psi & - gradzeta_gradx * grad_alpha_grad_alpha * normalized_toroidal_flux_used ) !    gds23 = sign_toroidal_flux*(gradzeta_grady * gds21/shat - gradzeta_gradx * gds2) ! this is psitor/|psitor| * ((grad y_stella . grad zeta) * |grad x_stella|&#94;2 ! - (grad x_stella . grad zeta)*(grad x_stella . grad y_stella)) / (B/Bref)&#94;2 gds24 = ( gradzeta_grady * grad_psi_grad_psi / normalized_toroidal_flux_used & - gradzeta_gradx * sign_toroidal_flux * grad_alpha_grad_psi ) * sign_toroidal_flux !    gds24 = (gradzeta_grady * gds22/shat**2 - gradzeta_gradx * gds21/shat) * sign_toroidal_flux ! this is ((grad y_stella . grad theta_pest)*(grad x_stella . grad y_stella) ! - (grad x_stella . grad theta_pest)*|grad y_stella|&#94;2) / (B/Bref)&#94;2 gds25 = gradtheta_grady * sign_toroidal_flux * grad_alpha_grad_psi & - gradtheta_gradx * grad_alpha_grad_alpha * normalized_toroidal_flux_used !    gds25 = gradtheta_grady * gds21/shat - gradtheta_gradx * gds2 ! this is ((grad y_stella . grad theta_pest) * |grad x_stella|&#94;2 ! - (grad x_stella . grad theta_pest)*(grad x_stella . grad y_stella)) / 2 / (B/Bref)&#94;2 gds26 = 0.5 * ( gradtheta_grady * grad_psi_grad_psi / normalized_toroidal_flux_used & - gradtheta_gradx * sign_toroidal_flux * grad_alpha_grad_psi ) !    gds26 = 0.5*(gradtheta_grady * gds22/shat**2 - gradtheta_gradx * gds21/shat) gbdrift_alpha = 2 * B_reference * L_reference * L_reference * B_cross_grad_B_dot_grad_alpha & / ( B * B * B ) !    gbdrift = 2 * B_reference * L_reference * L_reference * sqrt_s * B_cross_grad_B_dot_grad_alpha & gbdrift0_psi = - edge_toroidal_flux_over_2pi & * ( B_sub_theta_vmec * d_B_d_zeta - B_sub_zeta * d_B_d_theta_vmec ) / sqrt_g & * 2 * shat / ( B * B * B ) !    gbdrift0 = (B_sub_theta_vmec * d_B_d_zeta - B_sub_zeta * d_B_d_theta_vmec) / sqrt_g * edge_toroidal_flux_over_2pi & !    gbdrift0 = abs(edge_toroidal_flux_over_2pi) & !         * (B_sub_theta_vmec * d_B_d_zeta - B_sub_zeta * d_B_d_theta_vmec) / sqrt_g & !         * 2 * shat / (B * B * B * sqrt_s) ! In the above 2-line expression for gbdrift0, the first line is \\vec{B} \\times \\nabla B \\cdot \\nabla \\psi. cvdrift_alpha = gbdrift_alpha + 2 * B_reference * L_reference * L_reference * mu_0 * d_pressure_d_s & * B_cross_grad_s_dot_grad_alpha / ( B * B * B * B ) !    cvdrift = gbdrift + 2 * B_reference * L_reference * L_reference * sqrt_s * mu_0 * d_pressure_d_s & !         * B_cross_grad_s_dot_grad_alpha / (B * B * B * B) cvdrift0_psi = gbdrift0_psi ! calculate the ratio of the physical displacement due to movement in the stella x-coordinate to the x-coordinate itself ! This is |ds/dx|*sqrt((dR/ds)&#94;2+(dZ/ds)&#94;2) x_displacement_fac = 2.0 * sqrt ( normalized_toroidal_flux_used ) * sqrt ( d_R_d_s ** 2 + d_Z_d_s ** 2 ) / L_reference !********************************************************************* ! Free all arrays that were allocated. !********************************************************************* deallocate ( B ) deallocate ( temp2D ) deallocate ( sqrt_g ) deallocate ( R , Z ) deallocate ( d_B_d_theta_vmec ) deallocate ( d_B_d_zeta ) deallocate ( d_B_d_s ) deallocate ( d_R_d_theta_vmec ) deallocate ( d_R_d_zeta ) deallocate ( d_R_d_s ) deallocate ( d_Z_d_theta_vmec ) deallocate ( d_Z_d_zeta ) deallocate ( d_Z_d_s ) deallocate ( d_Lambda_d_theta_vmec ) deallocate ( d_Lambda_d_zeta ) deallocate ( d_Lambda_d_s ) deallocate ( B_sub_s ) !deallocate(B_sub_theta_vmec) !deallocate(B_sub_zeta) deallocate ( B_sup_theta_vmec ) deallocate ( B_sup_zeta ) deallocate ( d_B_d_s_mnc ) deallocate ( d_B_d_s_mns ) deallocate ( d_R_d_s_mnc ) deallocate ( d_R_d_s_mns ) deallocate ( d_Z_d_s_mnc ) deallocate ( d_Z_d_s_mns ) deallocate ( d_Lambda_d_s_mnc ) deallocate ( d_Lambda_d_s_mns ) deallocate ( d_X_d_s ) deallocate ( d_X_d_theta_vmec ) deallocate ( d_X_d_zeta ) deallocate ( d_Y_d_s ) deallocate ( d_Y_d_theta_vmec ) deallocate ( d_Y_d_zeta ) deallocate ( grad_s_X ) deallocate ( grad_s_Y ) deallocate ( grad_s_Z ) deallocate ( grad_theta_vmec_X ) deallocate ( grad_theta_vmec_Y ) deallocate ( grad_theta_vmec_Z ) deallocate ( grad_theta_pest_X ) deallocate ( grad_theta_pest_Y ) deallocate ( grad_theta_pest_Z ) deallocate ( grad_zeta_X ) deallocate ( grad_zeta_Y ) deallocate ( grad_zeta_Z ) deallocate ( grad_psi_X ) deallocate ( grad_psi_Y ) deallocate ( grad_psi_Z ) deallocate ( grad_alpha_X ) deallocate ( grad_alpha_Y ) deallocate ( grad_alpha_Z ) deallocate ( B_X ) deallocate ( B_Y ) deallocate ( B_Z ) deallocate ( grad_B_X ) deallocate ( grad_B_Y ) deallocate ( grad_B_Z ) deallocate ( B_cross_grad_B_dot_grad_alpha ) deallocate ( B_cross_grad_B_dot_grad_alpha_alternate ) deallocate ( B_cross_grad_s_dot_grad_alpha ) deallocate ( B_cross_grad_s_dot_grad_alpha_alternate ) deallocate ( gradzeta_grady ) deallocate ( gradzeta_gradx ) deallocate ( gradtheta_grady ) deallocate ( gradtheta_gradx ) deallocate ( normalized_toroidal_flux_full_grid ) deallocate ( normalized_toroidal_flux_half_grid ) if ( verbose ) then write ( * , * ) \"Leaving vmec_to_stella_geometry_interface.\" write ( * , * ) end if if ( allocated ( rmnc )) then deallocate ( xm , xn ) deallocate ( xm_nyq , xn_nyq ) deallocate ( rmnc , lmns , zmns , bmnc , gmnc ) deallocate ( bsupumnc , bsupvmnc , bsubumnc , bsubvmnc , bsubsmns ) deallocate ( phi , phip , iotas , iotaf , presf ) end if if ( allocated ( rmns )) then deallocate ( rmns , lmnc , zmnc , bmns , gmns ) deallocate ( bsupumns , bsupvmns , bsubumns , bsubvmns , bsubsmnc ) end if contains subroutine test_arrays ( array1 , array2 , should_be_0 , tolerance , name ) ! This subroutine is used for verifying the geometry arrays. ! When should_be_0 = .true., the subroutine verifies that |array1| = 0 to within !     an absolute tolerance specified by 'tolerance'. array2 is ignored in this case. ! When should_be_0 = .false., the subroutine verifies that array1 = array2 !     to within a relative tolerance specified by 'tolerance'. implicit none real , dimension ( nalpha , - nzgrid : nzgrid ) :: array1 , array2 real :: tolerance character ( len =* ) :: name logical :: should_be_0 real :: max_value , max_difference if ( should_be_0 ) then max_value = maxval ( abs ( array1 )) !         if (verbose) print *,\"  maxval(abs(\",trim(name),\")):\",max_value,\"(should be << 1.)\" if ( max_value > tolerance ) then print * , \"Error! \" , trim ( name ), \" should be 0, but instead it is:\" do ialpha = 1 , nalpha print * , array1 ( ialpha , :) end do stop end if else max_difference = maxval ( abs ( array1 - array2 )) / maxval ( abs ( array1 ) + abs ( array2 )) !         if (verbose) print *,\"  Relative difference between two methods for computing \",trim(name),\":\",max_difference,\"(should be << 1.)\" if ( max_difference > tolerance ) then print * , \"Error! Two methods for computing \" , trim ( name ), \" disagree. Here comes method 1:\" do ialpha = 1 , nalpha print * , array1 ( ialpha , :) end do print * , \"Here comes method 2:\" do ialpha = 1 , nalpha print * , array2 ( ialpha , :) end do print * , \"Here comes the difference:\" do ialpha = 1 , nalpha print * , array1 ( ialpha , :) - array2 ( ialpha , :) end do stop end if end if end subroutine test_arrays end subroutine vmec_to_stella_geometry_interface subroutine get_root ( a0 , b0 , root , converged ) implicit none real , intent ( in ) :: a0 , b0 real , intent ( out ) :: root logical , intent ( out ) :: converged integer , parameter :: itmax_bracket = 10 integer , parameter :: itmax_root = 10 real , parameter :: tol = 1.0e-10 integer :: it real :: a , b , c , d , e , fa , fb , fc , p , q , r , s , tol1 , xm , eps a = a0 b = b0 fa = fzero_residual ( a ) fb = fzero_residual ( b ) do it = 1 , itmax_bracket eps = epsilon ( a ) if (( fa > 0.0 . and . fb > 0.0 ) . or . ( fa < 0.0 . and . fb < 0.0 )) then write ( * , * ) write ( * , * ) 'in vmec_to_stella_geometry_interface, theta_min=' , a , ' and theta_max=' , b , ' do not bracket root.' write ( * , * ) 'f(theta_min)=' , fa , 'and f(theta_max)=' , fb , '.' a = a - 0.3 b = b + 0.3 write ( * , * ) 'Trying again with values ' , a , ' and ' , b , ' .' fa = fzero_residual ( a ) fb = fzero_residual ( b ) else exit end if end do c = b fc = fb do it = 1 , itmax_root if (( fb > 0.0 . and . fc > 0.0 ) . or . ( fb < 0.0 . and . fc < 0.0 )) then c = a fc = fa d = b - a e = d end if if ( abs ( fc ) < abs ( fb )) then a = b b = c c = a fa = fb fb = fc fc = fa end if tol1 = 2.0 * eps * abs ( b ) + 0.5 * tol xm = 0.5 * ( c - b ) if ( abs ( xm ) <= tol1 . or . fb == 0.0 ) then root = b converged = . true . exit end if if ( abs ( e ) >= tol1 . and . abs ( fa ) > abs ( fb )) then s = fb / fa if ( a == c ) then p = 2.0 * xm * s q = 1.0 - s else q = fa / fc r = fb / fc p = s * ( 2.0 * xm * q * ( q - r ) - ( b - a ) * ( r - 1.0 )) q = ( q - 1.0 ) * ( r - 1.0 ) * ( s - 1.0 ) end if if ( p > 0.0 ) q = - q p = abs ( p ) if ( 2.0 * p < min ( 3.0 * xm * q - abs ( tol1 * q ), abs ( e * q ))) then e = d d = p / q else d = xm e = d end if else d = xm e = d end if a = b fa = fb b = b + merge ( d , sign ( tol1 , xm ), abs ( d ) > tol1 ) fb = fzero_residual ( b ) end do end subroutine get_root function fzero_residual ( theta_vmec_try ) ! Note that lmns and lmnc use the non-Nyquist xm, xn, and mnmax. ! Also note that lmns and lmnc are on the HALF grid. implicit none real :: theta_vmec_try , fzero_residual real :: angle , sinangle , cosangle integer :: imn , which_surface ! residual = (theta_pest based on theta_vmec_try) - theta_pest_target = theta_vmec_try + Lambda - theta_pest_target fzero_residual = theta_vmec_try - theta_pest_target do imn = 1 , mnmax angle = xm ( imn ) * theta_vmec_try - xn ( imn ) * zeta0 sinangle = sin ( angle ) cosangle = cos ( angle ) do which_surface = 1 , 2 fzero_residual = fzero_residual + vmec_radial_weight_half ( which_surface ) * lmns ( imn , vmec_radial_index_half ( which_surface )) * sinangle if ( lasym ) then fzero_residual = fzero_residual + vmec_radial_weight_half ( which_surface ) * lmnc ( imn , vmec_radial_index_half ( which_surface )) * cosangle end if end do end do end function fzero_residual end module vmec_to_stella_geometry_interface_mod","tags":"","loc":"sourcefile/vmec_to_stella_geometry_interface.f90.html"},{"title":"test_vmec_to_stella_geometry_interface.f90 â€“ stella","text":"Contents Programs test_vmec_to_stella_geometry_interface Source Code test_vmec_to_stella_geometry_interface.f90 Source Code program test_vmec_to_stella_geometry_interface use vmec_to_stella_geometry_interface_mod implicit none !********************************************************************* ! Input parameters !********************************************************************* character ( len = 2000 ) :: vmec_filename = 'equilibria/wout_w7x_standardConfig.nc' !  character(len=2000) :: vmec_filename = 'equilibria/wout_161s1.nc' integer , parameter :: nalpha = 5 integer , parameter :: nzgrid = 7 real :: alpha0 = 0.0 real :: zeta_center = 0.0 real :: number_of_field_periods_to_include = 1 real :: desired_normalized_toroidal_flux = 0.6354167d+0 integer :: vmec_surface_option = 0 logical :: verbose = . true . !********************************************************************* ! Output arrays !********************************************************************* real :: normalized_toroidal_flux_used , safety_factor_q , shat , L_reference , B_reference , nfp integer :: sign_toroidal_flux real , dimension ( nalpha ) :: alpha real , dimension ( - nzgrid : nzgrid ) :: zeta real , dimension ( nalpha , - nzgrid : nzgrid ) :: bmag , gradpar , gds2 , gds21 , gds22 , gds23 , gds24 , gds25 , gds26 real , dimension ( nalpha , - nzgrid : nzgrid ) :: gbdrift , gbdrift0 , cvdrift , cvdrift0 real , dimension ( nalpha , - nzgrid : nzgrid ) :: theta_vmec real , dimension ( nalpha , - nzgrid : nzgrid ) :: B_sub_zeta , B_sub_theta_vmec , displacement ! This code uses normalizations in which kxfac is always 1, so kxfac is not presently returned. !********************************************************************* ! Variables used internally by this program !********************************************************************* integer :: j , iunit !********************************************************************* ! Beginning of executable statements !********************************************************************* call read_vmec_equilibrium ( vmec_filename ) call vmec_to_stella_geometry_interface ( nalpha , alpha0 , nzgrid , zeta_center , & number_of_field_periods_to_include , & desired_normalized_toroidal_flux , vmec_surface_option , verbose , & normalized_toroidal_flux_used , safety_factor_q , shat , L_reference , B_reference , nfp , & sign_toroidal_flux , & alpha , zeta , bmag , gradpar , gds2 , gds21 , gds22 , gds23 , gds24 , gds25 , gds26 , & gbdrift , gbdrift0 , cvdrift , cvdrift0 , & theta_vmec , B_sub_zeta , B_sub_theta_vmec , displacement ) print * , \"-------------- Input parameters ------------------\" print * , \"vmec_filename: \" , trim ( vmec_filename ) print * , \"nalpha:\" , nalpha print * , \"alpha0:\" , alpha0 print * , \"nzgrid:\" , nzgrid print * , \"zeta_center:\" , zeta_center print * , \"number_of_field_periods_to_include:\" , number_of_field_periods_to_include print * , \"desired_normalized_toroidal_flux:\" , desired_normalized_toroidal_flux print * , \"vmec_surface_option:\" , vmec_surface_option print * , \"-------------- Output parameters -----------------\" print * , \"normalized_toroidal_flux_used:\" , normalized_toroidal_flux_used print * , \"safety_factor_q:\" , safety_factor_q print * , \"shat:\" , shat print * , \"L_reference:\" , L_reference print * , \"B_reference:\" , B_reference print * , \"nfp:\" , nfp print * , \"alpha:\" print * , alpha print * , \"zeta:\" print * , zeta print * , \"bmag:\" do j = 1 , nalpha print * , bmag ( j , :) end do print * , \"gradpar:\" do j = 1 , nalpha print * , gradpar ( j , :) end do print * , \"gds2:\" do j = 1 , nalpha print * , gds2 ( j , :) end do print * , \"gds21:\" do j = 1 , nalpha print * , gds21 ( j , :) end do print * , \"gds22:\" do j = 1 , nalpha print * , gds22 ( j , :) end do print * , \"gds23:\" do j = 1 , nalpha print * , gds23 ( j , :) end do print * , \"gds24:\" do j = 1 , nalpha print * , gds24 ( j , :) end do print * , \"gds25:\" do j = 1 , nalpha print * , gds25 ( j , :) end do print * , \"gds26:\" do j = 1 , nalpha print * , gds26 ( j , :) end do print * , \"gbdrift:\" do j = 1 , nalpha print * , gbdrift ( j , :) end do print * , \"gbdrift0:\" do j = 1 , nalpha print * , gbdrift0 ( j , :) end do print * , \"cvdrfit:\" do j = 1 , nalpha print * , cvdrift ( j , :) end do print * , \"cvdrift0:\" do j = 1 , nalpha print * , cvdrift0 ( j , :) end do print * , \"theta_vmec:\" do j = 1 , nalpha print * , theta_vmec ( j , :) end do iunit = 6 open ( file = 'geometry.dat' , unit = iunit ) write ( iunit , * ) 'nalpha nzgrid' write ( iunit , * ) nalpha , nzgrid write ( iunit , * ) 'alpha' write ( iunit , * ) alpha write ( iunit , * ) 'zeta' write ( iunit , * ) zeta write ( iunit , * ) 'bmag' do j = 1 , nalpha write ( iunit , * ) bmag ( j , :) end do write ( iunit , * ) 'gradpar' do j = 1 , nalpha write ( iunit , * ) gradpar ( j , :) end do write ( iunit , * ) 'gds2' do j = 1 , nalpha write ( iunit , * ) gds2 ( j , :) end do write ( iunit , * ) 'gds21' do j = 1 , nalpha write ( iunit , * ) gds21 ( j , :) end do write ( iunit , * ) 'gds22' do j = 1 , nalpha write ( iunit , * ) gds22 ( j , :) end do write ( iunit , * ) 'gds23' do j = 1 , nalpha write ( iunit , * ) gds23 ( j , :) end do write ( iunit , * ) 'gds24' do j = 1 , nalpha write ( iunit , * ) gds24 ( j , :) end do write ( iunit , * ) 'gds25' do j = 1 , nalpha write ( iunit , * ) gds25 ( j , :) end do write ( iunit , * ) 'gds26' do j = 1 , nalpha write ( iunit , * ) gds26 ( j , :) end do write ( iunit , * ) 'gbdrift' do j = 1 , nalpha write ( iunit , * ) gbdrift ( j , :) end do write ( iunit , * ) 'gbdrift0' do j = 1 , nalpha write ( iunit , * ) gbdrift0 ( j , :) end do write ( iunit , * ) 'cvdrift' do j = 1 , nalpha write ( iunit , * ) cvdrift ( j , :) end do write ( iunit , * ) 'cvdrift0' do j = 1 , nalpha write ( iunit , * ) cvdrift0 ( j , :) end do write ( iunit , * ) 'theta_vmec' do j = 1 , nalpha write ( iunit , * ) theta_vmec ( j , :) end do close ( iunit ) end program test_vmec_to_stella_geometry_interface","tags":"","loc":"sourcefile/test_vmec_to_stella_geometry_interface.f90.html"},{"title":"fzero.f90 â€“ stella","text":"Contents Modules fzero_mod Source Code fzero.f90 Source Code module fzero_mod contains SUBROUTINE FZERO ( F , B , C , R , RE , AE , IFLAG ) !***BEGIN PROLOGUE  FZERO !***PURPOSE  Search for a zero of a function F(X) in a given interval !            (B,C).  It is designed primarily for problems where F(B) !            and F(C) have opposite signs. !***LIBRARY   SLATEC !***CATEGORY  F1B !***TYPE      SINGLE PRECISION (FZERO-S, DFZERO-D) !***KEYWORDS  BISECTION, NONLINEAR EQUATIONS, ROOTS, ZEROS !***AUTHOR  Shampine, L. F., (SNLA) !           Watts, H. A., (SNLA) !***DESCRIPTION ! !     FZERO searches for a zero of a REAL function F(X) between the !     given REAL values B and C until the width of the interval (B,C) !     has collapsed to within a tolerance specified by the stopping !     criterion, !        ABS(B-C) .LE. 2.*(RW*ABS(B)+AE). !     The method used is an efficient combination of bisection and the !     secant rule and is due to T. J. Dekker. ! !     Description Of Arguments ! !   F     :EXT   - Name of the REAL external function.  This name must !                  be in an EXTERNAL statement in the calling program. !                  F must be a function of one REAL argument. ! !   B     :INOUT - One end of the REAL interval (B,C).  The value !                  returned for B usually is the better approximation !                  to a zero of F. ! !   C     :INOUT - The other end of the REAL interval (B,C) ! !   R     :IN    - A (better) REAL guess of a zero of F which could help !                  in speeding up convergence.  If F(B) and F(R) have !                  opposite signs, a root will be found in the interval !                  (B,R); if not, but F(R) and F(C) have opposite signs, !                  a root will be found in the interval (R,C); !                  otherwise, the interval (B,C) will be searched for a !                  possible root.  When no better guess is known, it is !                  recommended that r be set to B or C, since if R is !                  not interior to the interval (B,C), it will be !                  ignored. ! !   RE    :IN    - Relative error used for RW in the stopping criterion. !                  If the requested RE is less than machine precision, !                  then RW is set to approximately machine precision. ! !   AE    :IN    - Absolute error used in the stopping criterion.  If !                  the given interval (B,C) contains the origin, then a !                  nonzero value should be chosen for AE. ! !   IFLAG :OUT   - A status code.  User must check IFLAG after each !                  call.  Control returns to the user from FZERO in all !                  cases. ! !                1  B is within the requested tolerance of a zero. !                   The interval (B,C) collapsed to the requested !                   tolerance, the function changes sign in (B,C), and !                   F(X) decreased in magnitude as (B,C) collapsed. ! !                2  F(B) = 0.  However, the interval (B,C) may not have !                   collapsed to the requested tolerance. ! !                3  B may be near a singular point of F(X). !                   The interval (B,C) collapsed to the requested tol- !                   erance and the function changes sign in (B,C), but !                   F(X) increased in magnitude as (B,C) collapsed, i.e. !                     ABS(F(B out)) .GT. MAX(ABS(F(B in)),ABS(F(C in))) ! !                4  No change in sign of F(X) was found although the !                   interval (B,C) collapsed to the requested tolerance. !                   The user must examine this case and decide whether !                   B is near a local minimum of F(X), or B is near a !                   zero of even multiplicity, or neither of these. ! !                5  Too many (.GT. 500) function evaluations used. ! !***REFERENCES  L. F. Shampine and H. A. Watts, FZERO, a root-solving !                 code, Report SC-TM-70-631, Sandia Laboratories, !                 September 1970. !               T. J. Dekker, Finding a zero by means of successive !                 linear interpolation, Constructive Aspects of the !                 Fundamental Theorem of Algebra, edited by B. Dejon !                 and P. Henrici, Wiley-Interscience, 1969. !***ROUTINES CALLED  R1MACH !***REVISION HISTORY  (YYMMDD) !   700901  DATE WRITTEN !   890531  Changed all specific intrinsics to generic.  (WRB) !   890531  REVISION DATE from Version 3.2 !   891214  Prologue converted to Version 4.0 format.  (BAB) !   920501  Reformatted the REFERENCES section.  (WRB) !***END PROLOGUE  FZERO !      USE stel_kinds IMPLICIT NONE !      REAL(RPREC), PARAMETER :: ZERO = 0, ONE = 1 !      REAL(RPREC) :: A,ACBS,ACMB,AE,AW,B,C,CMB,ER,FA,FB,FC,FX,FZ,P,Q,R, !     +     RE,RW,T,TOL,Z,F REAL , PARAMETER :: ZERO = 0 , ONE = 1 REAL :: A , ACBS , ACMB , AE , AW , B , C , CMB , ER , FA , FB , FC , FX , FZ , P , Q , R , & RE , RW , T , TOL , Z , F INTEGER :: IC , IFLAG , KOUNT EXTERNAL F !***FIRST EXECUTABLE STATEMENT  FZERO ! !   ER is two times the computer unit roundoff value which is defined !   here by the function EPSILON. ! ER = 2 * EPSILON ( ER ) ! !   Initialize. ! Z = R IF ( R <= MIN ( B , C ) . OR . R >= MAX ( B , C )) Z = C RW = MAX ( RE , ER ) AW = MAX ( AE , ZERO ) IC = 0 T = Z FZ = F ( T ) FC = FZ T = B FB = F ( T ) KOUNT = 2 IF ( SIGN ( ONE , FZ ) == SIGN ( ONE , FB )) GO TO 1 C = Z GO TO 2 1 IF ( Z == C ) GO TO 2 T = C FC = F ( T ) KOUNT = 3 IF ( SIGN ( ONE , FZ ) == SIGN ( ONE , FC )) GO TO 2 B = Z FB = FZ 2 A = C FA = FC ACBS = ABS ( B - C ) FX = MAX ( ABS ( FB ), ABS ( FC )) ! 3 IF ( ABS ( FC ) >= ABS ( FB )) GO TO 4 ! !   Perform interchange. ! A = B FA = FB B = C FB = FC C = A FC = FA ! !    4 CMB = 0.5_DP*(C-B) 4 CMB = 0.5d+0 * ( C - B ) ACMB = ABS ( CMB ) TOL = RW * ABS ( B ) + AW ! !   Test stopping criterion and function count. ! IF ( ACMB <= TOL ) GO TO 10 IF ( FB == ZERO ) GO TO 11 IF ( KOUNT >= 500 ) GO TO 14 ! !   Calculate new iterate implicitly as B+P/Q, where we arrange !   P .GE. 0.  The implicit form is used to prevent overflow. ! P = ( B - A ) * FB Q = FA - FB IF ( P >= ZERO ) GO TO 5 P = - P Q = - Q ! !   Update A and check for satisfactory reduction in the size of the !   bracketing interval.  If not, perform bisection. ! 5 A = B FA = FB IC = IC + 1 IF ( IC < 4 ) GO TO 6 IF ( 8 * ACMB >= ACBS ) GO TO 8 IC = 0 ACBS = ACMB ! !   Test for too small a change. ! 6 IF ( P > ABS ( Q ) * TOL ) GO TO 7 ! !   Increment by TOLerance. ! B = B + SIGN ( TOL , CMB ) GO TO 9 ! !   Root ought to be between B and (C+B)/2. ! 7 IF ( P >= CMB * Q ) GO TO 8 ! !   Use secant rule. ! B = B + P / Q GO TO 9 ! !   Use bisection (C+B)/2. ! 8 B = B + CMB ! !   Have completed computation for new iterate B. ! 9 T = B FB = F ( T ) KOUNT = KOUNT + 1 ! !   Decide whether next step is interpolation or extrapolation. ! IF ( SIGN ( ONE , FB ) /= SIGN ( ONE , FC )) GO TO 3 C = A FC = FA GO TO 3 ! !   Finished.  Process results for proper setting of IFLAG. ! 10 IF ( SIGN ( ONE , FB ) == SIGN ( ONE , FC )) GO TO 13 IF ( ABS ( FB ) > FX ) GO TO 12 IFLAG = 1 RETURN 11 IFLAG = 2 RETURN 12 IFLAG = 3 RETURN 13 IFLAG = 4 RETURN 14 IFLAG = 5 END SUBROUTINE FZERO end module fzero_mod","tags":"","loc":"sourcefile/fzero.f90.html"},{"title":"getcarg.f â€“ stella","text":"Contents Subroutines getcarg Source Code getcarg.f Source Code SUBROUTINE getcarg ( narg , arg , numargs ) IMPLICIT NONE C----------------------------------------------- C   D u m m y   A r g u m e n t s C----------------------------------------------- INTEGER , INTENT ( in ) :: narg INTEGER , INTENT ( out ) :: numargs CHARACTER ( LEN =* ), INTENT ( out ) :: arg C----------------------------------------------- C   L o c a l   V a r i a b l e s C----------------------------------------------- INTEGER :: numchars C----------------------------------------------- c$!DEC$ IF DEFINED (WIN32) c$      INTEGER :: nargs c$      numargs = nargs() - 1 c$      CALL getarg(narg, arg, numchars) c$!DEC$ ELSEIF DEFINED (LINUX) INTEGER iargc numargs = iargc () CALL getarg ( narg , arg ) c$!DEC$ ELSEIF DEFINED (VMS) c$      CALL lib$get_foreign(arg,,numchars) c$      numargs = MIN(1,numchars) c$!DEC$ ELSEIF DEFINED (CRAY) c$      INTEGER :: ier c$      INTEGER ipxfargc c$      numargs = ipxfargc() c$      CALL pxfgetarg(narg, arg, numchars, ier) c$!DEC$ ELSEIF DEFINED (MACOSX) c$      numargs = command_argument_count() c$      CALL get_command_argument(narg,arg) c$!DEC$ ELSE c$      INTEGER iargc, getarg c$      numargs = iargc() c$      numchars = getarg(narg, arg) c$!DEC$ ENDIF END SUBROUTINE getcarg","tags":"","loc":"sourcefile/getcarg.f.html"},{"title":"safe_open_mod.f â€“ stella","text":"Contents Modules safe_open_mod Source Code safe_open_mod.f Source Code MODULE safe_open_mod ! !     Module for performing a \"safe\" open of a file for !     a Fortran read/write operation. Makes sure the requested file !     unit number is not in use, and increments it until an unused !     unit is found ! CONTAINS SUBROUTINE safe_open ( iunit , istat , filename , filestat , & & fileform , record_in , access_in , delim_in ) ! !     Module for performing a \"safe\" open of a file for !     a Fortran read/write operation. Makes sure the requested file !     unit number is not in use, and increments it until an unused !     unit is found ! !  Note that: ! 1)  the actual i/o unit number used is returned in the first argument. ! 2)  the status variable from the OPEN command is returned as the second !     argument. !  Here are some examples of usage: ! !   To open an existing namelist input file: !      CALL safe_open(iou,istat,nli_file_name,'old','formatted') ! !   To create a file, in order to write to it: !      CALL safe_open(iou,istat,my_output_file_name,'replace','formatted') ! !   To create an output file, with 'NONE' as delimiter for characters for !   list-directed output and Namelist output !      CALL safe_open(iou,istat,my_output_file_name,'replace', !     &   'formatted',delim_in='none') !  JDH 08-30-2004. !     Based on Steve Hirshman's original safe_open routine !     Rearranged comments, continuation lines, some statement ordering. !     Should be NO change in functionality. ! !  JDH 2010-06-09 !     Added coding for DELIM specification ! !  SAL 2012-11-29 !     Checked to make sure iunit > 10 so we don't write to screen. IMPLICIT NONE !----------------------------------------------- !   D u m m y   A r g u m e n t s !----------------------------------------------- INTEGER , INTENT ( inout ) :: iunit INTEGER , INTENT ( out ) :: istat CHARACTER ( LEN =* ), INTENT ( in ) :: filename , filestat , fileform INTEGER , INTENT ( in ), OPTIONAL :: record_in CHARACTER ( LEN =* ), INTENT ( in ), OPTIONAL :: access_in CHARACTER ( LEN =* ), INTENT ( in ), OPTIONAL :: delim_in !----------------------------------------------- !   L o c a l   V a r i a b l e s !----------------------------------------------- CHARACTER ( LEN =* ), PARAMETER :: cdelim = \"apostrophe\" , 1 cform = \"formatted\" , cunform = \"unformatted\" , 2 cscratch = \"scratch\" , cseq = \"sequential\" CHARACTER ( LEN = 10 ) :: acc_type CHARACTER ( LEN = 10 ) :: delim_type LOGICAL :: lopen , lexist , linvalid !----------------------------------------------- !  Start of Executable Code !----------------------------------------------- !----------------------------------------------- ! !     Check that unit is not already opened !     Increment iunit until find one that is not in use ! linvalid = . true . DO WHILE ( linvalid ) IF ( iunit > 10 ) THEN INQUIRE ( iunit , exist = lexist , opened = lopen , iostat = istat ) linvalid = ( istat . ne . 0 . or . . not . lexist ) . or . lopen IF (. not . linvalid ) EXIT END IF iunit = iunit + 1 END DO !  JDH 08-24-2004 This next IF(Present) clause seems to be duplicated below. !  I think one of the two should be eliminated, for clarity. IF ( PRESENT ( access_in )) THEN acc_type = TRIM ( access_in ) ELSE acc_type = cseq END IF !  Why not call this variable lscratch? lexist = ( filestat ( 1 : 1 ). eq . 's' ) . or . ( filestat ( 1 : 1 ). eq . 'S' ) !Scratch file !  JDH 08-24-2004 Below is nearly exact duplicate of IF(Present) clause !  from above IF ( PRESENT ( access_in )) THEN acc_type = TRIM ( access_in ) ELSE acc_type = 'SEQUENTIAL' END IF !  JDH 2010-06-09. Coding for DELIM IF ( PRESENT ( delim_in )) THEN SELECT CASE ( delim_in ( 1 : 1 )) CASE ( 'n' , 'N' ) delim_type = 'none' CASE ( 'q' , 'Q' ) delim_type = 'quote' CASE DEFAULT delim_type = cdelim END SELECT ELSE delim_type = cdelim ENDIF ! Here are the actual OPEN commands. Eight different cases. SELECT CASE ( fileform ( 1 : 1 )) CASE ( 'u' , 'U' ) IF ( PRESENT ( record_in )) THEN IF ( lexist ) THEN ! unformatted, record length specified, scratch OPEN ( unit = iunit , form = cunform , status = cscratch , & & recl = record_in , access = acc_type , iostat = istat ) ELSE ! unformatted, record length specified, non-scratch OPEN ( unit = iunit , file = TRIM ( filename ), form = cunform , & & status = TRIM ( filestat ), recl = record_in , & & access = acc_type , iostat = istat ) END IF ELSE IF ( lexist ) THEN ! unformatted, record length unspecified, scratch OPEN ( unit = iunit , form = cunform , status = cscratch , & & access = acc_type , iostat = istat ) ELSE ! unformatted, record length unspecified, non-scratch OPEN ( unit = iunit , file = TRIM ( filename ), form = cunform , & & status = TRIM ( filestat ), access = acc_type , iostat = istat ) END IF END IF CASE DEFAULT IF ( PRESENT ( record_in )) THEN IF ( lexist ) THEN ! formatted, record length specified, scratch OPEN ( unit = iunit , form = cform , status = cscratch , & & delim = TRIM ( delim_type ), recl = record_in , & & access = acc_type , iostat = istat ) ELSE ! formatted, record length specified, non-scratch OPEN ( unit = iunit , file = TRIM ( filename ), form = cform , & & status = TRIM ( filestat ), delim = TRIM ( delim_type ), & & recl = record_in , access = acc_type , iostat = istat ) END IF ELSE IF ( lexist ) THEN ! formatted, record length unspecified, scratch OPEN ( unit = iunit , form = cform , status = cscratch , & & delim = TRIM ( delim_type ), access = acc_type , & & iostat = istat ) ELSE ! formatted, record length unspecified, non-scratch OPEN ( unit = iunit , file = TRIM ( filename ), form = cform , & & status = TRIM ( filestat ), delim = TRIM ( delim_type ), & & access = acc_type , iostat = istat ) END IF END IF END SELECT END SUBROUTINE safe_open END MODULE safe_open_mod","tags":"","loc":"sourcefile/safe_open_mod.f.html"},{"title":"stel_kinds.f â€“ stella","text":"Contents Modules stel_kinds Source Code stel_kinds.f Source Code MODULE stel_kinds !---------------------------------------------------------------------- !  Kind specifications !---------------------------------------------------------------------- INTEGER , PARAMETER :: rprec = SELECTED_REAL_KIND ( 12 , 100 ) !      INTEGER, PARAMETER :: rprec = SELECTED_REAL_KIND(15,307) INTEGER , PARAMETER :: iprec = SELECTED_INT_KIND ( 8 ) INTEGER , PARAMETER :: cprec = KIND (( 1.0_rprec , 1.0_rprec )) INTEGER , PARAMETER :: dp = rprec END MODULE stel_kinds","tags":"","loc":"sourcefile/stel_kinds.f.html"},{"title":"handle_err.f90 â€“ stella","text":"Contents Subroutines handle_err Source Code handle_err.f90 Source Code subroutine handle_err ( status , nam3 , nam1 , nam2 ) !DEC$ IF DEFINED (NETCDF) include \"netcdf.inc\" INTEGER , intent ( in ) :: status character * ( * ), intent ( in ) :: nam1 , nam2 , nam3 if ( status /= nf_noerr ) then WRITE ( * , 10 ) nam1 , nam2 , nam3 10 format ( '% ' , a , '--E-- A netCDF error has occurred in: ' , a / , 'while processing: ' , a ) print * , nf_strerror ( status ) end if !DEC$ ELSE return !DEC$ ENDIF end subroutine handle_err","tags":"","loc":"sourcefile/handle_err.f90.html"},{"title":"vmec_input.f â€“ stella","text":"Contents Modules vmec_input Source Code vmec_input.f Source Code MODULE vmec_input USE vparams , ONLY : rprec , dp , mpol1d , ntord , ndatafmax USE vsvd0 IMPLICIT NONE !----------------------------------------------- !   L o c a l   V a r i a b l e s !   For variable descriptions, see VMEC \"readin.f\" routine !----------------------------------------------- INTEGER , PARAMETER :: mpol_default = 6 INTEGER , PARAMETER :: ntor_default = 0 INTEGER , PARAMETER :: ns_default = 31 INTEGER :: nfp , ncurr , nsin , niter , nstep , nvacskip , mpol , ntor , 1 ntheta , nzeta , mfilter_fbdy , nfilter_fbdy , 2 max_main_iterations INTEGER , DIMENSION ( 100 ) :: ns_array , niter_array INTEGER :: imse , isnodes , itse , ipnodes , iopt_raxis , 1 imatch_phiedge , nflxs INTEGER , DIMENSION ( nbsetsp ) :: nbfld INTEGER , DIMENSION ( nfloops ) :: indxflx INTEGER , DIMENSION ( nbcoilsp , nbsetsp ) :: indxbfld REAL ( rprec ), DIMENSION ( - ntord : ntord , 0 : mpol1d ) :: 1 rbs , zbc , rbc , zbs REAL ( rprec ) :: time_slice , curtor , delt , ftol , tcon0 , 1 gamma , phiedge , phidiam , sigma_current , sigma_delphid , tensi , 2 tensp , tensi2 , fpolyi , presfac , mseangle_offset , pres_offset , 3 mseangle_offsetm , spres_ped , bloat , pres_scale , 4 prec2d_threshold REAL ( rprec ), DIMENSION ( 0 : 20 ) :: am , ai , ac REAL ( rprec ), DIMENSION ( 1 : 20 ) :: aphi CHARACTER ( len = 20 ) :: pcurr_type !  len=12 -> len=20 J Hanson 2010-03-16 CHARACTER ( len = 20 ) :: piota_type CHARACTER ( len = 20 ) :: pmass_type REAL ( rprec ), DIMENSION ( ndatafmax ) :: am_aux_s , am_aux_f , & & ai_aux_s , ai_aux_f , ac_aux_s , ac_aux_f !     ANISOTROPIC AMPLITUDES: AH=PHOT/PTHERMAL, AT=TPERP/TPAR !     bcrit: hot particle energy deposition value for |B| REAL ( rprec ), DIMENSION ( 0 : 20 ) :: ah , at REAL ( rprec ) :: bcrit CHARACTER ( len = 20 ) :: pt_type ! SAL  For Ani/Flow CHARACTER ( len = 20 ) :: ph_type ! SAL  For Ani/Flow, REAL ( rprec ), DIMENSION ( ndatafmax ) :: ah_aux_s , ah_aux_f , & at_aux_s , at_aux_f REAL ( rprec ), DIMENSION ( 0 : ntord ) :: raxis , zaxis !!Backwards compatibility: Obsolete REAL ( rprec ), DIMENSION ( 0 : ntord ) :: raxis_cc , raxis_cs , 1 zaxis_cc , zaxis_cs REAL ( rprec ), DIMENSION ( 100 ) :: ftol_array REAL ( rprec ), DIMENSION ( nigroup ), TARGET :: extcur ! V3FIT needs a pointer to this. REAL ( rprec ), DIMENSION ( nmse ) :: mseprof REAL ( rprec ), DIMENSION ( ntse ) :: rthom , datathom , sigma_thom REAL ( rprec ), DIMENSION ( nmse ) :: rstark , datastark , 1 sigma_stark REAL ( rprec ), DIMENSION ( nfloops ) :: dsiobt , sigma_flux REAL ( rprec ), DIMENSION ( nbcoilsp , nbsetsp ) :: bbc , sigma_b REAL ( rprec ), DIMENSION ( ndatafmax ) :: psa , pfa , isa , ifa LOGICAL :: lpofr , lmac , lfreeb , lrecon , loldout , ledge_dump , 1 lasym , lforbal , lrfp , lmovie , lmove_axis , 2 lwouttxt , ldiagno , ! J.Geiger: for txt- and diagno-output 3 lmoreiter , ! J.Geiger: if force residuals are not fulfilled add more iterations. 4 lfull3d1out , ! J.Geiger: to force full 3D1-output 5 l_v3fit = . false ., 6 lspectrum_dump , loptim !!Obsolete LOGICAL :: lgiveup ! inserted M.Drevlak REAL ( rprec ) :: fgiveup ! inserted M.Drevlak, giveup-factor for ftolv LOGICAL :: lbsubs ! J Hanson See jxbforce coding CHARACTER ( len = 200 ) :: mgrid_file CHARACTER ( len = 200 ) :: trip3d_file ! SAL - TRIP3D CHARACTER ( len = 10 ) :: precon_type CHARACTER ( len = 120 ) :: arg1 CHARACTER ( len = 100 ) :: input_extension NAMELIST / indata / mgrid_file , time_slice , nfp , ncurr , nsin , 1 niter , nstep , nvacskip , delt , ftol , gamma , am , ai , ac , aphi , 1 pcurr_type , pmass_type , piota_type , 1 am_aux_s , am_aux_f , ai_aux_s , ai_aux_f , ac_aux_s , ac_aux_f , ! J Hanson 2010-03-16 1 ah , at , bcrit , ! WAC (anisotropic pres) 1 ph_type , ah_aux_s , ah_aux_f , 1 pt_type , at_aux_s , at_aux_f , 2 rbc , zbs , rbs , zbc , spres_ped , pres_scale , raxis_cc , zaxis_cs , 3 raxis_cs , zaxis_cc , mpol , ntor , ntheta , nzeta , mfilter_fbdy , 3 nfilter_fbdy , niter_array , 4 ns_array , ftol_array , tcon0 , precon_type , prec2d_threshold , 4 curtor , sigma_current , extcur , 5 phiedge , psa , pfa , isa , ifa , imatch_phiedge , iopt_raxis , 6 tensi , tensp , mseangle_offset , mseangle_offsetm , imse , 7 isnodes , rstark , datastark , sigma_stark , itse , ipnodes , 8 presfac , pres_offset , rthom , datathom , sigma_thom , phidiam , 9 sigma_delphid , tensi2 , fpolyi , nflxs , indxflx , dsiobt , A sigma_flux , nbfld , indxbfld , bloat , raxis , zaxis , A bbc , sigma_b , lpofr , lforbal , lfreeb , lmove_axis , lrecon , lmac , C lmovie , ! S Lazerson 2010 D lasym , ledge_dump , lspectrum_dump , loptim , lrfp , E loldout , lwouttxt , ldiagno , lfull3d1out , max_main_iterations , ! J Geiger 2010-05-04 D lgiveup , fgiveup , ! M.Drevlak 2012-05-10 E lbsubs , ! 2014-01-12 See jxbforce F trip3d_file ! SAL - TRIP3D NAMELIST / mseprofile / mseprof CONTAINS SUBROUTINE read_indata_namelist ( iunit , istat ) INTEGER :: iunit , istat ! !     INITIALIZATIONS ! gamma = 0 spres_ped = 1 mpol = mpol_default ntor = ntor_default ntheta = 0 ; nzeta = 0 ns_array = 0 ; ns_array ( 1 ) = ns_default niter_array = - 1 ; bloat = 1 rbc = 0 ; rbs = 0 ; zbs = 0 ; zbc = 0 time_slice = 0 nfp = 1 ncurr = 0 nsin = ns_default niter = 100 nstep = 10 nvacskip = 1 delt = 1 ftol = 1.E-10_dp ftol_array = 0 ; ftol_array ( 1 ) = ftol am = 0 ; ai = 0 ; ac = 0 ; aphi = 0 ; aphi ( 1 ) = 1 pres_scale = 1 raxis_cc = 0 ; zaxis_cs = 0 ; raxis_cs = 0 ; zaxis_cc = 0 ; mfilter_fbdy = - 1 ; nfilter_fbdy = - 1 tcon0 = 1 precon_type = 'NONE' ; prec2d_threshold = 1.E-30_dp curtor = 0 ; extcur = 0 ; phiedge = 1 ; mgrid_file = 'NONE' trip3d_file = 'NONE' ! SAL - TRIP3D lfreeb = . true . lmove_axis = . true . lmac = . false . lforbal = . false . lasym = . false . lrfp = . false . loldout = . false . ! J Geiger 2010-05-04 start ldiagno = . false . lgiveup = . false . ! inserted M.Drevlak fgiveup = 3.E+01_dp ! inserted M.Drevlak lbsubs = . false . ! J Hanson. See jxbforce coding lfull3d1out = . false . lmovie = . false . ! S Lazerson for making movie files lmoreiter = . false . ! default value if no max_main_iterations given. max_main_iterations = 1 ! to keep a presumably expected standard behavior. !DEC$ IF DEFINED (NETCDF) lwouttxt = . false . ! to keep functionality as expected with netcdf !DEC$ ELSE lwouttxt = . true . ! and without netcdf !DEC$ ENDIF pcurr_type = 'power_series' piota_type = 'power_series' pmass_type = 'power_series' !     ANISTROPY PARAMETERS bcrit = 1 at ( 0 ) = 1 ; at ( 1 :) = 0 ah = 0 ph_type = 'power_series' pt_type = 'power_series' ah_aux_s (:) = - 1 at_aux_s (:) = - 1 am_aux_s (:) = - 1 ac_aux_s (:) = - 1 ai_aux_s (:) = - 1 ! !     BACKWARDS COMPATIBILITY ! raxis = 0 ; zaxis = 0 READ ( iunit , nml = indata , iostat = istat ) IF ( ALL ( niter_array == - 1 )) niter_array = niter WHERE ( raxis . ne . 0._dp ) raxis_cc = raxis WHERE ( zaxis . ne . 0._dp ) zaxis_cs = zaxis IF ( max_main_iterations . gt . 1 ) lmoreiter = . true . !J Geiger: if more iterations are requested. END SUBROUTINE read_indata_namelist SUBROUTINE read_mse_namelist ( iunit , istat ) INTEGER :: iunit , istat READ ( iunit , nml = mseprofile , iostat = istat ) END SUBROUTINE read_mse_namelist SUBROUTINE write_indata_namelist ( iunit , istat ) IMPLICIT NONE INTEGER , INTENT ( in ) :: iunit INTEGER , INTENT ( inout ) :: istat INTEGER :: iftol , i , n , m INTEGER , DIMENSION ( 1 ) :: ins CHARACTER ( LEN =* ), PARAMETER :: outboo = \"(2X,A,1X,'=',1X,L1)\" CHARACTER ( LEN =* ), PARAMETER :: outint = \"(2X,A,1X,'=',1X,I0)\" CHARACTER ( LEN =* ), PARAMETER :: outint1 = \"(2X,A,1X,'=',1X,I1.1)\" CHARACTER ( LEN =* ), PARAMETER :: outint2 = \"(2X,A,1X,'=',1X,I2.2)\" CHARACTER ( LEN =* ), PARAMETER :: outint3 = \"(2X,A,1X,'=',1X,I3.3)\" CHARACTER ( LEN =* ), PARAMETER :: outint4 = \"(2X,A,1X,'=',1X,I4.4)\" CHARACTER ( LEN =* ), PARAMETER :: outint5 = \"(2X,A,1X,'=',1X,I5.5)\" CHARACTER ( LEN =* ), PARAMETER :: outint6 = \"(2X,A,1X,'=',1X,I6.6)\" CHARACTER ( LEN =* ), PARAMETER :: outflt = \"(2X,A,1X,'=',1X,ES22.12E3)\" CHARACTER ( LEN =* ), PARAMETER :: outexp = \"(2X,A,1X,'=',1X,ES22.12E3)\" IF ( istat < 0 ) RETURN WRITE ( iunit , '(A)' ) '!----- Runtime Parameters -----' WRITE ( iunit , '(A)' ) '&INDATA' WRITE ( iunit , outflt ) 'DELT' , delt WRITE ( iunit , outint ) 'NITER' , niter WRITE ( iunit , outint ) 'NSTEP' , nstep WRITE ( iunit , outflt ) 'TCON0' , tcon0 ins = MAXLOC ( ns_array ) WRITE ( iunit , '(a,(1p,4i14))' ) '  NS_ARRAY =    ' , 1 ( ns_array ( i ), i = 1 , ins ( 1 )) iftol = 1 DO WHILE ( ftol_array ( iftol ). ne . 0 . and . iftol . lt . 100 ) iftol = iftol + 1 END DO WRITE ( iunit , '(a,(1p,4e14.6))' ) '  FTOL_ARRAY =  ' , 1 ( ftol_array ( i ), i = 1 , iftol - 1 ) ins = MINLOC ( niter_array ) IF ( ins ( 1 ) > 1 ) 1 WRITE ( iunit , '(a,(1p,4i14))' ) '  NITER_ARRAY = ' , 2 ( niter_array ( i ), i = 1 , ins ( 1 ) - 1 ) WRITE ( iunit , '(2x,3a)' ) \"PRECON_TYPE = '\" , TRIM ( precon_type ), \"'\" WRITE ( iunit , '(2x,a,1p,e14.6)' ) \"PREC2D_THRESHOLD = \" , 1 prec2d_threshold WRITE ( iunit , '(A)' ) '!----- Grid Parameters -----' WRITE ( iunit , outboo ) 'LASYM' , lasym WRITE ( iunit , outint4 ) 'NFP' , nfp WRITE ( iunit , outint4 ) 'MPOL' , mpol WRITE ( iunit , outint4 ) 'NTOR' , ntor WRITE ( iunit , outflt ) 'PHIEDGE' , phiedge IF ( lrfp ) THEN WRITE ( iunit , '(A)' ) '!----- RFP Parameters -----' WRITE ( iunit , outboo ) 'LRFP' , lasym WRITE ( iunit , '(a,(1p,4ES22.12E3))' ) '  APHI = ' , 1 ( aphi ( n - 1 ), n = 1 , SIZE ( aphi )) END IF WRITE ( iunit , '(A)' ) '!----- Free Boundary Parameters -----' WRITE ( iunit , outboo ) 'LFREEB' , lfreeb IF ( lfreeb ) THEN WRITE ( iunit , '(2x,3a)' ) \"MGRID_FILE = '\" , TRIM ( mgrid_file ), \"'\" WRITE ( iunit , outint4 ) 'NZETA' , nzeta DO n = 1 , SIZE ( extcur ) IF ( extcur ( n ) == 0 ) CYCLE WRITE ( iunit , '(2X,A,I3.3,A,ES22.12E3)' ) 1 'EXTCUR(' , n , ') = ' , extcur ( n ) END DO WRITE ( iunit , outint4 ) 'NVACSKIP' , nvacskip IF ( TRIM ( trip3d_file ) /= 'NONE' ) WRITE ( iunit , '(2x,3a)' ) 1 \"TRIP3D_FILE = '\" , TRIM ( trip3d_file ), \"'\" ! SAL - TRIP3D END IF WRITE ( iunit , '(A)' ) '!----- Pressure Parameters -----' WRITE ( iunit , outflt ) 'GAMMA' , gamma WRITE ( iunit , outflt ) 'BLOAT' , bloat WRITE ( iunit , outflt ) 'SPRES_PED' , spres_ped WRITE ( iunit , outflt ) 'PRES_SCALE' , pres_scale WRITE ( iunit , '(2x,3a)' ) \"PMASS_TYPE = '\" , TRIM ( pmass_type ), \"'\" WRITE ( iunit , '(a,(1p,4e22.14))' ) '  AM = ' , ( am ( i - 1 ), i = 1 , SIZE ( am )) i = minloc ( am_aux_s ( 2 :), DIM = 1 ) IF ( i > 4 ) THEN WRITE ( iunit , '(a,(1p,4ES22.12E3))' ) '  AM_AUX_S = ' , 1 ( am_aux_s ( n ), n = 1 , i ) WRITE ( iunit , '(a,(1p,4ES22.12E3))' ) '  AM_AUX_F = ' , 1 ( am_aux_f ( n ), n = 1 , i ) END IF WRITE ( iunit , '(A)' ) '!----- ANI/FLOW Parameters -----' WRITE ( iunit , outflt ) 'BCRIT' , SQRT ( bcrit ) WRITE ( iunit , '(2x,3a)' ) \"PT_TYPE = '\" , TRIM ( pt_type ), \"'\" WRITE ( iunit , '(a,(1p,4e22.14))' ) '  AT = ' , ( at ( i - 1 ), i = 1 , SIZE ( at )) i = minloc ( at_aux_s ( 2 :), DIM = 1 ) IF ( i > 4 ) THEN WRITE ( iunit , '(a,(1p,4ES22.12E3))' ) '  AT_AUX_S = ' , 1 ( at_aux_s ( n ), n = 1 , i ) WRITE ( iunit , '(a,(1p,4ES22.12E3))' ) '  AT_AUX_F = ' , 1 ( at_aux_f ( n ), n = 1 , i ) END IF WRITE ( iunit , '(2x,3a)' ) \"PH_TYPE = '\" , TRIM ( ph_type ), \"'\" WRITE ( iunit , '(a,(1p,4e22.14))' ) '  AH = ' , ( ah ( i - 1 ), i = 1 , SIZE ( ah )) i = minloc ( ah_aux_s ( 2 :), DIM = 1 ) IF ( i > 4 ) THEN WRITE ( iunit , '(a,(1p,4ES22.12E3))' ) '  AH_AUX_S = ' , 1 ( ah_aux_s ( n ), n = 1 , i ) WRITE ( iunit , '(a,(1p,4ES22.12E3))' ) '  AH_AUX_F = ' , 1 ( ah_aux_f ( n ), n = 1 , i ) END IF WRITE ( iunit , '(A)' ) '!----- Current/Iota Parameters -----' WRITE ( iunit , outexp ) 'CURTOR' , curtor WRITE ( iunit , outint ) 'NCURR' , ncurr WRITE ( iunit , '(2x,3a)' ) \"PIOTA_TYPE = '\" , TRIM ( piota_type ), \"'\" WRITE ( iunit , '(a,(1p,4e22.14))' ) '  AI = ' ,( ai ( n - 1 ), n = 1 , SIZE ( ai )) i = minloc ( ai_aux_s ( 2 :), DIM = 1 ) IF ( i > 4 ) THEN WRITE ( iunit , '(a,(1p,4ES22.12E3))' ) '  AI_AUX_S = ' , 1 ( ai_aux_s ( n ), n = 1 , i ) WRITE ( iunit , '(a,(1p,4ES22.12E3))' ) '  AI_AUX_F = ' , 1 ( ai_aux_f ( n ), n = 1 , i ) END IF WRITE ( iunit , '(2x,3a)' ) \"PCURR_TYPE = '\" , TRIM ( pcurr_type ), \"'\" WRITE ( iunit , '(a,(1p,4ES22.12E3))' ) 1 '  AC = ' ,( ac ( n - 1 ), n = 1 , SIZE ( ac )) i = minloc ( ac_aux_s ( 2 :), DIM = 1 ) IF ( i > 4 ) THEN WRITE ( iunit , '(a,(1p,4ES22.12E3))' ) '  AC_AUX_S = ' , 1 ( ac_aux_s ( n ), n = 1 , i ) WRITE ( iunit , '(a,(1p,4ES22.12E3))' ) '  AC_AUX_F = ' , 1 ( ac_aux_f ( n ), n = 1 , i ) END IF WRITE ( iunit , '(A)' ) '!----- Axis Parameters ----- ' WRITE ( iunit , '(a,(1p,4e22.14))' ) 1 '  RAXIS_CC = ' ,( raxis_cc ( n ), n = 0 , ntor ) IF ( lasym ) 1 WRITE ( iunit , '(a,(1p,4ES22.12E3))' ) 2 '  RAXIS_CS = ' ,( raxis_cs ( n ), n = 0 , ntor ) IF ( lasym ) 1 WRITE ( iunit , '(a,(1p,4ES22.12E3))' ) 2 '  ZAXIS_CC = ' ,( zaxis_cc ( n ), n = 0 , ntor ) WRITE ( iunit , '(a,(1p,4ES22.12E3))' ) 1 '  ZAXIS_CS = ' ,( zaxis_cs ( n ), n = 0 , ntor ) WRITE ( iunit , '(A)' ) '!----- Boundary Parameters -----' DO m = 0 , mpol - 1 DO n = - ntor , ntor IF (( rbc ( n , m ). ne . 0 ) . or . ( zbs ( n , m ). ne . 0 )) THEN WRITE ( iunit , '(2(A,I4.3,A,I3.3,A,ES22.12E3))' ) 1 '  RBC(' , n , ',' , m , ') = ' , rbc ( n , m ), 2 '    ZBS(' , n , ',' , m , ') = ' , zbs ( n , m ) IF (. not . lasym ) CYCLE WRITE ( iunit , '(2(A,I4.3,A,I3.3,A,ES22.12E3))' ) 1 '  RBS(' , n , ',' , m , ') = ' , rbs ( n , m ), 2 '    ZBC(' , n , ',' , m , ') = ' , zbc ( n , m ) END IF END DO END DO WRITE ( iunit , '(A)' ) '/' RETURN END SUBROUTINE write_indata_namelist END MODULE vmec_input","tags":"","loc":"sourcefile/vmec_input.f.html"},{"title":"parse_extension.f â€“ stella","text":"Contents Subroutines parse_extension Source Code parse_extension.f Source Code SUBROUTINE parse_extension ( file_to_parse , file_or_extension , lnc ) IMPLICIT NONE !----------------------------------------------- !   D u m m y   A r g u m e n t s !----------------------------------------------- CHARACTER ( LEN =* ), INTENT ( in ) :: file_or_extension CHARACTER ( LEN =* ), INTENT ( inout ) :: file_to_parse LOGICAL , INTENT ( out ) :: lnc !----------------------------------------------- !   L o c a l   V a r i a b l e s !----------------------------------------------- INTEGER :: index_path , index_comp , index_nc , istat = 0 LOGICAL :: ltxt CHARACTER ( len = LEN ( file_to_parse )) :: path CHARACTER ( len = LEN ( file_to_parse )) :: temp !!Assumes file_to_parse can store it all CHARACTER ( LEN = 1 ), PARAMETER :: ch_test = '.' !----------------------------------------------- ! !     FIRST CHECK IF FILE_OR_EXTENSION IS A FILENAME (FILE_TO_PARSE EMBEDDED) !     OR AN EXTENSION ! index_path = INDEX ( file_or_extension , TRIM ( file_to_parse )) inde x _ comp = index_path IF ( index_path . gt . 0 ) THEN ! !     MUST BE <FILENAME>. OR <FILENAME>_ ! index_nc = index_path + LEN_TRIM ( file_to_parse ) index_path = INDEX ( file_or_extension ( index_nc :), ch_test ) !SPH032510         IF ((ch_test.ne.'.') .and. (ch_test.ne.'_')) index_path = 0 END IF IF ( index_path . gt . 0 ) THEN file_to_parse = file_or_extension ! !     CHECK FOR netcdf FILE EXTENSION (*.nc) ! index_nc = INDEX ( file_to_parse , \".nc\" , BACK = . TRUE .) lnc = ( index_nc . eq . ( LEN_TRIM ( file_to_parse ) - 2 )) ! !     MAY HAVE PASSED FILE NAME EXTENSION WITHOUT .nc; CHECK IF FILE_TO_PARSE EXISTS IF (. not . lnc ) THEN INQUIRE ( FILE = file_to_parse , EXIST = ltxt , iostat = istat ) IF ( istat . ne . 0 . or . . not . ltxt ) THEN file_to_parse = TRIM ( file_to_parse ) // \".nc\" lnc = . true . END IF END IF ELSE ! !     CHECK IF TEXT (.txt) OR NETCDF (.nc) FILE EXISTS ! path = file_to_parse IF ( file_or_extension ( 1 : 1 ) == '.' . or . 1 file_or_extension ( 1 : 1 ) == '_' ) THEN temp = TRIM ( path ) // file_or_extension ELSE IF ( index_comp == 0 ) THEN temp = TRIM ( path ) // '_' // file_or_extension E L SE temp = TRIM ( file_or_extension ) END IF ! !     FIRST LOOK FOR FILE WITH .nc SUFFIX IN file_or_extension ! file_to_parse = TRIM ( temp ) index_nc = INDEX ( file_to_parse , \".nc\" , BACK = . TRUE .) lnc = ( index_nc . eq . ( LEN_TRIM ( file_to_parse ) - 2 )) ! !     NEXT LOOK FOR .txt SUFFIX ! IF (. not . lnc ) THEN index_nc = INDEX ( file_to_parse , \".txt\" , BACK = . TRUE .) ltxt = ( index_nc . eq . ( LEN_TRIM ( file_to_parse ) - 3 )) ! !     CHECK IF file_or_extension WAS GIVEN WITHOUT EXPLICIT .nc OR .txt SUFFIX ! IF (. not . ltxt ) THEN file_to_parse = TRIM ( temp ) // '.nc' INQUIRE ( FILE = file_to_parse , EXIST = lnc , iostat = istat ) IF ( istat . ne . 0 . or . . not . lnc ) THEN file_to_parse = TRIM ( path ) // '.' 1 // TRIM ( file_or_extension ) // '.nc' INQUIRE ( FILE = file_to_parse , EXIST = lnc , iostat = istat ) IF ( istat . ne . 0 . or . . not . lnc ) THEN file_to_parse = TRIM ( temp ) // '.txt' INQUIRE ( FILE = file_to_parse , EXIST = ltxt , 1 iostat = istat ) IF (. not . ltxt ) THEN file_to_parse = TRIM ( path ) // '.' // 1 TRIM ( file_or_extension ) // '.txt' INQUIRE ( FILE = file_to_parse , EXIST = ltxt , 1 iostat = istat ) END IF END IF END IF END IF ! !     DEFAULT (OLD STYLE) FILE NAME WHEN NONE OF THE ABOVE EXIST ! IF (( istat . ne . 0 . or . . not . ltxt ) . and . . not . lnc ) THEN file_to_parse = TRIM ( path ) // '.' // file_or_extension END IF END IF END IF END SUBROUTINE parse_extension","tags":"","loc":"sourcefile/parse_extension.f.html"},{"title":"mgrid_mod.f â€“ stella","text":"Contents Modules mgrid_mod Source Code mgrid_mod.f Source Code MODULE mgrid_mod USE stel_kinds USE vmec_input , ONLY : nbfld , nflxs , lfreeb , lrecon USE vsvd0 , ONLY : nigroup , nparts , npfcoil , nbcoilsp , nfloops , 1 nbctotp IMPLICIT NONE LOGICAL :: lnverror = . true . INTEGER , PARAMETER :: nlimset = 2 !number of different limiters CHARACTER ( LEN =* ), PARAMETER :: 1 vn_br0 = 'br' , vn_bp0 = 'bp' , vn_bz0 = 'bz' , 3 vn_ir = 'ir' , vn_jz = 'jz' , 4 vn_kp = 'kp' , vn_nfp = 'nfp' , 5 vn_rmin = 'rmin' , vn_rmax = 'rmax' , vn_zmin = 'zmin' , 6 vn_zmax = 'zmax' , vn_coilgrp = 'coil_group' CHARACTER ( LEN =* ), PARAMETER :: 1 vn_nextcur = 'nextcur' , vn_mgmode = 'mgrid_mode' , 2 vn_coilcur = 'raw_coil_cur' , 3 vn_flp = 'nobser' , vn_nobd = 'nobd' , vn_nbset = 'nbsets' , 4 vn_nbfld = 'nbfld' , 2 ln_flp = 'flux loops' , ln_nobd = 'Connected flux loops' , 3 ln_nbset = 'B-coil loops' , ln_next = 'External currents' , 4 ln_nbfld = 'B-coil measurements' C----------------------------------------------- C   L o c a l   V a r i a b l e s C----------------------------------------------- !     nr0b, np0b, nz0b: !              :  grid dimensions of magnetic field in mgrid file !     nbvac    :  total number of grid points (nr0b*np0b*nz0b) in mgrid file !     bvac(:,1):  br (radial component of external magnetic field) !     bvac(:,2):  bp (toroidal component) !     bvac(:,3) = bz (z-component) !     rminb, rmaxb : min (max) radial dimension of grid in mgrid !     zminb, zmaxb : min (max) vertical dimension of grid in mgrid ! !     nextcur:         no. of EXTERNAL current groups (eg., TF, PF, helical) !     raw_coil_current  array of raw currents for each coil group !     mgrid_mode     = 'S', scaled mode; = 'R', raw mode !     curlabel:   array of labels describing each current group !                     included in green''s FUNCTION BFIELD response ! !               - - - - - - - - - - - - - - - - - - !               FOR DIAGNOSTICS AND DATA ANALYSIS !               (HERE,COILS ARE FOR MEASURING FIELDS, FLUXES) !    iconnect:   two-dimensional array describing electrical !     needflx:    =NEEDIT, loop required for flux match !                    >=ISYMCOIL, loop required but flux computed by !                               invoking symmetry in Z !                    =IDONTNEED, loop not required for flux match !    needbfld:    =NEEDIT, loop required for B-field match !                    =ISAMECOIL, loop at same position as previous loop !                    >=ISYMCOIL, loop required but B-field computed !                               by invoking symmetry in Z !                    =IDONTNEED, loop not required in B-field match !      dsiext:    connected flux loop signals due to EXTERNAL coils !      plflux:    array of measured (inferred) plasma contrib. to flux loops !      plbfld:    array of measured (inferred) plasma contrib. to B-loops !                      connection of up to four flux loops. Specifies !                     the sign and flux loop number of (up to) four !                     connected individual loops (indexing based on !                     xobser,zobser arrays). !        nobd:   number of connected flux loop measurements !      nobser:   number of individual flux loop positions !      nbsets:   number of B-coil sets defined in mgrid file !  nbcoils(n):   number of bfield coils in each set defined in mgrid file !    nbcoilsn:   total number of bfield coils defined in mgrid file !      nbfldn:   total number of EXTERNAL bfield measurements used in matching !  bloopnames:   array of labels describing b-field sets !    dsilabel:   array of labels describing connected flux loops !      xobser:   array of flux loop R-positions !      zobser:   array of flux loop Z-positions ! rbcoil(m,n):   R position of the m-th coil in the n-th set from mgrid file ! zbcoil(m,n):   Z position of the m-th coil in the n-th set from mgrid file ! abcoil(m,n):   orientation (surface normal wrt R axis; in radians) ! INTEGER :: nr0b , np0b , nfper0 , nz0b INTEGER :: nobd , nobser , nextcur , nbfldn , nbsets , nbcoilsn INTEGER :: nbvac , nbcoil_max , nlim , nlim_max , nsets , 1 nrgrid , nzgrid INTEGER , DIMENSION (:), ALLOCATABLE :: needflx , nbcoils INTEGER , DIMENSION (:), ALLOCATABLE :: limitr , nsetsn INTEGER , DIMENSION (:,:), ALLOCATABLE :: iconnect , needbfld REAL ( rprec ) :: rminb , zminb , rmaxb , zmaxb , delrb , delzb REAL ( rprec ) :: rx1 , rx2 , zy1 , zy2 , condif REAL ( rprec ), DIMENSION (:,:), ALLOCATABLE , TARGET :: bvac REAL ( rprec ), DIMENSION (:,:,:), POINTER :: brvac , bzvac , bpvac REAL ( rprec ), DIMENSION (:,:), ALLOCATABLE :: unpsiext , 1 plbfld , rbcoil , zbcoil , abcoil , bcoil , rbcoilsqr REAL ( rprec ), DIMENSION (:), ALLOCATABLE :: raw_coil_current REAL ( rprec ), DIMENSION (:), ALLOCATABLE :: xobser , zobser , 1 xobsqr , dsiext , psiext , plflux , b_chi CHARACTER ( LEN = 300 ) :: mgrid_path CHARACTER ( LEN = 300 ) :: mgrid_path_old = \" \" CHARACTER ( LEN = 30 ), DIMENSION (:), ALLOCATABLE :: curlabel CHARACTER ( LEN = 15 ), DIMENSION (:), ALLOCATABLE :: 1 dsilabel , bloopnames CHARACTER ( LEN = 30 ) :: tokid REAL ( rprec ), DIMENSION (:,:,:), ALLOCATABLE :: dbcoil , pfcspec REAL ( rprec ), DIMENSION (:,:), ALLOCATABLE :: 1 rlim , zlim , reslim , seplim CHARACTER ( LEN = 1 ) :: mgrid_mode !!DEC$ IF DEFINED (NETCDF) PRIVATE :: read_mgrid_bin , read_mgrid_nc !!DEC$ ELSE ! MJL 20160504      PRIVATE :: read_mgrid_bin !      PRIVATE :: read_mgrid_bin !!DEC$ ENDIF CONTAINS SUBROUTINE read_mgrid ( mgrid_file , extcur , nv , nfp , lscreen , 1 ier_flag ) USE system_mod IMPLICIT NONE C----------------------------------------------- C   D u m m y   V a r i a b l e s C----------------------------------------------- ! !     mgrid_file:     full path to mgrid file !     lscreen   :     logical controlling output to screen !     ier_flag  ;     error flag returned to caller !     extcur(n)    :  external current multiplier for bfield(n) components ! INTEGER , INTENT ( out ) :: ier_flag INTEGER , INTENT ( in ) :: nv , nfp LOGICAL , INTENT ( in ) :: lscreen REAL ( rprec ), INTENT ( in ) :: extcur (:) CHARACTER ( len =* ), INTENT ( in ) :: mgrid_file C----------------------------------------------- C   L o c a l   P a r a m e t e r s C----------------------------------------------- !!DEC$ IF DEFINED (VMS) !      CHARACTER(LEN=*), PARAMETER :: mgrid_defarea='vmec$:[makegrid]' !!DEC$ ELSE CHARACTER ( LEN =* ), PARAMETER :: mgrid_defarea = '$HOME/vmec/MAKEGRID' !!DEC$ ENDIF C----------------------------------------------- C   L o c a l   V a r i a b l e s C----------------------------------------------- ! !     lgrid_exist  :   logical set if mgrid file is found in given path ! INTEGER :: istat , ii CHARACTER ( LEN = 200 ) :: home_dir LOGICAL :: lgrid_exist , lfind C----------------------------------------------- mgrid_path (:) = ' ' mgrid_path = TRIM ( mgrid_file ) IF (( mgrid_path . eq . TRIM ( mgrid_path_old )) . and . 1 ALLOCATED ( curlabel )) THEN PRINT * , ' mgrid file previously parsed!' RETURN END IF INQUIRE ( file = mgrid_path , exist = lgrid_exist , iostat = istat ) IF ( istat . ne . 0 . or . . not . lgrid_exist ) THEN IF ( lscreen ) PRINT * , ' MGRID FILE NOT FOUND IN SPECIFIED ' , 1 'PATH: SEARCHING DEFAULT AREA' ii = INDEX ( mgrid_file , '/' , back = . true .) istat = INDEX ( mgrid_defarea , '$HOME' ) IF ( istat . ne . 0 ) THEN CALL getenv ( 'HOME' , home_dir ) IF ( istat . gt . 1 ) THEN home_dir = mgrid_defarea ( 1 : istat - 1 ) // TRIM ( home_dir ) 1 // mgrid_defarea ( istat + 5 :) ELSE home_dir = TRIM ( home_dir ) // mgrid_defarea ( istat + 5 :) END IF ELSE home_dir = mgrid_defarea END IF mgrid_path = TRIM ( home_dir ) // mgrid_file ( ii + 1 :) INQUIRE ( file = mgrid_path , exist = lgrid_exist , iostat = istat ) END IF mgrid_path_old = mgrid_path ier_flag = 0 IF ( lgrid_exist ) THEN IF ( lscreen ) PRINT '(2x,2a)' , 1 'Opening vacuum field file: ' , TRIM ( mgrid_file ) ! !        Parse mgrid file name, look for .nc extension (netcdf format) ! ii = LEN_TRIM ( TRIM ( mgrid_path )) - 2 lfind = ( mgrid_path ( ii : ii + 2 ) == '.nc' ) IF ( lfind ) THEN !DEC$ IF DEFINED (NETCDF) CALL read_mgrid_nc ( mgrid_path , extcur , nv , nfp , 1 ier_flag , lscreen ) !DEC$ ELSE lgrid_exist = . false . !DEC$ ENDIF ELSE CALL read_mgrid_bin ( mgrid_path , extcur , nv , nfp , 1 ier_flag , lscreen ) END IF IF ( np0b . ne . nv ) THEN IF ( lnverror ) PRINT * , ' NZETA=' , nv , 1 ' NOT EQUAL TO NP0B=' , np0b , ' IN MGRID FILE' ier_flag = 9 ELSE IF ( nfper0 . ne . nfp ) THEN PRINT * , ' NFP(READ in) = ' , nfp , ' DOES NOT AGREE WITH ' , 1 'NFPER (in vacuum field file) = ' , nfper0 ier_flag = 9 END IF END IF IF ( ier_flag . ne . 0 ) RETURN IF (. not . lgrid_exist . or . ier_flag . ne . 0 ) THEN lfreeb = . false . lrecon = . false . IF ( lscreen ) THEN PRINT * , ' Error opening/reading mgrid file in dir: ' , 1 TRIM ( home_dir ) PRINT * , ' User must supply vacuum bfield in mgrid to ' , 1 'run vmec in free-boundary mode!' PRINT * , ' Proceeding to run vmec in' , 1 ' fixed boundary mode' END IF END IF END SUBROUTINE read_mgrid SUBROUTINE read_mgrid_bin ( filename , extcur , nv , nfp , ier_flag , 1 lscreen ) USE safe_open_mod IMPLICIT NONE C----------------------------------------------- C   D u m m y  A r g u m e n t s C----------------------------------------------- ! !     lstyle_2000  :   logical controlling ordering of magnetic field components read in ! INTEGER , INTENT ( in ) :: nv , nfp CHARACTER ( LEN =* ), INTENT ( in ) :: filename REAL ( rprec ), INTENT ( in ) :: extcur (:) C----------------------------------------------- C   L o c a l   V a r i a b l e s C----------------------------------------------- REAL ( rprec ), DIMENSION (:,:,:), ALLOCATABLE :: 1 brtemp , bztemp , bptemp INTEGER :: ier_flag , iunit = 50 INTEGER :: istat , ig , i , j , n , n1 , m , nsets_max , k LOGICAL :: lscreen , lstyle_2000 C----------------------------------------------- CALL safe_open ( iunit , istat , filename , 'old' , 'unformatted' ) IF ( istat . ne . 0 ) THEN ier_flag = 9 RETURN END IF READ ( iunit , iostat = istat ) nr0b , nz0b , np0b , nfper0 , nextcur IF ( istat . ne . 0 ) ier_flag = 9 IF ( nfper0 . ne . nfp . or . np0b . ne . nv ) RETURN lstyle_2000 = ( nextcur < 0 ) nextcur = ABS ( nextcur ) READ ( iunit , iostat = istat ) rminb , zminb , rmaxb , zmaxb IF ( istat . ne . 0 ) ier_flag = 9 IF ( nextcur . eq . 0 ) THEN PRINT * , ' NEXTCUR = 0 IN READING MGRID FILE' ier_flag = 9 ELSE IF ( nextcur . gt . nigroup ) THEN PRINT * , ' NEXTCUR > NIGROUP IN MGRID FILE' ier_flag = 9 END IF IF ( ier_flag . ne . 0 ) RETURN ALLOCATE ( curlabel ( 5 * ( nextcur / 5 + 1 )), stat = istat ) !MIN of 5 for printing curlabel = \" \" READ ( iunit , iostat = istat ) ( curlabel ( n ), n = 1 , nextcur ) IF ( istat . ne . 0 ) THEN PRINT * , ' reading mgrid file failed (curlabel)' ier_flag = 9 RETURN END IF ! !     NOTE: ADD UP CONTRIBUTION TO BVAC DIRECTLY FOR ALL EXTERNAL CURRENT GROUPS nbvac = nr0b * nz0b * np0b IF (. NOT . ALLOCATED ( bvac )) THEN ALLOCATE ( bvac ( nbvac , 3 )) ELSE IF ( SIZE ( bvac , 1 ) . ne . nbvac ) THEN DEALLOCATE ( bvac ); ALLOCATE ( bvac ( nbvac , 3 )) END IF ALLOCATE ( brtemp ( nr0b , nz0b , np0b ), bptemp ( nr0b , nz0b , np0b ), 1 bztemp ( nr0b , nz0b , np0b ), stat = istat ) IF ( istat . ne . 0 ) THEN PRINT * , ' allocation for b-vector storage failed' ier_flag = 9 RETURN END IF bvac = 0 DO ig = 1 , nextcur IF ( lstyle_2000 ) THEN READ ( iunit , iostat = istat ) brtemp , bptemp , bztemp ELSE READ ( iunit , iostat = istat ) ((( brtemp ( i , j , k ), bztemp ( i , j , k ), 1 bptemp ( i , j , k ), i = 1 , nr0b ), 2 j = 1 , nz0b ), k = 1 , np0b ) END IF ! !        STORE SUMMED BFIELD (OVER COIL GROUPS) IN BVAC ! CALL sum_bfield ( bvac ( 1 , 1 ), brtemp , extcur ( ig ), nbvac ) CALL sum_bfield ( bvac ( 1 , 2 ), bptemp , extcur ( ig ), nbvac ) CALL sum_bfield ( bvac ( 1 , 3 ), bztemp , extcur ( ig ), nbvac ) END DO DEALLOCATE ( brtemp , bztemp , bptemp ) IF ( istat . ne . 0 ) THEN ier_flag = 9 RETURN END IF IF ( lstyle_2000 ) THEN READ ( iunit , iostat = istat ) mgrid_mode IF ( istat . eq . 0 ) THEN ALLOCATE ( raw_coil_current ( nextcur )) READ ( iunit , iostat = istat ) raw_coil_current ( 1 : nextcur ) IF ( istat . ne . 0 ) mgrid_mode = 'N' END IF ELSE mgrid_mode = 'N' !Old-style, no mode info END IF ! !     READ IN EXTERNAL POLOIDAL FLUX, FIELD MEASURMENT !     LOOP COORDINATES AND LABELS ! READ ( iunit , iostat = istat ) nobser , nobd , nbsets IF ( istat . ne . 0 ) THEN nobser = 0 nobd = 0 nbsets = 0 IF ( lscreen ) PRINT * , ' No observation data in mgrid data' GOTO 900 END IF nbfldn = SUM ( nbfld (: nbsets )) ALLOCATE ( nbcoils ( nbsets ), stat = istat ) READ ( iunit ) ( nbcoils ( n ), n = 1 , nbsets ) nbcoil_max = MAXVAL ( nbcoils (: nbsets )) ALLOCATE ( xobser ( nobser ), zobser ( nobser ), dsilabel ( nobd ), 1 iconnect ( 4 , nobser + nobd ), unpsiext ( nobser , nextcur ), 2 xobsqr ( nobser ), needflx ( nobser ), plflux ( nobser + nobd ), 3 dsiext ( nobd ), psiext ( nobser ), bloopnames ( nbsets ), 4 needbfld ( nbcoil_max , nbsets ), plbfld ( nbcoil_max , nbsets ), 5 rbcoil ( nbcoil_max , nbsets ), zbcoil ( nbcoil_max , nbsets ), 6 abcoil ( nbcoil_max , nbsets ), bcoil ( nbcoil_max , nbsets ), 7 rbcoilsqr ( nbcoil_max , nbsets ), b_chi ( nbsets ), 8 dbcoil ( nbcoil_max , nbsets , nextcur ), stat = istat ) IF ( istat . ne . 0 ) THEN IF ( lscreen ) 1 PRINT * , ' allocation error for xobser: istat = ' , istat ier_flag = 9 RETURN END IF IF ( nobser . gt . nfloops ) THEN PRINT * , 'NOBSER>NFLOOPS' ier_flag = 9 END IF IF ( nobd . gt . nfloops ) THEN PRINT * , 'NOBD>NFLOOPS' ier_flag = 9 END IF IF ( nflxs . gt . nfloops ) THEN PRINT * , 'NFLXS>NFLOOPS' ier_flag = 9 END IF IF ( nbfldn . gt . nbctotp ) THEN PRINT * , 'NBFLDN>NBCTOTP' ier_flag = 9 END IF IF ( nbcoil_max . gt . nbcoilsp ) THEN PRINT * , 'NBCOIL_max>NBCOILSP' ier_flag = 9 END IF IF ( ier_flag . ne . 0 ) RETURN IF ( nobser + nobd . gt . 0 ) iconnect (: 4 ,: nobser + nobd ) = 0 READ ( iunit ) ( xobser ( n ), zobser ( n ), n = 1 , nobser ) READ ( iunit ) ( dsilabel ( n ), n = 1 , nobd ) READ ( iunit ) (( iconnect ( j , n ), j = 1 , 4 ), n = 1 , nobd ) IF ( nbcoil_max . gt . 0 . and . nbsets . gt . 0 ) THEN rbcoil (: nbcoil_max ,: nbsets ) = 0 zbcoil (: nbcoil_max ,: nbsets ) = 0 abcoil (: nbcoil_max ,: nbsets ) = 0 DO n = 1 , nbsets IF ( nbcoils ( n ). gt . 0 ) THEN READ ( iunit ) n1 , bloopnames ( n1 ) READ ( iunit )( rbcoil ( m , n ), zbcoil ( m , n ), abcoil ( m , n ), 1 m = 1 , nbcoils ( n )) ENDIF ENDDO dbcoil (: nbcoil_max ,: nbsets ,: nextcur ) = 0 END IF DO ig = 1 , nextcur !un-connected coil fluxes READ ( iunit ) ( unpsiext ( n , ig ), n = 1 , nobser ) DO n = 1 , nbsets READ ( iunit ) ( dbcoil ( m , n , ig ), m = 1 , nbcoils ( n )) ENDDO ENDDO ! !     READ LIMITER & PROUT PLOTTING SPECS ! ALLOCATE ( limitr ( nlimset ), nsetsn ( nigroup )) READ ( iunit , iostat = istat ) nlim ,( limitr ( i ), i = 1 , nlim ) IF ( istat . ne . 0 ) then nlim = 0 IF ( lscreen ) PRINT * , ' No limiter data in mgrid file' GOTO 900 END IF nlim_max = MAXVAL ( limitr ) IF ( nlim . gt . nlimset ) THEN PRINT * , 'nlim>nlimset' ier_flag = 9 RETURN END IF ALLOCATE ( rlim ( nlim_max , nlim ), zlim ( nlim_max , nlim ), 1 reslim ( nlim_max , nlim ) , seplim ( nlim_max , nlim ), 2 stat = istat ) IF ( istat . ne . 0 ) THEN PRINT * , 'rlim istat!=0' ier_flag = 9 RETURN END IF READ ( iunit , iostat = istat ) 1 (( rlim ( i , j ), zlim ( i , j ), i = 1 , limitr ( j )), j = 1 , nlim ) READ ( iunit , iostat = istat ) nsets ,( nsetsn ( i ), i = 1 , nsets ) IF ( nsets . gt . nigroup ) THEN PRINT * , 'nsets>nigroup' ier_flag = 9 RETURN ELSE IF ( istat . ne . 0 ) THEN ier_flag = 9 RETURN END IF nsets_max = MAXVAL ( nsetsn ) IF ( nsets_max . gt . npfcoil ) THEN PRINT * , 'nsetsn>npfcoil' ier_flag = 9 RETURN END IF ALLOCATE ( pfcspec ( nparts , nsets_max , nsets ), stat = istat ) !     NOTE TO RMW: SHOULD READ IN NPARTS HERE (PUT INTO MGRID FILE) READ ( iunit , iostat = istat ) ((( pfcspec ( i , j , k ), i = 1 , nparts ), 1 j = 1 , nsetsn ( k )), k = 1 , nsets ) DEALLOCATE ( limitr , nsetsn ) READ ( iunit , iostat = istat ) rx1 , rx2 , zy1 , zy2 , condif , 1 nrgrid , nzgrid , tokid IF ( istat . ne . 0 ) THEN ier_flag = 9 RETURN END IF IF ( nobser . gt . 0 ) xobsqr (: nobser ) = SQRT ( xobser (: nobser )) ! !       PARTITION MGRID B-LOOPS INTO SETS ! nbcoilsn = SUM ( nbcoils (: nbsets )) DO n = 1 , nbsets rbcoilsqr (: nbcoils ( n ), n ) = SQRT ( rbcoil (: nbcoils ( n ), n )) ENDDO 900 CONTINUE CLOSE ( iunit ) delrb = ( rmaxb - rminb ) / ( nr0b - 1 ) delzb = ( zmaxb - zminb ) / ( nz0b - 1 ) ! !     SUM UP CONTRIBUTIONS FROM INDIVIDUAL COIL GROUPS ! IF ( lfreeb ) THEN IF ( nobser . gt . 0 ) psiext (: nobser ) = 0 IF ( nbcoil_max . gt . 0 . and . nbsets . gt . 0 ) 1 bcoil (: nbcoil_max , : nbsets ) = 0 DO ig = 1 , nextcur IF ( nobser . gt . 0 ) 1 psiext (: nobser ) = psiext (: nobser ) + 2 extcur ( ig ) * unpsiext (: nobser , ig ) DO n = 1 , nbsets n1 = nbcoils ( n ) bcoil (: n1 , n ) = bcoil (: n1 , n ) + 1 extcur ( ig ) * dbcoil (: n1 , n , ig ) ENDDO ENDDO ENDIF !!IF LFREEB END SUBROUTINE read_mgrid_bin !DEC$ IF DEFINED (NETCDF) SUBROUTINE read_mgrid_nc ( filename , extcur , nv , nfp , 1 ier_flag , lscreen ) USE ezcdf IMPLICIT NONE C----------------------------------------------- C   D u m m y  A r g u m e n t s C----------------------------------------------- CHARACTER ( LEN =* ), INTENT ( in ) :: filename INTEGER , INTENT ( in ) :: nv , nfp REAL ( rprec ), INTENT ( in ) :: extcur (:) C----------------------------------------------- C   L o c a l   V a r i a b l e s C----------------------------------------------- REAL ( rprec ), DIMENSION (:,:,:), ALLOCATABLE :: 1 brtemp , bztemp , bptemp INTEGER :: ier_flag , ngrid INTEGER :: istat , ig LOGICAL :: lscreen INTEGER , DIMENSION ( 3 ) :: dimlens CHARACTER ( LEN = 100 ) :: temp CHARACTER ( LEN = 100 ), ALLOCATABLE , DIMENSION (:) :: 1 vn_br , vn_bp , vn_bz C----------------------------------------------- call cdf_open ( ngrid , filename , 'r' , istat ) IF ( istat . ne . 0 ) THEN ier_flag = 9 RETURN END IF ! !     READ IN DATA ! CALL cdf_read ( ngrid , vn_ir , nr0b ) CALL cdf_read ( ngrid , vn_jz , nz0b ) CALL cdf_read ( ngrid , vn_kp , np0b ) CALL cdf_read ( ngrid , vn_nfp , nfper0 ) IF ( nfper0 . ne . nfp . or . np0b . ne . nv ) RETURN CALL cdf_read ( ngrid , vn_nextcur , nextcur ) IF ( nextcur . eq . 0 ) THEN PRINT * , ' NEXTCUR = 0 IN READING MGRID FILE' ier_flag = 9 RETURN ELSE IF ( nextcur . gt . nigroup ) THEN PRINT * , ' NEXTCUR > NIGROUP IN MGRID FILE' ier_flag = 9 RETURN END IF CALL cdf_read ( ngrid , vn_rmin , rminb ) CALL cdf_read ( ngrid , vn_zmin , zminb ) CALL cdf_read ( ngrid , vn_rmax , rmaxb ) CALL cdf_read ( ngrid , vn_zmax , zmaxb ) delrb = ( rmaxb - rminb ) / ( nr0b - 1 ) delzb = ( zmaxb - zminb ) / ( nz0b - 1 ) CALL cdf_inquire ( ngrid , vn_coilgrp , dimlens ) IF ( . NOT . ALLOCATED ( curlabel )) THEN ALLOCATE ( curlabel ( nextcur ), stat = istat ) ELSE IF ( SIZE ( curlabel ) . ne . nextcur ) THEN D EALLOCATE ( curlabel ) ALLOCATE ( curlabel ( nextcur ), stat = istat ) END I F !THIS IS A GLITCH WITH cdf_read: must distinguish 1D char array from multi-D IF ( nextcur . eq . 1 ) THEN IF ( istat . eq . 0 ) 1 CALL cdf_read ( ngrid , vn_coilgrp , curlabel ( 1 )) ELSE IF ( istat . eq . 0 ) THEN CALL cdf_read ( ngrid , vn_coilgrp , curlabel ( 1 : nextcur )) END IF IF ( i stat . ne . 0 ) STOP 'Error allocating CURLABEL in mgrid_mod' ! !     READ 3D Br, Bp, Bz ARRAYS FOR EACH COIL GROUP ! ALLOCATE ( vn_br ( nextcur ), vn_bz ( nextcur ), vn_bp ( nextcur ), 1 stat = istat ) IF ( i stat . ne . 0 ) STOP 'Error allocating vn_bX in mgrid_mod' nbvac = nr0b * nz0b * np0b IF (. NOT . ALLOCATED ( bvac )) THEN ALLOCATE ( bvac ( nbvac , 3 ), stat = istat ) ELSE IF ( SIZE ( bvac , 1 ) . ne . nbvac ) THEN DEALLOCATE ( bvac ); ALLOCATE ( bvac ( nbvac , 3 ), stat = istat ) END IF IF ( istat . ne . 0 ) STOP 'Error allocating bvac in mgrid_mod' bvac = 0 DO ig = 1 , nextcur WRITE ( temp , '(a,i3.3)' ) \"_\" , ig vn_br ( ig ) = vn_br0 // temp vn_bp ( ig ) = vn_bp0 // temp vn_bz ( ig ) = vn_bz0 // temp CALL cdf_inquire ( ngrid , vn_br ( ig ), dimlens ) IF (. NOT . ALLOCATED ( brtemp )) THEN ALLOCATE ( brtemp ( dimlens ( 1 ), dimlens ( 2 ), dimlens ( 3 )), 1 bptemp ( dimlens ( 1 ), dimlens ( 2 ), dimlens ( 3 )), 2 bztemp ( dimlens ( 1 ), dimlens ( 2 ), dimlens ( 3 )), 3 stat = istat ) IF ( istat . ne . 0 ) STOP 'Error allocating bXtemp in mgrid_mod' END IF CALL cdf_read ( ngrid , vn_br ( ig ), brtemp ) CALL cdf_read ( ngrid , vn_bp ( ig ), bptemp ) CALL cdf_read ( ngrid , vn_bz ( ig ), bztemp ) ! !        STORE SUMMED BFIELD (OVER COIL GROUPS) IN BVAC ! CALL sum_bfield ( bvac ( 1 , 1 ), brtemp , extcur ( ig ), nbvac ) CALL sum_bfield ( bvac ( 1 , 2 ), bptemp , extcur ( ig ), nbvac ) CALL sum_bfield ( bvac ( 1 , 3 ), bztemp , extcur ( ig ), nbvac ) END DO ! !     MUST ADD EXTERNAL LOOP STUFF LATER !     MAY DECIDE TO WRITE THAT INFO INTO A SEPARATE FILE !     FOR NOW, JUST SET DEFAULTS ! nobser = 0 nobd = 0 nbsets = 0 CALL cdf_inquire ( ngrid , vn_mgmode , dimlens , ier = istat ) IF ( istat . eq . 0 ) THEN CALL cdf_read ( ngrid , vn_mgmode , mgrid_mode ) ELSE mgrid_mode = 'N' END IF CALL cdf_inquire ( ngrid , vn_coilcur , dimlens , ier = istat ) IF ( istat . eq . 0 ) THEN I F ( ALLOCATED ( raw_coil_current )) DEALLOCATE ( raw_coil_current ) ALLOCATE ( raw_coil_current ( nextcur ), stat = istat ) IF ( istat . ne . 0 ) STOP 'Error allocating RAW_COIL in mgrid_mod' CALL cdf_read ( ngrid , vn_coilcur , raw_coil_current ) END IF CALL cdf_close ( ngrid ) IF ( ALLOCATED ( brtemp )) 1 DEALLOCATE ( vn_br , vn_bz , vn_bp , brtemp , bptemp , bztemp ) END SUBROUTINE read_mgrid_nc !DEC$ ENDIF SUBROUTINE sum_bfield ( bfield , bf_add , cur , n1 ) INTEGER :: n1 REAL ( rprec ), INTENT ( inout ) :: bfield ( n1 ) REAL ( rprec ), INTENT ( in ) :: bf_add ( n1 ) REAL ( rprec ) :: cur bfield = bfield + cur * bf_add END SUBROUTINE sum_bfield SUBROUTINE assign_bptrs ( bptr ) IMPLICIT NONE REAL ( rprec ), TARGET , INTENT ( in ) :: bptr ( nr0b , nz0b , np0b , 3 ) brvac => bptr (:,:,:, 1 ) bpvac => bptr (:,:,:, 2 ) bzvac => bptr (:,:,:, 3 ) END SUBROUTINE assign_bptrs SUBROUTINE free_mgrid ( istat ) INTEGER :: istat istat = 0 mgrid_path_old = '' IF ( ALLOCATED ( bvac )) DEALLOCATE ( bvac , stat = istat ) IF ( ALLOCATED ( xobser )) 1 DEALLOCATE ( xobser , xobsqr , zobser , unpsiext , dsiext , 2 psiext , plflux , iconnect , needflx , needbfld , plbfld , 3 nbcoils , rbcoil , zbcoil , abcoil , bcoil , rbcoilsqr , dbcoil , 4 pfcspec , dsilabel , bloopnames , curlabel , b_chi , stat = istat ) IF ( ALLOCATED ( raw_coil_current )) DEALLOCATE ( raw_coil_current ) IF ( ALLOCATED ( rlim )) 1 DEALLOCATE ( rlim , zlim , reslim , seplim , stat = istat ) END SUBROUTINE free_mgrid END MODULE mgrid_mod","tags":"","loc":"sourcefile/mgrid_mod.f.html"},{"title":"ezcdf_GenPut.f90 â€“ stella","text":"Contents Modules ezcdf_GenPut Source Code ezcdf_GenPut.f90 Source Code MODULE ezcdf_GenPut USE ezcdf_opncls USE ezcdf_inqvar ! Generic Interface to Write netcdf data Variables ! 03/10/99 C. Ludescher ! C. Ludescher/A. Pletzer Tue Apr  4 10:11:33 EDT 2000 ! + support for complex numbers (ap) Wed May 16 15:18:05 EDT 2001 ! added support for logicals (sph) Oct 1, 2002 IMPLICIT NONE !DEC$ IF DEFINED (NETCDF) ! ! C. Ludescher/A. Pletzer Tue Apr  4 10:11:33 EDT 2000 ! ! added support (ap) Wed May 16 15:06:34 EDT 2001 PUBLIC :: cdfw_3i , cdfw_3l , cdfw_3d , cdfw_3c16 , cdfw_3f , cdfw_3c8 , & & cdfw_2i , cdfw_2l , cdfw_2d , cdfw_2c16 , cdfw_2f , cdfw_2c8 , cdfw_2c , & & cdfw_1i , cdfw_1l , cdfw_1d , cdfw_1c16 , cdfw_1f , cdfw_1c8 , cdfw_1c , & & cdfw_0i , cdfw_0l , cdfw_0d , cdfw_0c16 , cdfw_0f , cdfw_0c8 , & & cdfPutVar , cdf_write ! cdf_write is an alias of cdfPutVar (required by ifc compiler) INTERFACE cdf_write MODULE PROCEDURE cdfw_3i , cdfw_3l , cdfw_3d , cdfw_3c16 , cdfw_3f , cdfw_3c8 , & cdfw_2i , cdfw_2l , cdfw_2d , cdfw_2c16 , cdfw_2f , cdfw_2c8 , cdfw_2c , & cdfw_1i , cdfw_1l , cdfw_1d , cdfw_1c16 , cdfw_1f , cdfw_1c8 , cdfw_1c , & cdfw_0i , cdfw_0l , cdfw_0d , cdfw_0c16 , cdfw_0f , cdfw_0c8 END INTERFACE ! same as above (Intel compiler does not handle well aliases) INTERFACE cdfPutVar MODULE PROCEDURE cdfw_3i , cdfw_3l , cdfw_3d , cdfw_3c16 , cdfw_3f , cdfw_3c8 , & cdfw_2i , cdfw_2l , cdfw_2d , cdfw_2c16 , cdfw_2f , cdfw_2c8 , cdfw_2c , & cdfw_1i , cdfw_1l , cdfw_1d , cdfw_1c16 , cdfw_1f , cdfw_1c8 , cdfw_1c , & cdfw_0i , cdfw_0l , cdfw_0d , cdfw_0c16 , cdfw_0f , cdfw_0c8 END INTERFACE PUBLIC :: cdfDefVar , cdf_define , & & cdfd_3i , cdfd_3l , cdfd_3d , cdfd_3c16 , cdfd_3f , cdfd_3c8 , & & cdfd_2i , cdfd_2l , cdfd_2d , cdfd_2c16 , cdfd_2f , cdfd_2c8 , cdfd_2c , & & cdfd_1i , cdfd_1l , cdfd_1d , cdfd_1c16 , cdfd_1f , cdfd_1c8 , cdfd_1c , & & cdfd_0i , cdfd_0l , cdfd_0d , cdfd_0c16 , cdfd_0f , cdfd_0c8 INTERFACE cdf_define MODULE PROCEDURE cdfDefVar , & cdfd_3i , cdfd_3l , cdfd_3d , cdfd_3c16 , cdfd_3f , cdfd_3c8 , & cdfd_2i , cdfd_2l , cdfd_2d , cdfd_2c16 , cdfd_2f , cdfd_2c8 , cdfd_2c , & cdfd_1i , cdfd_1l , cdfd_1d , cdfd_1c16 , cdfd_1f , cdfd_1c8 , cdfd_1c , & cdfd_0i , cdfd_0l , cdfd_0d , cdfd_0c16 , cdfd_0f , cdfd_0c8 END INTERFACE PRIVATE include \"netcdf.inc\" INTEGER , PARAMETER :: r4 = SELECTED_REAL_KIND ( 6 , 37 ) INTEGER , PARAMETER :: r8 = SELECTED_REAL_KIND ( 12 , 100 ) CHARACTER * 13 , parameter :: cmplx_name = '__CmPlx_Re_Im' CHARACTER ( len = nf_max_name ) :: varnam_noalpha PRIVATE :: r4 , r8 , cmplx_name , varnam_noalpha EXTERNAL handle_err CONTAINS !----------------------------------------------------------------- !cdfPutVar implementation routines SUBROUTINE cdfw_3i ( ncid , varnam , varval , ier ) !     Write 3 dimensional Integer data array !     Use cdfDefVar to define the Variable implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam integer , dimension (:, :, :), intent ( in ) :: varval ! Output integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 3 ) :: st = ( / 1 , 1 , 1 / ) integer , dimension ( 3 ) :: dimlens integer :: varid , ndims , sts if ( PRESENT ( ier )) ier = 1 sts = nf_enddef ( ncid ) call cdfInqV ( ncid , varnam , varid , dimlens , ndims , sts ) if ( sts /= 0 ) return if ( ndims /= 3 ) then print \"('% cdfPutVar_3i: --E-- The variable ',a,               & &         ' was defined as',i2,' dimensional')\" , varnam , ndims return end if sts = nf_put_vara_int ( ncid , varid , st , dimlens , varval ) call handle_err ( sts , varnam , 'cdfPutVar_3i' , 'nf_put_vara_int' ) if ( PRESENT ( ier )) ier = sts END SUBROUTINE cdfw_3i SUBROUTINE cdfw_3l ( ncid , varnam , varval , ier ) !     Write 3 dimensional logical array !     Use cdfDefVar to define the Variable implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam logical , dimension (:, :, :), intent ( in ) :: varval ! Output integer , optional , intent ( out ) :: ier ! Local integer :: sts integer , allocatable , dimension (:, :, :) :: varval_i character * 11 , parameter :: logical_name = '__logical__' ALLOCATE ( varval_i ( size ( varval , 1 ), size ( varval , 2 ), size ( varval , 3 )), stat = sts ) if ( sts /= 0 ) stop 'Allocation error in cdf_putvar' WHERE ( varval ) varval_i = 1 ELSEWHERE varval_i = 0 END WHERE call cdfw_3i ( ncid , trim ( varnam ) // logical_name , varval_i , ier ) DEALLOCATE ( varval_i ) END SUBROUTINE cdfw_3l SUBROUTINE cdfw_3d ( ncid , varnam , varval , ier ) !     Write 3 dimensional 64-bit Real data array !     Use cdfDefVar to define the Variable implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam REAL ( KIND = r8 ), dimension (:, :, :), intent ( in ) :: varval ! Output integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 3 ) :: st = ( / 1 , 1 , 1 / ) integer , dimension ( 3 ) :: dimlens integer :: varid , ndims , sts if ( PRESENT ( ier )) ier = 1 sts = nf_enddef ( ncid ) call cdfInqV ( ncid , varnam , varid , dimlens , ndims , sts ) if ( sts /= 0 ) return if ( ndims /= 3 ) then print \"('% cdfPutVar_3d: --E-- The variable ',a,               & &         ' was defined as',i2,' dimensional')\" , varnam , ndims return end if sts = nf_put_vara_double ( ncid , varid , st , dimlens , varval ) call handle_err ( sts , varnam , 'cdf_3d' , 'nf_put_vara_double' ) if ( PRESENT ( ier )) ier = sts END SUBROUTINE cdfw_3d SUBROUTINE cdfw_3c16 ( ncid , varnam , varval , ier ) !     Write 3 dimensional 128-bit complex data array !     Use cdfDefVar to define the Variable implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam COMPLEX ( KIND = r8 ), dimension (:, :, :), intent ( in ) :: varval ! Output integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 3 ) :: st = ( / 1 , 1 , 1 / ) integer , dimension ( 3 ) :: dimlens integer :: varid , ndims , sts if ( PRESENT ( ier )) ier = 1 sts = nf_enddef ( ncid ) call cdfInqV ( ncid , trim ( varnam ) // cmplx_name , varid , dimlens , ndims , sts ) if ( sts /= 0 ) return if ( ndims /= 3 ) then print \"('% cdfPutVar_3c16: --E-- The variable ',a,               & &         ' was defined as',i2,' dimensional')\" , varnam , ndims return end if sts = nf_put_vara_double ( ncid , varid , st , dimlens , varval ) call handle_err ( sts , varnam , 'cdf_3c16' , 'nf_put_vara_double' ) if ( PRESENT ( ier )) ier = sts END SUBROUTINE cdfw_3c16 SUBROUTINE cdfw_3f ( ncid , varnam , varval , ier ) !     Write 3 dimensional default Real data array !     Use cdfDefVar to define the Variable implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam REAL ( KIND = r4 ), dimension (:, :, :), intent ( in ) :: varval ! Output integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 3 ) :: st = ( / 1 , 1 , 1 / ) integer , dimension ( 3 ) :: dimlens integer :: varid , ndims , sts if ( PRESENT ( ier )) ier = 1 sts = nf_enddef ( ncid ) call cdfInqV ( ncid , varnam , varid , dimlens , ndims , sts ) if ( sts /= 0 ) return if ( ndims /= 3 ) then print \"('% cdfPutVar_3f: --E-- The variable ',a,               & &         ' was defined as',i2,' dimensional')\" , varnam , ndims return end if sts = nf_put_vara_real ( ncid , varid , st , dimlens , varval ) call handle_err ( sts , varnam , 'cdf_3f' , 'nf_put_vara_real' ) if ( PRESENT ( ier )) ier = sts END SUBROUTINE cdfw_3f SUBROUTINE cdfw_3c8 ( ncid , varnam , varval , ier ) !     Write 3 dimensional complex*8 data array !     Use cdfDefVar to define the Variable implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam COMPLEX ( KIND = r4 ), dimension (:, :, :), intent ( in ) :: varval ! Output integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 3 ) :: st = ( / 1 , 1 , 1 / ) integer , dimension ( 3 ) :: dimlens integer :: varid , ndims , sts if ( PRESENT ( ier )) ier = 1 sts = nf_enddef ( ncid ) call cdfInqV ( ncid , trim ( varnam ) // cmplx_name , varid , dimlens , ndims , sts ) if ( sts /= 0 ) return if ( ndims /= 3 ) then print \"('% cdfPutVar_3c8: --E-- The variable ',a,               & &         ' was defined as',i2,' dimensional')\" , varnam , ndims return end if sts = nf_put_vara_real ( ncid , varid , st , dimlens , varval ) call handle_err ( sts , varnam , 'cdf_3c8' , 'nf_put_vara_real' ) if ( PRESENT ( ier )) ier = sts END SUBROUTINE cdfw_3c8 SUBROUTINE cdfw_2i ( ncid , varnam , varval , ier ) !     Write 2 dimensional Integer data array !     Use cdfDefVar to define the Variable implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam integer , dimension (:, :), intent ( in ) :: varval ! Output integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 2 ) :: st = ( / 1 , 1 / ) integer , dimension ( 2 ) :: dimlens integer :: varid , ndims , sts if ( PRESENT ( ier )) ier = 1 sts = nf_enddef ( ncid ) call cdfInqV ( ncid , varnam , varid , dimlens , ndims , sts ) if ( sts /= 0 ) return if ( ndims /= 2 ) then print \"('% cdfPutVar_2i: --E-- The variable ',a,               & &         ' was defined as',i2,' dimensional')\" , varnam , ndims return end if sts = nf_put_vara_int ( ncid , varid , st , dimlens , varval ) call handle_err ( sts , varnam , 'cdfPutVar_2i' , 'nf_put_vara_int' ) if ( PRESENT ( ier )) ier = sts END SUBROUTINE cdfw_2i SUBROUTINE cdfw_2l ( ncid , varnam , varval , ier ) !     Write 2 dimensional logical array !     Use cdfDefVar to define the Variable implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam logical , dimension (:, :), intent ( in ) :: varval ! Output integer , optional , intent ( out ) :: ier ! Local integer :: sts integer , allocatable , dimension (:, :) :: varval_i character * 11 , parameter :: logical_name = '__logical__' ALLOCATE ( varval_i ( size ( varval , 1 ), size ( varval , 2 )), stat = sts ) if ( sts /= 0 ) stop 'Allocation error in cdf_putvar' WHERE ( varval ) varval_i = 1 ELSEWHERE varval_i = 0 END WHERE call cdfw_2i ( ncid , trim ( varnam ) // logical_name , varval_i , ier ) DEALLOCATE ( varval_i ) END SUBROUTINE cdfw_2l SUBROUTINE cdfw_2d ( ncid , varnam , varval , ier ) !     Write 2 dimensional 64-bit Real data array !     Use cdfDefVar to define the Variable implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam REAL ( KIND = r8 ), dimension (:, :), intent ( in ) :: varval ! Output integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 2 ) :: st = ( / 1 , 1 / ) integer , dimension ( 2 ) :: dimlens integer :: varid , ndims , sts if ( PRESENT ( ier )) ier = 1 sts = nf_enddef ( ncid ) call cdfInqV ( ncid , varnam , varid , dimlens , ndims , sts ) if ( sts /= 0 ) return if ( ndims /= 2 ) then print \"('% cdfPutVar_2d: --E-- The variable ',a,               & &         ' was defined as',i2,' dimensional')\" , varnam , ndims return end if sts = nf_put_vara_double ( ncid , varid , st , dimlens , varval ) call handle_err ( sts , varnam , 'cdf_2d' , 'nf_put_vara_double' ) if ( PRESENT ( ier )) ier = sts END SUBROUTINE cdfw_2d SUBROUTINE cdfw_2c16 ( ncid , varnam , varval , ier ) !     Write 2 dimensional 128-bit complex data array !     Use cdfDefVar to define the Variable implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam COMPLEX ( KIND = r8 ), dimension (:, :), intent ( in ) :: varval ! Output integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 2 ) :: st = ( / 1 , 1 / ) integer , dimension ( 2 ) :: dimlens integer :: varid , ndims , sts if ( PRESENT ( ier )) ier = 1 sts = nf_enddef ( ncid ) call cdfInqV ( ncid , trim ( varnam ) // cmplx_name , varid , dimlens , ndims , sts ) if ( sts /= 0 ) return if ( ndims /= 2 ) then print \"('% cdfPutVar_2c16: --E-- The variable ',a,               & &         ' was defined as',i2,' dimensional')\" , varnam , ndims return end if sts = nf_put_vara_double ( ncid , varid , st , dimlens , varval ) call handle_err ( sts , varnam , 'cdf_2c16' , 'nf_put_vara_double' ) if ( PRESENT ( ier )) ier = sts END SUBROUTINE cdfw_2c16 SUBROUTINE cdfw_2f ( ncid , varnam , varval , ier ) !     Write 2 dimensional default Real data array !     Use cdfDefVar to define the Variable implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam REAL ( KIND = r4 ), dimension (:, :), intent ( in ) :: varval ! Output integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 2 ) :: st = ( / 1 , 1 / ) integer , dimension ( 2 ) :: dimlens integer :: varid , ndims , sts if ( PRESENT ( ier )) ier = 1 sts = nf_enddef ( ncid ) call cdfInqV ( ncid , varnam , varid , dimlens , ndims , sts ) if ( sts /= 0 ) return if ( ndims /= 2 ) then print \"('% cdfPutVar_2f: --E-- The variable ',a,               & &         ' was defined as',i2,' dimensional')\" , varnam , ndims return end if sts = nf_put_vara_real ( ncid , varid , st , dimlens , varval ) call handle_err ( sts , varnam , 'cdf_2f' , 'nf_put_vara_real' ) if ( PRESENT ( ier )) ier = sts END SUBROUTINE cdfw_2f SUBROUTINE cdfw_2c8 ( ncid , varnam , varval , ier ) !     Write 2 dimensional complex*8 data array !     Use cdfDefVar to define the Variable implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam COMPLEX ( KIND = r4 ), dimension (:, :), intent ( in ) :: varval ! Output integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 2 ) :: st = ( / 1 , 1 / ) integer , dimension ( 2 ) :: dimlens integer :: varid , ndims , sts if ( PRESENT ( ier )) ier = 1 sts = nf_enddef ( ncid ) call cdfInqV ( ncid , trim ( varnam ) // cmplx_name , varid , dimlens , ndims , sts ) if ( sts /= 0 ) return if ( ndims /= 2 ) then print \"('% cdfPutVar_2c8: --E-- The variable ',a,               & &         ' was defined as',i2,' dimensional')\" , varnam , ndims return end if sts = nf_put_vara_real ( ncid , varid , st , dimlens , varval ) call handle_err ( sts , varnam , 'cdf_2c8' , 'nf_put_vara_real' ) if ( PRESENT ( ier )) ier = sts END SUBROUTINE cdfw_2c8 SUBROUTINE cdfw_2c ( ncid , varnam , varval , ier ) !     Write 2 dimensional character array !     Use cdfDefVar to define the Variable implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam character * ( * ), dimension (:), intent ( in ) :: varval ! Output integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 2 ) :: st = ( / 1 , 1 / ) integer , dimension ( 2 ) :: dimlens integer :: varid , ndims , sts if ( PRESENT ( ier )) ier = 1 sts = nf_enddef ( ncid ) call cdfInqV ( ncid , varnam , varid , dimlens , ndims , sts ) if ( sts /= 0 ) return if ( ndims /= 2 ) then print \"('% cdfPutVar_2c: --E-- The variable ',a,               & &         ' was defined as',i2,' dimensional')\" , varnam , ndims return end if sts = nf_put_vara_text ( ncid , varid , st , dimlens , varval ) call handle_err ( sts , varnam , 'cdfPutVar_2c' , 'nf_put_var_text' ) if ( PRESENT ( ier )) ier = sts END SUBROUTINE cdfw_2c SUBROUTINE cdfw_1i ( ncid , varnam , varval , ier ) !     write 1 dimensional Integer array implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam integer , dimension (:), intent ( in ) :: varval ! Output integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 1 ) :: dimlens integer :: varid , ndims , sts if ( PRESENT ( ier )) ier = 1 sts = nf_enddef ( ncid ) call cdfInqV ( ncid , varnam , varid , dimlens , ndims , sts ) if ( sts /= 0 ) return if ( ndims /= 1 ) then print \"('% cdfPutVar_1i: --E-- The variable ',a,               & &         ' was defined as',i2,' dimensional')\" , varnam , ndims return end if sts = nf_put_var_int ( ncid , varid , varval ) call handle_err ( sts , varnam , 'cdfPutVar_1i' , 'nf_put_var_int' ) if ( PRESENT ( ier )) ier = sts END SUBROUTINE cdfw_1i SUBROUTINE cdfw_1l ( ncid , varnam , varval , ier ) !     Write 1 dimensional logical array implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam logical , dimension (:), intent ( in ) :: varval ! Output integer , optional , intent ( out ) :: ier ! Local integer :: sts integer , allocatable , dimension (:) :: varval_i character * 11 , parameter :: logical_name = '__logical__' ALLOCATE ( varval_i ( size ( varval , 1 )), stat = sts ) if ( sts /= 0 ) stop 'Allocation error in cdf_putvar' WHERE ( varval ) varval_i = 1 ELSEWHERE varval_i = 0 END WHERE call cdfw_1i ( ncid , trim ( varnam ) // logical_name , varval_i , ier ) DEALLOCATE ( varval_i ) END SUBROUTINE cdfw_1l SUBROUTINE cdfw_1d ( ncid , varnam , varval , ier ) !     Write 1 dimensional 64-bit data array !     Use cdfDefVar to define the Variable ! implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam REAL ( KIND = r8 ), dimension (:), intent ( in ) :: varval ! Output integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 1 ) :: dimlens integer :: varid , ndims , sts if ( PRESENT ( ier )) ier = 1 sts = nf_enddef ( ncid ) call cdfInqV ( ncid , varnam , varid , dimlens , ndims , sts ) if ( sts /= 0 ) return if ( ndims /= 1 ) then print \"('% cdfPutVar_1d: --E-- The variable ',a,               & &         ' was defined as',i2,' dimensional')\" , varnam , ndims return end if sts = nf_put_var_double ( ncid , varid , varval ) call handle_err ( sts , varnam , 'cdfPurVar_1d' , 'nf_put_var_double' ) if ( PRESENT ( ier )) ier = sts END SUBROUTINE cdfw_1d SUBROUTINE cdfw_1c16 ( ncid , varnam , varval , ier ) !     Write 1 dimensional 128-bit complex data array !     Use cdfDefVar to define the Variable ! implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam COMPLEX ( KIND = r8 ), dimension (:), intent ( in ) :: varval ! Output integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 1 ) :: dimlens integer :: varid , ndims , sts if ( PRESENT ( ier )) ier = 1 sts = nf_enddef ( ncid ) call cdfInqV ( ncid , trim ( varnam ) // cmplx_name , varid , dimlens , ndims , sts ) if ( sts /= 0 ) return if ( ndims /= 1 ) then print \"('% cdfPutVar_1c16: --E-- The variable ',a,               & &         ' was defined as',i2,' dimensional')\" , varnam , ndims return end if sts = nf_put_var_double ( ncid , varid , varval ) call handle_err ( sts , varnam , 'cdfPurVar_1c16' , 'nf_put_var_double' ) if ( PRESENT ( ier )) ier = sts END SUBROUTINE cdfw_1c16 SUBROUTINE cdfw_1f ( ncid , varnam , varval , ier ) !     Write 1 dimensional default real array !     Use cdfDefVar to define the Variable ! implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam REAL ( KIND = r4 ), dimension (:), intent ( in ) :: varval ! Output integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 1 ) :: dimlens integer :: varid , ndims , sts if ( PRESENT ( ier )) ier = 1 sts = nf_enddef ( ncid ) call cdfInqV ( ncid , varnam , varid , dimlens , ndims , sts ) if ( sts /= 0 ) return if ( ndims /= 1 ) then print \"('% cdfPutVar_1f: --E-- The variable ',a,               & &         ' was defined as',i2,' dimensional')\" , varnam , ndims return end if sts = nf_put_var_real ( ncid , varid , varval ) call handle_err ( sts , varnam , 'cdfPurVar_1f' , 'nf_put_var_real' ) if ( PRESENT ( ier )) ier = sts END SUBROUTINE cdfw_1f SUBROUTINE cdfw_1c8 ( ncid , varnam , varval , ier ) !     Write 1 dimensional complex*8 array !     Use cdfDefVar to define the Variable ! implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam COMPLEX ( KIND = r4 ), dimension (:), intent ( in ) :: varval ! Output integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 1 ) :: dimlens integer :: varid , ndims , sts if ( PRESENT ( ier )) ier = 1 sts = nf_enddef ( ncid ) call cdfInqV ( ncid , trim ( varnam ) // cmplx_name , varid , dimlens , ndims , sts ) if ( sts /= 0 ) return if ( ndims /= 1 ) then print \"('% cdfPutVar_1c8: --E-- The variable ',a,               & &         ' was defined as',i2,' dimensional')\" , varnam , ndims return end if sts = nf_put_var_real ( ncid , varid , varval ) call handle_err ( sts , varnam , 'cdfPurVar_1c8' , 'nf_put_var_real' ) if ( PRESENT ( ier )) ier = sts END SUBROUTINE cdfw_1c8 SUBROUTINE cdfw_1c ( ncid , varnam , varval , ier ) !     Write 1 dimensional character data array !     Use cdfDefVar to define the Variable ! implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam character * ( * ), intent ( in ) :: varval ! Output integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 1 ) :: dimlens integer :: varid , ndims , sts if ( PRESENT ( ier )) ier = 1 sts = nf_enddef ( ncid ) call cdfInqV ( ncid , varnam , varid , dimlens , ndims , sts ) if ( sts /= 0 ) return if ( ndims /= 1 ) then print \"('% cdfPutVar_1c: --E-- The variable ',a,               & &         ' was defined as',i2,' dimensional')\" , varnam , ndims return end if sts = nf_put_var_text ( ncid , varid , varval ) call handle_err ( sts , varnam , 'cdfPutVar_1c' , 'nf_put_var_text' ) if ( PRESENT ( ier )) ier = sts END SUBROUTINE cdfw_1c SUBROUTINE cdfw_0i ( ncid , varnam , varval , ier ) !     write integer scalar implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam integer , intent ( in ) :: varval ! Output integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 1 ) :: dimlens integer :: varid , ndims , sts if ( PRESENT ( ier )) ier = 1 sts = nf_enddef ( ncid ) call cdfInqV ( ncid , varnam , varid , dimlens , ndims , sts ) if ( sts /= 0 ) return if ( ndims /= 0 ) then print \"('% cdfPutVar_0i: --E-- The variable ',a,               & &         ' was defined as',i2,' dimensional')\" , varnam , ndims return end if sts = nf_put_var_int ( ncid , varid , varval ) call handle_err ( sts , varnam , 'cdfPutVar_0i' , 'nf_put_var_int' ) if ( PRESENT ( ier )) ier = sts END SUBROUTINE cdfw_0i SUBROUTINE cdfw_0l ( ncid , varnam , varval , ier ) !     Write logical scalar implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam logical , intent ( in ) :: varval ! Output integer , optional , intent ( out ) :: ier ! Local integer :: varval_i character * 11 , parameter :: logical_name = '__logical__' IF ( varval ) THEN varval_i = 1 ELSE varval_i = 0 END IF call cdfw_0i ( ncid , trim ( varnam ) // logical_name , varval_i , ier ) END SUBROUTINE cdfw_0l SUBROUTINE cdfw_0d ( ncid , varnam , varval , ier ) !     Write Real*8 Scalar ! implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam REAL ( KIND = r8 ), intent ( in ) :: varval ! Output integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 1 ) :: dimlens integer :: varid , ndims , sts if ( PRESENT ( ier )) ier = 1 sts = nf_enddef ( ncid ) call cdfInqV ( ncid , varnam , varid , dimlens , ndims , sts ) if ( sts /= 0 ) return if ( ndims /= 0 ) then print \"('% cdfPutVar_0d: --E-- The variable ',a,               & &         ' was defined as',i2,' dimensional')\" , varnam , ndims return end if sts = nf_put_var_double ( ncid , varid , varval ) call handle_err ( sts , varnam , 'cdfPutVar_0d' , 'nf_put_var_double' ) if ( PRESENT ( ier )) ier = sts END SUBROUTINE cdfw_0d SUBROUTINE cdfw_0c16 ( ncid , varnam , varval , ier ) !     Write Complex*16 Scalar ! implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam COMPLEX ( KIND = r8 ), intent ( in ) :: varval ! Output integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 1 ) :: dimlens integer :: varid , ndims , sts if ( PRESENT ( ier )) ier = 1 sts = nf_enddef ( ncid ) call cdfInqV ( ncid , trim ( varnam ) // cmplx_name , varid , dimlens , ndims , sts ) if ( sts /= 0 ) return if ( ndims /= 1 ) then ! scalar complex stored as 2 element real array print \"('% cdfPutVar_0c16: --E-- The variable ',a,               & &         ' was defined as',i2,' dimensional')\" , varnam , ndims return end if sts = nf_put_var_double ( ncid , varid , varval ) call handle_err ( sts , varnam , 'cdfPutVar_0c16' , 'nf_put_var_double' ) if ( PRESENT ( ier )) ier = sts END SUBROUTINE cdfw_0c16 SUBROUTINE cdfw_0f ( ncid , varnam , varval , ier ) !     Write default real ! implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam REAL ( KIND = r4 ), intent ( in ) :: varval ! Output integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 1 ) :: dimlens integer :: varid , ndims , sts if ( PRESENT ( ier )) ier = 1 sts = nf_enddef ( ncid ) call cdfInqV ( ncid , varnam , varid , dimlens , ndims , sts ) if ( sts /= 0 ) return if ( ndims /= 0 ) then print \"('% cdfPutVar_0f: --E-- The variable ',a,               & &         ' was defined as',i2,' dimensional')\" , varnam , ndims return end if sts = nf_put_var_real ( ncid , varid , varval ) call handle_err ( sts , varnam , 'cdfPutVar_0f' , 'nf_put_var_real' ) if ( PRESENT ( ier )) ier = sts END SUBROUTINE cdfw_0f SUBROUTINE cdfw_0c8 ( ncid , varnam , varval , ier ) !     Write complex*8 ! implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam complex ( KIND = r4 ), intent ( in ) :: varval ! Output integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 1 ) :: dimlens integer :: varid , ndims , sts if ( PRESENT ( ier )) ier = 1 sts = nf_enddef ( ncid ) call cdfInqV ( ncid , trim ( varnam ) // cmplx_name , varid , dimlens , ndims , sts ) if ( sts /= 0 ) return if ( ndims /= 1 ) then print \"('% cdfPutVar_0c8: --E-- The variable ',a,               & &         ' was defined as',i2,' dimensional')\" , varnam , ndims return end if sts = nf_put_var_real ( ncid , varid , varval ) call handle_err ( sts , varnam , 'cdfPutVar_0c8' , 'nf_put_var_real' ) if ( PRESENT ( ier )) ier = sts END SUBROUTINE cdfw_0c8 !------------------------------------------------------------------ ! cdfDefVar implementation routines subroutine cdfDefVar ( ncid , varnam , dimlens , xtype , ier , dimname ) ! Define a Variable and its dimensions ! 03/08/99 C. Ludescher ! C. Ludescher/A. Pletzer Tue Apr  4 10:11:33 EDT 2000 ! added support for complex types (ap) Wed May 16 15:06:34 EDT 2001 ! added support for logical type Oct 1 2002 (SPH) implicit none !!$  include \"netcdf.inc\" ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam integer , dimension (:), intent ( in ) :: dimlens character * ( * ), intent ( in ) :: xtype character * ( * ), optional , dimension (:), intent ( in ) :: dimname ! Output integer , optional , intent ( out ) :: ier ! Local integer :: ndims , varid , vartype , maxdims integer :: i , n , status integer , dimension ( 3 ) :: dimids character * ( nf_max_name ) :: dimnams ( 3 ) character * ( 5 ) :: zdim character * ( 9 ) :: zdim1 character * ( * ), parameter :: cmplx_name = '__CmPlx_Re_Im' character * ( * ), parameter :: logical_name = '__logical__' logical :: is_complex , is_logical integer dims ( 3 ) integer flag is_complex = . FALSE . is_logical = . FALSE . if ( PRESENT ( ier )) ier = 1 status = 0 dims = dimlens if ( xtype == 'R8' . or . xtype == 'r8' ) then vartype = nf_double else if ( xtype == 'C16' . or . xtype == 'c16' ) then ! complex array = real array with double leading length vartype = nf_double is_complex = . TRUE . dims ( 1 ) = 2 * abs ( dimlens ( 1 )) else if ( xtype == 'INT' . or . xtype == 'int' ) then vartype = nf_int else if ( xtype == 'LOG' . or . xtype == 'log' . or . xtype == 'BOOL' . or . xtype == 'bool' ) then vartype = nf_int !if nf_byte, MUST use integer*1 is_logical = . TRUE . else if ( xtype == 'R4' . or . xtype == 'r4' ) then vartype = nf_float else if ( xtype == 'C8' . or . xtype == 'c8' ) then ! complex array = real array with double leading length vartype = nf_float is_complex = . TRUE . dims ( 1 ) = 2 * abs ( dimlens ( 1 )) else if ( xtype == 'CHAR' . or . xtype == 'char' ) then vartype = nf_char end if ! The normal behavior is to decrement the rank if all ! sizes to the right are 1. However, in some cases it ! may be desirable to keep this dimension, in which the ! user needs to pass -1 as dimension. ndims = size ( dims ) n = ndims flag = 1 do i = n , 1 , - 1 if (( dims ( i ) == 1 . or . dims ( i ) == 0 ) . and . flag == 1 ) then ndims = i - 1 else flag = 0 end if dims ( i ) = abs ( dims ( i )) end do ! Check ndims <= maxdims if ( xtype == 'CHAR' . or . xtype == 'char' ) then maxdims = 2 else maxdims = 3 end if if ( ndims > maxdims ) then WRITE ( * , 10 ) ndims , xtype 10 format ( '% cdfDefVar --E--  Rank' , i3 , ' not supported for ' , a ) return end if do i = 1 , ndims if ( dims ( i ) > 999999999 ) then print * , '% cdfDefVar --E-- dimension >= 1.e9 not supported' return else if ( dims ( i ) < 100000 ) then write ( zdim , '(i5.5)' ) dims ( i ) dimnams ( i ) = 'dim_' // zdim else write ( zdim1 , '(i9.9)' ) dims ( i ) dimnams ( i ) = 'dim_' // zdim1 end if if ( PRESENT ( dimname )) then if ( SIZE ( dimname ) >= i ) then if ( LEN_TRIM ( dimname ( i )) > 0 ) dimnams ( i ) = dimname ( i ) end if end if status = nf_inq_dimid ( ncid , dimnams ( i ), dimids ( i )) if ( status /= nf_noerr ) then status = nf_def_dim ( ncid , dimnams ( i ), dims ( i ), dimids ( i )) call handle_err ( status , dimnams ( i ), 'cdfdef' , 'nf_def_dim' ) end if end do if ( status /= 0 ) return ! replace any embedded blanks or non-alphanumeric characters with underscores varnam_noalpha = varnam CALL alpha_numeric ( varnam_noalpha ) ! do some name mangling to keep track of complex and ! logical types if ( is_complex ) varnam_noalpha = trim ( varnam_noalpha ) // cmplx_name if ( is_logical ) varnam_noalpha = trim ( varnam_noalpha ) // logical_name status = nf_def_var ( ncid , varnam_noalpha , vartype , ndims , dimids , varid ) call handle_err ( status , varnam , 'cdfDefVar' , 'nf_def_var' ) if ( PRESENT ( ier )) ier = status end subroutine cdfDefVar SUBROUTINE cdfd_3i ( ncid , varnam , varval , ier , dimname ) !     define 3 dimensional Integer data array implicit none !!$  include \"netcdf.inc\" ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam integer , dimension (:, :, :), intent ( in ) :: varval character * ( * ), optional , dimension (:), intent ( in ) :: dimname ! Output integer , optional , intent ( out ) :: ier ! Local character * 3 :: vartype integer :: dims ( 3 ) vartype = 'INT' dims = - shape ( varval ) call cdfDefVar ( ncid , varnam , dims , vartype , ier , dimname ) END SUBROUTINE cdfd_3i SUBROUTINE cdfd_2i ( ncid , varnam , varval , ier , dimname ) !     define 2 dimensional Integer data array implicit none !!$  include \"netcdf.inc\" ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam integer , dimension (:, :), intent ( in ) :: varval character * ( * ), optional , dimension (:), intent ( in ) :: dimname ! Output integer , optional , intent ( out ) :: ier ! Local character * 3 :: vartype integer :: dims ( 3 ) vartype = 'INT' dims = ( /- shape ( varval ), 1 / ) call cdfDefVar ( ncid , varnam , dims , vartype , ier , dimname ) END SUBROUTINE cdfd_2i SUBROUTINE cdfd_1i ( ncid , varnam , varval , ier , dimname ) !     define 1 dimensional Integer data array implicit none !!$  include \"netcdf.inc\" ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam integer , dimension (:), intent ( in ) :: varval character * ( * ), optional , dimension (:), intent ( in ) :: dimname ! Output integer , optional , intent ( out ) :: ier ! Local character * 3 :: vartype integer :: dims ( 3 ) vartype = 'INT' dims = ( /- shape ( varval ), 1 , 1 / ) call cdfDefVar ( ncid , varnam , dims , vartype , ier , dimname ) END SUBROUTINE cdfd_1i SUBROUTINE cdfd_0i ( ncid , varnam , varval , ier , dimname ) !     define scalar Integer implicit none !!$  include \"netcdf.inc\" ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam integer , intent ( in ) :: varval character * ( * ), optional , dimension (:), intent ( in ) :: dimname ! Output integer , optional , intent ( out ) :: ier ! Local character * 3 :: vartype integer :: dims ( 3 ) vartype = 'INT' dims = 0 call cdfDefVar ( ncid , varnam , dims , vartype , ier , dimname ) END SUBROUTINE cdfd_0i SUBROUTINE cdfd_3l ( ncid , varnam , varval , ier , dimname ) !     define 3 dimensional logical array implicit none !!$  include \"netcdf.inc\" ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam logical , dimension (:, :, :), intent ( in ) :: varval character * ( * ), optional , dimension (:), intent ( in ) :: dimname ! Output integer , optional , intent ( out ) :: ier ! Local character * 4 :: vartype integer :: dims ( 3 ) vartype = 'LOG' dims = - shape ( varval ) call cdfDefVar ( ncid , varnam , dims , vartype , ier , dimname ) END SUBROUTINE cdfd_3l SUBROUTINE cdfd_2l ( ncid , varnam , varval , ier , dimname ) !     define 2 dimensional logical array implicit none !!$  include \"netcdf.inc\" ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam logical , dimension (:, :), intent ( in ) :: varval character * ( * ), optional , dimension (:), intent ( in ) :: dimname ! Output integer , optional , intent ( out ) :: ier ! Local character * 3 :: vartype integer :: dims ( 3 ) vartype = 'LOG' dims = ( /- shape ( varval ), 1 / ) call cdfDefVar ( ncid , varnam , dims , vartype , ier , dimname ) END SUBROUTINE cdfd_2l SUBROUTINE cdfd_1l ( ncid , varnam , varval , ier , dimname ) !     define 1 dimensional logical array implicit none !!$  include \"netcdf.inc\" ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam logical , dimension (:), intent ( in ) :: varval character * ( * ), optional , dimension (:), intent ( in ) :: dimname ! Output integer , optional , intent ( out ) :: ier ! Local character * 3 :: vartype integer :: dims ( 3 ) vartype = 'LOG' dims = ( /- shape ( varval ), 1 , 1 / ) call cdfDefVar ( ncid , varnam , dims , vartype , ier , dimname ) END SUBROUTINE cdfd_1l SUBROUTINE cdfd_0l ( ncid , varnam , varval , ier , dimname ) !     define scalar logical implicit none !!$  include \"netcdf.inc\" ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam logical , intent ( in ) :: varval character * ( * ), optional , dimension (:), intent ( in ) :: dimname ! Output integer , optional , intent ( out ) :: ier ! Local character * 3 :: vartype integer :: dims ( 3 ) vartype = 'LOG' dims = 0 call cdfDefVar ( ncid , varnam , dims , vartype , ier , dimname ) END SUBROUTINE cdfd_0l SUBROUTINE cdfd_3d ( ncid , varnam , varval , ier , dimname ) !     define 3 dimensional double data array implicit none !!$  include \"netcdf.inc\" ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam REAL ( kind = r8 ), dimension (:, :, :), intent ( in ) :: varval character * ( * ), optional , dimension (:), intent ( in ) :: dimname ! Output integer , optional , intent ( out ) :: ier ! Local character * 2 :: vartype integer :: dims ( 3 ) vartype = 'R8' dims = - shape ( varval ) call cdfDefVar ( ncid , varnam , dims , vartype , ier , dimname ) END SUBROUTINE cdfd_3d SUBROUTINE cdfd_2d ( ncid , varnam , varval , ier , dimname ) !     define 2 dimensional double data array implicit none !!$  include \"netcdf.inc\" ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam REAL ( kind = r8 ), dimension (:, :), intent ( in ) :: varval character * ( * ), optional , dimension (:), intent ( in ) :: dimname ! Output integer , optional , intent ( out ) :: ier ! Local character * 2 :: vartype integer :: dims ( 3 ) vartype = 'R8' dims = ( /- shape ( varval ), 1 / ) call cdfDefVar ( ncid , varnam , dims , vartype , ier , dimname ) END SUBROUTINE cdfd_2d SUBROUTINE cdfd_1d ( ncid , varnam , varval , ier , dimname ) !     define 1 dimensional double data array implicit none !!$  include \"netcdf.inc\" ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam REAL ( kind = r8 ), dimension (:), intent ( in ) :: varval character * ( * ), optional , dimension (:), intent ( in ) :: dimname ! Output integer , optional , intent ( out ) :: ier ! Local character * 2 :: vartype integer :: dims ( 3 ) vartype = 'R8' dims = ( /- shape ( varval ), 1 , 1 / ) call cdfDefVar ( ncid , varnam , dims , vartype , ier , dimname ) END SUBROUTINE cdfd_1d SUBROUTINE cdfd_0d ( ncid , varnam , varval , ier , dimname ) !     define scalar double implicit none !!$  include \"netcdf.inc\" ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam REAL ( kind = r8 ), intent ( in ) :: varval character * ( * ), optional , dimension (:), intent ( in ) :: dimname ! Output integer , optional , intent ( out ) :: ier ! Local character * 2 :: vartype integer :: dims ( 3 ) vartype = 'R8' dims = 0 call cdfDefVar ( ncid , varnam , dims , vartype , ier , dimname ) END SUBROUTINE cdfd_0d SUBROUTINE cdfd_3f ( ncid , varnam , varval , ier , dimname ) !     define 3 dimensional real data array implicit none !!$  include \"netcdf.inc\" ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam REAL ( kind = r4 ), dimension (:, :, :), intent ( in ) :: varval character * ( * ), optional , dimension (:), intent ( in ) :: dimname ! Output integer , optional , intent ( out ) :: ier ! Local character * 2 :: vartype integer :: dims ( 3 ) vartype = 'R4' dims = - shape ( varval ) call cdfDefVar ( ncid , varnam , dims , vartype , ier , dimname ) END SUBROUTINE cdfd_3f SUBROUTINE cdfd_2f ( ncid , varnam , varval , ier , dimname ) !     define 2 dimensional real data array implicit none !!$  include \"netcdf.inc\" ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam REAL ( kind = r4 ), dimension (:, :), intent ( in ) :: varval character * ( * ), optional , dimension (:), intent ( in ) :: dimname ! Output integer , optional , intent ( out ) :: ier ! Local character * 2 :: vartype integer :: dims ( 3 ) vartype = 'R4' dims = ( /- shape ( varval ), 1 / ) call cdfDefVar ( ncid , varnam , dims , vartype , ier , dimname ) END SUBROUTINE cdfd_2f SUBROUTINE cdfd_1f ( ncid , varnam , varval , ier , dimname ) !     define 1 dimensional real data array implicit none !!$  include \"netcdf.inc\" ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam REAL ( kind = r4 ), dimension (:), intent ( in ) :: varval character * ( * ), optional , dimension (:), intent ( in ) :: dimname ! Output integer , optional , intent ( out ) :: ier ! Local character * 2 :: vartype integer :: dims ( 3 ) vartype = 'R4' dims = ( /- shape ( varval ), 1 , 1 / ) call cdfDefVar ( ncid , varnam , dims , vartype , ier , dimname ) END SUBROUTINE cdfd_1f SUBROUTINE cdfd_0f ( ncid , varnam , varval , ier , dimname ) !     define scalar real implicit none !!$  include \"netcdf.inc\" ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam REAL ( kind = r4 ), intent ( in ) :: varval character * ( * ), optional , dimension (:), intent ( in ) :: dimname ! Output integer , optional , intent ( out ) :: ier ! Local character * 2 :: vartype integer :: dims ( 3 ) vartype = 'R4' dims = 0 call cdfDefVar ( ncid , varnam , dims , vartype , ier , dimname ) END SUBROUTINE cdfd_0f SUBROUTINE cdfd_3c16 ( ncid , varnam , varval , ier , dimname ) !     define 3 dimensional 128-bit complex data array implicit none !!$  include \"netcdf.inc\" ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam COMPLEX ( kind = r8 ), dimension (:, :, :), intent ( in ) :: varval character * ( * ), optional , dimension (:), intent ( in ) :: dimname ! Output integer , optional , intent ( out ) :: ier ! Local character * 3 :: vartype integer :: dims ( 3 ) vartype = 'C16' dims = - shape ( varval ) call cdfDefVar ( ncid , varnam , dims , vartype , ier , dimname ) END SUBROUTINE cdfd_3c16 SUBROUTINE cdfd_2c16 ( ncid , varnam , varval , ier , dimname ) !     define 2 dimensional 128-bit complex data array implicit none !!$  include \"netcdf.inc\" ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam COMPLEX ( kind = r8 ), dimension (:, :), intent ( in ) :: varval character * ( * ), optional , dimension (:), intent ( in ) :: dimname ! Output integer , optional , intent ( out ) :: ier ! Local character * 3 :: vartype integer :: dims ( 3 ) vartype = 'C16' dims = ( /- shape ( varval ), 1 / ) call cdfDefVar ( ncid , varnam , dims , vartype , ier , dimname ) END SUBROUTINE cdfd_2c16 SUBROUTINE cdfd_1c16 ( ncid , varnam , varval , ier , dimname ) !     define 1 dimensional 128-bit complex data array implicit none !!$  include \"netcdf.inc\" ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam COMPLEX ( kind = r8 ), dimension (:), intent ( in ) :: varval character * ( * ), optional , dimension (:), intent ( in ) :: dimname ! Output integer , optional , intent ( out ) :: ier ! Local character * 3 :: vartype integer :: dims ( 3 ) vartype = 'C16' dims = ( /- shape ( varval ), 1 , 1 / ) call cdfDefVar ( ncid , varnam , dims , vartype , ier , dimname ) END SUBROUTINE cdfd_1c16 SUBROUTINE cdfd_0c16 ( ncid , varnam , varval , ier , dimname ) !     define scalar 128-bit complex implicit none !!$  include \"netcdf.inc\" ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam COMPLEX ( kind = r8 ), intent ( in ) :: varval character * ( * ), optional , dimension (:), intent ( in ) :: dimname ! Output integer , optional , intent ( out ) :: ier ! Local character * 3 :: vartype integer :: dims ( 3 ) vartype = 'C16' dims = 0 call cdfDefVar ( ncid , varnam , dims , vartype , ier , dimname ) END SUBROUTINE cdfd_0c16 SUBROUTINE cdfd_3c8 ( ncid , varnam , varval , ier , dimname ) !     define 3 dimensional 64-bit complex data array implicit none !!$  include \"netcdf.inc\" ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam COMPLEX ( kind = r4 ), dimension (:, :, :), intent ( in ) :: varval character * ( * ), optional , dimension (:), intent ( in ) :: dimname ! Output integer , optional , intent ( out ) :: ier ! Local character * 2 :: vartype integer :: dims ( 3 ) vartype = 'C8' dims = - shape ( varval ) call cdfDefVar ( ncid , varnam , dims , vartype , ier , dimname ) END SUBROUTINE cdfd_3c8 SUBROUTINE cdfd_2c8 ( ncid , varnam , varval , ier , dimname ) !     define 2 dimensional 64-bit complex data array implicit none !!$  include \"netcdf.inc\" ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam COMPLEX ( kind = r4 ), dimension (:, :), intent ( in ) :: varval character * ( * ), optional , dimension (:), intent ( in ) :: dimname ! Output integer , optional , intent ( out ) :: ier ! Local character * 2 :: vartype integer :: dims ( 3 ) vartype = 'C8' dims = ( /- shape ( varval ), 1 / ) call cdfDefVar ( ncid , varnam , dims , vartype , ier , dimname ) END SUBROUTINE cdfd_2c8 SUBROUTINE cdfd_1c8 ( ncid , varnam , varval , ier , dimname ) !     define 1 dimensional 64-bit complex data array implicit none !!$  include \"netcdf.inc\" ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam COMPLEX ( kind = r4 ), dimension (:), intent ( in ) :: varval character * ( * ), optional , dimension (:), intent ( in ) :: dimname ! Output integer , optional , intent ( out ) :: ier ! Local character * 2 :: vartype integer :: dims ( 3 ) vartype = 'C8' dims = ( /- shape ( varval ), 1 , 1 / ) call cdfDefVar ( ncid , varnam , dims , vartype , ier , dimname ) END SUBROUTINE cdfd_1c8 SUBROUTINE cdfd_0c8 ( ncid , varnam , varval , ier , dimname ) !     define scalar 64-bit complex implicit none !!$  include \"netcdf.inc\" ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam COMPLEX ( kind = r4 ), intent ( in ) :: varval character * ( * ), optional , dimension (:), intent ( in ) :: dimname ! Output integer , optional , intent ( out ) :: ier ! Local character * 2 :: vartype integer :: dims ( 3 ) vartype = 'C8' dims = 0 call cdfDefVar ( ncid , varnam , dims , vartype , ier , dimname ) END SUBROUTINE cdfd_0c8 SUBROUTINE cdfd_2c ( ncid , varnam , varval , ier , dimname ) !     define 2 dimensional character array implicit none !!$  include \"netcdf.inc\" ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam character * ( * ), dimension (:), intent ( in ) :: varval character * ( * ), optional , dimension (:), intent ( in ) :: dimname ! Output integer , optional , intent ( out ) :: ier ! Local character * 4 :: vartype integer :: dims ( 3 ) vartype = 'CHAR' dims ( 1 ) = len ( varval ( 1 )) dims ( 2 ) = size ( varval ); dims ( 3 ) = 1 call cdfDefVar ( ncid , varnam , dims , vartype , ier , dimname ) END SUBROUTINE cdfd_2c SUBROUTINE cdfd_1c ( ncid , varnam , varval , ier , dimname ) !     define 1 dimensional character array implicit none !!$  include \"netcdf.inc\" ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam character * ( * ), intent ( in ) :: varval character * ( * ), optional , dimension (:), intent ( in ) :: dimname ! Output integer , optional , intent ( out ) :: ier ! Local character * 4 :: vartype integer :: dims ( 3 ) vartype = 'CHAR' dims ( 1 ) = len ( varval ); dims ( 2 : 3 ) = 1 if ( dims ( 1 ) <= 1 ) dims ( 1 ) = - 1 call cdfDefVar ( ncid , varnam , dims , vartype , ier , dimname ) END SUBROUTINE cdfd_1c !DEC$ ENDIF END MODULE ezcdf_GenPut","tags":"","loc":"sourcefile/ezcdf_genput.f90.html"},{"title":"ezcdf_attrib.f90 â€“ stella","text":"Contents Modules ezcdf_attrib Source Code ezcdf_attrib.f90 Source Code MODULE ezcdf_attrib USE ezcdf_inqvar !DEC$ IF DEFINED (NETCDF) include \"netcdf.inc\" INTEGER , PARAMETER :: r4 = SELECTED_REAL_KIND ( 6 , 37 ) INTEGER , PARAMETER :: r8 = SELECTED_REAL_KIND ( 12 , 100 ) CHARACTER ( len = nf_max_name ) :: varnam_noalpha PRIVATE :: r4 , r8 , varnam_noalpha PUBLIC :: cdf_setatt , cdf_getatt INTERFACE cdf_setatt MODULE PROCEDURE cdfSetatt , cdfsa_i , cdfsa_d , cdfsa_f END INTERFACE INTERFACE cdf_getatt MODULE PROCEDURE cdfGetatt , cdfga_i , cdfga_d , cdfga_f END INTERFACE CONTAINS SUBROUTINE cdfSetatt ( ncid , varnam , long_name , units , ier , varid ) implicit none !  include \"netcdf.inc\" ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam character * ( * ), intent ( in ), optional :: long_name , units ! Output integer , optional , intent ( out ) :: ier , varid ! Local integer :: varid0 integer :: status character * ( * ), parameter :: cmplx_name = '__CmPlx_Re_Im' character * ( * ), parameter :: logical_name = '__logical__' if ( PRESENT ( ier )) ier = 1 varnam_noalpha = varnam CALL alpha_numeric ( varnam_noalpha ) !Find varid status = nf_inq_varid ( ncid , varnam_noalpha , varid0 ) if ( status /= 0 ) then ! perhaps varnam is complex, try... status = nf_inq_varid ( ncid , trim ( varnam_noalpha ) // cmplx_name , varid0 ) if ( status /= 0 ) then status = nf_inq_varid ( ncid , trim ( varnam_noalpha ) // logical_name , varid0 ) end if end if !  call handle_err(status,varnam,'cdf_setatt','nf_inq_varid') if ( status /= 0 ) GO TO 100 if ( PRESENT ( long_name )) then status = nf_put_att_text ( ncid , varid0 , 'long_name' , LEN_TRIM ( long_name ), & TRIM ( long_name )) CALL handle_err ( status , long_name , 'cdf_setatt' , 'nf_put_att_text' ) if ( status /= 0 ) GO TO 100 end if if ( PRESENT ( units )) then status = nf_put_att_text ( ncid , varid0 , 'units' , LEN_TRIM ( units ), & TRIM ( units )) CALL handle_err ( status , units , 'cdf_setatt' , 'nf_put_att_text' ) if ( status /= 0 ) GO TO 100 end if 100 CONTINUE if ( PRESENT ( ier )) ier = status if ( PRESENT ( varid )) varid = varid0 END SUBROUTINE cdfSetatt SUBROUTINE cdf_SetTitle ( ncid , title , ier ) implicit none !  include \"netcdf.inc\" ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: title ! Output integer , optional , intent ( out ) :: ier ! Local integer :: status if ( PRESENT ( ier )) ier = 1 status = nf_put_att_text ( ncid , nf_global , 'title' , LEN_TRIM ( title ), & TRIM ( title )) CALL handle_err ( status , title , 'cdf_settitle' , 'nf_put_att_text' ) if ( PRESENT ( ier )) ier = status END SUBROUTINE cdf_SetTitle SUBROUTINE cdfsa_i ( ncid , varnam , valid_range , long_name , units , ier ) implicit none !  include \"netcdf.inc\" ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam character * ( * ), intent ( in ), optional :: long_name , units integer , intent ( in ), dimension ( 2 ) :: valid_range ! Output integer , optional , intent ( out ) :: ier ! Local integer :: varid integer :: status call cdfSetatt ( ncid , varnam , long_name , units , ier , varid ) status = nf_put_att_int ( ncid , varid , 'valid_range' , nf_double , & 2 , valid_range ) CALL handle_err ( status , 'valid_range' , 'cdf_setatt' , 'nf_put_att_double' ) END SUBROUTINE cdfsa_i SUBROUTINE cdfsa_f ( ncid , varnam , valid_range , long_name , units , ier ) implicit none !  include \"netcdf.inc\" ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam character * ( * ), intent ( in ), optional :: long_name , units real ( kind = r4 ), intent ( in ), dimension ( 2 ) :: valid_range ! Output integer , optional , intent ( out ) :: ier ! Local integer :: varid integer :: status call cdfSetatt ( ncid , varnam , long_name , units , ier , varid ) status = nf_put_att_real ( ncid , varid , 'valid_range' , nf_double , & 2 , valid_range ) CALL handle_err ( status , 'valid_range' , 'cdf_setatt' , 'nf_put_att_double' ) END SUBROUTINE cdfsa_f SUBROUTINE cdfsa_d ( ncid , varnam , valid_range , long_name , units , ier ) implicit none !  include \"netcdf.inc\" ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam character * ( * ), intent ( in ), optional :: long_name , units real ( kind = r8 ), intent ( in ), dimension ( 2 ) :: valid_range ! Output integer , optional , intent ( out ) :: ier ! Local integer :: varid integer :: status call cdfSetatt ( ncid , varnam , long_name , units , ier , varid ) status = nf_put_att_double ( ncid , varid , 'valid_range' , nf_double , & 2 , valid_range ) CALL handle_err ( status , 'valid_range' , 'cdf_setatt' , 'nf_put_att_double' ) END SUBROUTINE cdfsa_d SUBROUTINE cdfGetatt ( ncid , varnam , long_name , units , ier , varid ) implicit none !  include \"netcdf.inc\" ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output character * ( * ), intent ( out ), optional :: long_name , units integer , optional , intent ( out ) :: ier , varid ! Local integer :: varid0 integer :: status character * ( * ), parameter :: cmplx_name = '__CmPlx_Re_Im' character * ( * ), parameter :: logical_name = '__logical__' character * ( nf_max_name ) :: name if ( PRESENT ( ier )) ier = 1 varnam_noalpha = varnam CALL alpha_numeric ( varnam_noalpha ) !Find varid0 status = nf_inq_varid ( ncid , varnam_noalpha , varid0 ) if ( status /= 0 ) then ! perhaps varnam is complex, try... status = nf_inq_varid ( ncid , trim ( varnam_noalpha ) // cmplx_name , varid0 ) if ( status /= 0 ) then status = nf_inq_varid ( ncid , trim ( varnam_noalpha ) // logical_name , varid0 ) end if end if !  call handle_err(status,varnam,'cdf_setatt','nf_inq_varid') if ( status /= 0 ) GO TO 100 if ( PRESENT ( long_name )) then name = \"\" status = nf_get_att_text ( ncid , varid0 , 'long_name' , name ) if ( status == nf_noerr ) then long_name = name ( 1 : len ( name )) else long_name = \"\" end if end if if ( PRESENT ( units )) then name = \"\" status = nf_get_att_text ( ncid , varid0 , 'units' , name ) if ( status == nf_noerr ) then units = name ( 1 : len ( name )) else units = \"\" end if end if 100 CONTINUE if ( PRESENT ( ier )) ier = status if ( PRESENT ( varid )) varid = varid0 END SUBROUTINE cdfGetatt SUBROUTINE cdf_GetTitle ( ncid , title , ier ) implicit none !  include \"netcdf.inc\" ! Input integer , intent ( in ) :: ncid ! Output character * ( * ), intent ( out ) :: title integer , optional , intent ( out ) :: ier ! Local integer :: status character * ( nf_max_name ) :: name if ( PRESENT ( ier )) ier = 1 status = nf_get_att_text ( ncid , nf_global , 'title' , name ) if ( status == nf_noerr ) then title = name ( 1 : len ( name )) else title = \"\" end if if ( PRESENT ( ier )) ier = status END SUBROUTINE cdf_GetTitle SUBROUTINE cdfga_i ( ncid , varnam , valid_range , long_name , units , ier ) implicit none !  include \"netcdf.inc\" ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output character * ( * ), intent ( out ), optional :: long_name , units integer , intent ( out ), dimension ( 2 ) :: valid_range integer , optional , intent ( out ) :: ier ! Local integer :: varid integer :: status call cdfGetatt ( ncid , varnam , long_name , units , ier , varid ) status = nf_get_att_int ( ncid , varid , 'valid_range' , valid_range ) CALL handle_err ( status , 'valid_range' , 'cdf_getatt' , 'nf_get_att_int' ) END SUBROUTINE cdfga_i SUBROUTINE cdfga_f ( ncid , varnam , valid_range , long_name , units , ier ) implicit none !  include \"netcdf.inc\" ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output character * ( * ), intent ( out ), optional :: long_name , units real ( kind = r4 ), intent ( out ), dimension ( 2 ) :: valid_range integer , optional , intent ( out ) :: ier ! Local integer :: varid integer :: status call cdfGetatt ( ncid , varnam , long_name , units , ier , varid ) status = nf_get_att_real ( ncid , varid , 'valid_range' , valid_range ) CALL handle_err ( status , 'valid_range' , 'cdf_getatt' , 'nf_get_att_real' ) END SUBROUTINE cdfga_f SUBROUTINE cdfga_d ( ncid , varnam , valid_range , long_name , units , ier ) implicit none !  include \"netcdf.inc\" ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output character * ( * ), intent ( out ), optional :: long_name , units real ( kind = r8 ), intent ( out ), dimension ( 2 ) :: valid_range integer , optional , intent ( out ) :: ier ! Local integer :: varid integer :: status call cdfGetatt ( ncid , varnam , long_name , units , ier , varid ) status = nf_get_att_double ( ncid , varid , 'valid_range' , valid_range ) CALL handle_err ( status , 'valid_range' , 'cdf_getatt' , 'nf_get_att_double' ) END SUBROUTINE cdfga_d !DEC$ ENDIF END MODULE ezcdf_attrib","tags":"","loc":"sourcefile/ezcdf_attrib.f90.html"},{"title":"ezcdf.f90 â€“ stella","text":"Contents Modules ezcdf Source Code ezcdf.f90 Source Code !EZcdf, Easy Interface to netCDF Routine Calls !============================================= !The module is available through the NTCC Webpage, !w3.pppl.gov/NTTC  under \"Modules Library\", as compressed !tarfile, ezcdf.tar.gz, and as zip archive, ezcdf.zip. !Alternatively it can be obtained from ftp.pppl.gov !in pub/NTCC/. ! AUTHORS !Conceived by 7/98 by Sunitinder Sekhon !Modified by J. Menard 12/98 to run on Cray C90 !Completely re-written by C.Ludescher 2/99 !Added complex support (64 and 128 bit) by A. Pletzer 5/01 ! CONTACT ! C. Ludescher cludescher@pppl.gov ! A. Pletzer   pletzer@pppl.gov ! REVISION HISTORY !      date         Description ! February  1999  -- Created ! April     2000  -- A.Pletzer: Added R4 ! May 01,   2000  -- C. Ludescher: Simplified by adding module ezcdf ! May 17,   2001  -- A. Pletzer: Added C8 and C16 ! Interface for cdfopn to handle optional argument ier ! 04/28/00 C.Ludescher ! + ezcdf_close for symmetry (ap) ! September 2002  -- S. Hirshman, added aliases to mimic F90 I/O routines !                    added cdf_inquire with OPTIONAL xtype argument !                    added 'LOG' data type (nf_int) to handle logicals !                    (user may use 'INT' interchangeably) ! ! April 2003      -- removed ONLY and some rename clauses from USE stmts !                    (D. McCune).  These caused problems, because an !                    application with \"use ezcdf\" would indirectly see !                    \"use ezcdf_inqvar\" with various ONLY clauses; it !                    was unclear which one would rule, but, at load time !                    it was clear that the ONLY clauses were making some !                    legitimate ezcdf entries invisible, at least when !                    built using Lahey-Fujitsu fortran.  Also, the !                    indirect presence of multiple \"USE ezcdf_opencls\" !                    with rename lists caused problems which were resolved !                    by removing the rename lists ans using INTERFACE !                    statements inside ezcdf_opncls instead. ! MODULE ezcdf ! No aliases. this caused the Intel compiler to fail, so I had to duplicate ! 2 interfaces: cdfPutVar <=> cdf_write and cdfGetVar <=> cdf_read (pletzer) USE ezcdf_GenPut USE ezcdf_GenGet USE ezcdf_attrib USE ezcdf_opncls END MODULE ezcdf","tags":"","loc":"sourcefile/ezcdf.f90.html"},{"title":"vsvd0.f â€“ stella","text":"Contents Modules vsvd0 Source Code vsvd0.f Source Code MODULE vsvd0 USE stel_kinds IMPLICIT NONE REAL ( rprec ), PARAMETER :: fturnon_axis = 3.e-9_dp REAL ( rprec ), PARAMETER :: fopt_axis = 3.e-2_dp * fturnon_axis INTEGER , PARAMETER :: isamecoil = - 2 INTEGER , PARAMETER :: needit = - 1 INTEGER , PARAMETER :: idontneed = 0 INTEGER , PARAMETER :: isymcoil = 1 INTEGER , PARAMETER :: ithom0 = 1 INTEGER , PARAMETER :: istark0 = 2 INTEGER , PARAMETER :: islope0 = 3 INTEGER , PARAMETER :: icurr0 = 4 INTEGER , PARAMETER :: idiam0 = 5 INTEGER , PARAMETER :: iflxs0 = 6 INTEGER , PARAMETER :: ibrzfld = 7 INTEGER , PARAMETER :: natur = 0 INTEGER , PARAMETER :: ideriv = 1 INTEGER , PARAMETER :: intder = 1 INTEGER , PARAMETER :: intfun = 2 INTEGER , PARAMETER :: nmse = 100 !number of mse measurements INTEGER , PARAMETER :: ntse = 100 !number of thompson scattering measurements INTEGER , PARAMETER :: nfloops = 100 !number of external poloidal flux loops INTEGER , PARAMETER :: nbsetsp = 5 !number of external b-field loop sets allowed INTEGER , PARAMETER :: nbcoilsp = 100 !number of external b-field coils per set INTEGER , PARAMETER :: nbctotp = nbsetsp * nbcoilsp INTEGER , PARAMETER :: jngrn = 1001 !number of \"Greens Function\" points INTEGER , PARAMETER :: jchix = 7 !number of data types contributing to rms error match INTEGER , PARAMETER :: mstp = 100 !number of time steps to store chisq error INTEGER , PARAMETER :: jchix1 = jchix + 1 INTEGER , PARAMETER :: nparts = 4 !number of items needed to specify pf coils INTEGER , PARAMETER :: npfcoil = 40 !number of filaments in pf coil pack (for plotting) INTEGER , PARAMETER :: nigroup = 100 !number of external current groups INTEGER , PARAMETER :: ipedsvd = 8 END MODULE vsvd0","tags":"","loc":"sourcefile/vsvd0.f.html"},{"title":"vparams.f â€“ stella","text":"Contents Modules vparams Source Code vparams.f Source Code MODULE vparams USE stel_kinds USE stel_constants , ONLY : zero , twopi , mu0 , one IMPLICIT NONE !----------------------------------------------- !   L o c a l   P a r a m e t e r s !----------------------------------------------- ! !     MAXIMUM PARAMETERS FOR VMEC CODE (FOR READING INPUT) !     USER SHOULD NOT ALTER THESE ! !      INTEGER, PARAMETER :: nsd = 1001     !maximum number of radial nodes INTEGER , PARAMETER :: nsd = 10001 !maximum number of radial nodes SAL 05/22/12 INTEGER , PARAMETER :: mpold = 101 !maximum number of poloidal harmonics (in r,z,lam fourier series) INTEGER , PARAMETER :: ntord = 101 !maximum number of toroidal harmonics INTEGER , PARAMETER :: ndatafmax = 101 INTEGER , PARAMETER :: nstore_seq = 100 ! !     CONSTANTS ! INTEGER , PARAMETER :: nthreed0 = 9 , nmac0 = nthreed0 + 1 , 1 indata0 = nthreed0 + 2 , nwout0 = nthreed0 + 3 , 2 jxbout0 = nthreed0 + 4 INTEGER , PARAMETER :: nfort8 = 8 , nfort18 = 18 INTEGER , PARAMETER :: nlog0 = 51 , nmercier0 = 52 INTEGER :: nthreed , nmac , nlog = nlog0 ! !     DERIVED (FROM FUNDAMENTAL) PARAMETERS FOR VMEC CODE ! INTEGER , PARAMETER :: mpol1d = mpold - 1 INTEGER , PARAMETER :: ntor1d = 1 + ntord ! !     MISCELLANEOUS PARAMETERS ! REAL ( rprec ), PARAMETER :: c1pm2 = 1.e-2_dp REAL ( rprec ), PARAMETER :: cp15 = 0.15_dp REAL ( rprec ), PARAMETER :: cp25 = 0.25_dp REAL ( rprec ), PARAMETER :: cp5 = 0.50_dp REAL ( rprec ), PARAMETER :: c1pm8 = 1.0e-8_dp REAL ( rprec ), PARAMETER :: cbig = 0.9e30_dp REAL ( rprec ), PARAMETER :: c2p0 = 2 REAL ( rprec ), PARAMETER :: c3p0 = 3 REAL ( rprec ), PARAMETER :: cp05 = 0.05_dp REAL ( rprec ), PARAMETER :: c1pm13 = 1.0e-13_dp REAL ( rprec ), PARAMETER :: osqrt2 = 0.707106781186547462_dp REAL ( rprec ), PARAMETER :: epstan = EPSILON ( zero ) real ( rprec ), parameter :: dmu0 = 2.0e-7_dp * twopi !SAL 09/26/11 for COBRA END MODULE vparams","tags":"","loc":"sourcefile/vparams.f.html"},{"title":"read_wout_mod.F â€“ stella","text":"Contents Modules read_wout_mod Source Code read_wout_mod.F Source Code MODULE read_wout_mod ! !     USE READ_WOUT_MOD to include variables dynamically allocated !     in this module !     Call DEALLOCATE_READ_WOUT to free this memory when it is no longer needed ! !     Reads in output from VMEC equilibrium code(s), contained in wout file ! !     Contained subroutines: ! !     read_wout_file      wrapper alias called to read/open wout file !     read_wout_text      called by read_wout_file to read text file wout !     read_wout_nc        called by read_wout_file to read netcdf file wout ! !     Post-processing routines ! !     mse_pitch           user-callable function to compute mse pitch angle !                         for the computed equilibrium ! USE stel_kinds USE vmec_input , ONLY : lrfp USE mgrid_mod IMPLICIT NONE #if defined(NETCDF) C----------------------------------------------- C   L O C A L   P A R A M E T E R S C----------------------------------------------- ! Variable names (vn_...) : put eventually into library, used by read_wout too... CHARACTER ( LEN =* ), PARAMETER :: 1 vn_version = 'version_' , 2 vn_extension = 'input_extension' , vn_mgrid = 'mgrid_file' , 3 vn_magen = 'wb' , vn_therm = 'wp' , vn_gam = 'gamma' , 4 vn_maxr = 'rmax_surf' , vn_minr = 'rmin_surf' , 5 vn_maxz = 'zmax_surf' , vn_fp = 'nfp' , 6 vn_radnod = 'ns' , vn_polmod = 'mpol' , vn_tormod = 'ntor' , 7 vn_maxmod = 'mnmax' , vn_maxit = 'niter' , vn_actit = 'itfsq' , 8 vn_asym = 'lasym' , vn_recon = 'lrecon' , vn_free = 'lfreeb' , 9 vn_error = 'ier_flag' , vn_aspect = 'aspect' , vn_rfp = 'lrfp' , A vn_maxmod_nyq = 'mnmax_nyq' , B vn_beta = 'betatotal' , vn_pbeta = 'betapol' , C vn_tbeta = 'betator' , vn_abeta = 'betaxis' , D vn_b0 = 'b0' , vn_rbt0 = 'rbtor0' , vn_rbt1 = 'rbtor' , E vn_sgs = 'signgs' , vn_lar = 'IonLarmor' , vn_modB = 'volavgB' , F vn_ctor = 'ctor' , vn_amin = 'Aminor_p' , vn_Rmaj = 'Rmajor_p' , G vn_vol = 'volume_p' , vn_am = 'am' , vn_ai = 'ai' , vn_ac = 'ac' , G vn_ah = 'hot particle fraction' , vn_atuname = 'T-perp/T-par' , H vn_pmass_type = 'pmass_type' , vn_piota_type = 'piota_type' , I vn_pcurr_type = 'pcurr_type' , J vn_am_aux_s = 'am_aux_s' , vn_am_aux_f = 'am_aux_f' , K vn_ai_aux_s = 'ai_aux_s' , vn_ai_aux_f = 'ai_aux_f' , L vn_ac_aux_s = 'ac_aux_s' , vn_ac_aux_f = 'ac_aux_f' , M vn_mse = 'imse' , vn_thom = 'itse' , N vn_pmod = 'xm' , vn_tmod = 'xn' , vn_pmod_nyq = 'xm_nyq' , O vn_tmod_nyq = 'xn_nyq' , P vn_racc = 'raxis_cc' , vn_zacs = 'zaxis_cs' , Q vn_racs = 'raxis_cs' , vn_zacc = 'zaxis_cc' , vn_iotaf = 'iotaf' , Q vn_qfact = 'q-factor' , vn_chi = 'chi' , vn_chipf = 'chipf' , R vn_presf = 'presf' , vn_phi = 'phi' , vn_phipf = 'phipf' , S vn_jcuru = 'jcuru' , vn_jcurv = 'jcurv' , vn_iotah = 'iotas' , T vn_mass = 'mass' , vn_presh = 'pres' , vn_betah = 'beta_vol' , U vn_buco = 'buco' , vn_bvco = 'bvco' , vn_vp = 'vp' , V vn_specw = 'specw' , vn_phip = 'phips' , vn_jdotb = 'jdotb' , W vn_overr = 'over_r' , X vn_bgrv = 'bdotgradv' , vn_merc = 'DMerc' , vn_mshear = 'DShear' , Y vn_mwell = 'DWell' , vn_mcurr = 'DCurr' , vn_mgeo = 'DGeod' , Z vn_equif = 'equif' , vn_fsq = 'fsqt' , vn_wdot = 'wdot' , 1 vn_ftolv = 'ftolv' , vn_fsql = 'fsql' , vn_fsqr = 'fsqr' , 2 vn_fsqz = 'fsqz' , 3 vn_extcur = 'extcur' , vn_curlab = 'curlabel' , vn_rmnc = 'rmnc' , 4 vn_zmns = 'zmns' , vn_lmns = 'lmns' , vn_gmnc = 'gmnc' , 5 vn_bmnc = 'bmnc' , vn_bsubumnc = 'bsubumnc' , 6 vn_bsubvmnc = 'bsubvmnc' , vn_bsubsmns = 'bsubsmns' , 7 vn_bsupumnc = 'bsupumnc' , vn_bsupvmnc = 'bsupvmnc' , 8 vn_rmns = 'rmns' , vn_zmnc = 'zmnc' , 9 vn_lmnc = 'lmnc' , vn_gmns = 'gmns' , vn_bmns = 'bmns' , A vn_bsubumns = 'bsubumns' , vn_bsubvmns = 'bsubvmns' , B vn_bsubsmnc = 'bsubsmnc' , vn_bsupumns = 'bsupumns' , C vn_bsupvmns = 'bsupvmns' , D vn_rbc = 'rbc' , vn_zbs = 'zbs' , vn_rbs = 'rbs' , vn_zbc = 'zbc' , E vn_potvac = 'potvac' , !    FOR ANIMEC F vn_wpar = 'wpar' , vn_pparmnc = 'pparmnc' , vn_ppermnc = 'ppermnc' , G vn_hotdmnc = 'hotdmnc' , vn_pbprmnc = 'pbprmnc' , H vn_ppprmnc = 'ppprmnc' , vn_sigmnc = 'sigmnc' , I vn_taumnc = 'taumnc' , J vn_pparmns = 'pparmns' , vn_ppermns = 'ppermns' , K vn_hotdmns = 'hotdmns' , vn_pbprmns = 'pbprmns' , L vn_ppprmns = 'ppprmns' , vn_sigmns = 'sigmns' , M vn_taumns = 'taumns' , !    FOR FLOW N vn_machsq = 'machsq' , O vn_protmnc = 'protmnc' , vn_protrsqmnc = 'protrsqmnc' , P vn_prprmnc = 'prprmnc' , Q vn_protmns = 'protmns' , vn_protrsqmns = 'protrsqmns' , R vn_prprmns = 'prprmns' , S vn_pmap = 'pmap' , vn_omega = 'omega' , vn_tpotb = 'tpotb' ! Long names (ln_...) CHARACTER ( LEN =* ), PARAMETER :: 1 ln_version = 'VMEC Version' , 2 ln_extension = 'Input file extension' , 3 ln_mgrid = 'MGRID file' , 4 ln_magen = 'Magnetic Energy' , ln_therm = 'Thermal Energy' , 5 ln_gam = 'Gamma' , ln_maxr = 'Maximum R' , ln_minr = 'Minimum R' , 6 ln_maxz = 'Maximum Z' , ln_fp = 'Field Periods' , 7 ln_radnod = 'Radial nodes' , ln_polmod = 'Poloidal modes' , 8 ln_tormod = 'Toroidal modes' , ln_maxmod = 'Fourier modes' , 8 ln_maxmod_nyq = 'Fourier modes (Nyquist)' , 9 ln_maxit = 'Max iterations' , ln_actit = 'Actual iterations' , 1 ln_asym = 'Asymmetry' , ln_recon = 'Reconstruction' , 1 ln_free = 'Free boundary' , 2 ln_error = 'Error flag' , ln_aspect = 'Aspect ratio' , 3 ln_beta = 'Total beta' , ln_pbeta = 'Poloidal beta' , 4 ln_tbeta = 'Toroidal beta' , ln_abeta = 'Beta axis' , 5 ln_b0 = 'RB-t over R axis' , ln_rbt0 = 'RB-t axis' , 6 ln_rbt1 = 'RB-t edge' , ln_sgs = 'Sign jacobian' , 7 ln_lar = 'Ion Larmor radius' , ln_modB = 'avg mod B' , 8 ln_ctor = 'Toroidal current' , ln_amin = 'minor radius' , 9 ln_Rmaj = 'major radius' , ln_vol = 'Plasma volume' , 1 ln_mse = 'Number of MSE points' , 1 ln_thom = 'Number of Thompson scattering points' , 1 ln_am = 'Specification parameters for mass(s)' , 1 ln_ac = 'Specification parameters for <J>(s)' , 1 ln_ai = 'Specification parameters for iota(s)' , 1 ln_pmass_type = 'Profile type specifier for mass(s)' , 1 ln_pcurr_type = 'Profile type specifier for <J>(s)' , 1 ln_piota_type = 'Profile type specifier for iota(s)' , 1 ln_am_aux_s = 'Auxiliary-s parameters for mass(s)' , 1 ln_am_aux_f = 'Auxiliary-f parameters for mass(s)' , 1 ln_ac_aux_s = 'Auxiliary-s parameters for <J>(s)' , 1 ln_ac_aux_f = 'Auxiliary-f parameters for <J>(s)' , 1 ln_ai_aux_s = 'Auxiliary-s parameters for iota(s)' , 1 ln_ai_aux_f = 'Auxiliary-f parameters for iota(s)' , 4 ln_pmod = 'Poloidal mode numbers' , 5 ln_tmod = 'Toroidal mode numbers' , 4 ln_pmod_nyq = 'Poloidal mode numbers (Nyquist)' , 5 ln_tmod_nyq = 'Toroidal mode numbers (Nyquist)' , 5 ln_racc = 'raxis (cosnv)' , ln_racs = 'raxis (sinnv)' , 6 ln_zacs = 'zaxis (sinnv)' , ln_zacc = 'zaxis (cosnv)' , 7 ln_iotaf = 'iota on full mesh' , 7 ln_qfact = 'q-factor on full mesh' , 8 ln_presf = 'pressure on full mesh' , 8 ln_phi = 'Toroidal flux on full mesh' , 9 ln_phipf = 'd(phi)/ds: Toroidal flux deriv on full mesh' , 9 ln_chi = 'Poloidal flux on full mesh' , 9 ln_chipf = 'd(chi)/ds: Poroidal flux deriv on full mesh' , 9 ln_jcuru = 'j dot gradu full' , 1 ln_jcurv = 'j dot gradv full' , ln_iotah = 'iota half' , 2 ln_mass = 'mass half' , ln_presh = 'pressure half' , 3 ln_betah = 'beta half' , ln_buco = 'bsubu half' , 4 ln_bvco = 'bsubv half' , ln_vp = 'volume deriv half' , 5 ln_specw = 'Spectral width half' , 6 ln_phip = 'tor flux deriv over 2pi half' , 7 ln_jdotb = 'J dot B' , ln_bgrv = 'B dot grad v' , 8 ln_merc = 'Mercier criterion' , ln_mshear = 'Shear Mercier' , 9 ln_mwell = 'Well Mercier' , ln_mcurr = 'Current Mercier' , 1 ln_mgeo = 'Geodesic Mercier' , ln_equif = 'Average force balance' , 1 ln_fsq = 'Residual decay' , 2 ln_wdot = 'Wdot decay' , ln_extcur = 'External coil currents' , 2 ln_fsqr = 'Residual decay - radial' , 2 ln_fsqz = 'Residual decay - vertical' , 2 ln_fsql = 'Residual decay - hoop' , 2 ln_ftolv = 'Residual decay - requested' , 3 ln_curlab = 'External current names' , 3 ln_rmnc = 'cosmn component of cylindrical R, full mesh' , 4 ln_zmns = 'sinmn component of cylindrical Z, full mesh' , 4 ln_lmns = 'sinmn component of lambda, half mesh' , 5 ln_gmnc = 'cosmn component of jacobian, half mesh' , 6 ln_bmnc = 'cosmn component of mod-B, half mesh' , 6 ln_bsubumnc = 'cosmn covariant u-component of B, half mesh' , 6 ln_bsubvmnc = 'cosmn covariant v-component of B, half mesh' , 7 ln_bsubsmns = 'sinmn covariant s-component of B, full mesh' , 7 ln_bsupumnc = 'BSUPUmnc half' , 8 ln_bsupvmnc = 'BSUPVmnc half' , 3 ln_rmns = 'sinmn component of cylindrical R, full mesh' , 4 ln_zmnc = 'cosmn component of cylindrical Z, full mesh' , 4 ln_lmnc = 'cosmn component of lambda, half mesh' , 5 ln_gmns = 'sinmn component of jacobian, half mesh' , 6 ln_bmns = 'sinmn component of mod-B, half mesh' , 6 ln_bsubumns = 'sinmn covariant u-component of B, half mesh' , 6 ln_bsubvmns = 'sinmn covariant v-component of B, half mesh' , 7 ln_bsubsmnc = 'cosmn covariant s-component of B, full mesh' , 4 ln_bsupumns = 'BSUPUmns half' , ln_bsupvmns = 'BSUPVmns half' , 6 ln_rbc = 'Initial boundary R cos(mu-nv) coefficients' , 7 ln_zbs = 'Initial boundary Z sin(mu-nv) coefficients' , 8 ln_rbs = 'Initial boundary R sin(mu-nv) coefficients' , 9 ln_zbc = 'Initial boundary Z cos(mu-nv) coefficients' , 1 ln_potvac = 'Vacuum Potential on Boundary' , !    FOR ANIMEC F ln_wpar = 'Energy' , G ln_pparmnc = 'cosmn compoents of hot part. para. pressure' , H ln_ppermnc = 'cosmn compoents of hot part. perp. pressure' , I ln_hotdmnc = 'cosmn compoents of hot part. density' , J ln_pbprmnc = 'cosmn compoents of hot part. para. pres. grad.' , K ln_ppprmnc = 'cosmn compoents of hot part. perp. pres. grad.' , L ln_sigmnc = 'cosmn firehose stability variable' , M ln_taumnc = 'cosmn mirror stability variable' , N ln_pparmns = 'sinmn compoents of hot part. para. pressure' , O ln_ppermns = 'sinmn compoents of hot part. perp. pressure' , P ln_hotdmns = 'sinmn compoents of hot part. density' , Q ln_pbprmns = 'sinmn compoents of hot part. para. pres. grad.' , R ln_ppprmns = 'sinmn compoents of hot part. perp. pres. grad.' , S ln_sigmns = 'sinmn firehose stability variable' , T ln_taumns = 'sinmn mirror stability variable' , !    FOR FLOW U ln_machsq = 'Mach # on axis (squared)' , V ln_protmnc = 'cosmn components of pressure' , W ln_protrsqmnc = 'cosmn component of rotational energy' , X ln_prprmnc = 'cosmn components of radial pressure gradient' , Y ln_protmns = 'sinmn components of pressure' , Z ln_protrsqmns = 'sinmn component of rotational energy' , 1 ln_prprmns = 'sinmn components of radial pressure gradient' , 2 ln_pmap = '<p(s,R)>' , ln_omega = 'Toroidal Angular Freq.' , 3 ln_tpotb = 'T_perp/T_parallel or T(flow)' #endif !----------------------------------------------- !   L o c a l   V a r i a b l e s !----------------------------------------------- INTEGER :: nfp , ns , mpol , ntor , mnmax , mnmax_nyq , itfsq , niter , 1 iasym , ireconstruct , ierr_vmec , imse , itse , nstore_seq , 2 isnodes , ipnodes , imatch_phiedge , isigng , mnyq , nnyq , ntmax , 3 vmec_type REAL ( rprec ) :: wb , wp , gamma , pfac , rmax_surf , rmin_surf , 1 zmax_surf , aspect , betatot , betapol , betator , betaxis , b0 , 2 tswgt , msewgt , flmwgt , bcwgt , phidiam , version_ , 3 delphid , IonLarmor , VolAvgB , 3 fsql , fsqr , fsqz , ftolv , 4 Aminor , Rmajor , Volume , RBtor , RBtor0 , Itor , 5 machsq !SAL REAL ( rprec ), ALLOCATABLE :: rzl_local (:,:,:,:) REAL ( rprec ), DIMENSION (:,:), ALLOCATABLE :: 1 rmnc , zmns , lmns , rmns , zmnc , lmnc , bmnc , gmnc , bsubumnc , 2 bsubvmnc , bsubsmns , bsupumnc , bsupvmnc , currvmnc , 3 currumnc , bbc , raxis , zaxis REAL ( rprec ), DIMENSION (:,:), ALLOCATABLE :: 1 bmns , gmns , bsubumns , bsubvmns , bsubsmnc , 2 bsupumns , bsupvmns , currumns , currvmns REAL ( rprec ), DIMENSION (:,:), ALLOCATABLE :: 1 pparmnc , ppermnc , hotdmnc , pbprmnc , ppprmnc , sigmnc , taumnc , ! SAL - ANIMEC 2 pparmns , ppermns , hotdmns , pbprmns , ppprmns , sigmns , taumns , ! SAL - ANIMEC 3 protmnc , protrsqmnc , prprmnc , ! SAL - FLOW 4 protmns , protrsqmns , prprmns ! SAL - FLOW REAL ( rprec ), DIMENSION (:), ALLOCATABLE :: 1 iotas , iotaf , presf , phipf , mass , pres , beta_vol , xm , xn , 1 qfact , chipf , phi , chi , 2 xm_nyq , xn_nyq , phip , buco , bvco , vp , overr , jcuru , jcurv , 3 specw , jdotb , bdotgradv , fsqt , wdot , am , ac , ai , 3 am_aux_s , am_aux_f , ac_aux_s , ac_aux_f , ai_aux_s , ai_aux_f , 3 Dmerc , Dshear , Dwell , Dcurr , Dgeod , equif , extcur , 4 sknots , ystark , y2stark , pknots , ythom , y2thom , 5 anglemse , rmid , qmid , shear , presmid , alfa , curmid , rstark , 6 qmeas , datastark , rthom , datathom , dsiobt , potvac REAL ( rprec ), DIMENSION (:), ALLOCATABLE :: 1 pmap , omega , tpotb ! SAL -FLOW LOGICAL :: lasym , lthreed , lwout_opened = . false . CHARACTER :: mgrid_file * 200 , input_extension * 100 CHARACTER :: pmass_type * 20 , pcurr_type * 20 , piota_type * 20 INTEGER , PARAMETER :: norm_term_flag = 0 , 1 bad_jacobian_flag = 1 , more_iter_flag = 2 , jac75_flag = 4 !     OVERLOAD SUBROUTINE READ_WOUT_FILE TO ACCEPT BOTH UNIT NO. (OPENED EXTERNALLY) !     OR FILENAME (HANDLE OPEN/CLOSE HERE) INTERFACE read_wout_file MODULE PROCEDURE readw_and_open , readw_only END INTERFACE #if defined(NETCDF) PRIVATE :: read_wout_text , read_wout_nc #else PRIVATE :: read_wout_text #endif PRIVATE :: norm_term_flag , bad_jacobian_flag , 1 more_iter_flag , jac75_flag CONTAINS SUBROUTINE readw_and_open ( file_or_extension , ierr , iopen ) USE safe_open_mod IMPLICIT NONE C----------------------------------------------- C   D u m m y   A r g u m e n t s C----------------------------------------------- INTEGER , INTENT ( out ) :: ierr INTEGER , OPTIONAL :: iopen CHARACTER ( LEN =* ), INTENT ( in ) :: file_or_extension C----------------------------------------------- C   L o c a l   V a r i a b l e s C----------------------------------------------- INTEGER , PARAMETER :: iunit_init = 10 INTEGER :: iunit , i LOGICAL :: isnc CHARACTER ( len = LEN_TRIM ( file_or_extension ) + 10 ) :: filename C----------------------------------------------- ! !     THIS SUBROUTINE READS THE WOUT FILE CREATED BY THE VMEC CODE !     AND STORES THE DATA IN THE READ_WOUT MODULE ! !     FIRST, CHECK IF THIS IS A FULLY-QUALIFIED PATH NAME !     MAKE SURE wout IS NOT EMBEDDED IN THE NAME (PERVERSE USER...) ! filename = 'wout' CALL parse_extension ( filename , file_or_extension , isnc ) CALL flush ( 6 ) !SPH  IF (.not.isnc) STOP 'ISNC ERR IN READ_WOUT_MOD' IF ( isnc ) THEN #if defined(NETCDF) CALL read_wout_nc ( filename , ierr ) #else PRINT * , \"NETCDF wout file can not be opened on this platform\" ierr = - 100 #endif ELSE iunit = iunit_init CALL safe_open ( iunit , ierr , filename , 'old' , 'formatted' ) IF ( ierr . eq . 0 ) CALL read_wout_text ( iunit , ierr ) CLOSE ( unit = iunit ) END IF IF ( PRESENT ( iopen )) iopen = ierr lwout_opened = ( ierr . eq . 0 ) ! WHEN READING A NETCDF FILE, A BAD RUN MAY PREVENT XN FROM BEING ! READ, SUBSEQUENTLY WE MUST CHECK TO SEE IF XN HAS BEEN ALLOCATED ! BEFORE DOING ANYTHING WITH IT OTHERWISE WE DEFAULT LTHREED TO ! FALSE.  - SAL 09/07/11 IF ( ALLOCATED ( XN )) THEN lthreed = ANY ( NINT ( xn ) . ne . 0 ) ELSE lthreed = . FALSE . END IF END SUBROUTINE readw_and_open SUBROUTINE readw_only ( iunit , ierr , iopen ) IMPLICIT NONE C----------------------------------------------- C   D u m m y   A r g u m e n t s C----------------------------------------------- INTEGER , INTENT ( in ) :: iunit INTEGER , INTENT ( out ) :: ierr INTEGER , OPTIONAL :: iopen C----------------------------------------------- C   L o c a l   V a r i a b l e s C----------------------------------------------- INTEGER :: istat CHARACTER ( LEN = 256 ) :: vmec_version LOGICAL :: exfile C----------------------------------------------- ! !     User opened the file externally and has a unit number, iunit ! ierr = 0 INQUIRE ( unit = iunit , exist = exfile , name = vmec_version , iostat = istat ) IF ( istat . ne . 0 . or . . not . exfile ) THEN PRINT * , ' In READ_WOUT_FILE, Unit = ' , iunit , 1 ' File = ' , TRIM ( vmec_version ), ' DOES NOT EXIST' IF ( PRESENT ( iopen )) iopen = - 1 ierr = - 1 RETURN ELSE IF ( PRESENT ( iopen )) iopen = 0 END IF CALL read_wout_text ( iunit , ierr ) lwout_opened = ( ierr . eq . 0 ) lthreed = ANY ( NINT ( xn ) . ne . 0 ) END SUBROUTINE readw_only SUBROUTINE read_wout_text ( iunit , ierr ) USE stel_constants , ONLY : mu0 IMPLICIT NONE C----------------------------------------------- C   D u m m y   A r g u m e n t s C----------------------------------------------- INTEGER :: iunit , ierr C----------------------------------------------- C   L o c a l   P a r a m e t e r s C----------------------------------------------- REAL ( rprec ), PARAMETER :: eps_w = 1.e-4_dp C----------------------------------------------- C   L o c a l   V a r i a b l e s C----------------------------------------------- INTEGER :: istat ( 15 ), i , j , k , js , m , n , n1 , mn , nparts_in , 1 i_animec , i_flow CHARACTER ( LEN = 256 ) :: vmec_version LOGICAL :: lcurr C----------------------------------------------- ! !     THIS SUBROUTINE READS THE TEXT FILE WOUT CREATED BY THE VMEC CODE !     AND STORES THE INFORMATION IN THE read_WOUT MODULE ! !     CALL read_wout_file - GENERIC INTERFACE - CAN BE CALLED WITH EITHER UNIT NO. OR FILENAME ! !     RMNC, ZMNS: FULL-GRID !     LMNS      : HALF-GRID ! istat = 0 ierr = 0 nextcur = 0 READ ( iunit , '(a)' , iostat = istat ( 2 ), err = 1000 ) vmec_version i = INDEX ( vmec_version , '=' ) !!!! ADDED BY SAL i_animec = INDEX ( vmec_version , '_ANIMEC' ) i_flow = INDEX ( vmec_version , '_FLOW' ) vmec_type = 0 IF ( i_animec > 0 ) THEN vmec_type = 1 ! ANIMEC vmec_version = vmec_version ( 1 : i_animec - 1 ) END IF IF ( i_flow > 0 ) THEN vmec_type = 2 ! FLOW vmec_version = vmec_version ( 1 : i_flow - 1 ) END IF !!!! END SAL Addition IF ( i . ge . 0 ) THEN READ ( vmec_version ( i + 1 : len_trim ( vmec_version )), * ) version_ ELSE version_ = - 1.0 END IF ierr_vmec = norm_term_flag IF ( version_ . le . ( 5.10 + eps_w )) THEN READ ( iunit , * , iostat = istat ( 2 ), err = 1000 ) wb , wp , gamma , 1 pfac , nfp , ns , 1 mpol , ntor , mnmax , itfsq , niter , iasym , ireconstruct ELSE IF ( version_ . lt . 6.54 ) THEN READ ( iunit , * , iostat = istat ( 2 ), err = 1000 ) wb , wp , gamma , 1 pfac , rmax_surf , rmin_surf ELSE READ ( iunit , * , iostat = istat ( 2 ), err = 1000 ) wb , wp , gamma , 1 pfac , rmax_surf , rmin_surf , zmax_surf END IF IF ( vmec_type == 2 ) THEN !SAL READ ( iunit , * , iostat = istat ( 2 ), err = 1000 ) machsq END IF IF ( version_ . le . ( 8.0 + eps_w )) THEN READ ( iunit , * , iostat = istat ( 2 ), err = 1000 ) nfp , ns , mpol , 1 ntor , mnmax , itfsq , niter , iasym , ireconstruct , ierr_vmec mnmax_nyq = mnmax ELSE READ ( iunit , * , iostat = istat ( 2 ), err = 1000 ) nfp , ns , mpol , 1 ntor , mnmax , mnmax_nyq , itfsq , niter , iasym , ireconstruct , 2 ierr_vmec END IF END IF lasym = ( iasym . gt . 0 ) IF ( version_ . gt . ( 6.20 + eps_w )) THEN READ ( iunit , * , iostat = istat ( 1 ), err = 1000 ) imse , itse , nbsets , 1 nobd , nextcur , nstore_seq ELSE READ ( iunit , * , iostat = istat ( 1 ), err = 1000 ) imse , itse , nbsets , 1 nobd , nextcur nstore_seq = 100 END IF IF ( ierr_vmec . ne . norm_term_flag . and . ierr_vmec . ne . more_iter_flag ) 1 GOTO 1000 IF ( nextcur . gt . nigroup ) istat ( 15 ) = - 1 IF ( ALLOCATED ( xm )) CALL read_wout_deallocate ALLOCATE ( xm ( mnmax ), xn ( mnmax ), xm_nyq ( mnmax_nyq ), 1 xn_nyq ( mnmax_nyq ), rmnc ( mnmax , ns ), zmns ( mnmax , ns ), 2 lmns ( mnmax , ns ), bmnc ( mnmax_nyq , ns ), gmnc ( mnmax_nyq , ns ), 3 bsubumnc ( mnmax_nyq , ns ), bsubvmnc ( mnmax_nyq , ns ), 4 bsubsmns ( mnmax_nyq , ns ), bsupumnc ( mnmax_nyq , ns ), 5 bsupvmnc ( mnmax_nyq , ns ), currvmnc ( mnmax_nyq , ns ), 5 iotas ( ns ), mass ( ns ), pres ( ns ), beta_vol ( ns ), phip ( ns ), 6 buco ( ns ), bvco ( ns ), phi ( ns ), iotaf ( ns ), presf ( ns ), phipf ( ns ), 5 vp ( ns ), overr ( ns ), jcuru ( ns ), jcurv ( ns ), specw ( ns ), Dmerc ( ns ), 6 Dshear ( ns ), Dwell ( ns ), Dcurr ( ns ), Dgeod ( ns ), equif ( ns ), 7 extcur ( nextcur ), curlabel ( nextcur ), raxis ( 0 : ntor , 2 ), 8 zaxis ( 0 : ntor , 2 ), jdotb ( ns ), bdotgradv ( ns ), 8 am ( 0 : 20 ), ac ( 0 : 20 ), ai ( 0 : 20 ), 9 fsqt ( nstore_seq ), wdot ( nstore_seq ), stat = istat ( 6 )) IF ( lasym ) 1 ALLOCATE ( rmns ( mnmax , ns ), zmnc ( mnmax , ns ), lmnc ( mnmax , ns ), 2 bmns ( mnmax_nyq , ns ), gmns ( mnmax_nyq , ns ), 3 bsubumns ( mnmax_nyq , ns ), 3 bsubvmns ( mnmax_nyq , ns ), bsubsmnc ( mnmax_nyq , ns ), 4 bsupumns ( mnmax_nyq , ns ), bsupvmns ( mnmax_nyq , ns ), 5 stat = istat ( 6 )) IF ( vmec_type == 1 ) THEN ! SAL ALLOCATE ( pparmnc ( mnmax_nyq , ns ), ppermnc ( mnmax_nyq , ns ), 1 hotdmnc ( mnmax_nyq , ns ), pbprmnc ( mnmax_nyq , ns ), 2 ppprmnc ( mnmax_nyq , ns ), sigmnc ( mnmax_nyq , ns ), 3 taumnc ( mnmax_nyq , ns ), stat = istat ( 6 )) IF ( lasym ) 1 ALLOCATE ( pparmns ( mnmax_nyq , ns ), ppermns ( mnmax_nyq , ns ), 2 hotdmns ( mnmax_nyq , ns ), pbprmns ( mnmax_nyq , ns ), 3 ppprmns ( mnmax_nyq , ns ), sigmns ( mnmax_nyq , ns ), 4 taumns ( mnmax_nyq , ns ), stat = istat ( 6 )) ELSE IF ( vmec_type == 2 ) THEN ALLOCATE ( pmap ( ns ), omega ( ns ), tpotb ( ns ), stat = istat ( 6 )) ALLOCATE ( protmnc ( mnmax_nyq , ns ), protrsqmnc ( mnmax_nyq , ns ), 1 prprmnc ( mnmax_nyq , ns ), stat = istat ( 6 )) IF ( lasym ) 1 ALLOCATE ( protmns ( mnmax_nyq , ns ), protrsqmns ( mnmax_nyq , ns ), 2 prprmns ( mnmax_nyq , ns ), stat = istat ( 6 )) END IF fsqt = 0 ; wdot = 0 ; raxis = 0 ; zaxis = 0 IF ( nbsets . gt . 0 ) READ ( iunit , * , iostat = istat ( 4 ), err = 1000 ) 1 ( nbfld ( i ), i = 1 , nbsets ) READ ( iunit , '(a)' , iostat = istat ( 5 ), err = 1000 ) mgrid_file DO js = 1 , ns DO mn = 1 , mnmax IF ( js . eq . 1 ) THEN READ ( iunit , * , iostat = istat ( 7 ), err = 1000 ) m , n xm ( mn ) = REAL ( m , rprec ) xn ( mn ) = REAL ( n , rprec ) END IF IF ( version_ . le . ( 6.20 + eps_w )) THEN READ ( iunit , 730 , iostat = istat ( 8 ), err = 1000 ) 1 rmnc ( mn , js ), zmns ( mn , js ), lmns ( mn , js ), 2 bmnc ( mn , js ), gmnc ( mn , js ), bsubumnc ( mn , js ), 3 bsubvmnc ( mn , js ), bsubsmns ( mn , js ), 4 bsupumnc ( mn , js ), bsupvmnc ( mn , js ), 5 currvmnc ( mn , js ) ELSE IF ( version_ . le . ( 8.0 + eps_w )) THEN READ ( iunit , * , iostat = istat ( 8 ), err = 1000 ) 1 rmnc ( mn , js ), zmns ( mn , js ), lmns ( mn , js ), 2 bmnc ( mn , js ), gmnc ( mn , js ), bsubumnc ( mn , js ), 3 bsubvmnc ( mn , js ), bsubsmns ( mn , js ), 4 bsupumnc ( mn , js ), bsupvmnc ( mn , js ), 5 currvmnc ( mn , js ) ELSE READ ( iunit , * , iostat = istat ( 8 ), err = 1000 ) 1 rmnc ( mn , js ), zmns ( mn , js ), lmns ( mn , js ) END IF IF ( lasym ) THEN IF ( version_ . le . ( 8.0 + eps_w )) THEN READ ( iunit , * , iostat = istat ( 8 ), err = 1000 ) 1 rmns ( mn , js ), zmnc ( mn , js ), lmnc ( mn , js ), 2 bmns ( mn , js ), gmns ( mn , js ), bsubumns ( mn , js ), 3 bsubvmns ( mn , js ), bsubsmnc ( mn , js ), 4 bsupumns ( mn , js ), bsupvmns ( mn , js ) ELSE READ ( iunit , * , iostat = istat ( 8 ), err = 1000 ) 1 rmns ( mn , js ), zmnc ( mn , js ), lmnc ( mn , js ) END IF END IF IF ( js . eq . 1 . and . m . eq . 0 ) THEN n1 = ABS ( n / nfp ) IF ( n1 . le . ntor ) THEN raxis ( n1 , 1 ) = rmnc ( mn , 1 ) zaxis ( n1 , 1 ) = zmns ( mn , 1 ) IF ( lasym ) THEN raxis ( n1 , 2 ) = rmns ( mn , 1 ) zaxis ( n1 , 2 ) = zmnc ( mn , 1 ) END IF END IF END IF END DO IF ( version_ . le . ( 8.0 + eps_w )) CYCLE DO mn = 1 , mnmax_nyq IF ( js . eq . 1 ) THEN READ ( iunit , * , iostat = istat ( 7 ), err = 1000 ) m , n xm_nyq ( mn ) = REAL ( m , rprec ) xn_nyq ( mn ) = REAL ( n , rprec ) END IF IF ( vmec_type == 1 ) THEN !SAL (ELSE statement below is orriginal) READ ( iunit , * , iostat = istat ( 8 ), err = 1000 ) 1 bmnc ( mn , js ), gmnc ( mn , js ), bsubumnc ( mn , js ), 2 bsubvmnc ( mn , js ), bsubsmns ( mn , js ), 3 bsupumnc ( mn , js ), bsupvmnc ( mn , js ), 3 pparmnc ( mn , js ), ppermnc ( mn , js ), hotdmnc ( mn , js ), 4 pbprmnc ( mn , js ), ppprmnc ( mn , js ), sigmnc ( mn , js ), 5 taumnc ( mn , js ) IF ( lasym ) THEN READ ( iunit , * , iostat = istat ( 8 ), err = 1000 ) 1 bmns ( mn , js ), gmns ( mn , js ), bsubumns ( mn , js ), 2 bsubvmns ( mn , js ), bsubsmnc ( mn , js ), 3 bsupumns ( mn , js ), bsupvmns ( mn , js ), 3 pparmns ( mn , js ), ppermns ( mn , js ), hotdmns ( mn , js ), 4 pbprmns ( mn , js ), ppprmns ( mn , js ), sigmns ( mn , js ), 5 taumns ( mn , js ) END IF ELSE IF ( vmec_type == 2 ) THEN READ ( iunit , * , iostat = istat ( 8 ), err = 1000 ) 1 bmnc ( mn , js ), gmnc ( mn , js ), bsubumnc ( mn , js ), 2 bsubvmnc ( mn , js ), bsubsmns ( mn , js ), 3 bsupumnc ( mn , js ), bsupvmnc ( mn , js ), 4 protmnc ( mn , js ), protrsqmnc ( mn , js ), prprmnc ( mn , js ) IF ( lasym ) THEN READ ( iunit , * , iostat = istat ( 8 ), err = 1000 ) 1 bmns ( mn , js ), gmns ( mn , js ), bsubumns ( mn , js ), 2 bsubvmns ( mn , js ), bsubsmnc ( mn , js ), 3 bsupumns ( mn , js ), bsupvmns ( mn , js ), 4 protmns ( mn , js ), protrsqmns ( mn , js ), prprmns ( mn , js ) END IF ELSE READ ( iunit , * , iostat = istat ( 8 ), err = 1000 ) 1 bmnc ( mn , js ), gmnc ( mn , js ), bsubumnc ( mn , js ), 2 bsubvmnc ( mn , js ), bsubsmns ( mn , js ), 3 bsupumnc ( mn , js ), bsupvmnc ( mn , js ) IF ( lasym ) THEN READ ( iunit , * , iostat = istat ( 8 ), err = 1000 ) 2 bmns ( mn , js ), gmns ( mn , js ), bsubumns ( mn , js ), 3 bsubvmns ( mn , js ), bsubsmnc ( mn , js ), 4 bsupumns ( mn , js ), bsupvmns ( mn , js ) END IF END IF END DO END DO !     Compute current coefficients on full mesh IF ( version_ . gt . ( 8.0 + eps_w )) CALL Compute_Currents ( ierr ) mnyq = INT ( MAXVAL ( xm_nyq )); nnyq = INT ( MAXVAL ( ABS ( xn_nyq ))) / nfp ! !     Read FULL AND HALF-MESH QUANTITIES ! !     NOTE: In version_ <= 6.00, mass, press were written out in INTERNAL (VMEC) units !     and are therefore multiplied here by 1/mu0 to transform to pascals. Same is true !     for ALL the currents (jcuru, jcurv, jdotb). Also, in version_ = 6.10 and !     above, PHI is the true (physical) toroidal flux (has the sign of jacobian correctly !     built into it) ! iotas ( 1 ) = 0 ; mass ( 1 ) = 0 ; pres ( 1 ) = 0 ; phip ( 1 ) = 0 ; buco ( 1 ) = 0 ; bvco ( 1 ) = 0 ; vp ( 1 ) = 0 ; overr ( 1 ) = 0 ; specw ( 1 ) = 1 beta_vol ( 1 ) = 0 IF ( version_ . le . ( 6.05 + eps_w )) THEN READ ( iunit , 730 , iostat = istat ( 9 ), err = 1000 ) 1 ( iotas ( js ), mass ( js ), pres ( js ), 2 phip ( js ), buco ( js ), bvco ( js ), phi ( js ), vp ( js ), overr ( js ), 3 jcuru ( js ), jcurv ( js ), specw ( js ), js = 2 , ns ) READ ( iunit , 730 , iostat = istat ( 10 ), err = 1000 ) 1 aspect , betatot , betapol , betator , betaxis , b0 ELSE IF ( version_ . le . ( 6.20 + eps_w )) THEN READ ( iunit , 730 , iostat = istat ( 9 ), err = 1000 ) 1 ( iotas ( js ), mass ( js ), pres ( js ), beta_vol ( js ), 2 phip ( js ), buco ( js ), bvco ( js ), phi ( js ), vp ( js ), overr ( js ), 3 jcuru ( js ), jcurv ( js ), specw ( js ), js = 2 , ns ) READ ( iunit , 730 , iostat = istat ( 10 ), err = 1000 ) 1 aspect , betatot , betapol , betator , betaxis , b0 ELSE IF ( version_ . le . ( 6.95 + eps_w )) THEN READ ( iunit , * , iostat = istat ( 9 ), err = 1000 ) 1 ( iotas ( js ), mass ( js ), pres ( js ), beta_vol ( js ), 2 phip ( js ), buco ( js ), bvco ( js ), phi ( js ), vp ( js ), overr ( js ), 3 jcuru ( js ), jcurv ( js ), specw ( js ), js = 2 , ns ) READ ( iunit , * , iostat = istat ( 10 ), err = 1000 ) 1 aspect , betatot , betapol , betator , betaxis , b0 ELSE READ ( iunit , * , iostat = istat ( 9 ), err = 1000 ) 1 ( iotaf ( js ), presf ( js ), phipf ( js ), phi ( js ), 2 jcuru ( js ), jcurv ( js ), js = 1 , ns ) IF ( vmec_type == 2 ) THEN READ ( iunit , * , iostat = istat ( 9 ), err = 1000 ) 1 ( iotas ( js ), mass ( js ), 1 pmap ( js ), omega ( js ), tpotb ( js ), pres ( js ), 2 beta_vol ( js ), phip ( js ), buco ( js ), bvco ( js ), vp ( js ), 3 overr ( js ), specw ( js ), js = 2 , ns ) ELSE READ ( iunit , * , iostat = istat ( 9 ), err = 1000 ) 1 ( iotas ( js ), mass ( js ), pres ( js ), 2 beta_vol ( js ), phip ( js ), buco ( js ), bvco ( js ), vp ( js ), 3 overr ( js ), specw ( js ), js = 2 , ns ) END IF READ ( iunit , * , iostat = istat ( 10 ), err = 1000 ) 1 aspect , betatot , betapol , betator , betaxis , b0 END IF IF ( version_ . gt . ( 6.10 + eps_w )) THEN READ ( iunit , * , iostat = istat ( 10 ), err = 1000 ) isigng READ ( iunit , * , iostat = istat ( 10 ), err = 1000 ) input_extension READ ( iunit , * , iostat = istat ( 10 ), err = 1000 ) IonLarmor , 1 VolAvgB , RBtor0 , RBtor , Itor , Aminor , Rmajor , Volume END IF !----------------------------------------------- !     MERCIER CRITERION !----------------------------------------------- IF ( version_ . gt .( 5.10 + eps_w ) . and . version_ . lt .( 6.20 - eps_w )) THEN READ ( iunit , 730 , iostat = istat ( 11 ), err = 1000 ) 1 ( Dmerc ( js ), Dshear ( js ), Dwell ( js ), Dcurr ( js ), 2 Dgeod ( js ), equif ( js ), js = 2 , ns - 1 ) ELSE IF ( version_ . ge . ( 6.20 - eps_w )) THEN READ ( iunit , * , iostat = istat ( 11 ), err = 1000 ) 1 ( Dmerc ( js ), Dshear ( js ), Dwell ( js ), Dcurr ( js ), 2 Dgeod ( js ), equif ( js ), js = 2 , ns - 1 ) END IF IF ( nextcur . gt . 0 ) THEN IF ( version_ . le . ( 6.20 + eps_w )) THEN READ ( iunit , 730 , iostat = istat ( 12 ), err = 1000 ) 1 ( extcur ( i ), i = 1 , nextcur ) ELSE READ ( iunit , * , iostat = istat ( 12 ), err = 1000 ) 1 ( extcur ( i ), i = 1 , nextcur ) END IF !SAL 11/30/11 - To make DIAGNO v2 work with old files. IF (( version_ . ge . ( 6.90 - eps_w )) . and . 1 ( version_ . le . ( 6.90 + eps_w ))) THEN lcurr = . true . ELSE READ ( iunit , * , iostat = istat ( 13 )) lcurr END IF !READ (iunit, *, iostat=istat(13)) lcurr IF ( lcurr ) READ ( iunit , * , iostat = istat ( 13 ), err = 1000 ) 1 ( curlabel ( i ), i = 1 , nextcur ) END IF IF ( version_ . le . ( 6.20 + eps_w )) THEN READ ( iunit , 730 , iostat = istat ( 14 )) 1 ( fsqt ( i ), wdot ( i ), i = 1 , nstore_seq ) ELSE READ ( iunit , * , iostat = istat ( 14 )) 1 ( fsqt ( i ), wdot ( i ), i = 1 , nstore_seq ) END IF IF (( version_ . ge . 6.20 - eps_w ) . and . ( version_ . lt . ( 6.50 - eps_w )) 1 . and . ( istat ( 14 ). eq . 0 )) THEN READ ( iunit , 730 , iostat = istat ( 14 ), err = 1000 ) 1 ( jdotb ( js ), bdotgradv ( js ), js = 1 , ns ) ELSE IF ( version_ . ge . ( 6.50 - eps_w )) THEN READ ( iunit , * , iostat = istat ( 14 ), err = 1000 ) 1 ( jdotb ( js ), bdotgradv ( js ), js = 1 , ns ) ELSE istat ( 14 ) = 0 END IF ! !     CONVERT FROM INTERNAL UNITS TO PHYSICAL UNITS IF NEEDED ! IF ( version_ . le . ( 6.05 + eps_w )) THEN mass = mass / mu0 pres = pres / mu0 jcuru = jcuru / mu0 jcurv = jcurv / mu0 jdotb = jdotb / mu0 phi = - phi END IF !----------------------------------------------- !     DATA AND MSE FITS !----------------------------------------------- IF ( ireconstruct . gt . 0 ) THEN n1 = MAXVAL ( nbfld (: nbsets )) ALLOCATE ( sknots ( isnodes ), ystark ( isnodes ), y2stark ( isnodes ), 1 pknots ( ipnodes ), ythom ( ipnodes ), y2thom ( ipnodes ), 2 anglemse ( 2 * ns ), rmid ( 2 * ns ), qmid ( 2 * ns ), shear ( 2 * ns ), 3 presmid ( 2 * ns ), alfa ( 2 * ns ), curmid ( 2 * ns ), rstark ( imse ), 4 datastark ( imse ), rthom ( itse ), datathom ( itse ), 5 dsiext ( nobd ), plflux ( nobd ), dsiobt ( nobd ), bcoil ( n1 , nbsets ), 6 plbfld ( n1 , nbsets ), bbc ( n1 , nbsets )) IF ( imse . ge . 2 . or . itse . gt . 0 ) THEN READ ( iunit , * ) tswgt , msewgt READ ( iunit , * ) isnodes , ( sknots ( i ), ystark ( i ), y2stark ( i ), 1 i = 1 , isnodes ) READ ( iunit , * ) ipnodes , ( pknots ( i ), ythom ( i ), 1 y2thom ( i ), i = 1 , ipnodes ) READ ( iunit , * )( anglemse ( i ), rmid ( i ), qmid ( i ), shear ( i ), 1 presmid ( i ), alfa ( i ), curmid ( i ), i = 1 , 2 * ns - 1 ) READ ( iunit , * )( rstark ( i ), datastark ( i ), qmeas ( i ), i = 1 , imse ) READ ( iunit , * )( rthom ( i ), datathom ( i ), i = 1 , itse ) END IF IF ( nobd . gt . 0 ) THEN READ ( iunit , * ) ( dsiext ( i ), plflux ( i ), dsiobt ( i ), i = 1 , nobd ) READ ( iunit , * ) flmwgt END IF nbfldn = SUM ( nbfld (: nbsets )) IF ( nbfldn . gt . 0 ) THEN DO n = 1 , nbsets READ ( iunit , * ) ( bcoil ( i , n ), plbfld ( i , n ), bbc ( i , n ), 1 i = 1 , nbfld ( n )) END DO READ ( iunit , * ) bcwgt END IF READ ( iunit , * ) phidiam , delphid ! !     READ Limiter & Prout plotting specs ! READ ( iunit , * ) nsets , nparts_in , nlim ALLOCATE ( nsetsn ( nsets )) READ ( iunit , * ) ( nsetsn ( i ), i = 1 , nsets ) n1 = MAXVAL ( nsetsn (: nsets )) ALLOCATE ( pfcspec ( nparts_in , n1 , nsets ), limitr ( nlim )) READ ( iunit , * ) ((( pfcspec ( i , j , k ), i = 1 , nparts_in ), 1 j = 1 , nsetsn ( k )), k = 1 , nsets ) READ ( iunit , * ) ( limitr ( i ), i = 1 , nlim ) m = MAXVAL ( limitr (: nlim )) ALLOCATE ( rlim ( m , nlim ), zlim ( m , nlim )) READ ( iunit , * ) (( rlim ( i , j ), zlim ( i , j ), i = 1 , limitr ( j )), 1 j = 1 , nlim ) READ ( iunit , * ) nrgrid , nzgrid READ ( iunit , * ) tokid READ ( iunit , * ) rx1 , rx2 , zy1 , zy2 , condif READ ( iunit , * ) imatch_phiedge END IF 1000 CONTINUE READ ( iunit , iostat = ierr ) mgrid_mode IF ( ierr . ne . 0 ) THEN ierr = 0 ; mgrid_mode = 'N' END IF IF ( istat ( 2 ) . ne . 0 ) ierr_vmec = 1 DO m = 1 , 15 IF ( istat ( m ) . gt . 0 ) THEN PRINT * , ' Error No. ' , m , ' in READ_WOUT, iostat = ' , istat ( m ) ierr = m EXIT END IF END DO 720 FORMAT ( 8 i10 ) 730 FORMAT ( 5e20 . 13 ) 740 FORMAT ( a ) 790 FORMAT ( i5 , / ,( 1 p , 3e12 . 4 )) END SUBROUTINE read_wout_text #if defined(NETCDF) SUBROUTINE read_wout_nc ( filename , ierr ) USE ezcdf USE stel_constants , ONLY : mu0 IMPLICIT NONE C----------------------------------------------- C   D u m m y   A r g u m e n t s C----------------------------------------------- INTEGER , INTENT ( out ) :: ierr CHARACTER ( LEN =* ), INTENT ( in ) :: filename C----------------------------------------------- C   L o c a l   V a r i a b l e s C----------------------------------------------- INTEGER :: nwout , ierror , i_animec , i_flow INTEGER , DIMENSION ( 3 ) :: dimlens REAL ( rprec ) :: ohs REAL ( rprec ), DIMENSION (:), ALLOCATABLE :: raxis_cc , raxis_cs , 1 zaxis_cs , zaxis_cc C----------------------------------------------- ! Open cdf File CALL cdf_open ( nwout , filename , 'r' , ierr ) IF ( ierr . ne . 0 ) THEN PRINT * , ' Error opening wout .nc file' RETURN END IF ! Be sure all arrays are deallocated CALL read_wout_deallocate ! ANIMEC/FLOW -SAL i_animec = 0 i_flow = 0 vmec_type = 0 CALL cdf_inquire ( nwout , vn_pparmnc , dimlens , ier = ierror ) IF ( ierror . eq . 0 ) vmec_type = 1 CALL cdf_inquire ( nwout , vn_omega , dimlens , ier = ierror ) IF ( ierror . eq . 0 ) vmec_type = 2 ! Read in scalar variables CALL cdf_read ( nwout , vn_error , ierr_vmec ) ! Next 2 lines commented out by MJL 20150717. They were being triggered by a W7X file. !      IF (ierr_vmec.ne.norm_term_flag .and. ierr_vmec.ne.more_iter_flag) !     1   GOTO 1000 CALL cdf_read ( nwout , vn_version , version_ ) CALL cdf_read ( nwout , vn_extension , input_extension ) CALL cdf_read ( nwout , vn_mgrid , mgrid_file ) CALL cdf_read ( nwout , vn_magen , wb ) CALL cdf_read ( nwout , vn_therm , wp ) CALL cdf_read ( nwout , vn_gam , gamma ) CALL cdf_read ( nwout , vn_maxr , rmax_surf ) CALL cdf_read ( nwout , vn_minr , rmin_surf ) CALL cdf_read ( nwout , vn_maxz , zmax_surf ) CALL cdf_read ( nwout , vn_fp , nfp ) CALL cdf_read ( nwout , vn_radnod , ns ) CALL cdf_read ( nwout , vn_polmod , mpol ) CALL cdf_read ( nwout , vn_tormod , ntor ) CALL cdf_read ( nwout , vn_maxmod , mnmax ) mnmax_nyq = - 1 CALL cdf_read ( nwout , vn_maxmod_nyq , mnmax_nyq ) CALL cdf_read ( nwout , vn_maxit , niter ) CALL cdf_read ( nwout , vn_actit , itfsq ) CALL cdf_read ( nwout , vn_asym , lasym ) IF ( lasym ) iasym = 1 CALL cdf_read ( nwout , vn_recon , lrecon ) IF ( lrecon ) ireconstruct = 1 CALL cdf_read ( nwout , vn_free , lfreeb ) CALL cdf_read ( nwout , vn_rfp , lrfp ) CALL cdf_read ( nwout , vn_aspect , aspect ) CALL cdf_read ( nwout , vn_beta , betatot ) CALL cdf_read ( nwout , vn_pbeta , betapol ) CALL cdf_read ( nwout , vn_tbeta , betator ) CALL cdf_read ( nwout , vn_abeta , betaxis ) CALL cdf_read ( nwout , vn_b0 , b0 ) CALL cdf_read ( nwout , vn_rbt0 , rbtor0 ) CALL cdf_read ( nwout , vn_rbt1 , rbtor ) CALL cdf_read ( nwout , vn_sgs , isigng ) CALL cdf_read ( nwout , vn_lar , IonLarmor ) CALL cdf_read ( nwout , vn_modB , volAvgB ) CALL cdf_read ( nwout , vn_ctor , Itor ) CALL cdf_read ( nwout , vn_amin , Aminor ) CALL cdf_read ( nwout , vn_rmaj , Rmajor ) CALL cdf_read ( nwout , vn_vol , volume ) CALL cdf_read ( nwout , vn_ftolv , ftolv ) CALL cdf_read ( nwout , vn_fsqr , fsqr ) CALL cdf_read ( nwout , vn_fsqz , fsqz ) CALL cdf_read ( nwout , vn_fsql , fsql ) CALL cdf_read ( nwout , vn_pcurr_type , pcurr_type ) CALL cdf_read ( nwout , vn_piota_type , piota_type ) CALL cdf_read ( nwout , vn_pmass_type , pmass_type ) imse = - 1 IF ( lrecon ) THEN CALL cdf_read ( nwout , vn_mse , imse ) CALL cdf_read ( nwout , vn_thom , itse ) END IF CALL cdf_read ( nwout , vn_nextcur , nextcur ) mgrid_mode = 'N' CALL cdf_inquire ( nwout , vn_mgmode , dimlens , ier = ierror ) IF ( ierror . eq . 0 ) CALL cdf_read ( nwout , vn_mgmode , mgrid_mode ) IF ( lfreeb ) THEN CALL cdf_read ( nwout , vn_flp , nobser ) CALL cdf_read ( nwout , vn_nobd , nobd ) CALL cdf_read ( nwout , vn_nbset , nbsets ) END IF ! ANIMEC/FLOW -SAL CALL cdf_inquire ( nwout , vn_machsq , dimlens , ier = ierror ) IF ( ierror . eq . 0 ) CALL cdf_read ( nwout , vn_machsq , machsq ) CALL cdf_inquire ( nwout , vn_wpar , dimlens , ier = ierror ) IF ( ierror . eq . 0 ) CALL cdf_read ( nwout , vn_wpar , wp ) ! This overwrites wp with wpar ! Inquire existence, dimensions of arrays for allocation ! 1D Arrays IF ( lfreeb . and . nbsets . gt . 0 ) THEN CALL cdf_read ( nwout , vn_nbfld , nbfld ) END IF CALL cdf_inquire ( nwout , vn_pmod , dimlens ) ALLOCATE ( xm ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_tmod , dimlens ) ALLOCATE ( xn ( dimlens ( 1 )), stat = ierror ) IF ( mnmax_nyq . gt . 0 ) THEN CALL cdf_inquire ( nwout , vn_pmod_nyq , dimlens ) ALLOCATE ( xm_nyq ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_tmod_nyq , dimlens ) ALLOCATE ( xn_nyq ( dimlens ( 1 )), stat = ierror ) END IF CALL cdf_inquire ( nwout , vn_racc , dimlens ) ALLOCATE ( raxis_cc ( 0 : dimlens ( 1 ) - 1 ), stat = ierror ) CALL cdf_inquire ( nwout , vn_zacs , dimlens ) ALLOCATE ( zaxis_cs ( 0 : dimlens ( 1 ) - 1 ), stat = ierror ) IF ( lasym ) THEN CALL cdf_inquire ( nwout , vn_racs , dimlens ) ALLOCATE ( raxis_cs ( 0 : dimlens ( 1 ) - 1 ), stat = ierror ) CALL cdf_inquire ( nwout , vn_zacc , dimlens ) ALLOCATE ( zaxis_cc ( 0 : dimlens ( 1 ) - 1 ), stat = ierror ) END IF !  Profile coefficients, dimensioned from 0 CALL cdf_inquire ( nwout , vn_am , dimlens ) ALLOCATE ( am ( 0 : dimlens ( 1 ) - 1 ), stat = ierror ) CALL cdf_inquire ( nwout , vn_ac , dimlens ) ALLOCATE ( ac ( 0 : dimlens ( 1 ) - 1 ), stat = ierror ) CALL cdf_inquire ( nwout , vn_ai , dimlens ) ALLOCATE ( ai ( 0 : dimlens ( 1 ) - 1 ), stat = ierror ) CALL cdf_inquire ( nwout , vn_ac_aux_s , dimlens ) ALLOCATE ( ac_aux_s ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_ac_aux_f , dimlens ) ALLOCATE ( ac_aux_f ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_ai_aux_s , dimlens ) ALLOCATE ( ai_aux_s ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_ai_aux_f , dimlens ) ALLOCATE ( ai_aux_f ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_am_aux_s , dimlens ) ALLOCATE ( am_aux_s ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_am_aux_f , dimlens ) ALLOCATE ( am_aux_f ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_iotaf , dimlens ) ALLOCATE ( iotaf ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_qfact , dimlens ) ALLOCATE ( qfact ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_presf , dimlens ) ALLOCATE ( presf ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_phi , dimlens ) ALLOCATE ( phi ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_chi , dimlens ) ALLOCATE ( chi ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_phipf , dimlens ) ALLOCATE ( phipf ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_chipf , dimlens ) ALLOCATE ( chipf ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_jcuru , dimlens ) ALLOCATE ( jcuru ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_jcurv , dimlens ) ALLOCATE ( jcurv ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_iotah , dimlens ) ALLOCATE ( iotas ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_mass , dimlens ) ALLOCATE ( mass ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_presh , dimlens ) ALLOCATE ( pres ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_betah , dimlens ) ALLOCATE ( beta_vol ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_buco , dimlens ) ALLOCATE ( buco ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_bvco , dimlens ) ALLOCATE ( bvco ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_vp , dimlens ) ALLOCATE ( vp ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_specw , dimlens ) ALLOCATE ( specw ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_phip , dimlens ) ALLOCATE ( phip ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_overr , dimlens ) ALLOCATE ( overr ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_jdotb , dimlens ) ALLOCATE ( jdotb ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_bgrv , dimlens ) ALLOCATE ( bdotgradv ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_merc , dimlens ) ALLOCATE ( Dmerc ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_mshear , dimlens ) ALLOCATE ( Dshear ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_mwell , dimlens ) ALLOCATE ( Dwell ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_mcurr , dimlens ) ALLOCATE ( Dcurr ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_mgeo , dimlens ) ALLOCATE ( Dgeod ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_equif , dimlens ) ALLOCATE ( equif ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_fsq , dimlens ) ALLOCATE ( fsqt ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_wdot , dimlens ) ALLOCATE ( wdot ( dimlens ( 1 )), stat = ierror ) IF ( nextcur . gt . 0 ) THEN CALL cdf_inquire ( nwout , vn_extcur , dimlens ) ALLOCATE ( extcur ( dimlens ( 1 )), stat = ierror ) !NOTE: curlabel is an array of CHARACTER(30) strings - defined in mgrid_mod !      so dimlens(1) == 30 (check this) and dimlens(2) is the number of strings in the array CALL cdf_inquire ( nwout , vn_curlab , dimlens ) ALLOCATE ( curlabel ( dimlens ( 2 )), stat = ierror ) ENDIF ! ANIMEC/FLOW -SAL CALL cdf_inquire ( nwout , vn_pmap , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( pmap ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_omega , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( omega ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_tpotb , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( tpotb ( dimlens ( 1 )), stat = ierror ) ! 2D Arrays CALL cdf_inquire ( nwout , vn_rmnc , dimlens ) ALLOCATE ( rmnc ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_zmns , dimlens ) ALLOCATE ( zmns ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_lmns , dimlens ) ALLOCATE ( lmns ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_gmnc , dimlens ) ALLOCATE ( gmnc ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_bmnc , dimlens ) ALLOCATE ( bmnc ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_bsubumnc , dimlens ) ALLOCATE ( bsubumnc ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_bsubvmnc , dimlens ) ALLOCATE ( bsubvmnc ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_bsubsmns , dimlens ) ALLOCATE ( bsubsmns ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) !     ELIMINATE THESE EVENTUALLY: DON'T NEED THEM CALL cdf_inquire ( nwout , vn_bsupumnc , dimlens ) ALLOCATE ( bsupumnc ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_bsupvmnc , dimlens ) ALLOCATE ( bsupvmnc ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) ! ANIMEC/FLOW -SAL CALL cdf_inquire ( nwout , vn_pparmnc , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( pparmnc ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) CALL cdf_inquire ( nwout , vn_ppermnc , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( ppermnc ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) CALL cdf_inquire ( nwout , vn_hotdmnc , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( hotdmnc ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) CALL cdf_inquire ( nwout , vn_pbprmnc , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( pbprmnc ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) CALL cdf_inquire ( nwout , vn_ppprmnc , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( ppprmnc ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) CALL cdf_inquire ( nwout , vn_sigmnc , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( sigmnc ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) CALL cdf_inquire ( nwout , vn_taumnc , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( taumnc ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) CALL cdf_inquire ( nwout , vn_protmnc , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( protmnc ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) CALL cdf_inquire ( nwout , vn_protrsqmnc , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( protrsqmnc ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) CALL cdf_inquire ( nwout , vn_prprmnc , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( prprmnc ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) IF (. NOT . lasym ) GO TO 800 CALL cdf_inquire ( nwout , vn_rmns , dimlens ) ALLOCATE ( rmns ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_zmnc , dimlens ) ALLOCATE ( zmnc ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_lmnc , dimlens ) ALLOCATE ( lmnc ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_gmns , dimlens ) ALLOCATE ( gmns ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_bmns , dimlens ) ALLOCATE ( bmns ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_bsubumns , dimlens ) ALLOCATE ( bsubumns ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_bsubvmns , dimlens ) ALLOCATE ( bsubvmns ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_bsubsmnc , dimlens ) ALLOCATE ( bsubsmnc ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) !     ELIMINATE THESE EVENTUALLY: DO NOT NEED THEM CALL cdf_inquire ( nwout , vn_bsupumns , dimlens ) ALLOCATE ( bsupumns ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_bsupvmns , dimlens ) ALLOCATE ( bsupvmns ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) ! ANIMEC/FLOW -SAL CALL cdf_inquire ( nwout , vn_pparmns , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( pparmns ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) CALL cdf_inquire ( nwout , vn_ppermns , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( ppermns ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) CALL cdf_inquire ( nwout , vn_hotdmns , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( hotdmns ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) CALL cdf_inquire ( nwout , vn_pbprmns , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( pbprmns ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) CALL cdf_inquire ( nwout , vn_ppprmns , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( ppprmns ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) CALL cdf_inquire ( nwout , vn_sigmns , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( sigmns ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) CALL cdf_inquire ( nwout , vn_taumns , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( taumns ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) CALL cdf_inquire ( nwout , vn_protmns , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( protmns ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) CALL cdf_inquire ( nwout , vn_protrsqmns , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( protrsqmns ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) CALL cdf_inquire ( nwout , vn_prprmns , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( prprmns ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) 800 CONTINUE ! Read Arrays CALL cdf_read ( nwout , vn_pmod , xm ) CALL cdf_read ( nwout , vn_tmod , xn ) IF ( mnmax_nyq . le . 0 ) THEN mnmax_nyq = mnmax ALLOCATE ( xm_nyq ( mnmax_nyq ), xn_nyq ( mnmax_nyq ), stat = ierror ) xm_nyq = xm ; xn_nyq = xn ELSE CALL cdf_read ( nwout , vn_pmod_nyq , xm_nyq ) CALL cdf_read ( nwout , vn_tmod_nyq , xn_nyq ) END IF mnyq = INT ( MAXVAL ( xm_nyq )); nnyq = INT ( MAXVAL ( ABS ( xn_nyq ))) / nfp CALL cdf_read ( nwout , vn_racc , raxis_cc ) CALL cdf_read ( nwout , vn_zacs , zaxis_cs ) IF ( SIZE ( raxis_cc ) . ne . ntor + 1 ) 1 STOP 'WRONG SIZE(raxis_cc) in READ_WOUT_NC' ALLOCATE ( raxis ( 0 : ntor , 2 ), zaxis ( 0 : ntor , 2 ), stat = ierror ) raxis (:, 1 ) = raxis_cc ( 0 : ntor ); zaxis (:, 1 ) = zaxis_cs ( 0 : ntor ) raxis (:, 2 ) = 0 ; zaxis (:, 2 ) = 0 DEALLOCATE ( raxis_cc , zaxis_cs , stat = ierror ) CALL cdf_read ( nwout , vn_rmnc , rmnc ) CALL cdf_read ( nwout , vn_zmns , zmns ) CALL cdf_read ( nwout , vn_lmns , lmns ) CALL cdf_read ( nwout , vn_gmnc , gmnc ) !Half mesh CALL cdf_read ( nwout , vn_bmnc , bmnc ) !Half mesh CALL cdf_read ( nwout , vn_bsubumnc , bsubumnc ) !Half mesh CALL cdf_read ( nwout , vn_bsubvmnc , bsubvmnc ) !Half mesh CALL cdf_read ( nwout , vn_bsubsmns , bsubsmns ) !Full mesh !     ELIMINATE THESE EVENTUALLY: DON'T NEED THEM (can express in terms of lambdas) CALL cdf_read ( nwout , vn_bsupumnc , bsupumnc ) CALL cdf_read ( nwout , vn_bsupvmnc , bsupvmnc ) IF ( lasym ) THEN CALL cdf_read ( nwout , vn_racs , raxis_cs ) CALL cdf_read ( nwout , vn_zacc , zaxis_cc ) raxis (:, 2 ) = raxis_cs ; zaxis (:, 2 ) = zaxis_cc DEALLOCATE ( raxis_cs , zaxis_cc , stat = ierror ) CALL cdf_read ( nwout , vn_rmns , rmns ) CALL cdf_read ( nwout , vn_zmnc , zmnc ) CALL cdf_read ( nwout , vn_lmnc , lmnc ) CALL cdf_read ( nwout , vn_gmns , gmns ) CALL cdf_read ( nwout , vn_bmns , bmns ) CALL cdf_read ( nwout , vn_bsubumns , bsubumns ) CALL cdf_read ( nwout , vn_bsubvmns , bsubvmns ) CALL cdf_read ( nwout , vn_bsubsmnc , bsubsmnc ) !     ELIMINATE THESE EVENTUALLY: DON'T NEED THEM CALL cdf_read ( nwout , vn_bsupumns , bsupumns ) CALL cdf_read ( nwout , vn_bsupvmns , bsupvmns ) END IF ! ANIMEC/FLOW -SAL IF ( vmec_type == 1 ) THEN CALL cdf_read ( nwout , vn_pparmnc , pparmnc ) CALL cdf_read ( nwout , vn_ppermnc , ppermnc ) CALL cdf_read ( nwout , vn_hotdmnc , hotdmnc ) CALL cdf_read ( nwout , vn_pbprmnc , pbprmnc ) CALL cdf_read ( nwout , vn_ppprmnc , ppprmnc ) CALL cdf_read ( nwout , vn_sigmnc , sigmnc ) CALL cdf_read ( nwout , vn_taumnc , taumnc ) IF ( lasym ) THEN CALL cdf_read ( nwout , vn_pparmns , pparmns ) CALL cdf_read ( nwout , vn_ppermns , ppermns ) CALL cdf_read ( nwout , vn_hotdmns , hotdmns ) CALL cdf_read ( nwout , vn_pbprmns , pbprmns ) CALL cdf_read ( nwout , vn_ppprmns , ppprmns ) CALL cdf_read ( nwout , vn_sigmns , sigmns ) CALL cdf_read ( nwout , vn_taumns , taumns ) END IF ELSE IF ( vmec_type == 2 ) THEN CALL cdf_read ( nwout , vn_protmnc , protmnc ) CALL cdf_read ( nwout , vn_prprmnc , prprmnc ) CALL cdf_read ( nwout , vn_protrsqmnc , protrsqmnc ) IF ( lasym ) THEN CALL cdf_read ( nwout , vn_protmns , protmns ) CALL cdf_read ( nwout , vn_prprmns , prprmns ) CALL cdf_read ( nwout , vn_protrsqmns , protrsqmns ) END IF END IF CALL cdf_read ( nwout , vn_am , am ) CALL cdf_read ( nwout , vn_ac , ac ) CALL cdf_read ( nwout , vn_ai , ai ) CALL cdf_read ( nwout , vn_am_aux_s , am_aux_s ) CALL cdf_read ( nwout , vn_am_aux_f , am_aux_f ) CALL cdf_read ( nwout , vn_ac_aux_s , ac_aux_s ) CALL cdf_read ( nwout , vn_ac_aux_f , ac_aux_f ) CALL cdf_read ( nwout , vn_ai_aux_s , ai_aux_s ) CALL cdf_read ( nwout , vn_ai_aux_f , ai_aux_f ) CALL cdf_read ( nwout , vn_iotaf , iotaf ) CALL cdf_read ( nwout , vn_qfact , qfact ) CALL cdf_read ( nwout , vn_presf , presf ) CALL cdf_read ( nwout , vn_phi , phi ) CALL cdf_read ( nwout , vn_phipf , phipf ) CALL cdf_read ( nwout , vn_chi , chi ) CALL cdf_read ( nwout , vn_chipf , chipf ) CALL cdf_read ( nwout , vn_jcuru , jcuru ) CALL cdf_read ( nwout , vn_jcurv , jcurv ) IF ( vmec_type == 2 ) THEN CALL cdf_read ( nwout , vn_pmap , pmap ) CALL cdf_read ( nwout , vn_omega , omega ) CALL cdf_read ( nwout , vn_tpotb , tpotb ) END IF !     HALF-MESH quantities !     NOTE: jdotb is in units_of_A (1/mu0 incorporated in jxbforce...) !     prior to version 6.00, this was output in internal VMEC units... CALL cdf_read ( nwout , vn_iotah , iotas ) CALL cdf_read ( nwout , vn_mass , mass ) CALL cdf_read ( nwout , vn_presh , pres ) CALL cdf_read ( nwout , vn_betah , beta_vol ) CALL cdf_read ( nwout , vn_buco , buco ) CALL cdf_read ( nwout , vn_bvco , bvco ) CALL cdf_read ( nwout , vn_vp , vp ) CALL cdf_read ( nwout , vn_specw , specw ) CALL cdf_read ( nwout , vn_phip , phip ) CALL cdf_read ( nwout , vn_jdotb , jdotb ) CALL cdf_read ( nwout , vn_bgrv , bdotgradv ) !     MERCIER_CRITERION CALL cdf_read ( nwout , vn_merc , Dmerc ) CALL cdf_read ( nwout , vn_mshear , Dshear ) CALL cdf_read ( nwout , vn_mwell , Dwell ) CALL cdf_read ( nwout , vn_mcurr , Dcurr ) CALL cdf_read ( nwout , vn_mgeo , Dgeod ) CALL cdf_read ( nwout , vn_equif , equif ) CALL cdf_read ( nwout , vn_fsq , fsqt ) CALL cdf_read ( nwout , vn_wdot , wdot ) IF ( nextcur . gt . 0 ) THEN CALL cdf_read ( nwout , vn_extcur , extcur ) CALL cdf_read ( nwout , vn_curlab , curlabel ) ENDIF 1000 CONTINUE CALL cdf_close ( nwout , ierr ) IF (. not . ALLOCATED ( bsubumnc )) RETURN !Moved this here because ns may not be set. SAL -09/07/11 ! !     COMPUTE CONTRAVARIANT CURRENT COMPONENTS IN AMPS !     ON THE FULL RADIAL MESH, WHERE JACOBIAN = SQRT(G) ! !     CURRU = SQRT(G) * J dot grad(u) !     CURRV = SQRT(G) * J dot grad(v) ! ohs = ( ns - 1 ) IF ( ierror . eq . 0 ) CALL Compute_Currents ( ierror ) IF ( ierr . ne . 0 ) PRINT * , \"in read_wout_nc ierr=\" , ierr IF ( ierror . ne . 0 ) PRINT * , \"in read_wout_nc ierror=\" , ierror END SUBROUTINE read_wout_nc #endif SUBROUTINE write_wout_text ( filename , ierr ) USE v3_utilities USE vsvd0 , ONLY : nparts USE safe_open_mod USE stel_constants , ONLY : mu0 IMPLICIT NONE !------------------------------------------------ !   D u m m y   A r g u m e n t s !------------------------------------------------ CHARACTER ( len =* ) :: filename INTEGER , INTENT ( out ) :: ierr !------------------------------------------------ !   L o c a l   P a r a m e t e r s !------------------------------------------------ REAL ( rprec ), PARAMETER :: eps_w = 1.e-4_dp !------------------------------------------------ !   L o c a l   V a r i a b l e s !------------------------------------------------ INTEGER :: iounit , js , mn , i , j , k , m , n , iasymm LOGICAL :: lcurr !------------------------------------------------ ! !     THIS SUBROUTINE WRITES A TEXT FILE WOUT CREATED BY STORED THE INFORMATION !     IN THE read_WOUT MODULE. This routine can only be called if the wout has !     already been read in. iounit = 0 ierr = 0 CALL safe_open ( iounit , ierr , & & 'wout_' // TRIM ( filename ) // '.txt' , & & 'replace' , 'formatted' ) CALL assert_eq ( 0 , ierr , 'Error opening text wout file in ' // & & 'write_wout_text of read_wout_mod.' ) !  Write version info WRITE ( iounit , '(a15,f5.2)' ) 'VMEC VERSION = ' , version_ !  Check version numbers since values change. IF ( lasym ) THEN iasymm = 1 ELSE iasym = 0 END IF IF ( version_ . le . ( 5.10 + eps_w )) THEN WRITE ( iounit , * ) wb , wp , gamma , pfac , nfp , ns , mpol , ntor , & & mnmax , itfsq , niter , iasymm , ireconstruct ELSE IF ( version_ . lt . 6.54 ) THEN WRITE ( iounit , * ) wb , wp , gamma , pfac , rmax_surf , rmin_surf ELSE WRITE ( iounit , * ) wb , wp , gamma , pfac , rmax_surf , rmin_surf , & & zmax_surf END IF IF ( version_ . le . ( 8.0 + eps_w )) THEN WRITE ( iounit , * ) nfp , ns , mpol , ntor , mnmax , itfsq , niter , & & iasym , ireconstruct , ierr_vmec ELSE WRITE ( iounit , * ) nfp , ns , mpol , ntor , mnmax , mnmax_nyq , & & itfsq , niter , iasym , ireconstruct , & & ierr_vmec END IF END IF IF ( version_ . gt . ( 6.20 + eps_w )) THEN WRITE ( iounit , * ) imse , itse , nbsets , nobd , nextcur , nstore_seq ELSE WRITE ( iounit , * ) imse , itse , nbsets , nobd , nextcur END IF IF ( ierr_vmec . ne . norm_term_flag . and . & & ierr_vmec . ne . more_iter_flag ) THEN GOTO 1000 END IF IF ( nbsets . gt . 0 ) THEN WRITE ( iounit , * ) nbfld ( 1 : nbsets ) END IF WRITE ( iounit , * ) TRIM ( mgrid_file ) DO js = 1 , ns DO mn = 1 , mnmax IF ( js . eq . 1 ) THEN WRITE ( iounit , * ) NINT ( xm ( mn )), NINT ( xn ( mn ) / nfp ) END IF IF ( version_ . le . ( 6.20 + eps_w )) THEN WRITE ( iounit , 730 ) rmnc ( mn , js ), zmns ( mn , js ), & & lmns ( mn , js ), bmnc ( mn , js ), & & gmnc ( mn , js ), bsubumnc ( mn , js ), & & bsubvmnc ( mn , js ), bsubsmns ( mn , js ), & & bsupumnc ( mn , js ), bsupvmnc ( mn , js ), & & currvmnc ( mn , js ) ELSE IF ( version_ . le . ( 8.0 + eps_w )) THEN WRITE ( iounit , * ) rmnc ( mn , js ), zmns ( mn , js ), lmns ( mn , js ), & & bmnc ( mn , js ), gmnc ( mn , js ), & & bsubumnc ( mn , js ), bsubvmnc ( mn , js ), & & bsubsmns ( mn , js ), bsupumnc ( mn , js ), & & bsupvmnc ( mn , js ), currvmnc ( mn , js ) ELSE WRITE ( iounit , * ) rmnc ( mn , js ), zmns ( mn , js ), lmns ( mn , js ) END IF !  Write asymmetric components. IF ( lasym ) THEN IF ( version_ . le . ( 8.0 + eps_w )) THEN WRITE ( iounit , * ) rmns ( mn , js ), zmnc ( mn , js ), & & lmnc ( mn , js ), bmns ( mn , js ), & & gmns ( mn , js ), bsubumns ( mn , js ), & & bsubvmns ( mn , js ), bsubsmnc ( mn , js ), & & bsupumns ( mn , js ), bsubvmns ( mn , js ) ELSE WRITE ( iounit , * ) rmns ( mn , js ), zmnc ( mn , js ), & & lmnc ( mn , js ) END IF END IF END DO IF ( version_ . le . ( 8.0 + eps_w )) THEN CYCLE END IF DO mn = 1 , mnmax_nyq IF ( js . eq . 1 ) THEN WRITE ( iounit , * ) NINT ( xm_nyq ( mn )), & & NINT ( xn_nyq ( mn ) / nfp ) END IF WRITE ( iounit , * ) bmnc ( mn , js ), gmnc ( mn , js ), & & bsubumnc ( mn , js ), bsubvmnc ( mn , js ), & & bsubsmns ( mn , js ), bsupumnc ( mn , js ), & & bsupvmnc ( mn , js ) IF ( lasym ) THEN WRITE ( iounit , * ) bmns ( mn , js ), gmns ( mn , js ), & & bsubumns ( mn , js ), bsubvmns ( mn , js ), & & bsubsmnc ( mn , js ), bsupumns ( mn , js ), & & bsupvmns ( mn , js ) END IF END DO END DO ! !     Write FULL AND HALF-MESH QUANTITIES ! !     NOTE: In version_ <= 6.00, mass, press were written out in INTERNAL (VMEC) units !     and are therefore multiplied here by 1/mu0 to transform to pascals. Same is true !     for ALL the currents (jcuru, jcurv, jdotb). Also, in version_ = 6.10 and !     above, PHI is the true (physical) toroidal flux (has the sign of jacobian correctly !     built into it) ! IF ( version_ . le . ( 6.05 + eps_w )) THEN WRITE ( iounit , 730 ) ( iotas ( js ), mass ( js ) * mu0 , pres ( js ) * mu0 , & & phip ( js ), buco ( js ), bvco ( js ), - phi ( js ), & & vp ( js ), overr ( js ), jcuru ( js ) * mu0 , & & jcurv ( js ) * mu0 , specw ( js ), js = 2 , ns ) WRITE ( iounit , 730 ) aspect , betatot , betapol , betaxis , b0 ELSE IF ( version_ . le . ( 6.20 + eps_w )) THEN WRITE ( iounit , 730 ) ( iotas ( js ), mass ( js ), pres ( js ), & & beta_vol ( js ), phip ( js ), buco ( js ), & & bvco ( js ), phi ( js ), vp ( js ), overr ( js ), & & jcuru ( js ), jcurv ( js ), specw ( js ), & & js = 2 , ns ) WRITE ( iounit , 730 ) aspect , betatot , betapol , betaxis , b0 ELSE IF ( version_ . le . ( 6.95 + eps_w )) THEN WRITE ( iounit , * ) ( iotas ( js ), mass ( js ), pres ( js ), & & beta_vol ( js ), phip ( js ), buco ( js ), & & bvco ( js ), phi ( js ), vp ( js ), overr ( js ), & & jcuru ( js ), jcurv ( js ), specw ( js ), & & js = 2 , ns ) WRITE ( iounit , * ) aspect , betatot , betapol , betaxis , b0 ELSE WRITE ( iounit , * ) ( iotaf ( js ), presf ( js ), phipf ( js ), phi ( js ), & & jcuru ( js ), jcurv ( js ), js = 1 , ns ) WRITE ( iounit , * ) ( iotas ( js ), mass ( js ), pres ( js ), & & beta_vol ( js ), phip ( js ), buco ( js ), & & bvco ( js ), vp ( js ), overr ( js ), specw ( js ), & & js = 2 , ns ) WRITE ( iounit , * ) aspect , betatot , betapol , betaxis , b0 END IF IF ( version_ . gt . ( 6.10 + eps_w )) THEN WRITE ( iounit , * ) isigng WRITE ( iounit , * ) TRIM ( input_extension ) WRITE ( iounit , * ) IonLarmor , VolAvgB , RBtor0 , RBtor , Itor , & & Aminor , Rmajor , Volume END IF !----------------------------------------------- !     MERCIER CRITERION !----------------------------------------------- IF ( version_ . gt . ( 5.10 + eps_w ) . and . & & version_ . lt . ( 6.20 - eps_w )) THEN WRITE ( iounit , 730 ) ( Dmerc ( js ), Dshear ( js ), Dwell ( js ), & & Dcurr ( js ), Dgeod ( js ), equif ( js ), & & js = 2 , ns - 1 ) ELSE IF ( version_ . ge . ( 6.20 - eps_w )) THEN WRITE ( iounit , * ) ( Dmerc ( js ), Dshear ( js ), Dwell ( js ), & & Dcurr ( js ), Dgeod ( js ), equif ( js ), & & js = 2 , ns - 1 ) END IF IF ( nextcur . gt . 0 ) THEN IF ( version_ . le . ( 6.20 + eps_w )) THEN WRITE ( iounit , 730 ) ( extcur ( js ), js = 1 , nextcur ) ELSE WRITE ( iounit , * ) ( extcur ( js ), js = 1 , nextcur ) END IF lcurr = LEN_TRIM ( curlabel ( 1 )) . gt . 0 WRITE ( iounit , * ) lcurr IF ( lcurr ) THEN WRITE ( iounit , * ) ( TRIM ( curlabel ( js )), js = 1 , nextcur ) END IF END IF IF ( version_ . le . ( 6.20 + eps_w )) THEN WRITE ( iounit , 730 ) ( fsqt ( js ), wdot ( js ), js = 1 , nstore_seq ) ELSE WRITE ( iounit , * ) ( fsqt ( js ), wdot ( js ), js = 1 , nstore_seq ) END IF IF ( version_ . ge . ( 6.20 - eps_w ) . and . & & version_ . lt . ( 6.50 - eps_w )) THEN WRITE ( iounit , 730 ) ( jdotb ( js ), bdotgradv ( js ), js = 1 , ns ) ELSE IF ( version_ . ge . ( 6.50 - eps_w )) THEN WRITE ( iounit , * ) ( jdotb ( js ), bdotgradv ( js ), js = 1 , ns ) END IF !----------------------------------------------- !     DATA AND MSE FITS !----------------------------------------------- IF ( ireconstruct . gt . 0 ) THEN IF ( imse . ge . 2 . or . itse . gt . 0 ) THEN WRITE ( iounit , * ) tswgt , msewgt WRITE ( iounit , * ) isnodes , ( sknots ( js ), ystark ( js ), & & y2stark ( js ), js = 1 , isnodes ) WRITE ( iounit , * ) ipnodes , ( pknots ( js ), ythom ( js ), & & y2thom ( js ), js = 1 , ipnodes ) WRITE ( iounit , * ) ( anglemse ( js ), rmid ( js ), qmid ( js ), & & shear ( js ), presmid ( js ), alfa ( js ), & & curmid ( js ), js = 1 , 2 * ns - 1 ) WRITE ( iounit , * ) ( rstark ( js ), datastark ( js ), qmeas ( js ), & & js = 1 , imse ) WRITE ( iounit , * ) ( rthom ( js ), datathom ( i ), js = 1 , itse ) END IF IF ( nobd . gt . 0 ) THEN WRITE ( iounit , * ) ( dsiext ( js ), plflux ( js ), dsiobt ( js ), & & js = 1 , nobd ) WRITE ( iounit , * ) flmwgt END IF IF ( nbfldn . gt . 0 ) THEN DO n = 1 , nbsets READ ( iounit , * ) ( bcoil ( i , n ), plbfld ( i , n ), bbc ( i , n ), & & i = 1 , nbfld ( n )) END DO WRITE ( iounit , * ) bcwgt END IF WRITE ( iounit , * ) phidiam , delphid ! !     READ Limiter & Prout plotting specs ! WRITE ( iounit , * ) nsets , nparts , nlim WRITE ( iounit , * ) ( nsetsn ( js ), js = 1 , nsets ) WRITE ( iounit , * ) ((( pfcspec ( i , j , k ), i = 1 , nparts ), & & j = 1 , nsetsn ( k )), k = 1 , nsets ) WRITE ( iounit , * ) ( limitr ( i ), i = 1 , nlim ) WRITE ( iounit , * ) (( rlim ( i , j ), zlim ( i , j ), i = 1 , limitr ( j )), & & j = 1 , nlim ) WRITE ( iounit , * ) nrgrid , nzgrid WRITE ( iounit , * ) tokid WRITE ( iounit , * ) rx1 , rx2 , zy1 , zy2 , condif WRITE ( iounit , * ) imatch_phiedge END IF 1000 CONTINUE WRITE ( iounit , * ) mgrid_mode 730 FORMAT ( 5e20 . 13 ) CLOSE ( iounit , iostat = ierr ) CALL assert_eq ( 0 , ierr , 'Error closing text wout file in ' // & & 'write_wout_text of read_wout_mod.' ) END SUBROUTINE SUBROUTINE Compute_Currents ( ierror ) USE stel_constants , ONLY : mu0 IMPLICIT NONE INTEGER , INTENT ( out ) :: ierror !----------------------------------------------- !   L o c a l   V a r i a b l e s !----------------------------------------------- INTEGER :: js REAL ( rprec ) :: ohs , hs , shalf ( ns ), sfull ( ns ) REAL ( rprec ), DIMENSION ( mnmax_nyq ) :: bu1 , bu0 , bv1 , bv0 , t1 , t2 , & t3 !----------------------------------------------- ! !     Computes current harmonics for currXmn == sqrt(g)*JsupX, X = u,v !     [Corrected above \"JsubX\" to \"JsupX\", JDH 2010-08-16] !     NOTE: bsub(s,u,v)mn are on HALF radial grid !          (in earlier versions, bsubsmn was on FULL radial grid) ! ohs = ( ns - 1 ) hs = 1._dp / ohs DO js = 2 , ns shalf ( js ) = SQRT ( hs * ( js - 1.5_dp )) sfull ( js ) = SQRT ( hs * ( js - 1 )) END DO ALLOCATE ( currumnc ( mnmax_nyq , ns ), currvmnc ( mnmax_nyq , ns ), & & stat = ierror ) IF ( ierror . ne . 0 ) RETURN DO js = 2 , ns - 1 WHERE ( MOD ( INT ( xm_nyq ), 2 ) . EQ . 1 ) t1 = 0.5_dp * ( shalf ( js + 1 ) * bsubsmns (:, js + 1 ) + & & shalf ( js ) * bsubsmns (:, js )) / sfull ( js ) bu0 = bsubumnc (:, js ) / shalf ( js ) bu1 = bsubumnc (:, js + 1 ) / shalf ( js + 1 ) t2 = ohs * ( bu1 - bu0 ) * sfull ( js ) + 0.25_dp * ( bu0 + bu1 ) / sfull ( js ) bv0 = bsubvmnc (:, js ) / shalf ( js ) bv1 = bsubvmnc (:, js + 1 ) / shalf ( js + 1 ) t3 = ohs * ( bv1 - bv0 ) * sfull ( js ) + 0.25_dp * ( bv0 + bv1 ) / sfull ( js ) ELSEWHERE t1 = 0.5_dp * ( bsubsmns (:, js + 1 ) + bsubsmns (:, js )) t2 = ohs * ( bsubumnc (:, js + 1 ) - bsubumnc (:, js )) t3 = ohs * ( bsubvmnc (:, js + 1 ) - bsubvmnc (:, js )) ENDWHERE currumnc (:, js ) = - xn_nyq (:) * t1 - t3 currvmnc (:, js ) = - xm_nyq (:) * t1 + t2 END DO WHERE ( xm_nyq . LE . 1 ) currvmnc (:, 1 ) = 2 * currvmnc (:, 2 ) - currvmnc (:, 3 ) currumnc (:, 1 ) = 2 * currumnc (:, 2 ) - currumnc (:, 3 ) ELSEWHERE currvmnc (:, 1 ) = 0 currumnc (:, 1 ) = 0 ENDWHERE currumnc (:, ns ) = 2 * currumnc (:, ns - 1 ) - currumnc (:, ns - 2 ) currvmnc (:, ns ) = 2 * currvmnc (:, ns - 1 ) - currvmnc (:, ns - 2 ) currumnc = currumnc / mu0 ; currvmnc = currvmnc / mu0 IF (. NOT . lasym ) RETURN ALLOCATE ( currumns ( mnmax_nyq , ns ), currvmns ( mnmax_nyq , ns ), & & stat = ierror ) DO js = 2 , ns - 1 WHERE ( MOD ( INT ( xm_nyq ), 2 ) . EQ . 1 ) t1 = 0.5_dp * ( shalf ( js + 1 ) * bsubsmnc (:, js + 1 ) & & + shalf ( js ) * bsubsmnc (:, js )) / sfull ( js ) bu0 = bsubumns (:, js ) / shalf ( js + 1 ) bu1 = bsubumns (:, js + 1 ) / shalf ( js + 1 ) t2 = ohs * ( bu1 - bu0 ) * sfull ( js ) + 0.25_dp * ( bu0 + bu1 ) / sfull ( js ) bv0 = bsubvmns (:, js ) / shalf ( js ) bv1 = bsubvmns (:, js + 1 ) / shalf ( js + 1 ) t3 = ohs * ( bv1 - bv0 ) * sfull ( js ) + 0.25_dp * ( bv0 + bv1 ) / sfull ( js ) ELSEWHERE t1 = 0.5_dp * ( bsubsmnc (:, js + 1 ) + bsubsmnc (:, js )) t2 = ohs * ( bsubumns (:, js + 1 ) - bsubumns (:, js )) t3 = ohs * ( bsubvmns (:, js + 1 ) - bsubvmns (:, js )) END WHERE currumns (:, js ) = xn_nyq (:) * t1 - t3 currvmns (:, js ) = xm_nyq (:) * t1 + t2 END DO WHERE ( xm_nyq . LE . 1 ) currvmns (:, 1 ) = 2 * currvmns (:, 2 ) - currvmns (:, 3 ) currumns (:, 1 ) = 2 * currumns (:, 2 ) - currumns (:, 3 ) ELSEWHERE currvmns (:, 1 ) = 0 currumns (:, 1 ) = 0 END WHERE currumns (:, ns ) = 2 * currumns (:, ns - 1 ) - currumns (:, ns - 2 ) currvmns (:, ns ) = 2 * currvmns (:, ns - 1 ) - currvmns (:, ns - 2 ) currumns = currumns / mu0 ; currvmns = currvmns / mu0 END SUBROUTINE Compute_Currents SUBROUTINE read_wout_deallocate IMPLICIT NONE !----------------------------------------------- !   L o c a l   V a r i a b l e s !----------------------------------------------- INTEGER :: istat ( 10 ) !----------------------------------------------- istat = 0 lwout_opened = . false . IF ( ALLOCATED ( extcur )) DEALLOCATE ( extcur , 1 stat = istat ( 1 )) IF ( ALLOCATED ( curlabel )) DEALLOCATE ( curlabel , 1 stat = istat ( 1 )) IF ( ALLOCATED ( overr )) DEALLOCATE ( overr , stat = istat ( 2 )) IF ( ALLOCATED ( xm )) DEALLOCATE ( xm , xn , xm_nyq , xn_nyq , 1 rmnc , zmns , lmns , bmnc , gmnc , bsubumnc , iotaf , presf , phipf , 2 bsubvmnc , bsubsmns , bsupumnc , bsupvmnc , currvmnc , iotas , mass , 3 pres , beta_vol , phip , buco , bvco , phi , vp , jcuru , am , ac , ai , 4 jcurv , specw , Dmerc , Dshear , Dwell , Dcurr , Dgeod , equif , jdotb , 5 bdotgradv , raxis , zaxis , fsqt , wdot , stat = istat ( 3 )) IF ( ALLOCATED ( chipf )) DEALLOCATE ( chipf , chi ) IF ( ALLOCATED ( am_aux_s )) DEALLOCATE ( am_aux_s , am_aux_f , ac_aux_s , 1 ac_aux_f , ai_aux_s , ai_aux_f , stat = istat ( 6 )) IF ( ireconstruct . gt . 0 . and . ALLOCATED ( sknots )) DEALLOCATE ( 1 ystark , y2stark , pknots , anglemse , rmid , qmid , shear , 2 presmid , alfa , curmid , rstark , datastark , rthom , datathom , 3 ythom , y2thom , plflux , dsiobt , bcoil , plbfld , bbc , sknots , 4 pfcspec , limitr , rlim , zlim , nsetsn , stat = istat ( 4 )) IF ( ALLOCATED ( rmns )) DEALLOCATE ( rmns , zmnc , lmnc , 1 bmns , gmns , bsubumns , bsubvmns , bsubsmnc , 2 bsupumns , bsupvmns , stat = istat ( 5 )) IF ( ALLOCATED ( currumnc )) DEALLOCATE ( currumnc ) IF ( ALLOCATED ( currumns )) DEALLOCATE ( currumns , currvmns ) IF ( ALLOCATED ( rzl_local )) DEALLOCATE ( rzl_local ) ! FLOW/ANIMEC additions IF ( ALLOCATED ( pmap )) DEALLOCATE ( pmap , omega , tpotb ) IF ( ALLOCATED ( pparmnc )) DEALLOCATE ( pparmnc , ppermnc , hotdmnc , 1 pbprmnc , ppprmnc , sigmnc , taumnc ) IF ( ALLOCATED ( pparmns )) DEALLOCATE ( pparmns , ppermns , hotdmns , 1 pbprmns , ppprmns , sigmns , taumns ) IF ( ALLOCATED ( protmnc )) DEALLOCATE ( protmnc , protrsqmnc , prprmnc ) IF ( ALLOCATED ( protmns )) DEALLOCATE ( protmns , protrsqmns , prprmns ) IF ( ANY ( istat . ne . 0 )) THEN PRINT * , istat STOP 'Deallocation error in read_wout_deallocate' END IF END SUBROUTINE read_wout_deallocate SUBROUTINE tosuvspace ( s_in , u_in , v_in , gsqrt , 1 bsupu , bsupv , jsupu , jsupv , lam ) USE stel_constants , ONLY : zero , one IMPLICIT NONE C----------------------------------------------- C   D u m m y   A r g u m e n t s C----------------------------------------------- REAL ( rprec ), INTENT ( in ) :: s_in , u_in , v_in REAL ( rprec ), INTENT ( out ), OPTIONAL :: gsqrt , bsupu , bsupv , 1 jsupu , jsupv , lam C----------------------------------------------- C   L o c a l   V a r i a b l e s C----------------------------------------------- REAL ( rprec ), PARAMETER :: c1p5 = 1.5_dp INTEGER :: m , n , n1 , mn , ipresent , jslo , jshi REAL ( rprec ) :: hs1 , wlo , whi , wlo_odd , whi_odd REAL ( rprec ), DIMENSION ( mnmax_nyq ) :: gmnc1 , gmns1 , bsupumnc1 , 1 bsupumns1 , bsupvmnc1 , bsupvmns1 , jsupumnc1 , jsupumns1 , 2 jsupvmnc1 , jsupvmns1 , wmins , wplus , lammns1 , lammnc1 REAL ( rprec ) :: cosu , sinu , cosv , sinv , tcosmn , tsinmn , sgn REAL ( rprec ) :: cosmu ( 0 : mnyq ), sinmu ( 0 : mnyq ), 1 cosnv ( 0 : nnyq ), sinnv ( 0 : nnyq ) LOGICAL :: lgsqrt , lbsupu , lbsupv , ljsupu , ljsupv , llam C----------------------------------------------- ! !     COMPUTE VARIOUS HALF/FULL-RADIAL GRID QUANTITIES AT THE INPUT POINT !     (S, U, V) , WHERE !        S = normalized toroidal flux (0 - 1), !        U = poloidal angle !        V = N*phi = toroidal angle * no. field periods ! !     HALF-RADIAL GRID QUANTITIES !     gsqrt, bsupu, bsupv ! !     FULL-RADIAL GRID QUANTITIES !     dbsubuds, dbsubvds, dbsubsdu, dbsubsdv ! C----------------------------------------------- IF ( s_in . lt . zero . or . s_in . gt . one ) THEN WRITE ( 6 , * ) 1 ' In tosuvspace, s(flux) must be between 0 and 1' RETURN END IF IF (. not . lwout_opened ) THEN WRITE ( 6 , * ) 1 ' tosuvspace can only be called AFTER opening wout file!' RETURN END IF ! !     SETUP TRIG ARRAYS ! cosu = COS ( u_in ); sinu = SIN ( u_in ) cosv = COS ( v_in ); sinv = SIN ( v_in ) cosmu ( 0 ) = 1 ; sinmu ( 0 ) = 0 cosnv ( 0 ) = 1 ; sinnv ( 0 ) = 0 DO m = 1 , mnyq cosmu ( m ) = cosmu ( m - 1 ) * cosu - sinmu ( m - 1 ) * sinu sinmu ( m ) = sinmu ( m - 1 ) * cosu + cosmu ( m - 1 ) * sinu END DO DO n = 1 , nnyq cosnv ( n ) = cosnv ( n - 1 ) * cosv - sinnv ( n - 1 ) * sinv sinnv ( n ) = sinnv ( n - 1 ) * cosv + cosnv ( n - 1 ) * sinv END DO ! !     FIND INTERPOLATED s VALUE AND COMPUTE INTERPOLATION WEIGHTS wlo, whi !     RECALL THAT THESE QUANTITIES ARE ON THE HALF-RADIAL GRID... !     s-half(j) = (j-1.5)*hs, for j = 2,...ns ! hs1 = one / ( ns - 1 ) jslo = INT ( c1p5 + s_in / hs1 ) jshi = jslo + 1 wlo = ( hs1 * ( jshi - c1p5 ) - s_in ) / hs1 whi = 1 - wlo IF ( jslo . eq . ns ) THEN !        USE Xhalf(ns+1) = 2*Xhalf(ns) - Xhalf(ns-1) FOR \"GHOST\" POINT VALUE 1/2hs OUTSIDE EDGE !        THEN, X = wlo*Xhalf(ns) + whi*Xhalf(ns+1) == Xhalf(ns) + whi*(Xhalf(ns) - Xhalf(ns-1)) jshi = jslo - 1 wlo = 1 + whi ; whi = - whi ELSE IF ( jslo . eq . 1 ) THEN jslo = 2 END IF ! !     FOR ODD-m MODES X ~ SQRT(s), SO INTERPOLATE Xmn/SQRT(s) ! whi_odd = whi * SQRT ( s_in / ( hs1 * ( jshi - c1p5 ))) IF ( jslo . ne . 1 ) THEN wlo_odd = wlo * SQRT ( s_in / ( hs1 * ( jslo - c1p5 ))) ELSE wlo_odd = 0 whi_odd = SQRT ( s_in / ( hs1 * ( jshi - c1p5 ))) END IF WHERE ( MOD ( NINT ( xm_nyq (:)), 2 ) . eq . 0 ) wmins = wlo wplus = whi ELSEWHERE wmins = wlo_odd wplus = whi_odd END WHERE ipresent = 0 lgsqrt = PRESENT ( gsqrt ) IF ( lgsqrt ) THEN gsqrt = 0 ; ipresent = ipresent + 1 gmnc1 = wmins * gmnc (:, jslo ) + wplus * gmnc (:, jshi ) IF ( lasym ) 1 gmns1 = wmins * gmns (:, jslo ) + wplus * gmns (:, jshi ) END IF lbsupu = PRESENT ( bsupu ) IF ( lbsupu ) THEN bsupu = 0 ; ipresent = ipresent + 1 bsupumnc1 = wmins * bsupumnc (:, jslo ) + wplus * bsupumnc (:, jshi ) IF ( lasym ) 1 bsupumns1 = wmins * bsupumns (:, jslo ) + wplus * bsupumns (:, jshi ) END IF lbsupv = PRESENT ( bsupv ) IF ( lbsupv ) THEN bsupv = 0 ; ipresent = ipresent + 1 bsupvmnc1 = wmins * bsupvmnc (:, jslo ) + wplus * bsupvmnc (:, jshi ) IF ( lasym ) 1 bsupvmns1 = wmins * bsupvmns (:, jslo ) + wplus * bsupvmns (:, jshi ) END IF llam = PRESENT ( lam ) IF ( llam ) THEN lam = 0 ; ipresent = ipresent + 1 lammns1 = wmins * lmns (:, jslo ) + wplus * lmns (:, jshi ) IF ( lasym ) 1 lammnc1 = wmins * lmnc (:, jslo ) + wplus * lmnc (:, jshi ) END IF IF ( ipresent . eq . 0 ) GOTO 1000 ! !     COMPUTE GSQRT, ... IN REAL SPACE !     tcosmn = cos(mu - nv);  tsinmn = sin(mu - nv) ! DO mn = 1 , mnmax_nyq m = NINT ( xm_nyq ( mn )); n = NINT ( xn_nyq ( mn )) / nfp n1 = ABS ( n ); sgn = SIGN ( 1 , n ) tcosmn = cosmu ( m ) * cosnv ( n1 ) + sgn * sinmu ( m ) * sinnv ( n1 ) tsinmn = sinmu ( m ) * cosnv ( n1 ) - sgn * cosmu ( m ) * sinnv ( n1 ) IF ( lgsqrt ) gsqrt = gsqrt + gmnc1 ( mn ) * tcosmn IF ( lbsupu ) bsupu = bsupu + bsupumnc1 ( mn ) * tcosmn IF ( lbsupv ) bsupv = bsupv + bsupvmnc1 ( mn ) * tcosmn IF ( llam ) lam = lam + lammns1 ( mn ) * tsinmn END DO IF (. not . lasym ) GOTO 1000 DO mn = 1 , mnmax_nyq m = NINT ( xm_nyq ( mn )); n = NINT ( xn_nyq ( mn )) / nfp n1 = ABS ( n ); sgn = SIGN ( 1 , n ) tcosmn = cosmu ( m ) * cosnv ( n1 ) + sgn * sinmu ( m ) * sinnv ( n1 ) tsinmn = sinmu ( m ) * cosnv ( n1 ) - sgn * cosmu ( m ) * sinnv ( n1 ) IF ( lgsqrt ) gsqrt = gsqrt + gmns1 ( mn ) * tsinmn IF ( lbsupu ) bsupu = bsupu + bsupumns1 ( mn ) * tsinmn IF ( lbsupv ) bsupv = bsupv + bsupvmns1 ( mn ) * tsinmn IF ( llam ) lam = lam + lammnc1 ( mn ) * tcosmn END DO 1000 CONTINUE !     FULL-MESH QUANTITIES ! !     FIND INTERPOLATED s VALUE AND COMPUTE INTERPOLATION WEIGHTS wlo, whi !     RECALL THAT THESE QUANTITIES ARE ON THE FULL-RADIAL GRID... !     s-full(j) = (j-1)*hs, for j = 1,...ns ! hs1 = one / ( ns - 1 ) jslo = 1 + INT ( s_in / hs1 ) jshi = jslo + 1 IF ( jslo . eq . ns ) jshi = ns wlo = ( hs1 * ( jshi - 1 ) - s_in ) / hs1 whi = 1 - wlo ! !     FOR ODD-m MODES X ~ SQRT(s), SO INTERPOLATE Xmn/SQRT(s) ! whi_odd = whi * SQRT ( s_in / ( hs1 * ( jshi - 1 ))) IF ( jslo . ne . 1 ) THEN wlo_odd = wlo * SQRT ( s_in / ( hs1 * ( jslo - 1 ))) ELSE wlo_odd = 0 whi_odd = SQRT ( s_in / ( hs1 * ( jshi - 1 ))) END IF WHERE ( MOD ( NINT ( xm_nyq (:)), 2 ) . eq . 0 ) wmins = wlo wplus = whi ELSEWHERE wmins = wlo_odd wplus = whi_odd END WHERE ipresent = 0 ljsupu = PRESENT ( jsupu ) IF ( ljsupu ) THEN IF (. not . lgsqrt ) STOP 'MUST compute gsqrt for jsupu' jsupu = 0 ; ipresent = ipresent + 1 jsupumnc1 = wmins * currumnc (:, jslo ) + wplus * currumnc (:, jshi ) IF ( lasym ) 1 jsupumns1 = wmins * currumns (:, jslo ) + wplus * currumns (:, jshi ) END IF ljsupv = PRESENT ( jsupv ) IF ( ljsupv ) THEN IF (. not . lgsqrt ) STOP 'MUST compute gsqrt for jsupv' jsupv = 0 ; ipresent = ipresent + 1 jsupvmnc1 = wmins * currvmnc (:, jslo ) + wplus * currvmnc (:, jshi ) IF ( lasym ) 1 jsupvmns1 = wmins * currvmns (:, jslo ) + wplus * currvmns (:, jshi ) END IF IF ( ipresent . eq . 0 ) RETURN DO mn = 1 , mnmax_nyq m = NINT ( xm_nyq ( mn )); n = NINT ( xn_nyq ( mn )) / nfp n1 = ABS ( n ); sgn = SIGN ( 1 , n ) tcosmn = cosmu ( m ) * cosnv ( n1 ) + sgn * sinmu ( m ) * sinnv ( n1 ) IF ( ljsupu ) jsupu = jsupu + jsupumnc1 ( mn ) * tcosmn IF ( ljsupv ) jsupv = jsupv + jsupvmnc1 ( mn ) * tcosmn END DO IF (. not . lasym ) GOTO 2000 DO mn = 1 , mnmax_nyq m = NINT ( xm_nyq ( mn )); n = NINT ( xn_nyq ( mn )) / nfp n1 = ABS ( n ); sgn = SIGN ( 1 , n ) tsinmn = sinmu ( m ) * cosnv ( n1 ) - sgn * cosmu ( m ) * sinnv ( n1 ) IF ( ljsupu ) jsupu = jsupu + jsupumns1 ( mn ) * tsinmn IF ( ljsupv ) jsupv = jsupv + jsupvmns1 ( mn ) * tsinmn END DO 2000 CONTINUE IF ( ljsupu ) jsupu = jsupu / gsqrt IF ( ljsupv ) jsupv = jsupv / gsqrt END SUBROUTINE tosuvspace SUBROUTINE LoadRZL IMPLICIT NONE C----------------------------------------------- C   L o c a l   V a r i a b l e s C----------------------------------------------- INTEGER :: rcc , rss , zsc , zcs , rsc , rcs , zcc , zss INTEGER :: mpol1 , mn , m , n , n1 REAL ( rprec ) :: sgn C----------------------------------------------- ! !     Arrays must be stacked (and ns,ntor,mpol ordering imposed) !     as coefficients of cos(mu)*cos(nv), etc !     Only need R, Z components(not lambda, for now anyhow) ! IF ( ALLOCATED ( rzl_local )) RETURN mpol1 = mpol - 1 rcc = 1 ; zsc = 1 IF (. not . lasym ) THEN IF ( lthreed ) THEN ntmax = 2 rss = 2 ; zcs = 2 ELSE ntmax = 1 END IF ELSE IF ( lthreed ) THEN ntmax = 4 rss = 2 ; rsc = 3 ; rcs = 4 zcs = 2 ; zcc = 3 ; zss = 4 ELSE ntmax = 2 rsc = 2 ; zcc = 2 END IF END IF !     only ALLOCATE 2*ntmax, don't need lambdas zsc = 1 + ntmax ; zcs = zcs + ntmax ; zcc = zcc + ntmax ; zss = zss + ntmax ALLOCATE ( rzl_local ( ns , 0 : ntor , 0 : mpol1 , 2 * ntmax ), stat = n ) IF ( n . ne . 0 ) STOP 'Allocation error in LoadRZL' rzl_local = 0 DO mn = 1 , mnmax m = NINT ( xm ( mn )); n = NINT ( xn ( mn )) / nfp ; n1 = ABS ( n ) sgn = SIGN ( 1 , n ) rzl_local (:, n1 , m , rcc ) = rzl_local (:, n1 , m , rcc ) + rmnc ( mn ,:) rzl_local (:, n1 , m , zsc ) = rzl_local (:, n1 , m , zsc ) + zmns ( mn ,:) IF ( lthreed ) THEN rzl_local (:, n1 , m , rss ) = rzl_local (:, n1 , m , rss ) 1 + sgn * rmnc ( mn ,:) rzl_local (:, n1 , m , zcs ) = rzl_local (:, n1 , m , zcs ) 1 - sgn * zmns ( mn ,:) END IF IF ( lasym ) THEN rzl_local (:, n1 , m , rsc ) = rzl_local (:, n1 , m , rsc ) 1 + rmns ( mn ,:) rzl_local (:, n1 , m , zcc ) = rzl_local (:, n1 , m , zcc ) 1 + zmnc ( mn ,:) IF ( lthreed ) THEN rzl_local (:, n1 , m , rcs ) = rzl_local (:, n1 , m , rcs ) 1 - sgn * rmns ( mn ,:) rzl_local (:, n1 , m , zss ) = rzl_local (:, n1 , m , zss ) 1 + sgn * zmnc ( mn ,:) END IF END IF END DO !     ADDED by SAL for Vecpot calc IF (. not . ALLOCATED ( chi )) ALLOCATE ( chi ( 1 : ns )) DO mn = 1 , ns chi ( mn ) = SUM ( iotaf ( 1 : mn ) * phipf ( 1 : mn )) END DO END SUBROUTINE LoadRZL END MODULE read_wout_mod","tags":"","loc":"sourcefile/read_wout_mod.f.html"},{"title":"vmec_getenv.f â€“ stella","text":"Contents Subroutines vmec_getenv Source Code vmec_getenv.f Source Code SUBROUTINE vmec_getenv ( ename , evalue ) IMPLICIT NONE CHARACTER ( LEN =* ) :: ename , evalue ! MJL 2016-09-22 The rest of this subroutine is commented out because there was an error on my laptop ! associated with pxfgetenv not being found, and this subroutine is not needed for regcoil anyway. ! !DEC$ IF DEFINED (CRAY) !       INTEGER :: lenname=0, lenval, ierror !       CALL pxfgetenv(ename, lenname, evalue, lenval, ierror) ! !DEC$ ELSE !       CALL getenv(ename, evalue) ! !DEC$ ENDIF END SUBROUTINE vmec_getenv","tags":"","loc":"sourcefile/vmec_getenv.f.html"},{"title":"system_mod.f â€“ stella","text":"Contents Modules system_mod Source Code system_mod.f Source Code MODULE system_mod INTERFACE system SUBROUTINE vmec_system ( cmd , error ) CHARACTER ( LEN =* ), INTENT ( in ) :: cmd INTEGER , OPTIONAL :: error END SUBROUTINE vmec_system END INTERFACE INTERFACE chdir INTEGER FUNCTION vmec_chdir ( path ) CHARACTER ( LEN =* ), INTENT ( in ) :: path END FUNCTION vmec_chdir END INTERFACE INTERFACE getenv SUBROUTINE vmec_getenv ( ename , evalue ) CHARACTER ( LEN =* ) :: ename , evalue END SUBROUTINE vmec_getenv END INTERFACE INTERFACE putenv SUBROUTINE vmec_putenv ( ename , evalue , ierror ) CHARACTER ( LEN =* ) :: ename , evalue INTEGER :: ierror END SUBROUTINE vmec_putenv END INTERFACE INTERFACE PXFFORK SUBROUTINE pxffork_g ( ipid , ierror ) INTEGER :: ipid , ierror END SUBROUTINE pxffork_g END INTERFACE INTERFACE getpid SUBROUTINE vmec_getpid ( ipid , ierror ) INTEGER :: ipid , ierror END SUBROUTINE vmec_getpid END INTERFACE INTERFACE PXFWAIT SUBROUTINE pxfwait_g ( istat , iretpid , ierror ) INTEGER :: istat , iretpid , ierror END SUBROUTINE pxfwait_g END INTERFACE END MODULE system_mod","tags":"","loc":"sourcefile/system_mod.f.html"},{"title":"ezcdf_GenGet.f90 â€“ stella","text":"Contents Modules ezcdf_GenGet Source Code ezcdf_GenGet.f90 Source Code MODULE ezcdf_GenGet USE ezcdf_opncls USE ezcdf_inqvar !DEC$ IF DEFINED (NETCDF) EXTERNAL handle_err PRIVATE include \"netcdf.inc\" INTEGER , PARAMETER :: r4 = SELECTED_REAL_KIND ( 6 , 37 ) INTEGER , PARAMETER :: r8 = SELECTED_REAL_KIND ( 12 , 100 ) CHARACTER * ( * ), PARAMETER :: cmplx_name = '__CmPlx_Re_Im' PRIVATE :: r4 , r8 , cmplx_name PUBLIC :: cdfr_3i , cdfr_3l , cdfr_3d , cdfr_3c16 , cdfr_3f , cdfr_3c8 , & & cdfr_2i , cdfr_2l , cdfr_2d , cdfr_2c16 , cdfr_2f , cdfr_2c8 , cdfr_2c , & & cdfr_1i , cdfr_1l , cdfr_1d , cdfr_1c16 , cdfr_1f , cdfr_1c8 , cdfr_1c , & & cdfr_0i , cdfr_0l , cdfr_0d , cdfr_0c16 , cdfr_0f , cdfr_0c8 , cdfGetVar , & & cdf_read ! Generic Interface to Read netcdf data Variables ! 03/10/99 C. Ludescher ! C. Ludescher/A. Pletzer Tue Apr  4 10:11:33 EDT 2000 ! + support for complex types (ap) Wed May 16 15:18:05 EDT 2001 !==================================================================== ! Generic Read Routines: cdfGetVar ! alias to cdfGetVar (ifc does not like => ) INTERFACE cdf_read MODULE PROCEDURE cdfr_3i , cdfr_3l , cdfr_3d , cdfr_3c16 , cdfr_3f , cdfr_3c8 , & cdfr_2i , cdfr_2l , cdfr_2d , cdfr_2c16 , cdfr_2f , cdfr_2c8 , cdfr_2c , & cdfr_1i , cdfr_1l , cdfr_1d , cdfr_1c16 , cdfr_1f , cdfr_1c8 , cdfr_1c , & cdfr_0i , cdfr_0l , cdfr_0d , cdfr_0c16 , cdfr_0f , cdfr_0c8 END INTERFACE ! same as above (Intel compiler does not handle well aliases) INTERFACE cdfGetVar MODULE PROCEDURE cdfr_3i , cdfr_3l , cdfr_3d , cdfr_3c16 , cdfr_3f , cdfr_3c8 , & cdfr_2i , cdfr_2l , cdfr_2d , cdfr_2c16 , cdfr_2f , cdfr_2c8 , cdfr_2c , & cdfr_1i , cdfr_1l , cdfr_1d , cdfr_1c16 , cdfr_1f , cdfr_1c8 , cdfr_1c , & cdfr_0i , cdfr_0l , cdfr_0d , cdfr_0c16 , cdfr_0f , cdfr_0c8 END INTERFACE CONTAINS !--------------------------------------------- !cdfGetVar implementation routines SUBROUTINE cdfr_3i ( ncid , varnam , varval , ier ) ! Read 3 dimensional Integer array ! implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output integer , dimension (:, :, :), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 3 ) :: st , cnt , ldim integer :: varid , status , j , k integer , dimension ( 3 ) :: dimlens integer , dimension (:, :, :), allocatable :: temp integer :: ndim1 , ndim2 , ndim3 if ( PRESENT ( ier )) ier = 1 ldim = shape ( varval ) call cdfgv ( ncid , varnam , varid , dimlens , ldim , 'i' , status ) if ( status /= 0 ) return ! if ( dimlens ( 1 ) == ldim ( 1 ) . and . dimlens ( 2 ) == ldim ( 2 ) . and . dimlens ( 3 ) == ldim ( 3 )) then status = nf_get_var_int ( ncid , varid , varval ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_3i' , 'nf_get_var_int' ) return end if else allocate ( temp ( dimlens ( 1 ), dimlens ( 2 ), dimlens ( 3 ))) status = nf_get_var_int ( ncid , varid , temp ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_3i' , 'nf_get_var_int' ) deallocate ( temp ) return end if ndim1 = min ( dimlens ( 1 ), ldim ( 1 )) ndim2 = min ( dimlens ( 2 ), ldim ( 2 )) ndim3 = min ( dimlens ( 3 ), ldim ( 3 )) varval ( 1 : ndim1 , 1 : ndim2 , 1 : ndim3 ) = temp ( 1 : ndim1 , 1 : ndim2 , 1 : ndim3 ) deallocate ( temp ) end if !!$  st(1) = 1 !!$  cnt(1) = min(dimlens(1),ldim(1)) ! x count !!$  cnt(2) = 1 !!$  cnt(3) = 1 !!$  do k = 1,min(dimlens(2),ldim(2)) !!$     st(2) = k !!$     do j = 1,min(dimlens(3),ldim(3)) ! For each Z : read slab in varval !!$        st(3) = j           ! Start of slab !!$        status = nf_get_vara_int(ncid,varid,st,cnt,varval(1,k,j)) !!$        if (status .ne. NF_NOERR) then !!$           call handle_err(status,varnam,'cdfr_3i',                 & !!$                &              'nf_get_vara_int') !!$           return !!$        end if !!$     end do !!$  end do if ( PRESENT ( ier )) ier = 0 END SUBROUTINE cdfr_3i SUBROUTINE cdfr_3l ( ncid , varnam , varval , ier ) ! Read 3 dimensional logical array ! implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output logical , dimension (:, :, :), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer :: status integer , dimension (:, :, :), allocatable :: varval_i character * 11 , parameter :: logical_name = '__logical__' ALLOCATE ( varval_i ( size ( varval , 1 ), size ( varval , 2 ), size ( varval , 3 )), stat = status ) if ( status /= 0 ) STOP 'Allocation error in cdf_getvar' call cdfr_3i ( ncid , trim ( varnam ) // logical_name , varval_i , ier ) WHERE ( varval_i == 0 ) varval = . false . ELSEWHERE varval = . true . END WHERE DEALLOCATE ( varval_i ) END SUBROUTINE cdfr_3l SUBROUTINE cdfr_3d ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output REAL ( KIND = r8 ), dimension (:, :, :), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 3 ) :: st , cnt , ldim integer :: varid , status , j , k integer , dimension ( 3 ) :: dimlens real ( r8 ), dimension (:, :, :), allocatable :: temp integer ndim1 , ndim2 , ndim3 if ( PRESENT ( ier )) ier = 1 ldim = shape ( varval ) call cdfgv ( ncid , varnam , varid , dimlens , ldim , 'd' , status ) if ( status /= 0 ) return ! if ( dimlens ( 1 ) == ldim ( 1 ) . and . dimlens ( 2 ) == ldim ( 2 ) . and . dimlens ( 3 ) == ldim ( 3 )) then status = nf_get_var_double ( ncid , varid , varval ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_3d' , 'nf_get_var_double' ) return end if else allocate ( temp ( dimlens ( 1 ), dimlens ( 2 ), dimlens ( 3 ))) status = nf_get_var_double ( ncid , varid , temp ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_3d' , 'nf_get_var_double' ) deallocate ( temp ) return end if ndim1 = min ( dimlens ( 1 ), ldim ( 1 )) ndim2 = min ( dimlens ( 2 ), ldim ( 2 )) ndim3 = min ( dimlens ( 3 ), ldim ( 3 )) varval ( 1 : ndim1 , 1 : ndim2 , 1 : ndim3 ) = temp ( 1 : ndim1 , 1 : ndim2 , 1 : ndim3 ) deallocate ( temp ) end if !!$  st(1) = 1 !!$  cnt(1) = min(dimlens(1),ldim(1)) ! x count !!$  cnt(2) = 1 !!$  cnt(3) = 1 !!$  do k = 1,min(dimlens(2),ldim(2)) !!$     st(2) = k !!$     do j = 1,min(dimlens(3),ldim(3)) ! For each Z : read slab into varval !!$        st(3) = j                      ! Start of slab !!$        status = nf_get_vara_double(ncid,varid,st,cnt,varval(1,k,j)) !!$        if (status .ne. NF_NOERR) then !!$           call handle_err(status,varnam,'cdfr_3d',                    & !!$                &           'nf_get_vara_double') !!$           return !!$        end if !!$     end do !!$  end do if ( PRESENT ( ier )) ier = 0 END SUBROUTINE cdfr_3d SUBROUTINE cdfr_3c16 ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output COMPLEX ( KIND = r8 ), dimension (:, :, :), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 3 ) :: st , cnt , ldim integer :: varid , status , j , k , i integer , dimension ( 3 ) :: dimlens real ( r8 ), dimension (:, :, :), allocatable :: temp integer ndim1 , ndim2 , ndim3 if ( PRESENT ( ier )) ier = 1 ldim = shape ( varval ) ldim ( 1 ) = 2 * ldim ( 1 ) ! Re/Im pairs call cdfgv ( ncid , trim ( varnam ) // cmplx_name , varid , dimlens , ldim , 'd' , status ) if ( status /= 0 ) return ! if ( dimlens ( 1 ) == ldim ( 1 ) . and . dimlens ( 2 ) == ldim ( 2 ) . and . dimlens ( 3 ) == ldim ( 3 )) then status = nf_get_var_double ( ncid , varid , varval ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_3c16' , 'nf_get_var_double' ) return end if else allocate ( temp ( dimlens ( 1 ), dimlens ( 2 ), dimlens ( 3 ))) status = nf_get_var_double ( ncid , varid , temp ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_3c16' , 'nf_get_var_double' ) deallocate ( temp ) return end if ndim1 = min ( dimlens ( 1 ), ldim ( 1 )) ndim2 = min ( dimlens ( 2 ), ldim ( 2 )) ndim3 = min ( dimlens ( 3 ), ldim ( 3 )) do i = 1 , ndim1 / 2 varval ( i , 1 : ndim2 , 1 : ndim3 ) = temp ( 2 * ( i - 1 ) + 1 , 1 : ndim2 , 1 : ndim3 ) + & & ( 0._r8 , 1._r8 ) * temp ( 2 * ( i - 1 ) + 2 , 1 : ndim2 , 1 : ndim3 ) end do deallocate ( temp ) end if !!$ !!$  st(1) = 1 !!$  cnt(1) = min(dimlens(1),ldim(1)) ! x count !!$  cnt(2) = 1 !!$  cnt(3) = 1 !!$  do k = 1,min(dimlens(2),ldim(2)) !!$     st(2) = k !!$     do j = 1,min(dimlens(3),ldim(3)) ! For each Z : read slab into varval !!$        st(3) = j                      ! Start of slab !!$        status = nf_get_vara_double(ncid,varid,st,cnt,varval(1,k,j)) !!$        if (status .ne. NF_NOERR) then !!$           call handle_err(status,varnam,'cdfr_3c16',                    & !!$                &           'nf_get_vara_double') !!$           return !!$        end if !!$     end do !!$  end do if ( PRESENT ( ier )) ier = 0 END SUBROUTINE cdfr_3c16 SUBROUTINE cdfr_3f ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output REAL ( KIND = r4 ), dimension (:, :, :), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 3 ) :: st , cnt , ldim integer :: varid , status , j , k integer , dimension ( 3 ) :: dimlens real , dimension (:, :, :), allocatable :: temp integer ndim1 , ndim2 , ndim3 if ( PRESENT ( ier )) ier = 1 ldim = shape ( varval ) call cdfgv ( ncid , varnam , varid , dimlens , ldim , 'r' , status ) if ( status /= 0 ) return ! if ( dimlens ( 1 ) == ldim ( 1 ) . and . dimlens ( 2 ) == ldim ( 2 ) . and . dimlens ( 3 ) == ldim ( 3 )) then status = nf_get_var_real ( ncid , varid , varval ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_3f' , 'nf_get_var_real' ) return end if else allocate ( temp ( dimlens ( 1 ), dimlens ( 2 ), dimlens ( 3 ))) status = nf_get_var_real ( ncid , varid , temp ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_3f' , 'nf_get_var_real' ) deallocate ( temp ) return end if ndim1 = min ( dimlens ( 1 ), ldim ( 1 )) ndim2 = min ( dimlens ( 2 ), ldim ( 2 )) ndim3 = min ( dimlens ( 3 ), ldim ( 3 )) varval ( 1 : ndim1 , 1 : ndim2 , 1 : ndim3 ) = temp ( 1 : ndim1 , 1 : ndim2 , 1 : ndim3 ) deallocate ( temp ) end if !!$  st(1) = 1 !!$  cnt(1) = min(dimlens(1),ldim(1)) ! x count !!$  cnt(2) = 1 !!$  cnt(3) = 1 !!$  do k = 1,min(dimlens(2),ldim(2)) !!$     st(2) = k !!$     do j = 1,min(dimlens(3),ldim(3)) ! For each Z : read slab into varval !!$        st(3) = j                      ! Start of slab !!$        status = nf_get_vara_real(ncid,varid,st,cnt,varval(1,k,j)) !!$        if (status .ne. NF_NOERR) then !!$           call handle_err(status,varnam,'cdfr_3f',                    & !!$                &           'nf_get_vara_real') !!$           return !!$        end if !!$     end do !!$  end do if ( PRESENT ( ier )) ier = 0 END SUBROUTINE cdfr_3f SUBROUTINE cdfr_3c8 ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output COMPLEX ( KIND = r4 ), dimension (:, :, :), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 3 ) :: st , cnt , ldim integer :: varid , status , j , k integer , dimension ( 3 ) :: dimlens real , dimension (:, :, :), allocatable :: temp integer ndim1 , ndim2 , ndim3 , i if ( PRESENT ( ier )) ier = 1 ldim = shape ( varval ) ldim ( 1 ) = 2 * ldim ( 1 ) ! Re/Im pairs call cdfgv ( ncid , trim ( varnam ) // cmplx_name , varid , dimlens , ldim , 'r' , status ) if ( status /= 0 ) return ! if ( dimlens ( 1 ) == ldim ( 1 ) . and . dimlens ( 2 ) == ldim ( 2 ) . and . dimlens ( 3 ) == ldim ( 3 )) then status = nf_get_var_real ( ncid , varid , varval ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_3c8' , 'nf_get_var_real' ) return end if else allocate ( temp ( dimlens ( 1 ), dimlens ( 2 ), dimlens ( 3 ))) status = nf_get_var_real ( ncid , varid , temp ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_3c8' , 'nf_get_var_real' ) deallocate ( temp ) return end if ndim1 = min ( dimlens ( 1 ), ldim ( 1 )) ndim2 = min ( dimlens ( 2 ), ldim ( 2 )) ndim3 = min ( dimlens ( 3 ), ldim ( 3 )) do i = 1 , ndim1 / 2 varval ( i , 1 : ndim2 , 1 : ndim3 ) = temp ( 2 * ( i - 1 ) + 1 , 1 : ndim2 , 1 : ndim3 ) + & & ( 0. , 1. ) * temp ( 2 * ( i - 1 ) + 2 , 1 : ndim2 , 1 : ndim3 ) end do deallocate ( temp ) end if !!$  st(1) = 1 !!$  cnt(1) = min(dimlens(1),ldim(1)) ! x count !!$  cnt(2) = 1 !!$  cnt(3) = 1 !!$  do k = 1,min(dimlens(2),ldim(2)) !!$     st(2) = k !!$     do j = 1,min(dimlens(3),ldim(3)) ! For each Z : read slab into varval !!$        st(3) = j                      ! Start of slab !!$        status = nf_get_vara_real(ncid,varid,st,cnt,varval(1,k,j)) !!$        if (status .ne. NF_NOERR) then !!$           call handle_err(status,varnam,'cdfr_3c8',                    & !!$                &           'nf_get_vara_real') !!$           return !!$        end if !!$     end do !!$  end do if ( PRESENT ( ier )) ier = 0 END SUBROUTINE cdfr_3c8 SUBROUTINE cdfr_2i ( ncid , varnam , varval , ier ) ! Read 2 dimensional Integer array ! implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output integer , dimension (:, :), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 2 ) :: st , cnt , ldim integer :: varid , status , j integer , dimension ( 2 ) :: dimlens integer , dimension (:, :), allocatable :: temp integer ndim1 , ndim2 if ( PRESENT ( ier )) ier = 1 ldim = shape ( varval ) call cdfgv ( ncid , varnam , varid , dimlens , ldim , 'i' , status ) if ( status /= 0 ) return ! if ( dimlens ( 1 ) == ldim ( 1 ) . and . dimlens ( 2 ) == ldim ( 2 )) then status = nf_get_var_int ( ncid , varid , varval ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_2i' , 'nf_get_var_int' ) return end if else allocate ( temp ( dimlens ( 1 ), dimlens ( 2 ))) status = nf_get_var_int ( ncid , varid , temp ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_2i' , 'nf_get_var_int' ) deallocate ( temp ) return end if ndim1 = min ( dimlens ( 1 ), ldim ( 1 )) ndim2 = min ( dimlens ( 2 ), ldim ( 2 )) varval ( 1 : ndim1 , 1 : ndim2 ) = temp ( 1 : ndim1 , 1 : ndim2 ) deallocate ( temp ) end if !!$  st(1) = 1 !!$  cnt(1) = min(dimlens(1),ldim(1)) ! x count !!$  cnt(2) = 1 !!$  do j = 1,min(dimlens(2),ldim(2)) ! For each Y : read slab into varval !!$     st(2) = j              ! Start of slab !!$     status = nf_get_vara_int(ncid,varid,st,cnt,varval(1,j)) !!$     if (status .ne. NF_NOERR) then !!$        call handle_err(status,varnam,'cdfr_2i',                    & !!$             &           'nf_get_vara_int') !!$        return !!$     end if !!$  end do if ( PRESENT ( ier )) ier = 0 END SUBROUTINE cdfr_2i SUBROUTINE cdfr_2l ( ncid , varnam , varval , ier ) ! Read 2 dimensional logical array ! implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output logical , dimension (:, :), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer :: status integer , dimension (:, :), allocatable :: varval_i character * 11 , parameter :: logical_name = '__logical__' ALLOCATE ( varval_i ( size ( varval , 1 ), size ( varval , 2 )), stat = status ) if ( status /= 0 ) STOP 'Allocation error in cdf_getvar' call cdfr_2i ( ncid , trim ( varnam ) // logical_name , varval_i , ier ) WHERE ( varval_i == 0 ) varval = . false . ELSEWHERE varval = . true . END WHERE DEALLOCATE ( varval_i ) END SUBROUTINE cdfr_2l SUBROUTINE cdfr_2d ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output REAL ( KIND = r8 ), dimension (:, :), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 2 ) :: st , cnt , ldim integer :: varid , status , j integer , dimension ( 2 ) :: dimlens real ( r8 ), dimension (:, :), allocatable :: temp integer ndim1 , ndim2 if ( PRESENT ( ier )) ier = 1 ldim = shape ( varval ) call cdfgv ( ncid , varnam , varid , dimlens , ldim , 'd' , status ) if ( status /= 0 ) return ! if ( dimlens ( 1 ) == ldim ( 1 ) . and . dimlens ( 2 ) == ldim ( 2 )) then status = nf_get_var_double ( ncid , varid , varval ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_2d' , 'nf_get_var_double' ) return end if else allocate ( temp ( dimlens ( 1 ), dimlens ( 2 ))) status = nf_get_var_double ( ncid , varid , temp ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_2d' , 'nf_get_var_double' ) deallocate ( temp ) return end if ndim1 = min ( dimlens ( 1 ), ldim ( 1 )) ndim2 = min ( dimlens ( 2 ), ldim ( 2 )) varval ( 1 : ndim1 , 1 : ndim2 ) = temp ( 1 : ndim1 , 1 : ndim2 ) deallocate ( temp ) end if !!$  st(1) = 1 !!$  cnt(1) = min(dimlens(1),ldim(1)) ! x count !!$  cnt(2) = 1 !!$  do j = 1,min(dimlens(2),ldim(2)) ! For each Y : read slab into varval !!$     st(2) = j              ! Start of slab !!$     status = nf_get_vara_double(ncid,varid,st,cnt,varval(1,j)) !!$     if (status .ne. NF_NOERR) then !!$        call handle_err(status,varnam,'cdfr_2d',                    & !!$             &           'nf_get_vara_double') !!$        return !!$     end if !!$  end do if ( PRESENT ( ier )) ier = 0 END SUBROUTINE cdfr_2d SUBROUTINE cdfr_2c16 ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output COMPLEX ( KIND = r8 ), dimension (:, :), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 2 ) :: st , cnt , ldim integer :: varid , status , j , i integer , dimension ( 2 ) :: dimlens real ( r8 ), dimension (:, :), allocatable :: temp integer ndim1 , ndim2 if ( PRESENT ( ier )) ier = 1 ldim = shape ( varval ) ldim ( 1 ) = 2 * ldim ( 1 ) ! Re/Im pairs call cdfgv ( ncid , trim ( varnam ) // cmplx_name , varid , dimlens , ldim , 'd' , status ) if ( status /= 0 ) return ! if ( dimlens ( 1 ) == ldim ( 1 ) . and . dimlens ( 2 ) == ldim ( 2 )) then status = nf_get_var_double ( ncid , varid , varval ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_2c16' , 'nf_get_var_double' ) return end if else allocate ( temp ( dimlens ( 1 ), dimlens ( 2 ))) status = nf_get_var_double ( ncid , varid , temp ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_2c16' , 'nf_get_var_double' ) deallocate ( temp ) return end if ndim1 = min ( dimlens ( 1 ), ldim ( 1 )) ndim2 = min ( dimlens ( 2 ), ldim ( 2 )) do i = 1 , ndim1 / 2 varval ( i , 1 : ndim2 ) = temp ( 2 * ( i - 1 ) + 1 , 1 : ndim2 ) + & & ( 0._r8 , 1._r8 ) * temp ( 2 * ( i - 1 ) + 2 , 1 : ndim2 ) end do deallocate ( temp ) end if !!$  st(1) = 1 !!$  cnt(1) = min(dimlens(1),ldim(1)) ! x count !!$  cnt(2) = 1 !!$  do j = 1,min(dimlens(2),ldim(2)) ! For each Y : read slab into varval !!$     st(2) = j              ! Start of slab !!$     status = nf_get_vara_double(ncid,varid,st,cnt,varval(1,j)) !!$     if (status .ne. NF_NOERR) then !!$        call handle_err(status,varnam,'cdfr_2c16',                    & !!$             &           'nf_get_vara_double') !!$        return !!$     end if !!$  end do if ( PRESENT ( ier )) ier = 0 END SUBROUTINE cdfr_2c16 SUBROUTINE cdfr_2f ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output REAL ( KIND = r4 ), dimension (:, :), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 2 ) :: st , cnt , ldim integer :: varid , status , j integer , dimension ( 2 ) :: dimlens real , dimension (:, :), allocatable :: temp integer ndim1 , ndim2 if ( PRESENT ( ier )) ier = 1 ldim = shape ( varval ) call cdfgv ( ncid , varnam , varid , dimlens , ldim , 'r' , status ) if ( status /= 0 ) return ! if ( dimlens ( 1 ) == ldim ( 1 ) . and . dimlens ( 2 ) == ldim ( 2 )) then status = nf_get_var_real ( ncid , varid , varval ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_2f' , 'nf_get_var_real' ) return end if else allocate ( temp ( dimlens ( 1 ), dimlens ( 2 ))) status = nf_get_var_real ( ncid , varid , temp ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_2f' , 'nf_get_var_real' ) deallocate ( temp ) return end if ndim1 = min ( dimlens ( 1 ), ldim ( 1 )) ndim2 = min ( dimlens ( 2 ), ldim ( 2 )) varval ( 1 : ndim1 , 1 : ndim2 ) = temp ( 1 : ndim1 , 1 : ndim2 ) deallocate ( temp ) end if !!$  st(1) = 1 !!$  cnt(1) = min(dimlens(1),ldim(1)) ! x count !!$  cnt(2) = 1 !!$  do j = 1,min(dimlens(2),ldim(2)) ! For each Y : read slab into varval !!$     st(2) = j              ! Start of slab !!$     status = nf_get_vara_real(ncid,varid,st,cnt,varval(1,j)) !!$     if (status .ne. NF_NOERR) then !!$        call handle_err(status,varnam,'cdfr_2f',                    & !!$             &           'nf_get_vara_real') !!$        return !!$     end if !!$  end do if ( PRESENT ( ier )) ier = 0 END SUBROUTINE cdfr_2f SUBROUTINE cdfr_2c8 ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output COMPLEX ( KIND = r4 ), dimension (:, :), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 2 ) :: st , cnt , ldim integer :: varid , status , j , i integer , dimension ( 2 ) :: dimlens real ( r8 ), dimension (:, :), allocatable :: temp integer ndim1 , ndim2 if ( PRESENT ( ier )) ier = 1 ldim = shape ( varval ) ldim ( 1 ) = 2 * ldim ( 1 ) ! Re/Pairs call cdfgv ( ncid , trim ( varnam ) // cmplx_name , varid , dimlens , ldim , 'r' , status ) if ( status /= 0 ) return ! if ( dimlens ( 1 ) == ldim ( 1 ) . and . dimlens ( 2 ) == ldim ( 2 )) then status = nf_get_var_real ( ncid , varid , varval ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_2c8' , 'nf_get_var_real' ) return end if else allocate ( temp ( dimlens ( 1 ), dimlens ( 2 ))) status = nf_get_var_real ( ncid , varid , temp ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_2c8' , 'nf_get_var_real' ) deallocate ( temp ) return end if ndim1 = min ( dimlens ( 1 ), ldim ( 1 )) ndim2 = min ( dimlens ( 2 ), ldim ( 2 )) do i = 1 , ndim1 / 2 varval ( i , 1 : ndim2 ) = temp ( 2 * ( i - 1 ) + 1 , 1 : ndim2 ) + & & ( 0. , 1. ) * temp ( 2 * ( i - 1 ) + 2 , 1 : ndim2 ) end do deallocate ( temp ) end if !!$  st(1) = 1 !!$  cnt(1) = min(dimlens(1),ldim(1)) ! x count !!$  cnt(2) = 1 !!$  do j = 1,min(dimlens(2),ldim(2)) ! For each Y : read slab into varval !!$     st(2) = j              ! Start of slab !!$     status = nf_get_vara_real(ncid,varid,st,cnt,varval(1,j)) !!$     if (status .ne. NF_NOERR) then !!$        call handle_err(status,varnam,'cdfr_2c8',                    & !!$             &           'nf_get_vara_real') !!$        return !!$     end if !!$  end do if ( PRESENT ( ier )) ier = 0 END SUBROUTINE cdfr_2c8 SUBROUTINE cdfr_2c ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output character * ( * ), dimension (:), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 2 ) :: st , cnt , ldim integer :: varid , status , charlen , j integer , dimension ( 2 ) :: dimlens if ( PRESENT ( ier )) ier = 1 ldim ( 1 ) = len ( varval ) ldim ( 2 ) = size ( varval ) call cdfgv ( ncid , varnam , varid , dimlens , ldim , 'c' , status ) if ( status /= 0 ) return ! st ( 1 ) = 1 cnt ( 1 ) = min ( dimlens ( 1 ), ldim ( 1 )) ! x count cnt ( 2 ) = 1 do j = 1 , min ( dimlens ( 2 ), ldim ( 2 )) ! For each Y : read slab into varval st ( 2 ) = j ! Start of slab status = nf_get_vara_text ( ncid , varid , st , cnt , varval ( j )) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_2c' , & & 'nf_get_var_text' ) return end if end do if ( PRESENT ( ier )) ier = 0 END SUBROUTINE cdfr_2c SUBROUTINE cdfr_1i ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output integer , dimension (:), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer :: varid , status integer , dimension ( 1 ) :: dimlens , ldim if ( PRESENT ( ier )) ier = 1 ldim = shape ( varval ) call cdfgv ( ncid , varnam , varid , dimlens , ldim , 'i' , status ) if ( status /= 0 ) return ! status = nf_get_var_int ( ncid , varid , varval ) call handle_err ( status , varnam , 'cdfr_1i' , 'nf_get_var_int' ) if ( PRESENT ( ier )) ier = status END SUBROUTINE cdfr_1i SUBROUTINE cdfr_1l ( ncid , varnam , varval , ier ) ! Read 1 dimensional logical array ! implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output logical , dimension (:), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer :: status integer , dimension (:), allocatable :: varval_i character * 11 , parameter :: logical_name = '__logical__' ALLOCATE ( varval_i ( size ( varval , 1 )), stat = status ) if ( status /= 0 ) STOP 'Allocation error in cdf_getvar' call cdfr_1i ( ncid , trim ( varnam ) // logical_name , varval_i , ier ) WHERE ( varval_i == 0 ) varval = . false . ELSEWHERE varval = . true . END WHERE DEALLOCATE ( varval_i ) END SUBROUTINE cdfr_1l SUBROUTINE cdfr_1d ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output REAL ( KIND = r8 ), dimension (:), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer :: varid , status integer , dimension ( 1 ) :: dimlens , ldim if ( PRESENT ( ier )) ier = 1 ldim = shape ( varval ) call cdfgv ( ncid , varnam , varid , dimlens , ldim , 'd' , status ) if ( status /= 0 ) return ! status = nf_get_var_double ( ncid , varid , varval ) call handle_err ( status , varnam , 'cdfr_1d' , 'nf_get_var_double' ) if ( PRESENT ( ier )) ier = status END SUBROUTINE cdfr_1d SUBROUTINE cdfr_1c16 ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output COMPLEX ( KIND = r8 ), dimension (:), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer :: varid , status integer , dimension ( 1 ) :: dimlens , ldim if ( PRESENT ( ier )) ier = 1 ldim = shape ( varval ) ldim ( 1 ) = 2 * ldim ( 1 ) ! Re/Im pairs call cdfgv ( ncid , trim ( varnam ) // cmplx_name , varid , dimlens , ldim , 'd' , status ) if ( status /= 0 ) return ! status = nf_get_var_double ( ncid , varid , varval ) call handle_err ( status , varnam , 'cdfr_1c16' , 'nf_get_var_double' ) if ( PRESENT ( ier )) ier = status END SUBROUTINE cdfr_1c16 SUBROUTINE cdfr_1f ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output REAL ( KIND = r4 ), dimension (:), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer :: varid , status integer , dimension ( 1 ) :: dimlens , ldim if ( PRESENT ( ier )) ier = 1 ldim = shape ( varval ) call cdfgv ( ncid , varnam , varid , dimlens , ldim , 'r' , status ) if ( status /= 0 ) return ! status = nf_get_var_real ( ncid , varid , varval ) call handle_err ( status , varnam , 'cdfr_1f' , 'nf_get_var_real' ) if ( PRESENT ( ier )) ier = status END SUBROUTINE cdfr_1f SUBROUTINE cdfr_1c8 ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output COMPLEX ( KIND = r4 ), dimension (:), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer :: varid , status integer , dimension ( 1 ) :: dimlens , ldim if ( PRESENT ( ier )) ier = 1 ldim = shape ( varval ) ldim ( 1 ) = 2 * ldim ( 1 ) call cdfgv ( ncid , trim ( varnam ) // cmplx_name , varid , dimlens , ldim , 'r' , status ) if ( status /= 0 ) return ! status = nf_get_var_real ( ncid , varid , varval ) call handle_err ( status , varnam , 'cdfr_1c8' , 'nf_get_var_real' ) if ( PRESENT ( ier )) ier = status END SUBROUTINE cdfr_1c8 SUBROUTINE cdfr_1c ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output character * ( * ), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer :: varid , status integer , dimension ( 1 ) :: dimlens , ldim if ( PRESENT ( ier )) ier = 1 ldim ( 1 ) = len ( varval ) call cdfgv ( ncid , varnam , varid , dimlens , ldim , 'c' , status ) if ( status /= 0 ) return ! status = nf_get_var_text ( ncid , varid , varval ) call handle_err ( status , varnam , 'cdfr_1c' , 'nf_get_var_text' ) if ( PRESENT ( ier )) ier = status END SUBROUTINE cdfr_1c SUBROUTINE cdfr_0i ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output integer , intent ( out ) :: varval integer , optional , intent ( out ) :: ier ! Local integer :: varid , status integer , dimension ( 1 ) :: dimlens , ldim if ( PRESENT ( ier )) ier = 1 ldim ( 1 ) = 0 call cdfgv ( ncid , varnam , varid , dimlens , ldim , 'i' , status ) if ( status /= 0 ) return ! status = nf_get_var_int ( ncid , varid , varval ) call handle_err ( status , varnam , 'cdfr_0i' , 'nf_get_var_int' ) if ( PRESENT ( ier )) ier = status END SUBROUTINE cdfr_0i SUBROUTINE cdfr_0l ( ncid , varnam , varval , ier ) ! Read scalar logical array ! implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output logical , intent ( out ) :: varval integer , optional , intent ( out ) :: ier ! Local integer :: varval_i character * 11 , parameter :: logical_name = '__logical__' varval_i = 0 call cdfr_0i ( ncid , trim ( varnam ) // logical_name , varval_i , ier ) IF ( varval_i == 0 ) THEN varval = . false . ELSE varval = . true . END IF END SUBROUTINE cdfr_0l SUBROUTINE cdfr_0d ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output REAL ( KIND = r8 ), intent ( out ) :: varval integer , optional , intent ( out ) :: ier ! Local integer :: varid , status integer , dimension ( 1 ) :: dimlens , ldim if ( PRESENT ( ier )) ier = 1 ldim ( 1 ) = 0 call cdfgv ( ncid , varnam , varid , dimlens , ldim , 'd' , status ) if ( status /= 0 ) return ! status = nf_get_var_double ( ncid , varid , varval ) call handle_err ( status , varnam , 'cdfr_0d' , 'nf_get_var_double' ) if ( PRESENT ( ier )) ier = status END SUBROUTINE cdfr_0d SUBROUTINE cdfr_0c16 ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output COMPLEX ( KIND = r8 ), intent ( out ) :: varval integer , optional , intent ( out ) :: ier ! Local integer :: varid , status integer , dimension ( 1 ) :: dimlens , ldim if ( PRESENT ( ier )) ier = 1 ldim ( 1 ) = 2 ! Re/Im pair call cdfgv ( ncid , trim ( varnam ) // cmplx_name , varid , dimlens , ldim , 'd' , status ) if ( status /= 0 ) return ! status = nf_get_var_double ( ncid , varid , varval ) call handle_err ( status , varnam , 'cdfr_0d' , 'nf_get_var_double' ) if ( PRESENT ( ier )) ier = status END SUBROUTINE cdfr_0c16 SUBROUTINE cdfr_0f ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output REAL ( KIND = r4 ), intent ( out ) :: varval integer , optional , intent ( out ) :: ier ! Local integer :: varid , status integer , dimension ( 1 ) :: dimlens , ldim if ( PRESENT ( ier )) ier = 1 ldim ( 1 ) = 0 call cdfgv ( ncid , varnam , varid , dimlens , ldim , 'r' , status ) if ( status /= 0 ) return ! status = nf_get_var_real ( ncid , varid , varval ) call handle_err ( status , varnam , 'cdfr_0f' , 'nf_get_var_real' ) if ( PRESENT ( ier )) ier = status END SUBROUTINE cdfr_0f SUBROUTINE cdfr_0c8 ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output COMPLEX ( KIND = r4 ), intent ( out ) :: varval integer , optional , intent ( out ) :: ier ! Local integer :: varid , status integer , dimension ( 1 ) :: dimlens , ldim if ( PRESENT ( ier )) ier = 1 ldim ( 1 ) = 2 ! Re/Im pair call cdfgv ( ncid , trim ( varnam ) // cmplx_name , varid , dimlens , ldim , 'r' , status ) if ( status /= 0 ) return ! status = nf_get_var_real ( ncid , varid , varval ) call handle_err ( status , varnam , 'cdfr_0f' , 'nf_get_var_real' ) if ( PRESENT ( ier )) ier = status END SUBROUTINE cdfr_0c8 !DEC$ ENDIF END MODULE ezcdf_GenGet","tags":"","loc":"sourcefile/ezcdf_genget.f90.html"},{"title":"ezcdf_inqvar.f90 â€“ stella","text":"Contents Modules ezcdf_inqvar Source Code ezcdf_inqvar.f90 Source Code MODULE ezcdf_inqvar IMPLICIT NONE !DEC$ IF DEFINED (NETCDF) PUBLIC :: cdfInqVar , cdfgv , cdfInqV , cdf_inquire , alpha_numeric INTERFACE cdfInqVarDim MODULE PROCEDURE cdfInqV , cdfgv , cdf_inquire END INTERFACE PRIVATE INCLUDE \"netcdf.inc\" CHARACTER * ( nf_max_name ) :: varnam_noalpha PRIVATE varnam_noalpha CONTAINS subroutine cdfInqVar ( ncid , varnam , dimlens , eztype , ier ) ! Inquire a Variable and its dimensions ! 03/08/99 C. Ludescher ! C. Ludescher/A. Pletzer Tue Apr  4 10:11:33 EDT 2000 ! + support for complex type (ap) Wed May 16 15:18:05 EDT 2001 implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output integer , dimension (:), intent ( out ) :: dimlens character * ( * ), intent ( out ) :: eztype integer , optional , intent ( out ) :: ier ! Local integer :: ndims , varid , natts , xtype integer :: status , i integer , dimension ( 3 ) :: dimids character * ( nf_max_name ) :: name integer , parameter :: cmplx_len = 13 character ( cmplx_len ), parameter :: cmplx_name = '__CmPlx_Re_Im' character * 11 , parameter :: logical_name = '__logical__' logical :: is_complex , is_logical if ( PRESENT ( ier )) ier = 1 is_complex = . false . is_logical = . false . ! replace any non-alphanumeric characters with underscores varnam_noalpha = varnam CALL alpha_numeric ( varnam_noalpha ) status = nf_inq_varid ( ncid , varnam_noalpha , varid ) if ( status /= 0 ) then ! perhaps varnam is complex, try... status = nf_inq_varid ( ncid , trim ( varnam_noalpha ) // cmplx_name , varid ) if ( status == 0 ) then is_complex = . true . else status = nf_inq_varid ( ncid , trim ( varnam_noalpha ) // logical_name , varid ) if ( status == 0 ) is_logical = . true . end if end if if ( is_complex ) varnam_noalpha = trim ( varnam_noalpha ) // cmplx_name if ( is_logical ) varnam_noalpha = trim ( varnam_noalpha ) // logical_name ! call handle_err(status,varnam_noalpha,'cdfInqVar','nf_inq_varid') if ( status /= 0 ) return status = nf_inq_var ( ncid , varid , name , xtype , ndims , dimids , natts ) call handle_err ( status , varnam_noalpha , 'cdfInqVar' , 'nf_inq_var' ) if ( status /= 0 ) return if ( size ( dimlens ) < ndims ) return dimlens = 0 select case ( xtype ) case ( nf_double ) eztype = 'R8' if ( is_complex ) eztype = 'C16' case ( nf_int ) eztype = 'INT' if ( is_logical ) eztype = 'LOG' !  case (nf_byte) !     eztype = 'LOG' case ( nf_float ) eztype = 'R4' if ( is_complex ) eztype = 'C8' case ( nf_char ) eztype = 'CHAR' end select do i = 1 , ndims status = nf_inq_dim ( ncid , dimids ( i ), name , dimlens ( i )) call handle_err ( status , varnam , 'cdfInqVar' , 'nf_inq_dim' ) end do if ( is_complex ) then dimlens ( 1 ) = dimlens ( 1 ) / 2 end if if ( PRESENT ( ier )) ier = status end subroutine cdfInqVar ! automatic conversion to free f90 compatible form ! free.pl cdfgv.for ! linewidth: 72 ! file names: cdfgv.for ! SUBROUTINE cdfgv ( ncid , varnam , varid , dimlens , sizes , xtype , status ) ! !     Get Variable id, etc. !     02/11/99 C.Ludescher ! C. Ludescher/A. Pletzer Tue Apr  4 10:11:33 EDT 2000 ! implicit none !!$      include \"netcdf.inc\" ! Input integer :: ncid character * ( * ) :: varnam character * 1 :: xtype integer , dimension (:) :: sizes ! Output integer , dimension (:) :: dimlens integer :: varid , status ! Local integer :: i , vartyp , ndims , atts , rank integer , dimension ( 3 ) :: dimids character * ( nf_max_name ) :: name !   replace any non-alphanumeric characters with underscores varnam_noalpha = varnam CALL alpha_numeric ( varnam_noalpha ) status = nf_inq_varid ( ncid , varnam_noalpha , varid ) !   call handle_err(status,varnam,'cdfgv','nf_inq_varid') if ( status /= 0 ) return status = nf_inq_var ( ncid , varid , name , vartyp , ndims , dimids , atts ) call handle_err ( status , varnam , 'cdfgv' , 'nf_inq_var' ) if ( status /= 0 ) return ! Verify input dimension is correct rank = size ( sizes ) status = 1 if ( ndims == 3 . and . rank /= 3 ) then print \"('% cdfgv: --E-- The variable ',a,                      & &         ' is 3 dimensional')\" , varnam return else if ( ndims == 2 . and . rank /= 2 ) then print \"('% cdfgv: --E-- The variable ',a,                      & &         ' is 2 dimensional')\" , varnam return end if if ( ndims == 0 . and . sizes ( 1 ) /= 0 ) then print \"('% cdfgv: --E-- The variable ',a,                      & &           ' is a Scalar')\" , varnam return else if ( ndims == 1 . and . rank /= 1 ) then print \"('% cdfgv: --E-- The variable ',a,                      & &           ' is 1 dimensional')\" , & & varnam return end if ! Verify data type is matching select case ( xtype ) case ( 'i' ) if ( vartyp /= nf_int ) then print \"('% cdfgv: --E-- ',a,' is of type Integer !')\" , & & varnam return end if case ( 'l' ) if ( vartyp /= nf_byte ) then print \"('% cdfgv: --E-- ',a,' is of type logical !')\" , & & varnam return end if case ( 'd' ) if ( vartyp /= nf_double ) then print \"('% cdfgv: --E-- ',a,' is of type REAL*8 !')\" , & & varnam return end if case ( 'r' ) if ( vartyp /= nf_real ) then print \"('% cdfgv: --E-- ',a,' is of type default REAL !')\" , & & varnam return end if case ( 'c' ) if ( vartyp /= nf_char ) then print \"('% cdfgv: --E-- ',a,' is of type Character !')\" , & & varnam return end if end select status = 0 do i = 1 , ndims dimlens ( i ) = 0 status = nf_inq_dim ( ncid , dimids ( i ), name , dimlens ( i )) call handle_err ( status , varnam , 'cdfgv' , 'nf_inq_dim' ) end do ! Check array size is big enough select case ( ndims ) case ( 1 ) if ( dimlens ( 1 ) > sizes ( 1 )) then print \"('% cdfgv: --W-- Output array size =',I6,/           & &           '                is smaller than ',                    & &           a,' size =',I6/,                                       & &           '                output will be truncated !')\" , & & sizes ( 1 ), varnam , dimlens ( 1 ) end if case ( 2 ) if ( dimlens ( 1 ) > sizes ( 1 ) . or . dimlens ( 2 ) > sizes ( 2 )) then print \"('% cdfgv: --W-- Output array size =',I6,' *',I6,/      & &           '                is smaller than ',                    & &           a,' size =',I6,' *',I6/,                               & &           '                output will be truncated !')\" , & & sizes ( 1 ), sizes ( 2 ), varnam , dimlens ( 1 ), dimlens ( 2 ) end if case ( 3 ) if ( dimlens ( 1 ) > sizes ( 1 ) . or . dimlens ( 2 ) > sizes ( 2 ) & & . or . dimlens ( 3 ) > sizes ( 3 )) then print \"('% cdfgv: --W-- Output array size =',                  & &          I5,' *',I5,' *',I5/,                                    & &           '                is smaller than ',                    & &           a,' size =',I5,' *',I5,' *',I5/,                       & &           '                output will be truncated !')\" , & & sizes ( 1 ), sizes ( 2 ), sizes ( 3 ), varnam , & & dimlens ( 1 ), dimlens ( 2 ), dimlens ( 3 ) end if end select end SUBROUTINE cdfgv SUBROUTINE cdfInqV ( ncid , varnam , varid , dimlens , ndims , status ) ! Inquire variable-id and dimlens ! 03/09/99 C.Ludescher ! implicit none ! !!$      include \"netcdf.inc\" ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Returns !      integer, dimension(3)  ::  dimlens !      integer ::  ndims, varid !      integer ::  status integer , dimension (:), intent ( out ) :: dimlens integer , intent ( out ) :: ndims , varid integer , intent ( out ) :: status ! Local integer :: natts , xtype , i integer , dimension ( 3 ) :: dimids character * ( nf_max_name ) :: name !--------------------------------------------------------------------------- !   Initialize values SAL 07012014 varid = 0 ! SAL 07012014 xtype = 0 ; ndims = 0 ; dimids = 0 ; natts = 0 ; dimlens = 0 ! SAL 07012014 !   replace any non-alphanumeric characters with underscores varnam_noalpha = varnam CALL alpha_numeric ( varnam_noalpha ) status = nf_inq_varid ( ncid , varnam_noalpha , varid ) !    call handle_err(status,varnam,'cdfInqV','nf_inq_varid') if ( status /= 0 ) return status = nf_inq_var ( ncid , varid , name , xtype , ndims , dimids , natts ) call handle_err ( status , varnam , 'cdfInqV' , 'nf_inq_var' ) if ( ndims > size ( dimlens )) stop 'dimlens too small in cdfInqV' do i = 1 , ndims status = nf_inq_dimlen ( ncid , dimids ( i ), dimlens ( i )) call handle_err ( status , varnam , 'cdfInqV' , 'nf_inq_dimlen' ) end do END SUBROUTINE cdfInqV SUBROUTINE cdf_inquire ( ncid , varnam , dimlens , xtype , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output integer , dimension (:), intent ( out ) :: dimlens character * ( * ), optional , intent ( out ) :: xtype integer , optional , intent ( out ) :: ier integer :: ezerror character * 4 :: eztype CALL cdfInqVar ( ncid , varnam , dimlens , eztype , ezerror ) IF ( PRESENT ( xtype )) xtype = eztype IF ( PRESENT ( ier )) ier = ezerror END SUBROUTINE cdf_inquire SUBROUTINE alpha_numeric ( string ) IMPLICIT NONE CHARACTER * ( * ), INTENT ( INOUT ) :: string CHARACTER * ( LEN_TRIM ( string )) :: temp INTEGER :: iascii , i ! 04/03/03 S. Hirshman ! replaces any non-alphanumeric characters with underscores temp = adjustl ( string ) string = trim ( temp ) do i = 2 , len_trim ( string ) iascii = iachar ( string ( i : i )) if ((( iascii >= iachar ( '0' )) . and . ( iascii <= iachar ( '9' ))) & . or . (( iascii >= iachar ( 'A' )) . and . ( iascii <= iachar ( 'z' )))) cycle string ( i : i ) = '_' end do END SUBROUTINE alpha_numeric !DEC$ ENDIF END MODULE ezcdf_inqvar","tags":"","loc":"sourcefile/ezcdf_inqvar.f90.html"},{"title":"v3_utilities.f â€“ stella","text":"File v3_utilitlies.f\n  Contains module v3_utilitlies\n  Utility Functions for V3FIT MODULE v3_utilitlies\n    (Utilities, for the V3FIT code)\n SECTION I.    Variable Declarations\n SECTION II.   Interface Blocks\n SECTION III.  Error Trapping\n SECTION IV.   Input-Output Utilities Contents Modules v3_utilities Source Code v3_utilities.f Source Code !  JDH 08-12-2004. First version. Some subroutines modeled after Numerical Recipes !  nrutil subroutines !******************************************************************************* !  File v3_utilitlies.f !  Contains module v3_utilitlies !  Utility Functions for V3FIT !******************************************************************************* !  MODULE v3_utilitlies !    (Utilities, for the V3FIT code) ! SECTION I.    Variable Declarations ! SECTION II.   Interface Blocks ! SECTION III.  Error Trapping ! SECTION IV.   Input-Output Utilities !******************************************************************************* MODULE v3_utilities IMPLICIT NONE !******************************************************************************* ! SECTION I. Variable Declarations !******************************************************************************* !------------------------------------------------------------------------------- !  Type declarations - lengths of reals, integers, and complexes. !  Frequently used mathematical constants, lots of extra precision. !  Make type declarations and constants Private, so there are no conflicts. !------------------------------------------------------------------------------- INTEGER , PARAMETER :: rprec = SELECTED_REAL_KIND ( 12 , 100 ) INTEGER , PARAMETER :: iprec = SELECTED_INT_KIND ( 8 ) INTEGER , PARAMETER :: cprec = KIND (( 1.0_rprec , 1.0_rprec )) REAL ( rprec ), PARAMETER :: pi = 3.14159265358979323846264338328_rprec REAL ( rprec ), PARAMETER :: twopi = 6.28318530717958647692528677_rprec REAL ( rprec ), PARAMETER :: one = 1.0_rprec REAL ( rprec ), PARAMETER :: zero = 0.0_rprec !      USE stell_kinds, only : rprec, iprec, cprec !      USE stell_constants, only: pi, twopi, one, zero PRIVATE rprec , iprec , cprec , pi , twopi , one , zero !------------------------------------------------------------------------------- !  JDH 08-13-04. Perhaps add variable for error IO unit numnber, and print there also !------------------------------------------------------------------------------- !******************************************************************************* ! SECTION II. INTERFACE BLOCKS !******************************************************************************* !------------------------------------------------------------------------------- !  assert, with varying numbers of arguments !------------------------------------------------------------------------------- INTERFACE assert MODULE PROCEDURE assert1 , assert2 , assert3 , assert4 , assert_v END INTERFACE !------------------------------------------------------------------------------- !  assert_eq, with varying numbers of arguments !------------------------------------------------------------------------------- INTERFACE assert_eq MODULE PROCEDURE assert_eq2 , assert_eq3 , assert_eq4 , assert_eqn END INTERFACE CONTAINS !******************************************************************************* ! SECTION III. Error Trapping !******************************************************************************* !------------------------------------------------------------------------------- !  Assert !    This subroutine is modeled after 'assert' in the Numerical Recipes in F90. !    The last argument is a string, the first argument(s) are logicals !    If any of the logicals are false, an error message is printed, and the !    subroutine either stops or continues. !    The optional argument err_class determines if the error is fatal, or just !    a warning. The default action is fatal (execution stops). If the argument !    err_class is present, and its first character is 'w' or 'W', then execution !    continues. !    Different versions have 1, 2, 3, 4, or a vector of logicals. !  Assert, 1 logical !------------------------------------------------------------------------------- SUBROUTINE assert1 ( n1 , string , err_class ) !  Argument Declaration CHARACTER ( LEN =* ), INTENT ( IN ) :: string LOGICAL , INTENT ( IN ) :: n1 CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: err_class !  Local variable declarations CHARACTER ( LEN =* ), PARAMETER :: fmt = '(1x,a,/,1x,a)' CHARACTER ( LEN = 1 ) :: first_char LOGICAL :: lfatal !  Start of executable code IF (. not . n1 ) THEN WRITE ( * , fmt ) 'error: an assertion failed with this tag:' , & & string WRITE ( * , * ) ' n1 = ' , n1 !  Is error Fatal or Warning? lfatal = . TRUE . IF ( PRESENT ( err_class )) THEN first_char = err_class ( 1 : 1 ) IF (( first_char . eq . 'w' ) . or . ( first_char . eq . 'W' )) & lfatal = . FALSE . ENDIF IF ( lfatal ) THEN STOP 'program terminated by assert1' ELSE WRITE ( * , * ) ' end of warning error message from assert1' END IF END IF END SUBROUTINE assert1 !------------------------------------------------------------------------------- !  Assert, 2 logicals !------------------------------------------------------------------------------- SUBROUTINE assert2 ( n1 , n2 , string , err_class ) !  Argument Declaration CHARACTER ( LEN =* ), INTENT ( IN ) :: string LOGICAL , INTENT ( IN ) :: n1 , n2 CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: err_class !  Local variable declarations CHARACTER ( LEN =* ), PARAMETER :: fmt = '(1x,a,/,1x,a)' CHARACTER ( LEN = 1 ) :: first_char LOGICAL :: lfatal !  Start of executable code IF (. not . ( n1 . and . n2 )) THEN WRITE ( * , fmt ) 'error: an assertion failed with this tag:' , & & string WRITE ( * , * ) ' n1, n2 = ' , n1 , n2 !  Is error Fatal or Warning? lfatal = . TRUE . IF ( PRESENT ( err_class )) THEN first_char = err_class ( 1 : 1 ) IF (( first_char . eq . 'w' ) . or . ( first_char . eq . 'W' )) & lfatal = . FALSE . ENDIF IF ( lfatal ) THEN STOP 'program terminated by assert2' ELSE WRITE ( * , * ) ' end of warning error message from assert2' END IF END IF END SUBROUTINE assert2 !------------------------------------------------------------------------------- !  Assert, 3 logicals !------------------------------------------------------------------------------- SUBROUTINE assert3 ( n1 , n2 , n3 , string , err_class ) !  Argument Declaration CHARACTER ( LEN =* ), INTENT ( IN ) :: string LOGICAL , INTENT ( IN ) :: n1 , n2 , n3 CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: err_class !  Local variable declarations CHARACTER ( LEN =* ), PARAMETER :: fmt = '(1x,a,/,1x,a)' CHARACTER ( LEN = 1 ) :: first_char LOGICAL :: lfatal !  Start of executable code IF (. not . ( n1 . and . n2 . and . n3 )) THEN WRITE ( * , fmt ) 'error: an assertion failed with this tag:' , & & string WRITE ( * , * ) ' n1, n2, n3 = ' , n1 , n2 , n3 !  Is error Fatal or Warning? lfatal = . TRUE . IF ( PRESENT ( err_class )) THEN first_char = err_class ( 1 : 1 ) IF (( first_char . eq . 'w' ) . or . ( first_char . eq . 'W' )) & lfatal = . FALSE . ENDIF IF ( lfatal ) THEN STOP 'program terminated by assert3' ELSE WRITE ( * , * ) ' end of warning error message from assert3' END IF END IF END SUBROUTINE assert3 !------------------------------------------------------------------------------- !  Assert, 4 logicals !------------------------------------------------------------------------------- SUBROUTINE assert4 ( n1 , n2 , n3 , n4 , string , err_class ) !  Argument Declaration CHARACTER ( LEN =* ), INTENT ( IN ) :: string LOGICAL , INTENT ( IN ) :: n1 , n2 , n3 , n4 CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: err_class !  Local variable declarations CHARACTER ( LEN =* ), PARAMETER :: fmt = '(1x,a,/,1x,a)' CHARACTER ( LEN = 1 ) :: first_char LOGICAL :: lfatal !  Start of executable code IF (. not . ( n1 . and . n2 . and . n3 . and . n4 )) THEN WRITE ( * , fmt ) 'error: an assertion failed with this tag:' , & & string WRITE ( * , * ) ' n1, n2, n3, n4 = ' , n1 , n2 , n3 , n4 !  Is error Fatal or Warning? lfatal = . TRUE . IF ( PRESENT ( err_class )) THEN first_char = err_class ( 1 : 1 ) IF (( first_char . eq . 'w' ) . or . ( first_char . eq . 'W' )) & lfatal = . FALSE . ENDIF IF ( lfatal ) THEN STOP 'program terminated by assert4' ELSE WRITE ( * , * ) ' end of warning error message from assert4' END IF END IF END SUBROUTINE assert4 !------------------------------------------------------------------------------- !  Assert, vector of logicals !------------------------------------------------------------------------------- SUBROUTINE assert_v ( n , string , err_class ) !  Argument Declaration CHARACTER ( LEN =* ), INTENT ( IN ) :: string LOGICAL , DIMENSION (:), INTENT ( IN ) :: n CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: err_class !  Local variable declarations CHARACTER ( LEN =* ), PARAMETER :: fmt = '(1x,a,/,1x,a)' INTEGER ( iprec ) :: ntot , nfalse , ifirst , i CHARACTER ( LEN = 1 ) :: first_char LOGICAL :: lfatal !  Start of executable code IF (. not . all ( n )) THEN WRITE ( * , fmt ) 'error: an assertion failed with this tag:' , & & string ntot = SIZE ( n ) WRITE ( * , * ) ntot , ' logicals in array. indices of .F. are:' nfalse = 0 DO i = 1 , ntot IF (. not . n ( i )) THEN WRITE ( * , * ) i nfalse = nfalse + 1 END IF END DO WRITE ( * , * ) nfalse , ' logicals are false' !  Is error Fatal or Warning? lfatal = . TRUE . IF ( PRESENT ( err_class )) THEN first_char = err_class ( 1 : 1 ) IF (( first_char . eq . 'w' ) . or . ( first_char . eq . 'W' )) & lfatal = . FALSE . ENDIF IF ( lfatal ) THEN STOP 'program terminated by assert_v' ELSE WRITE ( * , * ) ' end of warning error message from assert_v' END IF END IF END SUBROUTINE assert_v !------------------------------------------------------------------------------- !  Assert_eq !    This subroutine is modeled after 'assert_eq' in the Numerical Recipes in F90. !    The last argument is a string, the first argument are integers !    If any of the integers is different from the first integer, then !    an error message is printed, and the subroutine either STOPs or continues. !    The optional argument err_class determines if the error is fatal, or just !    a warning. The default action is fatal (execution stops). If the argument !    err_class is present, and its first character is 'w' or 'W', then execution !    continues. !    Different versions have 2, 3, 4, or a vector of integer arguments. !    Note: NR had this as a FUNCTION. I have changed it to a subroutine. !  Assert_eq, 2 integer arguments !------------------------------------------------------------------------------- SUBROUTINE assert_eq2 ( n1 , n2 , string , err_class ) !  Argument Declaration CHARACTER ( LEN =* ), INTENT ( IN ) :: string INTEGER , INTENT ( IN ) :: n1 , n2 CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: err_class !  Local variable declarations CHARACTER ( LEN =* ), PARAMETER :: fmt = '(1x,a,/,1x,a)' CHARACTER ( LEN = 1 ) :: first_char LOGICAL :: lfatal !  Start of executable code IF (. not .( n1 == n2 )) THEN WRITE ( * , fmt ) 'error: an assert_eq failed with this tag:' , & & string WRITE ( * , * ) ' n1, n2 = ' , n1 , n2 !  Is error Fatal or Warning? lfatal = . TRUE . IF ( PRESENT ( err_class )) THEN first_char = err_class ( 1 : 1 ) IF (( first_char . eq . 'w' ) . or . ( first_char . eq . 'W' )) & lfatal = . FALSE . ENDIF IF ( lfatal ) THEN STOP 'program terminated by assert_eq2' ELSE WRITE ( * , * ) ' end of warning error message from assert_eq2' END IF END IF END SUBROUTINE assert_eq2 !------------------------------------------------------------------------------- !  Assert_eq, 3 integer arguments !------------------------------------------------------------------------------- SUBROUTINE assert_eq3 ( n1 , n2 , n3 , string , err_class ) !  Argument Declaration CHARACTER ( LEN =* ), INTENT ( IN ) :: string INTEGER , INTENT ( IN ) :: n1 , n2 , n3 CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: err_class !  Local variable declarations CHARACTER ( LEN =* ), PARAMETER :: fmt = '(1x,a,/,1x,a)' CHARACTER ( LEN = 1 ) :: first_char LOGICAL :: lfatal !  Start of executable code IF (. not .( n1 == n2 . and . n2 == n3 )) THEN WRITE ( * , fmt ) 'error: an assert_eq failed with this tag:' , & & string WRITE ( * , * ) ' n1, n2, n3 = ' , n1 , n2 , n3 !  Is error Fatal or Warning? lfatal = . TRUE . IF ( PRESENT ( err_class )) THEN first_char = err_class ( 1 : 1 ) IF (( first_char . eq . 'w' ) . or . ( first_char . eq . 'W' )) & lfatal = . FALSE . ENDIF IF ( lfatal ) THEN STOP 'program terminated by assert_eq3' ELSE WRITE ( * , * ) ' end of warning error message from assert_eq3' END IF END IF END SUBROUTINE assert_eq3 !------------------------------------------------------------------------------- !  Assert_eq, 4 integer arguments !------------------------------------------------------------------------------- SUBROUTINE assert_eq4 ( n1 , n2 , n3 , n4 , string , err_class ) !  Argument Declaration CHARACTER ( LEN =* ), INTENT ( IN ) :: string INTEGER , INTENT ( IN ) :: n1 , n2 , n3 , n4 CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: err_class !  Local variable declarations CHARACTER ( LEN =* ), PARAMETER :: fmt = '(1x,a,/,1x,a)' CHARACTER ( LEN = 1 ) :: first_char LOGICAL :: lfatal !  Start of executable code IF (. not .( n1 == n2 . and . n2 == n3 . and . n3 == n4 )) THEN WRITE ( * , fmt ) 'error: an assert_eq failed with this tag:' , & & string WRITE ( * , * ) ' n1, n2, n3, n4 = ' , n1 , n2 , n3 , n4 !  Is error Fatal or Warning? lfatal = . TRUE . IF ( PRESENT ( err_class )) THEN first_char = err_class ( 1 : 1 ) IF (( first_char . eq . 'w' ) . or . ( first_char . eq . 'W' )) & lfatal = . FALSE . ENDIF IF ( lfatal ) THEN STOP 'program terminated by assert_eq4' ELSE WRITE ( * , * ) ' end of warning error message from assert_eq4' END IF END IF END SUBROUTINE assert_eq4 !------------------------------------------------------------------------------- !  Assert_eq, a vector of integers !------------------------------------------------------------------------------- SUBROUTINE assert_eqn ( nn , string , err_class ) !  Argument Declaration CHARACTER ( LEN =* ), INTENT ( IN ) :: string INTEGER , DIMENSION (:), INTENT ( IN ) :: nn INTEGER :: ntot , nne , i CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: err_class !  Local variable declarations CHARACTER ( LEN =* ), PARAMETER :: fmt = '(1x,a,/,1x,a)' CHARACTER ( LEN = 1 ) :: first_char LOGICAL :: lfatal !  Start of executable code IF (. not .( all ( nn ( 2 :) == nn ( 1 )))) THEN WRITE ( * , fmt ) 'error: an assert_eq failed with this tag:' , & & string ntot = SIZE ( nn ) WRITE ( * , * ) ntot , ' integers in the array.' WRITE ( * , * ) nn ( 1 ), ' is the first value in the array' WRITE ( * , * ) ' index    value  (of those .ne. to first)' nne = 0 DO i = 2 , ntot IF ( nn ( i ) . ne . nn ( 1 )) THEN WRITE ( * , * ) i , nn ( i ) nne = nne + 1 END IF END DO WRITE ( * , * ) ' There are ' , nne , ' integers .ne. to first' !  Is error Fatal or Warning? lfatal = . TRUE . IF ( PRESENT ( err_class )) THEN first_char = err_class ( 1 : 1 ) IF (( first_char . eq . 'w' ) . or . ( first_char . eq . 'W' )) & lfatal = . FALSE . ENDIF IF ( lfatal ) THEN STOP 'program terminated by assert_eqn' ELSE WRITE ( * , * ) ' end of warning error message from assert_eqn' END IF END IF END SUBROUTINE assert_eqn !------------------------------------------------------------------------------- !  SPH: Changed int to INTEGER (from INTEGER(iprec)) !  Subroutine err_fatal !    This subroutine is for fatal errors. !    The first argument is a string, and there are optional arguments for !    character, real, integer and logical variables. !    (The user should use KEYWORDs for the optional arguments) !    When called, err_fatal prints the first argument, and all of the !    optional arguments, and then STOPs the program. !------------------------------------------------------------------------------- SUBROUTINE err_fatal ( string , char , real1 , int , log ) !  Argument Declaration CHARACTER ( LEN =* ), INTENT ( IN ) :: string CHARACTER ( LEN =* ), OPTIONAL , INTENT ( IN ) :: char REAL ( rprec ), OPTIONAL , INTENT ( IN ) :: real1 INTEGER , OPTIONAL , INTENT ( IN ) :: int LOGICAL , OPTIONAL , INTENT ( IN ) :: log !  Local variable declarations CHARACTER ( LEN =* ), PARAMETER :: fmt = '(1x,a,/,1x,a)' !  Start of executable code WRITE ( * , fmt ) 'FATAL ERROR: ' , string IF ( PRESENT ( char )) THEN WRITE ( * , * ) ' char argument = ' , char END IF IF ( PRESENT ( real1 )) THEN WRITE ( * , * ) ' real argument = ' , real1 END IF IF ( PRESENT ( int )) THEN WRITE ( * , * ) ' integer argument = ' , int END IF IF ( PRESENT ( log )) THEN WRITE ( * , * ) ' logical argument = ' , log END IF STOP 'program terminated by err_fatal' END SUBROUTINE err_fatal !------------------------------------------------------------------------------- ! Warning !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- !  Subroutine err_warn !    This subroutine is for warnings. Execution is not stopped. !    The first argument is a string, and there are optional arguments for !    character, real, integer and logical variables. !    (The user should use KEYWORDs for the optional arguments) !    When called, err_warn prints the first argument, and all of the !    optional arguments, and then returns. !------------------------------------------------------------------------------- SUBROUTINE err_warn ( string , char , real , int , log ) !  Argument Declaration CHARACTER ( LEN =* ), INTENT ( IN ) :: string CHARACTER ( LEN =* ), OPTIONAL , INTENT ( IN ) :: char REAL ( rprec ), OPTIONAL , INTENT ( IN ) :: real INTEGER , OPTIONAL , INTENT ( IN ) :: int LOGICAL , OPTIONAL , INTENT ( IN ) :: log !  Local variable declarations CHARACTER ( LEN =* ), PARAMETER :: fmt = '(1x,a,/,1x,a)' !  Start of executable code WRITE ( * , fmt ) 'WARNING ERROR: ' , string IF ( PRESENT ( char )) THEN WRITE ( * , * ) ' char argument = ' , char END IF IF ( PRESENT ( real )) THEN WRITE ( * , * ) ' real argument = ' , real END IF IF ( PRESENT ( int )) THEN WRITE ( * , * ) ' integer argument = ' , int END IF IF ( PRESENT ( log )) THEN WRITE ( * , * ) ' logical argument = ' , log END IF RETURN END SUBROUTINE err_warn !******************************************************************************* ! SECTION IV.   Input-Output Utilities !******************************************************************************* !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- SUBROUTINE svdproducts ( b , svprod , numzeros ) ! This subroutine takes as its first argument an arbitrary real matrix B. ! It's purpose is to find the variable in column-space that is ! \"most redundant\" ! It returns a vector of singular value products, computed by eliminating ! individual columns of B, and finding the product of the Singular Values (SV) ! for the resulting column-reduced matrix. ! For example, suppose a matrix B has 13 columns, and svprod(7) is the maximum ! of all the SV products. Thus eliminating column 7 yields the reduced matrix ! with the largest SV product. Variable 7 in the column space is then ! the \"most redundant\" variable. !  Note that when B is a normalized Jacobian matrix, a surface of !  constant-chi-squared in the column-space is an !  ellipsoid, and the volume of the ellipsoid is proportional to the !  reciprocal of the product of the singular values. ! There is a problem if there are TWO (or more) variables that essentially ! give ZERO singular values. (For example, if B has 13 columns, and ! columns 7 and 9 are both zero.) Then the SV-product array will all be zero, and ! won't be able to distinguish the \"most redundant\" variable. ! A solution to this problem is to keep track of the number of zero SVs. ! These are stored in the numzeros array. ! Then the column number with the MINIMUM number of zero singular values ! will be (one of) the \"most-redundant\" variables. !  The length of the SV product vector must be equal to the number of columns of B. !  The length of the numzeros vector must be equal to the number of columns of B !  JDH 2008-02-21, 24 !  JDH 2008-05-19 - CHanged for SV ratios to SV product value USE stel_kinds IMPLICIT NONE !  Declare Arguments REAL ( rprec ), DIMENSION (:,:), INTENT ( inout ) :: b REAL ( rprec ), DIMENSION (:), INTENT ( inout ) :: svprod INTEGER , DIMENSION (:), INTENT ( inout ) :: numzeros !  Declare local variables INTEGER , DIMENSION ( 2 ) :: dimlens INTEGER :: nrowb , ncolb , nrow , ncol , minrowcol , l_work_svd , ier1 INTEGER :: jelim , info_svd REAL ( rprec ) :: svp REAL ( rprec ), DIMENSION (:,:), ALLOCATABLE :: c REAL ( rprec ), PARAMETER :: tiny = 1.e-14_rprec REAL ( rprec ), PARAMETER :: verytiny = 1.e-28_rprec REAL ( rprec ), DIMENSION (:), ALLOCATABLE :: work_svd , svec CHARACTER ( len =* ), PARAMETER :: sub_name = & & 'svdproducts: ' !  Start of executable code !  Array sizes dimlens = SHAPE ( b ) nrowb = dimlens ( 1 ) ncolb = dimlens ( 2 ) CALL assert ( nrowb . ge . 2 , sub_name // 'nrowb too small' ) CALL assert ( ncolb . ge . 2 , sub_name // 'ncolb too small' ) CALL assert_eq ( ncolb , SIZE ( svprod ), sub_name // 'svprod wrong size' ) CALL assert_eq ( ncolb , SIZE ( numzeros ), sub_name // & & 'numzeros wrong size' ) !  Allocate space for the number-columns-reduced-by-one arrays nrow = nrowb ncol = ncolb - 1 minrowcol = min ( nrow , ncol ) l_work_svd = 5 * MAX ( nrow , ncol ) ALLOCATE ( work_svd ( l_work_svd ), stat = ier1 ) CALL assert_eq ( 0 , ier1 , sub_name // 'Allocate work_svd' ) ALLOCATE ( c ( nrow , ncol ), stat = ier1 ) CALL assert_eq ( 0 , ier1 , sub_name // 'Allocate c' ) ALLOCATE ( svec ( minrowcol ), stat = ier1 ) CALL assert_eq ( 0 , ier1 , sub_name // 'Allocate svec' ) !  Loop over the column to be eliminated DO jelim = 1 , ncolb c ( 1 : nrow , 1 : jelim - 1 ) = b ( 1 : nrow , 1 : jelim - 1 ) c ( 1 : nrow , jelim : ncolb - 1 ) = b ( 1 : nrow , jelim + 1 : ncolb ) ! Next line commented out by MJL 2017-08-15 since not needed for mini_libstell. !         CALL dgesvd('None','None',nrow,ncol,c,nrow,                           & !     &      svec,c,nrow,c,ncol,work_svd,l_work_svd,info_svd) CALL assert_eq ( 0 , info_svd , sub_name // 'dgesvd problem' ) svp = PRODUCT ( svec ) numzeros ( jelim ) = COUNT ( svec < tiny ) svprod ( jelim ) = svp END DO RETURN END SUBROUTINE svdproducts !------------------------------------------------------------------------------- !------------------------------------------------------------------------------- SUBROUTINE most_redundant ( a , ncol_array , svprod_array , j_col_elim ) !  This subroutine orders the variables in the column-space of a matrix A from !  \"most redundant\" to \"least redundant\". Redundancy is measured by an increase !  in the product of singular values when the column is eliminated. !  Arguments (Input) !    A               Input: An array with nrow rows and ncol columns !    ncol_array      Integer array (ncol): number of columns of A remaining !    svprod_array    Real array (ncol): singular value product !    j_col_elim      Integer array (ncol): index of the column of A !                    (in the ORIGINAL ORDERING) that was eliminated most recently ! !  The subroutine makes repeated calls to the related subroutine svdproducts. ! !  JDH 2008-02-21 !  JDH 2008-05-19 - Changed from SV ratios to SV products. USE stel_kinds IMPLICIT NONE !------------------------------------------------------------------------------- !  Declare Arguments !------------------------------------------------------------------------------- REAL ( rprec ), DIMENSION (:,:), INTENT ( inout ) :: a REAL ( rprec ), DIMENSION (:), INTENT ( inout ) :: svprod_array INTEGER , DIMENSION (:), INTENT ( inout ) :: ncol_array , j_col_elim !------------------------------------------------------------------------------- !  Declare local variables !------------------------------------------------------------------------------- REAL ( rprec ), PARAMETER :: tiny = 1.e-14_rprec REAL ( rprec ), PARAMETER :: verytiny = 1.e-28_rprec !   Array dimensions, error status, indices, etc INTEGER , DIMENSION ( 2 ) :: dimlens INTEGER :: nrowa , ncola , nrow , ncol , minrowcol , ier1 , ncolb INTEGER :: i , ncolelim , minnz , k , kk !   For calling the SVD subroutine REAL ( rprec ), DIMENSION (:), ALLOCATABLE :: work_svd , svec INTEGER :: l_work_svd , info_svd !   Arrays for the call to svdproducts REAL ( rprec ), DIMENSION (:,:), ALLOCATABLE :: atemp , b REAL ( rprec ), DIMENSION (:), ALLOCATABLE :: svprod INTEGER , DIMENSION (:), ALLOCATABLE :: numzeros !   Keeping track of the j-k indices, locations INTEGER , DIMENSION ( 1 ) :: k_minnz_a , k_maxprod_a INTEGER , DIMENSION (:), ALLOCATABLE :: j_now ! REAL ( rprec ) :: maxprod CHARACTER ( len =* ), PARAMETER :: sub_name = & & 'most_redundant: ' !------------------------------------------------------------------------------- !  Start of executable code !------------------------------------------------------------------------------- !  Array sizes dimlens = SHAPE ( a ) nrowa = dimlens ( 1 ) ncola = dimlens ( 2 ) CALL assert ( nrowa . ge . 2 , sub_name // 'nrowa too small' ) CALL assert ( ncola . ge . 2 , sub_name // 'ncola too small' ) CALL assert_eq ( ncola , SIZE ( ncol_array ), sub_name // & & 'ncol_array wrong size' ) CALL assert_eq ( ncola , SIZE ( svprod_array ), sub_name // & & 'svprod_array wrong size' ) CALL assert_eq ( ncola , SIZE ( j_col_elim ), sub_name // & & 'j_col_elim wrong size' ) !  Allocations for local arrays nrow = nrowa ncol = ncola minrowcol = min ( nrow , ncol ) l_work_svd = 5 * MAX ( nrow , ncol ) ALLOCATE ( work_svd ( l_work_svd ), stat = ier1 ) CALL assert_eq ( 0 , ier1 , sub_name // 'Allocate work_svd' ) ALLOCATE ( atemp ( nrow , ncol ), b ( nrow , ncol ), stat = ier1 ) CALL assert_eq ( 0 , ier1 , sub_name // 'Allocate atemp, b' ) ALLOCATE ( svec ( minrowcol ), stat = ier1 ) CALL assert_eq ( 0 , ier1 , sub_name // 'Allocate svec' ) ALLOCATE ( svprod ( ncola ), stat = ier1 ) CALL assert_eq ( 0 , ier1 , sub_name // 'Allocate svprod' ) ALLOCATE ( numzeros ( ncola ), stat = ier1 ) CALL assert_eq ( 0 , ier1 , sub_name // 'Allocate numzeros' ) ALLOCATE ( j_now ( ncola ), stat = ier1 ) CALL assert_eq ( 0 , ier1 , sub_name // 'Allocate j_now' ) !  All Columns - do SVD and find ratio b = a ! Next line commented out by MJL 2017-08-15 since not needed for mini_libstell. !      CALL dgesvd('None','None',nrow,ncol,b,nrow,                              & !     &   svec,b,nrow,b,ncol,work_svd,l_work_svd,info_svd) CALL assert_eq ( 0 , info_svd , sub_name // 'dgesvd problem' ) ncol_array ( 1 ) = ncola svprod_array ( 1 ) = PRODUCT ( svec ) j_col_elim ( 1 ) = 0 !  Initialize array of j-indices !  Used to convert from k-index (current column number, B matrix) !  to j-index (original column number, A matrix) DO i = 1 , ncola j_now ( i ) = i END DO !  Loop over the number of columns to be eliminated atemp = a DO ncolelim = 1 , ncola - 2 ncolb = ncola + 1 - ncolelim b ( 1 : nrow , 1 : ncolb ) = atemp ( 1 : nrow , 1 : ncolb ) CALL svdproducts ( b ( 1 : nrow , 1 : ncolb ), svprod ( 1 : ncolb ), & & numzeros ( 1 : ncolb )) minnz = MINVAL ( numzeros ( 1 : ncolb )) k_minnz_a = MINLOC ( numzeros ( 1 : ncolb )) maxprod = MAXVAL ( svprod ( 1 : ncolb )) k_maxprod_a = MAXLOC ( svprod ( 1 : ncolb )) IF ( minnz . gt . 0 ) THEN k = k_minnz_a ( 1 ) ELSE k = k_maxprod_a ( 1 ) ENDIF !         WRITE(*,*) 'products', svprod(1:ncolb) !         WRITE(*,*) 'numzeros', numzeros(1:ncolb) ncol_array ( ncolelim + 1 ) = ncola - ncolelim svprod_array ( ncolelim + 1 ) = maxprod j_col_elim ( ncolelim + 1 ) = j_now ( k ) DO kk = k , ncola - ncolelim + 1 j_now ( kk ) = j_now ( kk + 1 ) atemp ( 1 : nrow , kk ) = atemp ( 1 : nrow , kk + 1 ) END DO END DO !  Define last elements. Make o choice between last two variables. !  Put the last two variables into j_col_elim and !  into the (real) svprod_array. ncol_array ( ncola ) = 1 svprod_array ( ncola ) = j_now ( 2 ) j_col_elim ( ncola ) = j_now ( 1 ) RETURN END SUBROUTINE most_redundant END MODULE v3_utilities","tags":"","loc":"sourcefile/v3_utilities.f.html"},{"title":"stel_constants.f â€“ stella","text":"Contents Modules stel_constants Source Code stel_constants.f Source Code MODULE stel_constants USE stel_kinds , ONLY : rprec , dp !---------------------------------------------------------------------- !  Mathematical constants !---------------------------------------------------------------------- REAL ( dp ), PARAMETER :: pi = 3.14159265358979323846264338328_dp REAL ( dp ), PARAMETER :: pio2 = pi / 2 REAL ( dp ), PARAMETER :: twopi = 2 * pi REAL ( dp ), PARAMETER :: sqrt2 = 1.41421356237309504880168872_dp REAL ( dp ), PARAMETER :: degree = twopi / 360 REAL ( dp ), PARAMETER :: one = 1 REAL ( dp ), PARAMETER :: zero = 0 !---------------------------------------------------------------------- !  Physical constants !------------------------------------------------------------------ REAL ( dp ), PARAMETER :: mu0 = 2 * twopi * 1.0e-7_dp END MODULE stel_constants","tags":"","loc":"sourcefile/stel_constants.f.html"},{"title":"ezcdf_opncls.f90 â€“ stella","text":"Contents Modules ezcdf_opncls Source Code ezcdf_opncls.f90 Source Code MODULE ezcdf_opncls !DEC$ IF DEFINED (NETCDF) INTERFACE cdfOpn MODULE PROCEDURE ezcdf_open END INTERFACE INTERFACE cdf_open MODULE PROCEDURE ezcdf_open END INTERFACE INTERFACE cdfCls MODULE PROCEDURE ezcdf_close END INTERFACE INTERFACE cdf_close MODULE PROCEDURE ezcdf_close END INTERFACE CONTAINS subroutine ezcdf_open ( ncid , filename , opt , ier ) ! Create/open cdf file ! 03/09/99 C.Ludescher ! !  opt values: !    \"R\" -- readonly, existing file !    \"W\" -- write new file !    \"M\" -- \"Modify\" -- read/write data in existing file !                       (but structure of file does not change) !    \"A\" -- \"Append\" -- add new structure (define new data items) !                       in existing file.  Existing items can also !                       be read/written, but only after *new* items !                       are first defined and then written. ! !  for both \"W\" and \"A\" modes, the file is opened in \"define data mode\". ! include \"netcdf.inc\" INTEGER , intent ( out ) :: ncid character * ( * ), intent ( in ) :: filename character * 1 , intent ( in ) :: opt integer , optional , intent ( out ) :: ier integer :: status if ( opt == 'w' . or . opt == 'W' ) then ! New file... start in \"define mode\". status = nf_create ( filename , IOR ( NF_CLOBBER , NF_64BIT_OFFSET ), ncid ) call handle_err ( status , filename , 'cdfcrt' , 'nf_create' ) else if ( opt == 'm' . or . opt == 'M' ) then ! Open existing file for read/write modifications... status = nf_open ( filename , nf_write , ncid ) call handle_err ( status , filename , 'cdfopn' , 'nf_open' ) else if ( opt == 'a' . or . opt == 'A' ) then ! Open existing file for read/write modifications... status = nf_open ( filename , nf_write , ncid ) call handle_err ( status , filename , 'cdfopn' , 'nf_open' ) if ( status == NF_NOERR ) then status = nf_redef ( ncid ) ! start in \"define mode\". call handle_err ( status , filename , 'cdfopn' , 'nf_redef' ) end if else ! Open for readonly status = nf_open ( filename , nf_nowrite , ncid ) call handle_err ( status , filename , 'cdfopn' , 'nf_open' ) end if if ( PRESENT ( ier )) then if ( status /= NF_NOERR ) then ier = 1 else ier = 0 end if end if return end subroutine ezcdf_open subroutine ezcdf_close ( ncid , ier ) include \"netcdf.inc\" INTEGER , INTENT ( in ) :: ncid integer , optional , intent ( out ) :: ier INTEGER status status = nf_close ( ncid ) call handle_err ( status , ' ' , 'cdfcls' , 'nf_close' ) if ( PRESENT ( ier )) ier = status end subroutine ezcdf_close !DEC$ ENDIF END MODULE ezcdf_opncls","tags":"","loc":"sourcefile/ezcdf_opncls.f90.html"},{"title":"fluxes.f90 â€“ stella","text":"Contents Programs fluxes Source Code fluxes.f90 Source Code program fluxes ! takes argument 1 as .fluxes output file path ! argument 2 as number of time steps in .fluxes file ! argument 3 as number of species in simulation ! argument 4 as starting time for time average ! writes the time average of the fluxes to screen implicit none integer :: iargc integer :: flxunit = 101 integer :: it , nstep , nspec integer :: target_it real :: tstart = 0.0 logical :: tstart_flag character ( 500 ) :: line character ( 500 ) :: flxfile real , dimension (:), allocatable :: time real , dimension (:, :), allocatable :: pflx , vflx , qflx real , dimension (:), allocatable :: pflxavg , vflxavg , qflxavg , pi_over_q call getarg ( 1 , flxfile ) call getarg ( 2 , line ) read ( line , * ) nstep call getarg ( 3 , line ) read ( line , * ) nspec if ( iargc () > 3 ) then call getarg ( 4 , line ) read ( line , * ) tstart end if write ( * , * ) nstep , tstart , nspec , trim ( flxfile ) allocate ( time ( nstep )) allocate ( pflx ( nspec , nstep )) allocate ( vflx ( nspec , nstep )) allocate ( qflx ( nspec , nstep )) allocate ( pflxavg ( nspec )) allocate ( vflxavg ( nspec )) allocate ( qflxavg ( nspec )) allocate ( pi_over_q ( nspec )) target_it = 1 tstart_flag = . true . open ( unit = flxunit , file = trim ( flxfile ) // \".fluxes\" ) read ( flxunit , * ) line do it = 1 , nstep read ( flxunit , * ) time ( it ), pflx (:, it ), vflx (:, it ), qflx (:, it ) ! find the time index corresponding to the requested start time if ( tstart_flag . and . time ( it ) > tstart ) then target_it = it tstart_flag = . false . end if end do call time_average ( time , target_it , pflx , pflxavg ) call time_average ( time , target_it , vflx , vflxavg ) call time_average ( time , target_it , qflx , qflxavg ) call time_average ( time , target_it , vflx / qflx , pi_over_q ) close ( flxunit ) open ( flxunit , file = trim ( flxfile ) // \".fluxes_tavg\" ) write ( flxunit , * ) 'pflx: ' , pflxavg , 'vflx: ' , vflxavg , 'qflx: ' , qflxavg , 'vflx/qflx: ' , pi_over_q , vflxavg / qflxavg close ( flxunit ) deallocate ( time ) deallocate ( pflx , vflx , qflx ) deallocate ( pflxavg , vflxavg , qflxavg , pi_over_q ) contains subroutine time_average ( t , it , flx , flxavg ) implicit none real , dimension (:), intent ( in ) :: t integer , intent ( in ) :: it real , dimension (:, :), intent ( in ) :: flx real , dimension (:), intent ( out ) :: flxavg integer :: i , nt nt = size ( t ) flxavg = 0.5 * ( t ( it + 1 ) - t ( it )) * flx (:, it ) do i = it + 1 , nt - 1 flxavg = flxavg + ( t ( i + 1 ) - t ( i )) * flx (:, i ) end do flxavg = flxavg + 0.5 * ( t ( nt ) - t ( nt - 1 )) * flx (:, nt ) flxavg = flxavg / ( t ( nt ) - t ( it )) end subroutine time_average end program fluxes","tags":"","loc":"sourcefile/fluxes.f90.html"},{"title":"git_version.f90 â€“ stella","text":"Contents Modules git_version Source Code git_version.f90 Source Code !> SPDX-License-Identifier: MIT !> !> Some helper functions for returning a git commit or tag compiled !> into the binary. The implementations are in a submodule to avoid !> recompilation cascades. module git_version implicit none interface !> Returns the git version from `git describe` !> !> This looks like: `{tag}-g{hash}[-dirty]` module function get_git_version () character (:), allocatable :: get_git_version end function get_git_version !> Returns the git hash of the current commit module function get_git_hash ( length_in ) integer , optional , intent ( in ) :: length_in integer :: length character (:), allocatable :: get_git_hash end function get_git_hash !> Return \"-dirty\" if the repository has modifications to tracked !> files, or the empty string otherwise module function get_git_state () character (:), allocatable :: get_git_state end function get_git_state !> Returns the short date (YYYY-MM-DD) of the current commit module function get_git_date () character ( len = 10 ) :: get_git_date end function get_git_date end interface end module git_version","tags":"","loc":"sourcefile/git_version.f90.html"},{"title":"git_version_impl.fpp â€“ stella","text":"Contents Submodules git_version_impl Source Code git_version_impl.fpp Source Code ! SPDX-License-Identifier: MIT submodule ( git_version ) git_version_impl implicit none #ifndef GIT_SHA1 #define GIT_SHA1 \"unknown\" #endif #ifndef GIT_STATE #define GIT_STATE \"unknown\" #endif #ifndef GIT_VERSION #define GIT_VERSION \"unknown\" #endif #ifndef GIT_DATE #define GIT_DATE \"unknown\" #endif contains module procedure get_git_version integer , parameter :: max_length = 40 integer :: length length = min ( max_length , len ( GIT_VERSION )) allocate ( character ( length ) :: get_git_version ) get_git_version = GIT_VERSION ( 1 : length ) get_git_version = trim ( get_git_version ) end procedure get_git_version module procedure get_git_hash integer :: length length = 7 if ( present ( length_in )) then if ( length_in <= 40 ) then length = length_in end if end if allocate ( character ( length ) :: get_git_hash ) get_git_hash = GIT_SHA1 ( 1 : length ) end procedure get_git_hash module procedure get_git_state if ( GIT_STATE == \"clean\" ) then get_git_state = \"\" else get_git_state = \"-dirty\" end if end procedure get_git_state module procedure get_git_date get_git_date = GIT_DATE end procedure get_git_date end submodule git_version_impl","tags":"","loc":"sourcefile/git_version_impl.fpp.html"},{"title":"netcdf_utils.fpp â€“ stella","text":"Contents Modules netcdf_utils Source Code netcdf_utils.fpp Source Code # include \"define.inc\" module netcdf_utils # ifdef NETCDF use netcdf , only : NF90_FLOAT , NF90_DOUBLE use netcdf , only : NF90_NOWRITE , NF90_CLOBBER , NF90_NOERR use netcdf , only : nf90_strerror use netcdf , only : nf90_inquire_variable use netcdf , only : nf90_inquire_dimension use netcdf , only : nf90_open , nf90_close use netcdf , only : nf90_inq_varid use netcdf , only : NF90_INT # endif implicit none public :: netcdf_error public :: get_netcdf_code_precision public :: check_netcdf_file_precision public :: netcdf_real , kind_nf , netcdf_int private # ifdef NETCDF integer , parameter :: kind_nf = kind ( NF90_NOERR ) # else integer , parameter :: kind_nf = kind ( 1 ) # endif integer ( kind_nf ) :: netcdf_real = 0 , netcdf_int = 0 logical :: test = . false . contains function get_netcdf_code_precision () result ( code_real ) use constants , only : pi , kind_rs , kind_rd use file_utils , only : error_unit integer :: code_real # ifdef NETCDF ! second condition for Cray if (( kind ( pi ) == kind_rs ) . or . ( kind_rs == kind_rd )) then code_real = NF90_FLOAT else if ( kind ( pi ) == kind_rd ) then code_real = NF90_DOUBLE else write ( error_unit (), * ) & 'ERROR: precision mismatch in get_netcdf_code_precision' end if # endif end function get_netcdf_code_precision subroutine check_netcdf_file_precision ( ncid , filename ) use file_utils , only : error_unit integer ( kind_nf ), intent ( in ), optional :: ncid character ( * ), intent ( in ), optional :: filename # ifdef NETCDF integer ( kind_nf ) :: file_real integer ( kind_nf ) :: ist , ncid_private , tid integer :: ierr !SET integer type: NOTE: This is not checked for compatability!!!! GGH 20 JAN 2012 netcdf_int = NF90_INT ist = NF90_NOERR file_real = - 1 if ( present ( ncid )) then if ( present ( filename )) then ierr = error_unit () write ( ierr , * ) 'WARNING: in calling check_netcdf_file_precision' write ( ierr , * ) & 'WARNING: both filename and ncid given -- filename ignored' end if ncid_private = ncid else if ( present ( filename )) then ist = nf90_open ( filename , NF90_NOWRITE , ncid_private ) if ( test ) write ( error_unit (), * ) & 'opened netcdf file ' , trim ( filename ), ' with ncid: ' , & ncid_private , ' in check_netcdf_file_precision' if ( ist /= NF90_NOERR ) then call netcdf_error ( ist , file = filename ) return end if else ierr = error_unit () write ( ierr , * ) 'ERROR: in calling check_netcdf_file_precision' write ( ierr , * ) 'ERROR: either filename or ncid should be given' return end if end if ist = nf90_inq_varid ( ncid_private , 't0' , tid ) if ( ist /= NF90_NOERR ) call netcdf_error ( ist , var = 't0' ) ! get file_real if ( ist == NF90_NOERR ) then ist = nf90_inquire_variable ( ncid_private , tid , xtype = file_real ) if ( ist /= NF90_NOERR ) call netcdf_error ( ist , ncid_private , tid ) end if if (. not . present ( ncid )) then ist = nf90_close ( ncid_private ) if ( ist /= NF90_NOERR ) call netcdf_error ( ist , file = filename ) end if ! check if file_real == code_real if ( file_real /= netcdf_real ) then ierr = error_unit () write ( ierr , * ) 'WARNING: precision mismatch in input netcdf file and running code' if ( file_real == NF90_FLOAT ) then write ( ierr , * ) 'WARNING: file_real = NF90_FLOAT' else if ( file_real == NF90_DOUBLE ) then write ( ierr , * ) 'WARNING: file_real = NF90_DOUBLE' else write ( ierr , * ) 'WARNING: unknown file_real' , file_real end if if ( netcdf_real == NF90_FLOAT ) then write ( ierr , * ) 'WARNING: code_real = NF90_FLOAT' else if ( netcdf_real == NF90_DOUBLE ) then write ( ierr , * ) 'WARNING: code_real = NF90_DOUBLE' else write ( ierr , * ) 'WARNING: unknown code_real' end if end if # endif end subroutine check_netcdf_file_precision subroutine netcdf_error & ( istatus , ncid , varid , dimid , file , dim , var , att , message , abort ) use file_utils , only : error_unit use mp , only : proc0 , finish_mp # ifdef NETCDF use netcdf , only : NF90_GLOBAL # endif integer ( kind_nf ), intent ( in ) :: istatus integer ( kind_nf ), intent ( in ), optional :: ncid integer ( kind_nf ), intent ( in ), optional :: varid integer ( kind_nf ), intent ( in ), optional :: dimid character ( * ), intent ( in ), optional :: file character ( * ), intent ( in ), optional :: dim character ( * ), intent ( in ), optional :: var character ( * ), intent ( in ), optional :: att character ( * ), intent ( in ), optional :: message logical , intent ( in ), optional :: abort # ifdef NETCDF integer ( kind_nf ) :: ist integer :: ierr character ( 20 ) :: varname , dimname ierr = error_unit () write ( ierr , '(2a)' , advance = 'no' ) 'ERROR: ' , trim ( nf90_strerror ( istatus )) ! TT: If $ control fails, there is an alternative advance='no' specifier if ( present ( file )) & write ( ierr , '(2a)' , advance = 'no' ) ' in file: ' , trim ( file ) if ( present ( dim )) & write ( ierr , '(2a)' , advance = 'no' ) ' in dimension: ' , trim ( dim ) if ( present ( var )) & write ( ierr , '(2a)' , advance = 'no' ) ' in variable: ' , trim ( var ) if ( present ( varid )) then if ( present ( ncid )) then if (( varid == NF90_GLOBAL ) . and . present ( att )) then write ( ierr , '(2a)' ) ' in global attribute: ' , trim ( att ) return else ist = nf90_inquire_variable ( ncid , varid , varname ) if ( ist == NF90_NOERR ) then write ( ierr , '(a,i8,2a)' , advance = 'no' ) ' in varid: ' , varid , & & ' variable name: ' , trim ( varname ) else write ( ierr , * ) write ( ierr , '(3a,i8,a,i8)' , advance = 'no' ) 'ERROR in netcdf_error: ' , & trim ( nf90_strerror ( ist )), ' in varid: ' , varid , & ', ncid: ' , ncid end if end if if ( present ( att )) & write ( ierr , '(2a)' ) ' with the attribute: ' , trim ( att ) else write ( ierr , * ) write ( ierr , '(2a)' , advance = 'no' ) 'ERROR in netcdf_error: ' , & & 'ncid missing while varid present in the argument' end if end if if ( present ( dimid )) then if ( present ( ncid )) then ist = nf90_inquire_dimension ( ncid , dimid , dimname ) if ( ist == NF90_NOERR ) then write ( ierr , '(a,i8,2a)' , advance = 'no' ) ' in dimid: ' , dimid , & & ' dimension name: ' , trim ( dimname ) else write ( ierr , * ) write ( ierr , '(3a,i8,a,i8)' , advance = 'no' ) 'ERROR in netcdf_error: ' , & trim ( nf90_strerror ( ist )), ' in dimid: ' , dimid , & ', ncid: ' , ncid end if else write ( ierr , * ) write ( ierr , '(2a)' , advance = 'no' ) 'ERROR in netcdf_error: ' , & & 'ncid missing while dimid present in the argument' end if end if if ( present ( message )) write ( ierr , '(a)' , advance = 'no' ) trim ( message ) ! append line-break write ( ierr , * ) ! if error is detected, the program should abort immediately if ( present ( abort )) then if ( abort ) then call finish_mp if ( proc0 ) stop 'Aborted by netcdf_error' stop end if end if # endif end subroutine netcdf_error end module netcdf_utils","tags":"","loc":"sourcefile/netcdf_utils.fpp.html"},{"title":"linear_solve.f90 â€“ stella","text":"Contents Modules linear_solve Source Code linear_solve.f90 Source Code module linear_solve implicit none public :: lu_decomposition public :: lu_back_substitution public :: lu_inverse public :: imaxloc interface lu_decomposition module procedure lu_decomposition_real module procedure lu_decomposition_complex end interface interface lu_back_substitution module procedure lu_back_substitution_real module procedure lu_back_substitution_real_complex module procedure lu_back_substitution_complex module procedure lu_back_substitution_matrix_real module procedure lu_back_substitution_matrix_complex end interface interface lu_inverse module procedure lu_inverse_real module procedure lu_inverse_complex end interface contains subroutine lu_decomposition_real ( lu , idx , d ) implicit none real , dimension (:, :), intent ( in out ) :: lu integer , dimension (:), intent ( out ) :: idx real , intent ( out ) :: d real , parameter :: zero = 1.0e-20 real , dimension ( size ( lu , 1 )) :: vv real , dimension ( size ( lu , 2 )) :: dum integer :: j , n , imax n = size ( lu , 1 ) d = 1.0 vv = maxval ( abs ( lu ), dim = 2 ) if ( any ( vv == 0.0 )) & write ( * , * ) 'singular matrix in lu_decomposition' vv = 1.0 / vv do j = 1 , n imax = ( j - 1 ) + imaxloc ( vv ( j : n ) * abs ( lu ( j : n , j ))) if ( j /= imax ) then dum = lu ( imax , :) lu ( imax , :) = lu ( j , :) lu ( j , :) = dum d = - d vv ( imax ) = vv ( j ) end if idx ( j ) = imax if ( lu ( j , j ) == 0.0 ) lu ( j , j ) = zero lu ( j + 1 : n , j ) = lu ( j + 1 : n , j ) / lu ( j , j ) lu ( j + 1 : n , j + 1 : n ) = lu ( j + 1 : n , j + 1 : n ) - spread ( lu ( j + 1 : n , j ), 2 , n - j ) & * spread ( lu ( j , j + 1 : n ), 1 , n - j ) end do end subroutine lu_decomposition_real subroutine lu_decomposition_complex ( lu , idx , d ) implicit none complex , dimension (:, :), intent ( in out ) :: lu integer , dimension (:), intent ( out ) :: idx real , intent ( out ) :: d real , parameter :: zero = 1.0e-20 real , dimension ( size ( lu , 1 )) :: vv complex , dimension ( size ( lu , 2 )) :: dum integer :: j , n , imax n = size ( lu , 1 ) d = 1.0 vv = maxval ( cabs ( lu ), dim = 2 ) if ( any ( vv == 0.0 )) & write ( * , * ) 'singular matrix in lu_decomposition' vv = 1.0 / vv do j = 1 , n imax = ( j - 1 ) + imaxloc ( vv ( j : n ) * cabs ( lu ( j : n , j ))) if ( j /= imax ) then dum = lu ( imax , :) lu ( imax , :) = lu ( j , :) lu ( j , :) = dum d = - d vv ( imax ) = vv ( j ) end if idx ( j ) = imax if ( lu ( j , j ) == 0.0 ) lu ( j , j ) = zero lu ( j + 1 : n , j ) = lu ( j + 1 : n , j ) / lu ( j , j ) lu ( j + 1 : n , j + 1 : n ) = lu ( j + 1 : n , j + 1 : n ) - spread ( lu ( j + 1 : n , j ), 2 , n - j ) & * spread ( lu ( j , j + 1 : n ), 1 , n - j ) end do end subroutine lu_decomposition_complex subroutine lu_back_substitution_real ( lu , idx , b ) implicit none real , dimension (:, :), intent ( in ) :: lu integer , dimension (:), intent ( in ) :: idx real , dimension (:), intent ( in out ) :: b integer :: i , n , ii , ll real :: summ n = size ( lu , 1 ) ii = 0 do i = 1 , n ll = idx ( i ) summ = b ( ll ) b ( ll ) = b ( i ) if ( ii /= 0 ) then summ = summ - dot_product ( lu ( i , ii : i - 1 ), b ( ii : i - 1 )) else if ( summ /= 0.0 ) then ii = i end if b ( i ) = summ end do do i = n , 1 , - 1 b ( i ) = ( b ( i ) - dot_product ( lu ( i , i + 1 : n ), b ( i + 1 : n ))) / lu ( i , i ) end do end subroutine lu_back_substitution_real subroutine lu_back_substitution_real_complex ( lu , idx , b ) implicit none real , dimension (:, :), intent ( in ) :: lu integer , dimension (:), intent ( in ) :: idx complex , dimension (:), intent ( in out ) :: b integer :: i , n , ii , ll complex :: summ !! The dot products we use below automatically take the complex conjugate of its !! first argument, which we do not want here. Hence the use of conjg to undo this n = size ( lu , 1 ) ii = 0 do i = 1 , n ll = idx ( i ) summ = b ( ll ) b ( ll ) = b ( i ) if ( ii /= 0 ) then summ = summ - dot_product ( lu ( i , ii : i - 1 ), b ( ii : i - 1 )) else if ( summ /= 0.0 ) then ii = i end if b ( i ) = summ end do do i = n , 1 , - 1 b ( i ) = ( b ( i ) - dot_product ( lu ( i , i + 1 : n ), b ( i + 1 : n ))) / lu ( i , i ) end do end subroutine lu_back_substitution_real_complex subroutine lu_back_substitution_complex ( lu , idx , b ) implicit none complex , dimension (:, :), intent ( in ) :: lu integer , dimension (:), intent ( in ) :: idx complex , dimension (:), intent ( in out ) :: b integer :: i , n , ii , ll complex :: summ !! The dot products we use below automatically take the complex conjugate of its !! first argument, which we do not want here. Hence the use of conjg to undo this n = size ( lu , 1 ) ii = 0 do i = 1 , n ll = idx ( i ) summ = b ( ll ) b ( ll ) = b ( i ) if ( ii /= 0 ) then summ = summ - dot_product ( conjg ( lu ( i , ii : i - 1 )), b ( ii : i - 1 )) else if ( summ /= 0.0 ) then ii = i end if b ( i ) = summ end do do i = n , 1 , - 1 b ( i ) = ( b ( i ) - dot_product ( conjg ( lu ( i , i + 1 : n )), b ( i + 1 : n ))) / lu ( i , i ) end do end subroutine lu_back_substitution_complex subroutine lu_back_substitution_matrix_real ( lu , idx , b ) implicit none real , dimension (:, :), intent ( in ) :: lu integer , dimension (:), intent ( in ) :: idx real , dimension (:, :), intent ( in out ) :: b integer :: i , j , n , ii , ll real :: summ n = size ( lu , 1 ) ii = 0 do j = 1 , n do i = 1 , n ll = idx ( i ) summ = b ( ll , j ) b ( ll , j ) = b ( i , j ) if ( ii /= 0 ) then summ = summ - dot_product ( lu ( i , ii : i - 1 ), b ( ii : i - 1 , j )) else if ( summ /= 0.0 ) then ii = i end if b ( i , j ) = summ end do do i = n , 1 , - 1 b ( i , j ) = ( b ( i , j ) - dot_product ( lu ( i , i + 1 : n ), b ( i + 1 : n , j ))) / lu ( i , i ) end do end do end subroutine lu_back_substitution_matrix_real subroutine lu_back_substitution_matrix_complex ( lu , idx , b ) implicit none complex , dimension (:, :), intent ( in ) :: lu integer , dimension (:), intent ( in ) :: idx complex , dimension (:, :), intent ( in out ) :: b integer :: i , j , n , ii , ll complex :: summ !! The dot products we use below automatically take the complex conjugate of its !! first argument, which we do not want here. Hence the use of conjg to undo this n = size ( lu , 1 ) ii = 0 do j = 1 , n do i = 1 , n ll = idx ( i ) summ = b ( ll , j ) b ( ll , j ) = b ( i , j ) if ( ii /= 0 ) then summ = summ - dot_product ( conjg ( lu ( i , ii : i - 1 )), b ( ii : i - 1 , j )) else if ( summ /= 0.0 ) then ii = i end if b ( i , j ) = summ end do do i = n , 1 , - 1 b ( i , j ) = ( b ( i , j ) - dot_product ( conjg ( lu ( i , i + 1 : n )), b ( i + 1 : n , j ))) / lu ( i , i ) end do end do end subroutine lu_back_substitution_matrix_complex !! !! One shouldn't need to compute the inverse of a matrix if solving the linear equation A.x = y; !! a simple back substitution should suffice. !! !! Only compute the inverse of A when absolutely necessary! !! subroutine lu_inverse_real ( lu , idx , inverse ) implicit none real , dimension (:, :), intent ( in ) :: lu integer , dimension (:), intent ( in ) :: idx real , dimension (:, :), intent ( out ) :: inverse integer :: i , n n = size ( lu , 1 ) inverse = 0.0 do i = 1 , n inverse ( i , i ) = 1.0 end do do i = 1 , n call lu_back_substitution ( lu , idx , inverse (:, i )) end do end subroutine lu_inverse_real subroutine lu_inverse_complex ( lu , idx , inverse ) implicit none complex , dimension (:, :), intent ( in ) :: lu integer , dimension (:), intent ( in ) :: idx complex , dimension (:, :), intent ( out ) :: inverse integer :: i , n n = size ( lu , 1 ) inverse = 0.0 do i = 1 , n inverse ( i , i ) = 1.0 end do do i = 1 , n call lu_back_substitution ( lu , idx , inverse (:, i )) end do end subroutine lu_inverse_complex function imaxloc ( array ) real , dimension (:), intent ( in ) :: array integer :: imaxloc integer , dimension ( 1 ) :: imax imax = maxloc ( array ) imaxloc = imax ( 1 ) end function imaxloc end module linear_solve","tags":"","loc":"sourcefile/linear_solve.f90.html"},{"title":"file_utils.fpp â€“ stella","text":"Contents Modules file_utils Source Code file_utils.fpp Source Code # include \"define.inc\" module file_utils implicit none private public :: init_file_utils ! subroutine init_file_utils (list, input, error, trin_run, name) ! logical, intent (out) :: list ! logical, intent (in), optional :: input, error, trin_run ! character(*), intent (in), optional :: name !   default: INPUT=.true., ERROR=.true., TRIN_RUN=.false., NAME=\"unknown\" !   Set up run_name(s) and list_name for output files !   Open input file and strip comments, unless disabled with INPUT=.false. !   Open error output file, unless disabled with ERROR=.false. public :: init_job_name ! subroutine ... public :: finish_file_utils ! subroutine finish_file_utils !   Clean up files opened in init public :: run_name ! character(500) :: run_name !    Label for the run, taken from the command line public :: list_name ! character(500) :: list_name !    Label for the list, taken from the command line public :: input_unit ! function input_unit (nml) ! character(*), intent (in) :: nml ! integer :: input_unit !    Rewind the input file to start of namelist NML, !    and return its unit number public :: input_unit_exist ! function input_unit_exist (nml,exist) ! character(*), intent (in) :: nml ! integer :: input_unit !    Rewind the input file to start of namelist NML, !    and return its unit number, setexist=.true. !    If the namelist NML is not found, set exist=.false. public :: init_error_unit public :: init_input_unit public :: error_unit ! function error_unit () ! integer :: error_unit !    Return the error unit number public :: get_input_unit public :: open_output_file ! subroutine open_output_file (unit, ext) ! integer, intent (out) :: unit ! character (*), intent (in) :: ext !    Open a file with name made from the run_name with the EXT appended !    and return its unit number in UNIT public :: close_output_file ! subroutine close_output_file (unit) ! integer, intent (in) :: unit !    Close the file associated with UNIT from open_output_file public :: flush_output_file ! subroutine flush_output_file (unit) ! integer, intent (in) :: unit !    Close/open-append the file associated with UNIT from open_output_file public :: get_unused_unit ! subroutine get_unused_unit (unit) ! integer, intent (out) :: unit !    Return a unit number not associated with any file public :: get_indexed_namelist_unit ! subroutine get_indexed_namelist_unit (unit, nml, index) ! integer, intent (out) :: unit ! character (*), intent (in) :: nml ! integer, intent (in) :: index !    Copy namelist, NML // '_' // INDEX, from the input file to !    namelist, NML, in a temporary file, UNIT !  public :: num_input_lines public :: stdout_unit public :: runtype_option_switch public :: runtype_standalone public :: runtype_trinity public :: runtype_list public :: runtype_multibox character ( 500 ), pointer :: run_name character ( 500 ), target :: arun_name , job_name character ( 500 ) :: list_name integer , parameter :: stdout_unit = 6 integer :: runtype_option_switch integer , parameter :: runtype_standalone = 0 , & runtype_list = 1 , & runtype_trinity = 2 , & runtype_multibox = 3 integer , save :: input_unit_no , error_unit_no = stdout_unit ! TT> integer , save , public :: num_input_lines ! <TT contains subroutine init_file_utils ( list , input , error , trin_run , name , n_ensembles ) ! Find out the [[run_name]], and use the run name to determine whether ! this is a [[list]] run (i.e. a list of runs has been given) or a [[Trinity]] run. ! If not, open the error file and call init_input_unit implicit none logical , intent ( out ) :: list logical , intent ( in ), optional :: input , error , trin_run character ( * ), intent ( in ), optional :: name integer , intent ( in ), optional :: n_ensembles logical :: inp , err if ( present ( input )) then inp = input else inp = . true . end if if ( present ( error )) then err = error else err = . true . end if if ( present ( name )) then !# if FCOMPILER == _XL_ !       arun_name = name !# else arun_name = trim ( name ) !# endif else arun_name = \"unknown\" end if ! TT> changed for slice_g !    call run_type (list) if ( inp . and . . not . present ( trin_run )) then ! get runname from command line and ! set list=T if input ends in \".list\" call run_type ( list ) else if ( present ( trin_run )) then if ( trin_run ) runtype_option_switch = runtype_trinity list = . false . end if ! <TT if ( list ) then list_name = arun_name else if ( present ( n_ensembles )) then if ( n_ensembles > 1 ) then list_name = arun_name else call init_run_name call init_error_unit ( err ) call init_input_unit ( inp ) end if else call init_run_name call init_error_unit ( err ) call init_input_unit ( inp ) end if end subroutine init_file_utils subroutine run_type ( list ) ! This determines the type of run, by reading the name of the input file ! on the command line into [[arun_name]], and then looking at the extension. If ! the extension is .list, then [[list]] is set to .true.). use command_line , only : cl_getarg , cl_iargc implicit none logical , intent ( out ) :: list integer :: l , ierr list = . false . ! get argument from command line and put in arun_name if ( cl_iargc () /= 0 ) then call cl_getarg ( 1 , arun_name , l , ierr ) if ( ierr /= 0 ) then print * , \"Error getting run name.\" end if end if if ( l > 5 . and . arun_name ( l - 4 : l ) == \".list\" ) then list = . true . runtype_option_switch = runtype_list end if if ( l > 6 . and . arun_name ( l - 5 : l ) == \".multi\" ) then list = . true . runtype_option_switch = runtype_multibox end if end subroutine run_type subroutine init_run_name ! This is called for a non [[Trinity]] or [[list]] run - ! it checks that the input file name ends in \".in\", chops ! the extension off and stores it in [[arun_name]]. It ! also assigns the pointer [[run_name]] to [[arun_name]]. implicit none integer :: l l = len_trim ( arun_name ) if ( l > 3 . and . arun_name ( l - 2 : l ) == \".in\" ) then arun_name = arun_name ( 1 : l - 3 ) end if run_name => arun_name end subroutine init_run_name subroutine init_job_name ( jobname ) implicit none character ( len = 500 ), intent ( in ) :: jobname job_name = trim ( jobname ) run_name => job_name end subroutine init_job_name subroutine get_unused_unit ( unit ) ! Get an unused unit number for I/O. implicit none integer , intent ( out ) :: unit logical :: od unit = 50 do inquire ( unit = unit , opened = od ) if (. not . od ) return unit = unit + 1 end do end subroutine get_unused_unit !============================================== !============= OPEN OUTPUT FILE =============== !============================================== ! Open an output file to write data (replacing or appending any existing) ! The name is [[run_name]] + [[ext]], and set [[unit]] to the ! unit number of that output file. subroutine open_output_file ( unit , ext , overwrite_in ) implicit none integer , intent ( out ) :: unit logical , intent ( in ), optional :: overwrite_in logical :: overwrite character ( * ), intent ( in ) :: ext character ( 500 ) :: hack ! Initiate the optional argument if ( present ( overwrite_in )) then overwrite = overwrite_in else overwrite = . true . end if ! Get a unit for the output file that is not currently in use call get_unused_unit ( unit ) ! Create the name of the output file hack = trim ( run_name ) // ext ! If overwrite==True: Create a new output file or replace the existing file ! If overwrite==False: Append data to the already existing output file if ( overwrite ) then open ( unit = unit , file = trim ( hack ), status = \"replace\" , action = \"write\" ) else open ( unit = unit , file = trim ( hack ), status = \"unknown\" , action = \"write\" , position = \"append\" ) end if end subroutine open_output_file !============================================== !============= CLOSE OUTPUT FILE ============== !============================================== ! Close the output file identified by [[unit]]. subroutine close_output_file ( unit ) implicit none integer , intent ( in ) :: unit close ( unit = unit ) end subroutine close_output_file subroutine flush_output_file ( unit ) implicit none integer , intent ( in ) :: unit character ( len = 500 ) :: fname inquire ( unit , name = fname ) # if FCOMPILER == _XL_ call flush_ ( unit ) # elif FCOMPILER == _NAG_ close ( unit = unit ) open ( unit = unit , file = trim ( fname ), status = \"old\" , action = \"write\" , position = \"append\" ) # else call flush ( unit ) # endif end subroutine flush_output_file subroutine init_error_unit ( open_it ) implicit none logical , intent ( in ) :: open_it ! TT> changed for slice_g !    error_unit_no = 6 error_unit_no = 0 ! <TT if ( run_name /= \"unknown\" . and . open_it ) then call open_output_file ( error_unit_no , \".error\" ) ! TT: error_unit_no is overwritten for .error file end if end subroutine init_error_unit subroutine strip_comments ( line ) implicit none character ( * ), intent ( in out ) :: line logical :: in_single_quotes , in_double_quotes integer :: i , length length = len_trim ( line ) i = 1 in_single_quotes = . false . in_double_quotes = . false . loop : do if ( in_single_quotes ) then if ( line ( i : i ) == \"'\" ) in_single_quotes = . false . else if ( in_double_quotes ) then if ( line ( i : i ) == '\"' ) in_double_quotes = . false . else select case ( line ( i : i )) case ( \"'\" ) in_single_quotes = . true . case ( '\"' ) in_double_quotes = . true . case ( \"!\" ) i = i - 1 exit loop end select end if if ( i >= length ) exit loop i = i + 1 end do loop line = line ( 1 : i ) end subroutine strip_comments subroutine init_input_unit ( open_it ) ! open the input file, strip out any comments and !  write them into the file \".run_name.in\". Check ! for includes, read any lines from the includes, strip ! any comments from them and add them to the same file. implicit none logical , intent ( in ) :: open_it integer :: in_unit , out_unit , iostat character ( 500 ) :: line integer :: ind_slash !To hold position of slash in run_name ! for includes integer , parameter :: stack_size = 10 integer , dimension ( stack_size ) :: stack integer :: stack_ptr if (. not . open_it ) then input_unit_no = - 1 return end if call get_unused_unit ( in_unit ) open ( unit = in_unit , file = trim ( run_name ) // \".in\" , status = \"old\" , & action = \"read\" , iostat = iostat ) if ( iostat /= 0 ) then print \"(a)\" , \"Could not open input file: \" // trim ( run_name ) // \".in\" end if call get_unused_unit ( out_unit ) !    open (unit=out_unit, status=\"scratch\", action=\"readwrite\") !Determine if '/' is in input name and if so what position !in the string is the last one (i.e. split run_name into path_to_file and file) ind_slash = index ( run_name , \"/\" , . True .) if ( ind_slash == 0 ) then !No slash in name !Original behaviour open ( unit = out_unit , file = \".\" // trim ( run_name ) // \".in\" ) else !General behaviour open ( unit = out_unit , file = trim ( run_name ( 1 : ind_slash )) // \".\" // trim ( run_name ( ind_slash + 1 :)) // \".in\" ) end if iostat = 0 stack_ptr = 0 num_input_lines = 0 do read ( unit = in_unit , fmt = \"(a)\" , iostat = iostat ) line if ( iostat /= 0 ) then if ( stack_ptr <= 0 ) exit close ( unit = in_unit ) iostat = 0 in_unit = stack ( stack_ptr ) stack_ptr = stack_ptr - 1 cycle end if if ( line ( 1 : 9 ) == \"!include \" ) then if ( stack_ptr >= stack_size ) then print \"(a)\" , \"!include ignored: nesting too deep: \" // trim ( line ) cycle end if stack_ptr = stack_ptr + 1 stack ( stack_ptr ) = in_unit call get_unused_unit ( in_unit ) open ( unit = in_unit , file = trim ( line ( 10 :)), status = \"old\" , & action = \"read\" , iostat = iostat ) if ( iostat /= 0 ) then print \"(a)\" , \"!include ignored: file unreadable: \" // trim ( line ) in_unit = stack ( stack_ptr ) stack_ptr = stack_ptr - 1 cycle end if cycle end if call strip_comments ( line ) write ( unit = out_unit , fmt = \"(a)\" ) trim ( line ) num_input_lines = num_input_lines + 1 end do close ( unit = in_unit ) input_unit_no = out_unit end subroutine init_input_unit subroutine finish_file_utils implicit none if ( input_unit_no > 0 ) then close ( unit = input_unit_no ) input_unit_no = - 1 end if if ( error_unit_no > 0 . and . error_unit_no /= 6 ) then close ( unit = error_unit_no ) error_unit_no = - 1 end if end subroutine finish_file_utils function input_unit ( nml ) implicit none character ( * ), intent ( in ) :: nml integer :: input_unit , iostat character ( 500 ) :: line intrinsic adjustl , trim input_unit = input_unit_no if ( input_unit_no > 0 ) then rewind ( unit = input_unit_no ) do read ( unit = input_unit_no , fmt = \"(a)\" , iostat = iostat ) line if ( iostat /= 0 ) then rewind ( unit = input_unit_no ) exit end if if ( trim ( adjustl ( line )) == \"&\" // nml ) then backspace ( unit = input_unit_no ) return end if end do end if write ( unit = error_unit_no , fmt = \"('Could not find namelist: ',a)\" ) nml write ( unit =* , fmt = \"('Could not find namelist: ',a)\" ) nml end function input_unit function input_unit_exist ( nml , exist ) implicit none character ( * ), intent ( in ) :: nml logical , intent ( out ) :: exist integer :: input_unit_exist , iostat character ( 500 ) :: line intrinsic adjustl , trim input_unit_exist = input_unit_no exist = . true . if ( input_unit_no > 0 ) then rewind ( unit = input_unit_no ) do read ( unit = input_unit_no , fmt = \"(a)\" , iostat = iostat ) line if ( iostat /= 0 ) then rewind ( unit = input_unit_no ) exit end if if ( trim ( adjustl ( line )) == \"&\" // nml ) then backspace ( unit = input_unit_no ) return end if end do end if exist = . false . end function input_unit_exist function error_unit () implicit none integer :: error_unit error_unit = error_unit_no end function error_unit subroutine get_input_unit ( unit ) implicit none integer , intent ( out ) :: unit unit = input_unit_no end subroutine get_input_unit subroutine get_indexed_namelist_unit ( unit , nml , index_in ) implicit none integer , intent ( out ) :: unit character ( * ), intent ( in ) :: nml integer , intent ( in ) :: index_in character ( 500 ) :: line integer :: iunit , iostat , in_file integer :: ind_slash logical :: exist call get_unused_unit ( unit ) !    open (unit=unit, status=\"scratch\", action=\"readwrite\") !Determine if '/' is in input name and if so what position !in the string is the last one (i.e. split run_name into path_to_file and file) ind_slash = index ( run_name , \"/\" , . True .) if ( ind_slash == 0 ) then !No slash in name !Original behaviour open ( unit = unit , file = \".\" // trim ( run_name ) // \".scratch\" ) else !General behaviour open ( unit = unit , file = trim ( run_name ( 1 : ind_slash )) // \".\" // trim ( run_name ( ind_slash + 1 :)) // \".scratch\" ) end if write ( line , * ) index_in line = nml // \"_\" // trim ( adjustl ( line )) in_file = input_unit_exist ( trim ( line ), exist ) if ( exist ) then iunit = input_unit ( trim ( line )) else write ( 6 , * ) \"get_indexed_namelist: following namelist not found \" , trim ( line ) return end if read ( unit = iunit , fmt = \"(a)\" ) line write ( unit = unit , fmt = \"('&',a)\" ) nml do read ( unit = iunit , fmt = \"(a)\" , iostat = iostat ) line if ( iostat /= 0 . or . trim ( adjustl ( line )) == \"/\" ) exit write ( unit = unit , fmt = \"(a)\" ) trim ( line ) end do write ( unit = unit , fmt = \"('/')\" ) rewind ( unit = unit ) end subroutine get_indexed_namelist_unit end module file_utils","tags":"","loc":"sourcefile/file_utils.fpp.html"},{"title":"fft_work.f90 â€“ stella","text":"Contents Modules fft_work Source Code fft_work.f90 Source Code module fft_work use constants , only : kind_id implicit none include \"fftw3.f\" public :: fft_type , delete_fft public :: init_ccfftw , init_crfftw , init_rcfftw public :: FFT_BACKWARD , FFT_FORWARD private integer , parameter :: FFT_BACKWARD = FFTW_BACKWARD integer , parameter :: FFT_FORWARD = FFTW_FORWARD type :: fft_type integer :: n , is , type integer ( kind_id ) :: plan real :: scale end type fft_type contains subroutine init_ccfftw ( fft , is , n , data_in , data_out ) use mp , only : mp_abort type ( fft_type ), intent ( out ) :: fft integer , intent ( in ) :: is , n complex , dimension (:), intent ( inout ) :: data_in , data_out integer :: j fft % n = n fft % is = is fft % scale = 1. / real ( n ) if ( is > 0 ) fft % scale = 1. fft % type = 1 j = FFTW_PATIENT call dfftw_plan_dft_1d ( fft % plan , n , data_in , data_out , is , j ) end subroutine init_ccfftw subroutine init_crfftw ( fft , is , n , data_in , data_out ) use mp , only : mp_abort type ( fft_type ), intent ( out ) :: fft integer , intent ( in ) :: is , n complex , dimension (:), intent ( in out ) :: data_in real , dimension (:), intent ( in out ) :: data_out integer :: j fft % n = n fft % is = is fft % scale = 1. / real ( n ) if ( is > 0 ) fft % scale = 1. fft % type = 1 j = FFTW_PATIENT call dfftw_plan_dft_c2r_1d ( fft % plan , n , data_in , data_out , j ) end subroutine init_crfftw subroutine init_rcfftw ( fft , is , n , data_in , data_out ) use mp , only : mp_abort type ( fft_type ), intent ( out ) :: fft integer , intent ( in ) :: is , n real , dimension (:), intent ( in out ) :: data_in complex , dimension (:), intent ( in out ) :: data_out integer :: j fft % n = n fft % is = is fft % scale = 1. / real ( n ) if ( is > 0 ) fft % scale = 1. fft % type = 1 j = FFTW_PATIENT call dfftw_plan_dft_r2c_1d ( fft % plan , n , data_in , data_out , j ) end subroutine init_rcfftw subroutine delete_fft ( fft ) type ( fft_type ), intent ( in out ) :: fft call dfftw_destroy_plan ( fft % plan ) end subroutine delete_fft end module fft_work","tags":"","loc":"sourcefile/fft_work.f90.html"},{"title":"smooth_step.f90 â€“ stella","text":"Contents Modules smooth_step Source Code smooth_step.f90 Source Code module smooth_step implicit none public :: smoothstep contains pure function smoothstep ( x , N , minV , maxV ) implicit none real :: smoothstep real , intent ( in ) :: x integer , intent ( in ) :: N real , optional , intent ( in ) :: minV real , optional , intent ( in ) :: maxV real :: minVl real :: maxVl real :: dV minVl = 0 maxVl = 1 if ( present ( minV )) minVl = minV if ( present ( maxV )) maxVl = maxV dV = maxVl - minVl if ( x <= 0 ) then smoothstep = minVl return end if if ( x >= 1 ) then smoothstep = maxVl return end if select case ( N ) case ( 0 ) smoothstep = minVl + dV * smoothstep0 ( x ) case ( 1 ) smoothstep = minVl + dV * smoothstep1 ( x ) case ( 2 ) smoothstep = minVl + dV * smoothstep2 ( x ) case default smoothstep = minVl + dV * smoothstepN ( x , N ) end select end function smoothstep pure function smoothstep0 ( x ) implicit none real :: smoothstep0 real , intent ( in ) :: x smoothstep0 = x end function smoothstep0 pure function smoothstep1 ( x ) implicit none real :: smoothstep1 real , intent ( in ) :: x smoothstep1 = x * x * ( 3 - 2 * x ) end function smoothstep1 pure function smoothstep2 ( x ) implicit none real :: smoothstep2 real , intent ( in ) :: x smoothstep2 = x * x * x * ( x * ( x * 6 - 15 ) + 10 ) end function smoothstep2 pure function smoothstepN ( x , N ) implicit none real :: smoothstepN real :: sumV real :: xp real , intent ( in ) :: x integer , intent ( in ) :: N integer :: i if ( N < 0 ) then smoothstepN = 0.5 * sin ( 3.14159265358979 * ( x - 0.5 )) + 0.5 return end if xp = x if ( x > 0.5 ) xp = 1.0 - x sumV = 0 do i = N , 0 , - 1 sumV = xp * sumV + & pascalTriangle ( - N - 1 , i ) * & pascalTriangle ( 2 * N + 1 , N - i ) end do sumV = xp ** ( N + 1 ) * sumV smoothstepN = sumV if ( x > 0.5 ) smoothstepN = 1 - sumV end function smoothstepN pure function pascalTriangle ( a , b ) implicit none integer :: pascalTriangle integer , intent ( in ) :: a , b integer i pascalTriangle = 1 do i = 0 , b - 1 pascalTriangle = pascalTriangle * ( a - i ) / ( i + 1 ) end do end function pascalTriangle end module smooth_step","tags":"","loc":"sourcefile/smooth_step.f90.html"},{"title":"system_fortran.fpp â€“ stella","text":"Contents Modules system_fortran Source Code system_fortran.fpp Source Code # include \"define.inc\" module system_fortran implicit none private public :: systemf #ifdef ISO_C_BINDING interface subroutine call_system_c ( command ) bind ( C , name = 'system' ) use , intrinsic :: iso_c_binding , only : c_char , c_int character ( kind = c_char ), intent ( in ) :: command ( * ) end subroutine call_system_c end interface #endif contains subroutine systemf ( command ) #ifdef ISO_C_BINDING use , intrinsic :: iso_c_binding , only : c_null_char implicit none character ( * ), intent ( in ) :: command call call_system_c ( command // c_null_char ) #else # if FCOMPILER == _INTEL_ !   for system call with intel compiler use ifport , only : system # endif implicit none character ( * ), intent ( in ) :: command # if FCOMPILER == _CRAY_ integer :: ierr ierr = system ( command ) #endif #endif /* ISO_C_BINDING */ end subroutine systemf end module system_fortran","tags":"","loc":"sourcefile/system_fortran.fpp.html"},{"title":"spl.f90 â€“ stella","text":"Contents Modules splines Source Code spl.f90 Source Code module splines implicit none public :: geo_spline , linear_interp_periodic type :: spline integer :: n real , dimension (:), pointer :: x , y , y2 end type spline type :: periodic_spline integer :: n real :: period real , dimension (:), pointer :: x , y , y2 end type periodic_spline interface geo_spline module procedure geo_spline_real module procedure geo_spline_array end interface contains !   subroutine new_spline (n, x, y, spl) !     implicit none !     integer, intent (in) :: n !     real, dimension (n), intent (in) :: x, y !     type (spline), intent (out) :: spl !     real, dimension (n) :: temp !     integer :: ierr !     spl%n = n !     allocate (spl%x(n),spl%y(n)) !     spl%x = x !     spl%y = y !     allocate (spl%y2(n)) !     call fitp_curv1 (n, x, y, 0.0, 0.0, 3, spl%y2, temp, 1.0, ierr) !   end subroutine new_spline !   subroutine new_periodic_spline (n, x, y, period, spl) !     implicit none !     integer, intent (in) :: n !     real, dimension (n), intent (in) :: x, y !     real, intent (in) :: period !     type (periodic_spline), intent (out) :: spl !     real, dimension (2*n) :: temp !     integer :: ierr !     spl%n = n !     spl%period = period !     allocate (spl%x(n),spl%y(n)) !     spl%x = x !     spl%y = y !     allocate (spl%y2(n)) !     call fitp_curvp1 (n,x,y,period,spl%y2,temp,1.0,ierr) !   end subroutine new_periodic_spline !   subroutine delete_spline (spl) !     implicit none !     type (spline), intent (in out) :: spl !     spl%n = 0 !     deallocate (spl%x,spl%y) !     nullify (spl%x) !     nullify (spl%y) !     deallocate (spl%y2) !     nullify (spl%y2) !   end subroutine delete_spline !   subroutine delete_periodic_spline (spl) !     implicit none !     type (periodic_spline), intent (in out) :: spl !     spl%n = 0 !     spl%period = 0.0 !     deallocate (spl%x,spl%y) !     nullify (spl%x) !     nullify (spl%y) !     deallocate (spl%y2) !     nullify (spl%y2) !   end subroutine delete_periodic_spline !   function splint (x, spl) !     implicit none !     real, intent (in) :: x !     type (spline), intent (in) :: spl !     real :: splint !     splint = fitp_curv2 (x, spl%n, spl%x, spl%y, spl%y2, 1.0) !   end function splint !   function periodic_splint (x, spl) !     implicit none !     real, intent (in) :: x !     type (periodic_spline), intent (in) :: spl !     real :: periodic_splint !     periodic_splint = fitp_curvp2 & !          (x, spl%n, spl%x, spl%y, spl%period, spl%y2, 1.0) !   end function periodic_splint !   function dsplint (x, spl) !     implicit none !     real, intent (in) :: x !     type (spline), intent (in) :: spl !     real :: dsplint !     dsplint = fitp_curvd (x, spl%n, spl%x, spl%y, spl%y2, 1.0) !   end function dsplint !   function splintint (x0, x1, spl) !     implicit none !     real, intent (in) :: x0, x1 !     type (spline), intent (in) :: spl !     real :: splintint !     splintint = fitp_curvi (x0,x1,spl%n,spl%x,spl%y,spl%y2,1.0) !   end function splintint !   function periodic_splintint (x0, x1, spl) !     implicit none !     real, intent (in) :: x0, x1 !     type (periodic_spline), intent (in) :: spl !     real :: periodic_splintint !     periodic_splintint = fitp_curvpi & !          (x0,x1,spl%n,spl%x,spl%y,spl%period,spl%y2, 1.0) !   end function periodic_splintint !   subroutine inter_d_cspl(n,r,data,m,x,dint,ddint) !     integer n !     integer m !     real r(n), data(n), x(m), dint(m), ddint(m) !     integer max !     parameter (max=1000) !     real ddata(max),temp(max) !     integer i,ierr !     if (n .gt. max) then !        write (*,*) 'error in inter_d_cspl' !        write (*,*) 'increase max' !        stop !     endif !     ierr = 0 !     call fitp_curv1(n,r,data,0.0,0.0,3,ddata,temp,1.0,ierr) !     if (ierr .ne. 0) then !        if (ierr .eq. 1) then !           write (*,*) 'FITPACK: curv1 error: n < 2' !        elseif (ierr .eq. 2) then !           write (*,*) 'FITPACK: curv1 error: x-values not increasing' !        else !           write (*,*) 'FITPACK: curv1 error' !        endif !        stop !     endif !     do i=1,m !        dint(i) = fitp_curv2 (x(i),n,r,data,ddata,1.0) !        ddint(i)= fitp_curvd (x(i),n,r,data,ddata,1.0) !     enddo !   end subroutine inter_d_cspl !   subroutine inter_cspl(n,r,data,m,x,dint) !     integer n !     integer m !     real r(n), data(n), x(m), dint(m) !     integer max !     parameter (max=1000) !     real ddata(max),temp(max) !     integer i,ierr !     if (n .gt. max) then !        write (*,*) 'error in inter_cspl' !        write (*,*) 'increase max' !        stop !     endif !     ierr = 0 !     call fitp_curv1(n,r,data,0.0,0.0,3,ddata,temp,1.0,ierr) !     if (ierr .ne. 0) then !        if (ierr .eq. 1) then !           write (*,*) 'FITPACK: curv1 error: n < 2' !        elseif (ierr .eq. 2) then !           write (*,*) 'FITPACK: curv1 error: x-values not increasing' !        else !           write (*,*) 'FITPACK: curv1 error' !        endif !        stop !     endif !     do i=1,m !        dint(i) = fitp_curv2 (x(i),n,r,data,ddata,1.0) !     enddo !   end subroutine inter_cspl !   subroutine inter_getspl (n, x, y, y2) !     integer n !     real x(n), y(n), y2(n) !     integer max !     parameter (max=1000) !     real temp(max) !     integer ierr !     if (n .gt. max) then !        write (*,*) 'error in inter_getspl' !        write (*,*) 'increase max' !        stop !     endif !     ierr = 0 !     call fitp_curv1(n,x,y,0.0,0.0,3,y2,temp,1.0,ierr) !     if (ierr .ne. 0) then !        if (ierr .eq. 1) then !           write (*,*) 'FITPACK: curv1 error: n < 2' !        elseif (ierr .eq. 2) then !           write (*,*) 'FITPACK: curv1 error: x-values not increasing' !        else !           write (*,*) 'FITPACK: curv1 error' !        endif !        stop !     endif !   end subroutine inter_getspl !   real function inter_splint (x0, n, x, y, y2) !     real x0 !     integer n !     real x(n), y(n), y2(n) !     inter_splint = fitp_curv2 (x0, n, x, y, y2, 1.0) !   end function inter_splint !   real function inter_dsplint (x0, n, x, y, y2) !     real x0 !     integer n !     real x(n), y(n), y2(n) !     inter_dsplint = fitp_curvd (x0, n, x, y, y2, 1.0) !   end function inter_dsplint !   real function inter_d2splint (x0, n, x, y, y2) !     real x0 !     integer n !     real x(n), y(n), y2(n) !     real yx(500) !     data yx(1)/1.0/ !     save yx !     integer i !     if (yx(1) .ne. 0.0) then !        do i=1,500 !           yx(i) = 0.0 !        enddo !     endif !     inter_d2splint = fitp_curv2 (x0, n, x, y2, yx, 1e5) !   end function inter_d2splint !   subroutine inter_getpspl (n, x, p, y, y2) !     integer n !     real x(n), p, y(n), y2(n) !     integer max !     parameter (max=1000) !     real temp(max) !     integer ierr !     if (n .gt. max) then !        write (*,*) 'error in inter_getpspl' !        write (*,*) 'increase max' !        stop !     endif !     ierr=0 !     call fitp_curvp1(n,x,y,p,y2,temp,1.0,ierr) !     if (ierr .ne. 0) then !        if (ierr .eq. 1) then !           write (*,*) 'FITPACK: curvp1 error: n < 2' !        elseif (ierr .eq. 2) then !           write (*,*) 'FITPACK: curvp1 error: p <= x(n)-x(1)' !        elseif (ierr .eq. 3) then !           write (*,*) 'FITPACK: curvp1 error: x-values not increasing' !        else !           write (*,*) 'FITPACK: curv1 error' !        endif !        stop !     endif !   end subroutine inter_getpspl !   real function inter_psplint (x0, n, x, p, y, y2) !     real x0 !     integer n !     real x(n), p, y(n), y2(n) !     inter_psplint = fitp_curvp2 (x0, n, x, y, p, y2, 1.0) !   end function inter_psplint !   real function inter_pdsplint (x0, n, x, p, y, y2) !     real x0 !     integer n !     real x(n), p, y(n), y2(n) !     inter_pdsplint = fitp_curvpd (x0, n, x, y, p, y2, 1.0) !   end function inter_pdsplint ! From inet!cs.utexas.edu!cline Tue Oct 31 17:10:31 CST 1989 ! Received: from mojave.cs.utexas.edu by cs.utexas.edu (5.59/1.44) !         id AA29509; Tue, 31 Oct 89 17:11:51 CST ! Posted-Date: Tue, 31 Oct 89 17:10:31 CST ! Message-Id: <8910312310.AA04442@mojave.cs.utexas.edu> ! Received: by mojave.cs.utexas.edu (14.5/1.4-Client) !         id AA04442; Tue, 31 Oct 89 17:10:34 cst ! Date: Tue, 31 Oct 89 17:10:31 CST ! X-Mailer: Mail User's Shell (6.5 4/17/89) ! From: cline@cs.utexas.edu (Alan Cline) ! To: ehg@research.att.com ! Subject: New FITPACK Subset for netlib ! ! ! This new version of FITPACK distributed by netlib is about 20% of ! the total package in terms of characters, lines of code, and num- ! ber of subprograms. However, these 25 subprograms represent about ! 95% of usages of the package.  What has been omitted are such ca- ! pabilities as: !   1. Automatic tension determination, !   2. Derivatives, arclengths, and enclosed areas for planar !      curves, !   3. Three dimensional curves, !   4. Special surface fitting using equispacing assumptions, !   5. Surface fitting in annular, wedge, polar, toroidal, lunar, !      and spherical geometries, !   6. B-splines in tension generation and usage, !   7. General surface fitting in three dimensional space. ! ! (The code previously circulated in netlib is less than 10% of the ! total  package  and is more than a decade old.  Its usage is dis- ! couraged.) ! ! Please note:  Two versions of the subroutine snhcsh are included. ! Both serve the same purpose:  obtaining approximations to certain ! hyperbolic trigonometric-like functions.  The first is less accu- ! rate (but more efficient) than the second.  Installers should se- ! lect the one with the precision they desire. ! ! Interested parties can obtain the entire package on disk or  tape ! from Pleasant  Valley Software, 8603 Altus Cove, Austin TX (USA), ! 78759 at a cost of $495 US. A 340 page manual  is  available  for ! $30  US  per  copy.  The  package  includes  examples and machine ! readable documentation. subroutine fitp_curv1 ( n , x , y , slp1 , slpn , islpsw , yp , temp , sigma , ierr ) integer n , islpsw , ierr real x ( n ), y ( n ), slp1 , slpn , yp ( n ), temp ( n ), sigma ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this subroutine determines the parameters necessary to ! compute an interpolatory spline under tension through ! a sequence of functional values. the slopes at the two ! ends of the curve may be specified or omitted.  for actual ! computation of points on the curve it is necessary to call ! the function curv2. ! ! on input-- ! !   n is the number of values to be interpolated (n.ge.2). ! !   x is an array of the n increasing abscissae of the !   functional values. ! !   y is an array of the n ordinates of the values, (i. e. !   y(k) is the functional value corresponding to x(k) ). ! !   slp1 and slpn contain the desired values for the first !   derivative of the curve at x(1) and x(n), respectively. !   the user may omit values for either or both of these !   parameters and signal this with islpsw. ! !   islpsw contains a switch indicating which slope data !   should be used and which should be estimated by this !   subroutine, !          = 0 if slp1 and slpn are to be used, !          = 1 if slp1 is to be used but not slpn, !          = 2 if slpn is to be used but not slp1, !          = 3 if both slp1 and slpn are to be estimated !              internally. ! !   yp is an array of length at least n. ! !   temp is an array of length at least n which is used for !   scratch storage. ! ! and ! !   sigma contains the tension factor. this value indicates !   the curviness desired. if abs(sigma) is nearly zero !   (e.g. .001) the resulting curve is approximately a !   cubic spline. if abs(sigma) is large (e.g. 50.) the !   resulting curve is nearly a polygonal line. if sigma !   equals zero a cubic spline results.  a standard value !   for sigma is approximately 1. in absolute value. ! ! on output-- ! !   yp contains the values of the second derivative of the !   curve at the given nodes. ! !   ierr contains an error flag, !        = 0 for normal return, !        = 1 if n is less than 2, !        = 2 if x-values are not strictly increasing. ! ! and ! !   n, x, y, slp1, slpn, islpsw and sigma are unaltered. ! ! this subroutine references package modules ceez, terms, ! and snhcsh. ! !----------------------------------------------------------- integer i , ibak , nm1 , np1 real sdiag1 , diag1 , delxnm , dx1 , diag , sdiag2 , dx2 , diag2 real delxn , slpp1 , delx1 , sigmap , c3 , c2 , c1 , slppn , delx2 nm1 = n - 1 np1 = n + 1 ierr = 0 if ( n <= 1 ) go to 8 if ( x ( n ) <= x ( 1 )) go to 9 ! ! denormalize tension factor ! sigmap = abs ( sigma ) * real ( n - 1 ) / ( x ( n ) - x ( 1 )) ! ! approximate end slopes ! if ( islpsw >= 2 ) go to 1 slpp1 = slp1 go to 2 1 delx1 = x ( 2 ) - x ( 1 ) delx2 = delx1 + delx1 if ( n > 2 ) delx2 = x ( 3 ) - x ( 1 ) if ( delx1 <= 0. . or . delx2 <= delx1 ) go to 9 call fitp_ceez ( delx1 , delx2 , sigmap , c1 , c2 , c3 , n ) slpp1 = c1 * y ( 1 ) + c2 * y ( 2 ) if ( n > 2 ) slpp1 = slpp1 + c3 * y ( 3 ) 2 if ( islpsw == 1 . or . islpsw == 3 ) go to 3 slppn = slpn go to 4 3 delxn = x ( n ) - x ( nm1 ) delxnm = delxn + delxn if ( n > 2 ) delxnm = x ( n ) - x ( n - 2 ) if ( delxn <= 0. . or . delxnm <= delxn ) go to 9 call fitp_ceez ( - delxn , - delxnm , sigmap , c1 , c2 , c3 , n ) slppn = c1 * y ( n ) + c2 * y ( nm1 ) if ( n > 2 ) slppn = slppn + c3 * y ( n - 2 ) ! ! set up right hand side and tridiagonal system for yp and ! perform forward elimination ! 4 delx1 = x ( 2 ) - x ( 1 ) if ( delx1 <= 0. ) go to 9 dx1 = ( y ( 2 ) - y ( 1 )) / delx1 call fitp_terms ( diag1 , sdiag1 , sigmap , delx1 ) yp ( 1 ) = ( dx1 - slpp1 ) / diag1 temp ( 1 ) = sdiag1 / diag1 if ( n == 2 ) go to 6 do i = 2 , nm1 delx2 = x ( i + 1 ) - x ( i ) if ( delx2 <= 0. ) go to 9 dx2 = ( y ( i + 1 ) - y ( i )) / delx2 call fitp_terms ( diag2 , sdiag2 , sigmap , delx2 ) diag = diag1 + diag2 - sdiag1 * temp ( i - 1 ) yp ( i ) = ( dx2 - dx1 - sdiag1 * yp ( i - 1 )) / diag temp ( i ) = sdiag2 / diag dx1 = dx2 diag1 = diag2 sdiag1 = sdiag2 end do 6 diag = diag1 - sdiag1 * temp ( nm1 ) yp ( n ) = ( slppn - dx1 - sdiag1 * yp ( nm1 )) / diag ! ! perform back substitution ! do i = 2 , n ibak = np1 - i yp ( ibak ) = yp ( ibak ) - temp ( ibak ) * yp ( ibak + 1 ) end do return ! ! too few points ! 8 ierr = 1 return ! ! x-values not strictly increasing ! 9 ierr = 2 return end subroutine fitp_curv1 subroutine fitp_curvs ( n , x , y , d , isw , s , eps , ys , ysp , sigma , temp , ierr ) integer n , isw , ierr real x ( n ), y ( n ), d ( n ), s , eps , ys ( n ), ysp ( n ), sigma , temp ( n , 9 ) ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this subroutine determines the parameters necessary to ! compute a smoothing spline under tension. for a given ! increasing sequence of abscissae (x(i)), i = 1,..., n and ! associated ordinates (y(i)), i = 1,..., n, the function ! determined minimizes the summation from i = 1 to n-1 of ! the square of the second derivative of f plus sigma ! squared times the difference of the first derivative of f ! and (f(x(i+1))-f(x(i)))/(x(i+1)-x(i)) squared, over all ! functions f with two continuous derivatives such that the ! summation of the square of (f(x(i))-y(i))/d(i) is less ! than or equal to a given constant s, where (d(i)), i = 1, ! ..., n are a given set of observation weights. the ! function determined is a spline under tension with third ! derivative discontinuities at (x(i)), i = 2,..., n-1. for ! actual computation of points on the curve it is necessary ! to call the function curv2. the determination of the curve ! is performed by subroutine curvss, the subroutine curvs ! only decomposes the workspace for curvss. ! ! on input-- ! !   n is the number of values to be smoothed (n.ge.2). ! !   x is an array of the n increasing abscissae of the !   values to be smoothed. ! !   y is an array of the n ordinates of the values to be !   smoothed, (i. e. y(k) is the functional value !   corresponding to x(k) ). ! !   d is a parameter containing the observation weights. !   this may either be an array of length n or a scalar !   (interpreted as a constant). the value of d !   corresponding to the observation (x(k),y(k)) should !   be an approximation to the standard deviation of error. ! !   isw contains a switch indicating whether the parameter !   d is to be considered a vector or a scalar, !          = 0 if d is an array of length n, !          = 1 if d is a scalar. ! !   s contains the value controlling the smoothing. this !   must be non-negative. for s equal to zero, the !   subroutine does interpolation, larger values lead to !   smoother funtions. if parameter d contains standard !   deviation estimates, a reasonable value for s is !   float(n). ! !   eps contains a tolerance on the relative precision to !   which s is to be interpreted. this must be greater than !   or equal to zero and less than or equal to one. a !   reasonable value for eps is sqrt(2./float(n)). ! !   ys is an array of length at least n. ! !   ysp is an array of length at least n. ! !   sigma contains the tension factor. this value indicates !   the degree to which the first derivative part of the !   smoothing functional is emphasized. if sigma is nearly !   zero (e. g. .001) the resulting curve is approximately a !   cubic spline. if sigma is large (e. g. 50.) the !   resulting curve is nearly a polygonal line. if sigma !   equals zero a cubic spline results. a standard value for !   sigma is approximately 1. ! ! and ! !   temp is an array of length at least 9*n which is used !   for scratch storage. ! ! on output-- ! !   ys contains the smoothed ordinate values. ! !   ysp contains the values of the second derivative of the !   smoothed curve at the given nodes. ! !   ierr contains an error flag, !        = 0 for normal return, !        = 1 if n is less than 2, !        = 2 if s is negative, !        = 3 if eps is negative or greater than one, !        = 4 if x-values are not strictly increasing, !        = 5 if a d-value is non-positive. ! ! and ! !   n, x, y, d, isw, s, eps, and sigma are unaltered. ! ! this subroutine references package modules curvss, terms, ! and snhcsh. ! !----------------------------------------------------------- ! ! decompose temp into nine arrays and call curvss ! call fitp_curvss ( n , x , y , d , isw , s , eps , ys , ysp , sigma , temp ( 1 , 1 ), & temp ( 1 , 2 ), temp ( 1 , 3 ), temp ( 1 , 4 ), temp ( 1 , 5 ), & temp ( 1 , 6 ), temp ( 1 , 7 ), temp ( 1 , 8 ), temp ( 1 , 9 ), & ierr ) end subroutine fitp_curvs real function fitp_curv2 ( t , n , x , y , yp , sigma ) integer n real t , x ( n ), y ( n ), yp ( n ), sigma ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this function interpolates a curve at a given point ! using a spline under tension. the subroutine curv1 should ! be called earlier to determine certain necessary ! parameters. ! ! on input-- ! !   t contains a real value to be mapped onto the interpo- !   lating curve. ! !   n contains the number of points which were specified to !   determine the curve. ! !   x and y are arrays containing the abscissae and !   ordinates, respectively, of the specified points. ! !   yp is an array of second derivative values of the curve !   at the nodes. ! ! and ! !   sigma contains the tension factor (its sign is ignored). ! ! the parameters n, x, y, yp, and sigma should be input ! unaltered from the output of curv1. ! ! on output-- ! !   curv2 contains the interpolated value. ! ! none of the input parameters are altered. ! ! this function references package modules intrvl and ! snhcsh. ! !----------------------------------------------------------- integer i , im1 real ss , sigdel , dummy , s1 , s2 , sum , sigmap real del1 , del2 , dels ! ! determine interval ! im1 = fitp_intrvl ( t , x , n ) i = im1 + 1 ! ! denormalize tension factor ! sigmap = abs ( sigma ) * real ( n - 1 ) / ( x ( n ) - x ( 1 )) ! ! set up and perform interpolation ! del1 = t - x ( im1 ) del2 = x ( i ) - t dels = x ( i ) - x ( im1 ) sum = ( y ( i ) * del1 + y ( im1 ) * del2 ) / dels if ( sigmap /= 0. ) go to 1 fitp_curv2 = sum - del1 * del2 * ( yp ( i ) * ( del1 + dels ) + yp ( im1 ) * ( del2 + dels )) / ( 6. * dels ) return 1 sigdel = sigmap * dels call fitp_snhcsh ( ss , dummy , sigdel , - 1 ) call fitp_snhcsh ( s1 , dummy , sigmap * del1 , - 1 ) call fitp_snhcsh ( s2 , dummy , sigmap * del2 , - 1 ) fitp_curv2 = sum + ( yp ( i ) * del1 * ( s1 - ss ) + yp ( im1 ) * del2 * ( s2 - ss )) / ( sigdel * sigmap * ( 1. + ss )) return end function fitp_curv2 real function fitp_curvd ( t , n , x , y , yp , sigma ) integer n real t , x ( n ), y ( n ), yp ( n ), sigma ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this function differentiates a curve at a given point ! using a spline under tension. the subroutine curv1 should ! be called earlier to determine certain necessary ! parameters. ! ! on input-- ! !   t contains a real value at which the derivative is to be !   determined. ! !   n contains the number of points which were specified to !   determine the curve. ! !   x and y are arrays containing the abscissae and !   ordinates, respectively, of the specified points. ! !   yp is an array of second derivative values of the curve !   at the nodes. ! ! and ! !   sigma contains the tension factor (its sign is ignored). ! ! the parameters n, x, y, yp, and sigma should be input ! unaltered from the output of curv1. ! ! on output-- ! !   curvd contains the derivative value. ! ! none of the input parameters are altered. ! ! this function references package modules intrvl and ! snhcsh. ! !----------------------------------------------------------- integer i , im1 real ss , sigdel , dummy , c1 , c2 , sum , sigmap real del1 , del2 , dels ! ! determine interval ! im1 = fitp_intrvl ( t , x , n ) i = im1 + 1 ! ! denormalize tension factor ! sigmap = abs ( sigma ) * real ( n - 1 ) / ( x ( n ) - x ( 1 )) ! ! set up and perform differentiation ! del1 = t - x ( im1 ) del2 = x ( i ) - t dels = x ( i ) - x ( im1 ) sum = ( y ( i ) - y ( im1 )) / dels if ( sigmap /= 0. ) go to 1 fitp_curvd = sum + ( yp ( i ) * ( 2. * del1 * del1 - del2 * ( del1 + dels )) - & yp ( im1 ) * ( 2. * del2 * del2 - del1 * ( del2 + dels ))) & / ( 6. * dels ) return 1 sigdel = sigmap * dels call fitp_snhcsh ( ss , dummy , sigdel , - 1 ) call fitp_snhcsh ( dummy , c1 , sigmap * del1 , 1 ) call fitp_snhcsh ( dummy , c2 , sigmap * del2 , 1 ) fitp_curvd = sum + ( yp ( i ) * ( c1 - ss ) - yp ( im1 ) * ( c2 - ss )) / ( sigdel * sigmap * ( 1. + ss )) return end function fitp_curvd real function fitp_curvi ( xl , xu , n , x , y , yp , sigma ) integer n real xl , xu , x ( n ), y ( n ), yp ( n ), sigma ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this function integrates a curve specified by a spline ! under tension between two given limits. the subroutine ! curv1 should be called earlier to determine necessary ! parameters. ! ! on input-- ! !   xl and xu contain the upper and lower limits of inte- !   gration, respectively. (sl need not be less than or !   equal to xu, curvi (xl,xu,...) .eq. -curvi (xu,xl,...) ). ! !   n contains the number of points which were specified to !   determine the curve. ! !   x and y are arrays containing the abscissae and !   ordinates, respectively, of the specified points. ! !   yp is an array from subroutine curv1 containing !   the values of the second derivatives at the nodes. ! ! and ! !   sigma contains the tension factor (its sign is ignored). ! ! the parameters n, x, y, yp, and sigma should be input ! unaltered from the output of curv1. ! ! on output-- ! !   curvi contains the integral value. ! ! none of the input parameters are altered. ! ! this function references package modules intrvl and ! snhcsh. ! !----------------------------------------------------------- integer i , ilp1 , ilm1 , il , ium1 , iu real delu1 , delu2 , c2 , ss , cs , cu2 , cl1 , cl2 , cu1 real dell1 , dell2 , deli , c1 , ssign , sigmap real xxl , xxu , t1 , t2 , dummy , dels , sum , del1 , del2 ! ! denormalize tension factor ! sigmap = abs ( sigma ) * real ( n - 1 ) / ( x ( n ) - x ( 1 )) ! ! determine actual upper and lower bounds ! xxl = xl xxu = xu ssign = 1. if ( xl < xu ) go to 1 xxl = xu xxu = xl ssign = - 1. if ( xl > xu ) go to 1 ! ! return zero if xl .eq. xu ! fitp_curvi = 0. return ! ! search for proper intervals ! 1 ilm1 = fitp_intrvl ( xxl , x , n ) il = ilm1 + 1 ium1 = fitp_intrvl ( xxu , x , n ) iu = ium1 + 1 if ( il == iu ) go to 8 ! ! integrate from xxl to x(il) ! sum = 0. if ( xxl == x ( il )) go to 3 del1 = xxl - x ( ilm1 ) del2 = x ( il ) - xxl dels = x ( il ) - x ( ilm1 ) t1 = ( del1 + dels ) * del2 / ( 2. * dels ) t2 = del2 * del2 / ( 2. * dels ) sum = t1 * y ( il ) + t2 * y ( ilm1 ) if ( sigma == 0. ) go to 2 call fitp_snhcsh ( dummy , c1 , sigmap * del1 , 2 ) call fitp_snhcsh ( dummy , c2 , sigmap * del2 , 2 ) call fitp_snhcsh ( ss , cs , sigmap * dels , 3 ) sum = sum + (( dels * dels * ( cs - ss / 2. ) - del1 * del1 * ( c1 - ss / 2. )) & * yp ( il ) + del2 * del2 * ( c2 - ss / 2. ) * yp ( ilm1 )) / & ( sigmap * sigmap * dels * ( 1. + ss )) go to 3 2 sum = sum - t1 * t1 * dels * yp ( il ) / 6. & - t2 * ( del1 * ( del2 + dels ) + dels * dels ) * yp ( ilm1 ) / 1 2. ! ! integrate over interior intervals ! 3 if ( iu - il == 1 ) go to 6 ilp1 = il + 1 do i = ilp1 , ium1 dels = x ( i ) - x ( i - 1 ) sum = sum + ( y ( i ) + y ( i - 1 )) * dels / 2. if ( sigma == 0. ) go to 4 call fitp_snhcsh ( ss , cs , sigmap * dels , 3 ) sum = sum + ( yp ( i ) + yp ( i - 1 )) * dels * ( cs - ss / 2. ) / ( sigmap * sigmap * ( 1. + ss )) go to 5 4 sum = sum - ( yp ( i ) + yp ( i - 1 )) * dels * dels * dels / 2 4. 5 continue end do ! ! integrate from x(iu-1) to xxu ! 6 if ( xxu == x ( ium1 )) go to 10 del1 = xxu - x ( ium1 ) del2 = x ( iu ) - xxu dels = x ( iu ) - x ( ium1 ) t1 = del1 * del1 / ( 2. * dels ) t2 = ( del2 + dels ) * del1 / ( 2. * dels ) sum = sum + t1 * y ( iu ) + t2 * y ( ium1 ) if ( sigma == 0. ) go to 7 call fitp_snhcsh ( dummy , c1 , sigmap * del1 , 2 ) call fitp_snhcsh ( dummy , c2 , sigmap * del2 , 2 ) call fitp_snhcsh ( ss , cs , sigmap * dels , 3 ) sum = sum + ( yp ( iu ) * del1 * del1 * ( c1 - ss / 2. ) + yp ( ium1 ) * & ( dels * dels * ( cs - ss / 2. ) - del2 * del2 * ( c2 - ss / 2. ))) & / ( sigmap * sigmap * dels * ( 1. + ss )) go to 10 7 sum = sum - t1 * ( del2 * ( del1 + dels ) + dels * dels ) * yp ( iu ) / 1 2. - t2 * t2 * dels * yp ( ium1 ) / 6. go to 10 ! ! integrate from xxl to xxu ! 8 delu1 = xxu - x ( ium1 ) delu2 = x ( iu ) - xxu dell1 = xxl - x ( ium1 ) dell2 = x ( iu ) - xxl dels = x ( iu ) - x ( ium1 ) deli = xxu - xxl t1 = ( delu1 + dell1 ) * deli / ( 2. * dels ) t2 = ( delu2 + dell2 ) * deli / ( 2. * dels ) sum = t1 * y ( iu ) + t2 * y ( ium1 ) if ( sigma == 0. ) go to 9 call fitp_snhcsh ( dummy , cu1 , sigmap * delu1 , 2 ) call fitp_snhcsh ( dummy , cu2 , sigmap * delu2 , 2 ) call fitp_snhcsh ( dummy , cl1 , sigmap * dell1 , 2 ) call fitp_snhcsh ( dummy , cl2 , sigmap * dell2 , 2 ) call fitp_snhcsh ( ss , dummy , sigmap * dels , - 1 ) sum = sum + ( yp ( iu ) * ( delu1 * delu1 * ( cu1 - ss / 2. ) & - dell1 * dell1 * ( cl1 - ss / 2. )) & + yp ( ium1 ) * ( dell2 * dell2 * ( cl2 - ss / 2. ) & - delu2 * delu2 * ( cu2 - ss / 2. ))) / & ( sigmap * sigmap * dels * ( 1. + ss )) go to 10 9 sum = sum - t1 * ( delu2 * ( dels + delu1 ) + dell2 * ( dels + dell1 )) * & yp ( iu ) / 1 2. & - t2 * ( dell1 * ( dels + dell2 ) + delu1 * ( dels + delu2 )) * & yp ( ium1 ) / 1 2. ! ! correct sign and return ! 10 fitp_curvi = ssign * sum return end function fitp_curvi subroutine fitp_curvp1 ( n , x , y , p , yp , temp , sigma , ierr ) integer n , ierr real , dimension (:) :: x , y , yp , temp real :: p , sigma !!    real x(n),y(n),p,yp(n),temp(2*n),sigma !      real x(n),y(n),p,yp(n),temp(1),sigma ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this subroutine determines the parameters necessary to ! compute a periodic interpolatory spline under tension ! through a sequence of functional values. for actual ends ! of the curve may be specified or omitted.  for actual ! computation of points on the curve it is necessary to call ! the function curvp2. ! ! on input-- ! !   n is the number of values to be interpolated (n.ge.2). ! !   x is an array of the n increasing abscissae of the !   functional values. ! !   y is an array of the n ordinates of the values, (i. e. !   y(k) is the functional value corresponding to x(k) ). ! !   p is the period (p .gt. x(n)-x(1)). ! !   yp is an array of length at least n. ! !   temp is an array of length at least 2*n which is used !   for scratch storage. ! ! and ! !   sigma contains the tension factor.  this value indicates !   the curviness desired. if abs(sigma) is nearly zero !   (e.g. .001) the resulting curve is approximately a !   cubic spline. if abs(sigma) is large (e.g. 50.) the !   resulting curve is nearly a polygonal line. if sigma !   equals zero a cubic spline results.  a standard value !   for sigma is approximately 1. in absolute value. ! ! on output-- ! !   yp contains the values of the second derivative of the !   curve at the given nodes. ! !   ierr contains an error flag, !        = 0 for normal return, !        = 1 if n is less than 2, !        = 2 if p is less than or equal to x(n)-x(1), !        = 3 if x-values are not strictly increasing. ! ! and ! !  n, x, y, and sigma are unaltered. ! ! this subroutine references package modules terms and ! snhcsh. ! !----------------------------------------------------------- integer i , npibak , npi , ibak , nm1 , np1 real diag , diag2 , sdiag2 , ypn , dx2 , sigmap , delx1 real sdiag1 , delx2 , dx1 , diag1 nm1 = n - 1 np1 = n + 1 ierr = 0 if ( n <= 1 ) go to 6 if ( p <= x ( n ) - x ( 1 ) . or . p <= 0. ) go to 7 ! ! denormalize tension factor ! sigmap = abs ( sigma ) * real ( n ) / p ! ! set up right hand side and tridiagonal system for yp and ! perform forward elimination ! delx1 = p - ( x ( n ) - x ( 1 )) dx1 = ( y ( 1 ) - y ( n )) / delx1 call fitp_terms ( diag1 , sdiag1 , sigmap , delx1 ) delx2 = x ( 2 ) - x ( 1 ) if ( delx2 <= 0. ) go to 8 dx2 = ( y ( 2 ) - y ( 1 )) / delx2 call fitp_terms ( diag2 , sdiag2 , sigmap , delx2 ) diag = diag1 + diag2 yp ( 1 ) = ( dx2 - dx1 ) / diag temp ( np1 ) = - sdiag1 / diag temp ( 1 ) = sdiag2 / diag dx1 = dx2 diag1 = diag2 sdiag1 = sdiag2 if ( n == 2 ) go to 2 do i = 2 , nm1 npi = n + i delx2 = x ( i + 1 ) - x ( i ) if ( delx2 <= 0. ) go to 8 dx2 = ( y ( i + 1 ) - y ( i )) / delx2 call fitp_terms ( diag2 , sdiag2 , sigmap , delx2 ) diag = diag1 + diag2 - sdiag1 * temp ( i - 1 ) yp ( i ) = ( dx2 - dx1 - sdiag1 * yp ( i - 1 )) / diag temp ( npi ) = - temp ( npi - 1 ) * sdiag1 / diag temp ( i ) = sdiag2 / diag dx1 = dx2 diag1 = diag2 sdiag1 = sdiag2 end do 2 delx2 = p - ( x ( n ) - x ( 1 )) dx2 = ( y ( 1 ) - y ( n )) / delx2 call fitp_terms ( diag2 , sdiag2 , sigmap , delx2 ) yp ( n ) = dx2 - dx1 temp ( nm1 ) = temp ( 2 * n - 1 ) - temp ( nm1 ) if ( n == 2 ) go to 4 ! ! perform first step of back substitution ! do i = 3 , n ibak = np1 - i npibak = n + ibak yp ( ibak ) = yp ( ibak ) - temp ( ibak ) * yp ( ibak + 1 ) temp ( ibak ) = temp ( npibak ) - temp ( ibak ) * temp ( ibak + 1 ) end do 4 yp ( n ) = ( yp ( n ) - sdiag2 * yp ( 1 ) - sdiag1 * yp ( nm1 )) / & ( diag1 + diag2 + sdiag2 * temp ( 1 ) + sdiag1 * temp ( nm1 )) ! ! perform second step of back substitution ! ypn = yp ( n ) do i = 1 , nm1 yp ( i ) = yp ( i ) + temp ( i ) * ypn end do return ! ! too few points ! 6 ierr = 1 return ! ! period too small ! 7 ierr = 2 return ! ! x-values not strictly increasing ! 8 ierr = 3 return end subroutine fitp_curvp1 subroutine fitp_curvps ( n , x , y , p , d , isw , s , eps , ys , ysp , sigma , temp , ierr ) integer n , isw , ierr real x ( n ), y ( n ), p , d ( n ), s , eps , ys ( n ), ysp ( n ), sigma , temp ( n , 11 ) ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this subroutine determines the parameters necessary to ! compute a periodic smoothing spline under tension. for a ! given increasing sequence of abscissae (x(i)), i = 1,...,n ! and associated ordinates (y(i)), i = 1,...,n, letting p be ! the period, x(n+1) = x(1)+p, and y(n+1) = y(1), the ! function determined minimizes the summation from i = 1 to ! n of the square of the second derivative of f plus sigma ! squared times the difference of the first derivative of f ! and (f(x(i+1))-f(x(i)))/(x(i+1)-x(i)) squared, over all ! functions f with period p and two continuous derivatives ! such that the summation of the square of ! (f(x(i))-y(i))/d(i) is less than or equal to a given ! constant s, where (d(i)), i = 1,...,n are a given set of ! observation weights. the function determined is a periodic ! spline under tension with third derivative discontinuities ! at (x(i)) i = 1,...,n (and all periodic translations of ! these values). for actual computation of points on the ! curve it is necessary to call the function curvp2. the ! determination of the curve is performed by subroutine ! curvpp, the subroutin curvps only decomposes the workspace ! for curvpp. ! ! on input-- ! !   n is the number of values to be smoothed (n.ge.2). ! !   x is an array of the n increasing abscissae of the !   values to be smoothed. ! !   y is an array of the n ordinates of the values to be !   smoothed, (i. e. y(k) is the functional value !   corresponding to x(k) ). ! !   p is the period (p .gt. x(n)-x(1)). ! !   d is a parameter containing the observation weights. !   this may either be an array of length n or a scalar !   (interpreted as a constant). the value of d !   corresponding to the observation (x(k),y(k)) should !   be an approximation to the standard deviation of error. ! !   isw contains a switch indicating whether the parameter !   d is to be considered a vector or a scalar, !          = 0 if d is an array of length n, !          = 1 if d is a scalar. ! !   s contains the value controlling the smoothing. this !   must be non-negative. for s equal to zero, the !   subroutine does interpolation, larger values lead to !   smoother funtions. if parameter d contains standard !   deviation estimates, a reasonable value for s is !   float(n). ! !   eps contains a tolerance on the relative precision to !   which s is to be interpreted. this must be greater than !   or equal to zero and less than or equal to one. a !   reasonable value for eps is sqrt(2./float(n)). ! !   ys is an array of length at least n. ! !   ysp is an array of length at least n. ! !   sigma contains the tension factor. this value indicates !   the degree to which the first derivative part of the !   smoothing functional is emphasized. if sigma is nearly !   zero (e. g. .001) the resulting curve is approximately a !   cubic spline. if sigma is large (e. g. 50.) the !   resulting curve is nearly a polygonal line. if sigma !   equals zero a cubic spline results. a standard value for !   sigma is approximately 1. ! ! and ! !   temp is an array of length at least 11*n which is used !   for scratch storage. ! ! on output-- ! !   ys contains the smoothed ordinate values. ! !   ysp contains the values of the second derivative of the !   smoothed curve at the given nodes. ! !   ierr contains an error flag, !        = 0 for normal return, !        = 1 if n is less than 2, !        = 2 if s is negative, !        = 3 if eps is negative or greater than one, !        = 4 if x-values are not strictly increasing, !        = 5 if a d-value is non-positive, !        = 6 if p is less than or equal to x(n)-x(1). ! ! and ! !   n, x, y, p, d, isw, s, eps, and sigma are unaltered. ! ! this subroutine references package modules curvpp, terms, ! and snhcsh. ! !----------------------------------------------------------- ! ! decompose temp into eleven arrays and call curvpp ! call fitp_curvpp ( n , x , y , p , d , isw , s , eps , ys , ysp , sigma , & temp ( 1 , 1 ), temp ( 1 , 2 ), temp ( 1 , 3 ), temp ( 1 , 4 ), & temp ( 1 , 5 ), temp ( 1 , 6 ), temp ( 1 , 7 ), temp ( 1 , 8 ), & temp ( 1 , 9 ), temp ( 1 , 10 ), temp ( 1 , 11 ), ierr ) return end subroutine fitp_curvps real function fitp_curvp2 ( t , n , x , y , p , yp , sigma ) integer n real , dimension (:) :: x , y , yp real :: t , p , sigma !    real t,x(n),y(n),p,yp(n),sigma ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this function interpolates a curve at a given point using ! a periodic spline under tension. the subroutine curvp1 ! should be called earlier to determine certain necessary ! parameters. ! ! on input-- ! !   t contains a real value to be mapped onto the interpo- !   lating curve. ! !   n contains the number of points which were specified to !   determine the curve. ! !   x and y are arrays containing the abscissae and !   ordinates, respectively, of the specified points. ! !   p contains the period. ! !   yp is an array of second derivative values of the curve !   at the nodes. ! ! and ! !   sigma contains the tension factor (its sign is ignored). ! ! the parameters n, x, y, p, yp, and sigma should be input ! unaltered from the output of curvp1. ! ! on output-- ! !   curvp2 contains the interpolated value. ! ! none of the input parameters are altered. ! ! this function references package modules intrvp and ! snhcsh. ! !----------------------------------------------------------- integer i , im1 real ss , sigdel , sum , s2 , s1 , dummy real tp , sigmap , dels , del2 , del1 ! ! determine interval ! im1 = fitp_intrvp ( t , x , n , p , tp ) i = im1 + 1 ! ! denormalize tension factor ! sigmap = abs ( sigma ) * real ( n ) / p ! ! set up and perform interpolation ! del1 = tp - x ( im1 ) if ( im1 == n ) go to 1 del2 = x ( i ) - tp dels = x ( i ) - x ( im1 ) go to 2 1 i = 1 del2 = x ( 1 ) + p - tp dels = p - ( x ( n ) - x ( 1 )) 2 sum = ( y ( i ) * del1 + y ( im1 ) * del2 ) / dels if ( sigmap /= 0. ) go to 3 fitp_curvp2 = sum - del1 * del2 * ( yp ( i ) * ( del1 + dels ) + yp ( im1 ) * ( del2 + dels )) / ( 6. * dels ) return 3 sigdel = sigmap * dels call fitp_snhcsh ( ss , dummy , sigdel , - 1 ) call fitp_snhcsh ( s1 , dummy , sigmap * del1 , - 1 ) call fitp_snhcsh ( s2 , dummy , sigmap * del2 , - 1 ) fitp_curvp2 = sum + ( yp ( i ) * del1 * ( s1 - ss ) + yp ( im1 ) * del2 * ( s2 - ss )) / ( sigdel * sigmap * ( 1. + ss )) end function fitp_curvp2 real function fitp_curvpd ( t , n , x , y , p , yp , sigma ) integer n real t , x ( n ), y ( n ), p , yp ( n ), sigma ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this function is the derivative of curvp2 ! interpolates a curve at a given point using ! a periodic spline under tension. the subroutine curvp1 ! should be called earlier to determine certain necessary ! parameters. ! ! on input-- ! !   t contains a real value to be mapped onto the interpo- !   lating curve. ! !   n contains the number of points which were specified to !   determine the curve. ! !   x and y are arrays containing the abscissae and !   ordinates, respectively, of the specified points. ! !   p contains the period. ! !   yp is an array of second derivative values of the curve !   at the nodes. ! ! and ! !   sigma contains the tension factor (its sign is ignored). ! ! the parameters n, x, y, p, yp, and sigma should be input ! unaltered from the output of curvp1. ! ! on output-- ! !   curvpd contains the interpolated derivative ! ! none of the input parameters are altered. ! ! this function references package modules intrvp and ! snhcsh. ! !----------------------------------------------------------- integer i , im1 real ss , sigdel , sum , c2 , c1 , dummy real tp , sigmap , dels , del2 , del1 ! ! determine interval ! im1 = fitp_intrvp ( t , x , n , p , tp ) i = im1 + 1 ! ! denormalize tension factor ! sigmap = abs ( sigma ) * real ( n ) / p ! ! set up and perform interpolation ! del1 = tp - x ( im1 ) if ( im1 == n ) go to 1 del2 = x ( i ) - tp dels = x ( i ) - x ( im1 ) go to 2 1 i = 1 del2 = x ( 1 ) + p - tp dels = p - ( x ( n ) - x ( 1 )) 2 sum = ( y ( i ) - y ( im1 )) / dels if ( sigmap /= 0. ) go to 3 fitp_curvpd = sum + ( yp ( i ) * ( 2. * del1 * del1 - del2 * ( del1 + dels )) - & yp ( im1 ) * ( 2. * del2 * del2 - del1 * ( del2 + dels ))) & / ( 6. * dels ) return 3 sigdel = sigmap * dels call fitp_snhcsh ( ss , dummy , sigdel , - 1 ) call fitp_snhcsh ( dummy , c1 , sigmap * del1 , - 1 ) call fitp_snhcsh ( dummy , c2 , sigmap * del2 , - 1 ) fitp_curvpd = sum + ( yp ( i ) * ( c1 - ss ) - yp ( im1 ) * ( c2 - ss )) / ( sigdel * sigmap * ( 1. + ss )) return end function fitp_curvpd real function fitp_curvpi ( xl , xu , n , x , y , p , yp , sigma ) integer n real xl , xu , x ( n ), y ( n ), p , yp ( n ), sigma ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this function integrates a curve specified by a periodic ! spline under tension between two given limits. the ! subroutine curvp1 should be called earlier to determine ! necessary parameters. ! ! on input-- ! !   xl and xu contain the upper and lower limits of inte- !   gration, respectively. (sl need not be less than or !   equal to xu, curvpi (xl,xu,...) .eq. -curvpi (xu,xl,...) ). ! !   n contains the number of points which were specified to !   determine the curve. ! !   x and y are arrays containing the abscissae and !   ordinates, respectively, of the specified points. ! !   p contains the period. ! !   yp is an array from subroutine curvp1 containing !   the values of the second derivatives at the nodes. ! ! and ! !   sigma contains the tension factor (its sign is ignored). ! ! the parameters n, x, y, p, yp, and sigma should be input ! unaltered from the output of curvp1. ! ! on output-- ! ! !   curvpi contains the integral value. ! ! none of the input parameters are altered. ! ! this function references package modules intrvp and ! snhcsh. ! !-------------------------------------------------------------- integer np1 , im1 , ii , iup1 , ilp1 , ideltp real s7 , s6 , s3 , c2 , c1 , s5 , s4 , cl1 , cu2 , cu1 , si , so real cl2 , delu2 , delu1 , s8 , deli , dell2 , dell1 , dummy integer ium1 , il , isave , isign , lper , ilm1 , iu , i real xxu , xsave , x1pp , sigmap , xxl , xil , del1 , s2 , cs real t2 , t1 , del2 , s1 , xiu , ss , dels integer uper logical bdy ! ! denormalize tension factor ! sigmap = abs ( sigma ) * real ( n ) / p ! ! determine actual upper and lower bounds ! x1pp = x ( 1 ) + p isign = 1 ilm1 = fitp_intrvp ( xl , x , n , p , xxl ) lper = int (( xl - x ( 1 )) / p ) if ( xl < x ( 1 )) lper = lper - 1 ium1 = fitp_intrvp ( xu , x , n , p , xxu ) uper = int (( xu - x ( 1 )) / p ) if ( xu < x ( 1 )) uper = uper - 1 ideltp = uper - lper bdy = real ( ideltp ) * ( xxu - xxl ) < 0. if (( ideltp == 0 . and . xxu < xxl ) . or . ideltp < 0 ) isign = - 1 if ( bdy ) ideltp = ideltp - isign if ( xxu >= xxl ) go to 1 xsave = xxl xxl = xxu xxu = xsave isave = ilm1 ilm1 = ium1 ium1 = isave 1 il = ilm1 + 1 if ( ilm1 == n ) il = 1 xil = x ( il ) if ( ilm1 == n ) xil = x1pp iu = ium1 + 1 if ( ium1 == n ) iu = 1 xiu = x ( iu ) if ( ium1 == n ) xiu = x1pp s1 = 0. if ( ilm1 == 1 . or . ( ideltp == 0 . and . . not . bdy )) go to 4 ! ! integrate from x(1) to x(ilm1), store in s1 ! do i = 2 , ilm1 dels = x ( i ) - x ( i - 1 ) s1 = s1 + ( y ( i ) + y ( i - 1 )) * dels / 2. if ( sigma == 0. ) go to 2 call fitp_snhcsh ( ss , cs , sigmap * dels , 3 ) s1 = s1 + ( yp ( i ) + yp ( i - 1 )) * dels * ( cs - ss / 2. ) / ( sigmap * sigmap * ( 1. + ss )) cycle 2 s1 = s1 - ( yp ( i ) + yp ( i - 1 )) * dels * dels * dels / 2 4. end do 4 s2 = 0. if ( x ( ilm1 ) >= xxl . or . ( ideltp == 0 . and . . not . bdy )) go to 6 ! ! integrate from x(ilm1) to xxl, store in s2 ! del1 = xxl - x ( ilm1 ) del2 = xil - xxl dels = xil - x ( ilm1 ) t1 = del1 * del1 / ( 2. * dels ) t2 = ( del2 + dels ) * del1 / ( 2. * dels ) s2 = t1 * y ( il ) + t2 * y ( ilm1 ) if ( sigma == 0. ) go to 5 call fitp_snhcsh ( dummy , c1 , sigmap * del1 , 2 ) call fitp_snhcsh ( dummy , c2 , sigmap * del2 , 2 ) call fitp_snhcsh ( ss , cs , sigmap * dels , 3 ) s2 = s2 + ( yp ( il ) * del1 * del1 * ( c1 - ss / 2. ) + yp ( ilm1 ) * & ( dels * dels * ( cs - ss / 2. ) - del2 * del2 * ( c2 - ss / 2. ))) & / ( sigmap * sigmap * dels * ( 1. + ss )) go to 6 5 s2 = s2 - t1 * ( del2 * ( del1 + dels ) & + dels * dels ) * yp ( il ) / 1 2. & - t2 * t2 * dels * yp ( ilm1 ) / 6. 6 s3 = 0. if ( xxl >= xil . or . ( ideltp == 0 . and . bdy ) . or . ilm1 == ium1 ) go to 8 ! ! integrate from xxl to xil, store in s3 ! del1 = xxl - x ( ilm1 ) del2 = xil - xxl dels = xil - x ( ilm1 ) t1 = ( del1 + dels ) * del2 / ( 2. * dels ) t2 = del2 * del2 / ( 2. * dels ) s3 = t1 * y ( il ) + t2 * y ( ilm1 ) if ( sigma == 0. ) go to 7 call fitp_snhcsh ( dummy , c1 , sigmap * del1 , 2 ) call fitp_snhcsh ( dummy , c2 , sigmap * del2 , 2 ) call fitp_snhcsh ( ss , cs , sigmap * dels , 3 ) s3 = s3 + (( dels * dels * ( cs - ss / 2. ) - del1 * del1 * ( c1 - ss / 2. )) & * yp ( il ) + del2 * del2 * ( c2 - ss / 2. ) * yp ( ilm1 )) / & ( sigmap * sigmap * dels * ( 1. + ss )) go to 8 7 s3 = s3 - t1 * t1 * dels * yp ( il ) / 6. & - t2 * ( del1 * ( del2 + dels ) + dels * dels ) * & yp ( ilm1 ) / 1 2. 8 s4 = 0. if ( ilm1 >= ium1 - 1 . or . ( ideltp == 0 . and . bdy )) go to 11 ! ! integrate from xil to x(ium1), store in s4 ! ilp1 = il + 1 do i = ilp1 , ium1 dels = x ( i ) - x ( i - 1 ) s4 = s4 + ( y ( i ) + y ( i - 1 )) * dels / 2. if ( sigma == 0. ) go to 9 call fitp_snhcsh ( ss , cs , sigmap * dels , 3 ) s4 = s4 + ( yp ( i ) + yp ( i - 1 )) * dels * ( cs - ss / 2. ) / ( sigmap * sigmap * ( 1. + ss )) cycle 9 s4 = s4 - ( yp ( i ) + yp ( i - 1 )) * dels * dels * dels / 2 4. end do 11 s5 = 0. if ( x ( ium1 ) >= xxu . or . ( ideltp == 0 . and . bdy ) . or . ilm1 == ium1 ) go to 13 ! ! integrate from x(ium1) to xxu, store in s5 ! del1 = xxu - x ( ium1 ) del2 = xiu - xxu dels = xiu - x ( ium1 ) t1 = del1 * del1 / ( 2. * dels ) t2 = ( del2 + dels ) * del1 / ( 2. * dels ) s5 = t1 * y ( iu ) + t2 * y ( ium1 ) if ( sigma == 0. ) go to 12 call fitp_snhcsh ( dummy , c1 , sigmap * del1 , 2 ) call fitp_snhcsh ( dummy , c2 , sigmap * del2 , 2 ) call fitp_snhcsh ( ss , cs , sigmap * dels , 3 ) s5 = s5 + ( yp ( iu ) * del1 * del1 * ( c1 - ss / 2. ) + yp ( ium1 ) * & ( dels * dels * ( cs - ss / 2. ) - del2 * del2 * ( c2 - ss / 2. ))) & / ( sigmap * sigmap * dels * ( 1. + ss )) go to 13 12 s5 = s5 - t1 * ( del2 * ( del1 + dels ) + dels * dels ) * yp ( iu ) / 1 2. - t2 * t2 * dels * yp ( ium1 ) / 6. 13 s6 = 0. if ( xxu >= xiu . or . ( ideltp == 0 . and . . not . bdy )) go to 15 ! ! integrate from xxu to xiu, store in s6 ! del1 = xxu - x ( ium1 ) del2 = xiu - xxu dels = xiu - x ( ium1 ) t1 = ( del1 + dels ) * del2 / ( 2. * dels ) t2 = del2 * del2 / ( 2. * dels ) s6 = t1 * y ( iu ) + t2 * y ( ium1 ) if ( sigma == 0. ) go to 14 call fitp_snhcsh ( dummy , c1 , sigmap * del1 , 2 ) call fitp_snhcsh ( dummy , c2 , sigmap * del2 , 2 ) call fitp_snhcsh ( ss , cs , sigmap * dels , 3 ) s6 = s6 + (( dels * dels * ( cs - ss / 2. ) - del1 * del1 * ( c1 - ss / 2. )) & * yp ( iu ) + del2 * del2 * ( c2 - ss / 2. ) * yp ( ium1 )) / & ( sigmap * sigmap * dels * ( 1. + ss )) go to 15 14 s6 = s6 - t1 * t1 * dels * yp ( iu ) / 6. - t2 * ( del1 * ( del2 + dels ) + dels * dels ) * yp ( ium1 ) / 1 2. 15 s7 = 0. if ( iu == 1 . or . ( ideltp == 0 . and . . not . bdy )) go to 18 ! ! integrate from xiu to x1pp, store in s7 ! np1 = n + 1 iup1 = iu + 1 do ii = iup1 , np1 im1 = ii - 1 i = ii if ( i == np1 ) i = 1 dels = x ( i ) - x ( im1 ) if ( dels <= 0. ) dels = dels + p s7 = s7 + ( y ( i ) + y ( im1 )) * dels / 2. if ( sigma == 0. ) go to 16 call fitp_snhcsh ( ss , cs , sigmap * dels , 3 ) s7 = s7 + ( yp ( i ) + yp ( im1 )) * dels * ( cs - ss / 2. ) / ( sigmap * sigmap * ( 1. + ss )) cycle 16 s7 = s7 - ( yp ( i ) + yp ( im1 )) * dels * dels * dels / 2 4. end do 18 s8 = 0. if ( ilm1 < ium1 . or . ( ideltp == 0 . and . bdy )) go to 20 ! ! integrate from xxl to xxu, store in s8 ! delu1 = xxu - x ( ium1 ) delu2 = xiu - xxu dell1 = xxl - x ( ium1 ) dell2 = xiu - xxl dels = xiu - x ( ium1 ) deli = xxu - xxl t1 = ( delu1 + dell1 ) * deli / ( 2. * dels ) t2 = ( delu2 + dell2 ) * deli / ( 2. * dels ) s8 = t1 * y ( iu ) + t2 * y ( ium1 ) if ( sigma == 0. ) go to 19 call fitp_snhcsh ( dummy , cu1 , sigmap * delu1 , 2 ) call fitp_snhcsh ( dummy , cu2 , sigmap * delu2 , 2 ) call fitp_snhcsh ( dummy , cl1 , sigmap * dell1 , 2 ) call fitp_snhcsh ( dummy , cl2 , sigmap * dell2 , 2 ) call fitp_snhcsh ( ss , dummy , sigmap * dels , - 1 ) s8 = s8 + ( yp ( iu ) * ( delu1 * delu1 * ( cu1 - ss / 2. ) & - dell1 * dell1 * ( cl1 - ss / 2. )) & + yp ( ium1 ) * ( dell2 * dell2 * ( cl2 - ss / 2. ) & - delu2 * delu2 * ( cu2 - ss / 2. ))) / & ( sigmap * sigmap * dels * ( 1. + ss )) go to 20 19 s8 = s8 - t1 * ( delu2 * ( dels + delu1 ) & + dell2 * ( dels + dell1 )) * yp ( iu ) / 1 2. & - t2 * ( dell1 * ( dels + dell2 ) & + delu1 * ( dels + delu2 )) * yp ( ium1 ) / 1 2. 20 so = s1 + s2 + s6 + s7 si = s3 + s4 + s5 + s8 if ( bdy ) go to 21 fitp_curvpi = real ( ideltp ) * ( so + si ) + real ( isign ) * si return 21 fitp_curvpi = real ( ideltp ) * ( so + si ) + real ( isign ) * so return end function fitp_curvpi subroutine fitp_kurv1 ( n , x , y , slp1 , slpn , islpsw , xp , yp , temp , s , sigma , ierr ) integer n , islpsw , ierr real x ( n ), y ( n ), slp1 , slpn , xp ( n ), yp ( n ), temp ( n ), s ( n ), sigma ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this subroutine determines the parameters necessary to ! compute a spline under tension forming a curve in the ! plane and passing through a sequence of pairs (x(1),y(1)), ! ...,(x(n),y(n)). for actual computation of points on the ! curve it is necessary to call the subroutine kurv2. ! ! on input-- ! !   n is the number of points to be interpolated (n.ge.2). ! !   x is an array containing the n x-coordinates of the !   points. ! !   y is an array containing the n y-coordinates of the !   points. (adjacent x-y pairs must be distinct, i. e. !   either x(i) .ne. x(i+1) or y(i) .ne. y(i+1), for !   i = 1,...,n-1.) ! !   slp1 and slpn contain the desired values for the angles !   (in radians) of the slope at (x(1),y(1)) and (x(n),y(n)) !   respectively. the angles are measured counter-clock- !   wise from the x-axis and the positive sense of the curve !   is assumed to be that moving from point 1 to point n. !   the user may omit values for either or both of these !   parameters and signal this with islpsw. ! !   islpsw contains a switch indicating which slope data !   should be used and which should be estimated by this !   subroutine, !          = 0 if slp1 and slpn are to be used, !          = 1 if slp1 is to be used but not slpn, !          = 2 if slpn is to be used but not slp1, !          = 3 if both slp1 and slpn are to be estimated !              internally. ! !   xp and yp are arrays of length at least n. ! !   temp is an array of length at least n which is used !   for scratch storage. ! !   s is an array of length at least n. ! ! and ! !   sigma contains the tension factor. this value indicates !   the curviness desired. if abs(sigma) is nearly zero !   (e.g. .001) the resulting curve is approximately a cubic !   spline. if abs(sigma) is large (e. g. 50.) the resulting !   curve is nearly a polygonal line. if sigma equals zero a !   cubic spline results. a standard value for sigma is !   approximately 1. in absolute value. ! ! on output-- ! !   xp and yp contain information about the curvature of the !   curve at the given nodes. ! !   s contains the polygonal arclengths of the curve. ! !   ierr contains an error flag, !        = 0 for normal return, !        = 1 if n is less than 2, !        = 2 if adjacent coordinate pairs coincide. ! ! and ! !   n, x, y, slp1, slpn, islpsw, and sigma are unaltered. ! ! this subroutine references package modules ceez, terms, ! and snhcsh. ! !----------------------------------------------------------- integer ibak , im1 , nm1 , np1 , i real dx1 , dy1 , diag1 , delsnm , slppnx , slppny , delsn real diag , diagin , sdiag1 , sdiag2 , dx2 , dy2 , diag2 real sigmap , slpp1x , slpp1y , dels1 , sx , sy , delt real c3 , dels2 , c1 , c2 nm1 = n - 1 np1 = n + 1 ierr = 0 if ( n <= 1 ) go to 11 ! ! determine polygonal arclengths ! s ( 1 ) = 0. do i = 2 , n im1 = i - 1 s ( i ) = s ( im1 ) + sqrt (( x ( i ) - x ( im1 )) ** 2 + ( y ( i ) - y ( im1 )) ** 2 ) end do ! ! denormalize tension factor ! sigmap = abs ( sigma ) * real ( n - 1 ) / s ( n ) ! ! approximate end slopes ! if ( islpsw >= 2 ) go to 2 slpp1x = cos ( slp1 ) slpp1y = sin ( slp1 ) go to 4 2 dels1 = s ( 2 ) - s ( 1 ) dels2 = dels1 + dels1 if ( n > 2 ) dels2 = s ( 3 ) - s ( 1 ) if ( dels1 == 0. . or . dels2 == 0. ) go to 12 call fitp_ceez ( dels1 , dels2 , sigmap , c1 , c2 , c3 , n ) sx = c1 * x ( 1 ) + c2 * x ( 2 ) sy = c1 * y ( 1 ) + c2 * y ( 2 ) if ( n == 2 ) go to 3 sx = sx + c3 * x ( 3 ) sy = sy + c3 * y ( 3 ) 3 delt = sqrt ( sx * sx + sy * sy ) slpp1x = sx / delt slpp1y = sy / delt 4 if ( islpsw == 1 . or . islpsw == 3 ) go to 5 slppnx = cos ( slpn ) slppny = sin ( slpn ) go to 7 5 delsn = s ( n ) - s ( nm1 ) delsnm = delsn + delsn if ( n > 2 ) delsnm = s ( n ) - s ( n - 2 ) if ( delsn == 0. . or . delsnm == 0. ) go to 12 call fitp_ceez ( - delsn , - delsnm , sigmap , c1 , c2 , c3 , n ) sx = c1 * x ( n ) + c2 * x ( nm1 ) sy = c1 * y ( n ) + c2 * y ( nm1 ) if ( n == 2 ) go to 6 sx = sx + c3 * x ( n - 2 ) sy = sy + c3 * y ( n - 2 ) 6 delt = sqrt ( sx * sx + sy * sy ) slppnx = sx / delt slppny = sy / delt ! ! set up right hand sides and tridiagonal system for xp and ! yp and perform forward elimination ! 7 dx1 = ( x ( 2 ) - x ( 1 )) / s ( 2 ) dy1 = ( y ( 2 ) - y ( 1 )) / s ( 2 ) call fitp_terms ( diag1 , sdiag1 , sigmap , s ( 2 )) xp ( 1 ) = ( dx1 - slpp1x ) / diag1 yp ( 1 ) = ( dy1 - slpp1y ) / diag1 temp ( 1 ) = sdiag1 / diag1 if ( n == 2 ) go to 9 do i = 2 , nm1 dels2 = s ( i + 1 ) - s ( i ) if ( dels2 == 0. ) go to 12 dx2 = ( x ( i + 1 ) - x ( i )) / dels2 dy2 = ( y ( i + 1 ) - y ( i )) / dels2 call fitp_terms ( diag2 , sdiag2 , sigmap , dels2 ) diag = diag1 + diag2 - sdiag1 * temp ( i - 1 ) diagin = 1. / diag xp ( i ) = ( dx2 - dx1 - sdiag1 * xp ( i - 1 )) * diagin yp ( i ) = ( dy2 - dy1 - sdiag1 * yp ( i - 1 )) * diagin temp ( i ) = sdiag2 * diagin dx1 = dx2 dy1 = dy2 diag1 = diag2 sdiag1 = sdiag2 end do 9 diag = diag1 - sdiag1 * temp ( nm1 ) xp ( n ) = ( slppnx - dx1 - sdiag1 * xp ( nm1 )) / diag yp ( n ) = ( slppny - dy1 - sdiag1 * yp ( nm1 )) / diag ! ! perform back substitution ! do i = 2 , n ibak = np1 - i xp ( ibak ) = xp ( ibak ) - temp ( ibak ) * xp ( ibak + 1 ) yp ( ibak ) = yp ( ibak ) - temp ( ibak ) * yp ( ibak + 1 ) end do return ! ! too few points ! 11 ierr = 1 return ! ! coincident adjacent points ! 12 ierr = 2 return end subroutine fitp_kurv1 subroutine fitp_kurv2 ( t , xs , ys , n , x , y , xp , yp , s , sigma ) integer n real t , xs , ys , x ( n ), y ( n ), xp ( n ), yp ( n ), s ( n ), sigma ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this subroutine performs the mapping of points in the ! interval (0.,1.) onto a curve in the plane. the subroutine ! kurv1 should be called earlier to determine certain ! necessary parameters. the resulting curve has a parametric ! representation both of whose components are splines under ! tension and functions of the polygonal arclength ! parameter. ! ! on input-- ! !   t contains a real value to be mapped to a point on the !   curve. the interval (0.,1.) is mapped onto the entire !   curve, with 0. mapping to (x(1),y(1)) and 1. mapping !   to (x(n),y(n)). values outside this interval result in !   extrapolation. ! !   n contains the number of points which were specified !   to determine the curve. ! !   x and y are arrays containing the x- and y-coordinates !   of the specified points. ! !   xp and yp are the arrays output from kurv1 containing !   curvature information. ! !   s is an array containing the polygonal arclengths of !   the curve. ! ! and ! !   sigma contains the tension factor (its sign is ignored). ! ! the parameters n, x, y, xp, yp, s, and sigma should be ! input unaltered from the output of kurv1. ! ! on output-- ! !   xs and ys contain the x- and y-coordinates of the image !   point on the curve. ! ! none of the input parameters are altered. ! ! this subroutine references package modules intrvl and ! snhcsh. ! !----------------------------------------------------------- integer i , im1 real c2 , sigdel , d , c1 , s1 , s2 , ss , dummy real sigmap , tn , del1 , sumx , sumy , del2 , dels ! ! determine interval ! tn = s ( n ) * t im1 = fitp_intrvl ( tn , s , n ) i = im1 + 1 ! ! denormalize tension factor ! sigmap = abs ( sigma ) * real ( n - 1 ) / s ( n ) ! ! set up and perform interpolation ! del1 = tn - s ( im1 ) del2 = s ( i ) - tn dels = s ( i ) - s ( im1 ) sumx = ( x ( i ) * del1 + x ( im1 ) * del2 ) / dels sumy = ( y ( i ) * del1 + y ( im1 ) * del2 ) / dels if ( sigmap /= 0. ) go to 1 d = del1 * del2 / ( 6. * dels ) c1 = ( del1 + dels ) * d c2 = ( del2 + dels ) * d xs = sumx - xp ( i ) * c1 - xp ( im1 ) * c2 ys = sumy - yp ( i ) * c1 - yp ( im1 ) * c2 return 1 sigdel = sigmap * dels call fitp_snhcsh ( ss , dummy , sigdel , - 1 ) call fitp_snhcsh ( s1 , dummy , sigmap * del1 , - 1 ) call fitp_snhcsh ( s2 , dummy , sigmap * del2 , - 1 ) d = sigdel * sigmap * ( 1. + ss ) c1 = del1 * ( s1 - ss ) / d c2 = del2 * ( s2 - ss ) / d xs = sumx + xp ( i ) * c1 + xp ( im1 ) * c2 ys = sumy + yp ( i ) * c1 + yp ( im1 ) * c2 return end subroutine fitp_kurv2 subroutine fitp_kurvd ( t , xs , ys , xst , yst , xstt , ystt , n , x , y , xp , yp , s , sigma ) integer n real t , xs , ys , xst , yst , xstt , ystt , x ( n ), y ( n ), xp ( n ), yp ( n ), s ( n ), sigma ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this subroutine performs the mapping of points in the ! interval (0.,1.) onto a curve in the plane. it also ! returns the first and second derivatives of the component ! functions. the subroutine kurv1 should be called earlier ! to determine certain necessary parameters. the resulting ! curve has a parametric representation both of whose ! components are splines under tension and functions of the ! polygonal arclength parameter. ! ! on input-- ! !   t contains a real value to be mapped to a point on the !   curve. the interval (0.,1.) is mapped onto the entire !   curve, with 0. mapping to (x(1),y(1)) and 1. mapping !   to (x(n),y(n)). values outside this interval result in !   extrapolation. ! !   n contains the number of points which were specified !   to determine the curve. ! !   x and y are arrays containing the x- and y-coordinates !   of the specified points. ! !   xp and yp are the arrays output from kurv1 containing !   curvature information. ! !   s is an array containing the polygonal arclengths of !   the curve. ! ! and ! !   sigma contains the tension factor (its sign is ignored). ! ! the parameters n, x, y, xp, yp, s, and sigma should be ! input unaltered from the output of kurv1. ! ! on output-- ! !   xs and ys contain the x- and y-coordinates of the image !   point on the curve. xst and yst contain the first !   derivatives of the x- and y-components of the mapping !   with respect to t. xstt and ystt contain the second !   derivatives of the x- and y-components of the mapping !   with respect to t. ! ! none of the input parameters are altered. ! ! this subroutine references package modules intrvl and ! snhcsh. ! !----------------------------------------------------------- integer im1 , i real ctt1 , ctt2 , sigdel , c2 , ct1 , ct2 , co1 , s2 , co2 , ss real dummy , s1 , c1 , sigmap , del1 , del2 , tn , dels , sumyt real dels6 , d , sumx , sumy , sumxt ! ! determine interval ! tn = s ( n ) * t im1 = fitp_intrvl ( tn , s , n ) i = im1 + 1 ! ! denormalize tension factor ! sigmap = abs ( sigma ) * real ( n - 1 ) / s ( n ) ! ! set up and perform interpolation ! del1 = tn - s ( im1 ) del2 = s ( i ) - tn dels = s ( i ) - s ( im1 ) sumx = ( x ( i ) * del1 + x ( im1 ) * del2 ) / dels sumy = ( y ( i ) * del1 + y ( im1 ) * del2 ) / dels sumxt = s ( n ) * ( x ( i ) - x ( im1 )) / dels sumyt = s ( n ) * ( y ( i ) - y ( im1 )) / dels if ( sigmap /= 0. ) go to 1 dels6 = 6. * dels d = del1 * del2 / dels6 c1 = - ( del1 + dels ) * d c2 = - ( del2 + dels ) * d dels6 = dels6 / s ( n ) ct1 = ( 2. * del1 * del1 - del2 * ( del1 + dels )) / dels6 ct2 = - ( 2. * del2 * del2 - del1 * ( del2 + dels )) / dels6 dels = dels / ( s ( n ) * s ( n )) ctt1 = del1 / dels ctt2 = del2 / dels go to 2 1 sigdel = sigmap * dels call fitp_snhcsh ( ss , dummy , sigdel , - 1 ) call fitp_snhcsh ( s1 , co1 , sigmap * del1 , 0 ) call fitp_snhcsh ( s2 , co2 , sigmap * del2 , 0 ) d = sigdel * sigmap * ( 1. + ss ) c1 = del1 * ( s1 - ss ) / d c2 = del2 * ( s2 - ss ) / d ct1 = ( co1 - ss ) * s ( n ) / d ct2 = - ( co2 - ss ) * s ( n ) / d ctt1 = del1 * ( 1. + s1 ) * s ( n ) * s ( n ) / ( dels * ( 1. + ss )) ctt2 = del2 * ( 1. + s2 ) * s ( n ) * s ( n ) / ( dels * ( 1. + ss )) 2 xs = sumx + c1 * xp ( i ) + c2 * xp ( im1 ) ys = sumy + c1 * yp ( i ) + c2 * yp ( im1 ) xst = sumxt + ct1 * xp ( i ) + ct2 * xp ( im1 ) yst = sumyt + ct1 * yp ( i ) + ct2 * yp ( im1 ) xstt = ctt1 * xp ( i ) + ctt2 * xp ( im1 ) ystt = ctt1 * yp ( i ) + ctt2 * yp ( im1 ) return end subroutine fitp_kurvd subroutine fitp_kurvp1 ( n , x , y , xp , yp , temp , s , sigma , ierr ) integer n , ierr real x ( n ), y ( n ), xp ( n ), yp ( n ), temp ( 1 ), s ( n ), sigma ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this subroutine determines the parameters necessary to ! compute a spline under tension forming a closed curve in ! the plane and passing through a sequence of pairs ! (x(1),y(1)),...,(x(n),y(n)). for actual computation of ! points on the curve it is necessary to call the subroutine ! kurvp2. ! ! on input-- ! !   n is the number of points to be interpolated (n.ge.2). ! !   x is an array containing the n x-coordinates of the !   points. ! !   y is an array containing the n y-coordinates of the !   points. (adjacent x-y pairs must be distinct, i. e. !   either x(i) .ne. x(i+1) or y(i) .ne. y(i+1), for !   i = 1,...,n-1 and either x(1) .ne. x(n) or y(1) .ne. y(n).) ! !   xp and yp are arrays of length at least n. ! !   temp is an array of length at least 2*n which is used !   for scratch storage. ! !   s is an array of length at least n. ! ! and ! !   sigma contains the tension factor. this value indicates !   the curviness desired. if abs(sigma) is nearly zero !   (e.g. .001) the resulting curve is approximately a cubic !   spline. if abs(sigma) is large (e. g. 50.) the resulting !   curve is nearly a polygonal line. if sigma equals zero a !   cubic spline results. a standard value for sigma is !   approximately 1. in absolute value. ! ! on output-- ! !   xp and yp contain information about the curvature of the !   curve at the given nodes. ! !   s contains the polygonal arclengths of the curve. ! !   ierr contains an error flag, !        = 0 for normal return, !        = 1 if n is less than 2, !        = 2 if adjacent coordinate pairs coincide. ! ! and ! !   n, x, y, and sigma are unaltered, ! ! this subroutine references package modules terms and ! snhcsh. ! !----------------------------------------------------------- integer npibak , npi , ibak , im1 , i , nm1 , np1 real sdiag2 , diag , diag2 , dx2 , dy2 , diagin , xpn , ypn real sigmap , dels1 , sdiag1 , dels2 , diag1 , dx1 , dy1 nm1 = n - 1 np1 = n + 1 ierr = 0 if ( n <= 1 ) go to 7 ! ! determine polygonal arclengths ! s ( 1 ) = sqrt (( x ( n ) - x ( 1 )) ** 2 + ( y ( n ) - y ( 1 )) ** 2 ) do i = 2 , n im1 = i - 1 s ( i ) = s ( im1 ) + sqrt (( x ( i ) - x ( im1 )) ** 2 + ( y ( i ) - y ( im1 )) ** 2 ) end do ! ! denormalize tension factor ! sigmap = abs ( sigma ) * real ( n ) / s ( n ) ! ! set up right hand sides of tridiagonal (with corner ! elements) linear system for xp and yp ! dels1 = s ( 1 ) if ( dels1 == 0. ) go to 8 dx1 = ( x ( 1 ) - x ( n )) / dels1 dy1 = ( y ( 1 ) - y ( n )) / dels1 call fitp_terms ( diag1 , sdiag1 , sigmap , dels1 ) dels2 = s ( 2 ) - s ( 1 ) if ( dels2 == 0. ) go to 8 dx2 = ( x ( 2 ) - x ( 1 )) / dels2 dy2 = ( y ( 2 ) - y ( 1 )) / dels2 call fitp_terms ( diag2 , sdiag2 , sigmap , dels2 ) diag = diag1 + diag2 diagin = 1. / diag xp ( 1 ) = ( dx2 - dx1 ) * diagin yp ( 1 ) = ( dy2 - dy1 ) * diagin temp ( np1 ) = - sdiag1 * diagin temp ( 1 ) = sdiag2 * diagin dx1 = dx2 dy1 = dy2 diag1 = diag2 sdiag1 = sdiag2 if ( n == 2 ) go to 3 do i = 2 , nm1 npi = n + i dels2 = s ( i + 1 ) - s ( i ) if ( dels2 == 0. ) go to 8 dx2 = ( x ( i + 1 ) - x ( i )) / dels2 dy2 = ( y ( i + 1 ) - y ( i )) / dels2 call fitp_terms ( diag2 , sdiag2 , sigmap , dels2 ) diag = diag1 + diag2 - sdiag1 * temp ( i - 1 ) diagin = 1. / diag xp ( i ) = ( dx2 - dx1 - sdiag1 * xp ( i - 1 )) * diagin yp ( i ) = ( dy2 - dy1 - sdiag1 * yp ( i - 1 )) * diagin temp ( npi ) = - temp ( npi - 1 ) * sdiag1 * diagin temp ( i ) = sdiag2 * diagin dx1 = dx2 dy1 = dy2 diag1 = diag2 sdiag1 = sdiag2 end do 3 dels2 = s ( 1 ) dx2 = ( x ( 1 ) - x ( n )) / dels2 dy2 = ( y ( 1 ) - y ( n )) / dels2 call fitp_terms ( diag2 , sdiag2 , sigmap , dels2 ) xp ( n ) = dx2 - dx1 yp ( n ) = dy2 - dy1 temp ( nm1 ) = temp ( 2 * n - 1 ) - temp ( nm1 ) if ( n == 2 ) go to 5 ! ! perform first step of back substitution ! do i = 3 , n ibak = np1 - i npibak = n + ibak xp ( ibak ) = xp ( ibak ) - temp ( ibak ) * xp ( ibak + 1 ) yp ( ibak ) = yp ( ibak ) - temp ( ibak ) * yp ( ibak + 1 ) temp ( ibak ) = temp ( npibak ) - temp ( ibak ) * temp ( ibak + 1 ) end do 5 xp ( n ) = ( xp ( n ) - sdiag2 * xp ( 1 ) - sdiag1 * xp ( nm1 )) / & ( diag1 + diag2 + sdiag2 * temp ( 1 ) + sdiag1 * temp ( nm1 )) yp ( n ) = ( yp ( n ) - sdiag2 * yp ( 1 ) - sdiag1 * yp ( nm1 )) / & ( diag1 + diag2 + sdiag2 * temp ( 1 ) + sdiag1 * temp ( nm1 )) ! ! perform second step of back substitution ! xpn = xp ( n ) ypn = yp ( n ) do i = 1 , nm1 xp ( i ) = xp ( i ) + temp ( i ) * xpn yp ( i ) = yp ( i ) + temp ( i ) * ypn end do return ! ! too few points ! 7 ierr = 1 return ! ! coincident adjacent points ! 8 ierr = 2 return end subroutine fitp_kurvp1 subroutine fitp_kurvp2 ( t , xs , ys , n , x , y , xp , yp , s , sigma ) integer n real t , xs , ys , x ( n ), y ( n ), xp ( n ), yp ( n ), s ( n ), sigma ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this subroutine performs the mapping of points in the ! interval (0.,1.) onto a closed curve in the plane. the ! subroutine kurvp1 should be called earlier to determine ! certain necessary parameters. the resulting curve has a ! parametric representation both of whose components are ! periodic splines under tension and functions of the poly- ! gonal arclength parameter. ! ! on input-- ! !   t contains a value to be mapped onto the curve. the !   interval (0.,1.) is mapped onto the entire closed curve !   with both 0. and 1. mapping to (x(1),y(1)). the mapping !   is periodic with period one thus any interval of the !   form (tt,tt+1.) maps onto the entire curve. ! !   n contains the number of points which were specified !   to determine the curve. ! !   x and y are arrays containing the x- and y-coordinates !   of the specified points. ! !   xp and yp are the arrays output from kurvp1 containing !   curvature information. ! !   s is an array containing the polygonal arclengths of !   the curve. ! ! and ! !   sigma contains the tension factor (its sign is ignored). ! ! the parameters n, x, y, xp, yp, s and sigma should ! be input unaltered from the output of kurvp1. ! ! on output-- ! !   xs and ys contain the x- and y-coordinates of the image !   point on the curve. ! ! none of the input parameters are altered. ! ! this subroutine references package modules intrvl and ! snhcsh. ! !----------------------------------------------------------- integer i , im1 real sigdel , ss , c1 , c2 , dummy , ci , cim1 , s1 , s2 , d real sigmap , si , tn , sumx , sumy , dels , del1 , del2 ! ! determine interval ! tn = t - real ( int ( t )) if ( tn < 0. ) tn = tn + 1. tn = s ( n ) * tn + s ( 1 ) im1 = n if ( tn < s ( n )) im1 = fitp_intrvl ( tn , s , n ) i = im1 + 1 if ( i > n ) i = 1 ! ! denormalize tension factor ! sigmap = abs ( sigma ) * real ( n ) / s ( n ) ! ! set up and perform interpolation ! si = s ( i ) if ( im1 == n ) si = s ( n ) + s ( 1 ) del1 = tn - s ( im1 ) del2 = si - tn dels = si - s ( im1 ) sumx = ( x ( i ) * del1 + x ( im1 ) * del2 ) / dels sumy = ( y ( i ) * del1 + y ( im1 ) * del2 ) / dels if ( sigmap /= 0. ) go to 1 d = del1 * del2 / ( 6. * dels ) c1 = ( del1 + dels ) * d c2 = ( del2 + dels ) * d xs = sumx - xp ( i ) * c1 - xp ( im1 ) * c2 ys = sumy - yp ( i ) * c1 - yp ( im1 ) * c2 return 1 sigdel = sigmap * dels call fitp_snhcsh ( ss , dummy , sigdel , - 1 ) call fitp_snhcsh ( s1 , dummy , sigmap * del1 , - 1 ) call fitp_snhcsh ( s2 , dummy , sigmap * del2 , - 1 ) d = sigdel * sigmap * ( 1. + ss ) ci = del1 * ( s1 - ss ) / d cim1 = del2 * ( s2 - ss ) / d xs = sumx + xp ( i ) * ci + xp ( im1 ) * cim1 ys = sumy + yp ( i ) * ci + yp ( im1 ) * cim1 return end subroutine fitp_kurvp2 subroutine fitp_kurvpd ( t , xs , ys , xst , yst , xstt , ystt , n , x , y , xp , yp , s , sigma ) integer n real t , xs , ys , xst , yst , xstt , ystt , x ( n ), y ( n ), xp ( n ), yp ( n ), s ( n ), sigma ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this subroutine performs the mapping of points in the ! interval (0.,1.) onto a closed curve in the plane. it also ! returns the first and second derivatives of the component ! functions. the subroutine kurvp1 should be called earlier ! to determine certain necessary parameters. the resulting ! curve has a parametric representation both of whose ! components are periodic splines under tension and ! functions of the polygonal arclength parameter. ! ! on input-- ! !   t contains a value to be mapped onto the curve. the !   interval (0.,1.) is mapped onto the entire closed curve !   with both 0. and 1. mapping to (x(1),y(1)). the mapping !   is periodic with period one thus any interval of the !   form (tt,tt+1.) maps onto the entire curve. ! !   n contains the number of points which were specified !   to determine the curve. ! !   x and y are arrays containing the x- and y-coordinates !   of the specified points. ! !   xp and yp are the arrays output from kurvp1 containing !   curvature information. ! !   s is an array containing the polygonal arclengths of !   the curve. ! ! and ! !   sigma contains the tension factor (its sign is ignored). ! ! the parameters n, x, y, xp, yp, s and sigma should ! be input unaltered from the output of kurvp1. ! ! on output-- ! !   xs and ys contain the x- and y-coordinates of the image !   point on the curve. xst and yst contain the first !   derivatives of the x- and y-components of the mapping !   with respect to t. xstt and ystt contain the second !   derivatives of the x- and y-components of the mapping !   with respect to t. ! ! none of the input parameters are altered. ! ! this subroutine references package modules intrvl and ! snhcsh. ! !----------------------------------------------------------- integer im1 , i real ct2 , ctt1 , ctt2 , c1 , c2 , ct1 , sigdel , co1 , s2 , co2 , ss real dummy , s1 , si , del1 , del2 , sigmap , tn real sumyt , dels6 , d , sumxt , dels , sumx , sumy ! ! determine interval ! tn = t - real ( int ( t )) if ( tn < 0. ) tn = tn + 1. tn = s ( n ) * tn + s ( 1 ) im1 = n if ( tn < s ( n )) im1 = fitp_intrvl ( tn , s , n ) i = im1 + 1 if ( i > n ) i = 1 ! ! denormalize tension factor ! sigmap = abs ( sigma ) * real ( n ) / s ( n ) ! ! set up and perform interpolation ! si = s ( i ) if ( im1 == n ) si = s ( n ) + s ( 1 ) del1 = tn - s ( im1 ) del2 = si - tn dels = si - s ( im1 ) sumx = ( x ( i ) * del1 + x ( im1 ) * del2 ) / dels sumy = ( y ( i ) * del1 + y ( im1 ) * del2 ) / dels sumxt = s ( n ) * ( x ( i ) - x ( im1 )) / dels sumyt = s ( n ) * ( y ( i ) - y ( im1 )) / dels if ( sigmap /= 0. ) go to 1 dels6 = 6. * dels d = del1 * del2 / dels6 c1 = - ( del1 + dels ) * d c2 = - ( del2 + dels ) * d dels6 = dels6 / s ( n ) ct1 = ( 2. * del1 * del1 - del2 * ( del1 + dels )) / dels6 ct2 = - ( 2. * del2 * del2 - del1 * ( del2 + dels )) / dels6 dels = dels / ( s ( n ) * s ( n )) ctt1 = del1 / dels ctt2 = del2 / dels go to 2 1 sigdel = sigmap * dels call fitp_snhcsh ( ss , dummy , sigdel , - 1 ) call fitp_snhcsh ( s1 , co1 , sigmap * del1 , 0 ) call fitp_snhcsh ( s2 , co2 , sigmap * del2 , 0 ) d = sigdel * sigmap * ( 1. + ss ) c1 = del1 * ( s1 - ss ) / d c2 = del2 * ( s2 - ss ) / d ct1 = ( co1 - ss ) * s ( n ) / d ct2 = - ( co2 - ss ) * s ( n ) / d ctt1 = del1 * ( 1. + s1 ) * s ( n ) * s ( n ) / ( dels * ( 1. + ss )) ctt2 = del2 * ( 1. + s2 ) * s ( n ) * s ( n ) / ( dels * ( 1. + ss )) 2 xs = sumx + c1 * xp ( i ) + c2 * xp ( im1 ) ys = sumy + c1 * yp ( i ) + c2 * yp ( im1 ) xst = sumxt + ct1 * xp ( i ) + ct2 * xp ( im1 ) yst = sumyt + ct1 * yp ( i ) + ct2 * yp ( im1 ) xstt = ctt1 * xp ( i ) + ctt2 * xp ( im1 ) ystt = ctt1 * yp ( i ) + ctt2 * yp ( im1 ) return end subroutine fitp_kurvpd subroutine fitp_surf1 ( m , n , x , y , z , iz , zx1 , zxm , zy1 , zyn , zxy11 , & zxym1 , zxy1n , zxymn , islpsw , zp , temp , sigma , ierr ) integer m , n , iz , islpsw , ierr real x ( m ), y ( n ), z ( iz , n ), zx1 ( n ), zxm ( n ), zy1 ( m ), zyn ( m ), & zxy11 , zxym1 , zxy1n , zxymn , zp ( m , n , 3 ), temp ( n + n + m ), sigma ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this subroutine determines the parameters necessary to ! compute an interpolatory surface passing through a rect- ! angular grid of functional values. the surface determined ! can be represented as the tensor product of splines under ! tension. the x- and y-partial derivatives around the ! boundary and the x-y-partial derivatives at the four ! corners may be specified or omitted. for actual mapping ! of points onto the surface it is necessary to call the ! function surf2. ! ! on input-- ! !   m is the number of grid lines in the x-direction, i. e. !   lines parallel to the y-axis (m .ge. 2). ! !   n is the number of grid lines in the y-direction, i. e. !   lines parallel to the x-axis (n .ge. 2). ! !   x is an array of the m x-coordinates of the grid lines !   in the x-direction. these should be strictly increasing. ! !   y is an array of the n y-coordinates of the grid lines !   in the y-direction. these should be strictly increasing. ! !   z is an array of the m * n functional values at the grid !   points, i. e. z(i,j) contains the functional value at !   (x(i),y(j)) for i = 1,...,m and j = 1,...,n. ! !   iz is the row dimension of the matrix z used in the !   calling program (iz .ge. m). ! !   zx1 and zxm are arrays of the m x-partial derivatives !   of the function along the x(1) and x(m) grid lines, !   respectively. thus zx1(j) and zxm(j) contain the x-part- !   ial derivatives at the points (x(1),y(j)) and !   (x(m),y(j)), respectively, for j = 1,...,n. either of !   these parameters will be ignored (and approximations !   supplied internally) if islpsw so indicates. ! !   zy1 and zyn are arrays of the n y-partial derivatives !   of the function along the y(1) and y(n) grid lines, !   respectively. thus zy1(i) and zyn(i) contain the y-part- !   ial derivatives at the points (x(i),y(1)) and !   (x(i),y(n)), respectively, for i = 1,...,m. either of !   these parameters will be ignored (and estimations !   supplied internally) if islpsw so indicates. ! !   zxy11, zxym1, zxy1n, and zxymn are the x-y-partial !   derivatives of the function at the four corners, !   (x(1),y(1)), (x(m),y(1)), (x(1),y(n)), and (x(m),y(n)), !   respectively. any of the parameters will be ignored (and !   estimations supplied internally) if islpsw so indicates. ! !   islpsw contains a switch indicating which boundary !   derivative information is user-supplied and which !   should be estimated by this subroutine. to determine !   islpsw, let !        i1 = 0 if zx1 is user-supplied (and = 1 otherwise), !        i2 = 0 if zxm is user-supplied (and = 1 otherwise), !        i3 = 0 if zy1 is user-supplied (and = 1 otherwise), !        i4 = 0 if zyn is user-supplied (and = 1 otherwise), !        i5 = 0 if zxy11 is user-supplied !                                       (and = 1 otherwise), !        i6 = 0 if zxym1 is user-supplied !                                       (and = 1 otherwise), !        i7 = 0 if zxy1n is user-supplied !                                       (and = 1 otherwise), !        i8 = 0 if zxymn is user-supplied !                                       (and = 1 otherwise), !   then islpsw = i1 + 2*i2 + 4*i3 + 8*i4 + 16*i5 + 32*i6 !                   + 64*i7 + 128*i8 !   thus islpsw = 0 indicates all derivative information is !   user-supplied and islpsw = 255 indicates no derivative !   information is user-supplied. any value between these !   limits is valid. ! !   zp is an array of at least 3*m*n locations. ! !   temp is an array of at least n+n+m locations which is !   used for scratch storage. ! ! and ! !   sigma contains the tension factor. this value indicates !   the curviness desired. if abs(sigma) is nearly zero !   (e. g. .001) the resulting surface is approximately the !   tensor product of cubic splines. if abs(sigma) is large !   (e. g. 50.) the resulting surface is approximately !   bi-linear. if sigma equals zero tensor products of !   cubic splines result. a standard value for sigma is !   approximately 1. in absolute value. ! ! on output-- ! !   zp contains the values of the xx-, yy-, and xxyy-partial !   derivatives of the surface at the given nodes. ! !   ierr contains an error flag, !        = 0 for normal return, !        = 1 if n is less than 2 or m is less than 2, !        = 2 if the x-values or y-values are not strictly !            increasing. ! ! and ! !   m, n, x, y, z, iz, zx1, zxm, zy1, zyn, zxy11, zxym1, !   zxy1n, zxymn, islpsw, and sigma are unaltered. ! ! this subroutine references package modules ceez, terms, ! and snhcsh. ! !----------------------------------------------------------- integer jbak , jbakp1 , jm1 , jp1 , im1 , ibakp1 integer npibak , ip1 , ibak , nm1 , np1 , mm1 , mp1 , npm , j integer npmpj , i , npi real diagi , sdiag1 , del2 , zxymns , delxmm , del1 real diag1 , deli , diag2 , diagin , sdiag2 , t real delxm , sigmay , dely1 , c1 , dely2 , c2 real delx1 , delx2 , zxy1ns , c3 , delyn , sigmax , delynm mm1 = m - 1 mp1 = m + 1 nm1 = n - 1 np1 = n + 1 npm = n + m ierr = 0 if ( n <= 1 . or . m <= 1 ) go to 46 if ( y ( n ) <= y ( 1 )) go to 47 ! ! denormalize tension factor in y-direction ! sigmay = abs ( sigma ) * real ( n - 1 ) / ( y ( n ) - y ( 1 )) ! ! obtain y-partial derivatives along y = y(1) ! if (( islpsw / 8 ) * 2 /= ( islpsw / 4 )) go to 2 do i = 1 , m zp ( i , 1 , 1 ) = zy1 ( i ) end do go to 5 2 dely1 = y ( 2 ) - y ( 1 ) dely2 = dely1 + dely1 if ( n > 2 ) dely2 = y ( 3 ) - y ( 1 ) if ( dely1 <= 0. . or . dely2 <= dely1 ) go to 47 call fitp_ceez ( dely1 , dely2 , sigmay , c1 , c2 , c3 , n ) do i = 1 , m zp ( i , 1 , 1 ) = c1 * z ( i , 1 ) + c2 * z ( i , 2 ) end do if ( n == 2 ) go to 5 do i = 1 , m zp ( i , 1 , 1 ) = zp ( i , 1 , 1 ) + c3 * z ( i , 3 ) end do ! ! obtain y-partial derivatives along y = y(n) ! 5 if (( islpsw / 16 ) * 2 /= ( islpsw / 8 )) go to 7 do i = 1 , m npi = n + i temp ( npi ) = zyn ( i ) end do go to 10 7 delyn = y ( n ) - y ( nm1 ) delynm = delyn + delyn if ( n > 2 ) delynm = y ( n ) - y ( n - 2 ) if ( delyn <= 0. . or . delynm <= delyn ) go to 47 call fitp_ceez ( - delyn , - delynm , sigmay , c1 , c2 , c3 , n ) do i = 1 , m npi = n + i temp ( npi ) = c1 * z ( i , n ) + c2 * z ( i , nm1 ) end do if ( n == 2 ) go to 10 do i = 1 , m npi = n + i temp ( npi ) = temp ( npi ) + c3 * z ( i , n - 2 ) end do 10 if ( x ( m ) <= x ( 1 )) go to 47 ! ! denormalize tension factor in x-direction ! sigmax = abs ( sigma ) * real ( m - 1 ) / ( x ( m ) - x ( 1 )) ! ! obtain x-partial derivatives along x = x(1) ! if (( islpsw / 2 ) * 2 /= islpsw ) go to 12 do j = 1 , n zp ( 1 , j , 2 ) = zx1 ( j ) end do if (( islpsw / 32 ) * 2 == ( islpsw / 16 ) . and . ( islpsw / 128 ) * 2 == ( islpsw / 64 )) go to 15 12 delx1 = x ( 2 ) - x ( 1 ) delx2 = delx1 + delx1 if ( m > 2 ) delx2 = x ( 3 ) - x ( 1 ) if ( delx1 <= 0. . or . delx2 <= delx1 ) go to 47 call fitp_ceez ( delx1 , delx2 , sigmax , c1 , c2 , c3 , m ) if (( islpsw / 2 ) * 2 == islpsw ) go to 15 do j = 1 , n zp ( 1 , j , 2 ) = c1 * z ( 1 , j ) + c2 * z ( 2 , j ) end do if ( m == 2 ) go to 15 do j = 1 , n zp ( 1 , j , 2 ) = zp ( 1 , j , 2 ) + c3 * z ( 3 , j ) end do ! ! obtain x-y-partial derivative at (x(1),y(1)) ! 15 if (( islpsw / 32 ) * 2 /= ( islpsw / 16 )) go to 16 zp ( 1 , 1 , 3 ) = zxy11 go to 17 16 zp ( 1 , 1 , 3 ) = c1 * zp ( 1 , 1 , 1 ) + c2 * zp ( 2 , 1 , 1 ) if ( m > 2 ) zp ( 1 , 1 , 3 ) = zp ( 1 , 1 , 3 ) + c3 * zp ( 3 , 1 , 1 ) ! ! obtain x-y-partial derivative at (x(1),y(n)) ! 17 if (( islpsw / 128 ) * 2 /= ( islpsw / 64 )) go to 18 zxy1ns = zxy1n go to 19 18 zxy1ns = c1 * temp ( n + 1 ) + c2 * temp ( n + 2 ) if ( m > 2 ) zxy1ns = zxy1ns + c3 * temp ( n + 3 ) ! ! obtain x-partial derivative along x = x(m) ! 19 if (( islpsw / 4 ) * 2 /= ( islpsw / 2 )) go to 21 do j = 1 , n npmpj = npm + j temp ( npmpj ) = zxm ( j ) end do if (( islpsw / 64 ) * 2 == ( islpsw / 32 ) . and . ( islpsw / 256 ) * 2 == ( islpsw / 128 )) go to 24 21 delxm = x ( m ) - x ( mm1 ) delxmm = delxm + delxm if ( m > 2 ) delxmm = x ( m ) - x ( m - 2 ) if ( delxm <= 0. . or . delxmm <= delxm ) go to 47 call fitp_ceez ( - delxm , - delxmm , sigmax , c1 , c2 , c3 , m ) if (( islpsw / 4 ) * 2 == ( islpsw / 2 )) go to 24 do j = 1 , n npmpj = npm + j temp ( npmpj ) = c1 * z ( m , j ) + c2 * z ( mm1 , j ) end do if ( m == 2 ) go to 24 do j = 1 , n npmpj = npm + j temp ( npmpj ) = temp ( npmpj ) + c3 * z ( m - 2 , j ) end do ! ! obtain x-y-partial derivative at (x(m),y(1)) ! 24 if (( islpsw / 64 ) * 2 /= ( islpsw / 32 )) go to 25 zp ( m , 1 , 3 ) = zxym1 go to 26 25 zp ( m , 1 , 3 ) = c1 * zp ( m , 1 , 1 ) + c2 * zp ( mm1 , 1 , 1 ) if ( m > 2 ) zp ( m , 1 , 3 ) = zp ( m , 1 , 3 ) + c3 * zp ( m - 2 , 1 , 1 ) ! ! obtain x-y-partial derivative at (x(m),y(n)) ! 26 if (( islpsw / 256 ) * 2 /= ( islpsw / 128 )) go to 27 zxymns = zxymn go to 28 27 zxymns = c1 * temp ( npm ) + c2 * temp ( npm - 1 ) if ( m > 2 ) zxymns = zxymns + c3 * temp ( npm - 2 ) ! ! set up right hand sides and tridiagonal system for y-grid ! perform forward elimination ! 28 del1 = y ( 2 ) - y ( 1 ) if ( del1 <= 0. ) go to 47 deli = 1. / del1 do i = 1 , m zp ( i , 2 , 1 ) = deli * ( z ( i , 2 ) - z ( i , 1 )) end do zp ( 1 , 2 , 3 ) = deli * ( zp ( 1 , 2 , 2 ) - zp ( 1 , 1 , 2 )) zp ( m , 2 , 3 ) = deli * ( temp ( npm + 2 ) - temp ( npm + 1 )) call fitp_terms ( diag1 , sdiag1 , sigmay , del1 ) diagi = 1. / diag1 do i = 1 , m zp ( i , 1 , 1 ) = diagi * ( zp ( i , 2 , 1 ) - zp ( i , 1 , 1 )) end do zp ( 1 , 1 , 3 ) = diagi * ( zp ( 1 , 2 , 3 ) - zp ( 1 , 1 , 3 )) zp ( m , 1 , 3 ) = diagi * ( zp ( m , 2 , 3 ) - zp ( m , 1 , 3 )) temp ( 1 ) = diagi * sdiag1 if ( n == 2 ) go to 34 do j = 2 , nm1 jm1 = j - 1 jp1 = j + 1 npmpj = npm + j del2 = y ( jp1 ) - y ( j ) if ( del2 <= 0. ) go to 47 deli = 1. / del2 do i = 1 , m zp ( i , jp1 , 1 ) = deli * ( z ( i , jp1 ) - z ( i , j )) end do zp ( 1 , jp1 , 3 ) = deli * ( zp ( 1 , jp1 , 2 ) - zp ( 1 , j , 2 )) zp ( m , jp1 , 3 ) = deli * ( temp ( npmpj + 1 ) - temp ( npmpj )) call fitp_terms ( diag2 , sdiag2 , sigmay , del2 ) diagin = 1. / ( diag1 + diag2 - sdiag1 * temp ( jm1 )) do i = 1 , m zp ( i , j , 1 ) = diagin * ( zp ( i , jp1 , 1 ) - zp ( i , j , 1 ) - sdiag1 * zp ( i , jm1 , 1 )) end do zp ( 1 , j , 3 ) = diagin * ( zp ( 1 , jp1 , 3 ) - zp ( 1 , j , 3 ) - sdiag1 * zp ( 1 , jm1 , 3 )) zp ( m , j , 3 ) = diagin * ( zp ( m , jp1 , 3 ) - zp ( m , j , 3 ) - sdiag1 * zp ( m , jm1 , 3 )) temp ( j ) = diagin * sdiag2 diag1 = diag2 sdiag1 = sdiag2 end do 34 diagin = 1. / ( diag1 - sdiag1 * temp ( nm1 )) do i = 1 , m npi = n + i zp ( i , n , 1 ) = diagin * ( temp ( npi ) - zp ( i , n , 1 ) - sdiag1 * zp ( i , nm1 , 1 )) end do zp ( 1 , n , 3 ) = diagin * ( zxy1ns - zp ( 1 , n , 3 ) - sdiag1 * zp ( 1 , nm1 , 3 )) temp ( n ) = diagin * ( zxymns - zp ( m , n , 3 ) - sdiag1 * zp ( m , nm1 , 3 )) ! ! perform back substitution ! do j = 2 , n jbak = np1 - j jbakp1 = jbak + 1 t = temp ( jbak ) do i = 1 , m zp ( i , jbak , 1 ) = zp ( i , jbak , 1 ) - t * zp ( i , jbakp1 , 1 ) end do zp ( 1 , jbak , 3 ) = zp ( 1 , jbak , 3 ) - t * zp ( 1 , jbakp1 , 3 ) temp ( jbak ) = zp ( m , jbak , 3 ) - t * temp ( jbakp1 ) end do ! ! set up right hand sides and tridiagonal system for x-grid ! perform forward elimination ! del1 = x ( 2 ) - x ( 1 ) if ( del1 <= 0. ) go to 47 deli = 1. / del1 do j = 1 , n zp ( 2 , j , 2 ) = deli * ( z ( 2 , j ) - z ( 1 , j )) zp ( 2 , j , 3 ) = deli * ( zp ( 2 , j , 1 ) - zp ( 1 , j , 1 )) end do call fitp_terms ( diag1 , sdiag1 , sigmax , del1 ) diagi = 1. / diag1 do j = 1 , n zp ( 1 , j , 2 ) = diagi * ( zp ( 2 , j , 2 ) - zp ( 1 , j , 2 )) zp ( 1 , j , 3 ) = diagi * ( zp ( 2 , j , 3 ) - zp ( 1 , j , 3 )) end do temp ( n + 1 ) = diagi * sdiag1 if ( m == 2 ) go to 43 do i = 2 , mm1 im1 = i - 1 ip1 = i + 1 npi = n + i del2 = x ( ip1 ) - x ( i ) if ( del2 <= 0. ) go to 47 deli = 1. / del2 do j = 1 , n zp ( ip1 , j , 2 ) = deli * ( z ( ip1 , j ) - z ( i , j )) zp ( ip1 , j , 3 ) = deli * ( zp ( ip1 , j , 1 ) - zp ( i , j , 1 )) end do call fitp_terms ( diag2 , sdiag2 , sigmax , del2 ) diagin = 1. / ( diag1 + diag2 - sdiag1 * temp ( npi - 1 )) do j = 1 , n zp ( i , j , 2 ) = diagin * ( zp ( ip1 , j , 2 ) - zp ( i , j , 2 ) - sdiag1 * zp ( im1 , j , 2 )) zp ( i , j , 3 ) = diagin * ( zp ( ip1 , j , 3 ) - zp ( i , j , 3 ) - sdiag1 * zp ( im1 , j , 3 )) end do temp ( npi ) = diagin * sdiag2 diag1 = diag2 sdiag1 = sdiag2 end do 43 diagin = 1. / ( diag1 - sdiag1 * temp ( npm - 1 )) do j = 1 , n npmpj = npm + j zp ( m , j , 2 ) = diagin * ( temp ( npmpj ) - zp ( m , j , 2 ) - sdiag1 * zp ( mm1 , j , 2 )) zp ( m , j , 3 ) = diagin * ( temp ( j ) - zp ( m , j , 3 ) - sdiag1 * zp ( mm1 , j , 3 )) end do ! ! perform back substitution ! do i = 2 , m ibak = mp1 - i ibakp1 = ibak + 1 npibak = n + ibak t = temp ( npibak ) do j = 1 , n zp ( ibak , j , 2 ) = zp ( ibak , j , 2 ) - t * zp ( ibakp1 , j , 2 ) zp ( ibak , j , 3 ) = zp ( ibak , j , 3 ) - t * zp ( ibakp1 , j , 3 ) end do end do return ! ! too few points ! 46 ierr = 1 return ! ! points not strictly increasing ! 47 ierr = 2 return end subroutine fitp_surf1 real function fitp_surf2 ( xx , yy , m , n , x , y , z , iz , zp , sigma ) integer m , n , iz real xx , yy , x ( m ), y ( n ), z ( iz , n ), zp ( m , n , 3 ), sigma ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this function interpolates a surface at a given coordinate ! pair using a bi-spline under tension. the subroutine surf1 ! should be called earlier to determine certain necessary ! parameters. ! ! on input-- ! !   xx and yy contain the x- and y-coordinates of the point !   to be mapped onto the interpolating surface. ! !   m and n contain the number of grid lines in the x- and !   y-directions, respectively, of the rectangular grid !   which specified the surface. ! !   x and y are arrays containing the x- and y-grid values, !   respectively, each in increasing order. ! !   z is a matrix containing the m * n functional values !   corresponding to the grid values (i. e. z(i,j) is the !   surface value at the point (x(i),y(j)) for i = 1,...,m !   and j = 1,...,n). ! !   iz contains the row dimension of the array z as declared !   in the calling program. ! !   zp is an array of 3*m*n locations stored with the !   various surface derivative information determined by !   surf1. ! ! and ! !   sigma contains the tension factor (its sign is ignored). ! ! the parameters m, n, x, y, z, iz, zp, and sigma should be ! input unaltered from the output of surf1. ! ! on output-- ! !   surf2 contains the interpolated surface value. ! ! none of the input parameters are altered. ! ! this function references package modules intrvl and ! snhcsh. ! !----------------------------------------------------------- integer im1 , i , j , jm1 real hermz , hermnz , zxxi , dummy , zxxim1 , zim1 , zi real sigmax , fp2 , del1 , fp1 , f1 , f2 , del2 real sinhms , sinhm2 , sinhm1 , dels , sigmay , sigmap ! ! inline one dimensional cubic spline interpolation ! hermz ( f1 , f2 , fp1 , fp2 ) = ( f2 * del1 + f1 * del2 ) / dels - del1 * & del2 * ( fp2 * ( del1 + dels ) + & fp1 * ( del2 + dels )) / ( 6. * dels ) ! ! inline one dimensional spline under tension interpolation ! hermnz ( f1 , f2 , fp1 , fp2 , sigmap ) = ( f2 * del1 + f1 * del2 ) / dels & + ( fp2 * del1 * ( sinhm1 - sinhms ) & + fp1 * del2 * ( sinhm2 - sinhms ) & ) / ( sigmap * sigmap * dels * ( 1. + sinhms )) ! ! denormalize tension factor in x and y direction ! sigmax = abs ( sigma ) * real ( m - 1 ) / ( x ( m ) - x ( 1 )) sigmay = abs ( sigma ) * real ( n - 1 ) / ( y ( n ) - y ( 1 )) ! ! determine y interval ! jm1 = fitp_intrvl ( yy , y , n ) j = jm1 + 1 ! ! determine x interval ! im1 = fitp_intrvl ( xx , x , m ) i = im1 + 1 del1 = yy - y ( jm1 ) del2 = y ( j ) - yy dels = y ( j ) - y ( jm1 ) if ( sigmay /= 0. ) go to 1 ! ! perform four interpolations in y-direction ! zim1 = hermz ( z ( i - 1 , j - 1 ), z ( i - 1 , j ), zp ( i - 1 , j - 1 , 1 ), zp ( i - 1 , j , 1 )) zi = hermz ( z ( i , j - 1 ), z ( i , j ), zp ( i , j - 1 , 1 ), zp ( i , j , 1 )) zxxim1 = hermz ( zp ( i - 1 , j - 1 , 2 ), zp ( i - 1 , j , 2 ), zp ( i - 1 , j - 1 , 3 ), zp ( i - 1 , j , 3 )) zxxi = hermz ( zp ( i , j - 1 , 2 ), zp ( i , j , 2 ), zp ( i , j - 1 , 3 ), zp ( i , j , 3 )) go to 2 1 call fitp_snhcsh ( sinhm1 , dummy , sigmay * del1 , - 1 ) call fitp_snhcsh ( sinhm2 , dummy , sigmay * del2 , - 1 ) call fitp_snhcsh ( sinhms , dummy , sigmay * dels , - 1 ) zim1 = hermnz ( z ( i - 1 , j - 1 ), z ( i - 1 , j ), zp ( i - 1 , j - 1 , 1 ), zp ( i - 1 , j , 1 ), sigmay ) zi = hermnz ( z ( i , j - 1 ), z ( i , j ), zp ( i , j - 1 , 1 ), zp ( i , j , 1 ), sigmay ) zxxim1 = hermnz ( zp ( i - 1 , j - 1 , 2 ), zp ( i - 1 , j , 2 ), zp ( i - 1 , j - 1 , 3 ), zp ( i - 1 , j , 3 ), sigmay ) zxxi = hermnz ( zp ( i , j - 1 , 2 ), zp ( i , j , 2 ), zp ( i , j - 1 , 3 ), zp ( i , j , 3 ), sigmay ) ! ! perform final interpolation in x-direction ! 2 del1 = xx - x ( im1 ) del2 = x ( i ) - xx dels = x ( i ) - x ( im1 ) if ( sigmax /= 0. ) go to 3 fitp_surf2 = hermz ( zim1 , zi , zxxim1 , zxxi ) return 3 call fitp_snhcsh ( sinhm1 , dummy , sigmax * del1 , - 1 ) call fitp_snhcsh ( sinhm2 , dummy , sigmax * del2 , - 1 ) call fitp_snhcsh ( sinhms , dummy , sigmax * dels , - 1 ) fitp_surf2 = hermnz ( zim1 , zi , zxxim1 , zxxi , sigmax ) return end function fitp_surf2 subroutine fitp_ceez ( del1 , del2 , sigma , c1 , c2 , c3 , n ) real del1 , del2 , sigma , c1 , c2 , c3 ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this subroutine determines the coefficients c1, c2, and c3 ! used to determine endpoint slopes. specifically, if ! function values y1, y2, and y3 are given at points x1, x2, ! and x3, respectively, the quantity c1*y1 + c2*y2 + c3*y3 ! is the value of the derivative at x1 of a spline under ! tension (with tension factor sigma) passing through the ! three points and having third derivative equal to zero at ! x1. optionally, only two values, c1 and c2 are determined. ! ! on input-- ! !   del1 is x2-x1 (.gt. 0.). ! !   del2 is x3-x1 (.gt. 0.). if n .eq. 2, this parameter is !   ignored. ! !   sigma is the tension factor. ! ! and ! !   n is a switch indicating the number of coefficients to !   be returned. if n .eq. 2 only two coefficients are !   returned. otherwise all three are returned. ! ! on output-- ! !   c1, c2, and c3 contain the coefficients. ! ! none of the input parameters are altered. ! ! this subroutine references package module snhcsh. ! !----------------------------------------------------------- integer n real delm , delp , sinhmp , denom , sinhmm , del , dummy , coshm2 , coshm1 if ( n == 2 ) go to 2 if ( sigma /= 0. ) go to 1 del = del2 - del1 ! ! tension .eq. 0. ! c1 = - ( del1 + del2 ) / ( del1 * del2 ) c2 = del2 / ( del1 * del ) c3 = - del1 / ( del2 * del ) return ! ! tension .ne. 0. ! 1 call fitp_snhcsh ( dummy , coshm1 , sigma * del1 , 1 ) call fitp_snhcsh ( dummy , coshm2 , sigma * del2 , 1 ) delp = sigma * ( del2 + del1 ) / 2. delm = sigma * ( del2 - del1 ) / 2. call fitp_snhcsh ( sinhmp , dummy , delp , - 1 ) call fitp_snhcsh ( sinhmm , dummy , delm , - 1 ) denom = coshm1 * ( del2 - del1 ) - 2. * del1 * delp * delm * ( 1. + sinhmp ) * ( 1. + sinhmm ) c1 = 2. * delp * delm * ( 1. + sinhmp ) * ( 1. + sinhmm ) / denom c2 = - coshm2 / denom c3 = coshm1 / denom return ! ! two coefficients ! 2 c1 = - 1. / del1 c2 = - c1 return end subroutine fitp_ceez subroutine fitp_curvpp ( n , x , y , p , d , isw , s , eps , ys , ysp , sigma , & td , tsd1 , hd , hsd1 , hsd2 , rd , rsd1 , rsd2 , rnm1 , rn , v , ierr ) integer n , isw , ierr real x ( n ), y ( n ), p , d ( n ), s , eps , ys ( n ), ysp ( n ), sigma , td ( n ), & tsd1 ( n ), hd ( n ), hsd1 ( n ), hsd2 ( n ), rd ( n ), rsd1 ( n ), & rsd2 ( n ), rnm1 ( n ), rn ( n ), v ( n ) ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this subroutine determines the parameters necessary to ! compute a periodic smoothing spline under tension. for a ! given increasing sequence of abscissae (x(i)), i = 1,...,n ! and associated ordinates (y(i)), i = 1,...,n, letting p be ! the period, x(n+1) = x(1)+p, and y(n+1) = y(1), the ! function determined minimizes the summation from i = 1 to ! n of the square of the second derivative of f plus sigma ! squared times the difference of the first derivative of f ! and (f(x(i+1))-f(x(i)))/(x(i+1)-x(i)) squared, over all ! functions f with period p and two continuous derivatives ! such that the summation of the square of ! (f(x(i))-y(i))/d(i) is less than or equal to a given ! constant s, where (d(i)), i = 1,...,n are a given set of ! observation weights. the function determined is a periodic ! spline under tension with third derivative discontinuities ! at (x(i)) i = 1,...,n (and all periodic translations of ! these values). for actual computation of points on the ! curve it is necessary to call the function curvp2. ! ! on input-- ! !   n is the number of values to be smoothed (n.ge.2). ! !   x is an array of the n increasing abscissae of the !   values to be smoothed. ! !   y is an array of the n ordinates of the values to be !   smoothed, (i. e. y(k) is the functional value !   corresponding to x(k) ). ! !   p is the period (p .gt. x(n)-x(1)). ! !   d is a parameter containing the observation weights. !   this may either be an array of length n or a scalar !   (interpreted as a constant). the value of d !   corresponding to the observation (x(k),y(k)) should !   be an approximation to the standard deviation of error. ! !   isw contains a switch indicating whether the parameter !   d is to be considered a vector or a scalar, !          = 0 if d is an array of length n, !          = 1 if d is a scalar. ! !   s contains the value controlling the smoothing. this !   must be non-negative. for s equal to zero, the !   subroutine does interpolation, larger values lead to !   smoother funtions. if parameter d contains standard !   deviation estimates, a reasonable value for s is !   float(n). ! !   eps contains a tolerance on the relative precision to !   which s is to be interpreted. this must be greater than !   or equal to zero and less than equal or equal to one. a !   reasonable value for eps is sqrt(2./float(n)). ! !   ys is an array of length at least n. ! !   ysp is an array of length at least n. ! !   sigma contains the tension factor. this value indicates !   the degree to which the first derivative part of the !   smoothing functional is emphasized. if sigma is nearly !   zero (e. g. .001) the resulting curve is approximately a !   cubic spline. if sigma is large (e. g. 50.) the !   resulting curve is nearly a polygonal line. if sigma !   equals zero a cubic spline results. a standard value for !   sigma is approximately 1. ! ! and ! !   td, tsd1, hd, hsd1, hsd2, rd, rsd1, rsd2, rnm1, rn, and !   v are arrays of length at least n which are used for !   scratch storage. ! ! on output-- ! !   ys contains the smoothed ordinate values. ! !   ysp contains the values of the second derivative of the !   smoothed curve at the given nodes. ! !   ierr contains an error flag, !        = 0 for normal return, !        = 1 if n is less than 2, !        = 2 if s is negative, !        = 3 if eps is negative or greater than one, !        = 4 if x-values are not strictly increasing, !        = 5 if a d-value is non-positive, !        = 6 if p is less than or equal to x(n)-x(1). ! ! and ! !   n, x, y, d, isw, s, eps, and sigma are unaltered. ! ! this subroutine references package modules terms and ! snhcsh. ! !----------------------------------------------------------- real f , g , rnm1sm integer ibak real rnm1t , rnt , rdn , wi , h , step , tui , rnsm real wim1 , wim2 , hsd1p , hdim1 , hdi , sum , hsd11 real sl , con , sum2 , sumn , rsd2i , sumnm1 , yspnm1 , yspn , rsd1i integer ip1 , i real dim1 , di , delyi , delxi , delyi1 real sigmap , q , delxi1 integer nm3 , nm2 , nm1 real disq , sumy , sumd , beta , hsd1ip , alpha integer im1 real su , alphap , betap , betapp if ( n < 2 ) go to 25 if ( s < 0. ) go to 26 if ( eps < 0. . or . eps > 1. ) go to 27 if ( p <= x ( n ) - x ( 1 )) go to 30 ierr = 0 q = 0. rsd1 ( 1 ) = 0. rsd2 ( 1 ) = 0. rsd2 ( 2 ) = 0. rsd1 ( n - 1 ) = 0. rsd2 ( n - 1 ) = 0. rsd2 ( n ) = 0. ! ! denormalize tension factor ! sigmap = abs ( sigma ) * real ( n ) / p ! ! form t matrix and second differences of y into ys ! nm1 = n - 1 nm2 = n - 2 nm3 = n - 3 delxi1 = x ( 1 ) + p - x ( n ) delyi1 = ( y ( 1 ) - y ( n )) / delxi1 call fitp_terms ( dim1 , tsd1 ( 1 ), sigmap , delxi1 ) hsd1 ( 1 ) = 1. / delxi1 do i = 1 , n ip1 = i + 1 if ( i == n ) ip1 = 1 delxi = x ( ip1 ) - x ( i ) if ( i == n ) delxi = x ( 1 ) + p - x ( n ) if ( delxi <= 0. ) go to 28 delyi = ( y ( ip1 ) - y ( i )) / delxi ys ( i ) = delyi - delyi1 call fitp_terms ( di , tsd1 ( ip1 ), sigmap , delxi ) td ( i ) = di + dim1 hd ( i ) = - ( 1. / delxi + 1. / delxi1 ) hsd1 ( ip1 ) = 1. / delxi delxi1 = delxi delyi1 = delyi dim1 = di end do hsd11 = hsd1 ( 1 ) if ( n >= 3 ) go to 2 tsd1 ( 2 ) = tsd1 ( 1 ) + tsd1 ( 2 ) tsd1 ( 1 ) = 0. hsd1 ( 2 ) = hsd1 ( 1 ) + hsd1 ( 2 ) hsd1 ( 1 ) = 0. ! ! calculate lower and upper tolerances ! 2 sl = s * ( 1. - eps ) su = s * ( 1. + eps ) if ( d ( 1 ) <= 0. ) go to 29 if ( isw == 1 ) go to 5 ! ! form h matrix - d array ! betapp = hsd1 ( n ) * d ( n ) * d ( n ) betap = hsd1 ( 1 ) * d ( 1 ) * d ( 1 ) alphap = hd ( n ) * d ( n ) * d ( n ) im1 = n sumd = 0. sumy = 0. do i = 1 , n disq = d ( i ) * d ( i ) sumd = sumd + 1. / disq sumy = sumy + y ( i ) / disq ip1 = i + 1 if ( i == n ) ip1 = 1 alpha = hd ( i ) * disq if ( d ( ip1 ) <= 0. ) go to 29 hsd1ip = hsd1 ( ip1 ) if ( i == n ) hsd1ip = hsd11 beta = hsd1ip * d ( ip1 ) * d ( ip1 ) hd ( i ) = ( hsd1 ( i ) * d ( im1 )) ** 2 + alpha * hd ( i ) + beta * hsd1ip hsd2 ( i ) = hsd1 ( i ) * betapp hsd1 ( i ) = hsd1 ( i ) * ( alpha + alphap ) im1 = i alphap = alpha betapp = betap betap = beta end do if ( n == 3 ) hsd1 ( 3 ) = hsd1 ( 3 ) + hsd2 ( 2 ) ! ! test for straight line fit ! con = sumy / sumd sum = 0. do i = 1 , n sum = sum + (( y ( i ) - con ) / d ( i )) ** 2 end do if ( sum <= su ) go to 23 go to 8 ! ! form h matrix - d constant ! 5 sl = d ( 1 ) * d ( 1 ) * sl su = d ( 1 ) * d ( 1 ) * su hsd1p = hsd1 ( n ) hdim1 = hd ( n ) sumy = 0. do i = 1 , n sumy = sumy + y ( i ) hsd1ip = hsd11 if ( i < n ) hsd1ip = hsd1 ( i + 1 ) hdi = hd ( i ) hd ( i ) = hsd1 ( i ) * hsd1 ( i ) + hdi * hdi + hsd1ip * hsd1ip hsd2 ( i ) = hsd1 ( i ) * hsd1p hsd1p = hsd1 ( i ) hsd1 ( i ) = hsd1p * ( hdi + hdim1 ) hdim1 = hdi end do if ( n == 3 ) hsd1 ( 3 ) = hsd1 ( 3 ) + hsd2 ( 2 ) ! ! test for straight line fit ! con = sumy / real ( n ) sum = 0. do i = 1 , n sum = sum + ( y ( i ) - con ) ** 2 end do if ( sum <= su ) go to 23 ! ! top of iteration ! cholesky factorization of q*t+h into r ! ! ! i = 1 ! 8 rd ( 1 ) = 1. / ( q * td ( 1 ) + hd ( 1 )) rnm1 ( 1 ) = hsd2 ( 1 ) yspnm1 = ys ( nm1 ) rn ( 1 ) = q * tsd1 ( 1 ) + hsd1 ( 1 ) yspn = ys ( n ) ysp ( 1 ) = ys ( 1 ) rsd1i = q * tsd1 ( 2 ) + hsd1 ( 2 ) rsd1 ( 2 ) = rsd1i * rd ( 1 ) sumnm1 = 0. sum2 = 0. sumn = 0. if ( n == 3 ) go to 11 if ( n == 2 ) go to 12 ! ! i = 2 ! rd ( 2 ) = 1. / ( q * td ( 2 ) + hd ( 2 ) - rsd1i * rsd1 ( 2 )) rnm1 ( 2 ) = - rnm1 ( 1 ) * rsd1 ( 2 ) rn ( 2 ) = hsd2 ( 2 ) - rn ( 1 ) * rsd1 ( 2 ) ysp ( 2 ) = ys ( 2 ) - rsd1 ( 2 ) * ysp ( 1 ) if ( n == 4 ) go to 10 do i = 3 , nm2 rsd2i = hsd2 ( i ) rsd1i = q * tsd1 ( i ) + hsd1 ( i ) - rsd2i * rsd1 ( i - 1 ) rsd2 ( i ) = rsd2i * rd ( i - 2 ) rsd1 ( i ) = rsd1i * rd ( i - 1 ) rd ( i ) = 1. / ( q * td ( i ) + hd ( i ) - rsd1i * rsd1 ( i ) - rsd2i * rsd2 ( i )) rnm1 ( i ) = - rnm1 ( i - 2 ) * rsd2 ( i ) - rnm1 ( i - 1 ) * rsd1 ( i ) rnm1t = rnm1 ( i - 2 ) * rd ( i - 2 ) sumnm1 = sumnm1 + rnm1t * rnm1 ( i - 2 ) rnm1 ( i - 2 ) = rnm1t sum2 = sum2 + rnm1t * rn ( i - 2 ) yspnm1 = yspnm1 - rnm1t * ysp ( i - 2 ) rn ( i ) = - rn ( i - 2 ) * rsd2 ( i ) - rn ( i - 1 ) * rsd1 ( i ) rnt = rn ( i - 2 ) * rd ( i - 2 ) sumn = sumn + rnt * rn ( i - 2 ) rn ( i - 2 ) = rnt yspn = yspn - rnt * ysp ( i - 2 ) ysp ( i ) = ys ( i ) - rsd1 ( i ) * ysp ( i - 1 ) - rsd2 ( i ) * ysp ( i - 2 ) end do ! ! i = n-3 ! 10 rnm1 ( nm3 ) = hsd2 ( nm1 ) + rnm1 ( nm3 ) rnm1 ( nm2 ) = rnm1 ( nm2 ) - hsd2 ( nm1 ) * rsd1 ( nm2 ) rnm1t = rnm1 ( nm3 ) * rd ( nm3 ) sumnm1 = sumnm1 + rnm1t * rnm1 ( nm3 ) rnm1 ( nm3 ) = rnm1t sum2 = sum2 + rnm1t * rn ( nm3 ) yspnm1 = yspnm1 - rnm1t * ysp ( nm3 ) rnt = rn ( nm3 ) * rd ( nm3 ) sumn = sumn + rnt * rn ( nm3 ) rn ( nm3 ) = rnt yspn = yspn - rnt * ysp ( nm3 ) ! ! i = n-2 ! 11 rnm1 ( nm2 ) = q * tsd1 ( nm1 ) + hsd1 ( nm1 ) + rnm1 ( nm2 ) rnm1t = rnm1 ( nm2 ) * rd ( nm2 ) sumnm1 = sumnm1 + rnm1t * rnm1 ( nm2 ) rnm1 ( nm2 ) = rnm1t rn ( nm2 ) = hsd2 ( n ) + rn ( nm2 ) sum2 = sum2 + rnm1t * rn ( nm2 ) yspnm1 = yspnm1 - rnm1t * ysp ( nm2 ) rnt = rn ( nm2 ) * rd ( nm2 ) sumn = sumn + rnt * rn ( nm2 ) rn ( nm2 ) = rnt yspn = yspn - rnt * ysp ( nm2 ) ! ! i = n-1 ! 12 rd ( nm1 ) = 1. / ( q * td ( nm1 ) + hd ( nm1 ) - sumnm1 ) ysp ( nm1 ) = yspnm1 rn ( nm1 ) = q * tsd1 ( n ) + hsd1 ( n ) - sum2 rnt = rn ( nm1 ) * rd ( nm1 ) sumn = sumn + rnt * rn ( nm1 ) rn ( nm1 ) = rnt yspn = yspn - rnt * ysp ( nm1 ) ! ! i = n ! rdn = q * td ( n ) + hd ( n ) - sumn rd ( n ) = 0. if ( rdn > 0. ) rd ( n ) = 1. / rdn ysp ( n ) = yspn ! ! back solve of r(transpose)* r * ysp = ys ! ysp ( n ) = rd ( n ) * ysp ( n ) ysp ( nm1 ) = rd ( nm1 ) * ysp ( nm1 ) - rn ( nm1 ) * ysp ( n ) if ( n == 2 ) go to 14 yspn = ysp ( n ) yspnm1 = ysp ( nm1 ) do ibak = 1 , nm2 i = nm1 - ibak ysp ( i ) = rd ( i ) * ysp ( i ) - rsd1 ( i + 1 ) * ysp ( i + 1 ) - rsd2 ( i + 2 ) * ysp ( i + 2 ) - rnm1 ( i ) * yspnm1 - rn ( i ) * yspn end do 14 sum = 0. delyi1 = ( ysp ( 1 ) - ysp ( n )) / ( x ( 1 ) + p - x ( n )) if ( isw == 1 ) go to 16 ! ! calculation of residual norm !  - d array ! do i = 1 , nm1 delyi = ( ysp ( i + 1 ) - ysp ( i )) / ( x ( i + 1 ) - x ( i )) v ( i ) = ( delyi - delyi1 ) * d ( i ) * d ( i ) sum = sum + v ( i ) * ( delyi - delyi1 ) delyi1 = delyi end do delyi = ( ysp ( 1 ) - ysp ( n )) / ( x ( 1 ) + p - x ( n )) v ( n ) = ( delyi - delyi1 ) * d ( n ) * d ( n ) go to 18 ! ! calculation of residual norm !  - d constant ! 16 do i = 1 , nm1 delyi = ( ysp ( i + 1 ) - ysp ( i )) / ( x ( i + 1 ) - x ( i )) v ( i ) = delyi - delyi1 sum = sum + v ( i ) * ( delyi - delyi1 ) delyi1 = delyi end do delyi = ( ysp ( 1 ) - ysp ( n )) / ( x ( 1 ) + p - x ( n )) v ( n ) = delyi - delyi1 18 sum = sum + v ( n ) * ( delyi - delyi1 ) ! ! test for convergence ! if ( sum <= su . and . sum >= sl . and . q > 0. ) go to 21 ! ! calculation of newton correction ! f = 0. g = 0. rnm1sm = 0. rnsm = 0. im1 = n if ( n == 2 ) go to 20 wim2 = 0. wim1 = 0. do i = 1 , nm2 tui = tsd1 ( i ) * ysp ( im1 ) + td ( i ) * ysp ( i ) + tsd1 ( i + 1 ) * ysp ( i + 1 ) wi = tui - rsd1 ( i ) * wim1 - rsd2 ( i ) * wim2 rnm1sm = rnm1sm - rnm1 ( i ) * wi rnsm = rnsm - rn ( i ) * wi f = f + tui * ysp ( i ) g = g + wi * wi * rd ( i ) im1 = i wim2 = wim1 wim1 = wi end do 20 tui = tsd1 ( nm1 ) * ysp ( im1 ) + td ( nm1 ) * ysp ( nm1 ) + tsd1 ( n ) * ysp ( n ) wi = tui + rnm1sm f = f + tui * ysp ( nm1 ) g = g + wi * wi * rd ( nm1 ) tui = tsd1 ( n ) * ysp ( nm1 ) + td ( n ) * ysp ( n ) + tsd1 ( 1 ) * ysp ( 1 ) wi = tui + rnsm - rn ( nm1 ) * wi f = f + tui * ysp ( n ) g = g + wi * wi * rd ( n ) h = f - q * g if ( h <= 0. . and . q > 0. ) go to 21 ! ! update q - newton step ! step = ( sum - sqrt ( sum * sl )) / h if ( sl /= 0. ) step = step * sqrt ( sum / sl ) q = q + step go to 8 ! ! store smoothed y-values and second derivatives ! 21 do i = 1 , n ys ( i ) = y ( i ) - v ( i ) ysp ( i ) = q * ysp ( i ) end do return ! ! store constant ys and zero ysp ! 23 do i = 1 , n ys ( i ) = con ysp ( i ) = 0. end do return ! ! n less than 2 ! 25 ierr = 1 return ! ! s negative ! 26 ierr = 2 return ! ! eps negative or greater than 1 ! 27 ierr = 3 return ! ! x-values not strictly increasing ! 28 ierr = 4 return ! ! weight non-positive ! 29 ierr = 5 return ! ! incorrect period ! 30 ierr = 6 return end subroutine fitp_curvpp subroutine fitp_curvss ( n , x , y , d , isw , s , eps , ys , ysp , sigma , td , & tsd1 , hd , hsd1 , hsd2 , rd , rsd1 , rsd2 , v , ierr ) integer n , isw , ierr real x ( n ), y ( n ), d ( n ), s , eps , ys ( n ), ysp ( n ), sigma , td ( n ), & tsd1 ( n ), hd ( n ), hsd1 ( n ), hsd2 ( n ), rd ( n ), rsd1 ( n ), rsd2 ( n ), v ( n ) ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this subroutine determines the parameters necessary to ! compute a smoothing spline under tension. for a given ! increasing sequence of abscissae (x(i)), i = 1,..., n and ! associated ordinates (y(i)), i = 1,..., n, the function ! determined minimizes the summation from i = 1 to n-1 of ! the square of the second derivative of f plus sigma ! squared times the difference of the first derivative of f ! and (f(x(i+1))-f(x(i)))/(x(i+1)-x(i)) squared, over all ! functions f with two continuous derivatives such that the ! summation of the square of (f(x(i))-y(i))/d(i) is less ! than or equal to a given constant s, where (d(i)), i = 1, ! ..., n are a given set of observation weights. the ! function determined is a spline under tension with third ! derivative discontinuities at (x(i)), i = 2,..., n-1. for ! actual computation of points on the curve it is necessary ! to call the function curv2. ! ! on input-- ! !   n is the number of values to be smoothed (n.ge.2). ! !   x is an array of the n increasing abscissae of the !   values to be smoothed. ! !   y is an array of the n ordinates of the values to be !   smoothed, (i. e. y(k) is the functional value !   corresponding to x(k) ). ! !   d is a parameter containing the observation weights. !   this may either be an array of length n or a scalar !   (interpreted as a constant). the value of d !   corresponding to the observation (x(k),y(k)) should !   be an approximation to the standard deviation of error. ! !   isw contains a switch indicating whether the parameter !   d is to be considered a vector or a scalar, !          = 0 if d is an array of length n, !          = 1 if d is a scalar. ! !   s contains the value controlling the smoothing. this !   must be non-negative. for s equal to zero, the !   subroutine does interpolation, larger values lead to !   smoother funtions. if parameter d contains standard !   deviation estimates, a reasonable value for s is !   float(n). ! !   eps contains a tolerance on the relative precision to !   which s is to be interpreted. this must be greater than !   or equal to zero and less than equal or equal to one. a !   reasonable value for eps is sqrt(2./float(n)). ! !   ys is an array of length at least n. ! !   ysp is an array of length at least n. ! !   sigma contains the tension factor. this value indicates !   the degree to which the first derivative part of the !   smoothing functional is emphasized. if sigma is nearly !   zero (e. g. .001) the resulting curve is approximately a !   cubic spline. if sigma is large (e. g. 50.) the !   resulting curve is nearly a polygonal line. if sigma !   equals zero a cubic spline results. a standard value for !   sigma is approximately 1. ! ! and ! !   td, tsd1, hd, hsd1, hsd2, rd, rsd1, rsd2, and v are !   arrays of length at least n which are used for scratch !   storage. ! ! on output-- ! !   ys contains the smoothed ordinate values. ! !   ysp contains the values of the second derivative of the !   smoothed curve at the given nodes. ! !   ierr contains an error flag, !        = 0 for normal return, !        = 1 if n is less than 2, !        = 2 if s is negative, !        = 3 if eps is negative or greater than one, !        = 4 if x-values are not strictly increasing, !        = 5 if a d-value is non-positive. ! ! and ! !   n, x, y, d, isw, s, eps, and sigma are unaltered. ! ! this subroutine references package modules terms and ! snhcsh. ! !----------------------------------------------------------- integer ibak real rsd1i , rsd2i , sum , hdi , beta , alpha , hdim1 , hsd1p real wi , tui , step , h , g , f , wim1 , wim2 , alphap integer nm1 , nm3 real delyi1 , delxi1 , rdim1 , p , sigmap , yspim2 real dim1 , su , sl , betap , betapp , delxi integer i real di , delyi if ( n < 2 ) go to 16 if ( s < 0. ) go to 17 if ( eps < 0. . or . eps > 1. ) go to 18 ierr = 0 p = 0. v ( 1 ) = 0. v ( n ) = 0. ysp ( 1 ) = 0. ysp ( n ) = 0. if ( n == 2 ) go to 14 rsd1 ( 1 ) = 0. rd ( 1 ) = 0. rsd2 ( n ) = 0. rdim1 = 0. yspim2 = 0. ! ! denormalize tension factor ! sigmap = abs ( sigma ) * real ( n - 1 ) / ( x ( n ) - x ( 1 )) ! ! form t matrix and second differences of y into ys ! nm1 = n - 1 nm3 = n - 3 delxi1 = 1. delyi1 = 0. dim1 = 0. do i = 1 , nm1 delxi = x ( i + 1 ) - x ( i ) if ( delxi <= 0. ) go to 19 delyi = ( y ( i + 1 ) - y ( i )) / delxi ys ( i ) = delyi - delyi1 call fitp_terms ( di , tsd1 ( i + 1 ), sigmap , delxi ) td ( i ) = di + dim1 hd ( i ) = - ( 1. / delxi + 1. / delxi1 ) hsd1 ( i + 1 ) = 1. / delxi delxi1 = delxi delyi1 = delyi dim1 = di end do ! ! calculate lower and upper tolerances ! sl = s * ( 1. - eps ) su = s * ( 1. + eps ) if ( isw == 1 ) go to 3 ! ! form h matrix - d array ! if ( d ( 1 ) <= 0. . or . d ( 2 ) <= 0. ) go to 20 betapp = 0. betap = 0. alphap = 0. do i = 2 , nm1 alpha = hd ( i ) * d ( i ) * d ( i ) if ( d ( i + 1 ) <= 0. ) go to 20 beta = hsd1 ( i + 1 ) * d ( i + 1 ) * d ( i + 1 ) hd ( i ) = ( hsd1 ( i ) * d ( i - 1 )) ** 2 + alpha * hd ( i ) + beta * hsd1 ( i + 1 ) hsd2 ( i ) = hsd1 ( i ) * betapp hsd1 ( i ) = hsd1 ( i ) * ( alpha + alphap ) alphap = alpha betapp = betap betap = beta end do go to 5 ! ! form h matrix - d constant ! 3 if ( d ( 1 ) <= 0. ) go to 20 sl = d ( 1 ) * d ( 1 ) * sl su = d ( 1 ) * d ( 1 ) * su hsd1p = 0. hdim1 = 0. do i = 2 , nm1 hdi = hd ( i ) hd ( i ) = hsd1 ( i ) * hsd1 ( i ) + hdi * hdi + hsd1 ( i + 1 ) * hsd1 ( i + 1 ) hsd2 ( i ) = hsd1 ( i ) * hsd1p hsd1p = hsd1 ( i ) hsd1 ( i ) = hsd1p * ( hdi + hdim1 ) hdim1 = hdi end do ! ! top of iteration ! cholesky factorization of p*t+h into r ! 5 do i = 2 , nm1 rsd2i = hsd2 ( i ) rsd1i = p * tsd1 ( i ) + hsd1 ( i ) - rsd2i * rsd1 ( i - 1 ) rsd2 ( i ) = rsd2i * rdim1 rdim1 = rd ( i - 1 ) rsd1 ( i ) = rsd1i * rdim1 rd ( i ) = 1. / ( p * td ( i ) + hd ( i ) - rsd1i * rsd1 ( i ) - rsd2i * rsd2 ( i )) ysp ( i ) = ys ( i ) - rsd1 ( i ) * ysp ( i - 1 ) - rsd2 ( i ) * yspim2 yspim2 = ysp ( i - 1 ) end do ! ! back solve of r(transpose)* r * ysp = ys ! ysp ( nm1 ) = rd ( nm1 ) * ysp ( nm1 ) if ( n == 3 ) go to 8 do ibak = 1 , nm3 i = nm1 - ibak ysp ( i ) = rd ( i ) * ysp ( i ) - rsd1 ( i + 1 ) * ysp ( i + 1 ) - rsd2 ( i + 2 ) * ysp ( i + 2 ) end do 8 sum = 0. delyi1 = 0. if ( isw == 1 ) go to 10 ! ! calculation of residual norm !  - d array ! do i = 1 , nm1 delyi = ( ysp ( i + 1 ) - ysp ( i )) / ( x ( i + 1 ) - x ( i )) v ( i ) = ( delyi - delyi1 ) * d ( i ) * d ( i ) sum = sum + v ( i ) * ( delyi - delyi1 ) delyi1 = delyi end do v ( n ) = - delyi1 * d ( n ) * d ( n ) go to 12 ! ! calculation of residual norm !  - d constant ! 10 do i = 1 , nm1 delyi = ( ysp ( i + 1 ) - ysp ( i )) / ( x ( i + 1 ) - x ( i )) v ( i ) = delyi - delyi1 sum = sum + v ( i ) * ( delyi - delyi1 ) delyi1 = delyi end do v ( n ) = - delyi1 12 sum = sum - v ( n ) * delyi1 ! ! test for convergence ! if ( sum <= su ) go to 14 ! ! calculation of newton correction ! f = 0. g = 0. wim2 = 0. wim1 = 0. do i = 2 , nm1 tui = tsd1 ( i ) * ysp ( i - 1 ) + td ( i ) * ysp ( i ) + tsd1 ( i + 1 ) * ysp ( i + 1 ) wi = tui - rsd1 ( i ) * wim1 - rsd2 ( i ) * wim2 f = f + tui * ysp ( i ) g = g + wi * wi * rd ( i ) wim2 = wim1 wim1 = wi end do h = f - p * g if ( h <= 0. ) go to 14 ! ! update p - newton step ! step = ( sum - sqrt ( sum * sl )) / h if ( sl /= 0. ) step = step * sqrt ( sum / sl ) p = p + step go to 5 ! ! store smoothed y-values and second derivatives ! 14 do i = 1 , n ys ( i ) = y ( i ) - v ( i ) ysp ( i ) = p * ysp ( i ) end do return ! ! n less than 2 ! 16 ierr = 1 return ! ! s negative ! 17 ierr = 2 return ! ! eps negative or greater than 1 ! 18 ierr = 3 return ! ! x-values not strictly increasing ! 19 ierr = 4 return ! ! weight non-positive ! 20 ierr = 5 return end subroutine fitp_curvss integer function fitp_intrvl ( t , x , n ) integer n real t , x ( n ) ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this function determines the index of the interval ! (determined by a given increasing sequence) in which ! a given value lies. ! ! on input-- ! !   t is the given value. ! !   x is a vector of strictly increasing values. ! ! and ! !   n is the length of x (n .ge. 2). ! ! on output-- ! !   intrvl returns an integer i such that ! !          i =  1       if         e   t .lt. x(2)  , !          i =  n-1     if x(n-1) .le. t            , !          otherwise       x(i)  .le. t .le. x(i+1), ! ! none of the input parameters are altered. ! !----------------------------------------------------------- integer il , ih , i real tt save i data i / 1 / tt = t ! ! check for illegal i ! if ( i >= n ) i = n / 2 ! ! check old interval and extremes ! if ( tt < x ( i )) then if ( tt <= x ( 2 )) then i = 1 fitp_intrvl = 1 return else il = 2 ih = i end if else if ( tt <= x ( i + 1 )) then fitp_intrvl = i return else if ( tt >= x ( n - 1 )) then i = n - 1 fitp_intrvl = n - 1 return else il = i + 1 ih = n - 1 end if ! ! binary search loop ! 1 i = ( il + ih ) / 2 if ( tt < x ( i )) then ih = i else if ( tt > x ( i + 1 )) then il = i + 1 else fitp_intrvl = i return end if go to 1 end function fitp_intrvl integer function fitp_intrvp ( t , x , n , p , tp ) integer n real t , x ( n ), p , tp ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this function determines the index of the interval ! (determined by a given increasing sequence) in which a ! given value lies, after translating the value to within ! the correct period.  it also returns this translated value. ! ! on input-- ! !   t is the given value. ! !   x is a vector of strictly increasing values. ! !   n is the length of x (n .ge. 2). ! ! and ! !   p contains the period. ! ! on output-- ! !   tp contains a translated value of t (i. e. x(1) .le. tp, !   tp .lt. x(1)+p, and tp = t + k*p for some integer k). ! !   intrvl returns an integer i such that ! !          i = 1       if             tp .lt. x(2)  , !          i = n       if   x(n) .le. tp            , !          otherwise       x(i)  .le. tp .lt. x(i+1), ! ! none of the input parameters are altered. ! !----------------------------------------------------------- integer il , ih , i , nper real tt save i data i / 1 / nper = int (( t - x ( 1 )) / p ) tp = t - real ( nper ) * p if ( tp < x ( 1 )) tp = tp + p tt = tp ! ! check for illegal i ! if ( i >= n ) i = n / 2 ! ! check old interval and extremes ! if ( tt < x ( i )) then if ( tt <= x ( 2 )) then i = 1 fitp_intrvp = 1 return else il = 2 ih = i end if else if ( tt <= x ( i + 1 )) then fitp_intrvp = i return else if ( tt >= x ( n )) then i = n fitp_intrvp = n return else il = i + 1 ih = n end if ! ! binary search loop ! 1 i = ( il + ih ) / 2 if ( tt < x ( i )) then ih = i else if ( tt > x ( i + 1 )) then il = i + 1 else fitp_intrvp = i return end if go to 1 end function fitp_intrvp subroutine fitp_snhcsh ( sinhm , coshm , x , isw ) integer isw real sinhm , coshm , x ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this subroutine returns approximations to !       sinhm(x) = sinh(x)/x-1 !       coshm(x) = cosh(x)-1 ! and !       coshmm(x) = (cosh(x)-1-x*x/2)/(x*x) ! with relative error less than 1.0e-6 ! ! on input-- ! !   x contains the value of the independent variable. ! !   isw indicates the function desired !           = -1 if only sinhm is desired, !           =  0 if both sinhm and coshm are desired, !           =  1 if only coshm is desired, !           =  2 if only coshmm is desired, !           =  3 if both sinhm and coshmm are desired. ! ! on output-- ! !   sinhm contains the value of sinhm(x) if isw .le. 0 or !   isw .eq. 3 (sinhm is unaltered if isw .eq.1 or isw .eq. !   2). ! !   coshm contains the value of coshm(x) if isw .eq. 0 or !   isw .eq. 1 and contains the value of coshmm(x) if isw !   .ge. 2 (coshm is unaltered if isw .eq. -1). ! ! and ! !   x and isw are unaltered. ! !----------------------------------------------------------- real sp10 , sp11 , sp12 , sp13 real sp20 , sp21 , sp22 , sp23 , sp24 real sp31 , sp32 , sp33 real sq30 , sq31 , sq32 real sp41 , sp42 , sp43 real sq40 , sq41 , sq42 real cp0 , cp1 , cp2 , cp3 , cp4 real ax , xs , expx data sp13 / . 302939 0e-5 / , sp12 / . 197513 5e-3 / , sp11 / . 833426 1e-2 / , sp10 / . 166666 5e0 / data sp24 / . 369346 7e-7 / , sp23 / . 245997 4e-5 / , sp22 / . 201810 7e-3 / , sp21 / . 831507 2e-2 / , sp20 / . 166703 5e0 / data sp33 / . 666655 8e-5 / , sp32 / . 664630 7e-3 / , sp31 / . 400147 7e-1 / , sq32 / . 203793 0e-3 / , sq31 /- . 637273 9e-1 / , sq30 / . 601749 7e1 / data sp43 / . 231181 6e-4 / , sp42 / . 272970 2e-3 / , sp41 / . 986875 7e-1 / , sq42 / . 177663 7e-3 / , sq41 /- . 754977 9e-1 / , sq40 / . 911003 4e1 / data cp4 / . 298262 8e-6 / , cp3 / . 247267 3e-4 / , cp2 / . 138896 7e-2 / , cp1 / . 416666 5e-1 / , cp0 / . 500000 0e0 / ax = abs ( x ) if ( isw >= 0 ) go to 5 ! ! sinhm approximation ! if ( ax > 4.45 ) go to 2 xs = ax * ax if ( ax > 2.3 ) go to 1 ! ! sinhm approximation on (0.,2.3) ! sinhm = xs * ((( sp13 * xs + sp12 ) * xs + sp11 ) * xs + sp10 ) return ! ! sinhm approximation on (2.3,4.45) ! 1 sinhm = xs * (((( sp24 * xs + sp23 ) * xs + sp22 ) * xs + sp21 ) * xs + sp20 ) return 2 if ( ax > 7.65 ) go to 3 ! ! sinhm approximation on (4.45,7.65) ! xs = ax * ax sinhm = xs * ((( sp33 * xs + sp32 ) * xs + sp31 ) * xs + 1. ) / (( sq32 * xs + sq31 ) * xs + sq30 ) return 3 if ( ax > 1 0.1 ) go to 4 ! ! sinhm approximation on (7.65,10.1) ! xs = ax * ax sinhm = xs * ((( sp43 * xs + sp42 ) * xs + sp41 ) * xs + 1. ) / (( sq42 * xs + sq41 ) * xs + sq40 ) return ! ! sinhm approximation above 10.1 ! 4 sinhm = exp ( ax ) / ( ax + ax ) - 1. return ! ! coshm and (possibly) sinhm approximation ! 5 if ( isw >= 2 ) go to 7 if ( ax > 2.3 ) go to 6 xs = ax * ax coshm = xs * (((( cp4 * xs + cp3 ) * xs + cp2 ) * xs + cp1 ) * xs + cp0 ) if ( isw == 0 ) sinhm = xs * ((( sp13 * xs + sp12 ) * xs + sp11 ) * xs + sp10 ) return 6 expx = exp ( ax ) coshm = ( expx + 1. / expx ) / 2. - 1. if ( isw == 0 ) sinhm = ( expx - 1. / expx ) / ( ax + ax ) - 1. return ! ! coshmm and (possibly) sinhm approximation ! 7 xs = ax * ax if ( ax > 2.3 ) go to 8 coshm = xs * ((( cp4 * xs + cp3 ) * xs + cp2 ) * xs + cp1 ) if ( isw == 3 ) sinhm = xs * ((( sp13 * xs + sp12 ) * xs + sp11 ) * xs + sp10 ) return 8 expx = exp ( ax ) coshm = (( expx + 1. / expx - xs ) / 2. - 1. ) / xs if ( isw == 3 ) sinhm = ( expx - 1. / expx ) / ( ax + ax ) - 1. return end subroutine fitp_snhcsh subroutine fitp_terms ( diag , sdiag , sigma , del ) ! real diag , sdiag , sigma , del ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this subroutine computes the diagonal and superdiagonal ! terms of the tridiagonal linear system associated with ! spline under tension interpolation. ! ! on input-- ! !   sigma contains the tension factor. ! ! and ! !   del contains the step size. ! ! on output-- ! !                sigma*del*cosh(sigma*del) - sinh(sigma*del) !   diag = del*--------------------------------------------. !                     (sigma*del)**2 * sinh(sigma*del) ! !                   sinh(sigma*del) - sigma*del !   sdiag = del*----------------------------------. !                (sigma*del)**2 * sinh(sigma*del) ! ! and ! !   sigma and del are unaltered. ! ! this subroutine references package module snhcsh. ! !----------------------------------------------------------- real coshm , denom , sigdel , sinhm if ( sigma /= 0. ) go to 1 diag = del / 3. sdiag = del / 6. return 1 sigdel = sigma * del call fitp_snhcsh ( sinhm , coshm , sigdel , 0 ) denom = sigma * sigdel * ( 1. + sinhm ) diag = ( coshm - sinhm ) / denom sdiag = sinhm / denom return end subroutine fitp_terms real function dedge ( a , r , n , iside ) integer n , iside real a ( n ), r ( n ) ! ! Not quite right for non-uniform r mesh ! if ( iside == 1 ) then dedge = - ( 3. * a ( 1 ) - 4. * a ( 2 ) + a ( 3 )) / ( r ( 3 ) - r ( 1 )) else dedge = ( 3. * a ( iside ) - 4. * a ( iside - 1 ) + a ( iside - 2 )) / ( r ( iside ) - r ( iside - 2 )) end if return end function dedge subroutine geo_spline_real ( x , y , xint , yint ) implicit none real , dimension (:), intent ( in ) :: x , y real , intent ( in ) :: xint real , intent ( out ) :: yint integer :: n , ierr real :: dum1 , dum2 , sigma real , dimension (:), allocatable :: ypp , dum3 n = size ( x ) allocate ( ypp ( n ), dum3 ( n )) sigma = 1.0 call fitp_curv1 ( n , x , y , dum1 , dum2 , 3 , ypp , dum3 , sigma , ierr ) yint = fitp_curv2 ( xint , n , x , y , ypp , sigma ) deallocate ( ypp , dum3 ) end subroutine geo_spline_real subroutine geo_spline_array ( x , y , xint , yint ) implicit none real , dimension (:), intent ( in ) :: x , y , xint real , dimension (:), intent ( out ) :: yint integer :: n , ierr , ix real :: dum1 , dum2 , sigma real , dimension (:), allocatable :: ypp , dum3 n = size ( x ) allocate ( ypp ( n ), dum3 ( n )) sigma = 1.0 call fitp_curv1 ( n , x , y , dum1 , dum2 , 3 , ypp , dum3 , sigma , ierr ) do ix = 1 , size ( xint ) yint ( ix ) = fitp_curv2 ( xint ( ix ), n , x , y , ypp , sigma ) end do deallocate ( ypp , dum3 ) end subroutine geo_spline_array ! assumes that y is periodic in x ! if x has m entries, then assumes that y(m+1)=y(1) subroutine linear_interp_periodic ( x , y , xint , yint , period ) use constants , only : pi implicit none real , dimension (:), intent ( in ) :: x , y , xint real , intent ( in ), optional :: period real , dimension (:), intent ( out ) :: yint integer :: i , j , m , n logical :: not_finished real , dimension (:), allocatable :: xp , yp m = size ( x ) + 1 n = size ( xint ) allocate ( xp ( m ), yp ( m )) xp (: m - 1 ) = x if ( present ( period )) then xp ( m ) = x ( 1 ) + period else xp ( m ) = x ( 1 ) + 2. * pi end if yp (: m - 1 ) = y yp ( m ) = y ( 1 ) j = 1 do i = 1 , n not_finished = . true . do while ( not_finished ) if ( abs ( xint ( i ) - xp ( j )) < 10 0. * epsilon ( 0. )) then yint ( i ) = yp ( j ) not_finished = . false . else if ( xint ( i ) > xp ( j )) then j = j + 1 else yint ( i ) = ( yp ( j - 1 ) * ( xp ( j ) - xint ( i )) + yp ( j ) * ( xint ( i ) - xp ( j - 1 ))) / ( xp ( j ) - xp ( j - 1 )) not_finished = . false . end if end do end do deallocate ( xp , yp ) end subroutine linear_interp_periodic end module splines","tags":"","loc":"sourcefile/spl.f90.html"},{"title":"sort.f90 â€“ stella","text":"Contents Modules sort Source Code sort.f90 Source Code module sort implicit none public :: sort_array_ascending public :: unsort_array_ascending contains subroutine sort_array_ascending ( array , sort_index ) implicit none real , dimension (:), intent ( in out ) :: array integer , dimension (:), intent ( out ) :: sort_index integer :: i , j , n real , dimension (:), allocatable :: tmp n = size ( array ) sort_index = 1 do i = 1 , n - 1 do j = i + 1 , n if ( array ( i ) > array ( j )) then sort_index ( i ) = sort_index ( i ) + 1 else sort_index ( j ) = sort_index ( j ) + 1 end if end do end do allocate ( tmp ( n )) tmp = array do i = 1 , n array ( sort_index ( i )) = tmp ( i ) end do deallocate ( tmp ) end subroutine sort_array_ascending subroutine unsort_array_ascending ( array , sort_index ) implicit none real , dimension (:), intent ( in out ) :: array integer , dimension (:), intent ( in ) :: sort_index integer :: i , n real , dimension (:), allocatable :: tmp n = size ( array ) allocate ( tmp ( n )) tmp = array do i = 1 , n array ( i ) = tmp ( sort_index ( i )) end do deallocate ( tmp ) end subroutine unsort_array_ascending end module sort","tags":"","loc":"sourcefile/sort.f90.html"},{"title":"convert.f90 â€“ stella","text":"Contents Modules convert Source Code convert.f90 Source Code module convert !------------------------------------------------------------------------------ !                              AstroGK, 2009 !------------------------------------------------------------------------------ ! <doc>Convert from complex variable a(d1,d2,d3, ...) to a ! real variable ar(2,d1,d2,d3,...) and back. ! This is necessary for saving complex variables in NetCDF format</doc> ! !     (c) Copyright 1991 to 1998 by Michael A. Beer, William D. Dorland, !     P. B. Snyder, Q. P. Liu, and Gregory W. Hammett. ALL RIGHTS RESERVED. ! implicit none private public :: c2r , r2c interface c2r module procedure x1c2r module procedure x2c2r module procedure x3c2r module procedure x4c2r module procedure x5c2r module procedure x6c2r end interface interface r2c module procedure x1r2c module procedure x2r2c module procedure x3r2c module procedure x4r2c module procedure x5r2c end interface contains !------------------------------------------------------------------------------ !                              AstroGK, 2009 !------------------------------------------------------------------------------ ! subroutine x5c2r ( a , a_ri ) complex , dimension (:, :, :, :, :), intent ( in ) :: a real , dimension (:, :, :, :, :, :), intent ( out ) :: a_ri if ( size ( a , 1 ) /= size ( a_ri , 2 )) call aborter ( 6 , 'x5c2r: size(a, 1) does not match size(a_ri, 2)' ) if ( size ( a , 2 ) /= size ( a_ri , 3 )) call aborter ( 6 , 'x5c2r: size(a, 2) does not match size(a_ri, 3)' ) if ( size ( a , 3 ) /= size ( a_ri , 4 )) call aborter ( 6 , 'x5c2r: size(a, 3) does not match size(a_ri, 4)' ) if ( size ( a , 4 ) /= size ( a_ri , 5 )) call aborter ( 6 , 'x5c2r: size(a, 4) does not match size(a_ri, 5)' ) if ( size ( a , 5 ) /= size ( a_ri , 6 )) call aborter ( 6 , 'x5c2r: size(a, 5) does not match size(a_ri, 6)' ) a_ri ( 1 , :, :, :, :, :) = real ( a (:, :, :, :, :)) a_ri ( 2 , :, :, :, :, :) = aimag ( a (:, :, :, :, :)) end subroutine x5c2r subroutine x6c2r ( a , a_ri ) complex , dimension (:, :, :, :, :, :), intent ( in ) :: a real , dimension (:, :, :, :, :, :, :), intent ( out ) :: a_ri if ( size ( a , 1 ) /= size ( a_ri , 2 )) call aborter ( 6 , 'x6c2r: size(a, 1) does not match size(a_ri, 2)' ) if ( size ( a , 2 ) /= size ( a_ri , 3 )) call aborter ( 6 , 'x6c2r: size(a, 2) does not match size(a_ri, 3)' ) if ( size ( a , 3 ) /= size ( a_ri , 4 )) call aborter ( 6 , 'x6c2r: size(a, 3) does not match size(a_ri, 4)' ) if ( size ( a , 4 ) /= size ( a_ri , 5 )) call aborter ( 6 , 'x6c2r: size(a, 4) does not match size(a_ri, 5)' ) if ( size ( a , 5 ) /= size ( a_ri , 6 )) call aborter ( 6 , 'x6c2r: size(a, 5) does not match size(a_ri, 6)' ) if ( size ( a , 6 ) /= size ( a_ri , 7 )) call aborter ( 6 , 'x6c2r: size(a, 6) does not match size(a_ri, 7)' ) a_ri ( 1 , :, :, :, :, :, :) = real ( a (:, :, :, :, :, :)) a_ri ( 2 , :, :, :, :, :, :) = aimag ( a (:, :, :, :, :, :)) end subroutine x6c2r !------------------------------------------------------------------------------ !                              AstroGK, 2009 !------------------------------------------------------------------------------ ! subroutine x5r2c ( a , a_ri ) real , dimension (:, :, :, :, :, :), intent ( in ) :: a_ri complex , dimension (:, :, :, :, :), intent ( out ) :: a if ( size ( a , 1 ) /= size ( a_ri , 2 )) call aborter ( 6 , 'x5r2c: size(a, 1) does not match size(a_ri, 2)' ) if ( size ( a , 2 ) /= size ( a_ri , 3 )) call aborter ( 6 , 'x5r2c: size(a, 2) does not match size(a_ri, 3)' ) if ( size ( a , 3 ) /= size ( a_ri , 4 )) call aborter ( 6 , 'x5r2c: size(a, 3) does not match size(a_ri, 4)' ) if ( size ( a , 4 ) /= size ( a_ri , 5 )) call aborter ( 6 , 'x5r2c: size(a, 4) does not match size(a_ri, 5)' ) if ( size ( a , 5 ) /= size ( a_ri , 6 )) call aborter ( 6 , 'x5r2c: size(a, 5) does not match size(a_ri, 6)' ) a (:, :, :, :, :) = cmplx ( a_ri ( 1 , :, :, :, :, :), a_ri ( 2 , :, :, :, :, :)) end subroutine x5r2c !------------------------------------------------------------------------------ !                              AstroGK, 2009 !------------------------------------------------------------------------------ ! subroutine x4c2r ( a , a_ri ) complex , dimension (:, :, :, :), intent ( in ) :: a real , dimension (:, :, :, :, :), intent ( out ) :: a_ri if ( size ( a , 1 ) /= size ( a_ri , 2 )) call aborter ( 6 , 'x4c2r: size(a, 1) does not match size(a_ri, 2)' ) if ( size ( a , 2 ) /= size ( a_ri , 3 )) call aborter ( 6 , 'x4c2r: size(a, 2) does not match size(a_ri, 3)' ) if ( size ( a , 3 ) /= size ( a_ri , 4 )) call aborter ( 6 , 'x4c2r: size(a, 3) does not match size(a_ri, 4)' ) if ( size ( a , 4 ) /= size ( a_ri , 5 )) call aborter ( 6 , 'x4c2r: size(a, 4) does not match size(a_ri, 5)' ) a_ri ( 1 , :, :, :, :) = real ( a (:, :, :, :)) a_ri ( 2 , :, :, :, :) = aimag ( a (:, :, :, :)) end subroutine x4c2r !------------------------------------------------------------------------------ !                              AstroGK, 2009 !------------------------------------------------------------------------------ ! subroutine x4r2c ( a , a_ri ) real , dimension (:, :, :, :, :), intent ( in ) :: a_ri complex , dimension (:, :, :, :), intent ( out ) :: a if ( size ( a , 1 ) /= size ( a_ri , 2 )) call aborter ( 6 , 'x4r2c: size(a, 1) does not match size(a_ri, 2)' ) if ( size ( a , 2 ) /= size ( a_ri , 3 )) call aborter ( 6 , 'x4r2c: size(a, 2) does not match size(a_ri, 3)' ) if ( size ( a , 3 ) /= size ( a_ri , 4 )) call aborter ( 6 , 'x4r2c: size(a, 3) does not match size(a_ri, 4)' ) if ( size ( a , 4 ) /= size ( a_ri , 5 )) call aborter ( 6 , 'x4r2c: size(a, 4) does not match size(a_ri, 5)' ) a (:, :, :, :) = cmplx ( a_ri ( 1 , :, :, :, :), a_ri ( 2 , :, :, :, :)) end subroutine x4r2c !------------------------------------------------------------------------------ !                              AstroGK, 2009 !------------------------------------------------------------------------------ ! subroutine x3c2r ( a , a_ri ) complex , dimension (:, :, :), intent ( in ) :: a real , dimension (:, :, :, :), intent ( out ) :: a_ri if ( size ( a , 1 ) /= size ( a_ri , 2 )) call aborter ( 6 , 'x3c2r: size(a, 1) does not match size(a_ri, 2)' ) if ( size ( a , 2 ) /= size ( a_ri , 3 )) call aborter ( 6 , 'x3c2r: size(a, 2) does not match size(a_ri, 3)' ) if ( size ( a , 3 ) /= size ( a_ri , 4 )) call aborter ( 6 , 'x3c2r: size(a, 3) does not match size(a_ri, 4)' ) a_ri ( 1 , :, :, :) = real ( a (:, :, :)) a_ri ( 2 , :, :, :) = aimag ( a (:, :, :)) end subroutine x3c2r !------------------------------------------------------------------------------ !                              AstroGK, 2009 !------------------------------------------------------------------------------ ! subroutine x3r2c ( a , a_ri ) real , dimension (:, :, :, :), intent ( in ) :: a_ri complex , dimension (:, :, :), intent ( out ) :: a if ( size ( a , 1 ) /= size ( a_ri , 2 )) call aborter ( 6 , 'x3r2c: size(a, 1) does not match size(a_ri, 2)' ) if ( size ( a , 2 ) /= size ( a_ri , 3 )) call aborter ( 6 , 'x3r2c: size(a, 2) does not match size(a_ri, 3)' ) if ( size ( a , 3 ) /= size ( a_ri , 4 )) call aborter ( 6 , 'x3r2c: size(a, 3) does not match size(a_ri, 4)' ) a (:, :, :) = cmplx ( a_ri ( 1 , :, :, :), a_ri ( 2 , :, :, :)) end subroutine x3r2c !------------------------------------------------------------------------------ !                              AstroGK, 2009 !------------------------------------------------------------------------------ ! subroutine x2c2r ( a , a_ri ) complex , dimension (:, :), intent ( in ) :: a real , dimension (:, :, :), intent ( out ) :: a_ri if ( size ( a , 1 ) /= size ( a_ri , 2 )) call aborter ( 6 , 'x2c2r: size(a, 1) does not match size(a_ri, 2)' ) if ( size ( a , 2 ) /= size ( a_ri , 3 )) call aborter ( 6 , 'x2c2r: size(a, 2) does not match size(a_ri, 3)' ) a_ri ( 1 , :, :) = real ( a (:, :)) a_ri ( 2 , :, :) = aimag ( a (:, :)) end subroutine x2c2r !------------------------------------------------------------------------------ !                              AstroGK, 2009 !------------------------------------------------------------------------------ ! subroutine x2r2c ( a , a_ri ) real , dimension (:, :, :), intent ( in ) :: a_ri complex , dimension (:, :), intent ( out ) :: a if ( size ( a , 1 ) /= size ( a_ri , 2 )) call aborter ( 6 , 'x2r2c: size(a, 1) does not match size(a_ri, 2)' ) if ( size ( a , 2 ) /= size ( a_ri , 3 )) call aborter ( 6 , 'x2r2c: size(a, 2) does not match size(a_ri, 3)' ) a (:, :) = cmplx ( a_ri ( 1 , :, :), a_ri ( 2 , :, :)) end subroutine x2r2c !------------------------------------------------------------------------------ !                              AstroGK, 2009 !------------------------------------------------------------------------------ ! subroutine x1c2r ( a , a_ri ) complex , dimension (:), intent ( in ) :: a real , dimension (:, :), intent ( out ) :: a_ri if ( size ( a , 1 ) /= size ( a_ri , 2 )) call aborter ( 6 , 'x2c2r: size(a, 1) does not match size(a_ri, 2)' ) a_ri ( 1 , :) = real ( a (:)) a_ri ( 2 , :) = aimag ( a (:)) end subroutine x1c2r !------------------------------------------------------------------------------ !                              AstroGK, 2009 !------------------------------------------------------------------------------ ! subroutine x1r2c ( a , a_ri ) real , dimension (:, :), intent ( in ) :: a_ri complex , dimension (:), intent ( out ) :: a if ( size ( a , 1 ) /= size ( a_ri , 2 )) call aborter ( 6 , 'x2r2c: size(a, 1) does not match size(a_ri, 2)' ) a (:) = cmplx ( a_ri ( 1 , :), a_ri ( 2 , :)) end subroutine x1r2c !------------------------------------------------------------------------------ !                              AstroGK, 2009 !------------------------------------------------------------------------------ ! Subroutine Aborter ( iunit , ierrmsg ) !---------------------------------------------------------------------- !  ABORT A PROGRAM AFTER A FATAL ERROR CONDITION IS DETECTED. ! ! ! input: iunit  Unit Number of the file to write error messages to. !        ierrmsg  An error message to write ilunerr ! !       The advantage of using this subroutine is that it will !       generate a traceback showing the chain of subroutines which !       eventually bombed, and it forces an arithmetic error which !       the job control system can detect as a fatal error. ! character ierrmsg * ( * ) real :: zz0 , zz1 integer :: iunit , ilunerr common / abortcmn / zz0 , zz1 ! ! zz0 is in a common block to prevent an optimizing compiler ! from evaluating 1.0/zz0 during compilation rather than during ! execution. ! write ( iunit , 1001 ) 1001 format ( // ' %ABORTER:  ** FATAL ERROR.  ABORT SUBROUTINE CALLED **' // ) write ( iunit , 1002 ) ierrmsg 1002 format ( 1 x , a , // ) ! on CRAY's and VAXes: ! generate a divide-by-zero error: zz1 = 1.0 / zz0 !&#94; ilunerr = 5 !&#94; ! on the DecStation: !&#94;      call exit(1) write ( ilunerr , 1010 ) zz0 1010 format ( ' ?ABORTER-- ZZ0= ' , 1 PE11 . 4 , ' AND STILL EXECUTING...' ) end subroutine aborter !------------------------------------------------------------------------------ end module convert","tags":"","loc":"sourcefile/convert.f90.html"},{"title":"spfunc.fpp â€“ stella","text":"Contents Modules spfunc Source Code spfunc.fpp Source Code # include \"define.inc\" ! ! special function wrapper routine written by Tomo Tatsuno (5/7/08) ! only has Bessel function at the moment ! ! RN 2008/07/01: Error function is added ! RN 2008/07/01: Compilers not having intrinsic those special functions !                must choose one of the following !                 1: local [USE_LOCAL_SPFUNC=on] !                 2: NAG Library [USE_NAGLIB=spfunc] ! ! Unfortunately we do not support elemental feature for ifort... ! XL-fortran does not seem to have intrinsic Bessel function ! ! To do: avoid explicit specification of kind and use kind_rs or kind_rd !        support of other compilers such as absoft, lahay etc... ! ! PGI cannot use kind_rs, kind_rd as kind specifications, but it is ok ! because we know kind_rs=4 kind_rd=8 for PGI ! module spfunc use constants , only : kind_rs , kind_rd # if SPFUNC == _SPNAG_ use constants , only : nag_kind # endif implicit none public :: j0 , j1 public :: erf_ext private # if SPFUNC == _SPNAG_ ! error handling ! ifail=0: terminate the program ! ifail=1 (-1): continues the program w/o (w) error messages integer :: ifail = - 1 # endif # if SPFUNC == _SPLOCAL_ # elif SPFUNC == _SPNAG_ # else /* if not _SPLOCAL_ and not _SPNAG_ */ # if (FCOMPILER == _GFORTRAN_ || FCOMPILER == _INTEL_ \\ || FCOMPILER == _ PATHSCALE_ ) interface j0 module procedure sj0 , dj0 end interface interface j1 module procedure sj1 , dj1 end interface interface erf_ext module procedure serf_ext , derf_ext end interface # elif FCOMPILER == _G95_ /* not _GFORTRAN_, _INTEL_, _PATHSCALE_ */ interface j0 module procedure sj0 , dj0 end interface interface j1 module procedure sj1 , dj1 end interface # elif FCOMPILER == _PGI_ /* not _GFORTRAN_, _INTEL_, _PATHSCALE_, _G95_ */ interface j0 elemental function besj0 ( x ) real ( kind = 4 ), intent ( in ) :: x real ( kind = 4 ) :: besj0 end function besj0 elemental function dbesj0 ( x ) real ( kind = 8 ), intent ( in ) :: x real ( kind = 8 ) :: dbesj0 end function dbesj0 end interface ! j1 is below interface erf_ext elemental function erf ( x ) real ( kind = 4 ), intent ( in ) :: x real ( kind = 4 ) :: erf end function erf elemental function derf ( x ) real ( kind = 8 ), intent ( in ) :: x real ( kind = 8 ) :: derf end function derf end interface # endif /* FCOMPILER */ # endif /* SPFUNC */ contains # if SPFUNC == _SPLOCAL_ !-------------------------------------------------------------------------! ! double precision Bessel functions (dbesj0.f dbesj1.f)                   ! ! http://www.kurims.kyoto-u.ac.jp/~ooura/bessel.html                      ! !-------------------------------------------------------------------------! ! Copyright(C) 1996 Takuya OOURA (email: ooura@mmm.t.u-tokyo.ac.jp).      ! ! You may use, copy, modify this code for any purpose and                 ! ! without fee. You may distribute this ORIGINAL package.                  ! !-------------------------------------------------------------------------! ! Modified by Ryusuke NUMATA 2008/06/27                                   ! !  to fit F90 format, and for j1 to give besj1/x                          ! !-------------------------------------------------------------------------! ! these routines are declared as real, but can be promoted to ! double presicion using compiler option. ! this is so because constatns used are only double precision, ! and cannot be promoted to quad-precision. ! differences from GNU gfortran besj0 and besj1 are ! |err| < 1.e-15 elemental function j0 ( x ) ! Bessel J_0(x) function in double precision use constants , only : pi real :: j0 real , intent ( in ) :: x integer :: k real :: w , t , y , theta , v real , parameter :: a ( 0 : 7 ) = ( / & & - 0.0000000000023655394 , 0.0000000004708898680 , & & - 0.0000000678167892231 , 0.0000067816840038636 , & & - 0.0004340277777716935 , 0.0156249999999992397 , & & - 0.2499999999999999638 , 0.9999999999999999997 / ) real , parameter :: b ( 0 : 64 ) = ( / & & 0.0000000000626681117 , - 0.0000000022270614428 , & & 0.0000000662981656302 , - 0.0000016268486502196 , & & 0.0000321978384111685 , - 0.0005005237733315830 , & & 0.0059060313537449816 , - 0.0505265323740109701 , & & 0.2936432097610503985 , - 1.0482565081091638637 , & & 1.9181123286040428113 , - 1.1319199475221700100 , & & - 0.1965480952704682000 , 0.0000000000457457332 , & & - 0.0000000015814772025 , 0.0000000455487446311 , & & - 0.0000010735201286233 , 0.0000202015179970014 , & & - 0.0002942392368203808 , 0.0031801987726150648 , & & - 0.0239875209742846362 , 0.1141447698973777641 , & & - 0.2766726722823530233 , 0.1088620480970941648 , & & 0.5136514645381999197 , - 0.2100594022073706033 , & & 0.0000000000331366618 , - 0.0000000011119090229 , & & 0.0000000308823040363 , - 0.0000006956602653104 , & & 0.0000123499947481762 , - 0.0001662951945396180 , & & 0.0016048663165678412 , - 0.0100785479932760966 , & & 0.0328996815223415274 , - 0.0056168761733860688 , & & - 0.2341096400274429386 , 0.2551729256776404262 , & & 0.2288438186148935667 , 0.0000000000238007203 , & & - 0.0000000007731046439 , 0.0000000206237001152 , & & - 0.0000004412291442285 , 0.0000073107766249655 , & & - 0.0000891749801028666 , 0.0007341654513841350 , & & - 0.0033303085445352071 , 0.0015425853045205717 , & & 0.0521100583113136379 , - 0.1334447768979217815 , & & - 0.1401330292364750968 , 0.2685616168804818919 , & & 0.0000000000169355950 , - 0.0000000005308092192 , & & 0.0000000135323005576 , - 0.0000002726650587978 , & & 0.0000041513240141760 , - 0.0000443353052220157 , & & 0.0002815740758993879 , - 0.0004393235121629007 , & & - 0.0067573531105799347 , 0.0369141914660130814 , & & 0.0081673361942996237 , - 0.2573381285898881860 , & & 0.0459580257102978932 / ) real , parameter :: c ( 0 : 69 ) = ( / & & - 0.00000000003009451757 , - 0.00000000014958003844 , & & 0.00000000506854544776 , 0.00000001863564222012 , & & - 0.00000060304249068078 , - 0.00000147686259937403 , & & 0.00004714331342682714 , 0.00006286305481740818 , & & - 0.00214137170594124344 , - 0.00089157336676889788 , & & 0.04508258728666024989 , - 0.00490362805828762224 , & & - 0.27312196367405374426 , 0.04193925184293450356 , & & - 0.00000000000712453560 , - 0.00000000041170814825 , & & 0.00000000138012624364 , 0.00000005704447670683 , & & - 0.00000019026363528842 , - 0.00000533925032409729 , & & 0.00001736064885538091 , 0.00030692619152608375 , & & - 0.00092598938200644367 , - 0.00917934265960017663 , & & 0.02287952522866389076 , 0.10545197546252853195 , & & - 0.16126443075752985095 , - 0.19392874768742235538 , & & 0.00000000002128344556 , - 0.00000000031053910272 , & & - 0.00000000334979293158 , 0.00000004507232895050 , & & 0.00000036437959146427 , - 0.00000446421436266678 , & & - 0.00002523429344576552 , 0.00027519882931758163 , & & 0.00097185076358599358 , - 0.00898326746345390692 , & & - 0.01665959196063987584 , 0.11456933464891967814 , & & 0.07885001422733148815 , - 0.23664819446234712621 , & & 0.00000000003035295055 , 0.00000000005486066835 , & & - 0.00000000501026824811 , - 0.00000000501246847860 , & & 0.00000058012340163034 , 0.00000016788922416169 , & & - 0.00004373270270147275 , 0.00001183898532719802 , & & 0.00189863342862291449 , - 0.00113759249561636130 , & & - 0.03846797195329871681 , 0.02389746880951420335 , & & 0.22837862066532347461 , - 0.06765394811166522844 , & & 0.00000000001279875977 , 0.00000000035925958103 , & & - 0.00000000228037105967 , - 0.00000004852770517176 , & & 0.00000028696428000189 , 0.00000440131125178642 , & & - 0.00002366617753349105 , - 0.00024412456252884129 , & & 0.00113028178539430542 , 0.00708470513919789080 , & & - 0.02526914792327618386 , - 0.08006137953480093426 , & & 0.16548380461475971846 , 0.14688405470042110229 / ) real , parameter :: d ( 0 : 51 ) = ( / & & 1.059601355592185731e-14 , - 2.71150591218550377e-13 , & & 8.6514809056201638e-12 , - 4.6264028554286627e-10 , & & 5.0815403835647104e-8 , - 1.76722552048141208e-5 , & & 0.16286750396763997378 , 2.949651820598278873e-13 , & & - 8.818215611676125741e-12 , 3.571119876162253451e-10 , & & - 2.631924120993717060e-8 , 4.709502795656698909e-6 , & & - 5.208333333333283282e-3 , 7.18344107717531977e-15 , & & - 2.51623725588410308e-13 , 8.6017784918920604e-12 , & & - 4.6256876614290359e-10 , 5.0815343220437937e-8 , & & - 1.76722551764941970e-5 , 0.16286750396763433767 , & & 2.2327570859680094777e-13 , - 8.464594853517051292e-12 , & & 3.563766464349055183e-10 , - 2.631843986737892965e-8 , & & 4.709502342288659410e-6 , - 5.2083333332278466225e-3 , & & 5.15413392842889366e-15 , - 2.27740238380640162e-13 , & & 8.4827767197609014e-12 , - 4.6224753682737618e-10 , & & 5.0814848128929134e-8 , - 1.76722547638767480e-5 , & & 0.16286750396748926663 , 1.7316195320192170887e-13 , & & - 7.971122772293919646e-12 , 3.544039469911895749e-10 , & & - 2.631443902081701081e-8 , 4.709498228695400603e-6 , & & - 5.2083333315143653610e-3 , 3.84653681453798517e-15 , & & - 2.04464520778789011e-13 , 8.3089298605177838e-12 , & & - 4.6155016158412096e-10 , 5.0813263696466650e-8 , & & - 1.76722528311426167e-5 , 0.16286750396650065930 , & & 1.3797879972460878797e-13 , - 7.448089381011684812e-12 , & & 3.512733797106959780e-10 , - 2.630500895563592722e-8 , & & 4.709483934775839193e-6 , - 5.2083333227940760113e-3 / ) w = abs ( x ) if ( w < 1 ) then t = w * w y = (((((( a ( 0 ) * t + a ( 1 )) * t + & & a ( 2 )) * t + a ( 3 )) * t + a ( 4 )) * t + & & a ( 5 )) * t + a ( 6 )) * t + a ( 7 ) else if ( w < 8.5 ) then t = w * w * 0.0625 k = int ( t ) t = t - ( k + 0.5 ) k = k * 13 y = ((((((((((( b ( k ) * t + b ( k + 1 )) * t + & & b ( k + 2 )) * t + b ( k + 3 )) * t + b ( k + 4 )) * t + & & b ( k + 5 )) * t + b ( k + 6 )) * t + b ( k + 7 )) * t + & & b ( k + 8 )) * t + b ( k + 9 )) * t + b ( k + 10 )) * t + & & b ( k + 11 )) * t + b ( k + 12 ) else if ( w < 1 2.5 ) then k = int ( w ) t = w - ( k + 0.5 ) k = 14 * ( k - 8 ) y = (((((((((((( c ( k ) * t + c ( k + 1 )) * t + & & c ( k + 2 )) * t + c ( k + 3 )) * t + c ( k + 4 )) * t + & & c ( k + 5 )) * t + c ( k + 6 )) * t + c ( k + 7 )) * t + & & c ( k + 8 )) * t + c ( k + 9 )) * t + c ( k + 10 )) * t + & & c ( k + 11 )) * t + c ( k + 12 )) * t + c ( k + 13 ) else v = 2 4. / w t = v * v k = 13 * ( int ( t )) y = (((((( d ( k ) * t + d ( k + 1 )) * t + & & d ( k + 2 )) * t + d ( k + 3 )) * t + d ( k + 4 )) * t + & & d ( k + 5 )) * t + d ( k + 6 )) * sqrt ( v ) theta = ((((( d ( k + 7 ) * t + d ( k + 8 )) * t + & & d ( k + 9 )) * t + d ( k + 10 )) * t + d ( k + 11 )) * t + & & d ( k + 12 )) * v - . 25 * pi y = y * cos ( w + theta ) end if j0 = y end function j0 elemental function j1 ( x ) ! Bessel J_1(x) function devided by x in double precision use constants , only : pi real :: j1 real , intent ( in ) :: x integer :: k real :: w , t , y , theta , v real , parameter :: a ( 0 : 7 ) = ( / & & - 0.00000000000014810349 , 0.00000000003363594618 , & & - 0.00000000565140051697 , 0.00000067816840144764 , & & - 0.00005425347222188379 , 0.00260416666666662438 , & & - 0.06249999999999999799 , 0.49999999999999999998 / ) real , parameter :: b ( 0 : 64 ) = ( / & & 0.00000000000243721316 , - 0.00000000009400554763 , & & 0.00000000306053389980 , - 0.00000008287270492518 , & & 0.00000183020515991344 , - 0.00003219783841164382 , & & 0.00043795830161515318 , - 0.00442952351530868999 , & & 0.03157908273375945955 , - 0.14682160488052520107 , & & 0.39309619054093640008 , - 0.47952808215101070280 , & & 0.14148999344027125140 , 0.00000000000182119257 , & & - 0.00000000006862117678 , 0.00000000217327908360 , & & - 0.00000005693592917820 , 0.00000120771046483277 , & & - 0.00002020151799736374 , 0.00025745933218048448 , & & - 0.00238514907946126334 , 0.01499220060892984289 , & & - 0.05707238494868888345 , 0.10375225210588234727 , & & - 0.02721551202427354117 , - 0.06420643306727498985 , & & 0.000000000001352611196 , - 0.000000000049706947875 , & & 0.000000001527944986332 , - 0.000000038602878823401 , & & 0.000000782618036237845 , - 0.000012349994748451100 , & & 0.000145508295194426686 , - 0.001203649737425854162 , & & 0.006299092495799005109 , - 0.016449840761170764763 , & & 0.002106328565019748701 , 0.058527410006860734650 , & & - 0.031896615709705053191 , 0.000000000000997982124 , & & - 0.000000000035702556073 , 0.000000001062332772617 , & & - 0.000000025779624221725 , 0.000000496382962683556 , & & - 0.000007310776625173004 , 0.000078028107569541842 , & & - 0.000550624088538081113 , 0.002081442840335570371 , & & - 0.000771292652260286633 , - 0.019541271866742634199 , & & 0.033361194224480445382 , 0.017516628654559387164 , & & 0.000000000000731050661 , - 0.000000000025404499912 , & & 0.000000000729360079088 , - 0.000000016915375004937 , & & 0.000000306748319652546 , - 0.000004151324014331739 , & & 0.000038793392054271497 , - 0.000211180556924525773 , & & 0.000274577195102593786 , 0.003378676555289966782 , & & - 0.013842821799754920148 , - 0.002041834048574905921 , & & 0.032167266073736023299 / ) real , parameter :: c ( 0 : 69 ) = ( / & & - 0.00000000001185964494 , 0.00000000039110295657 , & & 0.00000000180385519493 , - 0.00000005575391345723 , & & - 0.00000018635897017174 , 0.00000542738239401869 , & & 0.00001181490114244279 , - 0.00033000319398521070 , & & - 0.00037717832892725053 , 0.01070685852970608288 , & & 0.00356629346707622489 , - 0.13524776185998074716 , & & 0.00980725611657523952 , 0.27312196367405374425 , & & - 0.00000000003029591097 , 0.00000000009259293559 , & & 0.00000000496321971223 , - 0.00000001518137078639 , & & - 0.00000057045127595547 , 0.00000171237271302072 , & & 0.00004271400348035384 , - 0.00012152454198713258 , & & - 0.00184155714921474963 , 0.00462994691003219055 , & & 0.03671737063840232452 , - 0.06863857568599167175 , & & - 0.21090395092505707655 , 0.16126443075752985095 , & & - 0.00000000002197602080 , - 0.00000000027659100729 , & & 0.00000000374295124827 , 0.00000003684765777023 , & & - 0.00000045072801091574 , - 0.00000327941630669276 , & & 0.00003571371554516300 , 0.00017664005411843533 , & & - 0.00165119297594774104 , - 0.00485925381792986774 , & & 0.03593306985381680131 , 0.04997877588191962563 , & & - 0.22913866929783936544 , - 0.07885001422733148814 , & & 0.00000000000516292316 , - 0.00000000039445956763 , & & - 0.00000000066220021263 , 0.00000005511286218639 , & & 0.00000005012579400780 , - 0.00000522111059203425 , & & - 0.00000134311394455105 , 0.00030612891890766805 , & & - 0.00007103391195326182 , - 0.00949316714311443491 , & & 0.00455036998246516948 , 0.11540391585989614784 , & & - 0.04779493761902840455 , - 0.22837862066532347460 , & & 0.00000000002697817493 , - 0.00000000016633326949 , & & - 0.00000000433134860350 , 0.00000002508404686362 , & & 0.00000048528284780984 , - 0.00000258267851112118 , & & - 0.00003521049080466759 , 0.00016566324273339952 , & & 0.00146474737522491617 , - 0.00565140892697147306 , & & - 0.02833882055679300400 , 0.07580744376982855057 , & & 0.16012275906960187978 , - 0.16548380461475971845 / ) real , parameter :: d ( 0 : 51 ) = ( / & & - 1.272346002224188092e-14 , 3.370464692346669075e-13 , & & - 1.144940314335484869e-11 , 6.863141561083429745e-10 , & & - 9.491933932960924159e-8 , 5.301676561445687562e-5 , & & 0.1628675039676399740 , - 3.652982212914147794e-13 , & & 1.151126750560028914e-11 , - 5.165585095674343486e-10 , & & 4.657991250060549892e-8 , - 1.186794704692706504e-5 , & & 1.562499999999994026e-2 , - 8.713069680903981555e-15 , & & 3.140780373478474935e-13 , - 1.139089186076256597e-11 , & & 6.862299023338785566e-10 , - 9.491926788274594674e-8 , & & 5.301676558106268323e-5 , 0.1628675039676466220 , & & - 2.792555727162752006e-13 , 1.108650207651756807e-11 , & & - 5.156745588549830981e-10 , 4.657894859077370979e-8 , & & - 1.186794650130550256e-5 , 1.562499999987299901e-2 , & & - 6.304859171204770696e-15 , 2.857249044208791652e-13 , & & - 1.124956921556753188e-11 , 6.858482894906716661e-10 , & & - 9.491867953516898460e-8 , 5.301676509057781574e-5 , & & 0.1628675039678191167 , - 2.185193490132496053e-13 , & & 1.048820673697426074e-11 , - 5.132819367467680132e-10 , & & 4.657409437372994220e-8 , - 1.186794150862988921e-5 , & & 1.562499999779270706e-2 , - 4.740417209792009850e-15 , & & 2.578715253644144182e-13 , - 1.104148898414138857e-11 , & & 6.850134201626289183e-10 , - 9.491678234174919640e-8 , & & 5.301676277588728159e-5 , 0.1628675039690033136 , & & - 1.755122057493842290e-13 , 9.848723331445182397e-12 , & & - 5.094535425482245697e-10 , 4.656255982268609304e-8 , & & - 1.186792402114394891e-5 , 1.562499998712198636e-2 / ) w = abs ( x ) if ( w < 1 ) then t = w * w !       y = (((((((a(0) * t + a(1)) * t + & !            & a(2)) * t + a(3)) * t + a(4)) * t + & !            & a(5)) * t + a(6)) * t + a(7)) * w y = (((((( a ( 0 ) * t + a ( 1 )) * t + & & a ( 2 )) * t + a ( 3 )) * t + a ( 4 )) * t + & & a ( 5 )) * t + a ( 6 )) * t + a ( 7 ) else if ( w < 8.5 ) then t = w * w * 0.0625 k = int ( t ) t = t - ( k + 0.5 ) k = k * 13 !       y = ((((((((((((b(k) * t + b(k + 1)) * t + & !            & b(k + 2)) * t + b(k + 3)) * t + b(k + 4)) * t + & !            & b(k + 5)) * t + b(k + 6)) * t + b(k + 7)) * t + & !            & b(k + 8)) * t + b(k + 9)) * t + b(k + 10)) * t + & !            & b(k + 11)) * t + b(k + 12)) * w y = ((((((((((( b ( k ) * t + b ( k + 1 )) * t + & & b ( k + 2 )) * t + b ( k + 3 )) * t + b ( k + 4 )) * t + & & b ( k + 5 )) * t + b ( k + 6 )) * t + b ( k + 7 )) * t + & & b ( k + 8 )) * t + b ( k + 9 )) * t + b ( k + 10 )) * t + & & b ( k + 11 )) * t + b ( k + 12 ) else if ( w < 1 2.5 ) then k = int ( w ) t = w - ( k + 0.5 ) k = 14 * ( k - 8 ) !       y = ((((((((((((c(k) * t + c(k + 1)) * t + & !            & c(k + 2)) * t + c(k + 3)) * t + c(k + 4)) * t + & !            & c(k + 5)) * t + c(k + 6)) * t + c(k + 7)) * t + & !            & c(k + 8)) * t + c(k + 9)) * t + c(k + 10)) * t + & !            & c(k + 11)) * t + c(k + 12)) * t + c(k + 13) y = ((((((((((((( c ( k ) * t + c ( k + 1 )) * t + & & c ( k + 2 )) * t + c ( k + 3 )) * t + c ( k + 4 )) * t + & & c ( k + 5 )) * t + c ( k + 6 )) * t + c ( k + 7 )) * t + & & c ( k + 8 )) * t + c ( k + 9 )) * t + c ( k + 10 )) * t + & & c ( k + 11 )) * t + c ( k + 12 )) * t + c ( k + 13 )) / w else v = 2 4. / w t = v * v k = 13 * ( int ( t )) y = (((((( d ( k ) * t + d ( k + 1 )) * t + & & d ( k + 2 )) * t + d ( k + 3 )) * t + d ( k + 4 )) * t + & & d ( k + 5 )) * t + d ( k + 6 )) * sqrt ( v ) theta = ((((( d ( k + 7 ) * t + d ( k + 8 )) * t + & & d ( k + 9 )) * t + d ( k + 10 )) * t + d ( k + 11 )) * t + & & d ( k + 12 )) * v - . 25 * pi y = y * sin ( w + theta ) ! y = y / w end if !    if (x < 0) y = -y j1 = y end function j1 !-------------------------------------------------------------------------! ! double precision error functions (derf.f)                               ! ! http://www.kurims.kyoto-u.ac.jp/~ooura/gamerf.html                      ! !-------------------------------------------------------------------------! ! Copyright(C) 1996 Takuya OOURA (email: ooura@mmm.t.u-tokyo.ac.jp).      ! ! You may use, copy, modify this code for any purpose and                 ! ! without fee. You may distribute this ORIGINAL package.                  ! !-------------------------------------------------------------------------! ! Modified by Ryusuke NUMATA 2008/06/27                                   ! !  to fit F90 format                                                      ! !-------------------------------------------------------------------------! ! these routines are declared as real, but can be promoted to ! double presicion using compiler option. ! this is so because constatns used are only double precision, ! and cannot be promoted to quad-precision. ! differences from GNU gfortran besj0 and besj1 are ! |err| < 1.e-15 !!$  elemental function erf(x) !!$! A&S, p.299 7.1.28 |epsilon|<=3.e-7 !!$    implicit none !!$    real, intent(in) :: x !!$    real :: xerf !!$    real, parameter, dimension(6) :: a = (/ & !!$         0.0705230784, 0.0422820123, 0.0092705272, & !!$         0.0001520143, 0.0002765672, 0.0000430638 /) !!$ !!$    erf = 1.0 - 1.0/(1.0 + & !!$         x*(a(1) + x*(a(2) + x*(a(3) + x*(a(4) + x*(a(5) + x*(a(6))))))))**16 !!$ !!$  end function erf elemental function erf_ext ( x ) ! error function in double precision real :: erf_ext real , intent ( in ) :: x integer :: k real :: w , t , y real , parameter :: a ( 0 : 64 ) = ( / & & 0.00000000005958930743 , - 0.00000000113739022964 , & & 0.00000001466005199839 , - 0.00000016350354461960 , & & 0.00000164610044809620 , - 0.00001492559551950604 , & & 0.00012055331122299265 , - 0.00085483269811296660 , & & 0.00522397762482322257 , - 0.02686617064507733420 , & & 0.11283791670954881569 , - 0.37612638903183748117 , & & 1.12837916709551257377 , 0.00000000002372510631 , & & - 0.00000000045493253732 , 0.00000000590362766598 , & & - 0.00000006642090827576 , 0.00000067595634268133 , & & - 0.00000621188515924000 , 0.00005103883009709690 , & & - 0.00037015410692956173 , 0.00233307631218880978 , & & - 0.01254988477182192210 , 0.05657061146827041994 , & & - 0.21379664776456006580 , 0.84270079294971486929 , & & 0.00000000000949905026 , - 0.00000000018310229805 , & & 0.00000000239463074000 , - 0.00000002721444369609 , & & 0.00000028045522331686 , - 0.00000261830022482897 , & & 0.00002195455056768781 , - 0.00016358986921372656 , & & 0.00107052153564110318 , - 0.00608284718113590151 , & & 0.02986978465246258244 , - 0.13055593046562267625 , & & 0.67493323603965504676 , 0.00000000000382722073 , & & - 0.00000000007421598602 , 0.00000000097930574080 , & & - 0.00000001126008898854 , 0.00000011775134830784 , & & - 0.00000111992758382650 , 0.00000962023443095201 , & & - 0.00007404402135070773 , 0.00050689993654144881 , & & - 0.00307553051439272889 , 0.01668977892553165586 , & & - 0.08548534594781312114 , 0.56909076642393639985 , & & 0.00000000000155296588 , - 0.00000000003032205868 , & & 0.00000000040424830707 , - 0.00000000471135111493 , & & 0.00000005011915876293 , - 0.00000048722516178974 , & & 0.00000430683284629395 , - 0.00003445026145385764 , & & 0.00024879276133931664 , - 0.00162940941748079288 , & & 0.00988786373932350462 , - 0.05962426839442303805 , & & 0.49766113250947636708 / ) real , parameter :: b ( 0 : 64 ) = ( / & & - 0.00000000029734388465 , 0.00000000269776334046 , & & - 0.00000000640788827665 , - 0.00000001667820132100 , & & - 0.00000021854388148686 , 0.00000266246030457984 , & & 0.00001612722157047886 , - 0.00025616361025506629 , & & 0.00015380842432375365 , 0.00815533022524927908 , & & - 0.01402283663896319337 , - 0.19746892495383021487 , & & 0.71511720328842845913 , - 0.00000000001951073787 , & & - 0.00000000032302692214 , 0.00000000522461866919 , & & 0.00000000342940918551 , - 0.00000035772874310272 , & & 0.00000019999935792654 , 0.00002687044575042908 , & & - 0.00011843240273775776 , - 0.00080991728956032271 , & & 0.00661062970502241174 , 0.00909530922354827295 , & & - 0.20160072778491013140 , 0.51169696718727644908 , & & 0.00000000003147682272 , - 0.00000000048465972408 , & & 0.00000000063675740242 , 0.00000003377623323271 , & & - 0.00000015451139637086 , - 0.00000203340624738438 , & & 0.00001947204525295057 , 0.00002854147231653228 , & & - 0.00101565063152200272 , 0.00271187003520095655 , & & 0.02328095035422810727 , - 0.16725021123116877197 , & & 0.32490054966649436974 , 0.00000000002319363370 , & & - 0.00000000006303206648 , - 0.00000000264888267434 , & & 0.00000002050708040581 , 0.00000011371857327578 , & & - 0.00000211211337219663 , 0.00000368797328322935 , & & 0.00009823686253424796 , - 0.00065860243990455368 , & & - 0.00075285814895230877 , 0.02585434424202960464 , & & - 0.11637092784486193258 , 0.18267336775296612024 , & & - 0.00000000000367789363 , 0.00000000020876046746 , & & - 0.00000000193319027226 , - 0.00000000435953392472 , & & 0.00000018006992266137 , - 0.00000078441223763969 , & & - 0.00000675407647949153 , 0.00008428418334440096 , & & - 0.00017604388937031815 , - 0.00239729611435071610 , & & 0.02064129023876022970 , - 0.06905562880005864105 , & & 0.09084526782065478489 / ) w = abs ( x ) if ( w < 2.2 ) then t = w * w k = int ( t ) t = t - k k = k * 13 y = (((((((((((( a ( k ) * t + a ( k + 1 )) * t + & & a ( k + 2 )) * t + a ( k + 3 )) * t + a ( k + 4 )) * t + & & a ( k + 5 )) * t + a ( k + 6 )) * t + a ( k + 7 )) * t + & & a ( k + 8 )) * t + a ( k + 9 )) * t + a ( k + 10 )) * t + & & a ( k + 11 )) * t + a ( k + 12 )) * w else if ( w < 6.9 ) then k = int ( w ) t = w - k k = 13 * ( k - 2 ) y = ((((((((((( b ( k ) * t + b ( k + 1 )) * t + & & b ( k + 2 )) * t + b ( k + 3 )) * t + b ( k + 4 )) * t + & & b ( k + 5 )) * t + b ( k + 6 )) * t + b ( k + 7 )) * t + & & b ( k + 8 )) * t + b ( k + 9 )) * t + b ( k + 10 )) * t + & & b ( k + 11 )) * t + b ( k + 12 ) y = y * y y = y * y y = y * y y = 1. - y * y else y = 1. end if if ( x < 0. ) y = - y erf_ext = y end function erf_ext !-------------------------------------------------------------------------! # elif SPFUNC == _SPNAG_ /* if SPFUNC != _SPLOCAL_ */ function j0 ( x ) real :: j0 real , intent ( in ) :: x # if NAG_PREC == _NAGDBLE_ real ( kind = nag_kind ), external :: s17aef ! bessel J0 double # elif NAG_PREC == _NAGSNGL_ real ( kind = nag_kind ), external :: s17aee ! bessel J0 single # endif /* NAG_PREC */ real ( kind = nag_kind ) :: xarg xarg = x # if NAG_PREC == _NAGDBLE_ j0 = s17aef ( xarg , ifail ) # elif NAG_PREC == _NAGSNGL_ j0 = s17aee ( xarg , ifail ) # endif /* NAG_PREC */ end function j0 function j1 ( x ) real :: j1 real , intent ( in ) :: x # if NAG_PREC == _NAGDBLE_ real ( kind = nag_kind ), external :: s17aff ! bessel J1 double # elif NAG_PREC == _NAGSNGL_ real ( kind = nag_kind ), external :: s17afe ! bessel J1 single # endif /* NAG_PREC */ real ( kind = nag_kind ) :: xarg xarg = x # if NAG_PREC == _NAGDBLE_ j1 = s17aff ( xarg , ifail ) # elif NAG_PREC == _NAGSNGL_ j1 = s17afe ( xarg , ifail ) # endif /* NAG_PREC */ if ( x == 0. ) then j1 = . 5 else j1 = j1 / x end if end function j1 function erf_ext ( x ) real :: erf_ext real , intent ( in ) :: x # if NAG_PREC == _NAGDBLE_ real ( kind = nag_kind ), external :: s15aef ! error function double # elif NAG_PREC == _NAGSNGL_ real ( kind = nag_kind ), external :: s15aee ! error function single # endif /* NAG_PREC */ real ( kind = nag_kind ) :: xarg xarg = x # if NAG_PREC == _NAGDBLE_ erf_ext = s15aef ( xarg , ifail ) # elif NAG_PREC == _NAGSNGL_ erf_ext = s15aee ( xarg , ifail ) # endif /* NAG_PREC */ end function erf_ext # else /* if SPFUNC != _SPLOCAL_ && SPFUNC != _SPNAG_*/ # if (FCOMPILER == _G95_ || FCOMPILER == _GFORTRAN_ \\ || FCOMPILER == _ PATHSCALE_ || FCOMPILER == _ INTEL_ ) # if FCOMPILER == _INTEL_ function sj0 ( x ) use ifport , only : besj0 # else elemental function sj0 ( x ) # endif real ( kind = kind_rs ), intent ( in ) :: x real ( kind = kind_rs ) :: sj0 sj0 = besj0 ( x ) end function sj0 # if FCOMPILER == _INTEL_ function dj0 ( x ) use ifport , only : dbesj0 # else elemental function dj0 ( x ) # endif real ( kind = kind_rd ), intent ( in ) :: x real ( kind = kind_rd ) :: dj0 dj0 = dbesj0 ( x ) end function dj0 # if FCOMPILER == _INTEL_ function sj1 ( x ) use ifport , only : besj1 # else elemental function sj1 ( x ) # endif real ( kind = kind_rs ), intent ( in ) :: x real ( kind = kind_rs ) :: sj1 if ( x == 0.0 ) then sj1 = 0.5 else sj1 = besj1 ( x ) / x end if end function sj1 # if FCOMPILER == _INTEL_ function dj1 ( x ) use ifport , only : dbesj1 # else elemental function dj1 ( x ) # endif real ( kind = kind_rd ), intent ( in ) :: x real ( kind = kind_rd ) :: dj1 if ( x == 0.0 ) then dj1 = 0.5 else dj1 = dbesj1 ( x ) / x end if end function dj1 # if FCOMPILER == _G95_ function erf_ext ( x ) real , intent ( in ) :: x real :: erf_ext erf_ext = erf ( x ) end function erf_ext # else /* if FCOMPILER != _G95_ */ # if FCOMPILER == _INTEL_ function serf_ext ( x ) # else elemental function serf_ext ( x ) # endif /* if FCOMPILER == _INTEL_ */ real ( kind = kind_rs ), intent ( in ) :: x real ( kind = kind_rs ) :: serf_ext serf_ext = erf ( x ) end function serf_ext # if FCOMPILER == _INTEL_ function derf_ext ( x ) # else elemental function derf_ext ( x ) # endif real ( kind = kind_rd ), intent ( in ) :: x real ( kind = kind_rd ) :: derf_ext derf_ext = derf ( x ) end function derf_ext # endif /* if FCOMPILER == _G95_ */ # elif FCOMPILER == _PGI_ /* if (FCOMPILER != one of _G95_, _GFORTRAN_, _INTEL_, _PATHSCALE_) */ elemental function j1 ( x ) real , intent ( in ) :: x real :: j1 interface besj1 elemental function besj1 ( x ) real ( kind = 4 ), intent ( in ) :: x real ( kind = 4 ) :: besj1 end function besj1 elemental function dbesj1 ( x ) real ( kind = 8 ), intent ( in ) :: x real ( kind = 8 ) :: dbesj1 end function dbesj1 end interface if ( x == 0.0 ) then j1 = 0.5 else j1 = besj1 ( x ) / x end if end function j1 # endif /* if FCOMPILER */ # endif /* if SPFUNC */ end module spfunc","tags":"","loc":"sourcefile/spfunc.fpp.html"},{"title":"gauss_quad.f90 â€“ stella","text":"Contents Modules gauss_quad Source Code gauss_quad.f90 Source Code module gauss_quad ! <doc> !  Utilities for Gaussian quadrature. !  This module provides subroutines to obtain zeros and weights of !  Gauss-Legendre and Gauss-Laguerre quadrature rules. ! </doc> implicit none public :: get_legendre_grids_from_cheb public :: get_laguerre_grids private logical :: debug = . false . logical :: weight_roundoff_correction = . false . integer , parameter :: qp = selected_real_kind ( 33 , 4931 ) contains subroutine get_legendre_grids_from_cheb ( x1 , x2 , zero , wgt ) ! <doc> !  returns Legendre zeros and weights in the given interval [x1,x2]. !  The order is determined from the size of the array 'zero'. ! </doc> use constants , only : pi => dpi real , intent ( in ) :: x1 , x2 real , dimension (:), intent ( out ) :: zero , wgt integer :: i , nn , nh double precision :: xold , xnew , pold , pnew double precision , dimension (:), allocatable :: zz , ww nn = size ( zero ) nh = ( nn + 1 ) / 2 allocate ( zz ( nh )) allocate ( ww ( nh )) ! search zero from 1 to 0 using chebyshev grid points ! this is O(nn&#94;2) operations xold = cos ( pi / ( 2 * ( nn + 1 ))) pold = legendre_p ( nn , xold ) do i = 1 , nh xnew = cos ( pi * ( 2 * i + 1 ) / ( 2 * ( nn + 1 ))) pnew = legendre_p ( nn , xnew ) call find_zero_bisect_newton ( nn , xold , xnew , pold , pnew , zz ( i )) xold = xnew pold = pnew end do ! invert them to give zeros in (-1,0] zz ( 1 : nn / 2 ) = - zz ( 1 : nn / 2 ) ! weight from formula !    ww = dble(2.0) / (dble(1.0) - zz**2) / legendre_pp(nn,zz,dble(0.0))**2 ww = dble ( 2.0 ) / ( dble ( 1.0 ) - zz ** 2 ) / legendre_pp ( nn , zz ) ** 2 ! rescale (x2 may be smaller than x1) zero ( 1 : nh ) = real ( zz * ( x2 - x1 ) + ( x1 + x2 )) / 2.0 zero ( nh + 1 : nn ) = real ( zz ( nn / 2 : 1 : - 1 ) * ( x1 - x2 ) + ( x1 + x2 )) / 2.0 wgt ( 1 : nh ) = real ( ww * abs ( x2 - x1 ) / 2.0 ) wgt ( nh + 1 : nn ) = wgt ( nn / 2 : 1 : - 1 ) deallocate ( zz ) deallocate ( ww ) ! roundoff correction !!$    if (abs(sum(wgt)/abs(x2-x1)) - 1.0 > epsilon(wgt)) then !!$       print *, 'roundoff correction occurred' if ( weight_roundoff_correction ) then if ( mod ( nn , 2 ) == 0 ) then wgt ( nh ) = abs ( x2 - x1 ) / 2.0 - sum ( wgt ( 1 : nh - 1 )) wgt ( nh + 1 ) = wgt ( nh ) else wgt ( nh ) = abs ( x2 - x1 ) - sum ( wgt ( 1 : nh - 1 )) * 2.0 end if end if call check_legendre_zero ( x1 , x2 , zero ) call check_legendre_weights ( abs ( x2 - x1 ), wgt ) if ( debug ) then print * , 'get_legendre_grids_from_cheb: sum of weights = ' , sum ( wgt ) print * , 'get_legendre_grids_from_cheb: section length = ' , abs ( x2 - x1 ) end if end subroutine get_legendre_grids_from_cheb subroutine find_zero_bisect_newton ( n , xold , xnew , pold , pnew , zz ) use file_utils , only : error_unit integer , intent ( in ) :: n double precision , intent ( in ) :: xold , xnew , pold , pnew !    real, intent (in) :: eps double precision , intent ( out ) :: zz integer :: i , maxit = 100 real :: eps double precision :: x1 , x2 , p1 , p2 , pz ! <doc> !  eps is declared as real on purpose. !  We don't require higher order precision for convergence test !  because of a performance reason. The following definition means !  eps is a geometric mean of the machine-epsilons in real and double !  precisions. !  (note that real/double are promoted to double/double or double/quad !  depending on the compiler.) ! !  [same applies to eps in find_zero below.] ! </doc> eps = sqrt ( epsilon ( eps ) * epsilon ( x1 )) * 2.0 i = 0 x1 = xold x2 = xnew p1 = pold p2 = pnew if ( debug ) write ( * , '(4f10.5)' ) x1 , p1 , x2 , p2 ! bisection do i = 1 , 5 zz = ( x1 + x2 ) * dble (. 5 ) pz = legendre_p ( n , zz ) if ( abs ( pz ) <= epsilon ( pz )) return if ( pz * p1 < 0.0 ) then p2 = pz ; x2 = zz else p1 = pz ; x1 = zz end if if ( debug ) write ( * , '(4f10.5)' ) x1 , p1 , x2 , p2 end do if ( debug ) print * , 'finished bisection' ! newton-raphson if ( zz == x1 ) x1 = x2 !    do while (abs(zz/x1-1.0) > eps) do i = 1 , maxit x1 = zz p1 = legendre_p ( n , x1 ) !       zz = x1 - p1 / legendre_pp(n,x1,p1) zz = x1 - p1 / legendre_pp ( n , x1 ) pz = legendre_p ( n , zz ) if ( debug ) write ( * , '(4f10.5)' ) zz , pz , x1 , p1 if ( min ( abs ( zz / x1 - 1.0 ), abs ( pz )) < eps ) exit end do if ( i == maxit + 1 ) write ( error_unit (), * ) & & 'WARNING: too many iterations in get_legendre_grids' if ( debug ) stop end subroutine find_zero_bisect_newton elemental function legendre_p ( n , x ) integer , intent ( in ) :: n double precision , intent ( in ) :: x integer :: k double precision :: p , p1 , p2 , legendre_p select case ( n ) case ( 0 ) legendre_p = dble ( 1.0 ) case ( 1 ) legendre_p = x case default p1 = x p2 = dble ( 1.0 ) do k = 2 , n p = (( 2 * k - 1 ) * x * p1 - ( k - 1 ) * p2 ) / k p2 = p1 p1 = p end do legendre_p = p end select end function legendre_p !  elemental function legendre_pp (n, x, p1) elemental function legendre_pp ( n , x ) integer , intent ( in ) :: n double precision , intent ( in ) :: x !    double precision, intent (in), optional :: p1 double precision :: legendre_pp !    if (present(p1)) then !       legendre_pp = n * ( x * p1 - legendre_p(n-1,x) ) & !            / (x**2 - dble(1.0)) !    else legendre_pp = n * ( x * legendre_p ( n , x ) - legendre_p ( n - 1 , x )) & / ( x ** 2 - dble ( 1.0 )) !    end if end function legendre_pp subroutine check_legendre_zero ( x0 , x1 , zero ) use mp , only : mp_abort use file_utils , only : error_unit real , intent ( in ) :: x0 , x1 real , dimension (:), intent ( in ) :: zero logical :: error = . false . integer :: nn , nh real :: xx , xmin , xmax real , dimension (:), allocatable :: zz nn = size ( zero ) nh = ( nn + 1 ) / 2 error = . false . xmin = min ( x0 , x1 ) xmax = max ( x0 , x1 ) allocate ( zz ( nn )) zz = zero if ( zz ( 1 ) > zz ( nn )) zz ( 1 : nn ) = zero ( nn : 1 : - 1 ) if ( zz ( 1 ) < xmin . or . zz ( nn ) > xmax ) then write ( error_unit (), * ) 'ERROR in legendre: grid out of range' error = . true . end if if ( nn == 1 ) then if ( abs ( 2.0 * zz ( 1 ) / ( xmin + xmax ) - 1.0 ) > epsilon ( 0.0 )) then write ( error_unit (), '(\"ERROR in legendre: zz(1)= \", f20.15)' ) zz ( 1 ) error = . true . end if else ! check if distances at the edge: This suffices for nn<=3 if ( zz ( 2 ) - zz ( 1 ) <= zz ( 1 ) - xmin . or . zz ( nn ) - zz ( nn - 1 ) <= xmax - zz ( nn )) then write ( error_unit (), * ) 'ERROR in legendre: wrong distance at edge' error = . true . end if ! check distances at the center: The above and this suffices for nn=4 if ( mod ( nn , 2 ) == 0 . and . nn >= 4 ) then if ( zz ( nh + 1 ) - zz ( nh ) <= zz ( nh ) - zz ( nh - 1 ) . or . & zz ( nh + 1 ) - zz ( nh ) <= zz ( nh + 2 ) - zz ( nh + 1 )) then write ( error_unit (), * ) & & 'ERROR in legendre: wrong distance at center' error = . true . end if end if if ( nn >= 5 ) then ! check if distances are increasing toward center ! lower half if ( any ( zz ( 3 : nh ) - zz ( 2 : nh - 1 ) <= zz ( 2 : nh - 1 ) - zz ( 1 : nh - 2 ))) then write ( error_unit (), * ) 'ERROR in legendre: distance decreasing toward center' error = . true . end if ! upper half ! The separate use of nh and nn/2 are intentionally so that they ! both work for even and odd cases if ( any ( zz ( nn / 2 + 2 : nn - 1 ) - zz ( nn / 2 + 1 : nn - 2 ) & & <= zz ( nn / 2 + 3 : nn ) - zz ( nn / 2 + 2 : nn - 1 ))) then write ( error_unit (), * ) 'ERROR in legendre: distance decreasing toward center' error = . true . end if end if end if ! check if legendre_p(n, zero(i)) are close enough to zero if ( debug ) then xx = maxval ( abs ( real ( legendre_p ( nn , & dble (( zz (:) - xmin ) / ( xmax - xmin ) * 2.0 - 1.0 ))))) if ( xx / nn ** 2 > epsilon ( xx )) then write ( error_unit (), * ) 'WARNING in legendre: maxval(n,zz(:))= ' , xx ! Do not stop as it is mostly a minor issue end if end if if ( error ) call mp_abort ( 'STOP in check_legendre_zero' ) end subroutine check_legendre_zero !  subroutine check_legendre_weights (norm, wgt, eps) subroutine check_legendre_weights ( norm , wgt ) use mp , only : mp_abort use file_utils , only : error_unit real , intent ( in ) :: norm !, eps real , dimension (:), intent ( in ) :: wgt logical :: error = . false . integer :: n , nh real :: s n = size ( wgt ) error = . false . nh = ( n + 1 ) / 2 ! check if weights are all positive if ( any ( wgt < 0. )) then write ( error_unit (), * ) 'ERROR in legendre: weights got negative' error = . true . end if if ( n >= 2 ) then ! check symmetry of weights if ( any ( abs ( wgt ( n : n + 1 - n / 2 : - 1 ) / wgt ( 1 : n / 2 ) - 1.0 ) > epsilon ( wgt ))) then write ( error_unit (), * ) 'WARNING in legendre: symmetry of weights broken' error = . true . end if ! check if weights are increasing toward center if ( n >= 3 ) then if ( any ( wgt ( 2 : nh ) <= wgt ( 1 : nh - 1 ))) then write ( error_unit (), * ) 'ERROR in legendre: weights decreasing toward center' error = . true . end if end if end if ! check if their sum is close enough to normalized value if ( debug ) then !       s = sum(wgt) s = sum ( dble ( wgt )) ! ignore roundoff error arising from 8-byte summation if ( abs ( norm / s - 1.0 ) > epsilon ( s )) then write ( error_unit (), * ) 'WARNING in legendre: weights summation incorrect:' , & & size ( wgt ), s / norm - 1.0 ! Do not stop as it is mostly a minor issue end if end if if ( error ) call mp_abort ( 'STOP in check_legendre_weights' ) end subroutine check_legendre_weights subroutine get_laguerre_grids ( zero , wgt ) ! <doc> !  returns Laguerre zeros and weights. !  The order is determined from the size of the array 'zero'. ! </doc> use mp , only : mp_abort use file_utils , only : error_unit real , dimension (:), intent ( out ) :: zero real , dimension (:), intent ( out ) :: wgt logical :: error = . false . integer :: i , j , n , nzero real ( kind = qp ) :: x , delx , pold , pnew !double precision, dimension (:), allocatable :: zz real ( kind = qp ), dimension (:), allocatable :: zz double precision :: eps n = size ( zero ) allocate ( zz ( n )) zz = 0.0 eps = epsilon ( zero ( 1 )) * dble ( 4.0 ) if ( n > 180 ) then write ( error_unit (), * ) 'ERROR: can''t get so many laguerre grid points' write ( error_unit (), * ) 'ERROR: size(zero)= ' , n error = . true . end if ! search zero from 0 to xmax using evenly spaced grid points if ( n == 1 ) then zero ( 1 ) = 1.0 wgt ( 1 ) = 1.0 return else nzero = 0 pold = real ( laguerre_l ( n , real ( 0.0 , qp )), qp ) delx = 0.001 do i = 1 , 1000 ! up to x=1 x = delx * i !          print*, x pnew = real ( laguerre_l ( n , x ), qp ) !          if (pold*pnew < epsilon(0.0)) then if ( pold * pnew < 0.0 ) then nzero = nzero + 1 call find_zero ( n , eps , x - delx , x , pold , pnew , zz ( nzero )) end if pold = pnew end do do j = 0 , 3 delx = delx * 1 0. do i = 1 , 900 x = delx * ( i + 100 ) !             print*, x pnew = laguerre_l ( n , x ) if ( pold * pnew < 0.0 ) then nzero = nzero + 1 call find_zero ( n , eps , x - delx , x , pold , pnew , zz ( nzero )) end if if ( nzero == n ) exit pold = pnew end do if ( nzero == n ) exit end do end if zero = real ( zz , kind ( zero ( 1 ))) wgt = real ( zz / ( n + 1 ) ** 2 / laguerre_l ( n + 1 , zz ) ** 2 , kind ( wgt ( 1 ))) deallocate ( zz ) ! roundoff correction if ( weight_roundoff_correction ) then i = sum ( maxloc ( wgt )) wgt ( i ) = 1.0 - sum ( wgt ( 1 : i - 1 )) - sum ( wgt ( i + 1 : n )) end if ! check number of found zeros if ( nzero < n ) then write ( error_unit (), * ) 'ERROR in laguerre: didn''t find all zeros' do i = 1 , n write ( error_unit (), * ) i , zero ( i ) end do stop end if call check_laguerre_zeros ( zero ) call check_laguerre_weights ( wgt , eps = 1.0e-7 ) if ( error ) call mp_abort ( 'STOP in get_laguerre_grids' ) end subroutine get_laguerre_grids subroutine find_zero ( n , eps , xold , xnew , pold , pnew , zz ) use file_utils , only : error_unit integer , intent ( in ) :: n double precision , intent ( in ) :: eps real ( kind = qp ), intent ( in ) :: xold , xnew , pold , pnew !double precision, intent (out) :: zz real ( kind = qp ), intent ( out ) :: zz integer :: i , maxit = 100 real ( kind = qp ) :: x1 , x2 , p1 , p2 , pz ! <doc> !  eps is declared as real on purpose. !  [see comment in find_zero_bisect_newton above.] ! </doc> x1 = xold x2 = xnew p1 = pold p2 = pnew if ( debug ) write ( * , '(a,4es15.5e3)' ) 'initial ' , x1 , p1 , x2 , p2 ! bisection do i = 1 , maxit zz = ( x1 + x2 ) * 0.5 pz = laguerre_l ( n , zz ) if ( abs ( pz ) <= eps ) return if ( pz * p1 < 0. ) then p2 = pz ; x2 = zz else p1 = pz ; x1 = zz end if if ( debug ) write ( * , '(a,6es25.15e3)' ) 'bisection ' , x1 , p1 , x2 , p2 , pz , eps end do if ( i == maxit + 1 ) then ! newton-raphson if ( zz == x1 ) x1 = x2 do i = 1 , maxit x1 = zz p1 = dble ( laguerre_l ( n , x1 )) zz = x1 - p1 / dble ( laguerre_lp ( n , x1 )) pz = dble ( laguerre_l ( n , zz )) if ( debug ) write ( * , '(a,5es25.15e3)' ) & 'newton ' , zz , pz , x1 , p1 , eps if ( min ( abs ( zz / x1 - dble ( 1.0 )), abs ( pz )) < eps ) exit end do if ( i == maxit + 1 ) then write ( error_unit (), * ) & & 'WARNING: too many iterations in get_laguerre_grids' stop 11 end if end if end subroutine find_zero elemental function laguerre_l ( n , x ) integer , intent ( in ) :: n real ( kind = qp ), intent ( in ) :: x integer :: k !    double precision :: laguerre_l, p, p1, p2 real ( kind = qp ) :: laguerre_l , p , p1 , p2 p1 = dble ( 1.0 ) - x p2 = dble ( 1.0 ) if ( n == 0 ) then laguerre_l = p2 return else if ( n == 1 ) then laguerre_l = p1 return end if do k = 2 , n p = (( dble ( 2.0 ) * k - dble ( 1.0 ) - x ) * p1 - ( k - dble ( 1.0 )) * p2 ) / k p2 = p1 p1 = p end do laguerre_l = p end function laguerre_l elemental function laguerre_lp ( n , x ) integer , intent ( in ) :: n real ( kind = qp ), intent ( in ) :: x real ( kind = qp ) :: laguerre_lp laguerre_lp = n * ( laguerre_l ( n , x ) - laguerre_l ( n - 1 , x )) / x end function laguerre_lp subroutine check_laguerre_zeros ( zero ) use file_utils , only : error_unit use mp , only : mp_abort real , dimension (:), intent ( in ) :: zero logical :: error = . false . integer :: i , n n = size ( zero ) ! check positiveness if ( any ( zero <= 0.0 )) then write ( error_unit (), * ) 'ERROR in laguerre: grid not positive' error = . true . end if ! check alignment if ( any ( zero ( 2 : n ) - zero ( 1 : n - 1 ) < 0.0 )) then write ( error_unit (), * ) 'ERROR in laguerre: wrong alignment' error = . true . end if ! check distances are increasing do i = 1 , n - 2 if ( zero ( i + 1 ) - zero ( i ) > zero ( i + 2 ) - zero ( i + 1 )) then write ( error_unit (), * ) 'ERROR in laguerre: distances are decreasing at i= ' , i error = . true . end if end do if ( error ) call mp_abort ( 'STOP in check_laguerre_zeros' ) end subroutine check_laguerre_zeros subroutine check_laguerre_weights ( wgt , eps ) use file_utils , only : error_unit use mp , only : mp_abort real , intent ( in ) :: eps real , dimension (:), intent ( in ) :: wgt logical :: error = . false . integer :: imax , n real :: s n = size ( wgt ) ! check if weights are all positive if ( any ( wgt <= 0.0 )) then write ( error_unit (), * ) 'ERROR in laguerre: weights are not positive at n =' , n error = . true . end if ! check if there is a single maximum imax = sum ( maxloc ( wgt )) if ( any ( wgt ( 1 : imax - 1 ) > wgt ( 2 : imax ))) then write ( error_unit (), * ) 'ERROR in laguerre: weights decreasing before maximum' error = . true . end if if ( any ( wgt ( imax : n - 1 ) < wgt ( imax + 1 : n ))) then write ( error_unit (), * ) 'ERROR in laguerre: weights increasing after maximum' error = . true . end if ! check if their sum is close enough to normalized value if ( debug ) then s = sum ( dble ( wgt )) if ( abs ( s - 1.0 ) > eps ) then write ( error_unit (), * ) 'WARNING in laguerre: weights summation incorrect:' , & size ( wgt ), s ! Do not stop as it is mostly a minor issue end if end if if ( error ) call mp_abort ( 'STOP error in check_laguerre_weights' ) end subroutine check_laguerre_weights end module gauss_quad","tags":"","loc":"sourcefile/gauss_quad.f90.html"},{"title":"constants.fpp â€“ stella","text":"Contents Modules constants Source Code constants.fpp Source Code # include \"define.inc\" module constants ! ! This module must not be compiled with a padding option ! such as -qautodbl=dbl of xlf which makes type conversion ! of variables even with explicit kind statements. ! implicit none !  public :: size_of public :: kind_is , kind_id , kind_rs , kind_rd public :: zi , pi , twopi , dpi , dtwopi # ifdef NAG_PREC public :: nag_kind # endif private ! Symbolic names for kind type of single and double-precision reals: ! (with at least 6 and 12 digits of accuracy) integer , parameter :: kind_i1 = selected_int_kind ( 2 ) integer , parameter :: kind_ih = selected_int_kind ( 4 ) integer , parameter :: kind_is = selected_int_kind ( 8 ) integer , parameter :: kind_id = selected_int_kind ( 15 ) integer , parameter :: kind_rs = selected_real_kind ( p = 6 ) integer , parameter :: kind_rd = selected_real_kind ( p = 12 ) ! There is a selected_real_kind bug in xlf and the following does not work integer , parameter :: kind_rq = selected_real_kind ( p = 24 ) !   integer, parameter :: sizeof_i1 = 1 !   integer, parameter :: sizeof_ih = 2 !   integer, parameter :: sizeof_is = 4 !   integer, parameter :: sizeof_id = 8 !   integer, parameter :: sizeof_rs = 4 !   integer, parameter :: sizeof_rd = 8 !   integer, parameter :: sizeof_rq = 16 !   integer, parameter :: sizeof_cs = 8 !   integer, parameter :: sizeof_cd = 16 !   integer, parameter :: sizeof_cq = 32 # if NAG_PREC == _NAGDBLE_ integer , parameter :: nag_kind = kind_rd # elif NAG_PREC == _NAGSNGL_ integer , parameter :: nag_kind = kind_rs # endif ! Symbolic names for kind type of single and double-precision complex: !  integer, parameter :: spc = kind((1.0_sp,1.0_sp)) !  integer, parameter :: dpc = kind((1.0_dp,1.0_dp)) !  complex(dp), parameter :: ii = (0._dp, 1._dp) !  real(dp), parameter :: pi=3.141592653589793238_dp complex , parameter :: zi = ( 0.0 , 1.0 ) !  real, parameter :: pi = 3.1415926535897931 !  real, parameter :: pi = 3.14159265358979323846, twopi=2.*pi ! this is actually quad precision double precision , parameter :: dpi = & 3.14159265358979323846264338327950288419716939938 , dtwopi = 2. * dpi real , parameter :: pi = dpi , twopi = dtwopi ! Note: we will use dp=\"double precision\" for almost everything. ! ! The fortran-90 \"kind\" types is kind of awkward.  But the old trick of ! using a \"-r8\" compiler switch to promote all real variables to 64 bits ! does not work on some fortran 90 compilers, and so the above use of ! the standard fortran-90 routine selected_real_kind is more portable. ! ! It may not be a good idea to mimic \"-r8\" by making sp to be identical ! to dp, or to write single and double-precision versions of ! generic subroutines, since on the Cray computers both single and ! \"double\" precision are 64 bits, and the compiler will complain that ! it cannot distinguish the two specific subroutines.  In some cases, ! the cray compiler may be able to distinguish between two real \"kinds\" ! for the purposes of distinguishing overloaded procedure names, ! even though the two real kinds map to the same precision (64 bits). ! ! If this ever does become a problem, then you may be able to get around it by ! commenting out the double precision function names from the list of ! overloaded procedures (i.e., the \"module procedure\" statements). ! !   interface size_of !      module procedure size_of_i1, size_of_ih, size_of_is, size_of_id !      module procedure size_of_rs, size_of_rd !      module procedure size_of_cs, size_of_cd ! !!$# ifdef QUAD ! !!$     module procedure size_of_rq, size_of_cq ! !!$# endif !   end interface contains !   integer function size_of_i1 (arg) !     integer (kind_i1) :: arg !     size_of_i1 = sizeof_i1 !   end function size_of_i1 !   integer function size_of_ih (arg) !     integer (kind_ih) :: arg !     size_of_ih = sizeof_ih !   end function size_of_ih !   integer function size_of_is (arg) !     integer (kind_is) :: arg !     size_of_is = sizeof_is !   end function size_of_is !   integer function size_of_id (arg) !     integer (kind_id) :: arg !     size_of_id = sizeof_id !   end function size_of_id !   integer function size_of_rs (arg) !     real (kind_rs) :: arg !     size_of_rs = sizeof_rs !   end function size_of_rs !   integer function size_of_rd (arg) !     real (kind_rd) :: arg !     size_of_rd = sizeof_rd !   end function size_of_rd ! !!$# ifdef QUAD ! !!$  integer function size_of_rq (arg) ! !!$    real (kind_rq) :: arg ! !!$    size_of_rq = sizeof_rq ! !!$  end function size_of_rq ! !!$# endif !   integer function size_of_cs (arg) !     complex (kind_rs) :: arg !     size_of_cs = sizeof_cs !   end function size_of_cs !   integer function size_of_cd (arg) !     complex (kind_rd) :: arg !     size_of_cd = sizeof_cd !   end function size_of_cd !!$# ifdef QUAD !!$  integer function size_of_cq (arg) !!$    complex (kind_rq) :: arg !!$    size_of_cq = sizeof_cq !!$  end function size_of_cq !!$# endif end module constants","tags":"","loc":"sourcefile/constants.fpp.html"},{"title":"command_line.fpp â€“ stella","text":"Contents Modules command_line Source Code command_line.fpp Source Code # include \"define.inc\" module command_line ! (c) Copyright 1991 to 1998 by Michael A. Beer, William D. Dorland, ! P. B. Snyder, Q. P. Liu, and Gregory W. Hammett. ALL RIGHTS RESERVED. ! ! <doc> !  A wrapper module for handling command line arguments. !  This module provides subroutine cl_getarg and integer function cl_iargc. !  Most of the compilers have getarg and iargc as their extensions. !  If not, one can use POSIX pxfgetarg and ipxfargc. ! !  Note that Fortran 2003 includes get_command_argument and !  command_argument_count which will replace getarg and iargc. ! </doc> implicit none private public :: cl_getarg , cl_iargc contains function cl_iargc () ! <doc> !  returns the number of arguments !  using intrinsic iargc or POSIX ipxfargc ! </doc> # ifdef POSIX # if FCOMPILER == _INTEL_ use ifposix , only : iargc => ipxfargc # endif # else # if FCOMPILER == _NAG_ use f90_unix , only : iargc # endif # endif implicit none integer :: cl_iargc # if ( POSIX == _NONE_ && FCOMPILER != _NAG_ ) integer :: iargc # endif cl_iargc = iargc () end function cl_iargc subroutine cl_getarg ( k , arg , len , ierr ) ! <doc> !  gets k-th argument string and its length !  using intrinsic getarg or POSIX pxfgetarg ! </doc> # ifdef POSIX use ifposix , only : pxfgetarg # else # if FCOMPILER == _NAG_ use f90_unix , only : getarg # endif # endif implicit none integer , intent ( in ) :: k character ( len =* ), intent ( out ) :: arg integer , intent ( out ) :: len integer , intent ( out ) :: ierr # ifdef POSIX call pxfgetarg ( k , arg , len , ierr ) # else call getarg ( k , arg ) len = len_trim ( arg ) ierr = 0 # endif end subroutine cl_getarg end module command_line","tags":"","loc":"sourcefile/command_line.fpp.html"},{"title":"mp_lu_decomposition.fpp â€“ stella","text":"Contents Modules mp_lu_decomposition Source Code mp_lu_decomposition.fpp Source Code module mp_lu_decomposition #if defined MPI && ISO_C_BINDING implicit none public :: lu_decomposition_local public :: lu_inverse_local public :: lu_matrix_multiply_local interface lu_decomposition_local !    module procedure lu_decomposition_local_real module procedure lu_decomposition_local_complex end interface interface lu_inverse_local !    module procedure lu_inverse_local_real module procedure lu_inverse_local_complex end interface interface lu_matrix_multiply_local !    module procedure lu_decomposition_local_real module procedure lu_matrix_multiply_local_complex end interface contains subroutine lu_decomposition_local_complex ( mp_comm , root , win , lu , idx , d ) use mpi implicit none integer , intent ( in ) :: win , mp_comm , root complex , dimension (:, :), intent ( in out ) :: lu integer , dimension (:), intent ( out ) :: idx real , intent ( out ) :: d real , parameter :: zero = 1.0e-20 real , dimension ( size ( lu , 1 )) :: vv complex , dimension ( size ( lu , 2 )) :: dum integer , dimension (:), allocatable :: row_limits integer :: i , j , k , n , imax , rdiv , rmod integer :: iproc , nproc , ierr real :: dmax , tmp n = size ( lu , 1 ) call mpi_comm_size ( mp_comm , nproc , ierr ) call mpi_comm_rank ( mp_comm , iproc , ierr ) allocate ( row_limits ( 0 : nproc )) d = 1.0 !the following is a loop to avoid copying entire matrix ! with (cabs(lu)) do i = 1 , n vv ( i ) = maxval ( cabs ( lu ( i , :))) end do if ( any ( vv == 0.0 )) & write ( * , * ) 'singular matrix in lu_decomposition on process ' , iproc vv = 1.0 / vv do j = 1 , n !divide up the work using row_limits rdiv = ( n - j ) / nproc rmod = mod ( n - j , nproc ) row_limits ( 0 ) = j + 1 if ( rdiv == 0 ) then row_limits ( rmod + 1 :) = - 1 do k = 1 , rmod row_limits ( k ) = row_limits ( k - 1 ) + 1 end do else do k = 1 , nproc row_limits ( k ) = row_limits ( k - 1 ) + rdiv if ( k <= rmod ) row_limits ( k ) = row_limits ( k ) + 1 end do end if !pivot if needed dmax = - 1.0 do k = j , n tmp = vv ( k ) * abs ( lu ( k , j )) if ( tmp > dmax ) then dmax = tmp imax = k end if end do if ( iproc == root ) then idx ( j ) = imax if ( j /= imax ) then dum = lu ( imax , :) lu ( imax , :) = lu ( j , :) lu ( j , :) = dum vv ( imax ) = vv ( j ) d = - d end if if ( lu ( j , j ) == 0.0 ) lu ( j , j ) = zero else if ( j /= imax ) vv ( imax ) = vv ( j ) end if call mpi_win_fence ( 0 , win , ierr ) !get the lead multiplier do i = row_limits ( iproc ), row_limits ( iproc + 1 ) - 1 lu ( i , j ) = lu ( i , j ) / lu ( j , j ) end do call mpi_win_fence ( 0 , win , ierr ) do k = row_limits ( iproc ), row_limits ( iproc + 1 ) - 1 do i = j + 1 , n lu ( i , k ) = lu ( i , k ) - lu ( i , j ) * lu ( j , k ) end do end do call mpi_win_fence ( 0 , win , ierr ) end do deallocate ( row_limits ) end subroutine lu_decomposition_local_complex subroutine lu_inverse_local_complex ( mp_comm , win , lu , idx , inverse ) use linear_solve , only : lu_back_substitution implicit none integer , intent ( in ) :: win , mp_comm complex , dimension (:, :), intent ( in ) :: lu integer , dimension (:), intent ( in ) :: idx complex , dimension (:, :), intent ( out ) :: inverse integer :: i , n , nproc , iproc , rdiv , rmod , ierr integer :: llim , ulim n = size ( lu , 1 ) call mpi_comm_size ( mp_comm , nproc , ierr ) call mpi_comm_rank ( mp_comm , iproc , ierr ) rdiv = n / nproc rmod = mod ( n , nproc ) llim = 1 + iproc * rdiv + min ( rmod , iproc ) ulim = ( iproc + 1 ) * rdiv + min ( rmod , iproc + 1 ) do i = llim , ulim inverse ( i , :) = 0 inverse ( i , i ) = 1.0 end do call mpi_win_fence ( 0 , win , ierr ) do i = llim , ulim call lu_back_substitution ( lu , idx , inverse (:, i )) end do call mpi_win_fence ( 0 , win , ierr ) end subroutine lu_inverse_local_complex subroutine lu_matrix_multiply_local_complex ( mp_comm , win , mat , b ) implicit none integer , intent ( in ) :: win , mp_comm complex , dimension (:, :), intent ( in ) :: mat complex , dimension (:), intent ( out ) :: b complex , dimension ( size ( b )) :: a integer :: i , n , nproc , iproc , rdiv , rmod integer :: llim , ulim , ierr n = size ( mat , 1 ) call mpi_comm_size ( mp_comm , nproc , ierr ) call mpi_comm_rank ( mp_comm , iproc , ierr ) rdiv = n / nproc rmod = mod ( n , nproc ) llim = 1 + iproc * rdiv + min ( rmod , iproc ) ulim = ( iproc + 1 ) * rdiv + min ( rmod , iproc + 1 ) do i = llim , ulim a ( i ) = sum ( mat ( i , :) * b (:)) end do call mpi_win_fence ( 0 , win , ierr ) do i = llim , ulim b ( i ) = a ( i ) end do call mpi_win_fence ( 0 , win , ierr ) end subroutine lu_matrix_multiply_local_complex #endif end module mp_lu_decomposition","tags":"","loc":"sourcefile/mp_lu_decomposition.fpp.html"},{"title":"mp.fpp â€“ stella","text":"Contents Modules mp Source Code mp.fpp Source Code # include \"define.inc\" module mp ! ! <doc> Easier Fortran90 interface to the MPI Message Passing Library. </doc> ! !     (c) Copyright 1991 to 1998 by Michael A. Beer, William D. Dorland, !     P. B. Snyder, Q. P. Liu, and Gregory W. Hammett. ALL RIGHTS RESERVED. ! ! Note: mp_mpi_r8.f90 is a version of mp_mpi.f90 to use when compiling ! with -r8 (where the default real type is taken to be 8 bytes).  Just ! replaced all occurances of MPI_REAL with MPI_DOUBLE_PRECISION and ! MPI_COMPLEX with MPI_DOUBLE_COMPLEX. ! # ifdef MPI # ifndef MPIINC use mpi #endif ! TT: I experienced a problem on Ranger with mvapich-devel. ! TT: Compiler complained an inconsistent variable type for reorder below. ! TT: In this case, the problem was solved by commenting out the above line ! TT: and use mpif.h below.  (4/16/08) # endif implicit none private public :: init_mp , finish_mp public :: broadcast , sum_reduce , sum_allreduce public :: broadcast_with_comm public :: max_reduce , max_allreduce public :: min_reduce , min_allreduce public :: comm_split , comm_free public :: nproc , iproc , proc0 , job , min_proc public :: send , ssend , receive public :: numnodes , inode public :: barrier public :: waitany public :: mp_abort public :: mpireal , mpicmplx , real_size , nbytes_real public :: sgproc0 ! MAB> needed by Trinity public :: scope , allprocs , sharedprocs , subprocs , crossdomprocs , sharedsubprocs , scrossdomprocs public :: comm_group , comm_sgroup public :: all_to_group , group_to_all public :: trin_flag ! <MAB public :: init_job_topology public :: mp_comm , curr_focus public :: mp_info public :: mp_gather # ifdef MPI # ifdef MPIINC ! CMR: defined MPIINC for machines where need to include mpif.h include 'mpif.h' #endif !comm_all      - every processor !comm_shared   - every processor on a node (shared memory) !comm_group    - every processor on a given job !comm_sgroup   - every processor on a node on a given job (shared memory) !comm_node     - communicator that links procs of same rank across comm_shared !comm_cross    - communicator that links procs of same rank across comm_group !comm_scross   - communicator that links procs of same rank across comm_sgroup integer , pointer :: nproc integer , target :: ntot_proc , nshared_proc , ngroup_proc , ndomain_proc integer , target :: nsgroup_proc , nscross_proc integer :: numnodes , inode integer , pointer :: iproc integer , target :: aproc , sproc , gproc , cproc , sgproc , scproc logical , pointer :: proc0 logical , target :: aproc0 , sproc0 , gproc0 , sgproc0 integer :: mpi_comm_world_private integer , pointer :: mp_comm integer , target :: comm_all , comm_shared , comm_node , comm_group , comm_cross integer , target :: comm_sgroup , comm_scross integer :: curr_focus integer , parameter :: mp_info = MPI_INFO_NULL integer :: job = 0 , min_proc integer ( kind ( MPI_REAL )) :: mpireal , mpicmplx integer ( kind = MPI_ADDRESS_KIND ) :: real_size # else integer , parameter :: nproc = 1 , iproc = 0 logical , parameter :: proc0 = . true . integer , parameter :: mp_info = - 1 integer , parameter :: job = 0 , mp_comm = - 1 integer :: mpireal , mpicmplx , real_size # endif integer , parameter :: allprocs = 0 , & sharedprocs = 1 , & subprocs = 2 , & crossdomprocs = 3 , & sharedsubprocs = 4 , & scrossdomprocs = 5 integer :: nbytes_real ! needed for Trinity -- MAB integer , dimension (:), allocatable :: grp0 logical :: trin_flag = . false . interface broadcast module procedure broadcast_integer module procedure broadcast_integer_array module procedure broadcast_real module procedure broadcast_real_array module procedure broadcast_real_2array module procedure broadcast_real_3array module procedure broadcast_real_4array module procedure broadcast_real_5array module procedure broadcast_complex module procedure broadcast_complex_array module procedure broadcast_complex_2array module procedure broadcast_complex_3array module procedure broadcast_complex_4array module procedure broadcast_logical module procedure broadcast_logical_array module procedure bcastfrom_integer module procedure bcastfrom_integer_array module procedure bcastfrom_real module procedure bcastfrom_real_array module procedure bcastfrom_complex module procedure bcastfrom_complex_array module procedure bcastfrom_complex_2array module procedure bcastfrom_logical module procedure bcastfrom_logical_array module procedure broadcast_character module procedure bcastfrom_character end interface interface sum_reduce module procedure sum_reduce_integer module procedure sum_reduce_integer_array module procedure sum_reduce_real module procedure sum_reduce_real_array module procedure sum_reduce_real_2array module procedure sum_reduce_real_3array module procedure sum_reduce_real_4array module procedure sum_reduce_real_5array module procedure sum_reduce_complex module procedure sum_reduce_complex_array module procedure sum_reduce_complex_2array module procedure sum_reduce_complex_3array module procedure sum_reduce_complex_4array module procedure sum_reduce_complex_5array end interface !KDN 100526: Allows summing into alternate variable !rather than overwriting local data !  interface sum_reduce_alt !     module procedure sum_reduce_alt_complex_3array !  end interface interface sum_allreduce module procedure sum_allreduce_integer module procedure sum_allreduce_integer_array module procedure sum_allreduce_integer_2array module procedure sum_allreduce_real module procedure sum_allreduce_real_array module procedure sum_allreduce_real_2array module procedure sum_allreduce_real_3array module procedure sum_allreduce_real_4array module procedure sum_allreduce_real_5array module procedure sum_allreduce_complex module procedure sum_allreduce_complex_array module procedure sum_allreduce_complex_2array module procedure sum_allreduce_complex_3array module procedure sum_allreduce_complex_4array module procedure sum_allreduce_complex_5array end interface interface max_reduce module procedure max_reduce_integer module procedure max_reduce_integer_array module procedure max_reduce_real module procedure max_reduce_real_array end interface interface max_allreduce module procedure max_allreduce_integer module procedure max_allreduce_integer_array module procedure max_allreduce_real module procedure max_allreduce_real_array end interface interface min_reduce module procedure min_reduce_integer module procedure min_reduce_integer_array module procedure min_reduce_real module procedure min_reduce_real_array end interface interface min_allreduce module procedure min_allreduce_integer module procedure min_allreduce_integer_array module procedure min_allreduce_real module procedure min_allreduce_real_array end interface interface send module procedure send_integer module procedure send_integer_array module procedure send_real module procedure send_real_array module procedure send_real_array_2d module procedure send_complex module procedure send_complex_array module procedure nonblocking_send_complex_array module procedure send_logical module procedure send_logical_array module procedure send_character end interface interface receive module procedure receive_integer module procedure receive_integer_array module procedure receive_real module procedure receive_real_array module procedure receive_real_array_2d module procedure receive_complex module procedure receive_complex_array module procedure receive_complex_2array module procedure nonblocking_receive_complex_array module procedure receive_logical module procedure receive_logical_array module procedure receive_character end interface ! MAB> needed for Trinity ! synchronous sends interface ssend module procedure ssend_integer module procedure ssend_integer_array module procedure ssend_real module procedure ssend_real_array module procedure ssend_complex module procedure ssend_complex_array module procedure ssend_complex_2array module procedure ssend_logical module procedure ssend_logical_array end interface ! send stuff from global proc0 to group proc0s interface all_to_group module procedure all_to_group_real module procedure all_to_group_real_array end interface ! send stuff from group proc0s to global proc0 interface group_to_all module procedure group_to_all_real module procedure group_to_all_real_array end interface ! <MAB contains subroutine init_mp ( comm_in ) # ifdef MPI use constants , only : pi , kind_rs , kind_rd use file_utils , only : error_unit implicit none # endif integer , intent ( in ), optional :: comm_in # ifdef MPI integer :: ierror logical :: init call mpi_initialized ( init , ierror ) if (. not . init ) call mpi_init ( ierror ) call mpi_comm_dup ( mpi_comm_world , mpi_comm_world_private , ierror ) if ( present ( comm_in )) then comm_all = comm_in else comm_all = mpi_comm_world_private end if call mpi_comm_size ( comm_all , ntot_proc , ierror ) call mpi_comm_rank ( comm_all , aproc , ierror ) aproc0 = aproc == 0 !the next communicator is between all cores on a given node (i.e. shared memory) call mpi_comm_split_type ( comm_all , mpi_comm_type_shared , aproc , mp_info , comm_shared , ierror ) call mpi_comm_size ( comm_shared , nshared_proc , ierror ) call mpi_comm_rank ( comm_shared , sproc , ierror ) sproc0 = sproc == 0 call mpi_comm_split ( comm_all , sproc , aproc , comm_node , ierror ) call mpi_comm_size ( comm_node , numnodes , ierror ) call mpi_comm_rank ( comm_node , inode , ierror ) !group communicator is global communicator unless changed by job fork comm_group = comm_all ngroup_proc = ntot_proc gproc = aproc gproc0 = aproc0 comm_sgroup = comm_shared nsgroup_proc = nshared_proc sgproc = sproc sgproc0 = sproc0 comm_scross = comm_node nscross_proc = numnodes scproc = inode call scope ( sharedprocs ) call broadcast ( inode ) call scope ( allprocs ) min_proc = nshared_proc call min_allreduce ( min_proc ) if (( kind ( pi ) == kind_rs ) . and . ( kind_rs /= kind_rd )) then mpireal = MPI_REAL mpicmplx = MPI_COMPLEX real_size = 4_MPI_ADDRESS_KIND nbytes_real = 4 else if ( kind ( pi ) == kind_rd ) then mpireal = MPI_DOUBLE_PRECISION mpicmplx = MPI_DOUBLE_COMPLEX real_size = 8_MPI_ADDRESS_KIND nbytes_real = 8 else write ( error_unit (), * ) 'ERROR: precision mismatch in mpi' end if # endif end subroutine init_mp subroutine scope ( focus ) integer , intent ( in ) :: focus # ifdef MPI if ( focus == allprocs ) then curr_focus = allprocs mp_comm => comm_all nproc => ntot_proc iproc => aproc proc0 => aproc0 else if ( focus == sharedprocs ) then curr_focus = sharedprocs mp_comm => comm_shared nproc => nshared_proc iproc => sproc proc0 => sproc0 else if ( focus == subprocs ) then curr_focus = subprocs mp_comm => comm_group nproc => ngroup_proc iproc => gproc proc0 => gproc0 else if ( focus == crossdomprocs ) then curr_focus = crossdomprocs mp_comm => comm_cross nproc => ndomain_proc iproc => cproc !DSO - 'proc0' in this subgroup is meaningless... be careful proc0 => null () else if ( focus == sharedsubprocs ) then curr_focus = sharedsubprocs mp_comm => comm_sgroup nproc => nsgroup_proc iproc => sgproc proc0 => sgproc0 else if ( focus == scrossdomprocs ) then curr_focus = scrossdomprocs mp_comm => comm_scross nproc => nscross_proc iproc => scproc proc0 => null () end if # endif end subroutine scope subroutine init_job_topology ( ncolumns , group0 , ierr ) implicit none # ifdef MPI !    integer, parameter :: reorder=1 ! TT: I changed variable definition by assuming integer 1 corresponds to ! TT: logical .true. but I am not sure if reorder is needed. ! TT: In any case this subroutine is only called when you use job fork. logical , parameter :: reorder = . true . integer :: ip , j , comm2d , id2d , ierr , nrows # endif integer , intent ( in ) :: ncolumns integer , dimension ( 0 :), intent ( out ) :: group0 # ifndef MPI integer :: ierr if ( ncolumns /= 1 ) call error ( \"jobs\" ) # else integer , parameter :: ndim = 2 integer , dimension ( ndim ) :: dims integer , dimension ( 0 : ndim - 1 ) :: coords1d , coords2d logical , dimension ( 0 : ndim - 1 ) :: belongs logical , dimension ( ndim ) :: period logical :: isroot if (. not . allocated ( grp0 )) allocate ( grp0 ( 0 : size ( group0 ) - 1 )) ! calculate dimensions  mpi processor grid will have and check that ! ncolumns*nrows = number of processes ! nrows is # of processors per job (or group) nrows = ntot_proc / ncolumns dims = ( / ncolumns , nrows / ) if ( ntot_proc /= ncolumns * nrows ) then ierr = 1 if ( aproc0 ) write ( * , * ) 'Number of processes must be divisible by number of groups' return end if ngroup_proc = nrows ndomain_proc = ncolumns ! create 2d cartesian topology for processes period = ( / . false ., . false . / ) !! no circular shift call mpi_cart_create ( comm_all , ndim , dims , period , reorder , comm2d , ierr ) call mpi_comm_rank ( comm2d , id2d , ierr ) call mpi_cart_coords ( comm2d , id2d , ndim , coords2d , ierr ) ! each processor knows which subgrid it is in from variable mpi_group job = coords2d ( 0 ) ! create 1d subgrids from 2d processor grid, variable belongs denotes ! whether processor grid is split by column or row ! this group denotes processors on a single flux tube in a multi-tube ! simulation (e.g. for Trinity) belongs ( 1 ) = . true . ! this dimension belongs to subgrid belongs ( 0 ) = . false . call mpi_cart_sub ( comm2d , belongs , comm_group , ierr ) call mpi_comm_rank ( comm_group , gproc , ierr ) call mpi_cart_coords ( comm_group , gproc , 1 , coords1d , ierr ) gproc0 = ( gproc == 0 ) ! this group denotes processor with different domains at shared ! vpa_mu_s coordinates, with the intended purpose to couple separate ! flux tubes radially belongs ( 1 ) = . false . ! this dimension belongs to subgrid belongs ( 0 ) = . true . call mpi_cart_sub ( comm2d , belongs , comm_cross , ierr ) call mpi_comm_rank ( comm_cross , cproc , ierr ) !call mpi_cart_coords(comm_cross, cproc, 1, crosscoords1d, ierr) if ( job /= cproc ) call mp_abort ( \"topology coordinates\" ) ! find root process of each 1d subgrid and place in array group0 indexed ! from 0 to subgrids-1 ! MAB> following two lines were incorrect !    j=1 !    group0(0) = 0 ! replace with j = 0 if ( proc0 . and . gproc0 ) then group0 ( 0 ) = 0 j = 1 end if ! <MAB do ip = 1 , ntot_proc - 1 if ( proc0 ) then call receive ( isroot , ip ) if ( isroot ) then group0 ( j ) = ip j = j + 1 end if else if ( ip == aproc ) then call send ( gproc0 , 0 ) end if call barrier end do !the next communicator is between all cores on a given node for a given job(i.e. shared memory) call mpi_comm_split_type ( comm_group , mpi_comm_type_shared , aproc , mp_info , comm_sgroup , ierr ) call mpi_comm_size ( comm_sgroup , nsgroup_proc , ierr ) call mpi_comm_rank ( comm_sgroup , sgproc , ierr ) sgproc0 = sgproc == 0 call mpi_comm_split ( comm_group , sgproc , gproc , comm_scross , ierr ) call mpi_comm_size ( comm_scross , nscross_proc , ierr ) call mpi_comm_rank ( comm_scross , scproc , ierr ) !let all processors have the group0 array call broadcast ( group0 ) grp0 = group0 ! TT> brought down here from init_job_name in file_utils.fpp call scope ( subprocs ) ! <TT !get the minimum number of procs on a node for a given job min_proc = nsgroup_proc call min_allreduce ( min_proc ) # endif end subroutine init_job_topology subroutine finish_mp # ifdef MPI implicit none integer :: ierror call mpi_finalize ( ierror ) # endif end subroutine finish_mp ! ************** broadcasts ***************************** subroutine broadcast_character ( char ) implicit none character ( * ), intent ( in out ) :: char # ifdef MPI integer :: ierror call mpi_bcast ( char , len ( char ), MPI_CHARACTER , 0 , mp_comm , ierror ) # endif end subroutine broadcast_character subroutine broadcast_integer ( i ) implicit none integer , intent ( in out ) :: i # ifdef MPI integer :: ierror call mpi_bcast ( i , 1 , MPI_INTEGER , 0 , mp_comm , ierror ) # endif end subroutine broadcast_integer subroutine broadcast_integer_array ( i ) implicit none integer , dimension (:), intent ( in out ) :: i # ifdef MPI integer :: ierror call mpi_bcast ( i , size ( i ), MPI_INTEGER , 0 , mp_comm , ierror ) # endif end subroutine broadcast_integer_array subroutine broadcast_real ( x ) implicit none real , intent ( in out ) :: x # ifdef MPI integer :: ierror call mpi_bcast ( x , 1 , mpireal , 0 , mp_comm , ierror ) # endif end subroutine broadcast_real subroutine broadcast_real_array ( x ) implicit none real , dimension (:), intent ( in out ) :: x # ifdef MPI integer :: ierror call mpi_bcast ( x , size ( x ), mpireal , 0 , mp_comm , ierror ) # endif end subroutine broadcast_real_array subroutine broadcast_real_2array ( x ) implicit none real , dimension (:, :), intent ( in out ) :: x # ifdef MPI integer :: ierror call mpi_bcast ( x , size ( x ), mpireal , 0 , mp_comm , ierror ) # endif end subroutine broadcast_real_2array subroutine broadcast_real_3array ( x ) implicit none real , dimension (:, :, :), intent ( in out ) :: x # ifdef MPI integer :: ierror call mpi_bcast ( x , size ( x ), mpireal , 0 , mp_comm , ierror ) # endif end subroutine broadcast_real_3array subroutine broadcast_real_4array ( x ) implicit none real , dimension (:, :, :, :), intent ( in out ) :: x # ifdef MPI integer :: ierror call mpi_bcast ( x , size ( x ), mpireal , 0 , mp_comm , ierror ) # endif end subroutine broadcast_real_4array subroutine broadcast_real_5array ( x ) implicit none real , dimension (:, :, :, :, :), intent ( in out ) :: x # ifdef MPI integer :: ierror call mpi_bcast ( x , size ( x ), mpireal , 0 , mp_comm , ierror ) # endif end subroutine broadcast_real_5array subroutine broadcast_complex ( z ) implicit none complex , intent ( in out ) :: z # ifdef MPI integer :: ierror call mpi_bcast ( z , 1 , mpicmplx , 0 , mp_comm , ierror ) # endif end subroutine broadcast_complex subroutine broadcast_complex_array ( z ) implicit none complex , dimension (:), intent ( in out ) :: z # ifdef MPI integer :: ierror call mpi_bcast ( z , size ( z ), mpicmplx , 0 , mp_comm , ierror ) # endif end subroutine broadcast_complex_array subroutine broadcast_complex_2array ( z ) implicit none complex , dimension (:, :), intent ( in out ) :: z # ifdef MPI integer :: ierror call mpi_bcast ( z , size ( z ), mpicmplx , 0 , mp_comm , ierror ) # endif end subroutine broadcast_complex_2array subroutine broadcast_complex_3array ( z ) implicit none complex , dimension (:, :, :), intent ( in out ) :: z # ifdef MPI integer :: ierror call mpi_bcast ( z , size ( z ), mpicmplx , 0 , mp_comm , ierror ) # endif end subroutine broadcast_complex_3array subroutine broadcast_complex_4array ( z ) implicit none complex , dimension (:, :, :, :), intent ( in out ) :: z # ifdef MPI integer :: ierror call mpi_bcast ( z , size ( z ), mpicmplx , 0 , mp_comm , ierror ) # endif end subroutine broadcast_complex_4array subroutine broadcast_logical ( f ) implicit none logical , intent ( in out ) :: f # ifdef MPI integer :: ierror call mpi_bcast ( f , 1 , MPI_LOGICAL , 0 , mp_comm , ierror ) # endif end subroutine broadcast_logical subroutine broadcast_logical_array ( f ) implicit none logical , dimension (:), intent ( in out ) :: f # ifdef MPI integer :: ierror call mpi_bcast ( f , size ( f ), MPI_LOGICAL , 0 , mp_comm , ierror ) # endif end subroutine broadcast_logical_array subroutine bcastfrom_logical ( f , src ) implicit none logical , intent ( in out ) :: f integer , intent ( in ) :: src # ifdef MPI integer :: ierror call mpi_bcast ( f , 1 , MPI_LOGICAL , src , mp_comm , ierror ) # else if ( src /= 0 ) call error ( \"broadcast from\" ) # endif end subroutine bcastfrom_logical subroutine bcastfrom_logical_array ( f , src ) implicit none logical , dimension (:), intent ( in out ) :: f integer , intent ( in ) :: src # ifdef MPI integer :: ierror call mpi_bcast ( f , size ( f ), MPI_LOGICAL , src , mp_comm , ierror ) # else if ( src /= 0 ) call error ( \"broadcast from\" ) # endif end subroutine bcastfrom_logical_array subroutine bcastfrom_character ( c , src ) implicit none character ( * ), intent ( in out ) :: c integer , intent ( in ) :: src # ifdef MPI integer :: ierror call mpi_bcast ( c , len ( c ), MPI_CHARACTER , src , mp_comm , ierror ) # else if ( src /= 0 ) call error ( \"broadcast from\" ) # endif end subroutine bcastfrom_character subroutine bcastfrom_integer ( i , src ) implicit none integer , intent ( in out ) :: i integer , intent ( in ) :: src # ifdef MPI integer :: ierror call mpi_bcast ( i , 1 , MPI_INTEGER , src , mp_comm , ierror ) # else if ( src /= 0 ) call error ( \"broadcast from\" ) # endif end subroutine bcastfrom_integer subroutine bcastfrom_integer_array ( i , src ) implicit none integer , dimension (:), intent ( in out ) :: i integer , intent ( in ) :: src # ifdef MPI integer :: ierror call mpi_bcast ( i , size ( i ), MPI_INTEGER , src , mp_comm , ierror ) # else if ( src /= 0 ) call error ( \"broadcast from\" ) # endif end subroutine bcastfrom_integer_array subroutine bcastfrom_real ( x , src ) implicit none real , intent ( in out ) :: x integer , intent ( in ) :: src # ifdef MPI integer :: ierror call mpi_bcast ( x , 1 , mpireal , src , mp_comm , ierror ) # else if ( src /= 0 ) call error ( \"broadcast from\" ) # endif end subroutine bcastfrom_real subroutine bcastfrom_real_array ( x , src ) implicit none real , dimension (:), intent ( in out ) :: x integer , intent ( in ) :: src # ifdef MPI integer :: ierror call mpi_bcast ( x , size ( x ), mpireal , src , mp_comm , ierror ) # else if ( src /= 0 ) call error ( \"broadcast from\" ) # endif end subroutine bcastfrom_real_array subroutine bcastfrom_complex ( z , src ) implicit none complex , intent ( in out ) :: z integer , intent ( in ) :: src # ifdef MPI integer :: ierror call mpi_bcast ( z , 1 , mpicmplx , src , mp_comm , ierror ) # else if ( src /= 0 ) call error ( \"broadcast from\" ) # endif end subroutine bcastfrom_complex subroutine bcastfrom_complex_array ( z , src ) implicit none complex , dimension (:), intent ( in out ) :: z integer , intent ( in ) :: src # ifdef MPI integer :: ierror call mpi_bcast ( z , size ( z ), mpicmplx , src , mp_comm , ierror ) # else if ( src /= 0 ) call error ( \"broadcast from\" ) # endif end subroutine bcastfrom_complex_array subroutine bcastfrom_complex_2array ( z , src ) implicit none complex , dimension (:, :), intent ( in out ) :: z integer , intent ( in ) :: src # ifdef MPI integer :: ierror call mpi_bcast ( z , size ( z ), mpicmplx , src , mp_comm , ierror ) # else if ( src /= 0 ) call error ( \"broadcast from\" ) # endif end subroutine bcastfrom_complex_2array ! ************** reductions *********************** subroutine sum_reduce_integer ( i , dest ) implicit none integer , intent ( in out ) :: i integer , intent ( in ) :: dest # ifdef MPI integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , i , 1 , MPI_INTEGER , MPI_SUM , dest , mp_comm , ierror ) else call mpi_reduce & ( i , i , 1 , MPI_INTEGER , MPI_SUM , dest , mp_comm , ierror ) end if # else if ( dest /= 0 ) call error ( \"reduce to\" ) # endif end subroutine sum_reduce_integer subroutine sum_reduce_integer_array ( i , dest ) implicit none integer , dimension (:), intent ( in out ) :: i integer , intent ( in ) :: dest # ifdef MPI integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , i , size ( i ), MPI_INTEGER , MPI_SUM , dest , mp_comm , ierror ) else call mpi_reduce & ( i , i , size ( i ), MPI_INTEGER , MPI_SUM , dest , mp_comm , ierror ) end if # else if ( dest /= 0 ) call error ( \"reduce to\" ) # endif end subroutine sum_reduce_integer_array !   subroutine sum_reduce_logical (a, dest) !     implicit none !     logical, intent (in out) :: a !     integer, intent (in) :: dest ! # ifdef MPI !     integer :: ierror !     if(iproc.eq.dest)then !        call mpi_reduce & !             (MPI_IN_PLACE, a, 1, MPI_LOGICAL, MPI_LOR, dest, mp_comm, ierror) !     else !        call mpi_reduce & !             (a, a, 1, MPI_LOGICAL, MPI_LOR, dest, mp_comm, ierror) !     endif ! # else !     if (dest /= 0) call error (\"reduce to\") ! # endif !   end subroutine sum_reduce_logical subroutine sum_reduce_real ( a , dest ) implicit none real , intent ( in out ) :: a integer , intent ( in ) :: dest # ifdef MPI integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , a , 1 , mpireal , MPI_SUM , dest , mp_comm , ierror ) else call mpi_reduce & ( a , a , 1 , mpireal , MPI_SUM , dest , mp_comm , ierror ) end if # else if ( dest /= 0 ) call error ( \"reduce to\" ) # endif end subroutine sum_reduce_real subroutine sum_reduce_real_array ( a , dest ) implicit none real , dimension (:), intent ( in out ) :: a integer , intent ( in ) :: dest # ifdef MPI integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , a , size ( a ), mpireal , MPI_SUM , dest , mp_comm , ierror ) else call mpi_reduce & ( a , a , size ( a ), mpireal , MPI_SUM , dest , mp_comm , ierror ) end if # else if ( dest /= 0 ) call error ( \"reduce to\" ) # endif end subroutine sum_reduce_real_array subroutine sum_reduce_real_2array ( a , dest ) implicit none real , dimension (:, :), intent ( in out ) :: a integer , intent ( in ) :: dest # ifdef MPI integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , a , size ( a ), mpireal , MPI_SUM , dest , mp_comm , ierror ) else call mpi_reduce & ( a , a , size ( a ), mpireal , MPI_SUM , dest , mp_comm , ierror ) end if # else if ( dest /= 0 ) call error ( \"reduce to\" ) # endif end subroutine sum_reduce_real_2array subroutine sum_reduce_real_3array ( a , dest ) implicit none real , dimension (:, :, :), intent ( in out ) :: a integer , intent ( in ) :: dest # ifdef MPI integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , a , size ( a ), mpireal , MPI_SUM , dest , mp_comm , ierror ) else call mpi_reduce & ( a , a , size ( a ), mpireal , MPI_SUM , dest , mp_comm , ierror ) end if # else if ( dest /= 0 ) call error ( \"reduce to\" ) # endif end subroutine sum_reduce_real_3array subroutine sum_reduce_real_4array ( a , dest ) implicit none real , dimension (:, :, :, :), intent ( in out ) :: a integer , intent ( in ) :: dest # ifdef MPI integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , a , size ( a ), mpireal , MPI_SUM , dest , mp_comm , ierror ) else call mpi_reduce & ( a , a , size ( a ), mpireal , MPI_SUM , dest , mp_comm , ierror ) end if # else if ( dest /= 0 ) call error ( \"reduce to\" ) # endif end subroutine sum_reduce_real_4array subroutine sum_reduce_real_5array ( a , dest ) implicit none real , dimension (:, :, :, :, :), intent ( in out ) :: a integer , intent ( in ) :: dest # ifdef MPI integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , a , size ( a ), mpireal , MPI_SUM , dest , mp_comm , ierror ) else call mpi_reduce & ( a , a , size ( a ), mpireal , MPI_SUM , dest , mp_comm , ierror ) end if # else if ( dest /= 0 ) call error ( \"reduce to\" ) # endif end subroutine sum_reduce_real_5array subroutine sum_reduce_complex ( z , dest ) implicit none complex , intent ( in out ) :: z integer , intent ( in ) :: dest # ifdef MPI integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , z , 1 , mpicmplx , MPI_SUM , dest , mp_comm , ierror ) else call mpi_reduce & ( z , z , 1 , mpicmplx , MPI_SUM , dest , mp_comm , ierror ) end if # else if ( dest /= 0 ) call error ( \"reduce to\" ) # endif end subroutine sum_reduce_complex subroutine sum_reduce_complex_array ( z , dest ) implicit none complex , dimension (:), intent ( in out ) :: z integer , intent ( in ) :: dest # ifdef MPI integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , z , size ( z ), mpicmplx , MPI_SUM , dest , mp_comm , ierror ) else call mpi_reduce & ( z , z , size ( z ), mpicmplx , MPI_SUM , dest , mp_comm , ierror ) end if # else if ( dest /= 0 ) call error ( \"reduce to\" ) # endif end subroutine sum_reduce_complex_array subroutine sum_reduce_complex_2array ( z , dest ) implicit none complex , dimension (:, :), intent ( in out ) :: z integer , intent ( in ) :: dest # ifdef MPI integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , z , size ( z ), mpicmplx , MPI_SUM , dest , mp_comm , ierror ) else call mpi_reduce & ( z , z , size ( z ), mpicmplx , MPI_SUM , dest , mp_comm , ierror ) end if # else if ( dest /= 0 ) call error ( \"reduce to\" ) # endif end subroutine sum_reduce_complex_2array subroutine sum_reduce_complex_3array ( z , dest ) implicit none complex , dimension (:, :, :), intent ( in out ) :: z integer , intent ( in ) :: dest # ifdef MPI integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , z , size ( z ), mpicmplx , MPI_SUM , dest , mp_comm , ierror ) else call mpi_reduce & ( z , z , size ( z ), mpicmplx , MPI_SUM , dest , mp_comm , ierror ) end if # else if ( dest /= 0 ) call error ( \"reduce to\" ) # endif end subroutine sum_reduce_complex_3array subroutine sum_reduce_complex_4array ( z , dest ) implicit none complex , dimension (:, :, :, :), intent ( in out ) :: z integer , intent ( in ) :: dest # ifdef MPI integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , z , size ( z ), mpicmplx , MPI_SUM , dest , mp_comm , ierror ) else call mpi_reduce & ( z , z , size ( z ), mpicmplx , MPI_SUM , dest , mp_comm , ierror ) end if # else if ( dest /= 0 ) call error ( \"reduce to\" ) # endif end subroutine sum_reduce_complex_4array subroutine sum_reduce_complex_5array ( z , dest ) implicit none complex , dimension (:, :, :, :, :), intent ( in out ) :: z integer , intent ( in ) :: dest # ifdef MPI integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , z , size ( z ), mpicmplx , MPI_SUM , dest , mp_comm , ierror ) else call mpi_reduce & ( z , z , size ( z ), mpicmplx , MPI_SUM , dest , mp_comm , ierror ) end if # else if ( dest /= 0 ) call error ( \"reduce to\" ) # endif end subroutine sum_reduce_complex_5array ! Sum all z1 values into z2 at dest !   subroutine sum_reduce_alt_complex_3array (z1,z2,dest) !     implicit none !     complex, dimension (:,:,:), intent (in out) :: z1 !     complex, dimension (:,:,:), intent (in out) :: z2 !     integer, intent (in) :: dest ! # ifdef MPI !     integer :: ierror !     call mpi_reduce & !          (z1, z2, size(z1), mpicmplx, MPI_SUM, dest, mp_comm, ierror) ! # else !     if (dest /= 0) call error (\"reduce to\") ! # endif !   end subroutine sum_reduce_alt_complex_3array subroutine sum_allreduce_integer ( i ) implicit none integer , intent ( in out ) :: i # ifdef MPI integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , i , 1 , MPI_INTEGER , MPI_SUM , mp_comm , ierror ) # endif end subroutine sum_allreduce_integer subroutine sum_allreduce_integer_array ( i ) implicit none integer , dimension (:), intent ( in out ) :: i # ifdef MPI integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , i , size ( i ), MPI_INTEGER , MPI_SUM , mp_comm , ierror ) # endif end subroutine sum_allreduce_integer_array subroutine sum_allreduce_integer_2array ( i ) implicit none integer , dimension (:, :), intent ( in out ) :: i # ifdef MPI integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , i , size ( i ), MPI_INTEGER , MPI_SUM , mp_comm , ierror ) # endif end subroutine sum_allreduce_integer_2array subroutine sum_allreduce_real ( a ) implicit none real , intent ( in out ) :: a # ifdef MPI integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , a , 1 , mpireal , MPI_SUM , mp_comm , ierror ) # endif end subroutine sum_allreduce_real subroutine sum_allreduce_real_array ( a ) implicit none real , dimension (:), intent ( in out ) :: a # ifdef MPI integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , a , size ( a ), mpireal , MPI_SUM , mp_comm , ierror ) # endif end subroutine sum_allreduce_real_array subroutine sum_allreduce_real_2array ( a ) implicit none real , dimension (:, :), intent ( in out ) :: a # ifdef MPI integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , a , size ( a ), mpireal , MPI_SUM , mp_comm , ierror ) # endif end subroutine sum_allreduce_real_2array subroutine sum_allreduce_real_3array ( a ) implicit none real , dimension (:, :, :), intent ( in out ) :: a # ifdef MPI integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , a , size ( a ), mpireal , MPI_SUM , mp_comm , ierror ) # endif end subroutine sum_allreduce_real_3array subroutine sum_allreduce_real_4array ( a ) implicit none real , dimension (:, :, :, :), intent ( in out ) :: a # ifdef MPI integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , a , size ( a ), mpireal , MPI_SUM , mp_comm , ierror ) # endif end subroutine sum_allreduce_real_4array subroutine sum_allreduce_real_5array ( a ) implicit none real , dimension (:, :, :, :, :), intent ( in out ) :: a # ifdef MPI integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , a , size ( a ), mpireal , MPI_SUM , mp_comm , ierror ) # endif end subroutine sum_allreduce_real_5array subroutine sum_allreduce_complex ( z ) implicit none complex , intent ( in out ) :: z # ifdef MPI integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , z , 1 , mpicmplx , MPI_SUM , mp_comm , ierror ) # endif end subroutine sum_allreduce_complex subroutine sum_allreduce_complex_array ( z ) implicit none complex , dimension (:), intent ( in out ) :: z # ifdef MPI integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , z , size ( z ), mpicmplx , MPI_SUM , mp_comm , ierror ) # endif end subroutine sum_allreduce_complex_array subroutine sum_allreduce_complex_2array ( z ) implicit none complex , dimension (:, :), intent ( in out ) :: z # ifdef MPI integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , z , size ( z ), mpicmplx , MPI_SUM , mp_comm , ierror ) # endif end subroutine sum_allreduce_complex_2array subroutine sum_allreduce_complex_3array ( z ) implicit none complex , dimension (:, :, :), intent ( in out ) :: z # ifdef MPI integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , z , size ( z ), mpicmplx , MPI_SUM , mp_comm , ierror ) # endif end subroutine sum_allreduce_complex_3array subroutine sum_allreduce_complex_4array ( z ) implicit none complex , dimension (:, :, :, :), intent ( in out ) :: z # ifdef MPI integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , z , size ( z ), mpicmplx , MPI_SUM , mp_comm , ierror ) # endif end subroutine sum_allreduce_complex_4array subroutine sum_allreduce_complex_5array ( z ) implicit none complex , dimension (:, :, :, :, :), intent ( in out ) :: z # ifdef MPI integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , z , size ( z ), mpicmplx , MPI_SUM , mp_comm , ierror ) # endif end subroutine sum_allreduce_complex_5array subroutine max_reduce_integer ( i , dest ) implicit none integer , intent ( in out ) :: i integer , intent ( in ) :: dest # ifdef MPI integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , i , 1 , MPI_INTEGER , MPI_MAX , dest , mp_comm , ierror ) else call mpi_reduce & ( i , i , 1 , MPI_INTEGER , MPI_MAX , dest , mp_comm , ierror ) end if # else if ( dest /= 0 ) call error ( \"reduce to\" ) # endif end subroutine max_reduce_integer subroutine max_reduce_integer_array ( i , dest ) implicit none integer , dimension (:), intent ( in out ) :: i integer , intent ( in ) :: dest # ifdef MPI integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , i , size ( i ), MPI_INTEGER , MPI_MAX , dest , mp_comm , ierror ) else call mpi_reduce & ( i , i , size ( i ), MPI_INTEGER , MPI_MAX , dest , mp_comm , ierror ) end if # else if ( dest /= 0 ) call error ( \"reduce to\" ) # endif end subroutine max_reduce_integer_array subroutine max_reduce_real ( a , dest ) implicit none real , intent ( in out ) :: a integer , intent ( in ) :: dest # ifdef MPI integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , a , 1 , mpireal , MPI_MAX , dest , mp_comm , ierror ) else call mpi_reduce & ( a , a , 1 , mpireal , MPI_MAX , dest , mp_comm , ierror ) end if # else if ( dest /= 0 ) call error ( \"reduce to\" ) # endif end subroutine max_reduce_real subroutine max_reduce_real_array ( a , dest ) implicit none real , dimension (:), intent ( in out ) :: a integer , intent ( in ) :: dest # ifdef MPI integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , a , size ( a ), mpireal , MPI_MAX , dest , mp_comm , ierror ) else call mpi_reduce & ( a , a , size ( a ), mpireal , MPI_MAX , dest , mp_comm , ierror ) end if # else if ( dest /= 0 ) call error ( \"reduce to\" ) # endif end subroutine max_reduce_real_array subroutine max_allreduce_integer ( i ) implicit none integer , intent ( in out ) :: i # ifdef MPI integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , i , 1 , MPI_INTEGER , MPI_MAX , mp_comm , ierror ) # endif end subroutine max_allreduce_integer subroutine max_allreduce_integer_array ( i ) implicit none integer , dimension (:), intent ( in out ) :: i # ifdef MPI integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , i , size ( i ), MPI_INTEGER , MPI_MAX , mp_comm , ierror ) # endif end subroutine max_allreduce_integer_array subroutine max_allreduce_real ( a ) implicit none real , intent ( in out ) :: a # ifdef MPI integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , a , 1 , mpireal , MPI_MAX , mp_comm , ierror ) # endif end subroutine max_allreduce_real subroutine max_allreduce_real_array ( a ) implicit none real , dimension (:), intent ( in out ) :: a # ifdef MPI integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , a , size ( a ), mpireal , MPI_MAX , mp_comm , ierror ) # endif end subroutine max_allreduce_real_array subroutine min_reduce_integer ( i , dest ) implicit none integer , intent ( in out ) :: i integer , intent ( in ) :: dest # ifdef MPI integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , i , 1 , MPI_INTEGER , MPI_MIN , dest , mp_comm , ierror ) else call mpi_reduce & ( i , i , 1 , MPI_INTEGER , MPI_MIN , dest , mp_comm , ierror ) end if # else if ( dest /= 0 ) call error ( \"reduce to\" ) # endif end subroutine min_reduce_integer subroutine min_reduce_integer_array ( i , dest ) implicit none integer , dimension (:), intent ( in out ) :: i integer , intent ( in ) :: dest # ifdef MPI integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , i , size ( i ), MPI_INTEGER , MPI_MIN , dest , mp_comm , ierror ) else call mpi_reduce & ( i , i , size ( i ), MPI_INTEGER , MPI_MIN , dest , mp_comm , ierror ) end if # else if ( dest /= 0 ) call error ( \"reduce to\" ) # endif end subroutine min_reduce_integer_array subroutine min_reduce_real ( a , dest ) implicit none real , intent ( in out ) :: a integer , intent ( in ) :: dest # ifdef MPI integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , a , 1 , mpireal , MPI_MIN , dest , mp_comm , ierror ) else call mpi_reduce & ( a , a , 1 , mpireal , MPI_MIN , dest , mp_comm , ierror ) end if # else if ( dest /= 0 ) call error ( \"reduce to\" ) # endif end subroutine min_reduce_real subroutine min_reduce_real_array ( a , dest ) implicit none real , dimension (:), intent ( in out ) :: a integer , intent ( in ) :: dest # ifdef MPI integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , a , size ( a ), mpireal , MPI_MIN , dest , mp_comm , ierror ) else call mpi_reduce & ( a , a , size ( a ), mpireal , MPI_MIN , dest , mp_comm , ierror ) end if # else if ( dest /= 0 ) call error ( \"reduce to\" ) # endif end subroutine min_reduce_real_array subroutine min_allreduce_integer ( i ) implicit none integer , intent ( in out ) :: i # ifdef MPI integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , i , 1 , MPI_INTEGER , MPI_MIN , mp_comm , ierror ) # endif end subroutine min_allreduce_integer subroutine min_allreduce_integer_array ( i ) implicit none integer , dimension (:), intent ( in out ) :: i # ifdef MPI integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , i , size ( i ), MPI_INTEGER , MPI_MIN , mp_comm , ierror ) # endif end subroutine min_allreduce_integer_array subroutine min_allreduce_real ( a ) implicit none real , intent ( in out ) :: a # ifdef MPI integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , a , 1 , mpireal , MPI_MIN , mp_comm , ierror ) # endif end subroutine min_allreduce_real subroutine min_allreduce_real_array ( a ) implicit none real , dimension (:), intent ( in out ) :: a # ifdef MPI integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , a , size ( a ), mpireal , MPI_MIN , mp_comm , ierror ) # endif end subroutine min_allreduce_real_array subroutine comm_split ( color , comm_out , ierr ) implicit none integer , intent ( in ) :: color integer , intent ( out ) :: comm_out , ierr # ifdef MPI call mpi_comm_split ( mp_comm , color , iproc , comm_out , ierr ) #endif end subroutine comm_split subroutine comm_free ( comm_in , ierr ) implicit none integer , intent ( in ) :: comm_in integer , intent ( out ) :: ierr # ifdef MPI ! this seemingly unnecessary complication appears to be needed ! for compiling with open-mpi and gfortran on macosx integer , pointer :: comm_local integer , target :: comm_target comm_target = comm_in comm_local => comm_target call mpi_comm_free ( comm_local , ierr ) # endif end subroutine comm_free ! ********************* barrier ********************** subroutine barrier # ifdef MPI implicit none integer :: ierror call mpi_barrier ( mp_comm , ierror ) # endif end subroutine barrier ! ********************* sends ********************** subroutine send_integer ( i , dest , tag ) implicit none integer , intent ( in ) :: i integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag # ifdef MPI integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_send ( i , 1 , MPI_INTEGER , dest , tagp , mp_comm , ierror ) # else call error ( \"send\" ) # endif end subroutine send_integer subroutine send_integer_array ( i , dest , tag ) implicit none integer , dimension (:), intent ( in ) :: i integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag # ifdef MPI integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_send ( i , size ( i ), MPI_INTEGER , dest , tagp , mp_comm , ierror ) # else call error ( \"send\" ) # endif end subroutine send_integer_array subroutine send_real ( a , dest , tag ) implicit none real , intent ( in ) :: a integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag # ifdef MPI integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_send ( a , 1 , mpireal , dest , tagp , mp_comm , ierror ) # else call error ( \"send\" ) # endif end subroutine send_real subroutine send_real_array ( a , dest , tag ) implicit none real , dimension (:), intent ( in ) :: a integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag # ifdef MPI integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_send ( a , size ( a ), mpireal , dest , tagp , mp_comm , ierror ) # else call error ( \"send\" ) # endif end subroutine send_real_array subroutine send_real_array_2d ( a , dest , tag ) implicit none real , dimension (:, :), intent ( in ) :: a integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag # ifdef MPI integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_send ( a , size ( a ), mpireal , dest , tagp , mp_comm , ierror ) # else call error ( \"send\" ) # endif end subroutine send_real_array_2d subroutine send_complex ( z , dest , tag ) implicit none complex , intent ( in ) :: z integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag # ifdef MPI integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_send ( z , 1 , mpicmplx , dest , tagp , mp_comm , ierror ) # else call error ( \"send\" ) # endif end subroutine send_complex subroutine send_complex_array ( z , dest , tag ) implicit none complex , dimension (:), intent ( in ) :: z integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag # ifdef MPI integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_send ( z , size ( z ), mpicmplx , dest , tagp , mp_comm , ierror ) # else call error ( \"send\" ) # endif end subroutine send_complex_array subroutine nonblocking_send_complex_array ( z , dest , tag , request ) implicit none complex , dimension (:), intent ( in ) :: z integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag integer , intent ( out ) :: request # ifdef MPI integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_isend ( z , size ( z ), mpicmplx , dest , tagp , mp_comm , request , ierror ) # else call error ( \"send\" ) # endif end subroutine nonblocking_send_complex_array subroutine send_logical ( f , dest , tag ) implicit none logical , intent ( in ) :: f integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag # ifdef MPI integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_send ( f , 1 , MPI_LOGICAL , dest , tagp , mp_comm , ierror ) # else call error ( \"send\" ) # endif end subroutine send_logical subroutine send_logical_array ( f , dest , tag ) implicit none logical , dimension (:), intent ( in ) :: f integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag # ifdef MPI integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_send ( f , size ( f ), MPI_LOGICAL , dest , tagp , mp_comm , ierror ) # else call error ( \"send\" ) # endif end subroutine send_logical_array subroutine send_character ( s , dest , tag ) implicit none character ( * ), intent ( in ) :: s integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag # ifdef MPI integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_send & ( s , len ( s ), MPI_CHARACTER , dest , tagp , mp_comm , ierror ) # else call error ( \"send\" ) # endif end subroutine send_character ! MAB> needed for Trinity ! ********************* synchronous sends ********************** subroutine ssend_integer ( i , dest , tag ) implicit none integer , intent ( in ) :: i integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag # ifdef MPI integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_ssend ( i , 1 , MPI_INTEGER , dest , tagp , mp_comm , ierror ) # else call error ( \"send\" ) # endif end subroutine ssend_integer subroutine ssend_integer_array ( i , dest , tag ) implicit none integer , dimension (:), intent ( in ) :: i integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag # ifdef MPI integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_ssend ( i , size ( i ), MPI_INTEGER , dest , tagp , mp_comm , ierror ) # else call error ( \"send\" ) # endif end subroutine ssend_integer_array subroutine ssend_real ( a , dest , tag ) implicit none real , intent ( in ) :: a integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag # ifdef MPI integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_ssend ( a , 1 , MPI_DOUBLE_PRECISION , dest , tagp , mp_comm , ierror ) # else call error ( \"send\" ) # endif end subroutine ssend_real subroutine ssend_real_array ( a , dest , tag ) implicit none real , dimension (:), intent ( in ) :: a integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag # ifdef MPI integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_ssend ( a , size ( a ), MPI_DOUBLE_PRECISION , dest , tagp , mp_comm , ierror ) # else call error ( \"send\" ) # endif end subroutine ssend_real_array subroutine ssend_complex ( z , dest , tag ) implicit none complex , intent ( in ) :: z integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag # ifdef MPI integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_ssend ( z , 1 , MPI_DOUBLE_COMPLEX , dest , tagp , mp_comm , ierror ) # else call error ( \"send\" ) # endif end subroutine ssend_complex subroutine ssend_complex_array ( z , dest , tag ) implicit none complex , dimension (:), intent ( in ) :: z integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag # ifdef MPI integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_ssend ( z , size ( z ), MPI_DOUBLE_COMPLEX , dest , tagp , mp_comm , ierror ) # else call error ( \"send\" ) # endif end subroutine ssend_complex_array subroutine ssend_complex_2array ( z , dest , tag ) implicit none complex , dimension (:, :), intent ( in ) :: z integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag # ifdef MPI integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_ssend ( z , size ( z ), MPI_DOUBLE_COMPLEX , dest , tagp , mp_comm , ierror ) # else call error ( \"send\" ) # endif end subroutine ssend_complex_2array subroutine ssend_logical ( f , dest , tag ) implicit none logical , intent ( in ) :: f integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag # ifdef MPI integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_ssend ( f , 1 , MPI_LOGICAL , dest , tagp , mp_comm , ierror ) # else call error ( \"send\" ) # endif end subroutine ssend_logical subroutine ssend_logical_array ( f , dest , tag ) implicit none logical , dimension (:), intent ( in ) :: f integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag # ifdef MPI integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_ssend ( f , size ( f ), MPI_LOGICAL , dest , tagp , mp_comm , ierror ) # else call error ( \"send\" ) # endif end subroutine ssend_logical_array !   subroutine ssend_character (s, dest, tag) !     implicit none !     character(*), intent (in) :: s !     integer, intent (in) :: dest !     integer, intent (in), optional :: tag ! # ifdef MPI !     integer :: ierror !     integer :: tagp !     tagp = 0 !     if (present(tag)) tagp = tag !     call mpi_ssend & !          (s, len(s), MPI_CHARACTER, dest, tagp, mp_comm, ierror) ! # else !     call error (\"send\") ! # endif !   end subroutine ssend_character ! <MAB ! ********************* receives  ********************** subroutine receive_integer ( i , src , tag ) implicit none # ifdef MPI integer , intent ( out ) :: i # else integer :: i # endif integer , intent ( in ) :: src integer , intent ( in ), optional :: tag # ifdef MPI integer :: ierror integer :: tagp integer , dimension ( MPI_STATUS_SIZE ) :: status tagp = 0 if ( present ( tag )) tagp = tag call mpi_recv ( i , 1 , MPI_INTEGER , src , tagp , mp_comm , & status , ierror ) # else call error ( \"receive\" ) # endif end subroutine receive_integer subroutine receive_integer_array ( i , src , tag ) implicit none # ifdef MPI integer , dimension (:), intent ( out ) :: i # else integer , dimension (:) :: i # endif integer , intent ( in ) :: src integer , intent ( in ), optional :: tag # ifdef MPI integer :: ierror integer :: tagp integer , dimension ( MPI_STATUS_SIZE ) :: status tagp = 0 if ( present ( tag )) tagp = tag call mpi_recv ( i , size ( i ), MPI_INTEGER , src , tagp , mp_comm , & status , ierror ) # else call error ( \"receive\" ) # endif end subroutine receive_integer_array subroutine receive_real ( a , src , tag ) implicit none # ifdef MPI real , intent ( out ) :: a # else real :: a # endif integer , intent ( in ) :: src integer , intent ( in ), optional :: tag # ifdef MPI integer :: ierror integer :: tagp integer , dimension ( MPI_STATUS_SIZE ) :: status tagp = 0 if ( present ( tag )) tagp = tag call mpi_recv ( a , 1 , mpireal , src , tagp , mp_comm , & status , ierror ) # else call error ( \"receive\" ) # endif end subroutine receive_real subroutine receive_real_array ( a , src , tag ) implicit none # ifdef MPI real , dimension (:), intent ( out ) :: a # else real , dimension (:) :: a # endif integer , intent ( in ) :: src integer , intent ( in ), optional :: tag # ifdef MPI integer :: ierror integer :: tagp integer , dimension ( MPI_STATUS_SIZE ) :: status tagp = 0 if ( present ( tag )) tagp = tag call mpi_recv ( a , size ( a ), mpireal , src , tagp , mp_comm , & status , ierror ) # else call error ( \"receive\" ) # endif end subroutine receive_real_array subroutine receive_real_array_2d ( a , src , tag ) implicit none # ifdef MPI real , dimension (:, :), intent ( out ) :: a # else real , dimension (:, :) :: a # endif integer , intent ( in ) :: src integer , intent ( in ), optional :: tag # ifdef MPI integer :: ierror integer :: tagp integer , dimension ( MPI_STATUS_SIZE ) :: status tagp = 0 if ( present ( tag )) tagp = tag call mpi_recv ( a , size ( a ), mpireal , src , tagp , mp_comm , & status , ierror ) # else call error ( \"receive\" ) # endif end subroutine receive_real_array_2d subroutine receive_complex ( z , src , tag ) implicit none # ifdef MPI complex , intent ( out ) :: z # else complex :: z # endif integer , intent ( in ) :: src integer , intent ( in ), optional :: tag # ifdef MPI integer :: ierror integer :: tagp integer , dimension ( MPI_STATUS_SIZE ) :: status tagp = 0 if ( present ( tag )) tagp = tag call mpi_recv ( z , 1 , mpicmplx , src , tagp , mp_comm , & status , ierror ) # else call error ( \"receive\" ) # endif end subroutine receive_complex subroutine receive_complex_array ( z , src , tag ) implicit none # ifdef MPI complex , dimension (:), intent ( out ) :: z # else complex , dimension (:) :: z # endif integer , intent ( in ) :: src integer , intent ( in ), optional :: tag # ifdef MPI integer :: ierror integer :: tagp integer , dimension ( MPI_STATUS_SIZE ) :: status tagp = 0 if ( present ( tag )) tagp = tag call mpi_recv ( z , size ( z ), mpicmplx , src , tagp , mp_comm , & status , ierror ) # else call error ( \"receive\" ) # endif end subroutine receive_complex_array subroutine receive_complex_2array ( z , src , tag ) implicit none # ifdef MPI complex , dimension (:, :), intent ( out ) :: z # else complex , dimension (:, :) :: z # endif integer , intent ( in ) :: src integer , intent ( in ), optional :: tag # ifdef MPI integer :: ierror integer :: tagp integer , dimension ( MPI_STATUS_SIZE ) :: status tagp = 0 if ( present ( tag )) tagp = tag call mpi_recv ( z , size ( z ), mpicmplx , src , tagp , mp_comm , & status , ierror ) # else call error ( \"receive\" ) # endif end subroutine receive_complex_2array subroutine nonblocking_receive_complex_array ( z , src , tag , request ) implicit none # ifdef MPI complex , dimension (:), intent ( inout ) :: z # else complex , dimension (:) :: z # endif integer , intent ( in ) :: src integer , intent ( in ), optional :: tag integer , intent ( out ) :: request # ifdef MPI integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_irecv ( z , size ( z ), mpicmplx , src , tagp , mp_comm , & request , ierror ) # else call error ( \"receive\" ) # endif end subroutine nonblocking_receive_complex_array subroutine receive_logical ( f , src , tag ) implicit none # ifdef MPI logical , intent ( out ) :: f # else logical :: f # endif integer , intent ( in ) :: src integer , intent ( in ), optional :: tag # ifdef MPI integer :: ierror integer :: tagp integer , dimension ( MPI_STATUS_SIZE ) :: status tagp = 0 if ( present ( tag )) tagp = tag call mpi_recv ( f , 1 , MPI_LOGICAL , src , tagp , mp_comm , & status , ierror ) # else call error ( \"receive\" ) # endif end subroutine receive_logical subroutine receive_logical_array ( f , src , tag ) implicit none # ifdef MPI logical , dimension (:), intent ( out ) :: f # else logical , dimension (:) :: f # endif integer , intent ( in ) :: src integer , intent ( in ), optional :: tag # ifdef MPI integer :: ierror integer :: tagp integer , dimension ( MPI_STATUS_SIZE ) :: status tagp = 0 if ( present ( tag )) tagp = tag call mpi_recv ( f , size ( f ), MPI_LOGICAL , src , tagp , mp_comm , & status , ierror ) # else call error ( \"receive\" ) # endif end subroutine receive_logical_array subroutine receive_character ( s , src , tag ) implicit none # ifdef MPI character ( * ), intent ( out ) :: s # else character ( * ) :: s # endif integer , intent ( in ) :: src integer , intent ( in ), optional :: tag # ifdef MPI integer :: ierror integer :: tagp integer , dimension ( MPI_STATUS_SIZE ) :: status tagp = 0 if ( present ( tag )) tagp = tag call mpi_recv ( s , len ( s ), MPI_CHARACTER , src , tagp , mp_comm , & status , ierror ) # else call error ( \"receive\" ) # endif end subroutine receive_character subroutine waitany ( count , requests , requestindex , status ) implicit none integer , intent ( in ) :: count integer , dimension (:), intent ( inout ) :: requests integer , intent ( out ) :: requestindex # ifdef MPI integer , dimension ( MPI_STATUS_SIZE ), intent ( out ) :: status # else integer , dimension ( 1 ), intent ( out ) :: status # endif # ifdef MPI integer :: ierror call mpi_waitany ( count , requests , requestindex , status , ierror ) # else call error ( \"waitany\" ) # endif end subroutine waitany subroutine all_to_group_real ( all , group , njobs ) implicit none real , dimension (:), intent ( in ) :: all real , intent ( out ) :: group integer , intent ( in ) :: njobs integer :: ik , tag , idx tag = 1000 # ifndef MPI call error ( \"all_to_group\" ) # else !    do ik = 0, njobs-1 !       if (proc0) then !          if (iproc == grp0(ik)) then !             group = all(ik+1) !          else !             call ssend (all(ik+1), grp0(ik), tag) !          end if !       else if (iproc == grp0(ik)) then !          call receive (group, 0, tag) !       end if !!       call barrier !    end do do ik = 0 , njobs - 1 if ( proc0 ) then idx = mod ( ik , size ( all )) if ( iproc == grp0 ( ik )) then group = all ( idx + 1 ) else call ssend ( all ( idx + 1 ), grp0 ( ik ), tag ) end if else if ( iproc == grp0 ( ik )) then call receive ( group , 0 , tag ) end if !       call barrier end do # endif end subroutine all_to_group_real subroutine all_to_group_real_array ( all , group , njobs ) implicit none real , dimension (:, :), intent ( in ) :: all real , dimension (:), intent ( out ) :: group integer , intent ( in ) :: njobs integer :: ik , tag , idx # ifndef MPI call error ( \"all_to_group\" ) # else tag = 1001 !    do ik = 0, njobs-1 !       if (proc0) then !          if (iproc == grp0(ik)) then !             group = all(ik+1,:) !          else !             call ssend (all(ik+1,:), grp0(ik), tag) !          end if !       else if (iproc == grp0(ik)) then !          call receive (group, 0, tag) !       end if !!       call barrier !    end do do ik = 0 , njobs - 1 if ( proc0 ) then idx = mod ( ik , size ( all , dim = 1 )) if ( iproc == grp0 ( ik )) then group = all ( idx + 1 , :) else call ssend ( all ( idx + 1 , :), grp0 ( ik ), tag ) end if else if ( iproc == grp0 ( ik )) then call receive ( group , 0 , tag ) end if !       call barrier end do # endif end subroutine all_to_group_real_array subroutine group_to_all_real ( group , all , njobs ) implicit none real , intent ( in ) :: group real , dimension (:), intent ( out ) :: all integer , intent ( in ) :: njobs integer :: ik , tag , idx tag = 1002 # ifndef MPI call error ( \"group_to_all\" ) # else do ik = 0 , njobs - 1 if ( iproc == grp0 ( ik )) then if (. not . proc0 ) then call ssend ( group , 0 , tag ) else idx = mod ( ik , size ( all )) all ( idx + 1 ) = group end if else if ( proc0 ) then idx = mod ( ik , size ( all )) call receive ( all ( idx + 1 ), grp0 ( ik ), tag ) end if !       call barrier end do # endif end subroutine group_to_all_real subroutine group_to_all_real_array ( group , all , njobs ) implicit none real , dimension (:), intent ( in ) :: group real , dimension (:, :), intent ( out ) :: all integer , intent ( in ) :: njobs integer :: ik , tag , idx tag = 1003 # ifndef MPI call error ( \"group_to_all\" ) # else do ik = 0 , njobs - 1 if ( iproc == grp0 ( ik )) then if (. not . proc0 ) then call ssend ( group , 0 , tag ) else idx = mod ( ik , size ( all )) all ( idx + 1 , :) = group end if else if ( proc0 ) then idx = mod ( ik , size ( all )) call receive ( all ( idx + 1 , :), grp0 ( ik ), tag ) end if !       call barrier end do # endif end subroutine group_to_all_real_array subroutine mp_abort ( msg ) use file_utils , only : error_unit , flush_output_file implicit none character ( len =* ), intent ( in ) :: msg # ifdef MPI integer :: ierror integer , parameter :: error_code = MPI_ERR_UNKNOWN # endif if ( proc0 ) then write ( error_unit (), * ) \"Error: \" // msg call flush_output_file ( error_unit ()) end if # ifndef MPI # ifndef NO_ABORT call abort # endif # else call mpi_abort ( comm_all , error_code , ierror ) # endif end subroutine mp_abort # ifndef MPI subroutine error ( msg ) use file_utils , only : error_unit implicit none character ( len =* ), intent ( in ) :: msg write ( error_unit (), * ) \"mp error: \" // msg # ifndef NO_ABORT call abort # endif stop end subroutine error # endif ! this gathers a single integer from each processor into an array on proc0 subroutine mp_gather ( senddata , recvarray ) implicit none integer , intent ( in ) :: senddata integer , dimension (:), intent ( out ) :: recvarray integer :: ierr # ifndef MPI call error ( \"mp_gather\" ) # else call mpi_gather ( senddata , 1 , mpi_integer , recvarray , & 1 , mpi_integer , 0 , mp_comm , ierr ) #endif end subroutine mp_gather subroutine broadcast_with_comm ( x , comm ) implicit none real , dimension (:), intent ( in out ) :: x integer , intent ( in ) :: comm # ifdef MPI integer :: ierror call mpi_bcast ( x , size ( x ), mpireal , 0 , comm , ierror ) # endif end subroutine broadcast_with_comm end module mp","tags":"","loc":"sourcefile/mp.fpp.html"},{"title":"text_options.f90 â€“ stella","text":"Contents Modules text_options Source Code text_options.f90 Source Code module text_options implicit none private public :: text_option public :: get_option_value integer , parameter :: maxlen = 30 type :: text_option character ( maxlen ) :: name integer :: value end type text_option contains subroutine get_option_value ( selection , options , value , & error_unit , selection_name , stop_on_error ) use mp , only : mp_abort implicit none character ( * ), intent ( in ) :: selection type ( text_option ), dimension (:), intent ( in ) :: options integer , intent ( in out ) :: value integer , intent ( in ), optional :: error_unit character ( * ), intent ( in ), optional :: selection_name logical , intent ( in ), optional :: stop_on_error integer :: i , l , n_partial_matches , v_partial_match integer :: err logical :: local_stop local_stop = . false . if ( present ( stop_on_error )) local_stop = stop_on_error do i = 1 , size ( options ) if ( trim ( selection ) == trim ( options ( i )% name )) then value = options ( i )% value return end if end do ! look for partial matches l = len_trim ( selection ) n_partial_matches = 0 do i = 1 , size ( options ) if ( l < len_trim ( options ( i )% name )) then if ( trim ( selection ) == options ( i )% name ( 1 : l )) then n_partial_matches = n_partial_matches + 1 v_partial_match = options ( i )% value end if end if end do if ( n_partial_matches == 1 ) then value = v_partial_match return end if if ( present ( error_unit )) then err = error_unit else err = 6 end if if ( n_partial_matches == 0 ) then if ( present ( selection_name )) then write ( unit = err , fmt = \"('Invalid selection for ', a, ': ', a)\" ) & trim ( selection_name ), trim ( selection ) else write ( unit = err , fmt = \"('Invalid selection: ',a)\" ) trim ( selection ) end if write ( unit = err , fmt = \"('Valid selections are:')\" ) do i = 1 , size ( options ) write ( unit = err , fmt = \"(3x,a)\" ) trim ( options ( i )% name ) end do else if ( present ( selection_name )) then write ( unit = err , fmt = \"('Ambiguous selection for ', a, ': ', a)\" ) & trim ( selection_name ), trim ( selection ) else write ( unit = err , fmt = \"('Ambiguous selection: ',a)\" ) trim ( selection ) end if write ( unit = err , fmt = \"('Matching selections are:')\" ) do i = 1 , size ( options ) if ( l < len_trim ( options ( i )% name )) then if ( trim ( selection ) == options ( i )% name ( 1 : l )) then write ( unit = err , fmt = \"(3x,a)\" ) trim ( options ( i )% name ) end if end if end do end if if ( local_stop ) then call mp_abort ( 'STOP error in get_option_value' ) end if write ( unit = err , fmt = \"('Continuing with default selection...')\" ) end subroutine get_option_value end module text_options","tags":"","loc":"sourcefile/text_options.f90.html"},{"title":"mt19937.f90 â€“ stella","text":"Contents Modules mt19937 Source Code mt19937.f90 Source Code !!$ A C-program for MT19937: Real number version !!$   genrand() generates one pseudorandom real number (double) !!$ which is uniformly distributed on [0,1]-interval, for each !!$ call. sgenrand(seed) set initial values to the working area !!$ of 624 words. Before genrand(), sgenrand(seed) must be !!$ called once. (seed is any 32-bit integer except for 0). !!$ Integer generator is obtained by modifying two lines. !!$   Coded by Takuji Nishimura, considering the suggestions by !!$ Topher Cooper and Marc Rieffel in July-Aug. 1997. !!$ !!$ This library is free software; you can redistribute it and/or !!$ modify it under the terms of the GNU Library General Public !!$ License as published by the Free Software Foundation; either !!$ version 2 of the License, or (at your option) any later !!$ version. !!$ This library is distributed in the hope that it will be useful, !!$ but WITHOUT ANY WARRANTY; without even the implied warranty of !!$ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. !!$ See the GNU Library General Public License for more details. !!$ You should have received a copy of the GNU Library General !!$ Public License along with this library; if not, write to the !!$ Free Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA !!$ 02111-1307  USA !!$ !!$ Copyright (C) 1997 Makoto Matsumoto and Takuji Nishimura. !!$ When you use this, send an email to: matumoto@math.keio.ac.jp !!$ with an appropriate reference to your work. !!$ !!$*********************************************************************** !!$ Fortran translation by Hiroshi Takano.  Jan. 13, 1999. !!$ !!$ This program uses the following non-standard intrinsics. !!$   ishft(i,n): If n>0, shifts bits in i by n positions to left. !!$               If n<0, shifts bits in i by n positions to right. !!$   iand (i,j): Performs logical AND on corresponding bits of i and j. !!$   ior  (i,j): Performs inclusive OR on corresponding bits of i and j. !!$   ieor (i,j): Performs exclusive OR on corresponding bits of i and j. !!$ !!$************************************************************************ !!$ Fortran 95 translation and modularized to use in gyrokinetics project !!$ by R. Numata, June 2, 2010. !!$  * removed statement functions (TSHFTU,TSHFTS,TSHFTT,TSHFTL) !!$  * uses [0,1) interval !!$  * the above bit manipulation functions became standard. !!$  * definition of UMASK is corrected (the original value cannot be !!$    represented as a kind=4 integer. !!$*********************************************************************** module mt19937 implicit none private public :: sgrnd , grnd integer , parameter :: default_seed = 4357 ! Period parameters integer , parameter :: N = 624 integer , parameter :: M = 397 integer , parameter :: MATA = - 1727483681 ! constant vector a integer , parameter :: LMASK = 2147483647 ! least significant r bits integer , parameter :: UMASK = - LMASK - 1 ! most significant w-r bits ! Tempering parameters integer , parameter :: TMASKB = - 1658038656 integer , parameter :: TMASKC = - 272236544 integer , save :: mt ( 0 : N - 1 ) ! the array for the state vector integer , save :: mti = N + 1 ! mti==N+1 means mt[N] is not initialized integer , save :: mag01 ( 0 : 1 ) = ( / 0 , MATA / ) ! mag01(x) = x * MATA for x=0,1 contains subroutine sgrnd ( seed ) implicit none integer , intent ( in ) :: seed !!$      setting initial seeds to mt[N] using !!$      the generator Line 25 of Table 1 in !!$      [KNUTH 1981, The Art of Computer Programming !!$         Vol. 2 (2nd Ed.), pp102] mt ( 0 ) = iand ( seed , - 1 ) do mti = 1 , N - 1 mt ( mti ) = iand ( 69069 * mt ( mti - 1 ), - 1 ) end do return end subroutine sgrnd function grnd () implicit none real :: grnd real , parameter :: pow = 429496729 6.0 ! 2**32 real , parameter :: div = 1. / pow ! devided by 2**32 [0,1)-real-interval ! real, parameter :: div=1./(pow-1.)  ! devided by 2**32-1 [0,1]-real-interval integer :: y , kk if ( mti >= N ) then ! generate N words at one time if ( mti == N + 1 ) then ! if sgrnd() has not been called, call sgrnd ( default_seed ) ! a default initial seed is used end if do kk = 0 , N - M - 1 y = ior ( iand ( mt ( kk ), UMASK ), iand ( mt ( kk + 1 ), LMASK )) mt ( kk ) = ieor ( ieor ( mt ( kk + M ), ishft ( y , - 1 )), mag01 ( iand ( y , 1 ))) end do do kk = N - M , N - 2 y = ior ( iand ( mt ( kk ), UMASK ), iand ( mt ( kk + 1 ), LMASK )) mt ( kk ) = ieor ( ieor ( mt ( kk + ( M - N )), ishft ( y , - 1 )), mag01 ( iand ( y , 1 ))) end do y = ior ( iand ( mt ( N - 1 ), UMASK ), iand ( mt ( 0 ), LMASK )) mt ( N - 1 ) = ieor ( ieor ( mt ( M - 1 ), ishft ( y , - 1 )), mag01 ( iand ( y , 1 ))) mti = 0 end if y = mt ( mti ) mti = mti + 1 y = ieor ( y , ishft ( y , - 11 )) y = ieor ( y , iand ( ishft ( y , 7 ), TMASKB )) y = ieor ( y , iand ( ishft ( y , 15 ), TMASKC )) y = ieor ( y , ishft ( y , - 18 )) grnd = real ( y ) if ( grnd < 0. ) grnd = grnd + pow grnd = grnd * div return end function grnd end module mt19937 !!$ this main outputs first 1000 generated numbers !!$program main !!$  use mt19937, only: grnd !!$  ! use mt19937, only: sgrnd !!$  implicit none !!$  integer, parameter :: no=1000 !!$  real :: r(0:7) !!$  integer :: j,k !!$  ! call sgrnd(4357) ! any nonzero integer can be used as a seed !!$ !!$  do j=0,no-1 !!$     r(mod(j,8))=grnd() !!$     if(mod(j,8) == 7) then !!$        write(*,'(8(f8.6,'' ''))') (r(k),k=0,7) !!$     else if(j == no-1) then !!$        write(*,'(8(f8.6,'' ''))') (r(k),k=0,mod(no-1,8)) !!$     endif !!$  end do !!$ !!$  stop !!$end program main","tags":"","loc":"sourcefile/mt19937.f90.html"},{"title":"redistribute.f90 â€“ stella","text":"Contents Modules redistribute Source Code redistribute.f90 Source Code ! Modifications for optimised local copy in c_redist_22 and c_redist_32 ! (and their inverse routines): ! (c) The Numerical Algorithms Group (NAG) Ltd, 2012 ! on behalf of EPSRC for the HECToR project module redistribute ! ! Redistribute distributed (integer, real, complex or logical) ! (1, 2, 3, or 4) dimensional arrays into two dimensional arrays with ! first index on local processor, and vice versa. ! ! The first operation is called 'gather' and the second is called 'scatter.' ! ! One can also do a 'fill' operation.  This consists of copying ! values from a (2, 3, or 4) dimensional array of ! (integer, real, complex, or logical ) values into ! another array with the same number of dimensions. ! ! One can also do a three index to four index redistribution for complex numbers. ! implicit none private public :: index_list_type , delete_list public :: redist_type , delete_redist ! TT> public :: report_map_property , measure_gather , measure_scatter public :: gather_count , scatter_count , time_redist ! <TT public :: init_redist , gather , scatter public :: init_fill , fill public :: set_redist_character_type interface gather module procedure c_redist_22 , r_redist_22 , i_redist_22 , l_redist_22 module procedure c_redist_32 , r_redist_32 , i_redist_32 , l_redist_32 module procedure c_redist_42 , r_redist_42 , i_redist_42 , l_redist_42 module procedure c_redist_23 module procedure c_redist_34 , r_redist_34 module procedure c_redist_33 module procedure c_redist_35 , r_redist_35 end interface interface scatter module procedure c_redist_12 , r_redist_12 , i_redist_12 , l_redist_12 module procedure c_redist_22_inv , r_redist_22_inv , i_redist_22_inv , l_redist_22_inv module procedure c_redist_32_inv , r_redist_32_inv , i_redist_32_inv , l_redist_32_inv module procedure c_redist_42_inv , r_redist_42_inv , i_redist_42_inv , l_redist_42_inv module procedure c_redist_33_inv module procedure c_redist_34_inv , r_redist_34_inv module procedure c_redist_35_inv , r_redist_35_inv end interface ! TT> interface measure_gather module procedure measure_gather_32 , measure_gather_33 module procedure measure_gather_22 end interface interface measure_scatter module procedure measure_scatter_23 , measure_scatter_33 module procedure measure_scatter_22 end interface integer :: gather_count = 0 , scatter_count = 0 real , save :: time_redist ( 2 ) = 0. ! <TT interface fill module procedure c_fill_2 , c_fill_3 , c_fill_4 module procedure r_fill_2 , r_fill_3 , r_fill_4 module procedure i_fill_2 , i_fill_3 , i_fill_4 module procedure l_fill_2 , l_fill_3 , l_fill_4 end interface type :: index_map integer :: nn integer , dimension (:), pointer :: k => null () integer , dimension (:), pointer :: l => null () integer , dimension (:), pointer :: m => null () integer , dimension (:), pointer :: n => null () integer , dimension (:), pointer :: o => null () end type index_map ! TT: want to add map name, from_layout and to_layout type :: redist_type private integer , dimension ( 5 ) :: to_low , from_low , to_high , from_high type ( index_map ), dimension (:), pointer :: to => null () type ( index_map ), dimension (:), pointer :: from => null () complex , dimension (:), pointer :: complex_buff => null () real , dimension (:), pointer :: real_buff => null () integer , dimension (:), pointer :: integer_buff => null () logical , dimension (:), pointer :: logical_buff => null () character ( len = 3 ) :: redistname = \"\" end type redist_type type :: index_list_type integer , dimension (:), pointer :: first => null () integer , dimension (:), pointer :: second => null () integer , dimension (:), pointer :: third => null () integer , dimension (:), pointer :: fourth => null () integer , dimension (:), pointer :: fifth => null () end type index_list_type contains subroutine set_redist_character_type ( r , chartype ) type ( redist_type ), intent ( inout ) :: r character ( 3 ), intent ( in ) :: chartype r % redistname = chartype end subroutine set_redist_character_type subroutine init_redist ( r , char , to_low , to_high , to_list , & from_low , from_high , from_list , ierr ) use mp , only : iproc , nproc , proc0 type ( redist_type ), intent ( inout ) :: r character ( 1 ), intent ( in ) :: char type ( index_list_type ), dimension ( 0 : nproc - 1 ), intent ( in ) :: to_list , from_list integer , dimension (:), intent ( in ) :: from_low , to_high , from_high , to_low integer :: j , ip , n_to , n_from , buff_size integer , optional , intent ( out ) :: ierr allocate ( r % to ( 0 : nproc - 1 ), r % from ( 0 : nproc - 1 )) if ( present ( ierr )) ierr = 0 buff_size = 0 do ip = 0 , nproc - 1 if ( associated ( to_list ( ip )% first )) then n_to = size ( to_list ( ip )% first ) r % to ( ip )% nn = n_to allocate ( r % to ( ip )% k ( n_to )) allocate ( r % to ( ip )% l ( n_to )) r % to ( ip )% k = to_list ( ip )% first r % to ( ip )% l = to_list ( ip )% second if ( associated ( to_list ( ip )% third )) then allocate ( r % to ( ip )% m ( n_to )) r % to ( ip )% m = to_list ( ip )% third end if if ( associated ( to_list ( ip )% fourth )) then allocate ( r % to ( ip )% n ( n_to )) r % to ( ip )% n = to_list ( ip )% fourth end if if ( associated ( to_list ( ip )% fifth )) then allocate ( r % to ( ip )% o ( n_to )) r % to ( ip )% o = to_list ( ip )% fifth end if if ( ip /= iproc ) buff_size = max ( buff_size , n_to ) else r % to ( ip )% nn = 0 end if end do do j = 1 , size ( from_low ) r % from_low ( j ) = from_low ( j ) end do do j = 1 , size ( from_high ) r % from_high ( j ) = from_high ( j ) end do do j = 1 , size ( to_high ) r % to_high ( j ) = to_high ( j ) end do do j = 1 , size ( to_low ) r % to_low ( j ) = to_low ( j ) end do do ip = 0 , nproc - 1 if ( associated ( from_list ( ip )% first )) then n_from = size ( from_list ( ip )% first ) r % from ( ip )% nn = n_from allocate ( r % from ( ip )% k ( n_from )) allocate ( r % from ( ip )% l ( n_from )) r % from ( ip )% k = from_list ( ip )% first r % from ( ip )% l = from_list ( ip )% second if ( associated ( from_list ( ip )% third )) then allocate ( r % from ( ip )% m ( n_from )) r % from ( ip )% m = from_list ( ip )% third end if if ( associated ( from_list ( ip )% fourth )) then allocate ( r % from ( ip )% n ( n_from )) r % from ( ip )% n = from_list ( ip )% fourth end if if ( associated ( from_list ( ip )% fifth )) then allocate ( r % from ( ip )% o ( n_from )) r % from ( ip )% o = from_list ( ip )% fifth end if if ( ip /= iproc ) buff_size = max ( buff_size , n_from ) else r % from ( ip )% nn = 0 end if end do select case ( char ) case ( 'c' ) if ( buff_size > 0 ) allocate ( r % complex_buff ( buff_size )) case ( 'r' ) if ( buff_size > 0 ) allocate ( r % real_buff ( buff_size )) case ( 'i' ) if ( buff_size > 0 ) allocate ( r % integer_buff ( buff_size )) case ( 'l' ) if ( buff_size > 0 ) allocate ( r % logical_buff ( buff_size )) case default if ( proc0 ) then write ( * , * ) 'Type to be redistributed invalid.  Must stop.' write ( * , * ) char end if stop end select end subroutine init_redist !  subroutine init_fill (f, char, to_low, to_high, to_list, & !       from_low, from_high, from_list, ierr) subroutine init_fill ( f , char , to_low , to_list , & from_low , from_list , ierr ) use mp , only : nproc , proc0 , iproc type ( redist_type ), intent ( out ) :: f character ( 1 ), intent ( in ) :: char ! TT> caused a problem on PGI compiler !    type (index_list_type), dimension (0:) :: to_list, from_list type ( index_list_type ), dimension ( 0 : nproc - 1 ), intent ( in ) :: to_list , from_list ! <TT !    integer, dimension(:), intent (in) :: to_low, from_low, to_high, from_high integer , dimension (:), intent ( in ) :: to_low , from_low integer , optional , intent ( out ) :: ierr integer :: j , ip , n_to , n_from , buff_size if ( present ( ierr )) ierr = 0 do j = 1 , size ( to_low ) f % to_low ( j ) = to_low ( j ) end do do j = 1 , size ( from_low ) f % from_low ( j ) = from_low ( j ) end do allocate ( f % to ( 0 : nproc - 1 ), f % from ( 0 : nproc - 1 )) buff_size = 0 do ip = 0 , nproc - 1 if ( associated ( to_list ( ip )% first )) then n_to = size ( to_list ( ip )% first ) f % to ( ip )% nn = n_to allocate ( f % to ( ip )% k ( n_to )) f % to ( ip )% k = to_list ( ip )% first if ( associated ( to_list ( ip )% second )) then allocate ( f % to ( ip )% l ( n_to )) f % to ( ip )% l = to_list ( ip )% second end if if ( associated ( to_list ( ip )% third )) then allocate ( f % to ( ip )% m ( n_to )) f % to ( ip )% m = to_list ( ip )% third end if if ( associated ( to_list ( ip )% fourth )) then allocate ( f % to ( ip )% n ( n_to )) f % to ( ip )% n = to_list ( ip )% fourth end if if ( associated ( to_list ( ip )% fifth )) then allocate ( f % to ( ip )% o ( n_to )) f % to ( ip )% o = to_list ( ip )% fifth end if if ( ip /= iproc ) buff_size = max ( buff_size , n_to ) else f % to ( ip )% nn = 0 end if end do do ip = 0 , nproc - 1 if ( associated ( from_list ( ip )% first )) then n_from = size ( from_list ( ip )% first ) f % from ( ip )% nn = n_from allocate ( f % from ( ip )% k ( n_from )) f % from ( ip )% k = from_list ( ip )% first if ( associated ( from_list ( ip )% second )) then allocate ( f % from ( ip )% l ( n_from )) f % from ( ip )% l = from_list ( ip )% second end if if ( associated ( from_list ( ip )% third )) then allocate ( f % from ( ip )% m ( n_from )) f % from ( ip )% m = from_list ( ip )% third end if if ( associated ( from_list ( ip )% fourth )) then allocate ( f % from ( ip )% n ( n_from )) f % from ( ip )% n = from_list ( ip )% fourth end if if ( associated ( from_list ( ip )% fifth )) then allocate ( f % from ( ip )% o ( n_from )) f % from ( ip )% o = from_list ( ip )% fifth end if if ( ip /= iproc ) buff_size = max ( buff_size , n_from ) else f % from ( ip )% nn = 0 end if end do select case ( char ) case ( 'c' ) if ( buff_size > 0 ) allocate ( f % complex_buff ( buff_size )) case ( 'r' ) if ( buff_size > 0 ) allocate ( f % real_buff ( buff_size )) case ( 'i' ) if ( buff_size > 0 ) allocate ( f % integer_buff ( buff_size )) case ( 'l' ) if ( buff_size > 0 ) allocate ( f % logical_buff ( buff_size )) case default if ( proc0 ) then write ( * , * ) 'Type to be redistributed invalid.  Must stop.' write ( * , * ) char end if stop end select end subroutine init_fill subroutine delete_redist ( r ) use mp , only : nproc type ( redist_type ), intent ( in out ) :: r integer :: i if ( associated ( r % to )) then do i = 0 , nproc - 1 if ( associated ( r % to ( i )% k )) deallocate ( r % to ( i )% k ) if ( associated ( r % to ( i )% l )) deallocate ( r % to ( i )% l ) if ( associated ( r % to ( i )% m )) deallocate ( r % to ( i )% m ) if ( associated ( r % to ( i )% n )) deallocate ( r % to ( i )% n ) end do deallocate ( r % to ) end if if ( associated ( r % from )) then do i = 0 , nproc - 1 if ( associated ( r % from ( i )% k )) deallocate ( r % from ( i )% k ) if ( associated ( r % from ( i )% l )) deallocate ( r % from ( i )% l ) if ( associated ( r % from ( i )% m )) deallocate ( r % from ( i )% m ) if ( associated ( r % from ( i )% n )) deallocate ( r % from ( i )% n ) end do deallocate ( r % from ) end if if ( associated ( r % complex_buff )) deallocate ( r % complex_buff ) if ( associated ( r % real_buff )) deallocate ( r % real_buff ) if ( associated ( r % integer_buff )) deallocate ( r % integer_buff ) if ( associated ( r % logical_buff )) deallocate ( r % logical_buff ) end subroutine delete_redist subroutine delete_list ( list ) use mp , only : nproc ! TT> caused a problem on PGI compiler !    type (index_list_type), dimension(0:) :: list type ( index_list_type ), dimension ( 0 : nproc - 1 ), intent ( inout ) :: list ! <TT integer :: ip do ip = 0 , nproc - 1 if ( associated ( list ( ip )% first )) deallocate ( list ( ip )% first ) if ( associated ( list ( ip )% second )) deallocate ( list ( ip )% second ) if ( associated ( list ( ip )% third )) deallocate ( list ( ip )% third ) if ( associated ( list ( ip )% fourth )) deallocate ( list ( ip )% fourth ) if ( associated ( list ( ip )% fifth )) deallocate ( list ( ip )% fifth ) end do end subroutine delete_list subroutine c_redist_12 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % from_low ( 1 ):), intent ( in ) :: from_here complex , dimension ( r % to_low ( 1 ):, r % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), r % to ( iproc )% l ( i )) & = from_here ( r % from ( iproc )% k ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % complex_buff ( i ) = from_here ( r % from ( ipto )% k ( i )) end do call send ( r % complex_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % complex_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % complex_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % complex_buff ( i ) = from_here ( r % from ( ipto )% k ( i )) end do call send ( r % complex_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine c_redist_12 subroutine c_redist_22 ( r , from_here , to_here ) type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):), intent ( in ) :: from_here complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in out ) :: to_here call c_redist_22_old_copy ( r , from_here , to_here ) call c_redist_22_mpi_copy ( r , from_here , to_here ) end subroutine c_redist_22 subroutine c_redist_22_old_copy ( r , from_here , to_here ) use mp , only : iproc type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):), intent ( in ) :: from_here complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i !CMR ! In the stella standard FFT situation this routine maps !         xxf(it,ixxf) to yxf(ik,iyxf) data type !         where it is kx (or x) index, ik is ky (or y) index, !         ixxf is (y,ig,isgn,\"les\") and iyxf is (x,ig,isgn,\"les\") ! do i = 1 , r % from ( iproc )% nn ! ! redistribute from local processor to local processor ! NB r%from(iproc)%nn is #elements sent by THIS processor to THIS processor !    In this situation the data at (r%to(iproc)%k(i),r%to(iproc)%l(i)) !    should come from (r%from(iproc)%k(i), r%from(iproc)%l(i)). ! ! This do loop, in stella standard FFT situation, corresponds to: !    to_here(ik,iyxf)=from_here(it,ixxf) ! to_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) & = from_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i )) end do end subroutine c_redist_22_old_copy subroutine c_redist_22_mpi_copy ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):), intent ( in ) :: from_here complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % complex_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i )) end do call send ( r % complex_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % complex_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % complex_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % complex_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i )) end do call send ( r % complex_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine c_redist_22_mpi_copy subroutine c_redist_22_inv ( r , from_here , to_here ) type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in ) :: from_here complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):), intent ( in out ) :: to_here call c_redist_22_inv_old_copy ( r , from_here , to_here ) call c_redist_22_inv_mpi_copy ( r , from_here , to_here ) end subroutine c_redist_22_inv subroutine c_redist_22_inv_old_copy ( r , from_here , to_here ) use mp , only : iproc type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in ) :: from_here complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):), intent ( in out ) :: to_here integer :: i !CMR ! In the stella standard FFT situation this routine maps !         yxf(ik,iyxf) to xxf(it,ixxf) data type !         where it is kx (or x) index, ik is ky (or y) index, !         ixxf is (y,ig,isgn,\"les\") and iyxf is (x,ig,isgn,\"les\") ! do i = 1 , r % to ( iproc )% nn ! ! redistribute from local processor to local processor ! NB r%from(iproc)%nn is #elements sent by THIS processor to THIS processor !    In this situation the data at (r%from(iproc)%k(i),r%from(iproc)%l(i)) !    should come from (r%to(iproc)%k(i), r%to(iproc)%l(i)). ! ! This do loop, in stella standard FFT situation, corresponds to: !    to_here(it,ixxf)=from_here(ik,iyxf) ! to_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i )) & = from_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) end do end subroutine c_redist_22_inv_old_copy subroutine c_redist_22_inv_mpi_copy ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in ) :: from_here complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % complex_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % complex_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i )) & = r % complex_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i )) & = r % complex_buff ( i ) end do end if ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % complex_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % complex_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine c_redist_22_inv_mpi_copy subroutine c_redist_32 ( r , from_here , to_here ) use job_manage , only : time_message type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in ) :: from_here complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in out ) :: to_here call c_redist_32_old_copy ( r , from_here , to_here ) call c_redist_32_mpi_copy ( r , from_here , to_here ) end subroutine c_redist_32 subroutine c_redist_32_old_copy ( r , from_here , to_here ) use mp , only : iproc type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in ) :: from_here complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i !CMR ! In the stella standard FFT situation this routine maps !         g(ig, isgn, iglo) to xxf(it,ixxf) data type !         where it is kx (or x) index, ixxf is (y,ig,isgn,\"les\") !         and iglo is (\"xyles\") do i = 1 , r % from ( iproc )% nn ! ! redistribute from local processor to local processor ! NB r%from(iproc)%nn is #elements sent by THIS processor to THIS processor !    In this situation the data at (r%to(iproc)%k(i),r%to(iproc)%l(i)) !    should come from (r%from(iproc)%k(i),r%from(iproc)%l(i),r%from(iproc)%m(i)). ! ! This do loop, in stella standard FFT situation, corresponds to: !    to_here(it,ixxf)=from_here(ig,isgn,iglo) ! to_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) & = from_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i )) end do end subroutine c_redist_32_old_copy subroutine c_redist_32_mpi_copy ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in ) :: from_here complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % complex_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i )) end do call send ( r % complex_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % complex_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % complex_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % complex_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i )) end do call send ( r % complex_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine c_redist_32_mpi_copy subroutine c_redist_32_inv ( r , from_here , to_here ) use job_manage , only : time_message type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in ) :: from_here complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in out ) :: to_here call c_redist_32_inv_old_copy ( r , from_here , to_here ) call c_redist_32_inv_mpi_copy ( r , from_here , to_here ) end subroutine c_redist_32_inv subroutine c_redist_32_inv_old_copy ( r , from_here , to_here ) use mp , only : iproc type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in ) :: from_here complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in out ) :: to_here integer :: i !CMR ! In the stella standard FFT situation this routine maps !         xxf(it,ixxf) to g(ig, isgn, iglo) data type !         where it is kx (or x) index, ixxf is (y,ig,isgn,\"les\") !         and iglo is (\"xyles\") do i = 1 , r % to ( iproc )% nn ! ! redistribute from local processor to local processor ! NB r%to(iproc)%nn is #elements sent by THIS processor to THIS processor !    In this situation the data at (r%from(iproc)%k(i),r%from(iproc)%l(i),r%from(iproc)%m(i)) !    should come from (r%to(iproc)%k(i),r%to(iproc)%l(i)). ! ! This do loop, in stella standard FFT situation, corresponds to: !    to_here(ig,isgn,iglo)=from_here(it,ixxf) ! to_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i )) & = from_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) end do end subroutine c_redist_32_inv_old_copy subroutine c_redist_32_inv_mpi_copy ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in ) :: from_here complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % complex_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % complex_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i )) & = r % complex_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i )) & = r % complex_buff ( i ) end do end if ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % complex_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % complex_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine c_redist_32_inv_mpi_copy subroutine c_redist_42 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):, & r % from_low ( 4 ):), intent ( in ) :: from_here complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) & = from_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i ), & r % from ( iproc )% n ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % complex_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i ), & r % from ( ipto )% n ( i )) end do call send ( r % complex_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % complex_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % complex_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % complex_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i ), & r % from ( ipto )% n ( i )) end do call send ( r % complex_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine c_redist_42 subroutine c_redist_42_inv ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in ) :: from_here complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):, & r % from_low ( 4 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % to ( iproc )% nn to_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i ), & r % from ( iproc )% n ( i )) & = from_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % complex_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % complex_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i ), & r % from ( ipfrom )% n ( i )) & = r % complex_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i ), & r % from ( ipfrom )% n ( i )) & = r % complex_buff ( i ) end do end if ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % complex_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % complex_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine c_redist_42_inv subroutine c_redist_23 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):), intent ( in ) :: from_here complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):, & r % to_low ( 3 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i ), & r % to ( iproc )% m ( i )) & = from_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % complex_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i )) end do call send ( r % complex_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i ), & r % to ( ipfrom )% m ( i )) & = r % complex_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i ), & r % to ( ipfrom )% m ( i )) & = r % complex_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % complex_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i )) end do call send ( r % complex_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine c_redist_23 subroutine c_redist_34 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in ) :: from_here complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):, & r % to_low ( 3 ):, & r % to_low ( 4 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i ), & r % to ( iproc )% m ( i ), & r % to ( iproc )% n ( i )) & = from_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % complex_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i )) end do call send ( r % complex_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i ), & r % to ( ipfrom )% m ( i ), & r % to ( ipfrom )% n ( i )) & = r % complex_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i ), & r % to ( ipfrom )% m ( i ), & r % to ( ipfrom )% n ( i )) & = r % complex_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % complex_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i )) end do call send ( r % complex_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine c_redist_34 subroutine c_redist_34_inv ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):, & r % to_low ( 3 ):, & r % to_low ( 4 ):), intent ( in ) :: from_here complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % to ( iproc )% nn to_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i )) & = from_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i ), & r % to ( iproc )% m ( i ), & r % to ( iproc )% n ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % complex_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i ), & r % to ( ipto )% m ( i ), & r % to ( ipto )% n ( i )) end do call send ( r % complex_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i )) & = r % complex_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i )) & = r % complex_buff ( i ) end do end if ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % complex_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i ), & r % to ( ipto )% m ( i ), & r % to ( ipto )% n ( i )) end do call send ( r % complex_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine c_redist_34_inv subroutine r_redist_34 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r real , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in ) :: from_here real , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):, & r % to_low ( 3 ):, & r % to_low ( 4 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i ), & r % to ( iproc )% m ( i ), & r % to ( iproc )% n ( i )) & = from_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % real_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i )) end do call send ( r % real_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i ), & r % to ( ipfrom )% m ( i ), & r % to ( ipfrom )% n ( i )) & = r % real_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i ), & r % to ( ipfrom )% m ( i ), & r % to ( ipfrom )% n ( i )) & = r % real_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % real_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i )) end do call send ( r % real_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine r_redist_34 subroutine r_redist_34_inv ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r real , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):, & r % to_low ( 3 ):, & r % to_low ( 4 ):), intent ( in ) :: from_here real , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % to ( iproc )% nn to_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i )) & = from_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i ), & r % to ( iproc )% m ( i ), & r % to ( iproc )% n ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % real_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i ), & r % to ( ipto )% m ( i ), & r % to ( ipto )% n ( i )) end do call send ( r % real_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i )) & = r % real_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i )) & = r % real_buff ( i ) end do end if ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % real_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i ), & r % to ( ipto )% m ( i ), & r % to ( ipto )% n ( i )) end do call send ( r % real_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine r_redist_34_inv subroutine c_redist_35 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in ) :: from_here complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):, & r % to_low ( 3 ):, & r % to_low ( 4 ):, & r % to_low ( 5 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i ), & r % to ( iproc )% m ( i ), & r % to ( iproc )% n ( i ), & r % to ( iproc )% o ( i )) & = from_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % complex_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i )) end do call send ( r % complex_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i ), & r % to ( ipfrom )% m ( i ), & r % to ( ipfrom )% n ( i ), & r % to ( ipfrom )% o ( i )) & = r % complex_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i ), & r % to ( ipfrom )% m ( i ), & r % to ( ipfrom )% n ( i ), & r % to ( ipfrom )% o ( i )) & = r % complex_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % complex_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i )) end do call send ( r % complex_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine c_redist_35 subroutine r_redist_35 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r real , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in ) :: from_here real , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):, & r % to_low ( 3 ):, & r % to_low ( 4 ):, & r % to_low ( 5 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i ), & r % to ( iproc )% m ( i ), & r % to ( iproc )% n ( i ), & r % to ( iproc )% o ( i )) & = from_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % real_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i )) end do call send ( r % real_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i ), & r % to ( ipfrom )% m ( i ), & r % to ( ipfrom )% n ( i ), & r % to ( ipfrom )% o ( i )) & = r % real_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i ), & r % to ( ipfrom )% m ( i ), & r % to ( ipfrom )% n ( i ), & r % to ( ipfrom )% o ( i )) & = r % real_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % real_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i )) end do call send ( r % real_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine r_redist_35 subroutine c_redist_35_inv ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):, & r % to_low ( 3 ):, & r % to_low ( 4 ):, & r % to_low ( 5 ):), intent ( in ) :: from_here complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % to ( iproc )% nn to_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i )) & = from_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i ), & r % to ( iproc )% m ( i ), & r % to ( iproc )% n ( i ), & r % to ( iproc )% o ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % complex_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i ), & r % to ( ipto )% m ( i ), & r % to ( ipto )% n ( i ), & r % to ( ipto )% o ( i )) end do call send ( r % complex_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i )) & = r % complex_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i )) & = r % complex_buff ( i ) end do end if ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % complex_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i ), & r % to ( ipto )% m ( i ), & r % to ( ipto )% n ( i ), & r % to ( ipto )% o ( i )) end do call send ( r % complex_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine c_redist_35_inv subroutine r_redist_35_inv ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r real , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):, & r % to_low ( 3 ):, & r % to_low ( 4 ):, & r % to_low ( 5 ):), intent ( in ) :: from_here real , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % to ( iproc )% nn to_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i )) & = from_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i ), & r % to ( iproc )% m ( i ), & r % to ( iproc )% n ( i ), & r % to ( iproc )% o ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % real_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i ), & r % to ( ipto )% m ( i ), & r % to ( ipto )% n ( i ), & r % to ( ipto )% o ( i )) end do call send ( r % real_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i )) & = r % real_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i )) & = r % real_buff ( i ) end do end if ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % real_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i ), & r % to ( ipto )% m ( i ), & r % to ( ipto )% n ( i ), & r % to ( ipto )% o ( i )) end do call send ( r % real_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine r_redist_35_inv subroutine r_redist_12 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r real , dimension ( r % from_low ( 1 ):), intent ( in ) :: from_here real , dimension ( r % to_low ( 1 ):, r % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), r % to ( iproc )% l ( i )) & = from_here ( r % from ( iproc )% k ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % real_buff ( i ) = from_here ( r % from ( ipto )% k ( i )) end do call send ( r % real_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % real_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % real_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % real_buff ( i ) = from_here ( r % from ( ipto )% k ( i )) end do call send ( r % real_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine r_redist_12 subroutine r_redist_22 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r real , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):), intent ( in ) :: from_here real , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) & = from_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % real_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i )) end do call send ( r % real_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % real_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % real_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % real_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i )) end do call send ( r % real_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine r_redist_22 subroutine r_redist_22_inv ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r real , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in ) :: from_here real , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % to ( iproc )% nn to_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i )) & = from_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % real_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % real_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i )) & = r % real_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i )) & = r % real_buff ( i ) end do end if ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % real_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % real_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine r_redist_22_inv subroutine r_redist_32 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r real , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in ) :: from_here real , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) & = from_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % real_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i )) end do call send ( r % real_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % real_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % real_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % real_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i )) end do call send ( r % real_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine r_redist_32 subroutine r_redist_32_inv ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r real , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in ) :: from_here real , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % to ( iproc )% nn to_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i )) & = from_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % real_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % real_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i )) & = r % real_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i )) & = r % real_buff ( i ) end do end if ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % real_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % real_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine r_redist_32_inv subroutine r_redist_42 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r real , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):, & r % from_low ( 4 ):), intent ( in ) :: from_here real , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) & = from_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i ), & r % from ( iproc )% n ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % real_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i ), & r % from ( ipto )% n ( i )) end do call send ( r % real_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % real_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % real_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % real_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i ), & r % from ( ipto )% n ( i )) end do call send ( r % real_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine r_redist_42 subroutine r_redist_42_inv ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r real , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in ) :: from_here real , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):, & r % from_low ( 4 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % to ( iproc )% nn to_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i ), & r % from ( iproc )% n ( i )) & = from_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % real_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % real_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i ), & r % from ( ipfrom )% n ( i )) & = r % real_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i ), & r % from ( ipfrom )% n ( i )) & = r % real_buff ( i ) end do end if ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % real_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % real_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine r_redist_42_inv subroutine i_redist_12 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r integer , dimension ( r % from_low ( 1 ):), intent ( in ) :: from_here integer , dimension ( r % to_low ( 1 ):, r % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), r % to ( iproc )% l ( i )) & = from_here ( r % from ( iproc )% k ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % integer_buff ( i ) = from_here ( r % from ( ipto )% k ( i )) end do call send ( r % integer_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % integer_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % integer_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % integer_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % integer_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % integer_buff ( i ) = from_here ( r % from ( ipto )% k ( i )) end do call send ( r % integer_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine i_redist_12 subroutine i_redist_22 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r integer , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):), intent ( in ) :: from_here integer , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) & = from_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % integer_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i )) end do call send ( r % integer_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % integer_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % integer_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % integer_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % integer_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % integer_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i )) end do call send ( r % integer_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine i_redist_22 subroutine i_redist_22_inv ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r integer , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in ) :: from_here integer , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % to ( iproc )% nn to_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i )) & = from_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % integer_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % integer_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % integer_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i )) & = r % integer_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % integer_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i )) & = r % integer_buff ( i ) end do end if ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % integer_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % integer_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine i_redist_22_inv subroutine i_redist_32 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r integer , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in ) :: from_here integer , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) & = from_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % integer_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i )) end do call send ( r % integer_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % integer_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % integer_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % integer_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % integer_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % integer_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i )) end do call send ( r % integer_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine i_redist_32 subroutine i_redist_32_inv ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r integer , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in ) :: from_here integer , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % to ( iproc )% nn to_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i )) & = from_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % integer_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % integer_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % integer_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i )) & = r % integer_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % integer_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i )) & = r % integer_buff ( i ) end do end if ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % integer_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % integer_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine i_redist_32_inv subroutine i_redist_42 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r integer , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):, & r % from_low ( 4 ):), intent ( in ) :: from_here integer , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) & = from_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i ), & r % from ( iproc )% n ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % integer_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i ), & r % from ( ipto )% n ( i )) end do call send ( r % integer_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % integer_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % integer_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % integer_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % integer_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % integer_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i ), & r % from ( ipto )% n ( i )) end do call send ( r % integer_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine i_redist_42 subroutine i_redist_42_inv ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r integer , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in ) :: from_here integer , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):, & r % from_low ( 4 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % to ( iproc )% nn to_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i ), & r % from ( iproc )% n ( i )) & = from_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % integer_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % integer_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % integer_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i ), & r % from ( ipfrom )% n ( i )) & = r % integer_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % integer_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i ), & r % from ( ipfrom )% n ( i )) & = r % integer_buff ( i ) end do end if ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % integer_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % integer_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine i_redist_42_inv subroutine l_redist_12 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r logical , dimension ( r % from_low ( 1 ):), intent ( in ) :: from_here logical , dimension ( r % to_low ( 1 ):, r % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), r % to ( iproc )% l ( i )) & = from_here ( r % from ( iproc )% k ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % logical_buff ( i ) = from_here ( r % from ( ipto )% k ( i )) end do call send ( r % logical_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % logical_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % logical_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % logical_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % logical_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % logical_buff ( i ) = from_here ( r % from ( ipto )% k ( i )) end do call send ( r % logical_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine l_redist_12 subroutine l_redist_22 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r logical , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):), intent ( in ) :: from_here logical , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) & = from_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % logical_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i )) end do call send ( r % logical_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % logical_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % logical_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % logical_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % logical_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % logical_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i )) end do call send ( r % logical_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine l_redist_22 subroutine l_redist_22_inv ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r logical , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in ) :: from_here logical , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % to ( iproc )% nn to_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i )) & = from_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % logical_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % logical_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % logical_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i )) & = r % logical_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % logical_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i )) & = r % logical_buff ( i ) end do end if ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % logical_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % logical_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine l_redist_22_inv subroutine l_redist_32 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r logical , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in ) :: from_here logical , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) & = from_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % logical_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i )) end do call send ( r % logical_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % logical_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % logical_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % logical_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % logical_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % logical_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i )) end do call send ( r % logical_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine l_redist_32 subroutine l_redist_32_inv ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r logical , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in ) :: from_here logical , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % to ( iproc )% nn to_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i )) & = from_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % logical_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % logical_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % logical_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i )) & = r % logical_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % logical_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i )) & = r % logical_buff ( i ) end do end if ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % logical_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % logical_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine l_redist_32_inv subroutine l_redist_42 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r logical , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):, & r % from_low ( 4 ):), intent ( in ) :: from_here logical , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) & = from_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i ), & r % from ( iproc )% n ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % logical_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i ), & r % from ( ipto )% n ( i )) end do call send ( r % logical_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % logical_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % logical_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % logical_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % logical_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % logical_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i ), & r % from ( ipto )% n ( i )) end do call send ( r % logical_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine l_redist_42 subroutine l_redist_42_inv ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r logical , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in ) :: from_here logical , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):, & r % from_low ( 4 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % to ( iproc )% nn to_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i ), & r % from ( iproc )% n ( i )) & = from_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % logical_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % logical_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % logical_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i ), & r % from ( ipfrom )% n ( i )) & = r % logical_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % logical_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i ), & r % from ( ipfrom )% n ( i )) & = r % logical_buff ( i ) end do end if ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % logical_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % logical_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine l_redist_42_inv ! TT> subroutine c_redist_33 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in ) :: from_here complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):, & r % to_low ( 3 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i ), & r % to ( iproc )% m ( i )) & = from_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % complex_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i )) end do call send ( r % complex_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i ), & r % to ( ipfrom )% m ( i )) & = r % complex_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i ), & r % to ( ipfrom )% m ( i )) & = r % complex_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % complex_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i )) end do call send ( r % complex_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine c_redist_33 subroutine c_redist_33_inv ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):, & r % to_low ( 3 ):), intent ( in ) :: from_here complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % to ( iproc )% nn to_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i )) & = from_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i ), & r % to ( iproc )% m ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % complex_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i ), & r % to ( ipto )% m ( i )) end do call send ( r % complex_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i )) & = r % complex_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i )) & = r % complex_buff ( i ) end do end if ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % complex_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i ), & r % to ( ipto )% m ( i )) end do call send ( r % complex_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine c_redist_33_inv ! <TT subroutine c_fill_2 ( f , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: f complex , dimension ( f % from_low ( 1 ):, & f % from_low ( 2 ):), intent ( in ) :: from_here complex , dimension ( f % to_low ( 1 ):, & f % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , f % from ( iproc )% nn to_here ( f % to ( iproc )% k ( i ), & f % to ( iproc )% l ( i )) & = from_here ( f % from ( iproc )% k ( i ), & f % from ( iproc )% l ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % complex_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i )) end do call send ( f % complex_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % complex_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i )) & = f % complex_buff ( i ) end do end if else ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % complex_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i )) & = f % complex_buff ( i ) end do end if ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % complex_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i )) end do call send ( f % complex_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine c_fill_2 subroutine c_fill_3 ( f , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: f complex , dimension ( f % from_low ( 1 ):, & f % from_low ( 2 ):, & f % from_low ( 3 ):), intent ( in ) :: from_here complex , dimension ( f % to_low ( 1 ):, & f % to_low ( 2 ):, & f % to_low ( 3 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , f % from ( iproc )% nn to_here ( f % to ( iproc )% k ( i ), & f % to ( iproc )% l ( i ), & f % to ( iproc )% m ( i )) & = from_here ( f % from ( iproc )% k ( i ), & f % from ( iproc )% l ( i ), & f % from ( iproc )% m ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % complex_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i ), & f % from ( ipto )% m ( i )) end do call send ( f % complex_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % complex_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i ), & f % to ( ipfrom )% m ( i )) & = f % complex_buff ( i ) end do end if else ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % complex_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i ), & f % to ( ipfrom )% m ( i )) & = f % complex_buff ( i ) end do end if ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % complex_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i ), & f % from ( ipto )% m ( i )) end do call send ( f % complex_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine c_fill_3 subroutine c_fill_4 ( f , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: f complex , dimension ( f % from_low ( 1 ):, & f % from_low ( 2 ):, & f % from_low ( 3 ):, & f % from_low ( 4 ):), intent ( in ) :: from_here complex , dimension ( f % to_low ( 1 ):, & f % to_low ( 2 ):, & f % to_low ( 3 ):, & f % to_low ( 4 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , f % from ( iproc )% nn to_here ( f % to ( iproc )% k ( i ), & f % to ( iproc )% l ( i ), & f % to ( iproc )% m ( i ), & f % to ( iproc )% n ( i )) & = from_here ( f % from ( iproc )% k ( i ), & f % from ( iproc )% l ( i ), & f % from ( iproc )% m ( i ), & f % from ( iproc )% n ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % complex_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i ), & f % from ( ipto )% m ( i ), & f % from ( ipto )% n ( i )) end do call send ( f % complex_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % complex_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i ), & f % to ( ipfrom )% m ( i ), & f % to ( ipfrom )% n ( i )) & = f % complex_buff ( i ) end do end if else ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % complex_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i ), & f % to ( ipfrom )% m ( i ), & f % to ( ipfrom )% n ( i )) & = f % complex_buff ( i ) end do end if ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % complex_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i ), & f % from ( ipto )% m ( i ), & f % from ( ipto )% n ( i )) end do call send ( f % complex_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine c_fill_4 subroutine r_fill_2 ( f , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: f real , dimension ( f % from_low ( 1 ):, & f % from_low ( 2 ):), intent ( in ) :: from_here real , dimension ( f % to_low ( 1 ):, & f % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , f % from ( iproc )% nn to_here ( f % to ( iproc )% k ( i ), & f % to ( iproc )% l ( i )) & = from_here ( f % from ( iproc )% k ( i ), & f % from ( iproc )% l ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % real_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i )) end do call send ( f % real_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % real_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i )) & = f % real_buff ( i ) end do end if else ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % real_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i )) & = f % real_buff ( i ) end do end if ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % real_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i )) end do call send ( f % real_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine r_fill_2 subroutine r_fill_3 ( f , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: f real , dimension ( f % from_low ( 1 ):, & f % from_low ( 2 ):, & f % from_low ( 3 ):), intent ( in ) :: from_here real , dimension ( f % to_low ( 1 ):, & f % to_low ( 2 ):, & f % to_low ( 3 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , f % from ( iproc )% nn to_here ( f % to ( iproc )% k ( i ), & f % to ( iproc )% l ( i ), & f % to ( iproc )% m ( i )) & = from_here ( f % from ( iproc )% k ( i ), & f % from ( iproc )% l ( i ), & f % from ( iproc )% m ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % real_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i ), & f % from ( ipto )% m ( i )) end do call send ( f % real_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % real_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i ), & f % to ( ipfrom )% m ( i )) & = f % real_buff ( i ) end do end if else ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % real_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i ), & f % to ( ipfrom )% m ( i )) & = f % real_buff ( i ) end do end if ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % real_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i ), & f % from ( ipto )% m ( i )) end do call send ( f % real_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine r_fill_3 subroutine r_fill_4 ( f , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: f real , dimension ( f % from_low ( 1 ):, & f % from_low ( 2 ):, & f % from_low ( 3 ):, & f % from_low ( 4 ):), intent ( in ) :: from_here real , dimension ( f % to_low ( 1 ):, & f % to_low ( 2 ):, & f % to_low ( 3 ):, & f % to_low ( 4 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , f % from ( iproc )% nn to_here ( f % to ( iproc )% k ( i ), & f % to ( iproc )% l ( i ), & f % to ( iproc )% m ( i ), & f % to ( iproc )% n ( i )) & = from_here ( f % from ( iproc )% k ( i ), & f % from ( iproc )% l ( i ), & f % from ( iproc )% m ( i ), & f % from ( iproc )% n ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % real_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i ), & f % from ( ipto )% m ( i ), & f % from ( ipto )% n ( i )) end do call send ( f % real_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % real_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i ), & f % to ( ipfrom )% m ( i ), & f % to ( ipfrom )% n ( i )) & = f % real_buff ( i ) end do end if else ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % real_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i ), & f % to ( ipfrom )% m ( i ), & f % to ( ipfrom )% n ( i )) & = f % real_buff ( i ) end do end if ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % real_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i ), & f % from ( ipto )% m ( i ), & f % from ( ipto )% n ( i )) end do call send ( f % real_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine r_fill_4 subroutine i_fill_2 ( f , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: f integer , dimension ( f % from_low ( 1 ):, & f % from_low ( 2 ):), intent ( in ) :: from_here integer , dimension ( f % to_low ( 1 ):, & f % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , f % from ( iproc )% nn to_here ( f % to ( iproc )% k ( i ), & f % to ( iproc )% l ( i )) & = from_here ( f % from ( iproc )% k ( i ), & f % from ( iproc )% l ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % integer_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i )) end do call send ( f % integer_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % integer_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i )) & = f % integer_buff ( i ) end do end if else ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % integer_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i )) & = f % integer_buff ( i ) end do end if ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % integer_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i )) end do call send ( f % integer_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine i_fill_2 subroutine i_fill_3 ( f , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: f integer , dimension ( f % from_low ( 1 ):, & f % from_low ( 2 ):, & f % from_low ( 3 ):), intent ( in ) :: from_here integer , dimension ( f % to_low ( 1 ):, & f % to_low ( 2 ):, & f % to_low ( 3 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , f % from ( iproc )% nn to_here ( f % to ( iproc )% k ( i ), & f % to ( iproc )% l ( i ), & f % to ( iproc )% m ( i )) & = from_here ( f % from ( iproc )% k ( i ), & f % from ( iproc )% l ( i ), & f % from ( iproc )% m ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % integer_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i ), & f % from ( ipto )% m ( i )) end do call send ( f % integer_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % integer_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i ), & f % to ( ipfrom )% m ( i )) & = f % integer_buff ( i ) end do end if else ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % integer_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i ), & f % to ( ipfrom )% m ( i )) & = f % integer_buff ( i ) end do end if ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % integer_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i ), & f % from ( ipto )% m ( i )) end do call send ( f % integer_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine i_fill_3 subroutine i_fill_4 ( f , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: f integer , dimension ( f % from_low ( 1 ):, & f % from_low ( 2 ):, & f % from_low ( 3 ):, & f % from_low ( 4 ):), intent ( in ) :: from_here integer , dimension ( f % to_low ( 1 ):, & f % to_low ( 2 ):, & f % to_low ( 3 ):, & f % to_low ( 4 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , f % from ( iproc )% nn to_here ( f % to ( iproc )% k ( i ), & f % to ( iproc )% l ( i ), & f % to ( iproc )% m ( i ), & f % to ( iproc )% n ( i )) & = from_here ( f % from ( iproc )% k ( i ), & f % from ( iproc )% l ( i ), & f % from ( iproc )% m ( i ), & f % from ( iproc )% n ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % integer_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i ), & f % from ( ipto )% m ( i ), & f % from ( ipto )% n ( i )) end do call send ( f % integer_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % integer_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i ), & f % to ( ipfrom )% m ( i ), & f % to ( ipfrom )% n ( i )) & = f % integer_buff ( i ) end do end if else ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % integer_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i ), & f % to ( ipfrom )% m ( i ), & f % to ( ipfrom )% n ( i )) & = f % integer_buff ( i ) end do end if ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % integer_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i ), & f % from ( ipto )% m ( i ), & f % from ( ipto )% n ( i )) end do call send ( f % integer_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine i_fill_4 subroutine l_fill_2 ( f , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: f logical , dimension ( f % from_low ( 1 ):, & f % from_low ( 2 ):), intent ( in ) :: from_here logical , dimension ( f % to_low ( 1 ):, & f % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , f % from ( iproc )% nn to_here ( f % to ( iproc )% k ( i ), & f % to ( iproc )% l ( i )) & = from_here ( f % from ( iproc )% k ( i ), & f % from ( iproc )% l ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % logical_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i )) end do call send ( f % logical_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % logical_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i )) & = f % logical_buff ( i ) end do end if else ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % logical_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i )) & = f % logical_buff ( i ) end do end if ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % logical_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i )) end do call send ( f % logical_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine l_fill_2 subroutine l_fill_3 ( f , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: f logical , dimension ( f % from_low ( 1 ):, & f % from_low ( 2 ):, & f % from_low ( 3 ):), intent ( in ) :: from_here logical , dimension ( f % to_low ( 1 ):, & f % to_low ( 2 ):, & f % to_low ( 3 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , f % from ( iproc )% nn to_here ( f % to ( iproc )% k ( i ), & f % to ( iproc )% l ( i ), & f % to ( iproc )% m ( i )) & = from_here ( f % from ( iproc )% k ( i ), & f % from ( iproc )% l ( i ), & f % from ( iproc )% m ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % logical_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i ), & f % from ( ipto )% m ( i )) end do call send ( f % logical_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % logical_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i ), & f % to ( ipfrom )% m ( i )) & = f % logical_buff ( i ) end do end if else ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % logical_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i ), & f % to ( ipfrom )% m ( i )) & = f % logical_buff ( i ) end do end if ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % logical_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i ), & f % from ( ipto )% m ( i )) end do call send ( f % logical_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine l_fill_3 subroutine l_fill_4 ( f , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: f logical , dimension ( f % from_low ( 1 ):, & f % from_low ( 2 ):, & f % from_low ( 3 ):, & f % from_low ( 4 ):), intent ( in ) :: from_here logical , dimension ( f % to_low ( 1 ):, & f % to_low ( 2 ):, & f % to_low ( 3 ):, & f % to_low ( 4 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , f % from ( iproc )% nn to_here ( f % to ( iproc )% k ( i ), & f % to ( iproc )% l ( i ), & f % to ( iproc )% m ( i ), & f % to ( iproc )% n ( i )) & = from_here ( f % from ( iproc )% k ( i ), & f % from ( iproc )% l ( i ), & f % from ( iproc )% m ( i ), & f % from ( iproc )% n ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % logical_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i ), & f % from ( ipto )% m ( i ), & f % from ( ipto )% n ( i )) end do call send ( f % logical_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % logical_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i ), & f % to ( ipfrom )% m ( i ), & f % to ( ipfrom )% n ( i )) & = f % logical_buff ( i ) end do end if else ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % logical_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i ), & f % to ( ipfrom )% m ( i ), & f % to ( ipfrom )% n ( i )) & = f % logical_buff ( i ) end do end if ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % logical_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i ), & f % from ( ipto )% m ( i ), & f % from ( ipto )% n ( i )) end do call send ( f % logical_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine l_fill_4 subroutine report_map_property ( r ) use mp , only : iproc , nproc , proc0 , sum_reduce , max_reduce type ( redist_type ), intent ( in ) :: r type :: redist_prp integer :: local_max , local_total integer :: comm_max , comm_total integer :: elm_max , elm_total end type redist_prp type ( redist_prp ) :: prp integer :: ip , rank_from , rank_to integer , dimension (:), allocatable :: lbd_from , lbd_to prp % comm_max = 0 prp % comm_total = 0 prp % elm_total = 0 do ip = 0 , nproc - 1 if ( ip == iproc ) then prp % local_total = r % to ( ip )% nn else if ( r % to ( ip )% nn > 0 ) then prp % comm_total = prp % comm_total + 1 prp % elm_total = prp % elm_total + r % to ( ip )% nn end if end if end do prp % local_max = prp % local_total prp % comm_max = prp % comm_total prp % elm_max = prp % elm_total call max_reduce ( prp % local_max , 0 ) call sum_reduce ( prp % local_total , 0 ) call max_reduce ( prp % comm_max , 0 ) call sum_reduce ( prp % comm_total , 0 ) call max_reduce ( prp % elm_max , 0 ) call sum_reduce ( prp % elm_total , 0 ) if ( proc0 ) then rank_from = 1 if ( associated ( r % from ( 0 )% l )) rank_from = 2 if ( associated ( r % from ( 0 )% m )) rank_from = 3 if ( associated ( r % from ( 0 )% n )) rank_from = 4 rank_to = 1 if ( associated ( r % to ( 0 )% l )) rank_to = 2 if ( associated ( r % to ( 0 )% m )) rank_to = 3 if ( associated ( r % to ( 0 )% n )) rank_to = 4 allocate ( lbd_from ( rank_from ), lbd_to ( rank_to )) lbd_from = r % from_low ( 1 : rank_from ) lbd_to = r % to_low ( 1 : rank_to ) print '(a,i2,a,i2)' , 'From rank' , rank_from , ' to rank' , rank_to print '(a,t20,4i10)' , 'From lbound (proc0)' , r % from_low ( 1 : rank_from ) print '(a,t20,4i10)' , 'To lbound (proc0)' , r % to_low ( 1 : rank_to ) print '(a,t49,a,t64,a)' , '--- Redistribution statistics ---' , & 'max' , 'avg' print '(a,t40,i12,t55,f15.2)' , 'Number of local move elements' , & prp % local_max , real ( prp % local_total ) / real ( nproc ) print '(a,t40,i12,t60,f10.2)' , & 'Number of inter-processor communications' , & prp % comm_max , real ( prp % comm_total ) / real ( nproc ) print '(a,t40,i12,t55,f15.2)' , & 'Number of inter-processor move elements' , & prp % elm_max , real ( prp % elm_total ) / real ( nproc ) print * end if end subroutine report_map_property subroutine measure_gather_32 ( map , gin , gout ) use job_manage , only : time_message use mp , only : proc0 type ( redist_type ), intent ( in out ) :: map complex , dimension (:, :, :), intent ( in ) :: gin complex , dimension (:, :), intent ( out ) :: gout if ( proc0 ) call time_message (. false ., time_redist , ' Redistribution' ) call c_redist_32 ( map , gin , gout ) if ( proc0 ) call time_message (. false ., time_redist , ' Redistribution' ) gather_count = gather_count + 1 end subroutine measure_gather_32 subroutine measure_scatter_23 ( map , gin , gout ) use job_manage , only : time_message use mp , only : proc0 type ( redist_type ), intent ( in out ) :: map complex , dimension (:, :), intent ( in ) :: gin complex , dimension (:, :, :), intent ( out ) :: gout if ( proc0 ) call time_message (. false ., time_redist , ' Redistribution' ) call c_redist_32_inv ( map , gin , gout ) if ( proc0 ) call time_message (. false ., time_redist , ' Redistribution' ) scatter_count = scatter_count + 1 end subroutine measure_scatter_23 subroutine measure_gather_33 ( map , gin , gout ) use job_manage , only : time_message use mp , only : proc0 type ( redist_type ), intent ( in out ) :: map complex , dimension (:, :, :), intent ( in ) :: gin complex , dimension (:, :, :), intent ( out ) :: gout if ( proc0 ) call time_message (. false ., time_redist , ' Redistribution' ) call c_redist_33 ( map , gin , gout ) if ( proc0 ) call time_message (. false ., time_redist , ' Redistribution' ) gather_count = gather_count + 1 end subroutine measure_gather_33 subroutine measure_scatter_33 ( map , gin , gout ) use job_manage , only : time_message use mp , only : proc0 type ( redist_type ), intent ( in out ) :: map complex , dimension (:, :, :), intent ( in ) :: gin complex , dimension (:, :, :), intent ( out ) :: gout if ( proc0 ) call time_message (. false ., time_redist , ' Redistribution' ) call c_redist_33_inv ( map , gin , gout ) if ( proc0 ) call time_message (. false ., time_redist , ' Redistribution' ) scatter_count = scatter_count + 1 end subroutine measure_scatter_33 subroutine measure_gather_22 ( map , gin , gout ) use job_manage , only : time_message use mp , only : proc0 type ( redist_type ), intent ( in out ) :: map complex , dimension (:, :), intent ( in ) :: gin complex , dimension (:, :), intent ( out ) :: gout if ( proc0 ) call time_message (. false ., time_redist , ' Redistribution' ) call c_redist_22 ( map , gin , gout ) if ( proc0 ) call time_message (. false ., time_redist , ' Redistribution' ) gather_count = gather_count + 1 end subroutine measure_gather_22 subroutine measure_scatter_22 ( map , gin , gout ) use job_manage , only : time_message use mp , only : proc0 type ( redist_type ), intent ( in out ) :: map complex , dimension (:, :), intent ( in ) :: gin complex , dimension (:, :), intent ( out ) :: gout if ( proc0 ) call time_message (. false ., time_redist , ' Redistribution' ) call c_redist_22_inv ( map , gin , gout ) if ( proc0 ) call time_message (. false ., time_redist , ' Redistribution' ) scatter_count = scatter_count + 1 end subroutine measure_scatter_22 end module redistribute","tags":"","loc":"sourcefile/redistribute.f90.html"},{"title":"job_manage.fpp â€“ stella","text":"Contents Modules job_manage Source Code job_manage.fpp Source Code # include \"define.inc\" module job_manage implicit none private public :: timer_local public :: time_message public :: job_fork public :: checkstop public :: checktime public :: njobs integer :: njobs = 1 contains !!! returns CPU time in second function timer_local () # ifdef MPI # ifndef MPIINC use mpi , only : mpi_wtime # else include \"mpif.h\" ! CMR following Michele Weiland's advice # endif # endif real :: timer_local timer_local = 0. # ifdef MPI timer_local = mpi_wtime () # else ! this routine is F95 standard call cpu_time ( timer_local ) # endif end function timer_local subroutine time_message ( lprint , targ , chmessage ) ! ! this routine counts elapse time between two calls ! character ( len =* ), intent ( in ) :: chmessage logical , intent ( in ) :: lprint real , intent ( in out ) :: targ ( 2 ) ! tsum and told real :: tnew tnew = timer_local () if ( abs ( targ ( 2 )) < epsilon ( 0. )) then targ ( 2 ) = tnew else targ ( 1 ) = targ ( 1 ) + tnew - targ ( 2 ) if ( lprint ) write ( * , '(A24,F7.2,A8)' ) chmessage , tnew - targ ( 2 ), ' seconds' targ ( 2 ) = 0. end if end subroutine time_message subroutine job_fork ( n_ensembles ) use file_utils , only : get_unused_unit , list_name , run_name , init_job_name ! MAB> -- moved init_error_unit and init_input_unit calls here from file_utils ! because they were being called there on all procs when they should be called ! only on proc0 use file_utils , only : init_error_unit , init_input_unit , list_name ! <MAB use mp , only : job , scope , min_proc use mp , only : proc0 , nproc use mp , only : init_job_topology , broadcast , finish_mp implicit none integer , intent ( in ), optional :: n_ensembles integer , dimension (:), allocatable :: group0 integer :: i , l character ( 10 ) :: ext character ( len = 500 ), dimension (:), allocatable :: job_list integer :: list_unit , ierr logical :: err = . true ., inp = . true . ! open file containing list of input files to run and read total ! number of input files from first line if (. not . present ( n_ensembles )) then if ( proc0 ) then call get_unused_unit ( list_unit ) open ( unit = list_unit , file = trim ( list_name )) read ( list_unit , * ) njobs end if else njobs = n_ensembles end if call broadcast ( njobs ) if ( nproc < njobs ) then if ( proc0 ) then write ( * , * ) write ( * , * ) 'Number of jobs = ' , njobs , ' and number of processors = ' , nproc write ( * , * ) 'Number of processors must not be less than the number of jobs' write ( * , * ) 'Stopping' write ( * , * ) end if call finish_mp stop end if if ( mod ( nproc , njobs ) /= 0 ) then if ( proc0 ) then write ( * , * ) write ( * , * ) 'Number of jobs = ' , njobs , ' and number of processors = ' , nproc write ( * , * ) 'Number of jobs must evenly divide the number of processors.' write ( * , * ) 'Stopping' write ( * , * ) end if call finish_mp stop end if allocate ( job_list ( 0 : njobs - 1 )) if ( proc0 ) then if (. not . present ( n_ensembles )) then do i = 0 , njobs - 1 read ( list_unit , fmt = \"(a)\" ) job_list ( i ) end do close ( list_unit ) else l = len_trim ( list_name ) do i = 0 , njobs - 1 write ( ext , '(i9)' ) i + 1 ext = adjustl ( ext ) job_list ( i ) = trim ( list_name ( 1 : l - 3 )) // \"_\" // trim ( ext ) end do end if end if do i = 0 , njobs - 1 call broadcast ( job_list ( i )) end do allocate ( group0 ( 0 : njobs - 1 )) call init_job_topology ( njobs , group0 , ierr ) ! TT> brought up one line [call scope(subprocs)] from file_utils.fpp !     to init_jobs !    call init_job_name (njobs, group0, job_list) call init_job_name ( job_list ( job )) ! <TT ! MAB> moved from file_utils because had to be within proc0, ! which is undefined there if ( proc0 ) then call init_error_unit ( err ) call init_input_unit ( inp ) end if ! <MAB if ( nproc > 1 . and . proc0 ) & & write ( * , * ) 'Job ' , job , ' is called ' , trim ( run_name ),& & ' and is running on ' , nproc , ' processors with a minimum of' , & & min_proc , ' processors on a node' if ( nproc == 1 ) write ( * , * ) 'Job ' , job , ' is called ' , trim ( run_name ),& & ' and is running on ' , nproc , ' processors with a minimum of' , & & min_proc , ' processors on a node' deallocate ( group0 , job_list ) ! MAB end subroutine job_fork subroutine checkstop ( exit , list ) use mp , only : proc0 , broadcast use file_utils , only : run_name , list_name logical , intent ( in ), optional :: list logical , intent ( in out ) :: exit character ( len = 300 ) :: filename logical :: exit_local ! If .stop file has appeared, set exit flag filename = trim ( run_name ) // \".stop\" if ( present ( list )) then if ( list ) filename = list_name (: len_trim ( list_name ) - 5 ) // \".stop\" end if if ( proc0 ) then inquire ( file = filename , exist = exit_local ) exit = exit . or . exit_local end if call broadcast ( exit ) end subroutine checkstop subroutine checktime ( avail_time , exit ) use mp , only : proc0 , broadcast use file_utils , only : error_unit ! available time in second real , intent ( in ) :: avail_time ! true if elapse time exceed available time logical , intent ( in out ) :: exit logical , save :: initialized = . false . real :: elapse_time = 0. real :: initial_time = 0. real :: margin = 30 0. ! 5 minutes if (. not . initialized ) then initial_time = timer_local () ! timer_local() returns #seconds from fixed time in past initialized = . true . return end if elapse_time = timer_local () - initial_time if ( proc0 ) then if ( elapse_time >= avail_time - margin ) then write ( error_unit (), '(a,f12.4,a,f12.4)' ) & & 'Elapse time ' , elapse_time , & & ' exceeds available time' , avail_time - margin write ( error_unit (), '(a,f12.4,a,f12.4,a)' ) & & '  (Given CPU time: ' , avail_time , & & '  Margin: ' , margin , ')' exit = . true . end if end if call broadcast ( exit ) end subroutine checktime end module job_manage","tags":"","loc":"sourcefile/job_manage.fpp.html"},{"title":"ran.fpp â€“ stella","text":"Contents Modules ran Source Code ran.fpp Source Code # include \"define.inc\" module ran ! <doc> !  A wrapper module for random number generator. !  Thie module provides real function ranf !  using intrinsic random_number/random_seed or !  Mersenne Twister 19937 (see mt19937.f90). !  Note that instrinsic function appears to use !  and integer vector seed of length 2, but this !  is implementation dependent.  If there is ever !  a system that uses seed integer vector of !  different length, an error message will print. ! </doc> implicit none private public :: ranf public :: get_rnd_seed_length , get_rnd_seed , init_ranf contains !------------------------------------------------------------------- function ranf ( seed ) ! <doc> !  returns a uniform deviate in [0., 1.) !  The generator is initialized with the given seed if exists, !  otherwise uses the default seed. ! </doc> # if RANDOM == _RANMT_ use mt19937 , only : sgrnd , grnd # endif integer , intent ( in ), optional :: seed real :: ranf # if RANDOM == _RANMT_ if ( present ( seed )) call sgrnd ( seed ) ranf = grnd () # else integer :: l integer , allocatable :: seed_in (:) if ( present ( seed )) then call random_seed ( size = l ) allocate ( seed_in ( l )) seed_in (:) = seed call random_seed ( put = seed_in ) deallocate ( seed_in ) end if call random_number ( ranf ) # endif end function ranf !------------------------------------------------------------------- function get_rnd_seed_length () result ( l ) ! <doc> !  get_rnd_seed_length gets the length of the integer vector for !      the random number generator seed ! </doc> integer :: l # if RANDOM == _RANMT_ l = 1 # else call random_seed ( size = l ) # endif end function get_rnd_seed_length !------------------------------------------------------------------- subroutine get_rnd_seed ( seed ) ! <doc> !  get_rnd_seed  random number seed integer vector ! </doc> integer , dimension (:), intent ( out ) :: seed # if RANDOM == _RANMT_ !NOTE: If MT is generator, more codding needs to be done to !      extract seed, so this should be run using only randomize seed = 0 # else call random_seed ( get = seed ) # endif end subroutine get_rnd_seed !------------------------------------------------------------------- subroutine init_ranf ( randomize , init_seed , mult ) # if RANDOM == _RANMT_ use mt19937 , only : sgrnd , grnd # endif ! <doc> !  init_ranf seeds the choosen random number generator. !  if randomize=T, a random seed based on the date and time is used. !  Otherwise, it sets the seed using init_seed !  In either case, it outputs the initial seed in init_seed ! </doc> implicit none logical , intent ( in ) :: randomize integer , intent ( inout ), dimension (:) :: init_seed integer , optional , intent ( in ) :: mult integer :: lmult = 1 , clock # if RANDOM == _RANMT_ if ( present ( mult )) then lmult = mult end if if ( randomize ) then call system_clock ( COUNT = clock ) init_seed ( 1 ) = clock * lmult call sgrnd ( init_seed ( 1 )) else call sgrnd ( init_seed ( 1 ) * lmult ) end if # else integer :: i , n if ( present ( mult )) then lmult = mult end if if ( randomize ) then call random_seed ( size = n ) call system_clock ( count = clock ) init_seed = clock + 37 * lmult * ( / ( i - 1 , i = 1 , n ) / ) call random_seed ( put = init_seed ) else call random_seed ( put = init_seed * lmult ) end if # endif end subroutine init_ranf end module ran","tags":"","loc":"sourcefile/ran.fpp.html"},{"title":"kxkyz_layout_type â€“ stella ","text":"type, public :: kxkyz_layout_type sequence Contents Variables iproc nzgrid nzed ntubes naky nakx nvgrid nvpa nmu nspec llim_world ulim_world llim_proc ulim_proc ulim_alloc blocksize Components Type Visibility Attributes Name Initial integer, public :: iproc integer, public :: nzgrid integer, public :: nzed integer, public :: ntubes integer, public :: naky integer, public :: nakx integer, public :: nvgrid integer, public :: nvpa integer, public :: nmu integer, public :: nspec integer, public :: llim_world integer, public :: ulim_world integer, public :: llim_proc integer, public :: ulim_proc integer, public :: ulim_alloc integer, public :: blocksize","tags":"","loc":"type/kxkyz_layout_type.html"},{"title":"kxyz_layout_type â€“ stella ","text":"type, public :: kxyz_layout_type sequence Contents Variables iproc nzgrid nzed ntubes ny naky nakx ikx_max nvgrid nvpa nmu nspec llim_world ulim_world llim_proc ulim_proc ulim_alloc blocksize Components Type Visibility Attributes Name Initial integer, public :: iproc integer, public :: nzgrid integer, public :: nzed integer, public :: ntubes integer, public :: ny integer, public :: naky integer, public :: nakx integer, public :: ikx_max integer, public :: nvgrid integer, public :: nvpa integer, public :: nmu integer, public :: nspec integer, public :: llim_world integer, public :: ulim_world integer, public :: llim_proc integer, public :: ulim_proc integer, public :: ulim_alloc integer, public :: blocksize","tags":"","loc":"type/kxyz_layout_type.html"},{"title":"xyz_layout_type â€“ stella ","text":"type, public :: xyz_layout_type sequence Contents Variables iproc nzgrid nzed ntubes ny naky nx nakx nvgrid nvpa nmu nspec llim_world ulim_world llim_proc ulim_proc ulim_alloc blocksize Components Type Visibility Attributes Name Initial integer, public :: iproc integer, public :: nzgrid integer, public :: nzed integer, public :: ntubes integer, public :: ny integer, public :: naky integer, public :: nx integer, public :: nakx integer, public :: nvgrid integer, public :: nvpa integer, public :: nmu integer, public :: nspec integer, public :: llim_world integer, public :: ulim_world integer, public :: llim_proc integer, public :: ulim_proc integer, public :: ulim_alloc integer, public :: blocksize","tags":"","loc":"type/xyz_layout_type.html"},{"title":"vmu_layout_type â€“ stella ","text":"type, public :: vmu_layout_type sequence Contents Variables xyz iproc nzgrid nzed ntubes nalpha ny naky nx nakx nvgrid nvpa nmu nspec llim_world ulim_world llim_proc ulim_proc ulim_alloc blocksize Components Type Visibility Attributes Name Initial logical, public :: xyz integer, public :: iproc integer, public :: nzgrid integer, public :: nzed integer, public :: ntubes integer, public :: nalpha integer, public :: ny integer, public :: naky integer, public :: nx integer, public :: nakx integer, public :: nvgrid integer, public :: nvpa integer, public :: nmu integer, public :: nspec integer, public :: llim_world integer, public :: ulim_world integer, public :: llim_proc integer, public :: ulim_proc integer, public :: ulim_alloc integer, public :: blocksize","tags":"","loc":"type/vmu_layout_type.html"},{"title":"flux_surface_type â€“ stella ","text":"type, public :: flux_surface_type Contents Variables rmaj rgeo kappa kapprim tri triprim rhoc dr shift qinp shat betaprim betadbprim d2qdr2 d2psidr2 dpsitordrho d2psitordrho2 rhotor drhotordrho psitor_lcfs zed0_fac rhoc_psi0 qinp_psi0 shat_psi0 Components Type Visibility Attributes Name Initial real, public :: rmaj real, public :: rgeo real, public :: kappa real, public :: kapprim real, public :: tri real, public :: triprim real, public :: rhoc real, public :: dr real, public :: shift real, public :: qinp real, public :: shat real, public :: betaprim real, public :: betadbprim real, public :: d2qdr2 real, public :: d2psidr2 real, public :: dpsitordrho real, public :: d2psitordrho2 real, public :: rhotor real, public :: drhotordrho real, public :: psitor_lcfs real, public :: zed0_fac real, public :: rhoc_psi0 real, public :: qinp_psi0 real, public :: shat_psi0","tags":"","loc":"type/flux_surface_type.html"},{"title":"spec_type â€“ stella ","text":"type, public :: spec_type Contents Variables nspec z mass dens temp tprim fprim vnew_ref stm zstm tz smz zt d2ndr2 d2Tdr2 bess_fac vnew type dens_psi0 temp_psi0 stm_psi0 zstm_psi0 tz_psi0 smz_psi0 zt_psi0 Components Type Visibility Attributes Name Initial integer, public :: nspec real, public :: z real, public :: mass real, public :: dens real, public :: temp real, public :: tprim real, public :: fprim real, public :: vnew_ref real, public :: stm real, public :: zstm real, public :: tz real, public :: smz real, public :: zt real, public :: d2ndr2 real, public :: d2Tdr2 real, public :: bess_fac real, public, dimension(10) :: vnew integer, public :: type real, public :: dens_psi0 real, public :: temp_psi0 real, public :: stm_psi0 real, public :: zstm_psi0 real, public :: tz_psi0 real, public :: smz_psi0 real, public :: zt_psi0","tags":"","loc":"type/spec_type.html"},{"title":"eigen_type â€“ stella ","text":"type, public :: eigen_type Contents Variables zloc idx Components Type Visibility Attributes Name Initial complex, public, dimension(:, :), pointer :: zloc => null() integer, public, dimension(:), pointer :: idx => null()","tags":"","loc":"type/eigen_type.html"},{"title":"response_matrix_type â€“ stella ","text":"type, public :: response_matrix_type Contents Variables eigen Components Type Visibility Attributes Name Initial type( eigen_type ), public, dimension(:), pointer :: eigen => null()","tags":"","loc":"type/response_matrix_type.html"},{"title":"coupled_alpha_type â€“ stella ","text":"type, public :: coupled_alpha_type Contents Variables max_idx fourier Components Type Visibility Attributes Name Initial integer, public :: max_idx complex, public, dimension(:), pointer :: fourier => null()","tags":"","loc":"type/coupled_alpha_type.html"},{"title":"gam0_ffs_type â€“ stella ","text":"type, public :: gam0_ffs_type Contents Variables pivot_index matrix Components Type Visibility Attributes Name Initial integer, public, dimension(:), pointer :: pivot_index => null() complex, public, dimension(:, :), pointer :: matrix => null()","tags":"","loc":"type/gam0_ffs_type.html"},{"title":"fft_type â€“ stella ","text":"type, public :: fft_type Contents Variables n is type plan scale Components Type Visibility Attributes Name Initial integer, private :: n integer, private :: is integer, private :: type integer(kind=kind_id), private :: plan real, private :: scale","tags":"","loc":"type/fft_type.html"},{"title":"spline â€“ stella ","text":"type, public :: spline Contents Variables n x y y2 Components Type Visibility Attributes Name Initial integer, public :: n real, public, dimension(:), pointer :: x real, public, dimension(:), pointer :: y real, public, dimension(:), pointer :: y2","tags":"","loc":"type/spline.html"},{"title":"periodic_spline â€“ stella ","text":"type, public :: periodic_spline Contents Variables n period x y y2 Components Type Visibility Attributes Name Initial integer, public :: n real, public :: period real, public, dimension(:), pointer :: x real, public, dimension(:), pointer :: y real, public, dimension(:), pointer :: y2","tags":"","loc":"type/periodic_spline.html"},{"title":"text_option â€“ stella ","text":"type, public :: text_option Contents Variables name value Components Type Visibility Attributes Name Initial character, private :: name integer, private :: value","tags":"","loc":"type/text_option.html"},{"title":"index_map â€“ stella ","text":"type, private :: index_map Contents Variables nn k l m n o Components Type Visibility Attributes Name Initial integer, private :: nn integer, private, dimension(:), pointer :: k => null() integer, private, dimension(:), pointer :: l => null() integer, private, dimension(:), pointer :: m => null() integer, private, dimension(:), pointer :: n => null() integer, private, dimension(:), pointer :: o => null()","tags":"","loc":"type/index_map.html"},{"title":"redist_type â€“ stella ","text":"type, public :: redist_type Contents Variables to_low from_low to_high from_high to from complex_buff real_buff integer_buff logical_buff redistname Components Type Visibility Attributes Name Initial integer, private, dimension(5) :: to_low integer, private, dimension(5) :: from_low integer, private, dimension(5) :: to_high integer, private, dimension(5) :: from_high type( index_map ), private, dimension(:), pointer :: to => null() type( index_map ), private, dimension(:), pointer :: from => null() complex, private, dimension(:), pointer :: complex_buff => null() real, private, dimension(:), pointer :: real_buff => null() integer, private, dimension(:), pointer :: integer_buff => null() logical, private, dimension(:), pointer :: logical_buff => null() character(len=3), private :: redistname = \"\"","tags":"","loc":"type/redist_type.html"},{"title":"index_list_type â€“ stella ","text":"type, public :: index_list_type Contents Variables first second third fourth fifth Components Type Visibility Attributes Name Initial integer, private, dimension(:), pointer :: first => null() integer, private, dimension(:), pointer :: second => null() integer, private, dimension(:), pointer :: third => null() integer, private, dimension(:), pointer :: fourth => null() integer, private, dimension(:), pointer :: fifth => null()","tags":"","loc":"type/index_list_type.html"},{"title":"getcarg â€“ stella","text":"subroutine getcarg(narg, arg, numargs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: narg character(len=*), intent(out) :: arg integer, intent(out) :: numargs Contents None","tags":"","loc":"proc/getcarg.html"},{"title":"handle_err â€“ stella","text":"subroutine handle_err(status, nam3, nam1, nam2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: status character(len=*), intent(in) :: nam3 character(len=*), intent(in) :: nam1 character(len=*), intent(in) :: nam2 Contents None","tags":"","loc":"proc/handle_err.html"},{"title":"parse_extension â€“ stella","text":"subroutine parse_extension(file_to_parse, file_or_extension, lnc) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: file_to_parse character(len=*), intent(in) :: file_or_extension logical, intent(out) :: lnc Contents None","tags":"","loc":"proc/parse_extension.html"},{"title":"vmec_getenv â€“ stella","text":"subroutine vmec_getenv(ename, evalue) Arguments Type Intent Optional Attributes Name character(len=*) :: ename character(len=*) :: evalue Contents None","tags":"","loc":"proc/vmec_getenv.html"},{"title":"init_stella_io â€“ stella","text":"public subroutine init_stella_io(restart, write_phi_vs_t, write_kspectra, write_gvmus, write_gzvs, write_moments, write_omega, write_radial_fluxes, write_radial_moments, write_fluxes_kxky) Uses mp file_utils Arguments Type Intent Optional Attributes Name logical, intent(in) :: restart logical, intent(in) :: write_phi_vs_t logical, intent(in) :: write_kspectra logical, intent(in) :: write_gvmus logical, intent(in) :: write_gzvs logical, intent(in) :: write_moments logical, intent(in) :: write_omega logical, intent(in) :: write_radial_fluxes logical, intent(in) :: write_radial_moments logical, intent(in) :: write_fluxes_kxky Contents None","tags":"","loc":"proc/init_stella_io.html"},{"title":"define_dims â€“ stella","text":"private subroutine define_dims() Uses vpamu_grids physics_flags species file_utils zgrid kt_grids Arguments None Contents None","tags":"","loc":"proc/define_dims.html"},{"title":"finish_stella_io â€“ stella","text":"public subroutine finish_stella_io() Uses mp Arguments None Contents None","tags":"","loc":"proc/finish_stella_io.html"},{"title":"save_input â€“ stella","text":"private subroutine save_input() doc> Save the input file in the NetCDF file Arguments None Contents None","tags":"","loc":"proc/save_input.html"},{"title":"define_vars â€“ stella","text":"private subroutine define_vars(write_phi_vs_t, write_kspectra, write_gvmus, write_gzvs, write_moments, write_omega, write_radial_fluxes, write_radial_moments, write_fluxes_kxky) Uses run_parameters mp physics_flags Arguments Type Intent Optional Attributes Name logical, intent(in) :: write_phi_vs_t logical, intent(in) :: write_kspectra logical, intent(in) :: write_gvmus logical, intent(in) :: write_gzvs logical, intent(in) :: write_moments logical, intent(in) :: write_omega logical, intent(in) :: write_radial_fluxes logical, intent(in) :: write_radial_moments logical, intent(in) :: write_fluxes_kxky Contents None","tags":"","loc":"proc/define_vars.html"},{"title":"write_time_nc â€“ stella","text":"public subroutine write_time_nc(nout, time) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout real, intent(in) :: time Contents None","tags":"","loc":"proc/write_time_nc.html"},{"title":"write_phi2_nc â€“ stella","text":"public subroutine write_phi2_nc(nout, phi2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout real, intent(in) :: phi2 Contents None","tags":"","loc":"proc/write_phi2_nc.html"},{"title":"write_phi_nc â€“ stella","text":"public subroutine write_phi_nc(nout, phi) Uses kt_grids zgrid convert Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi Contents None","tags":"","loc":"proc/write_phi_nc.html"},{"title":"write_omega_nc â€“ stella","text":"public subroutine write_omega_nc(nout, omega) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout complex, intent(in), dimension(:, :) :: omega Contents None","tags":"","loc":"proc/write_omega_nc.html"},{"title":"write_radial_fluxes_nc â€“ stella","text":"public subroutine write_radial_fluxes_nc(nout, pflux, vflux, qflux) Uses kt_grids species Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout real, intent(in), dimension(:, :) :: pflux real, intent(in), dimension(:, :) :: vflux real, intent(in), dimension(:, :) :: qflux Contents None","tags":"","loc":"proc/write_radial_fluxes_nc.html"},{"title":"write_radial_moments_nc â€“ stella","text":"public subroutine write_radial_moments_nc(nout, dens_x, upar_x, temp_x) Uses kt_grids species Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout real, intent(in), dimension(:, :) :: dens_x real, intent(in), dimension(:, :) :: upar_x real, intent(in), dimension(:, :) :: temp_x Contents None","tags":"","loc":"proc/write_radial_moments_nc.html"},{"title":"write_kspectra_nc â€“ stella","text":"public subroutine write_kspectra_nc(nout, phi2_vs_kxky) Uses kt_grids Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout real, intent(in), dimension(:, :) :: phi2_vs_kxky Contents None","tags":"","loc":"proc/write_kspectra_nc.html"},{"title":"write_fluxes_kxkyz_nc â€“ stella","text":"public subroutine write_fluxes_kxkyz_nc(nout, pflx_kxkyz, vflx_kxkyz, qflx_kxkyz) Uses zgrid kt_grids species Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout real, intent(in), dimension(:, :, :, :, :) :: pflx_kxkyz real, intent(in), dimension(:, :, :, :, :) :: vflx_kxkyz real, intent(in), dimension(:, :, :, :, :) :: qflx_kxkyz Contents None","tags":"","loc":"proc/write_fluxes_kxkyz_nc.html"},{"title":"write_moments_nc â€“ stella","text":"public subroutine write_moments_nc(nout, density, upar, temperature, spitzer2) Uses kt_grids zgrid convert species Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout complex, intent(in), dimension(:, :, :, :, :) :: density complex, intent(in), dimension(:, :, :, :, :) :: upar complex, intent(in), dimension(:, :, :, :, :) :: temperature complex, intent(in), dimension(:, :, :, :, :) :: spitzer2 Contents None","tags":"","loc":"proc/write_moments_nc.html"},{"title":"write_gvmus_nc â€“ stella","text":"public subroutine write_gvmus_nc(nout, g) Uses vpamu_grids species Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout real, intent(in), dimension(:, :, :) :: g Contents None","tags":"","loc":"proc/write_gvmus_nc.html"},{"title":"write_gzvs_nc â€“ stella","text":"public subroutine write_gzvs_nc(nout, g) Uses zgrid species vpamu_grids Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout real, intent(in), dimension(:, :, :, :) :: g Contents None","tags":"","loc":"proc/write_gzvs_nc.html"},{"title":"nc_grids â€“ stella","text":"private subroutine nc_grids() Uses stella_geometry vpamu_grids physics_flags species physics_parameters zgrid kt_grids Arguments None Contents None","tags":"","loc":"proc/nc_grids.html"},{"title":"nc_species â€“ stella","text":"private subroutine nc_species() Uses species Arguments None Contents None","tags":"","loc":"proc/nc_species.html"},{"title":"nc_geo â€“ stella","text":"private subroutine nc_geo() Uses stella_geometry physics_parameters dist_fn_arrays zgrid kt_grids Arguments None Contents None","tags":"","loc":"proc/nc_geo.html"},{"title":"get_nout â€“ stella","text":"public subroutine get_nout(tstart, nout) Uses netcdf Get the index of the time dimension in the netCDF file that corresponds to\na time no larger than tstart Arguments Type Intent Optional Attributes Name real, intent(in) :: tstart Simulation time to find integer, intent(out) :: nout Index of time dimension Contents None","tags":"","loc":"proc/get_nout.html"},{"title":"sync_nc â€“ stella","text":"public subroutine sync_nc() Arguments None Contents None","tags":"","loc":"proc/sync_nc.html"},{"title":"init_physics_flags â€“ stella","text":"public subroutine init_physics_flags() Arguments None Contents None","tags":"","loc":"proc/init_physics_flags.html"},{"title":"read_parameters â€“ stella","text":"private subroutine read_parameters() Uses mp text_options file_utils Arguments None Contents None","tags":"","loc":"proc/read_parameters~3.html"},{"title":"finish_physics_flags â€“ stella","text":"public subroutine finish_physics_flags() Arguments None Contents None","tags":"","loc":"proc/finish_physics_flags.html"},{"title":"init_extended_zgrid â€“ stella","text":"public subroutine init_extended_zgrid() Uses zgrid constants kt_grids all periodic modes (e.g., the zonal mode) have no connections\nphi(kx-kx_shift,-nzgrid) = phi(kx,nzgrid) from twist-and-shift BC\nfor positive (negative) magnetic shear, kx_shift is positive (negative),\nso start at most positive (negative) kx and\nprogress to smaller (larger) kx values as connections occur\nfigure out how much to shift ikx by to get to the end of the kx chain\nfor positive (negative) magnetic shear, this is the left-most (right-most) theta-theta0\nin each set of connected 2pi segments\nnote that theta0 goes from 0 to theta0_max and then from theta0_min back\nto -dtheta0\nfirst ikx_max=nakx/2+1 theta0s are 0 and all positive theta0 values\nremainder are negative theta0s\ntheta_0 = kx / ky / shat\nif ky > 0, then most positive theta_0 corresponds to most positive kx\nfirst consider case where shift in kx is negative (corresponds to positive magnetic shear)\nthen consider case where shift in kx is positive\nnote that zero shift case is taken care of by initialization of ikx_shift_end ikx_shift is how much to shift each ikx by to connect\nto the next theta0 (from most positive to most negative for positive magnetic shear\nand vice versa for negative magnetic shear)\nfirst consider shift in index for case where shift is negative\n(corresponds to positive magnetic shear)\nif ky > 0, then going to more negative theta0\ncorresponds to going to more negative kx\nif theta0 is sufficiently positive, shifting to more\nnegative theta0 corresponds to decreasing ikx\nif a positive theta0 connects to a negative theta0\nmust do more complicated mapping of ikx\nif theta0 is negative, then shifting to more negative\ntheta0 corresponds to decreasing ikx\nif theta0 is sufficiently negative, it has no\nmore negative theta0 with which it can connect\ntheta0 is positive\nif ky > 0, then going to more positive theta0\ncorresponds to going to more positive kx\nif shift in kx, kx_shift, is less than kx-kx_max,\nthen shift by the appropriate amount\notherwise, no kx on grid to connect with\nif kx+kx_shift < 0, then simple shift by neigen\nif 0 < kx+kx_shift <= kx_max, then more complicated shift\nto positive set of kx values\notherwise, no kx on grid with which to connect\nthis is the number of 2pi poloidal segments in the extended theta domain,\nwhich is needed in initializing the reponse matrix and doing the implicit sweep iz_low(j) is the ig index corresponding to the inboard midplane from below (theta=-pi) within the jth segment\niz_mid(j) is the ig index corresponding to the outboard midplane (theta=0) within the jth segment\ninitialize ikxmod to nakx\nshould not be necessary but just in case one tries to access\na value beyond nsegments(ie,iky)\nonly do the following once for each independent set of theta0s\nthe assumption here is that all kx are on processor and sequential\nremap to start at theta0 = theta0_max (theta0_min) for negative (positive) kx shift\nfor this set of connected theta0s\nthis is the number of unique zed values in all segments but the first\nthe first has one extra unique zed value (all others have one grid common\nwith the previous segment due to periodicity) Arguments None Contents None","tags":"","loc":"proc/init_extended_zgrid.html"},{"title":"fill_zed_ghost_zones â€“ stella","text":"public subroutine fill_zed_ghost_zones(it, iseg, ie, iky, g, gleft, gright) Uses zgrid Arguments Type Intent Optional Attributes Name integer, intent(in) :: it integer, intent(in) :: iseg integer, intent(in) :: ie integer, intent(in) :: iky complex, intent(in), dimension(:, :, -nzgrid:, :) :: g complex, intent(out), dimension(:) :: gleft complex, intent(out), dimension(:) :: gright Contents None","tags":"","loc":"proc/fill_zed_ghost_zones.html"},{"title":"map_to_extended_zgrid â€“ stella","text":"public subroutine map_to_extended_zgrid(it, ie, iky, g, gext, ulim) Uses zgrid Arguments Type Intent Optional Attributes Name integer, intent(in) :: it integer, intent(in) :: ie integer, intent(in) :: iky complex, intent(in), dimension(:, -nzgrid:, :) :: g complex, intent(out), dimension(:) :: gext integer, intent(out) :: ulim Contents None","tags":"","loc":"proc/map_to_extended_zgrid.html"},{"title":"map_from_extended_zgrid â€“ stella","text":"public subroutine map_from_extended_zgrid(it, ie, iky, gext, g) Uses zgrid Arguments Type Intent Optional Attributes Name integer, intent(in) :: it integer, intent(in) :: ie integer, intent(in) :: iky complex, intent(in), dimension(:) :: gext complex, intent(inout), dimension(:, -nzgrid:, :) :: g Contents None","tags":"","loc":"proc/map_from_extended_zgrid.html"},{"title":"finish_extended_zgrid â€“ stella","text":"public subroutine finish_extended_zgrid() Arguments None Contents None","tags":"","loc":"proc/finish_extended_zgrid.html"},{"title":"init_time_advance â€“ stella","text":"public subroutine init_time_advance() Uses run_parameters mirror_terms physics_flags mp sources dissipation parallel_streaming flow_shear neoclassical_terms read time_advance_knobs namelist from the input file;\nsets the explicit time advance option, as well as allows for scaling of\nthe x and y components of the magnetic drifts and of the drive term\nallocate distribution function sized arrays needed, e.g., for Runge-Kutta time advance\nset up neoclassical corrections to the equilibrium Maxwellian;\nonly calculated/needed when simulating higher order terms in rhostar for intrinsic rotation\ncalculate the term multiplying dg/dvpa in the mirror term\nand set up either the semi-Lagrange machinery or the tridiagonal matrix to be inverted\nif solving implicitly\ncalculate the term multiplying dg/dz in the parallel streaming term\nand set up the tridiagonal matrix to be inverted if solving implicitly\nallocate and calculate the factors multiplying dg/dx, dg/dy, dphi/dx and dphi/dy\nin the magnetic drift terms\nallocate and calculate the factor multiplying dphi/dy in the gradient drive term Arguments None Contents None","tags":"","loc":"proc/init_time_advance.html"},{"title":"read_parameters â€“ stella","text":"private subroutine read_parameters() Uses run_parameters mp text_options file_utils Arguments None Contents None","tags":"","loc":"proc/read_parameters~4.html"},{"title":"init_wdrift â€“ stella","text":"private subroutine init_wdrift() Uses stella_geometry physics_flags vpamu_grids mp species stella_time dist_fn_arrays stella_layouts zgrid kt_grids neoclassical_terms allocate wdriftx_phi, the factor multiplying dphi/dx in the magnetic drift term\nallocate wdrifty_phi, the factor multiplying dphi/dy in the magnetic drift term\nallocate wdriftx_g, the factor multiplying dg/dx in the magnetic drift term\nallocate wdrifty_g, the factor multiplying dg/dy in the magnetic drift term\nthis is the curvature drift piece of wdrifty with missing factor of vpa\nvpa factor is missing to avoid singularity when including\nnon-Maxwellian corrections to equilibrium\nthis is the grad-B drift piece of wdrifty\nif including neoclassical correction to equilibrium Maxwellian,\nthen add in v_E&#94;{nc} . grad y dg/dy coefficient here\nif full_flux_surface, evolved distribution function is normalised by a Maxwellian\notherwise, it is not; a Maxwellian weighting factor must thus be included\nif including neoclassical corrections to equilibrium,\nadd in -(Ze/m) * v_curv/vpa . grad y d /dy * dF&#94;{nc}/dvpa term\nand v_E . grad z dF&#94;{nc}/dz (here get the dphi/dy part of v_E)\nNB: the below neoclassical correction needs to be divided by an equilibrium Maxwellian\nif running in full flux surface mode\nthis is the curvature drift piece of wdriftx with missing factor of vpa\nvpa factor is missing to avoid singularity when including\nnon-Maxwellian corrections to equilibrium\nthis is the grad-B drift piece of wdriftx\nif including neoclassical correction to equilibrium Maxwellian,\nthen add in v_E&#94;{nc} . grad x dg/dx coefficient here\nif full_flux_surface, evolved distribution function is normalised by a Maxwellian\notherwise, it is not; a Maxwellian weighting factor must thus be included\nif including neoclassical corrections to equilibrium,\nadd in (Ze/m) * v_curv/vpa . grad x d /dx * dF&#94;{nc}/dvpa term\nand v_E . grad z dF&#94;{nc}/dz (here get the dphi/dx part of v_E)\nand v_E . grad alpha dF&#94;{nc}/dalpha (dphi/dx part of v_E)\nNB: the below neoclassical correction needs to be divided by an equilibrium Maxwellian\nif running in full flux surface mode Arguments None Contents None","tags":"","loc":"proc/init_wdrift.html"},{"title":"init_wstar â€“ stella","text":"private subroutine init_wstar() Uses stella_geometry vpamu_grids physics_flags mp species stella_time dist_fn_arrays stella_layouts zgrid kt_grids neoclassical_terms Arguments None Contents None","tags":"","loc":"proc/init_wstar.html"},{"title":"init_drifts_implicit â€“ stella","text":"private subroutine init_drifts_implicit() Uses stella_geometry fields_arrays run_parameters fields vpamu_grids mp physics_flags gyro_averages species constants dist_fn_arrays stella_layouts zgrid kt_grids Arguments None Contents None","tags":"","loc":"proc/init_drifts_implicit.html"},{"title":"init_parallel_nonlinearity â€“ stella","text":"private subroutine init_parallel_nonlinearity() Uses stella_geometry physics_flags species physics_parameters zgrid Arguments None Contents None","tags":"","loc":"proc/init_parallel_nonlinearity.html"},{"title":"init_radial_variation â€“ stella","text":"private subroutine init_radial_variation() Uses stella_geometry vpamu_grids species stella_time dist_fn_arrays stella_layouts zgrid kt_grids Arguments None Contents None","tags":"","loc":"proc/init_radial_variation.html"},{"title":"allocate_arrays â€“ stella","text":"private subroutine allocate_arrays() Uses dist_fn_arrays stella_layouts zgrid kt_grids Arguments None Contents None","tags":"","loc":"proc/allocate_arrays~2.html"},{"title":"init_cfl â€“ stella","text":"private subroutine init_cfl() Uses run_parameters mirror_terms physics_flags vpamu_grids mp file_utils stella_time dist_fn_arrays dissipation zgrid flow_shear kt_grids parallel_streaming Arguments None Contents None","tags":"","loc":"proc/init_cfl.html"},{"title":"reset_dt â€“ stella","text":"private subroutine reset_dt() Uses run_parameters mirror_terms physics_flags response_matrix sources dissipation parallel_streaming flow_shear Arguments None Contents None","tags":"","loc":"proc/reset_dt.html"},{"title":"advance_stella â€“ stella","text":"public subroutine advance_stella(istep) Uses run_parameters fields kt_grids sources dist_fn_arrays fields_arrays multibox unless running in multibox mode, no need to worry about\nmb_communicate calls as the subroutine is immediately exited\nif not in multibox mode.\nsave value of phi\nfor use in diagnostics (to obtain frequency) reverse the order of operations every time step\nas part of alternating direction operator splitting\nthis is needed to ensure 2nd order accuracy in time\nadvance the explicit parts of the GKE\nuse operator splitting to separately evolve\nall terms treated implicitly\nEnsure fields are updated so that omega calculation is correct. Arguments Type Intent Optional Attributes Name integer, intent(in) :: istep Contents None","tags":"","loc":"proc/advance_stella.html"},{"title":"advance_explicit â€“ stella","text":"private subroutine advance_explicit(g) Uses job_manage mp extended_zgrid stella_layouts zgrid kt_grids parallel_streaming advance_explicit takes as input the guiding centre distribution function\nin k-space and updates it to account for all of the terms in the GKE that\nare advanced explicitly in time start the timer for the explicit part of the solve SSP RK2\ndefault is SSP RK3\nRK4\nenforce periodicity for periodic (including zonal) modes\nstream_sign > 0 corresponds to dz/dt < 0\nstop the timer for the explicit part of the solve Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g Contents None","tags":"","loc":"proc/advance_explicit.html"},{"title":"advance_explicit_rk2 â€“ stella","text":"private subroutine advance_explicit_rk2(g) Uses dist_fn_arrays stella_layouts zgrid multibox advance_expliciit_rk2 uses strong stability-preserving RK2 to advance one time step if CFL condition is violated by nonlinear term\nthen must modify time step size and restart time step\nassume false and test RK_step only true if running in multibox mode SSP rk3 algorithm to advance explicit part of code\nif GK equation written as dg/dt = rhs - vpar . grad h,\nsolve_gke returns rhs*dt\nthis is gbar at intermediate time level Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g Contents None","tags":"","loc":"proc/advance_explicit_rk2.html"},{"title":"advance_explicit_rk3 â€“ stella","text":"private subroutine advance_explicit_rk3(g) Uses dist_fn_arrays stella_layouts zgrid multibox strong stability-preserving RK3 if CFL condition is violated by nonlinear term\nthen must modify time step size and restart time step\nassume false and test RK_STEP = false unless in multibox mode SSP rk3 algorithm to advance explicit part of code\nif GK equation written as dg/dt = rhs - vpar . grad h,\nsolve_gke returns rhs*dt\nthis is gbar at intermediate time level Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g Contents None","tags":"","loc":"proc/advance_explicit_rk3.html"},{"title":"advance_explicit_rk4 â€“ stella","text":"private subroutine advance_explicit_rk4(g) Uses dist_fn_arrays stella_layouts zgrid multibox standard RK4 if CFL condition is violated by nonlinear term\nthen must modify time step size and restart time step\nassume false and test RK_step is false unless in multibox mode RK4 algorithm to advance explicit part of code\nif GK equation written as dg/dt = rhs - vpar . grad h,\nsolve_gke returns rhs*dt\nthis is gbar at intermediate time level Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g Contents None","tags":"","loc":"proc/advance_explicit_rk4.html"},{"title":"solve_gke â€“ stella","text":"private subroutine solve_gke(gin, rhs_ky, restart_time_step) Uses run_parameters mirror_terms physics_flags job_manage fields flow_shear multibox sources stella_layouts physics_parameters stella_transforms fields_arrays zgrid dissipation redistribute kt_grids parallel_streaming solve_gke accepts as argument gin, the guiding centre distribution function in k-space,\nand returns rhs_ky, the right-hand side of the gyrokinetic equation in k-space;\ni.e., if dg/dt = r, then rhs_ky = r*dt if full_flux_surface = .true., then initially obtain the RHS of the GKE in alpha-space;\nwill later inverse Fourier transform to get RHS in k_alpha-space\nrhs_ky will always be needed as the array returned by the subroutine,\nbut intermediate array rhs_y (RHS of gke in alpha-space) only needed for full_flux_surface = .true.\nrhs is array referred to for both flux tube and full-flux-surface simulations;\nfor full-flux-surface it should point to rhs_y\nrhs is array referred to for both flux tube and full-flux-surface simulations;\nfor flux tube it should point to rhs_ky\nstart with gbar in k-space and (ky,kx,z) local\nobtain fields corresponding to gbar\ndefault is to continue with same time step size.\nif estimated CFL condition for nonlinear terms is violated\nthen restart_time_step will be set to .true.\ncalculate and add ExB nonlinearity to RHS of GK eqn\ndo this first, as the CFL condition may require a change in time step\nand thus recomputation of mirror, wdrift, wstar, and parstream\ninclude contribution from the parallel nonlinearity (aka turbulent acceleration) include contribution from perp flow shear in the parallel component of the toroidal flow calculate and add mirror term to RHS of GK eqn\ncalculate and add alpha-component of magnetic drift term to RHS of GK eqn\ncalculate and add psi-component of magnetic drift term to RHS of GK eqn\ncalculate and add omega_* term to RHS of GK eqn\ncalculate and add contribution from collisions to RHS of GK eqn calculate and add parallel streaming term to RHS of GK eqn\nif simulating a full flux surface (flux annulus), all terms to this point have been calculated\nin real-space in alpha (y); transform to kalpha (ky) space before adding to RHS of GKE.\nNB: it may be that for fully explicit calculation, this transform can be eliminated with additional code changes Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gin complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:), target :: rhs_ky logical, intent(out) :: restart_time_step Contents None","tags":"","loc":"proc/solve_gke.html"},{"title":"advance_wstar_explicit â€“ stella","text":"private subroutine advance_wstar_explicit(phi, gout) Uses fields_arrays fields job_manage mp physics_flags dist_fn_arrays stella_transforms stella_layouts zgrid kt_grids start timing the time advance due to the driving gradients get d /dy in k-space assume only a single flux surface simulated\ntransform d /dy from k-space to y-space\nmultiply d /dy with omega_ coefficient and add to source (RHS of GK eqn)\nomega_ stays in ky,kx,z space with ky,kx,z local\nmultiply d /dy with omega_* coefficient and add to source (RHS of GK eqn) stop timing the time advance due to the driving gradients Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout Contents None","tags":"","loc":"proc/advance_wstar_explicit.html"},{"title":"advance_wdrifty_explicit â€“ stella","text":"private subroutine advance_wdrifty_explicit(g, phi, gout) Uses physics_flags job_manage mp gyro_averages dist_fn_arrays stella_transforms stella_layouts zgrid kt_grids advance_wdrifty_explicit subroutine calculates and adds the y-component of the\nmagnetic drift term to the RHS of the GK equation start the timing of the y component of the magnetic drift advance calculate dg/dy in (ky,kx) space\ncalculate dphi/dy in (ky,kx) space assume only a single flux surface simulated\ntransform dg/dy from k-space to y-space\nadd vM . grad y dg/dy term to equation get in k-space\ntransform d /dy from k-space to y-space\nadd vM . grad y d /dy term to equation stop the timing of the y component of the magnetic drift advance Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout Contents None","tags":"","loc":"proc/advance_wdrifty_explicit.html"},{"title":"advance_wdriftx_explicit â€“ stella","text":"private subroutine advance_wdriftx_explicit(g, phi, gout) Uses physics_flags job_manage mp gyro_averages dist_fn_arrays stella_transforms stella_layouts zgrid kt_grids advance_wdriftx_explicit subroutine calculates and adds the x-component of the\nmagnetic drift term to the RHS of the GK equation start the timing of the x component of the magnetic drift advance do not calculate if wdriftx terms are all zero\ncalculate dg/dx in (ky,kx) space\ncalculate dphi/dx in (ky,kx) space assume a single flux surface is simulated\ntransform dg/dx from k-space to y-space\nadd vM . grad x dg/dx term to equation\nget in k-space\ntransform d /dx from k-space to y-space\nadd vM . grad x d /dx term to equation\nadd vM . grad x dg/dx term to equation\nget in k-space\nadd vM . grad x d /dx term to equation\nstop the timing of the x component of the magnetic drift advance Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout Contents None","tags":"","loc":"proc/advance_wdriftx_explicit.html"},{"title":"advance_ExB_nonlinearity â€“ stella","text":"private subroutine advance_ExB_nonlinearity(g, gout, restart_time_step) Uses stella_geometry fields_arrays run_parameters fields job_manage mp physics_flags gyro_averages constants stella_time stella_transforms stella_layouts zgrid physics_parameters file_utils kt_grids compute phase factor needed when running with equilibrium flow shear\ncompute i ky g\nFFT to get dg/dy in (y,x) space\ncompute i kx if running with equilibrium flow shear, make adjustment to\nthe term multiplying dg/dy\nFFT to get d /dx in (y,x) space\nmultiply by the geometric factor appearing in the Poisson bracket;\ni.e., (dx/dpsi dy/dalpha) 0.5\ncompute the contribution to the Poisson bracket from dg/dy*d /dx estimate the CFL dt due to the above contribution estimate the CFL dt due to the above contribution compute dg/dx in k-space (= i kx g)\nif running with equilibrium flow shear, correct dg/dx term\nFFT to get dg/dx in (y,x) space\ncompute d /dy in k-space\nFFT to get d /dy in (y,x) space\nmultiply by the geometric factor appearing in the Poisson bracket;\ni.e., (dx/dpsi dy/dalpha) 0.5\ncompute the contribution to the Poisson bracket from dg/dy*d /dx estimate the CFL dt due to the above contribution estimate the CFL dt due to the above contribution check estimated cfl_dt to see if the time step size needs to be changed Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout logical, intent(out) :: restart_time_step Contents None","tags":"","loc":"proc/advance_exb_nonlinearity.html"},{"title":"advance_parallel_nonlinearity â€“ stella","text":"private subroutine advance_parallel_nonlinearity(g, gout, restart_time_step) Uses gyro_averages stella_time stella_layouts vpamu_grids zgrid redistribute parallel_streaming job_manage finite_differences mp dist_redistribute constants stella_transforms kt_grids run_parameters physics_flags extended_zgrid file_utils fields_arrays Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout logical, intent(out) :: restart_time_step Contents None","tags":"","loc":"proc/advance_parallel_nonlinearity.html"},{"title":"advance_radial_variation â€“ stella","text":"private subroutine advance_radial_variation(g, gout) Uses fields_arrays run_parameters mirror_terms fields job_manage mp physics_flags gyro_averages dist_fn_arrays stella_transforms stella_layouts zgrid flow_shear kt_grids parallel_streaming Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout Contents None","tags":"","loc":"proc/advance_radial_variation.html"},{"title":"get_dgdy_2d â€“ stella","text":"private subroutine get_dgdy_2d(g, dgdy) Uses kt_grids constants compute dg/dy in k-space\naccepts g(ky,kx) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: g complex, intent(out), dimension(:, :) :: dgdy Contents None","tags":"","loc":"proc/get_dgdy_2d.html"},{"title":"get_dgdy_3d â€“ stella","text":"private subroutine get_dgdy_3d(g, dgdy) Uses kt_grids zgrid constants compute dg/dy in k-space\naccepts g(ky,kx,z,tube) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: dgdy Contents None","tags":"","loc":"proc/get_dgdy_3d.html"},{"title":"get_dgdy_4d â€“ stella","text":"private subroutine get_dgdy_4d(g, dgdy) Uses kt_grids stella_layouts zgrid constants compute dg/dy in k-space\naccepts g(ky,kx,z,tube,(vpa,mu,spec)) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dgdy Contents None","tags":"","loc":"proc/get_dgdy_4d.html"},{"title":"get_dgdx_2d â€“ stella","text":"private subroutine get_dgdx_2d(g, dgdx) Uses kt_grids constants compute dg/dx in k-space\naccepts g(ky,kx) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: g complex, intent(out), dimension(:, :) :: dgdx Contents None","tags":"","loc":"proc/get_dgdx_2d.html"},{"title":"get_dgdx_3d â€“ stella","text":"private subroutine get_dgdx_3d(g, dgdx) Uses kt_grids zgrid constants compute dg/dx in k-space\naccepts g(ky,kx,z,tube) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: dgdx Contents None","tags":"","loc":"proc/get_dgdx_3d.html"},{"title":"get_dgdx_4d â€“ stella","text":"private subroutine get_dgdx_4d(g, dgdx) Uses kt_grids stella_layouts zgrid constants compute dg/dx in k-space\naccepts g(ky,kx,z,tube,(vpa,mu,spec)) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dgdx Contents None","tags":"","loc":"proc/get_dgdx_4d.html"},{"title":"add_explicit_term â€“ stella","text":"private subroutine add_explicit_term(g, pre_factor, src) Uses stella_layouts zgrid kt_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g real, intent(in), dimension(-nzgrid:, vmu_lo%llim_proc:) :: pre_factor complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: src Contents None","tags":"","loc":"proc/add_explicit_term.html"},{"title":"add_explicit_term_ffs â€“ stella","text":"private subroutine add_explicit_term_ffs(g, pre_factor, src) Uses stella_layouts zgrid kt_grids add vM . grad y d /dy or vM . grad x d /dx (or equivalents with g) or omega_* * d /dy term to RHS of GK equation Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g real, intent(in), dimension(:, -nzgrid:, vmu_lo%llim_proc:) :: pre_factor complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: src Contents None","tags":"","loc":"proc/add_explicit_term_ffs.html"},{"title":"advance_implicit â€“ stella","text":"private subroutine advance_implicit(istep, phi, apar, g) Uses run_parameters mirror_terms physics_flags job_manage mp fields dissipation stella_layouts zgrid flow_shear multibox parallel_streaming Arguments Type Intent Optional Attributes Name integer, intent(in) :: istep complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :) :: apar complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g Contents None","tags":"","loc":"proc/advance_implicit.html"},{"title":"advance_drifts_implicit â€“ stella","text":"private subroutine advance_drifts_implicit(g, phi, apar) Uses stella_geometry run_parameters physics_flags fields vpamu_grids gyro_averages species constants dist_fn_arrays stella_layouts zgrid kt_grids Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :) :: apar Contents None","tags":"","loc":"proc/advance_drifts_implicit.html"},{"title":"mb_communicate â€“ stella","text":"private subroutine mb_communicate(g_in) Uses fields_arrays fields mp file_utils stella_layouts zgrid multibox Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g_in Contents None","tags":"","loc":"proc/mb_communicate.html"},{"title":"checksum_field â€“ stella","text":"private subroutine checksum_field(field, total) Uses extended_zgrid zgrid kt_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: field real, intent(out) :: total Contents None","tags":"","loc":"proc/checksum_field.html"},{"title":"checksum_dist â€“ stella","text":"private subroutine checksum_dist(dist, total, norm) Uses vpamu_grids mp stella_layouts zgrid kt_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dist real, intent(out) :: total logical, intent(in), optional :: norm Contents None","tags":"","loc":"proc/checksum_dist.html"},{"title":"finish_time_advance â€“ stella","text":"public subroutine finish_time_advance() Uses mirror_terms physics_flags extended_zgrid dissipation stella_transforms parallel_streaming flow_shear neoclassical_terms Arguments None Contents None","tags":"","loc":"proc/finish_time_advance.html"},{"title":"finish_parallel_nonlinearity â€“ stella","text":"private subroutine finish_parallel_nonlinearity() Arguments None Contents None","tags":"","loc":"proc/finish_parallel_nonlinearity.html"},{"title":"finish_wdrift â€“ stella","text":"private subroutine finish_wdrift() Uses dist_fn_arrays Arguments None Contents None","tags":"","loc":"proc/finish_wdrift.html"},{"title":"finish_wstar â€“ stella","text":"private subroutine finish_wstar() Uses dist_fn_arrays Arguments None Contents None","tags":"","loc":"proc/finish_wstar.html"},{"title":"finish_drifts_implicit â€“ stella","text":"private subroutine finish_drifts_implicit() Arguments None Contents None","tags":"","loc":"proc/finish_drifts_implicit.html"},{"title":"deallocate_arrays â€“ stella","text":"private subroutine deallocate_arrays() Uses dist_fn_arrays Arguments None Contents None","tags":"","loc":"proc/deallocate_arrays.html"},{"title":"get_dgdy â€“ stella","text":"private interface get_dgdy Contents Module Procedures get_dgdy_2d get_dgdy_3d get_dgdy_4d Module Procedures private subroutine get_dgdy_2d (g, dgdy) compute dg/dy in k-space\naccepts g(ky,kx) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: g complex, intent(out), dimension(:, :) :: dgdy private subroutine get_dgdy_3d (g, dgdy) compute dg/dy in k-space\naccepts g(ky,kx,z,tube) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: dgdy private subroutine get_dgdy_4d (g, dgdy) compute dg/dy in k-space\naccepts g(ky,kx,z,tube,(vpa,mu,spec)) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dgdy","tags":"","loc":"interface/get_dgdy.html"},{"title":"get_dgdx â€“ stella","text":"private interface get_dgdx Contents Module Procedures get_dgdx_2d get_dgdx_3d get_dgdx_4d Module Procedures private subroutine get_dgdx_2d (g, dgdx) compute dg/dx in k-space\naccepts g(ky,kx) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: g complex, intent(out), dimension(:, :) :: dgdx private subroutine get_dgdx_3d (g, dgdx) compute dg/dx in k-space\naccepts g(ky,kx,z,tube) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: dgdx private subroutine get_dgdx_4d (g, dgdx) compute dg/dx in k-space\naccepts g(ky,kx,z,tube,(vpa,mu,spec)) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dgdx","tags":"","loc":"interface/get_dgdx.html"},{"title":"checksum â€“ stella","text":"public interface checksum Contents Module Procedures checksum_field checksum_dist Module Procedures private subroutine checksum_field (field, total) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: field real, intent(out) :: total private subroutine checksum_dist (dist, total, norm) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dist real, intent(out) :: total logical, intent(in), optional :: norm","tags":"","loc":"interface/checksum.html"},{"title":"read_species_euterpe â€“ stella","text":"public subroutine read_species_euterpe(nspec, spec) Uses common_types stella_geometry splines mp finite_differences physics_parameters Arguments Type Intent Optional Attributes Name integer, intent(in) :: nspec type( spec_type ), intent(inout), dimension(:) :: spec Contents None","tags":"","loc":"proc/read_species_euterpe.html"},{"title":"read_euterpe_parameters â€“ stella","text":"public subroutine read_euterpe_parameters(nradii_out, data_file_out) Uses file_utils Arguments Type Intent Optional Attributes Name integer, intent(out) :: nradii_out character, intent(out) :: data_file_out Contents None","tags":"","loc":"proc/read_euterpe_parameters.html"},{"title":"first_order_upwind_real â€“ stella","text":"public subroutine first_order_upwind_real(llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(out), dimension(llim:) :: df Contents None","tags":"","loc":"proc/first_order_upwind_real.html"},{"title":"first_order_upwind_complex â€“ stella","text":"public subroutine first_order_upwind_complex(llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(out), dimension(llim:) :: df Contents None","tags":"","loc":"proc/first_order_upwind_complex.html"},{"title":"third_order_upwind_complex â€“ stella","text":"public subroutine third_order_upwind_complex(llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(out), dimension(llim:) :: df Contents None","tags":"","loc":"proc/third_order_upwind_complex.html"},{"title":"third_order_upwind_real â€“ stella","text":"public subroutine third_order_upwind_real(llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(out), dimension(llim:) :: df Contents None","tags":"","loc":"proc/third_order_upwind_real.html"},{"title":"fifth_order_upwind_complex â€“ stella","text":"public subroutine fifth_order_upwind_complex(llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(out), dimension(llim:) :: df Contents None","tags":"","loc":"proc/fifth_order_upwind_complex.html"},{"title":"fifth_order_upwind_real â€“ stella","text":"public subroutine fifth_order_upwind_real(llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(out), dimension(llim:) :: df Contents None","tags":"","loc":"proc/fifth_order_upwind_real.html"},{"title":"third_order_upwind_zed â€“ stella","text":"public subroutine third_order_upwind_zed(llim, iseg, nseg, f, del, sgn, fl, fr, periodic, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim integer, intent(in) :: iseg integer, intent(in) :: nseg complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(in), dimension(:) :: fl complex, intent(in), dimension(:) :: fr logical, intent(in) :: periodic complex, intent(out), dimension(llim:) :: df Contents None","tags":"","loc":"proc/third_order_upwind_zed.html"},{"title":"first_order_upwind_zed â€“ stella","text":"public subroutine first_order_upwind_zed(llim, iseg, nseg, f, del, sgn, fl, fr, periodic, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim integer, intent(in) :: iseg integer, intent(in) :: nseg complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(in), dimension(:) :: fl complex, intent(in), dimension(:) :: fr logical, intent(in) :: periodic complex, intent(out), dimension(llim:) :: df Contents None","tags":"","loc":"proc/first_order_upwind_zed.html"},{"title":"second_order_centered_real â€“ stella","text":"public subroutine second_order_centered_real(llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del real, intent(out), dimension(llim:) :: df Contents None","tags":"","loc":"proc/second_order_centered_real.html"},{"title":"second_order_centered_complex â€“ stella","text":"public subroutine second_order_centered_complex(llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del complex, intent(out), dimension(llim:) :: df Contents None","tags":"","loc":"proc/second_order_centered_complex.html"},{"title":"four_point_triangle_real â€“ stella","text":"public subroutine four_point_triangle_real(llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del real, intent(out), dimension(llim:) :: df Contents None","tags":"","loc":"proc/four_point_triangle_real.html"},{"title":"four_point_triangle_complex â€“ stella","text":"public subroutine four_point_triangle_complex(llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del complex, intent(out), dimension(llim:) :: df Contents None","tags":"","loc":"proc/four_point_triangle_complex.html"},{"title":"fourth_order_centered_real â€“ stella","text":"public subroutine fourth_order_centered_real(llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del real, intent(out), dimension(llim:) :: df Contents None","tags":"","loc":"proc/fourth_order_centered_real.html"},{"title":"fourth_order_centered_complex â€“ stella","text":"public subroutine fourth_order_centered_complex(llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del complex, intent(out), dimension(llim:) :: df Contents None","tags":"","loc":"proc/fourth_order_centered_complex.html"},{"title":"second_order_centered_zed_real â€“ stella","text":"public subroutine second_order_centered_zed_real(llim, iseg, nseg, f, del, sgn, fl, fr, periodic, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim integer, intent(in) :: iseg integer, intent(in) :: nseg real, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(in), dimension(:) :: fl real, intent(in), dimension(:) :: fr logical, intent(in) :: periodic real, intent(out), dimension(llim:) :: df Contents None","tags":"","loc":"proc/second_order_centered_zed_real.html"},{"title":"second_order_centered_zed_complex â€“ stella","text":"public subroutine second_order_centered_zed_complex(llim, iseg, nseg, f, del, sgn, fl, fr, periodic, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim integer, intent(in) :: iseg integer, intent(in) :: nseg complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(in), dimension(:) :: fl complex, intent(in), dimension(:) :: fr logical, intent(in) :: periodic complex, intent(out), dimension(llim:) :: df Contents None","tags":"","loc":"proc/second_order_centered_zed_complex.html"},{"title":"second_order_centered_vpa â€“ stella","text":"public subroutine second_order_centered_vpa(llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del complex, intent(out), dimension(llim:) :: df Contents None","tags":"","loc":"proc/second_order_centered_vpa.html"},{"title":"fd_cell_centres_zed â€“ stella","text":"public subroutine fd_cell_centres_zed(llim, f, del, sgn, fl, fr, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(in) :: fl complex, intent(in) :: fr complex, intent(out), dimension(llim:) :: df Contents None","tags":"","loc":"proc/fd_cell_centres_zed.html"},{"title":"cell_centres_zed â€“ stella","text":"public subroutine cell_centres_zed(llim, f, upwnd, sgn, fl, fr, fc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: upwnd integer, intent(in) :: sgn complex, intent(in) :: fl complex, intent(in) :: fr complex, intent(out), dimension(llim:) :: fc Contents None","tags":"","loc":"proc/cell_centres_zed.html"},{"title":"fd_variable_upwinding_zed â€“ stella","text":"public subroutine fd_variable_upwinding_zed(llim, iseg, nseg, f, del, sgn, upwnd, fl, fr, periodic, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim integer, intent(in) :: iseg integer, intent(in) :: nseg complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(in) :: upwnd complex, intent(in), dimension(:) :: fl complex, intent(in), dimension(:) :: fr logical, intent(in) :: periodic complex, intent(out), dimension(llim:) :: df Contents None","tags":"","loc":"proc/fd_variable_upwinding_zed.html"},{"title":"fd_variable_upwinding_vpa â€“ stella","text":"public subroutine fd_variable_upwinding_vpa(llim, f, del, sgn, upwnd, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(in) :: upwnd complex, intent(out), dimension(llim:) :: df Contents None","tags":"","loc":"proc/fd_variable_upwinding_vpa.html"},{"title":"fd3pt_real â€“ stella","text":"public subroutine fd3pt_real(prof, profgrad, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: prof real, intent(out), dimension(:) :: profgrad real, intent(in) :: dr Contents None","tags":"","loc":"proc/fd3pt_real.html"},{"title":"fd3pt_real_array â€“ stella","text":"public subroutine fd3pt_real_array(prof, profgrad, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: prof real, intent(out), dimension(:) :: profgrad real, intent(in), dimension(:) :: dr Contents None","tags":"","loc":"proc/fd3pt_real_array.html"},{"title":"fd3pt_complex_array â€“ stella","text":"public subroutine fd3pt_complex_array(prof, profgrad, dr) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: prof complex, intent(out), dimension(:) :: profgrad real, intent(in), dimension(:) :: dr Contents None","tags":"","loc":"proc/fd3pt_complex_array.html"},{"title":"fd5pt_real â€“ stella","text":"public subroutine fd5pt_real(prof, profgrad, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: prof real, intent(out), dimension(:) :: profgrad real, intent(in) :: dr Contents None","tags":"","loc":"proc/fd5pt_real.html"},{"title":"fd5pt_array â€“ stella","text":"public subroutine fd5pt_array(prof, profgrad, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: prof real, intent(out), dimension(:) :: profgrad real, intent(in), dimension(:) :: dr Contents None","tags":"","loc":"proc/fd5pt_array.html"},{"title":"d2_3pt_real â€“ stella","text":"public subroutine d2_3pt_real(f, d2f, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: f real, intent(out), dimension(:) :: d2f real, intent(in), dimension(:) :: dr Contents None","tags":"","loc":"proc/d2_3pt_real.html"},{"title":"d2_3pt_complex â€“ stella","text":"public subroutine d2_3pt_complex(f, d2f, dr) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: f complex, intent(out), dimension(:) :: d2f real, intent(in), dimension(:) :: dr Contents None","tags":"","loc":"proc/d2_3pt_complex.html"},{"title":"tridag_real â€“ stella","text":"public subroutine tridag_real(aa, bb, cc, sol) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: aa real, intent(in), dimension(:) :: bb real, intent(in), dimension(:) :: cc real, intent(inout), dimension(:) :: sol Contents None","tags":"","loc":"proc/tridag_real.html"},{"title":"tridag_complex â€“ stella","text":"public subroutine tridag_complex(llim, aa, bb, cc, sol) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: aa real, intent(in), dimension(llim:) :: bb real, intent(in), dimension(llim:) :: cc complex, intent(inout), dimension(llim:) :: sol Contents None","tags":"","loc":"proc/tridag_complex.html"},{"title":"fd3pt â€“ stella","text":"public interface fd3pt Contents Module Procedures fd3pt_real fd3pt_real_array fd3pt_complex_array Module Procedures public subroutine fd3pt_real (prof, profgrad, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: prof real, intent(out), dimension(:) :: profgrad real, intent(in) :: dr public subroutine fd3pt_real_array (prof, profgrad, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: prof real, intent(out), dimension(:) :: profgrad real, intent(in), dimension(:) :: dr public subroutine fd3pt_complex_array (prof, profgrad, dr) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: prof complex, intent(out), dimension(:) :: profgrad real, intent(in), dimension(:) :: dr","tags":"","loc":"interface/fd3pt.html"},{"title":"fd5pt â€“ stella","text":"public interface fd5pt Contents Module Procedures fd5pt_real fd5pt_array Module Procedures public subroutine fd5pt_real (prof, profgrad, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: prof real, intent(out), dimension(:) :: profgrad real, intent(in) :: dr public subroutine fd5pt_array (prof, profgrad, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: prof real, intent(out), dimension(:) :: profgrad real, intent(in), dimension(:) :: dr","tags":"","loc":"interface/fd5pt.html"},{"title":"first_order_upwind â€“ stella","text":"public interface first_order_upwind Contents Module Procedures first_order_upwind_real first_order_upwind_complex Module Procedures public subroutine first_order_upwind_real (llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(out), dimension(llim:) :: df public subroutine first_order_upwind_complex (llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(out), dimension(llim:) :: df","tags":"","loc":"interface/first_order_upwind.html"},{"title":"third_order_upwind â€“ stella","text":"public interface third_order_upwind Contents Module Procedures third_order_upwind_complex third_order_upwind_real Module Procedures public subroutine third_order_upwind_complex (llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(out), dimension(llim:) :: df public subroutine third_order_upwind_real (llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(out), dimension(llim:) :: df","tags":"","loc":"interface/third_order_upwind.html"},{"title":"fifth_order_upwind â€“ stella","text":"public interface fifth_order_upwind Contents Module Procedures fifth_order_upwind_complex fifth_order_upwind_real Module Procedures public subroutine fifth_order_upwind_complex (llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(out), dimension(llim:) :: df public subroutine fifth_order_upwind_real (llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(out), dimension(llim:) :: df","tags":"","loc":"interface/fifth_order_upwind.html"},{"title":"tridag â€“ stella","text":"public interface tridag Contents Module Procedures tridag_real tridag_complex Module Procedures public subroutine tridag_real (aa, bb, cc, sol) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: aa real, intent(in), dimension(:) :: bb real, intent(in), dimension(:) :: cc real, intent(inout), dimension(:) :: sol public subroutine tridag_complex (llim, aa, bb, cc, sol) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: aa real, intent(in), dimension(llim:) :: bb real, intent(in), dimension(llim:) :: cc complex, intent(inout), dimension(llim:) :: sol","tags":"","loc":"interface/tridag.html"},{"title":"second_order_centered â€“ stella","text":"public interface second_order_centered Contents Module Procedures second_order_centered_real second_order_centered_complex Module Procedures public subroutine second_order_centered_real (llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del real, intent(out), dimension(llim:) :: df public subroutine second_order_centered_complex (llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del complex, intent(out), dimension(llim:) :: df","tags":"","loc":"interface/second_order_centered.html"},{"title":"four_point_triangle â€“ stella","text":"public interface four_point_triangle Contents Module Procedures four_point_triangle_real four_point_triangle_complex Module Procedures public subroutine four_point_triangle_real (llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del real, intent(out), dimension(llim:) :: df public subroutine four_point_triangle_complex (llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del complex, intent(out), dimension(llim:) :: df","tags":"","loc":"interface/four_point_triangle.html"},{"title":"fourth_order_centered â€“ stella","text":"public interface fourth_order_centered Contents Module Procedures fourth_order_centered_real fourth_order_centered_complex Module Procedures public subroutine fourth_order_centered_real (llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del real, intent(out), dimension(llim:) :: df public subroutine fourth_order_centered_complex (llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del complex, intent(out), dimension(llim:) :: df","tags":"","loc":"interface/fourth_order_centered.html"},{"title":"second_order_centered_zed â€“ stella","text":"public interface second_order_centered_zed Contents Module Procedures second_order_centered_zed_real second_order_centered_zed_complex Module Procedures public subroutine second_order_centered_zed_real (llim, iseg, nseg, f, del, sgn, fl, fr, periodic, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim integer, intent(in) :: iseg integer, intent(in) :: nseg real, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(in), dimension(:) :: fl real, intent(in), dimension(:) :: fr logical, intent(in) :: periodic real, intent(out), dimension(llim:) :: df public subroutine second_order_centered_zed_complex (llim, iseg, nseg, f, del, sgn, fl, fr, periodic, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim integer, intent(in) :: iseg integer, intent(in) :: nseg complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(in), dimension(:) :: fl complex, intent(in), dimension(:) :: fr logical, intent(in) :: periodic complex, intent(out), dimension(llim:) :: df","tags":"","loc":"interface/second_order_centered_zed.html"},{"title":"d2_3pt â€“ stella","text":"public interface d2_3pt Contents Module Procedures d2_3pt_real d2_3pt_complex Module Procedures public subroutine d2_3pt_real (f, d2f, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: f real, intent(out), dimension(:) :: d2f real, intent(in), dimension(:) :: dr public subroutine d2_3pt_complex (f, d2f, dr) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: f complex, intent(out), dimension(:) :: d2f real, intent(in), dimension(:) :: dr","tags":"","loc":"interface/d2_3pt.html"},{"title":"is_idx_kxkyz â€“ stella","text":"private elemental function is_idx_kxkyz(lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer Contents None","tags":"","loc":"proc/is_idx_kxkyz.html"},{"title":"ikx_idx_kxkyz â€“ stella","text":"private elemental function ikx_idx_kxkyz(lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer Contents None","tags":"","loc":"proc/ikx_idx_kxkyz.html"},{"title":"iky_idx_kxkyz â€“ stella","text":"private elemental function iky_idx_kxkyz(lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer Contents None","tags":"","loc":"proc/iky_idx_kxkyz.html"},{"title":"iz_idx_kxkyz â€“ stella","text":"private elemental function iz_idx_kxkyz(lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer Contents None","tags":"","loc":"proc/iz_idx_kxkyz.html"},{"title":"it_idx_kxkyz â€“ stella","text":"private elemental function it_idx_kxkyz(lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer Contents None","tags":"","loc":"proc/it_idx_kxkyz.html"},{"title":"proc_id_kxkyz â€“ stella","text":"private elemental function proc_id_kxkyz(lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer Contents None","tags":"","loc":"proc/proc_id_kxkyz.html"},{"title":"idx_kxkyz â€“ stella","text":"private elemental function idx_kxkyz(lo, iky, ikx, iz, it, is) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value integer Contents None","tags":"","loc":"proc/idx_kxkyz.html"},{"title":"idx_local_kxkyz â€“ stella","text":"private elemental function idx_local_kxkyz(lo, iky, ikx, iz, it, is) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value logical Contents None","tags":"","loc":"proc/idx_local_kxkyz.html"},{"title":"iz_local_kxkyz â€“ stella","text":"private elemental function iz_local_kxkyz(lo, iz) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: iz Return Value logical Contents None","tags":"","loc":"proc/iz_local_kxkyz.html"},{"title":"is_idx_kxyz â€“ stella","text":"private elemental function is_idx_kxyz(lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer Contents None","tags":"","loc":"proc/is_idx_kxyz.html"},{"title":"ikx_idx_kxyz â€“ stella","text":"private elemental function ikx_idx_kxyz(lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer Contents None","tags":"","loc":"proc/ikx_idx_kxyz.html"},{"title":"iy_idx_kxyz â€“ stella","text":"private elemental function iy_idx_kxyz(lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer Contents None","tags":"","loc":"proc/iy_idx_kxyz.html"},{"title":"iz_idx_kxyz â€“ stella","text":"private elemental function iz_idx_kxyz(lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer Contents None","tags":"","loc":"proc/iz_idx_kxyz.html"},{"title":"it_idx_kxyz â€“ stella","text":"private elemental function it_idx_kxyz(lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer Contents None","tags":"","loc":"proc/it_idx_kxyz.html"},{"title":"proc_id_kxyz â€“ stella","text":"private elemental function proc_id_kxyz(lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer Contents None","tags":"","loc":"proc/proc_id_kxyz.html"},{"title":"idx_kxyz â€“ stella","text":"private elemental function idx_kxyz(lo, iy, ikx, iz, it, is) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: iy integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value integer Contents None","tags":"","loc":"proc/idx_kxyz.html"},{"title":"idx_local_kxyz â€“ stella","text":"private elemental function idx_local_kxyz(lo, iy, ikx, iz, it, is) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: iy integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value logical Contents None","tags":"","loc":"proc/idx_local_kxyz.html"},{"title":"iz_local_kxyz â€“ stella","text":"private elemental function iz_local_kxyz(lo, iz) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: iz Return Value logical Contents None","tags":"","loc":"proc/iz_local_kxyz.html"},{"title":"is_idx_xyz â€“ stella","text":"private elemental function is_idx_xyz(lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer Contents None","tags":"","loc":"proc/is_idx_xyz.html"},{"title":"ix_idx_xyz â€“ stella","text":"private elemental function ix_idx_xyz(lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer Contents None","tags":"","loc":"proc/ix_idx_xyz.html"},{"title":"iy_idx_xyz â€“ stella","text":"private elemental function iy_idx_xyz(lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer Contents None","tags":"","loc":"proc/iy_idx_xyz.html"},{"title":"iz_idx_xyz â€“ stella","text":"private elemental function iz_idx_xyz(lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer Contents None","tags":"","loc":"proc/iz_idx_xyz.html"},{"title":"it_idx_xyz â€“ stella","text":"private elemental function it_idx_xyz(lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer Contents None","tags":"","loc":"proc/it_idx_xyz.html"},{"title":"proc_id_xyz â€“ stella","text":"private elemental function proc_id_xyz(lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer Contents None","tags":"","loc":"proc/proc_id_xyz.html"},{"title":"idx_xyz â€“ stella","text":"private elemental function idx_xyz(lo, iy, ix, iz, it, is) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: iy integer, intent(in) :: ix integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value integer Contents None","tags":"","loc":"proc/idx_xyz.html"},{"title":"idx_local_xyz â€“ stella","text":"private elemental function idx_local_xyz(lo, iy, ix, iz, it, is) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: iy integer, intent(in) :: ix integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value logical Contents None","tags":"","loc":"proc/idx_local_xyz.html"},{"title":"iz_local_xyz â€“ stella","text":"private elemental function iz_local_xyz(lo, iz) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: iz Return Value logical Contents None","tags":"","loc":"proc/iz_local_xyz.html"},{"title":"is_idx_vmu â€“ stella","text":"private elemental function is_idx_vmu(lo, i) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer Contents None","tags":"","loc":"proc/is_idx_vmu.html"},{"title":"imu_idx_vmu â€“ stella","text":"private elemental function imu_idx_vmu(lo, i) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer Contents None","tags":"","loc":"proc/imu_idx_vmu.html"},{"title":"iv_idx_vmu â€“ stella","text":"private elemental function iv_idx_vmu(lo, i) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer Contents None","tags":"","loc":"proc/iv_idx_vmu.html"},{"title":"proc_id_vmu â€“ stella","text":"private elemental function proc_id_vmu(lo, i) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer Contents None","tags":"","loc":"proc/proc_id_vmu.html"},{"title":"idx_vmu â€“ stella","text":"private elemental function idx_vmu(lo, iv, imu, is) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: iv integer, intent(in) :: imu integer, intent(in) :: is Return Value integer Contents None","tags":"","loc":"proc/idx_vmu.html"},{"title":"idx_local_vmu â€“ stella","text":"private elemental function idx_local_vmu(lo, iv, imu, is) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: iv integer, intent(in) :: imu integer, intent(in) :: is Return Value logical Contents None","tags":"","loc":"proc/idx_local_vmu.html"},{"title":"iz_local_vmu â€“ stella","text":"private elemental function iz_local_vmu(lo, iz) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: iz Return Value logical Contents None","tags":"","loc":"proc/iz_local_vmu.html"},{"title":"init_stella_layouts â€“ stella","text":"public subroutine init_stella_layouts() Uses mp Arguments None Contents None","tags":"","loc":"proc/init_stella_layouts.html"},{"title":"read_parameters â€“ stella","text":"private subroutine read_parameters() Uses mp file_utils Arguments None Contents None","tags":"","loc":"proc/read_parameters~5.html"},{"title":"broadcast_results â€“ stella","text":"private subroutine broadcast_results() Uses mp Arguments None Contents None","tags":"","loc":"proc/broadcast_results.html"},{"title":"init_dist_fn_layouts â€“ stella","text":"public subroutine init_dist_fn_layouts(nzgrid, ntubes, naky, nakx, nvgrid, nmu, nspec, ny, nx, nalpha) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nzgrid integer, intent(in) :: ntubes integer, intent(in) :: naky integer, intent(in) :: nakx integer, intent(in) :: nvgrid integer, intent(in) :: nmu integer, intent(in) :: nspec integer, intent(in) :: ny integer, intent(in) :: nx integer, intent(in) :: nalpha Contents None","tags":"","loc":"proc/init_dist_fn_layouts.html"},{"title":"init_kxkyz_layout â€“ stella","text":"private subroutine init_kxkyz_layout(nzgrid, ntubes, naky, nakx, nvgrid, nmu, nspec) Uses mp Arguments Type Intent Optional Attributes Name integer, intent(in) :: nzgrid integer, intent(in) :: ntubes integer, intent(in) :: naky integer, intent(in) :: nakx integer, intent(in) :: nvgrid integer, intent(in) :: nmu integer, intent(in) :: nspec Contents None","tags":"","loc":"proc/init_kxkyz_layout.html"},{"title":"init_kxyz_layout â€“ stella","text":"private subroutine init_kxyz_layout(nzgrid, ntubes, naky, nakx, nvgrid, nmu, nspec, ny) Uses mp Arguments Type Intent Optional Attributes Name integer, intent(in) :: nzgrid integer, intent(in) :: ntubes integer, intent(in) :: naky integer, intent(in) :: nakx integer, intent(in) :: nvgrid integer, intent(in) :: nmu integer, intent(in) :: nspec integer, intent(in) :: ny Contents None","tags":"","loc":"proc/init_kxyz_layout.html"},{"title":"init_xyz_layout â€“ stella","text":"private subroutine init_xyz_layout(nzgrid, ntubes, naky, nakx, nvgrid, nmu, nspec, ny, nx) Uses mp Arguments Type Intent Optional Attributes Name integer, intent(in) :: nzgrid integer, intent(in) :: ntubes integer, intent(in) :: naky integer, intent(in) :: nakx integer, intent(in) :: nvgrid integer, intent(in) :: nmu integer, intent(in) :: nspec integer, intent(in) :: ny integer, intent(in) :: nx Contents None","tags":"","loc":"proc/init_xyz_layout.html"},{"title":"init_vmu_layout â€“ stella","text":"private subroutine init_vmu_layout(nzgrid, ntubes, naky, nakx, nvgrid, nmu, nspec, ny, nx, nalpha) Uses mp Arguments Type Intent Optional Attributes Name integer, intent(in) :: nzgrid integer, intent(in) :: ntubes integer, intent(in) :: naky integer, intent(in) :: nakx integer, intent(in) :: nvgrid integer, intent(in) :: nmu integer, intent(in) :: nspec integer, intent(in) :: ny integer, intent(in) :: nx integer, intent(in) :: nalpha Contents None","tags":"","loc":"proc/init_vmu_layout.html"},{"title":"kxkyzidx2vmuidx â€“ stella","text":"public elemental subroutine kxkyzidx2vmuidx(iv, imu, ikxkyz, kxkyz_lo, vmu_lo, iky, ikx, iz, it, ivmu) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv integer, intent(in) :: imu integer, intent(in) :: ikxkyz type( kxkyz_layout_type ), intent(in) :: kxkyz_lo type( vmu_layout_type ), intent(in) :: vmu_lo integer, intent(out) :: iky integer, intent(out) :: ikx integer, intent(out) :: iz integer, intent(out) :: it integer, intent(out) :: ivmu Contents None","tags":"","loc":"proc/kxkyzidx2vmuidx.html"},{"title":"kxyzidx2vmuidx â€“ stella","text":"public elemental subroutine kxyzidx2vmuidx(iv, imu, ikxyz, kxyz_lo, vmu_lo, iy, ikx, iz, it, ivmu) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv integer, intent(in) :: imu integer, intent(in) :: ikxyz type( kxyz_layout_type ), intent(in) :: kxyz_lo type( vmu_layout_type ), intent(in) :: vmu_lo integer, intent(out) :: iy integer, intent(out) :: ikx integer, intent(out) :: iz integer, intent(out) :: it integer, intent(out) :: ivmu Contents None","tags":"","loc":"proc/kxyzidx2vmuidx.html"},{"title":"xyzidx2vmuidx â€“ stella","text":"public elemental subroutine xyzidx2vmuidx(iv, imu, ixyz, xyz_lo, vmu_lo, iy, ix, iz, it, ivmu) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv integer, intent(in) :: imu integer, intent(in) :: ixyz type( xyz_layout_type ), intent(in) :: xyz_lo type( vmu_layout_type ), intent(in) :: vmu_lo integer, intent(out) :: iy integer, intent(out) :: ix integer, intent(out) :: iz integer, intent(out) :: it integer, intent(out) :: ivmu Contents None","tags":"","loc":"proc/xyzidx2vmuidx.html"},{"title":"finish_layouts â€“ stella","text":"public subroutine finish_layouts() Arguments None Contents None","tags":"","loc":"proc/finish_layouts.html"},{"title":"it_idx â€“ stella","text":"public interface it_idx Contents Module Procedures it_idx_kxkyz it_idx_kxyz it_idx_xyz Module Procedures private elemental function it_idx_kxkyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function it_idx_kxyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function it_idx_xyz (lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"interface/it_idx.html"},{"title":"iz_idx â€“ stella","text":"public interface iz_idx Contents Module Procedures iz_idx_kxkyz iz_idx_kxyz iz_idx_xyz Module Procedures private elemental function iz_idx_kxkyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function iz_idx_kxyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function iz_idx_xyz (lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"interface/iz_idx.html"},{"title":"iv_idx â€“ stella","text":"public interface iv_idx Contents Module Procedures iv_idx_vmu Module Procedures private elemental function iv_idx_vmu (lo, i) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"interface/iv_idx.html"},{"title":"iky_idx â€“ stella","text":"public interface iky_idx Contents Module Procedures iky_idx_kxkyz Module Procedures private elemental function iky_idx_kxkyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"interface/iky_idx.html"},{"title":"iy_idx â€“ stella","text":"public interface iy_idx Contents Module Procedures iy_idx_kxyz iy_idx_xyz Module Procedures private elemental function iy_idx_kxyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function iy_idx_xyz (lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"interface/iy_idx.html"},{"title":"ikx_idx â€“ stella","text":"public interface ikx_idx Contents Module Procedures ikx_idx_kxkyz ikx_idx_kxyz Module Procedures private elemental function ikx_idx_kxkyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function ikx_idx_kxyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"interface/ikx_idx.html"},{"title":"ix_idx â€“ stella","text":"private interface ix_idx Contents Module Procedures ix_idx_xyz Module Procedures private elemental function ix_idx_xyz (lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"interface/ix_idx.html"},{"title":"imu_idx â€“ stella","text":"public interface imu_idx Contents Module Procedures imu_idx_vmu Module Procedures private elemental function imu_idx_vmu (lo, i) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"interface/imu_idx.html"},{"title":"is_idx â€“ stella","text":"public interface is_idx Contents Module Procedures is_idx_kxkyz is_idx_kxyz is_idx_xyz is_idx_vmu Module Procedures private elemental function is_idx_kxkyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function is_idx_kxyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function is_idx_xyz (lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function is_idx_vmu (lo, i) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"interface/is_idx.html"},{"title":"proc_id â€“ stella","text":"public interface proc_id Contents Module Procedures proc_id_kxkyz proc_id_kxyz proc_id_xyz proc_id_vmu Module Procedures private elemental function proc_id_kxkyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function proc_id_kxyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function proc_id_xyz (lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function proc_id_vmu (lo, i) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"interface/proc_id.html"},{"title":"idx â€“ stella","text":"public interface idx Contents Module Procedures idx_kxkyz idx_kxyz idx_xyz idx_vmu Module Procedures private elemental function idx_kxkyz (lo, iky, ikx, iz, it, is) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value integer private elemental function idx_kxyz (lo, iy, ikx, iz, it, is) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: iy integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value integer private elemental function idx_xyz (lo, iy, ix, iz, it, is) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: iy integer, intent(in) :: ix integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value integer private elemental function idx_vmu (lo, iv, imu, is) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: iv integer, intent(in) :: imu integer, intent(in) :: is Return Value integer","tags":"","loc":"interface/idx.html"},{"title":"idx_local â€“ stella","text":"public interface idx_local Contents Module Procedures idx_local_kxkyz iz_local_kxkyz idx_local_kxyz iz_local_kxyz idx_local_xyz iz_local_xyz idx_local_vmu iz_local_vmu Module Procedures private elemental function idx_local_kxkyz (lo, iky, ikx, iz, it, is) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value logical private elemental function iz_local_kxkyz (lo, iz) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: iz Return Value logical private elemental function idx_local_kxyz (lo, iy, ikx, iz, it, is) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: iy integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value logical private elemental function iz_local_kxyz (lo, iz) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: iz Return Value logical private elemental function idx_local_xyz (lo, iy, ix, iz, it, is) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: iy integer, intent(in) :: ix integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value logical private elemental function iz_local_xyz (lo, iz) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: iz Return Value logical private elemental function idx_local_vmu (lo, iv, imu, is) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: iv integer, intent(in) :: imu integer, intent(in) :: is Return Value logical private elemental function iz_local_vmu (lo, iz) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: iz Return Value logical","tags":"","loc":"interface/idx_local.html"},{"title":"init_fields â€“ stella","text":"public subroutine init_fields() Uses linear_solve physics_flags Arguments None Contents None","tags":"","loc":"proc/init_fields.html"},{"title":"init_fields_fluxtube â€“ stella","text":"private subroutine init_fields_fluxtube() Uses stella_geometry run_parameters fields_arrays physics_flags vpamu_grids mp linear_solve stella_transforms multibox gyro_averages species file_utils physics_parameters dist_fn_arrays stella_layouts zgrid kt_grids Todo would be tidier if the code related to radial profile variation\nwere gathered into a separate subroutine or subroutines\ninit_fields_fluxtube allocates and fills arrays needed during main time advance\nloop for the field solve for flux tube simulations Arguments None Contents None","tags":"","loc":"proc/init_fields_fluxtube.html"},{"title":"init_fields_ffs â€“ stella","text":"private subroutine init_fields_ffs() Uses species init_fields_ffs allocates and fills arrays needed during main time advance\nloop for the field solve for full_flux_surface simulations allocate arrays such as phi that are needed\nthroughout the simulation calculate and LU factorise the matrix multiplying the electrostatic potential in quasineutrality\nthis involves the factor 1-Gamma_0(kperp(alpha)) if using a modified Boltzmann response for the electrons\nobtain the response of phi_homogeneous to a unit perturbation in flux-surface-averaged phi Arguments None Contents None","tags":"","loc":"proc/init_fields_ffs.html"},{"title":"init_gamma0_factor_ffs â€“ stella","text":"private subroutine init_gamma0_factor_ffs() Uses stella_geometry spfunc vpamu_grids stella_transforms gyro_averages species physics_parameters dist_fn_arrays stella_layouts zgrid kt_grids calculate and LU factorise the matrix multiplying the electrostatic potential in quasineutrality\nthis involves the factor 1-Gamma_0(kperp(alpha)) wgts are species-dependent factors appearing in Gamma0 factor\nallocate gam0_ffs array, which will contain the Fourier coefficients in y\nof the Gamma0 factor that appears in quasineutrality\nin calculating the Fourier coefficients for Gamma_0, change loop orders\nso that inner loop is over ivmu super-index;\nthis is done because we must integrate over v-space and sum over species,\nand we want to minimise memory usage where possible (so, e.g., aj0_alpha need\nonly be a function of ivmu and can be over-written for each (ia,iky,ikx)).\nget J0 for all vpar, mu, spec values\ncalculate the argument of the Bessel function J0\ncompute J0 corresponding to the given argument arg\nform coefficient needed to calculate 1-Gamma_0\ncalculate gamma0(kalpha,alpha,...) = sum_s Zs&#94;2 * ns / Ts int d3v (1-J0&#94;2)*F_{Maxwellian}\nnote that v-space Jacobian contains alpha-dependent factor, B(z,alpha),\nbut this is not a problem as we have yet to transform from alpha to k_alpha\nif Boltzmann response used, account for non-flux-surface-averaged component of electron density\nif kx = ky = 0, 1-Gam0 factor is zero;\nthis leads to eqn of form 0 * phi_00 = int d3v g.\nhack for now is to set phi_00 = 0, as above inversion is singular.\nto avoid singular inversion, set gam0_alpha = 1.0\nfourier transform Gamma_0(alpha) from alpha to k_alpha space\nallocate array to hold the Fourier coefficients\nfill the array with the requisite coefficients LU factorise array of gam0, using the LAPACK zgbtrf routine for banded matrices Arguments None Contents None","tags":"","loc":"proc/init_gamma0_factor_ffs.html"},{"title":"init_adiabatic_response_factor â€“ stella","text":"private subroutine init_adiabatic_response_factor() Uses gyro_averages volume_averages physics_parameters stella_transforms zgrid kt_grids solves Delta * phi_hom = -delta_{ky,0} * ne/Te for phi_hom\nthis is the vector describing the response of phi_hom to a unit impulse in phi_fsa\nit is the sum over ky and integral over kx of this that is needed, and this\nis stored in adiabatic_response_factor adiabatic_response_vector is initialised to be the rhs of the equation for the\n'homogeneous' part of phi, with a unit impulse assumed for the flux-surface-averaged phi\nonly the ky=0 component contributes to the flux-surface-averaged potential\npass in the rhs and overwrite with the solution for phi_homogeneous obtain the flux surface average of the response vector Arguments None Contents None","tags":"","loc":"proc/init_adiabatic_response_factor.html"},{"title":"allocate_arrays â€“ stella","text":"private subroutine allocate_arrays() Uses physics_flags stella_layouts fields_arrays zgrid kt_grids Arguments None Contents None","tags":"","loc":"proc/allocate_arrays~3.html"},{"title":"enforce_reality_field â€“ stella","text":"public subroutine enforce_reality_field(fin) Uses zgrid kt_grids Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: fin Contents None","tags":"","loc":"proc/enforce_reality_field.html"},{"title":"advance_fields â€“ stella","text":"public subroutine advance_fields(g, phi, apar, dist) Uses run_parameters physics_flags job_manage mp dist_redistribute dist_fn_arrays stella_layouts zgrid redistribute time the communications + field solve\nfields_kxkyz = F is the default\nfirst gather (vpa,mu) onto processor for v-space operations\nv-space operations are field solve, dg/dvpa, and collisions\ngiven gvmu with vpa and mu local, calculate the corresponding fields\nset a flag to indicate that the fields have been updated\nthis helps avoid unnecessary field solves\ntime the communications + field solve Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: phi complex, intent(out), dimension(:, :, -nzgrid:, :) :: apar character, intent(in) :: dist Contents None","tags":"","loc":"proc/advance_fields.html"},{"title":"get_fields â€“ stella","text":"public subroutine get_fields(g, phi, apar, dist, skip_fsa) Uses run_parameters vpamu_grids job_manage mp gyro_averages species physics_parameters dist_fn_arrays stella_layouts zgrid Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: phi complex, intent(out), dimension(:, :, -nzgrid:, :) :: apar character, intent(in) :: dist logical, intent(in), optional :: skip_fsa Contents None","tags":"","loc":"proc/get_fields.html"},{"title":"get_fields_vmulo â€“ stella","text":"private subroutine get_fields_vmulo(g, phi, apar, dist, skip_fsa) Uses stella_geometry run_parameters physics_flags job_manage mp vpamu_grids gyro_averages species dist_fn_arrays stella_layouts zgrid kt_grids gather sub-sums from each processor and add them together\nstore result in phi, which will be further modified below to account for polarization term Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: phi complex, intent(out), dimension(:, :, -nzgrid:, :) :: apar character, intent(in) :: dist logical, intent(in), optional :: skip_fsa Contents None","tags":"","loc":"proc/get_fields_vmulo.html"},{"title":"get_fields_ffs â€“ stella","text":"private subroutine get_fields_ffs(g, phi, apar) Uses run_parameters mp species volume_averages physics_parameters stella_layouts zgrid kt_grids get_fields_ffs accepts as input the guiding centre distribution function g\nand calculates/returns the electronstatic potential phi for full_flux_surface simulations calculate the contribution to quasineutrality coming from the velocity space\nintegration of the guiding centre distribution function g;\nthe sign is consistent with phi appearing on the RHS of the eqn and int g appearing on the LHS.\nthis is returned in source\nuse sum_s int d3v and QN to solve for phi\nNB: assuming here that ntubes = 1 for FFS sim\nif using a modified Boltzmann response for the electrons, then phi\nat this stage is the 'inhomogeneous' part of phi.\nfirst must get phi on grid that includes positive and negative ky (but only positive kx)\ncalculate the flux surface average of this phi_inhomogeneous\nuse the flux surface average of phi_inhomogeneous, together with the\nadiabatic_response_factor, to obtain the flux-surface-averaged phi\nuse the computed flux surface average of phi as an additional sosurce in quasineutrality\nto obtain the electrostatic potential; only affects the ky=0 component of QN\nif adiabatic electrons are not employed, then\nno explicit equation for the ky=kx=0 component of phi;\nhack for now is to set it equal to zero. Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: phi complex, intent(out), dimension(:, :, -nzgrid:, :) :: apar Contents None","tags":"","loc":"proc/get_fields_ffs.html"},{"title":"get_fields_by_spec â€“ stella","text":"public subroutine get_fields_by_spec(g, fld, skip_fsa) Uses stella_geometry run_parameters vpamu_grids physics_flags mp gyro_averages species stella_layouts zgrid kt_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: fld logical, intent(in), optional :: skip_fsa Contents None","tags":"","loc":"proc/get_fields_by_spec.html"},{"title":"get_fields_by_spec_idx â€“ stella","text":"public subroutine get_fields_by_spec_idx(isa, g, fld) Uses stella_geometry run_parameters spfunc vpamu_grids physics_flags mp gyro_averages species dist_fn_arrays stella_layouts zgrid kt_grids Arguments Type Intent Optional Attributes Name integer, intent(in) :: isa complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: fld Contents None","tags":"","loc":"proc/get_fields_by_spec_idx.html"},{"title":"get_phi â€“ stella","text":"private subroutine get_phi(phi, dist, skip_fsa) Uses stella_geometry run_parameters fields_arrays physics_flags job_manage mp linear_solve species file_utils stella_transforms multibox zgrid kt_grids Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi character, intent(in) :: dist logical, intent(in), optional :: skip_fsa Contents None","tags":"","loc":"proc/get_phi.html"},{"title":"get_phi_ffs â€“ stella","text":"private subroutine get_phi_ffs(rhs, phi) Uses zgrid gyro_averages kt_grids change from rhs defined on grid with ky >=0 and kx from 0,...,kxmax,-kxmax,...,-dkx\nto rhs_swap defined on grid with ky = -kymax,...,kymax and kx >= 0\nsolve sum_s Z_s int d&#94;3v = gam0*phi\nwhere sum_s Z_s int d&#94;3v is initially passed in as rhs_swap\nand then rhs_swap is over-written with the solution to the linear system swap back from the ordered grid in ky to the original (kx,ky) grid Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:) :: rhs complex, intent(out), dimension(:, :, -nzgrid:) :: phi Contents None","tags":"","loc":"proc/get_phi_ffs.html"},{"title":"get_radial_correction â€“ stella","text":"public subroutine get_radial_correction(g, phi_in, dist) Uses stella_geometry run_parameters fields_arrays vpamu_grids physics_flags mp gyro_averages species dist_fn_arrays stella_layouts zgrid kt_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi_in character, intent(in) :: dist Contents None","tags":"","loc":"proc/get_radial_correction.html"},{"title":"get_dchidy_4d â€“ stella","text":"private subroutine get_dchidy_4d(phi, apar, dchidy) Uses run_parameters vpamu_grids gyro_averages species constants stella_layouts zgrid kt_grids compute d /dy in (ky,kx,z,tube) space Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(in), dimension(:, :, -nzgrid:, :) :: apar complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dchidy Contents None","tags":"","loc":"proc/get_dchidy_4d.html"},{"title":"get_dchidy_2d â€“ stella","text":"private subroutine get_dchidy_2d(iz, ivmu, phi, apar, dchidy) Uses run_parameters gyro_averages species constants stella_layouts vpamu_grids kt_grids compute d /dy in (ky,kx) space Arguments Type Intent Optional Attributes Name integer, intent(in) :: iz integer, intent(in) :: ivmu complex, intent(in), dimension(:, :) :: phi complex, intent(in), dimension(:, :) :: apar complex, intent(out), dimension(:, :) :: dchidy Contents None","tags":"","loc":"proc/get_dchidy_2d.html"},{"title":"get_dchidx â€“ stella","text":"public subroutine get_dchidx(iz, ivmu, phi, apar, dchidx) Uses run_parameters gyro_averages species constants stella_layouts vpamu_grids kt_grids compute d /dx in (ky,kx) space Arguments Type Intent Optional Attributes Name integer, intent(in) :: iz integer, intent(in) :: ivmu complex, intent(in), dimension(:, :) :: phi complex, intent(in), dimension(:, :) :: apar complex, intent(out), dimension(:, :) :: dchidx Contents None","tags":"","loc":"proc/get_dchidx.html"},{"title":"finish_fields â€“ stella","text":"public subroutine finish_fields() Uses fields_arrays arrays only allocated/used if simulating a full flux surface Arguments None Contents None","tags":"","loc":"proc/finish_fields.html"},{"title":"get_dchidy â€“ stella","text":"public interface get_dchidy Contents Module Procedures get_dchidy_4d get_dchidy_2d Module Procedures private subroutine get_dchidy_4d (phi, apar, dchidy) compute d /dy in (ky,kx,z,tube) space Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(in), dimension(:, :, -nzgrid:, :) :: apar complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dchidy private subroutine get_dchidy_2d (iz, ivmu, phi, apar, dchidy) compute d /dy in (ky,kx) space Arguments Type Intent Optional Attributes Name integer, intent(in) :: iz integer, intent(in) :: ivmu complex, intent(in), dimension(:, :) :: phi complex, intent(in), dimension(:, :) :: apar complex, intent(out), dimension(:, :) :: dchidy","tags":"","loc":"interface/get_dchidy.html"},{"title":"init_transforms â€“ stella","text":"public subroutine init_transforms() Uses stella_layouts physics_flags Arguments None Contents None","tags":"","loc":"proc/init_transforms.html"},{"title":"init_y_fft â€“ stella","text":"private subroutine init_y_fft() Uses stella_layouts fft_work Arguments None Contents None","tags":"","loc":"proc/init_y_fft.html"},{"title":"init_x_fft â€“ stella","text":"private subroutine init_x_fft() Uses stella_layouts fft_work Arguments None Contents None","tags":"","loc":"proc/init_x_fft.html"},{"title":"init_x_xfirst_fft â€“ stella","text":"private subroutine init_x_xfirst_fft() Uses stella_layouts fft_work Arguments None Contents None","tags":"","loc":"proc/init_x_xfirst_fft.html"},{"title":"init_y_xfirst_fft â€“ stella","text":"private subroutine init_y_xfirst_fft() Uses stella_layouts fft_work Arguments None Contents None","tags":"","loc":"proc/init_y_xfirst_fft.html"},{"title":"init_unpadded_x_fft â€“ stella","text":"private subroutine init_unpadded_x_fft() Uses stella_layouts fft_work Arguments None Contents None","tags":"","loc":"proc/init_unpadded_x_fft.html"},{"title":"init_unpadded_y_fft â€“ stella","text":"private subroutine init_unpadded_y_fft() Uses stella_layouts fft_work Arguments None Contents None","tags":"","loc":"proc/init_unpadded_y_fft.html"},{"title":"init_alpha_fft â€“ stella","text":"private subroutine init_alpha_fft() Uses stella_layouts fft_work Arguments None Contents None","tags":"","loc":"proc/init_alpha_fft.html"},{"title":"transform_ky2y_5d â€“ stella","text":"private subroutine transform_ky2y_5d(gky_unpad, gy) Uses stella_layouts Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -vmu_lo%nzgrid:, :, vmu_lo%llim_proc:) :: gky_unpad complex, intent(out), dimension(:, :, -vmu_lo%nzgrid:, :, vmu_lo%llim_proc:) :: gy Contents None","tags":"","loc":"proc/transform_ky2y_5d.html"},{"title":"transform_ky2y_2d â€“ stella","text":"private subroutine transform_ky2y_2d(gky_unpad, gy) Uses stella_layouts Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gky_unpad complex, intent(out), dimension(:, :) :: gy Contents None","tags":"","loc":"proc/transform_ky2y_2d.html"},{"title":"transform_y2ky_5d â€“ stella","text":"private subroutine transform_y2ky_5d(gy, gky) Uses stella_layouts Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -vmu_lo%nzgrid:, :, vmu_lo%llim_proc:) :: gy complex, intent(out), dimension(:, :, -vmu_lo%nzgrid:, :, vmu_lo%llim_proc:) :: gky Contents None","tags":"","loc":"proc/transform_y2ky_5d.html"},{"title":"transform_y2ky_2d â€“ stella","text":"private subroutine transform_y2ky_2d(gy, gky) Uses stella_layouts Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: gy complex, intent(out), dimension(:, :) :: gky Contents None","tags":"","loc":"proc/transform_y2ky_2d.html"},{"title":"transform_kx2x â€“ stella","text":"public subroutine transform_kx2x(gkx, gx) Uses stella_layouts Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gkx real, intent(out), dimension(:, :) :: gx Contents None","tags":"","loc":"proc/transform_kx2x~2.html"},{"title":"transform_x2kx â€“ stella","text":"public subroutine transform_x2kx(gx, gkx) Uses stella_layouts Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: gx complex, intent(out), dimension(:, :) :: gkx Contents None","tags":"","loc":"proc/transform_x2kx.html"},{"title":"transform_kx2x_xfirst â€“ stella","text":"public subroutine transform_kx2x_xfirst(gkx, gx) Uses stella_layouts Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gkx complex, intent(out), dimension(:, :) :: gx Contents None","tags":"","loc":"proc/transform_kx2x_xfirst.html"},{"title":"transform_x2kx_xfirst â€“ stella","text":"public subroutine transform_x2kx_xfirst(gx, gkx) Uses stella_layouts Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gx complex, intent(out), dimension(:, :) :: gkx Contents None","tags":"","loc":"proc/transform_x2kx_xfirst.html"},{"title":"transform_ky2y_xfirst â€“ stella","text":"public subroutine transform_ky2y_xfirst(gky, gy) Uses stella_layouts Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gky real, intent(out), dimension(:, :) :: gy Contents None","tags":"","loc":"proc/transform_ky2y_xfirst.html"},{"title":"transform_y2ky_xfirst â€“ stella","text":"public subroutine transform_y2ky_xfirst(gy, gky) Uses stella_layouts Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: gy complex, intent(out), dimension(:, :) :: gky Contents None","tags":"","loc":"proc/transform_y2ky_xfirst.html"},{"title":"transform_kx2x_unpadded â€“ stella","text":"public subroutine transform_kx2x_unpadded(gkx, gx) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gkx complex, intent(out), dimension(:, :) :: gx Contents None","tags":"","loc":"proc/transform_kx2x_unpadded.html"},{"title":"transform_x2kx_unpadded â€“ stella","text":"public subroutine transform_x2kx_unpadded(gx, gkx) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gx complex, intent(out), dimension(:, :) :: gkx Contents None","tags":"","loc":"proc/transform_x2kx_unpadded.html"},{"title":"transform_ky2y_unpadded â€“ stella","text":"public subroutine transform_ky2y_unpadded(gky, gy) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gky real, intent(out), dimension(:, :) :: gy Contents None","tags":"","loc":"proc/transform_ky2y_unpadded.html"},{"title":"transform_y2ky_unpadded â€“ stella","text":"public subroutine transform_y2ky_unpadded(gy, gky) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :) :: gy complex, intent(out), dimension(:, :) :: gky Contents None","tags":"","loc":"proc/transform_y2ky_unpadded.html"},{"title":"transform_kalpha2alpha â€“ stella","text":"public subroutine transform_kalpha2alpha(gkalph, galph) Uses stella_layouts Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: gkalph real, intent(out), dimension(:) :: galph Contents None","tags":"","loc":"proc/transform_kalpha2alpha.html"},{"title":"transform_alpha2kalpha â€“ stella","text":"public subroutine transform_alpha2kalpha(galph, gkalph) Uses stella_layouts input galph array is real and contains values on the padded alpha grid\ngkalph is output array; it contains the Fourier coefficients of galph\nfor positive ky values only (reality can be used to obtain the negative ky coefs)\nthe highest 1/3 of the ky modes from the FFT have been discarded to avoid de-aliasing Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: galph complex, intent(out), dimension(:) :: gkalph Contents None","tags":"","loc":"proc/transform_alpha2kalpha.html"},{"title":"finish_transforms â€“ stella","text":"public subroutine finish_transforms() Uses physics_flags Arguments None Contents None","tags":"","loc":"proc/finish_transforms.html"},{"title":"transform_ky2y â€“ stella","text":"public interface transform_ky2y Contents Module Procedures transform_ky2y_5d transform_ky2y_2d Module Procedures private subroutine transform_ky2y_5d (gky_unpad, gy) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -vmu_lo%nzgrid:, :, vmu_lo%llim_proc:) :: gky_unpad complex, intent(out), dimension(:, :, -vmu_lo%nzgrid:, :, vmu_lo%llim_proc:) :: gy private subroutine transform_ky2y_2d (gky_unpad, gy) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gky_unpad complex, intent(out), dimension(:, :) :: gy","tags":"","loc":"interface/transform_ky2y.html"},{"title":"transform_y2ky â€“ stella","text":"public interface transform_y2ky Contents Module Procedures transform_y2ky_5d transform_y2ky_2d Module Procedures private subroutine transform_y2ky_5d (gy, gky) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -vmu_lo%nzgrid:, :, vmu_lo%llim_proc:) :: gy complex, intent(out), dimension(:, :, -vmu_lo%nzgrid:, :, vmu_lo%llim_proc:) :: gky private subroutine transform_y2ky_2d (gy, gky) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: gy complex, intent(out), dimension(:, :) :: gky","tags":"","loc":"interface/transform_y2ky.html"},{"title":"init_neoclassical_terms â€“ stella","text":"public subroutine init_neoclassical_terms() Uses sfincs_interface vpamu_grids species stella_layouts zgrid kt_grids Arguments None Contents None","tags":"","loc":"proc/init_neoclassical_terms.html"},{"title":"read_parameters â€“ stella","text":"private subroutine read_parameters() Uses mp text_options file_utils Arguments None Contents None","tags":"","loc":"proc/read_parameters~6.html"},{"title":"distribute_vmus_over_procs â€“ stella","text":"private subroutine distribute_vmus_over_procs(local, distributed) Uses stella_layouts Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :, :) :: local real, intent(out), dimension(vmu_lo%llim_proc:) :: distributed Contents None","tags":"","loc":"proc/distribute_vmus_over_procs.html"},{"title":"get_dfneo_dvpa â€“ stella","text":"private subroutine get_dfneo_dvpa(fneo, dfneo) Uses vpamu_grids species finite_differences stella_layouts zgrid kt_grids Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, -nzgrid:, :, :, :) :: fneo real, intent(out), dimension(:, -nzgrid:, vmu_lo%llim_proc:) :: dfneo Contents None","tags":"","loc":"proc/get_dfneo_dvpa.html"},{"title":"get_dfneo_dzed â€“ stella","text":"private subroutine get_dfneo_dzed(fneo, dfneo) Uses vpamu_grids species finite_differences stella_layouts zgrid kt_grids Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, -nzgrid:, :, :, :) :: fneo real, intent(out), dimension(:, -nzgrid:, vmu_lo%llim_proc:) :: dfneo Contents None","tags":"","loc":"proc/get_dfneo_dzed.html"},{"title":"get_dfneo_drho â€“ stella","text":"private subroutine get_dfneo_drho(fneo, dfneo) Uses vpamu_grids species finite_differences stella_layouts zgrid kt_grids Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, -nzgrid:, :, :, :, -nradii/2:) :: fneo real, intent(out), dimension(:, -nzgrid:, vmu_lo%llim_proc:) :: dfneo Contents None","tags":"","loc":"proc/get_dfneo_drho.html"},{"title":"get_dphineo_dzed â€“ stella","text":"private subroutine get_dphineo_dzed(phineo, dphineo) Uses zgrid finite_differences kt_grids Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, -nzgrid:) :: phineo real, intent(out), dimension(:, -nzgrid:) :: dphineo Contents None","tags":"","loc":"proc/get_dphineo_dzed.html"},{"title":"get_dphineo_drho â€“ stella","text":"private subroutine get_dphineo_drho(phineo, dphineo) Uses zgrid finite_differences kt_grids Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, -nzgrid:, -nradii/2:) :: phineo real, intent(out), dimension(:, -nzgrid:) :: dphineo Contents None","tags":"","loc":"proc/get_dphineo_drho.html"},{"title":"write_neoclassical â€“ stella","text":"private subroutine write_neoclassical(fnc, phinc) Uses vpamu_grids mp file_utils stella_layouts zgrid kt_grids Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, -nzgrid:, :, :, :, -nradii/2:) :: fnc real, intent(in), dimension(:, -nzgrid:, -nradii/2:) :: phinc Contents None","tags":"","loc":"proc/write_neoclassical.html"},{"title":"finish_neoclassical_terms â€“ stella","text":"public subroutine finish_neoclassical_terms() Arguments None Contents None","tags":"","loc":"proc/finish_neoclassical_terms.html"},{"title":"init_redistribute â€“ stella","text":"public subroutine init_redistribute() Uses physics_flags Arguments None Contents None","tags":"","loc":"proc/init_redistribute.html"},{"title":"init_kxkyz_to_vmu_redistribute â€“ stella","text":"private subroutine init_kxkyz_to_vmu_redistribute() Uses mp zgrid stella_layouts vpamu_grids redistribute Arguments None Contents None","tags":"","loc":"proc/init_kxkyz_to_vmu_redistribute.html"},{"title":"init_kxyz_to_vmu_redistribute â€“ stella","text":"private subroutine init_kxyz_to_vmu_redistribute() Uses mp zgrid stella_layouts vpamu_grids redistribute Arguments None Contents None","tags":"","loc":"proc/init_kxyz_to_vmu_redistribute.html"},{"title":"init_xyz_to_vmu_redistribute â€“ stella","text":"private subroutine init_xyz_to_vmu_redistribute() Uses mp zgrid stella_layouts vpamu_grids redistribute Arguments None Contents None","tags":"","loc":"proc/init_xyz_to_vmu_redistribute.html"},{"title":"finish_redistribute â€“ stella","text":"public subroutine finish_redistribute() Arguments None Contents None","tags":"","loc":"proc/finish_redistribute.html"},{"title":"init_bessel â€“ stella","text":"public subroutine init_bessel() Uses stella_geometry spfunc physics_flags vpamu_grids species dist_fn_arrays stella_layouts zgrid kt_grids Arguments None Contents None","tags":"","loc":"proc/init_bessel.html"},{"title":"init_bessel_ffs â€“ stella","text":"private subroutine init_bessel_ffs() Uses stella_geometry spfunc vpamu_grids mp species dist_fn_arrays stella_transforms stella_layouts zgrid kt_grids aj0_alpha will contain J_0 as a function of k_alpha and alpha\nj0_B_maxwell will contain J_0 B exp(-v&#94;2) as a function of k_alpha and alpha\nfor each value of alpha, take kperp&#94;2 calculated on domain kx = [-kx_max, kx_max] and ky = [0, ky_max]\nand use symmetry to obtain kperp&#94;2 on domain kx = [0, kx_max] and ky = [-ky_max, ky_max]\nthis makes later convolutions involving sums over all ky more straightforward\ncalculate the argument of the Bessel function, which depends on both alpha and k_alpha compute J_0 B exp(-v&#94;2), needed when integrating g over v-space in Maxwell's equations,\ndue to B in v-space Jacobian and Maxwellian factor hidden in normalisation of g\nfourier transform aj0_alpha and j0_B_maxwell.\nnote that fourier coefficients aj0_kalpha and j0_B_maxwell_kalpha have\nbeen filtered to avoid aliasing\ngiven the Fourier coefficients aj0_kalpha, calculate the minimum number of coefficients needed,\ncalled j0_ffs%max_idx, to ensure that the relative error in the total spectral energy is below a specified tolerance\ngiven the Fourier coefficients j0_B_maxwell_kalpha, calculate the minimum number of coefficients needed,\ncalled j0_B_maxwell_ffs%max_idx, to ensure that the relative error in the total spectral energy is below a specified tolerance\nkeep track of the total number of coefficients that must be retained across different phase space points\nkeep track of the total number of coefficients that must be retained across different phase space points\nallocate array to hold the reduced number of Fourier coefficients\nfill the array with the requisite coefficients fill the array with the requisite coefficients calculate the reduction factor of Fourier modes\nused to represent J0 Arguments None Contents None","tags":"","loc":"proc/init_bessel_ffs.html"},{"title":"find_max_required_kalpha_index â€“ stella","text":"private subroutine find_max_required_kalpha_index(ft, idx, imu, iz, is) Uses vpamu_grids subroutine takes a set of Fourier coefficients (ft)\nand returns the minimum number of coeffients that must be retained (idx)\nto ensure that the relative error in the total spectral energy is\nbelow a specified tolerance (tol_floor) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: ft integer, intent(out) :: idx integer, intent(in), optional :: imu integer, intent(in), optional :: iz integer, intent(in), optional :: is Contents None","tags":"","loc":"proc/find_max_required_kalpha_index.html"},{"title":"finish_bessel â€“ stella","text":"public subroutine finish_bessel() Arguments None Contents None","tags":"","loc":"proc/finish_bessel.html"},{"title":"gyro_average_kxky_local â€“ stella","text":"private subroutine gyro_average_kxky_local(field, iz, ivmu, gyro_field) Uses physics_flags if simulating a full flux surface, the alpha dependence present\nin kperp makes gyro-averaging non-local in k-space\nif simulating a flux tube, a gyro-average is local in k-space Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: field integer, intent(in) :: iz integer, intent(in) :: ivmu complex, intent(out), dimension(:, :) :: gyro_field Contents None","tags":"","loc":"proc/gyro_average_kxky_local.html"},{"title":"gyro_average_kxkyz_local â€“ stella","text":"private subroutine gyro_average_kxkyz_local(field, ivmu, gyro_field) Uses zgrid physics_flags if simulating a full flux surface, the alpha dependence present\nin kperp makes gyro-averaging non-local in k-space\nif simulating a flux tube, a gyro-average is local in k-space Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: field integer, intent(in) :: ivmu complex, intent(out), dimension(:, :, -nzgrid:, :) :: gyro_field Contents None","tags":"","loc":"proc/gyro_average_kxkyz_local.html"},{"title":"gyro_average_ffs_kxky_local â€“ stella","text":"private subroutine gyro_average_ffs_kxky_local(field, gyro_field, coefs) Uses kt_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: field complex, intent(out), dimension(:, :) :: gyro_field type( coupled_alpha_type ), intent(in), dimension(:, :) :: coefs Contents None","tags":"","loc":"proc/gyro_average_ffs_kxky_local.html"},{"title":"gyro_average_ffs_kxkyz_local â€“ stella","text":"private subroutine gyro_average_ffs_kxkyz_local(field, gyro_field, coefs) Uses zgrid Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: field complex, intent(out), dimension(:, :, -nzgrid:, :) :: gyro_field type( coupled_alpha_type ), intent(in), dimension(:, :, -nzgrid:) :: coefs Contents None","tags":"","loc":"proc/gyro_average_ffs_kxkyz_local.html"},{"title":"gyro_average_ffs â€“ stella","text":"private subroutine gyro_average_ffs(dist, gyro_dist, coefs) Uses common_types stella_layouts zgrid Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dist complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gyro_dist type( coupled_alpha_type ), intent(in), dimension(:, :, -nzgrid:, vmu_lo%llim_proc:) :: coefs Contents None","tags":"","loc":"proc/gyro_average_ffs.html"},{"title":"gyro_average_vmu_local â€“ stella","text":"private subroutine gyro_average_vmu_local(distfn, ikxkyz, gyro_distfn) Uses vpamu_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: distfn integer, intent(in) :: ikxkyz complex, intent(out), dimension(:, :) :: gyro_distfn Contents None","tags":"","loc":"proc/gyro_average_vmu_local.html"},{"title":"gyro_average_vmus_nonlocal â€“ stella","text":"private subroutine gyro_average_vmus_nonlocal(field, iky, ikx, iz, gyro_field) Uses stella_layouts Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(vmu_lo%llim_proc:) :: field integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz complex, intent(out), dimension(vmu_lo%llim_proc:) :: gyro_field Contents None","tags":"","loc":"proc/gyro_average_vmus_nonlocal.html"},{"title":"gyro_average_j1_kxky_local â€“ stella","text":"private subroutine gyro_average_j1_kxky_local(field, iz, ivmu, gyro_field) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: field integer, intent(in) :: iz integer, intent(in) :: ivmu complex, intent(out), dimension(:, :) :: gyro_field Contents None","tags":"","loc":"proc/gyro_average_j1_kxky_local.html"},{"title":"gyro_average_j1_kxkyz_local â€“ stella","text":"private subroutine gyro_average_j1_kxkyz_local(field, ivmu, gyro_field) Uses zgrid Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: field integer, intent(in) :: ivmu complex, intent(out), dimension(:, :, -nzgrid:, :) :: gyro_field Contents None","tags":"","loc":"proc/gyro_average_j1_kxkyz_local.html"},{"title":"gyro_average_j1_vmu_local â€“ stella","text":"private subroutine gyro_average_j1_vmu_local(distfn, ikxkyz, gyro_distfn) Uses vpamu_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: distfn integer, intent(in) :: ikxkyz complex, intent(out), dimension(:, :) :: gyro_distfn Contents None","tags":"","loc":"proc/gyro_average_j1_vmu_local.html"},{"title":"band_lu_solve_ffs â€“ stella","text":"public subroutine band_lu_solve_ffs(lu, solvec) Uses common_types zgrid kt_grids Arguments Type Intent Optional Attributes Name type( gam0_ffs_type ), intent(in), dimension(:, -nzgrid:) :: lu complex, intent(inout), dimension(:, :, -nzgrid:) :: solvec Contents None","tags":"","loc":"proc/band_lu_solve_ffs.html"},{"title":"band_lu_solve_ffs_single â€“ stella","text":"private subroutine band_lu_solve_ffs_single(lu, solvec) Uses common_types kt_grids Arguments Type Intent Optional Attributes Name type( gam0_ffs_type ), intent(in) :: lu complex, intent(inout), dimension(:) :: solvec Contents None","tags":"","loc":"proc/band_lu_solve_ffs_single.html"},{"title":"band_lu_factorisation_ffs â€“ stella","text":"public subroutine band_lu_factorisation_ffs(gam0, lu_gam0) Uses common_types zgrid kt_grids Arguments Type Intent Optional Attributes Name type( coupled_alpha_type ), intent(in), dimension(:, :, -nzgrid:) :: gam0 type( gam0_ffs_type ), intent(out), dimension(:, -nzgrid:) :: lu_gam0 Contents None","tags":"","loc":"proc/band_lu_factorisation_ffs.html"},{"title":"band_lu_factorisation_single â€“ stella","text":"private subroutine band_lu_factorisation_single(gam0, lu_gam0) Uses common_types kt_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gam0 type( gam0_ffs_type ), intent(out) :: lu_gam0 Contents None","tags":"","loc":"proc/band_lu_factorisation_single.html"},{"title":"gyro_average â€“ stella","text":"public interface gyro_average Contents Module Procedures gyro_average_kxky_local gyro_average_kxkyz_local gyro_average_vmu_local gyro_average_vmus_nonlocal gyro_average_ffs_kxky_local gyro_average_ffs_kxkyz_local gyro_average_ffs Module Procedures private subroutine gyro_average_kxky_local (field, iz, ivmu, gyro_field) if simulating a full flux surface, the alpha dependence present\nin kperp makes gyro-averaging non-local in k-space\nif simulating a flux tube, a gyro-average is local in k-space Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: field integer, intent(in) :: iz integer, intent(in) :: ivmu complex, intent(out), dimension(:, :) :: gyro_field private subroutine gyro_average_kxkyz_local (field, ivmu, gyro_field) if simulating a full flux surface, the alpha dependence present\nin kperp makes gyro-averaging non-local in k-space\nif simulating a flux tube, a gyro-average is local in k-space Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: field integer, intent(in) :: ivmu complex, intent(out), dimension(:, :, -nzgrid:, :) :: gyro_field private subroutine gyro_average_vmu_local (distfn, ikxkyz, gyro_distfn) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: distfn integer, intent(in) :: ikxkyz complex, intent(out), dimension(:, :) :: gyro_distfn private subroutine gyro_average_vmus_nonlocal (field, iky, ikx, iz, gyro_field) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(vmu_lo%llim_proc:) :: field integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz complex, intent(out), dimension(vmu_lo%llim_proc:) :: gyro_field private subroutine gyro_average_ffs_kxky_local (field, gyro_field, coefs) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: field complex, intent(out), dimension(:, :) :: gyro_field type( coupled_alpha_type ), intent(in), dimension(:, :) :: coefs private subroutine gyro_average_ffs_kxkyz_local (field, gyro_field, coefs) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: field complex, intent(out), dimension(:, :, -nzgrid:, :) :: gyro_field type( coupled_alpha_type ), intent(in), dimension(:, :, -nzgrid:) :: coefs private subroutine gyro_average_ffs (dist, gyro_dist, coefs) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dist complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gyro_dist type( coupled_alpha_type ), intent(in), dimension(:, :, -nzgrid:, vmu_lo%llim_proc:) :: coefs","tags":"","loc":"interface/gyro_average.html"},{"title":"gyro_average_j1 â€“ stella","text":"public interface gyro_average_j1 Contents Module Procedures gyro_average_j1_kxky_local gyro_average_j1_kxkyz_local gyro_average_j1_vmu_local Module Procedures private subroutine gyro_average_j1_kxky_local (field, iz, ivmu, gyro_field) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: field integer, intent(in) :: iz integer, intent(in) :: ivmu complex, intent(out), dimension(:, :) :: gyro_field private subroutine gyro_average_j1_kxkyz_local (field, ivmu, gyro_field) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: field integer, intent(in) :: ivmu complex, intent(out), dimension(:, :, -nzgrid:, :) :: gyro_field private subroutine gyro_average_j1_vmu_local (distfn, ikxkyz, gyro_distfn) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: distfn integer, intent(in) :: ikxkyz complex, intent(out), dimension(:, :) :: gyro_distfn","tags":"","loc":"interface/gyro_average_j1.html"},{"title":"init_flow_shear â€“ stella","text":"public subroutine init_flow_shear() Uses stella_geometry fields_arrays vpamu_grids physics_flags job_manage mp species constants stella_time file_utils stella_layouts zgrid physics_parameters kt_grids Arguments None Contents None","tags":"","loc":"proc/init_flow_shear.html"},{"title":"advance_parallel_flow_shear â€“ stella","text":"public subroutine advance_parallel_flow_shear(gout) Uses fields_arrays physics_flags fields mp stella_layouts zgrid kt_grids Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout Contents None","tags":"","loc":"proc/advance_parallel_flow_shear.html"},{"title":"advance_perp_flow_shear â€“ stella","text":"public subroutine advance_perp_flow_shear(g) Uses fields_arrays physics_flags stella_time constants file_utils stella_transforms stella_layouts zgrid kt_grids Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g Contents None","tags":"","loc":"proc/advance_perp_flow_shear.html"},{"title":"finish_flow_shear â€“ stella","text":"public subroutine finish_flow_shear() Uses fields_arrays Arguments None Contents None","tags":"","loc":"proc/finish_flow_shear.html"},{"title":"stella_save_for_restart â€“ stella","text":"public subroutine stella_save_for_restart(g, istep0, t0, delt0, istatus, exit_in, fileopt) Uses common_types vpamu_grids physics_flags mp sources file_utils stella_layouts zgrid Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g integer, intent(in) :: istep0 real, intent(in) :: t0 real, intent(in) :: delt0 integer, intent(out) :: istatus logical, intent(in), optional :: exit_in character(len=20), intent(in), optional :: fileopt Contents None","tags":"","loc":"proc/stella_save_for_restart.html"},{"title":"stella_restore_many â€“ stella","text":"private subroutine stella_restore_many(g, scale, istatus) Uses vpamu_grids physics_flags mp sources file_utils stella_layouts zgrid Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :, kxkyz_lo%llim_proc:) :: g real, intent(in) :: scale integer, intent(out) :: istatus Contents None","tags":"","loc":"proc/stella_restore_many.html"},{"title":"init_save â€“ stella","text":"public subroutine init_save(file) Arguments Type Intent Optional Attributes Name character(len=300), intent(in) :: file Contents None","tags":"","loc":"proc/init_save.html"},{"title":"init_dt â€“ stella","text":"public subroutine init_dt(delt0, istatus) Arguments Type Intent Optional Attributes Name real, intent(inout) :: delt0 integer, intent(out) :: istatus Contents None","tags":"","loc":"proc/init_dt.html"},{"title":"init_tstart â€“ stella","text":"public subroutine init_tstart(tstart, istep0, istatus) Arguments Type Intent Optional Attributes Name real, intent(inout) :: tstart integer, intent(out) :: istep0 integer, intent(out) :: istatus Contents None","tags":"","loc":"proc/init_tstart.html"},{"title":"finish_save â€“ stella","text":"public subroutine finish_save() Arguments None Contents None","tags":"","loc":"proc/finish_save.html"},{"title":"stella_restore â€“ stella","text":"public interface stella_restore Contents Module Procedures stella_restore_many Module Procedures private subroutine stella_restore_many (g, scale, istatus) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :, kxkyz_lo%llim_proc:) :: g real, intent(in) :: scale integer, intent(out) :: istatus","tags":"","loc":"interface/stella_restore.html"},{"title":"associated_laguerre â€“ stella","text":"private elemental function associated_laguerre(n, alpha, x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real, intent(in) :: alpha real, intent(in) :: x Return Value real Contents None","tags":"","loc":"proc/associated_laguerre.html"},{"title":"associated_legendre â€“ stella","text":"private elemental function associated_legendre(l, m, x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: l integer, intent(in) :: m double precision, intent(in) :: x Return Value double precision Contents None","tags":"","loc":"proc/associated_legendre.html"},{"title":"init_dissipation â€“ stella","text":"public subroutine init_dissipation() Uses mp Arguments None Contents None","tags":"","loc":"proc/init_dissipation.html"},{"title":"read_parameters â€“ stella","text":"private subroutine read_parameters() Uses run_parameters mp file_utils physics_flags Arguments None Contents None","tags":"","loc":"proc/read_parameters~7.html"},{"title":"init_collisions â€“ stella","text":"public subroutine init_collisions() Uses stella_geometry run_parameters common_types species stella_layouts vpamu_grids Arguments None Contents None","tags":"","loc":"proc/init_collisions.html"},{"title":"init_nusDpa â€“ stella","text":"private subroutine init_nusDpa() Uses stella_geometry spfunc vpamu_grids species finite_differences constants zgrid Arguments None Contents None","tags":"","loc":"proc/init_nusdpa.html"},{"title":"finish_nusDpa â€“ stella","text":"private subroutine finish_nusDpa() Arguments None Contents None","tags":"","loc":"proc/finish_nusdpa.html"},{"title":"init_fp_diffmatrix â€“ stella","text":"private subroutine init_fp_diffmatrix() Uses stella_geometry common_types spfunc zgrid species constants stella_time dist_fn_arrays stella_layouts vpamu_grids physics_parameters file_utils kt_grids Arguments None Contents None","tags":"","loc":"proc/init_fp_diffmatrix.html"},{"title":"init_legendre â€“ stella","text":"private subroutine init_legendre() Uses stella_geometry zgrid file_utils stella_layouts vpamu_grids Arguments None Contents None","tags":"","loc":"proc/init_legendre.html"},{"title":"init_bessel_fn â€“ stella","text":"private subroutine init_bessel_fn() Uses stella_geometry vpamu_grids gyro_averages species file_utils dist_fn_arrays stella_layouts zgrid kt_grids Arguments None Contents None","tags":"","loc":"proc/init_bessel_fn.html"},{"title":"init_vgrid â€“ stella","text":"private subroutine init_vgrid() Uses stella_geometry vpamu_grids Arguments None Contents None","tags":"","loc":"proc/init_vgrid.html"},{"title":"gamlow â€“ stella","text":"private recursive subroutine gamlow(a, x, gl) Uses spfunc constants Arguments Type Intent Optional Attributes Name real, intent(in) :: a real, intent(in) :: x real, intent(out) :: gl Contents None","tags":"","loc":"proc/gamlow.html"},{"title":"gamup â€“ stella","text":"private recursive subroutine gamup(a, x, gu) Uses spfunc constants Arguments Type Intent Optional Attributes Name real, intent(in) :: a real, intent(in) :: x real, intent(out) :: gu Contents None","tags":"","loc":"proc/gamup.html"},{"title":"calc_delta0 â€“ stella","text":"private subroutine calc_delta0(xa, jj, ll, isa, isb, delt0) Uses constants species Arguments Type Intent Optional Attributes Name real, intent(in) :: xa integer, intent(in) :: jj integer, intent(in) :: ll integer, intent(in) :: isa integer, intent(in) :: isb real, intent(out) :: delt0 Contents None","tags":"","loc":"proc/calc_delta0.html"},{"title":"calc_deltaj_vmu â€“ stella","text":"private recursive subroutine calc_deltaj_vmu(jj, nn, ll, isa, isb, deltj) Uses stella_geometry vpamu_grids zgrid species Arguments Type Intent Optional Attributes Name integer, intent(in) :: jj integer, intent(in) :: nn integer, intent(in) :: ll integer, intent(in) :: isa integer, intent(in) :: isb real, intent(out), dimension(nvpa, nmu, -nzgrid:nzgrid) :: deltj Contents None","tags":"","loc":"proc/calc_deltaj_vmu.html"},{"title":"vLj_vmu â€“ stella","text":"private subroutine vLj_vmu(jj, ll, vLj) Uses stella_geometry vpamu_grids zgrid species Arguments Type Intent Optional Attributes Name integer, intent(in) :: jj integer, intent(in) :: ll real, intent(out), dimension(nvpa, nmu, -nzgrid:nzgrid) :: vLj Contents None","tags":"","loc":"proc/vlj_vmu.html"},{"title":"calc_psi_vmu â€“ stella","text":"private recursive subroutine calc_psi_vmu(jj, nn, ll, isa, isb, psij) Uses vpamu_grids zgrid species Arguments Type Intent Optional Attributes Name integer, intent(in) :: jj integer, intent(in) :: nn integer, intent(in) :: ll integer, intent(in) :: isa integer, intent(in) :: isb real, intent(out), dimension(-nzgrid:nzgrid) :: psij Contents None","tags":"","loc":"proc/calc_psi_vmu.html"},{"title":"init_deltaj_vmu â€“ stella","text":"private subroutine init_deltaj_vmu() Uses stella_geometry vpamu_grids species file_utils constants stella_time stella_layouts zgrid kt_grids Arguments None Contents None","tags":"","loc":"proc/init_deltaj_vmu.html"},{"title":"get_testpart_density â€“ stella","text":"private subroutine get_testpart_density(isa, isb, g, fld) Uses vpamu_grids mp species constants file_utils stella_time stella_layouts zgrid Arguments Type Intent Optional Attributes Name integer, intent(in) :: isa integer, intent(in) :: isb complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: fld Contents None","tags":"","loc":"proc/get_testpart_density.html"},{"title":"init_fp_conserve â€“ stella","text":"private subroutine init_fp_conserve() Uses fields job_manage linear_solve zgrid species file_utils stella_time dist_fn_arrays stella_layouts vpamu_grids constants kt_grids Arguments None Contents None","tags":"","loc":"proc/init_fp_conserve.html"},{"title":"get_psi_response â€“ stella","text":"private subroutine get_psi_response(ll, mm, jj, isa, response) Uses vpamu_grids fields linear_solve job_manage species finite_differences constants stella_time file_utils stella_layouts zgrid kt_grids Arguments Type Intent Optional Attributes Name integer, intent(in) :: ll integer, intent(in) :: mm integer, intent(in) :: jj integer, intent(in) :: isa complex, intent(out), dimension(:, :, kxkyz_lo%llim_proc:) :: response Contents None","tags":"","loc":"proc/get_psi_response.html"},{"title":"get_psi â€“ stella","text":"private subroutine get_psi(g, fld, isa, isb, ll, mm, jj) Uses vpamu_grids mp species constants file_utils stella_time stella_layouts zgrid Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: fld integer, intent(in) :: isa integer, intent(in) :: isb integer, intent(in) :: ll integer, intent(in) :: mm integer, intent(in) :: jj Contents None","tags":"","loc":"proc/get_psi.html"},{"title":"init_vpadiff_matrix â€“ stella","text":"private subroutine init_vpadiff_matrix() Uses stella_geometry species stella_time dist_fn_arrays stella_layouts vpamu_grids Arguments None Contents None","tags":"","loc":"proc/init_vpadiff_matrix.html"},{"title":"init_mudiff_matrix â€“ stella","text":"private subroutine init_mudiff_matrix() Uses stella_geometry vpamu_grids species stella_time dist_fn_arrays stella_layouts zgrid Arguments None Contents None","tags":"","loc":"proc/init_mudiff_matrix.html"},{"title":"init_vpadiff_conserve â€“ stella","text":"private subroutine init_vpadiff_conserve() Uses stella_geometry vpamu_grids fields mp linear_solve physics_flags gyro_averages species finite_differences stella_time dist_fn_arrays stella_layouts zgrid kt_grids Arguments None Contents None","tags":"","loc":"proc/init_vpadiff_conserve.html"},{"title":"init_mudiff_conserve â€“ stella","text":"private subroutine init_mudiff_conserve() Uses stella_geometry vpamu_grids fields mp linear_solve physics_flags gyro_averages species finite_differences stella_time dist_fn_arrays stella_layouts zgrid kt_grids Arguments None Contents None","tags":"","loc":"proc/init_mudiff_conserve.html"},{"title":"get_upar â€“ stella","text":"private subroutine get_upar(g, fld) Uses vpamu_grids mp gyro_averages stella_layouts zgrid Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: fld Contents None","tags":"","loc":"proc/get_upar.html"},{"title":"get_uperp â€“ stella","text":"private subroutine get_uperp(g, fld) Uses vpamu_grids mp gyro_averages stella_layouts zgrid Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: fld Contents None","tags":"","loc":"proc/get_uperp.html"},{"title":"get_temp â€“ stella","text":"private subroutine get_temp(g, fld) Uses vpamu_grids mp gyro_averages stella_layouts zgrid Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: fld Contents None","tags":"","loc":"proc/get_temp.html"},{"title":"get_temp_mu â€“ stella","text":"private subroutine get_temp_mu(g, fld) Uses vpamu_grids mp gyro_averages stella_layouts zgrid Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: fld Contents None","tags":"","loc":"proc/get_temp_mu.html"},{"title":"finish_dissipation â€“ stella","text":"public subroutine finish_dissipation() Arguments None Contents None","tags":"","loc":"proc/finish_dissipation.html"},{"title":"finish_collisions â€“ stella","text":"private subroutine finish_collisions() Arguments None Contents None","tags":"","loc":"proc/finish_collisions.html"},{"title":"finish_deltaj â€“ stella","text":"private subroutine finish_deltaj() Arguments None Contents None","tags":"","loc":"proc/finish_deltaj.html"},{"title":"finish_fp_diffmatrix â€“ stella","text":"private subroutine finish_fp_diffmatrix() Arguments None Contents None","tags":"","loc":"proc/finish_fp_diffmatrix.html"},{"title":"finish_fp_response â€“ stella","text":"private subroutine finish_fp_response() Arguments None Contents None","tags":"","loc":"proc/finish_fp_response.html"},{"title":"finish_vpadiff_matrix â€“ stella","text":"private subroutine finish_vpadiff_matrix() Arguments None Contents None","tags":"","loc":"proc/finish_vpadiff_matrix.html"},{"title":"finish_mudiff_matrix â€“ stella","text":"private subroutine finish_mudiff_matrix() Arguments None Contents None","tags":"","loc":"proc/finish_mudiff_matrix.html"},{"title":"finish_vpadiff_response â€“ stella","text":"private subroutine finish_vpadiff_response() Arguments None Contents None","tags":"","loc":"proc/finish_vpadiff_response.html"},{"title":"finish_mudiff_response â€“ stella","text":"private subroutine finish_mudiff_response() Arguments None Contents None","tags":"","loc":"proc/finish_mudiff_response.html"},{"title":"advance_collisions_explicit â€“ stella","text":"public subroutine advance_collisions_explicit(g, phi, gke_rhs) Uses stella_geometry run_parameters fields_arrays physics_flags job_manage mp vpamu_grids stella_transforms g_tofrom_h species dist_redistribute stella_time dist_fn_arrays stella_layouts zgrid redistribute kt_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gke_rhs Contents None","tags":"","loc":"proc/advance_collisions_explicit.html"},{"title":"vpa_differential_operator_fp â€“ stella","text":"private subroutine vpa_differential_operator_fp(h, Dh, imu, iz, is, ia) Uses stella_geometry vpamu_grids constants species Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: h complex, intent(out), dimension(:, :) :: Dh integer, intent(in) :: imu integer, intent(in) :: iz integer, intent(in) :: is integer, intent(in) :: ia Contents None","tags":"","loc":"proc/vpa_differential_operator_fp.html"},{"title":"mu_differential_operator_fp â€“ stella","text":"private subroutine mu_differential_operator_fp(h, Dh, iv, iz, is, ia, iky, ikx, cfac) Uses stella_geometry job_manage species constants dist_fn_arrays vpamu_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: h complex, intent(out), dimension(:, :) :: Dh integer, intent(in) :: iv integer, intent(in) :: iz integer, intent(in) :: is integer, intent(in) :: ia integer, intent(in) :: iky integer, intent(in) :: ikx real, intent(in) :: cfac Contents None","tags":"","loc":"proc/mu_differential_operator_fp.html"},{"title":"vpa_differential_operator_fp_conservative â€“ stella","text":"private subroutine vpa_differential_operator_fp_conservative(h, Dh, imu, iz, is, ia) Uses stella_geometry vpamu_grids constants species Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: h complex, intent(out), dimension(:, :) :: Dh integer, intent(in) :: imu integer, intent(in) :: iz integer, intent(in) :: is integer, intent(in) :: ia Contents None","tags":"","loc":"proc/vpa_differential_operator_fp_conservative.html"},{"title":"mu_differential_operator_fp_conservative â€“ stella","text":"private subroutine mu_differential_operator_fp_conservative(h, Dh, iv, iz, is, ia, iky, ikx, cfac) Uses stella_geometry job_manage species constants dist_fn_arrays vpamu_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: h complex, intent(out), dimension(:, :) :: Dh integer, intent(in) :: iv integer, intent(in) :: iz integer, intent(in) :: is integer, intent(in) :: ia integer, intent(in) :: iky integer, intent(in) :: ikx real, intent(in) :: cfac Contents None","tags":"","loc":"proc/mu_differential_operator_fp_conservative.html"},{"title":"vpa_differential_operator â€“ stella","text":"private subroutine vpa_differential_operator(tfac, h, Dh) Uses vpamu_grids Arguments Type Intent Optional Attributes Name real, intent(in) :: tfac complex, intent(in), dimension(:) :: h complex, intent(out), dimension(:) :: Dh Contents None","tags":"","loc":"proc/vpa_differential_operator.html"},{"title":"mu_differential_operator â€“ stella","text":"private subroutine mu_differential_operator(tfac, iz, ia, h, Dh) Uses stella_geometry vpamu_grids Arguments Type Intent Optional Attributes Name real, intent(in) :: tfac integer, intent(in) :: iz integer, intent(in) :: ia complex, intent(in), dimension(:) :: h complex, intent(out), dimension(:) :: Dh Contents None","tags":"","loc":"proc/mu_differential_operator.html"},{"title":"conserve_momentum â€“ stella","text":"private subroutine conserve_momentum(iky, ikx, iz, is, ikxkyz, h, Ch) Uses stella_geometry gyro_averages species dist_fn_arrays vpamu_grids Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: is integer, intent(in) :: ikxkyz complex, intent(in), dimension(:, :) :: h complex, intent(inout), dimension(:, :) :: Ch Contents None","tags":"","loc":"proc/conserve_momentum.html"},{"title":"conserve_energy â€“ stella","text":"private subroutine conserve_energy(iz, is, ikxkyz, h, Ch) Uses vpamu_grids gyro_averages Arguments Type Intent Optional Attributes Name integer, intent(in) :: iz integer, intent(in) :: is integer, intent(in) :: ikxkyz complex, intent(in), dimension(:, :) :: h complex, intent(inout), dimension(:, :) :: Ch Contents None","tags":"","loc":"proc/conserve_energy.html"},{"title":"conserve_momentum_vmulo â€“ stella","text":"private subroutine conserve_momentum_vmulo(h, gke_rhs) Uses stella_geometry physics_flags vpamu_grids mp gyro_averages species stella_time dist_fn_arrays stella_layouts zgrid kt_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: h complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gke_rhs Contents None","tags":"","loc":"proc/conserve_momentum_vmulo.html"},{"title":"conserve_energy_vmulo â€“ stella","text":"private subroutine conserve_energy_vmulo(h, gke_rhs) Uses stella_geometry physics_flags vpamu_grids mp gyro_averages species stella_time dist_fn_arrays stella_layouts zgrid kt_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: h complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gke_rhs Contents None","tags":"","loc":"proc/conserve_energy_vmulo.html"},{"title":"advance_collisions_implicit â€“ stella","text":"public subroutine advance_collisions_implicit(mirror_implicit, phi, apar, g) Uses vpamu_grids job_manage mp dist_redistribute dist_fn_arrays stella_layouts zgrid redistribute Arguments Type Intent Optional Attributes Name logical, intent(in) :: mirror_implicit complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :) :: apar complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g Contents None","tags":"","loc":"proc/advance_collisions_implicit.html"},{"title":"advance_implicit_fp â€“ stella","text":"private subroutine advance_implicit_fp(phi, apar, g) Uses run_parameters vpamu_grids fields mp linear_solve g_tofrom_h species finite_differences constants stella_time stella_layouts zgrid kt_grids Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :) :: apar complex, intent(inout), dimension(:, :, kxkyz_lo%llim_proc:) :: g Contents None","tags":"","loc":"proc/advance_implicit_fp.html"},{"title":"advance_vpadiff_implicit â€“ stella","text":"private subroutine advance_vpadiff_implicit(phi, apar, g) Uses stella_geometry run_parameters vpamu_grids fields mp linear_solve physics_flags g_tofrom_h gyro_averages species finite_differences stella_time stella_layouts zgrid kt_grids Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :) :: apar complex, intent(inout), dimension(:, :, kxkyz_lo%llim_proc:) :: g Contents None","tags":"","loc":"proc/advance_vpadiff_implicit.html"},{"title":"advance_mudiff_implicit â€“ stella","text":"private subroutine advance_mudiff_implicit(phi, apar, g) Uses stella_geometry run_parameters vpamu_grids fields mp linear_solve physics_flags gyro_averages g_tofrom_h species finite_differences stella_time dist_fn_arrays stella_layouts zgrid kt_grids Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :) :: apar complex, intent(inout), dimension(:, :, kxkyz_lo%llim_proc:) :: g Contents None","tags":"","loc":"proc/advance_mudiff_implicit.html"},{"title":"advance_hyper_dissipation â€“ stella","text":"public subroutine advance_hyper_dissipation(g) Uses stella_geometry stella_time dist_fn_arrays stella_layouts zgrid kt_grids Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g Contents None","tags":"","loc":"proc/advance_hyper_dissipation.html"},{"title":"read_kt_grids_parameters â€“ stella","text":"public subroutine read_kt_grids_parameters() Uses mp Arguments None Contents None","tags":"","loc":"proc/read_kt_grids_parameters.html"},{"title":"read_grid_option â€“ stella","text":"private subroutine read_grid_option() Uses text_options file_utils Arguments None Contents None","tags":"","loc":"proc/read_grid_option.html"},{"title":"read_kt_grids_box â€“ stella","text":"private subroutine read_kt_grids_box() Uses file_utils physics_flags Arguments None Contents None","tags":"","loc":"proc/read_kt_grids_box.html"},{"title":"read_kt_grids_range â€“ stella","text":"private subroutine read_kt_grids_range() Uses mp file_utils physics_flags Arguments None Contents None","tags":"","loc":"proc/read_kt_grids_range.html"},{"title":"init_kt_grids â€“ stella","text":"public subroutine init_kt_grids() Uses common_types zgrid determine if iky corresponds to zonal mode Arguments None Contents None","tags":"","loc":"proc/init_kt_grids.html"},{"title":"init_kt_grids_box â€“ stella","text":"private subroutine init_kt_grids_box() Uses common_types stella_geometry physics_flags mp ran constants physics_parameters file_utils zgrid set jtwist and y0 for cases where they have not been specified\nand for which it makes sense to set them automatically\nsigned version of jtwist, with sign determined by, e.g., magnetic shear if simulating a flux annulus, then\ny0 determined by the physical\nextent of the device if simulating a flux tube\nmakes no sense to have y0 < 0.0\nso abort\nget the grid spacing in ky and then in kx using twist-and-shift BC MAB: this seems overly restrictive; should allow for arbitrary box aspect ratio via inpur parameter\nky goes from zero to ky_max\nget the ikx index corresponding to kx_max aky_all contains all ky values (positive and negative),\nstored in the same order as akx (0 -> ky_max, -ky_max -> -dky)\nfirst set arrays equal for ky >= 0\naky_all_ordered contains all ky values, stored from\nmost negative to most positive (-ky_max -> ky_max)\nnext fill in ky < 0\nthis is the ky index corresponding to +ky in original array\nkx goes from zero to kx_max down to zero...\nand then from -kx_max to -|kx_min|\nset theta0=0 for ky=0\ntheta0 = kx/ky\ntheta0 = kx/ky/shat\nMAB: a lot of the radial variation coding below should probably be tidied away\ninto one or more separate subroutines\nfor radial variation Arguments None Contents None","tags":"","loc":"proc/init_kt_grids_box.html"},{"title":"init_kt_grids_range â€“ stella","text":"private subroutine init_kt_grids_range() Uses common_types mp zgrid stella_geometry Arguments None Contents None","tags":"","loc":"proc/init_kt_grids_range.html"},{"title":"broadcast_input â€“ stella","text":"private subroutine broadcast_input() Uses mp Arguments None Contents None","tags":"","loc":"proc/broadcast_input.html"},{"title":"dump_radial_grid â€“ stella","text":"private subroutine dump_radial_grid() Uses stella_geometry file_utils physics_parameters Arguments None Contents None","tags":"","loc":"proc/dump_radial_grid.html"},{"title":"allocate_arrays â€“ stella","text":"private subroutine allocate_arrays() Arguments None Contents None","tags":"","loc":"proc/allocate_arrays~4.html"},{"title":"swap_kxky_complex â€“ stella","text":"private subroutine swap_kxky_complex(gin, gout) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout Contents None","tags":"","loc":"proc/swap_kxky_complex.html"},{"title":"swap_kxky_real â€“ stella","text":"private subroutine swap_kxky_real(gin, gout) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: gin real, intent(out), dimension(:, :) :: gout Contents None","tags":"","loc":"proc/swap_kxky_real.html"},{"title":"swap_kxky_ordered_real â€“ stella","text":"private subroutine swap_kxky_ordered_real(gin, gout) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: gin real, intent(out), dimension(:, :) :: gout Contents None","tags":"","loc":"proc/swap_kxky_ordered_real.html"},{"title":"swap_kxky_ordered_complex â€“ stella","text":"private subroutine swap_kxky_ordered_complex(gin, gout) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout Contents None","tags":"","loc":"proc/swap_kxky_ordered_complex.html"},{"title":"swap_kxky_back â€“ stella","text":"public subroutine swap_kxky_back(gin, gout) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout Contents None","tags":"","loc":"proc/swap_kxky_back.html"},{"title":"swap_kxky_back_ordered â€“ stella","text":"public subroutine swap_kxky_back_ordered(gin, gout) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout Contents None","tags":"","loc":"proc/swap_kxky_back_ordered.html"},{"title":"communicate_ktgrids_multibox â€“ stella","text":"public subroutine communicate_ktgrids_multibox() Uses job_manage mp Arguments None Contents None","tags":"","loc":"proc/communicate_ktgrids_multibox.html"},{"title":"finish_kt_grids â€“ stella","text":"public subroutine finish_kt_grids() Arguments None Contents None","tags":"","loc":"proc/finish_kt_grids.html"},{"title":"multiply_by_rho â€“ stella","text":"public subroutine multiply_by_rho(gin) Uses stella_transforms Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: gin Contents None","tags":"","loc":"proc/multiply_by_rho.html"},{"title":"swap_kxky â€“ stella","text":"public interface swap_kxky Contents Module Procedures swap_kxky_real swap_kxky_complex Module Procedures private subroutine swap_kxky_real (gin, gout) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: gin real, intent(out), dimension(:, :) :: gout private subroutine swap_kxky_complex (gin, gout) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout","tags":"","loc":"interface/swap_kxky.html"},{"title":"swap_kxky_ordered â€“ stella","text":"public interface swap_kxky_ordered Contents Module Procedures swap_kxky_ordered_real swap_kxky_ordered_complex Module Procedures private subroutine swap_kxky_ordered_real (gin, gout) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: gin real, intent(out), dimension(:, :) :: gout private subroutine swap_kxky_ordered_complex (gin, gout) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout","tags":"","loc":"interface/swap_kxky_ordered.html"},{"title":"init_physics_parameters â€“ stella","text":"public subroutine init_physics_parameters() Arguments None Contents None","tags":"","loc":"proc/init_physics_parameters.html"},{"title":"read_parameters â€“ stella","text":"private subroutine read_parameters() Uses mp file_utils Arguments None Contents None","tags":"","loc":"proc/read_parameters~8.html"},{"title":"finish_physics_parameters â€“ stella","text":"public subroutine finish_physics_parameters() Arguments None Contents None","tags":"","loc":"proc/finish_physics_parameters.html"},{"title":"get_neo_from_sfincs â€“ stella","text":"public subroutine get_neo_from_sfincs(nradii, drho, f_neoclassical, phi_neoclassical, dfneo_dalpha, dphineo_dalpha) Uses mp zgrid Arguments Type Intent Optional Attributes Name integer, intent(in) :: nradii real, intent(in) :: drho real, intent(out), dimension(:, -nzgrid:, :, :, :, -nradii/2:) :: f_neoclassical real, intent(out), dimension(:, -nzgrid:, -nradii/2:) :: phi_neoclassical real, intent(out), dimension(:, -nzgrid:, :, :, :) :: dfneo_dalpha real, intent(out), dimension(:, -nzgrid:) :: dphineo_dalpha Contents None","tags":"","loc":"proc/get_neo_from_sfincs.html"},{"title":"init_response_matrix â€“ stella","text":"public subroutine init_response_matrix() Uses run_parameters job_manage linear_solve mp extended_zgrid stella_layouts fields_arrays system_fortran kt_grids Arguments None Contents None","tags":"","loc":"proc/init_response_matrix.html"},{"title":"read_response_matrix â€“ stella","text":"public subroutine read_response_matrix() Uses common_types mp extended_zgrid fields_arrays kt_grids Arguments None Contents None","tags":"","loc":"proc/read_response_matrix.html"},{"title":"get_dgdphi_matrix_column â€“ stella","text":"private subroutine get_dgdphi_matrix_column(iky, ikx, iz, ie, idx, nz_ext, nresponse, phiext, gext) Uses stella_geometry fields_arrays run_parameters vpamu_grids gyro_averages species extended_zgrid stella_time stella_layouts zgrid parallel_streaming Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: ie integer, intent(in) :: idx integer, intent(in) :: nz_ext integer, intent(in) :: nresponse complex, intent(inout), dimension(:) :: phiext complex, intent(inout), dimension(:, vmu_lo%llim_proc:) :: gext Contents None","tags":"","loc":"proc/get_dgdphi_matrix_column.html"},{"title":"sweep_zed_zonal_response â€“ stella","text":"private subroutine sweep_zed_zonal_response(iv, is, sgn, g) Uses run_parameters zgrid parallel_streaming Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv integer, intent(in) :: is integer, intent(in) :: sgn complex, intent(inout), dimension(:) :: g Contents None","tags":"","loc":"proc/sweep_zed_zonal_response.html"},{"title":"integrate_over_velocity â€“ stella","text":"private subroutine integrate_over_velocity(g, phi, iky, ie) Uses mp gyro_averages species extended_zgrid stella_layouts vpamu_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:) :: phi integer, intent(in) :: iky integer, intent(in) :: ie Contents None","tags":"","loc":"proc/integrate_over_velocity.html"},{"title":"get_fields_for_response_matrix â€“ stella","text":"private subroutine get_fields_for_response_matrix(phi, iky, ie) Uses stella_geometry fields_arrays physics_flags species extended_zgrid stella_layouts kt_grids Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: phi integer, intent(in) :: iky integer, intent(in) :: ie Contents None","tags":"","loc":"proc/get_fields_for_response_matrix.html"},{"title":"finish_response_matrix â€“ stella","text":"public subroutine finish_response_matrix() Uses fields_arrays Arguments None Contents None","tags":"","loc":"proc/finish_response_matrix.html"},{"title":"init_zgrid â€“ stella","text":"public subroutine init_zgrid() Uses mp constants Arguments None Contents None","tags":"","loc":"proc/init_zgrid.html"},{"title":"read_parameters â€“ stella","text":"private subroutine read_parameters() Uses text_options file_utils physics_flags Arguments None Contents None","tags":"","loc":"proc/read_parameters~9.html"},{"title":"broadcast_parameters â€“ stella","text":"private subroutine broadcast_parameters() Uses mp Arguments None Contents None","tags":"","loc":"proc/broadcast_parameters.html"},{"title":"finish_zgrid â€“ stella","text":"public subroutine finish_zgrid() Arguments None Contents None","tags":"","loc":"proc/finish_zgrid.html"},{"title":"get_total_arc_length â€“ stella","text":"public subroutine get_total_arc_length(nz, gp, dz, length) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nz real, intent(in), dimension(-nz:) :: gp real, intent(in) :: dz real, intent(out) :: length Contents None","tags":"","loc":"proc/get_total_arc_length.html"},{"title":"get_arc_length_grid â€“ stella","text":"public subroutine get_arc_length_grid(nz_max, nzext_max, zboundary, gp, dz, zarc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nz_max integer, intent(in) :: nzext_max real, intent(in) :: zboundary real, intent(in), dimension(-nzext_max:) :: gp real, intent(in) :: dz real, intent(out), dimension(-nzext_max:) :: zarc Contents None","tags":"","loc":"proc/get_arc_length_grid.html"},{"title":"integrate_zed â€“ stella","text":"private subroutine integrate_zed(nz, dz, f, intf) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nz real, intent(in) :: dz real, intent(in), dimension(-nz:) :: f real, intent(out) :: intf Contents None","tags":"","loc":"proc/integrate_zed.html"},{"title":"init_stella_diagnostics â€“ stella","text":"public subroutine init_stella_diagnostics(restart, tstart) Uses run_parameters dist_fn mp species stella_io physics_parameters zgrid init_g kt_grids Initialise the stella_diagnostics module Broadcast the parameters from the namelist \"stella_diagnostics_knobs\"\nand open/append the netcdf file and the ascii files. Make sure the other routines are intialized\nRead the namelist \"stella_diagnostics_knobs\" in the input file\nBroadcast the variables to all processors\nInitiate the netcdf file with extension '.out.nc' Open the '.out', '.fluxes' and '.omega' file Get the final position nout of the time axis in the netcdf file Arguments Type Intent Optional Attributes Name logical, intent(in) :: restart Has this simulation been restarted? real, intent(in) :: tstart Current simulation time Contents None","tags":"","loc":"proc/init_stella_diagnostics.html"},{"title":"read_parameters â€“ stella","text":"private subroutine read_parameters() Uses mp zgrid file_utils physics_flags Read the diagnostic input parameters from the input file Namelist: stella_diagnostics_knobs Arguments None Contents None","tags":"","loc":"proc/read_parameters.html"},{"title":"allocate_arrays â€“ stella","text":"private subroutine allocate_arrays() Uses kt_grids species Allocate the module-level arrays Arguments None Contents None","tags":"","loc":"proc/allocate_arrays.html"},{"title":"open_loop_ascii_files â€“ stella","text":"private subroutine open_loop_ascii_files(restart) Uses file_utils species Open the '.out' and the '.fluxes' file. When running a new simulation, create a new file or replace an old file.\nWhen restarting a simulation, append the old files. Arguments Type Intent Optional Attributes Name logical, intent(in) :: restart Contents None","tags":"","loc":"proc/open_loop_ascii_files.html"},{"title":"close_loop_ascii_files â€“ stella","text":"private subroutine close_loop_ascii_files() Uses file_utils Close the text files opened by open_loop_ascii_files Arguments None Contents None","tags":"","loc":"proc/close_loop_ascii_files.html"},{"title":"diagnose_stella â€“ stella","text":"public subroutine diagnose_stella(istep) Uses run_parameters fields vpamu_grids mp physics_flags stella_time species stella_io dist_redistribute constants g_tofrom_h dist_fn_arrays fields_arrays zgrid volume_averages redistribute kt_grids Calculate and write diagnostics only write data to file every nwrite time steps get the updated fields corresponding to gnew obtain turbulent fluxes calculate the particle density, parallel flow and pressure in (y,kx,z) space\nfor all species\ncalculate the (ky,kx) contributions to the particle, parallel momentum and energy fluxes\nredistribute data so that data for each vpa and mu are guaranteed to be on each processor\nget_fluxes assumes the non-Boltzmann part of the distribution, h, is passed in;\nconvert from = g to h\ncompute the fluxes\nconvert back from h to g Arguments Type Intent Optional Attributes Name integer, intent(in) :: istep The current timestep Contents None","tags":"","loc":"proc/diagnose_stella.html"},{"title":"get_fluxes â€“ stella","text":"private subroutine get_fluxes(g, pflx, vflx, qflx, pflx_vs_kxkyz, vflx_vs_kxkyz, qflx_vs_kxkyz) Uses stella_geometry run_parameters vpamu_grids mp gyro_averages species constants stella_layouts fields_arrays zgrid kt_grids Calculate fluxes Assumes that the non-Boltzmann part of df is passed in (aka h) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g real, intent(out), dimension(:) :: pflx real, intent(out), dimension(:) :: vflx real, intent(out), dimension(:) :: qflx real, intent(out), dimension(:, :, -nzgrid:, :, :) :: pflx_vs_kxkyz real, intent(out), dimension(:, :, -nzgrid:, :, :) :: vflx_vs_kxkyz real, intent(out), dimension(:, :, -nzgrid:, :, :) :: qflx_vs_kxkyz Contents None","tags":"","loc":"proc/get_fluxes.html"},{"title":"get_fluxes_vmulo â€“ stella","text":"private subroutine get_fluxes_vmulo(g, phi, pflx, vflx, qflx, pflx_x, vflx_x, qflx_x) Uses stella_geometry run_parameters vpamu_grids physics_flags mp gyro_averages species constants dist_fn_arrays stella_layouts zgrid kt_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi real, intent(out), dimension(:) :: pflx real, intent(out), dimension(:) :: vflx real, intent(out), dimension(:) :: qflx real, intent(out), dimension(:, :) :: pflx_x real, intent(out), dimension(:, :) :: vflx_x real, intent(out), dimension(:, :) :: qflx_x Contents None","tags":"","loc":"proc/get_fluxes_vmulo.html"},{"title":"get_fluxes_ffs â€“ stella","text":"private subroutine get_fluxes_ffs(dens, upar, pres, pflx, vflx, qflx, pflx_vs_kxkyz, vflx_vs_kxkyz, qflx_vs_kxkyz) Uses stella_geometry species constants fields_arrays zgrid kt_grids Calculate the total particle, momentum and heat fluxes (pflx, vflx, qflx)\nand the contributions from a given (kx,ky,z) location (pflx_kxkyz, vflx_kxkyz, qflx_kxkyz)\ninputs are the particle density (dens), parallel flow (upar) and pressure (pres) assume a single flux annulus obtain the y-component of the electric field that appears as a factor\nin the flux expression due to the radial component of the ExB velocity\ncompute the flux surface area = int dy dz (dalpha/dy)*(dpsi/dx)  / (B . grad z)\ncompute the flux surface average of |grad x|\nflxfac is pre-factor in front of fluxes Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: dens complex, intent(in), dimension(:, :, -nzgrid:, :) :: upar complex, intent(in), dimension(:, :, -nzgrid:, :) :: pres real, intent(out), dimension(:) :: pflx real, intent(out), dimension(:) :: vflx real, intent(out), dimension(:) :: qflx real, intent(out), dimension(:, :, -nzgrid:, :, :) :: pflx_vs_kxkyz real, intent(out), dimension(:, :, -nzgrid:, :, :) :: vflx_vs_kxkyz real, intent(out), dimension(:, :, -nzgrid:, :, :) :: qflx_vs_kxkyz Contents None","tags":"","loc":"proc/get_fluxes_ffs.html"},{"title":"get_one_flux_ffs â€“ stella","text":"private subroutine get_one_flux_ffs(mom, dphidy, flxfac, flx, flx_vs_kxkyz) Uses zgrid volume_averages kt_grids species divide the input density by the magnetic field strength (due to Jacobian in flux-surfacee avg)\nand Fourier transform in y to get mom_ky = (density/B)(ky,kx,z,spec)\npflx_vs_kxkyz is the particle flux before summing over (kx,ky) and integrating over z\ncalculate the volume average of the particle flux\nnote that the factor of 1/B that appears in the Jacobian has already been taken into account\nin the numerator of the flux surface average Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: mom complex, intent(in), dimension(:, :, -nzgrid:) :: dphidy real, intent(in) :: flxfac real, intent(out), dimension(:) :: flx real, intent(out), dimension(:, :, -nzgrid:, :) :: flx_vs_kxkyz Contents None","tags":"","loc":"proc/get_one_flux_ffs.html"},{"title":"get_modified_fourier_coefficient â€“ stella","text":"private subroutine get_modified_fourier_coefficient(moment, moment_ky) Uses stella_geometry species stella_transforms zgrid kt_grids divide the input moment by the magnetic field strength\nto account for Jacobian in flux-surface average\ntransform the B-modified input moment from y to ky space\nswap from all ky and kx >= 0 to all kx and ky >= 0 Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: moment complex, intent(out), dimension(:, :, -nzgrid:, :) :: moment_ky Contents None","tags":"","loc":"proc/get_modified_fourier_coefficient.html"},{"title":"get_one_flux â€“ stella","text":"private subroutine get_one_flux(iky, iz, norm, gin, fld, flxout) Uses vpamu_grids volume_averages kt_grids Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky integer, intent(in) :: iz real, intent(in) :: norm complex, intent(in), dimension(:, :) :: gin complex, intent(in) :: fld real, intent(inout) :: flxout Contents None","tags":"","loc":"proc/get_one_flux.html"},{"title":"get_one_flux_vmulo â€“ stella","text":"private subroutine get_one_flux_vmulo(weights, gin, fld, flxout) Uses stella_geometry physics_flags species zgrid volume_averages stella_transforms stella_layouts vpamu_grids kt_grids Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: weights complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gin complex, intent(in), dimension(:, :, -nzgrid:, :) :: fld real, intent(inout), dimension(:) :: flxout Contents None","tags":"","loc":"proc/get_one_flux_vmulo.html"},{"title":"get_one_flux_radial â€“ stella","text":"private subroutine get_one_flux_radial(weights, gin, fld, flxout) Uses stella_geometry zgrid species volume_averages stella_transforms stella_layouts vpamu_grids kt_grids Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: weights complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gin complex, intent(in), dimension(:, :, -nzgrid:, :) :: fld real, intent(inout), dimension(:, :) :: flxout Contents None","tags":"","loc":"proc/get_one_flux_radial.html"},{"title":"get_moments â€“ stella","text":"private subroutine get_moments(g, dens, upar, temp, dens_x, upar_x, temp_x, spitzer2) Uses stella_geometry fields_arrays run_parameters physics_flags stella_transforms gyro_averages zgrid species dist_fn_arrays stella_layouts vpamu_grids kt_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: dens complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: upar complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: temp real, intent(out), dimension(:, :) :: dens_x real, intent(out), dimension(:, :) :: upar_x real, intent(out), dimension(:, :) :: temp_x complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: spitzer2 Contents None","tags":"","loc":"proc/get_moments.html"},{"title":"get_moments_ffs â€“ stella","text":"private subroutine get_moments_ffs(g, dens, upar, pres) Uses fields_arrays stella_transforms gyro_averages zgrid species dist_fn_arrays stella_layouts vpamu_grids kt_grids species-dependent factor by which velocity moments must be multiplied\nto get density, pressure, etc.\nthe guiding centre distribution function, normalized by\nthe equilibrium Maxwellian, is passed in as g.\nto obtain moments such as density, flow and pressure,\nwe need to take moments of the distribution function, f,\nwhich is related to g via\nf/F0 = g + (Ze/T)*( _R - phi)\nobtain g0=f/F0 in Fourier space calculate the Fourier components of the gyro-average f at fixed particle position\ng0=f/F0 is passed in, along with j0_ffs = the Fourier coefficients of J0\ng1= _r is returned assume only a single flux annulus\nfor every (z,vpa,mu,spec) point\nswitch from ky >= 0 and kx = [-kxmax, kxmax]\nto ky = [-kymax, kymax] and kx >= 0\nfor every (z,vpa,mu,spec) point, Fourier tranform from ky to y space to get\nthe kx component of _r\nset species-dependent factors needed for density, parallel flow and pressure\nthe integrand for the density moment is the distribution function\nintegrate over v-space to get the density, normalised by the reference density. the integrand for the pressure moment is the energy-weighted distribution function\nintegrate over v-space to get the pressure, normalised by the reference pressure. the integrand for the parallel flow moment is the parallel velocity\nintegrate over v-space to get the parallel flow, normalised by the reference thermal speed. Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: dens complex, intent(out), dimension(:, :, -nzgrid:, :) :: upar complex, intent(out), dimension(:, :, -nzgrid:, :) :: pres Contents None","tags":"","loc":"proc/get_moments_ffs.html"},{"title":"g_to_f â€“ stella","text":"private subroutine g_to_f(g, phi, f) Uses stella_layouts zgrid gyro_averages species the Fourier components of the guiding centre distribution function\nnormalized by the equilibrium Maxwellian is passed in as g,\nalong with the Fourier components of the electrostatic potential, phi.\ng_to_f calculates the Maxwellian-normalized distribution function f,\nwhich is related to g via\nf = g + (Ze/T)*( _R - phi) compute _R and store in f\nj0_ffs are the fourier coefficients of J0(k_perp(y))\ncalculate the normalized f, given phi and _R (temporarily stored in f) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: f Contents None","tags":"","loc":"proc/g_to_f.html"},{"title":"get_gvmus â€“ stella","text":"private subroutine get_gvmus(g, gv) Uses stella_geometry vpamu_grids mp volume_averages stella_layouts zgrid Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g real, intent(out), dimension(:, :, :) :: gv Contents None","tags":"","loc":"proc/get_gvmus.html"},{"title":"get_gzvs â€“ stella","text":"private subroutine get_gzvs(g, gz) Uses vpamu_grids volume_averages stella_layouts zgrid kt_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g real, intent(out), dimension(:, :, :, :) :: gz Contents None","tags":"","loc":"proc/get_gzvs.html"},{"title":"finish_stella_diagnostics â€“ stella","text":"public subroutine finish_stella_diagnostics(istep) Uses mp stella_io dist_redistribute dist_fn_arrays stella_save stella_time redistribute Arguments Type Intent Optional Attributes Name integer, intent(in) :: istep Contents None","tags":"","loc":"proc/finish_stella_diagnostics.html"},{"title":"write_loop_ascii_files â€“ stella","text":"private subroutine write_loop_ascii_files(istep, phi2, apar2, pflx, vflx, qflx, om, om_avg) Uses kt_grids species stella_time Arguments Type Intent Optional Attributes Name integer, intent(in) :: istep real, intent(in) :: phi2 real, intent(in) :: apar2 real, intent(in), dimension(:) :: pflx real, intent(in), dimension(:) :: vflx real, intent(in), dimension(:) :: qflx complex, intent(in), dimension(:, :) :: om complex, intent(in), dimension(:, :) :: om_avg Contents None","tags":"","loc":"proc/write_loop_ascii_files.html"},{"title":"write_final_ascii_files â€“ stella","text":"private subroutine write_final_ascii_files() Uses stella_geometry file_utils dist_fn_arrays fields_arrays zgrid kt_grids Arguments None Contents None","tags":"","loc":"proc/write_final_ascii_files.html"},{"title":"deallocate_arrays â€“ stella","text":"private subroutine deallocate_arrays() Arguments None Contents None","tags":"","loc":"proc/deallocate_arrays~2.html"},{"title":"init_stella â€“ stella","text":"subroutine init_stella(istep0, VERNUM, VERDATE) Uses stella_time stella_layouts zgrid stella_diagnostics vpamu_grids stella_geometry job_manage dist_fn stella_save dist_fn_arrays fields mp time_advance species dist_redistribute volume_averages stella_transforms kt_grids multibox run_parameters physics_flags response_matrix extended_zgrid sources file_utils physics_parameters dissipation fields_arrays ran init_g Initialise stella Calls the initialisation routines for all the geometry, physics, and\ndiagnostic modules initialize mpi message passing\ninitialize timer\nwrite message to screen with useful info regarding start of simulation\ninitialize file i/o\nread the physics_flags namelist from the input file\nread the physics_parameters namelist from the input file\nread the zgrid_parameters namelist from the input file and setup the z grid\nread the species_knobs namelist from the input file\nread the grid option from the kt_grids_knobs namelist in the input file;\ndepending on the grid option chosen, read the corresponding kt_grids_XXXX_parameters\nnamelist from the input file and allocate some kx and ky arrays\nread the vpamu_grids_parameters namelist from the input file\nsetup the various data layouts for the distribution function;\ne.g., vmu_lo is the layout in which vpa, mu and species may be distributed\namongst processors, depending on the number of phase space points and processors\nneeds_transforms indicates whether or not FFTs will be needed in the simulation\nif FFTs are needed, init_transforms sets up the various FFTW plans\nand allocates the necessary arrays\nread in the geometry option and any necessary magnetic geometry info\nand use it to calculate all of the required geometric coefficients\nread species_parameters from input file and use the info to, e.g.,\ndetermine if a modified Boltzmann response is to be used\nread init_g_knobs namelist from the input file\nand prepare for reading in from restart file if requested\nread knobs namelist from the input file\nand the info to determine the mixture of implicit and explicit time advance\nread layouts_knobs namelist from the input file,\nwhich determines the order of parallelisation within the different layouts\nsetup the (kx,ky) grids and (x,y) grids, if applicable\nMAB: could multibox/radial variation code below be tidied away\nso that only one or two subroutine calls need appear here?\nnot sure that it needs to be separated from init_geometry, but\nfinish_init_geometry deallocates various geometric arrays that\nwere defined locally within the millerlocal module when using Miller geometry\nsetup the (vpa,mu) grids and associated integration weights\nset up all of the logic needed to do calculations on an extended grid in z.\nthis extended grid could be due to use of a ballooning angle so that\nz goes from -N pi to N pi, or it could be due to the coupling of different\nkx modes arising from the twist-and-shift boundary condition\nwhen doing a volume average using Fourier coefficients, the\nky=0 mode gets a different weighting than finite ky modes, due\nto the reality condition being imposed; init_volume_averages accounts for this\nallocates and initialises kperp2, vperp2 and arrays needed\nfor gyro-averaging (j0 and j1 or equivalents)\nsets up the mappings between different layouts, needed\nto redistribute data when going from one layout to another\nread dissipation namelist from the input file and print information\nabout chosen options to stdout\nallocate and initialise time-independent arrays needed to\nsolve the field equations; e.g., sum_s (Z_s&#94;2 n_s / T_s)*(1-Gamma0_s)\ninitialise the distribution function in the kxkyz_lo and store in gvmu\nuse mapping from kxkyz_lo to vmu_lo to get a copy of g that has ky, kx and z local to each core;\nstored in gnew and copied to gold\nif initializing from restart file, set the initial time step size appropriately\nset the internal time step size variable code_dt from the input variable delt\nallocate and calculate arrays needed for the mirror, parallel streaming,\nmagnetic drifts, gradient drive, etc. terms during time advance\nget initial field from initial distribution function\nread stella_diagnostics_knob namelist from the input file,\nopen ascii output files and initialise the neetcdf file with extension .out.nc\ninitialise the code_time\nAdd a header to the output file\nstop the timing of the initialization Arguments Type Intent Optional Attributes Name integer, intent(out) :: istep0 Starting timestep: zero unless the simulation has been restarted character(len=*), intent(in) :: VERNUM stella version number character(len=10), intent(in) :: VERDATE Release date Contents None","tags":"","loc":"proc/init_stella.html"},{"title":"check_transforms â€“ stella","text":"subroutine check_transforms(needs_transforms) Uses physics_parameters file_utils physics_flags check_transforms checks the various physics flag choices\nto determine if FFTs are needed for the simulation if ExB or parallel nonlinearity included in the simulations, need FFTs\nif 'global' in radial or bi-normal directions, need FFTs\nif running in multibox mode, need FFTs\nif including flow shear using anything other than wavenumber re-mapping, need FFTs Arguments Type Intent Optional Attributes Name logical, intent(out) :: needs_transforms Contents None","tags":"","loc":"proc/check_transforms.html"},{"title":"write_start_message â€“ stella","text":"subroutine write_start_message(VERNUM, VERDATE) Uses mp Write the start message to screen Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: VERNUM stella version number character(len=10), intent(in) :: VERDATE Release date Contents None","tags":"","loc":"proc/write_start_message.html"},{"title":"print_header â€“ stella","text":"subroutine print_header() Uses mp Arguments None Contents None","tags":"","loc":"proc/print_header.html"},{"title":"parse_command_line â€“ stella","text":"subroutine parse_command_line() Uses git_version Parse some basic command line arguments. Currently just 'version' and 'help'. This should be called before anything else, but especially before initialising MPI. Arguments None Contents None","tags":"","loc":"proc/parse_command_line.html"},{"title":"finish_stella â€“ stella","text":"subroutine finish_stella(last_call) Uses stella_diagnostics zgrid parallel_streaming vpamu_grids stella_geometry job_manage dist_fn fields mp time_advance species dist_redistribute volume_averages kt_grids multibox run_parameters mirror_terms physics_flags response_matrix sources extended_zgrid file_utils physics_parameters dissipation init_g Finish a simulation, call the finialisation routines of all modules Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: last_call Contents None","tags":"","loc":"proc/finish_stella.html"},{"title":"init_sources â€“ stella","text":"public subroutine init_sources() Uses run_parameters fields_arrays physics_flags mp species file_utils dist_fn_arrays stella_layouts zgrid kt_grids Arguments None Contents None","tags":"","loc":"proc/init_sources.html"},{"title":"read_parameters â€“ stella","text":"private subroutine read_parameters() Uses physics_flags mp file_utils fields_arrays kt_grids Arguments None Contents None","tags":"","loc":"proc/read_parameters~10.html"},{"title":"init_source_timeaverage â€“ stella","text":"public subroutine init_source_timeaverage() Uses fields_arrays stella_time Arguments None Contents None","tags":"","loc":"proc/init_source_timeaverage.html"},{"title":"finish_sources â€“ stella","text":"public subroutine finish_sources() Uses dist_fn_arrays fields_arrays Arguments None Contents None","tags":"","loc":"proc/finish_sources.html"},{"title":"add_krook_operator â€“ stella","text":"public subroutine add_krook_operator(g, gke_rhs) Uses physics_flags job_manage mp stella_transforms constants stella_time dist_fn_arrays stella_layouts zgrid kt_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:), target :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gke_rhs Contents None","tags":"","loc":"proc/add_krook_operator.html"},{"title":"update_tcorr_krook â€“ stella","text":"public subroutine update_tcorr_krook(g) Uses job_manage mp stella_transforms constants stella_time dist_fn_arrays stella_layouts zgrid kt_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:), target :: g Contents None","tags":"","loc":"proc/update_tcorr_krook.html"},{"title":"enforce_momentum_conservation â€“ stella","text":"private subroutine enforce_momentum_conservation(g_work) Uses job_manage mp zgrid dist_redistribute dist_fn_arrays stella_layouts vpamu_grids redistribute Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g_work Contents None","tags":"","loc":"proc/enforce_momentum_conservation.html"},{"title":"enforce_density_conservation â€“ stella","text":"private subroutine enforce_density_conservation(g_work) Uses stella_geometry physics_flags mp stella_transforms gyro_averages species zgrid dist_fn_arrays stella_layouts vpamu_grids kt_grids Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, -nzgrid:, :, vmu_lo%llim_proc:) :: g_work Contents None","tags":"","loc":"proc/enforce_density_conservation.html"},{"title":"project_out_zero â€“ stella","text":"public subroutine project_out_zero(gold, gnew) Uses job_manage mp stella_transforms constants stella_time dist_fn_arrays stella_layouts zgrid kt_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gold complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gnew Contents None","tags":"","loc":"proc/project_out_zero.html"},{"title":"init_quasineutrality_source â€“ stella","text":"public subroutine init_quasineutrality_source() Uses stella_geometry physics_flags linear_solve stella_transforms fields_arrays zgrid kt_grids Arguments None Contents None","tags":"","loc":"proc/init_quasineutrality_source.html"},{"title":"update_quasineutrality_source â€“ stella","text":"public subroutine update_quasineutrality_source() Uses fields_arrays Arguments None Contents None","tags":"","loc":"proc/update_quasineutrality_source.html"},{"title":"init_mirror â€“ stella","text":"public subroutine init_mirror() Uses stella_geometry run_parameters physics_flags zgrid species stella_time vpamu_grids kt_grids neoclassical_terms mirror has sign consistent with being on RHS of GKE;\nit is the factor multiplying dg/dvpa in the mirror term\nmirror_sign set to +/- 1 depending on the sign of the mirror term.\nNB: mirror_sign = -1 corresponds to positive advection velocity\nset up the tridiagonal matrix that must be inverted\nfor the implicit treatment of the mirror operator Arguments None Contents None","tags":"","loc":"proc/init_mirror.html"},{"title":"init_mirror_semi_lagrange â€“ stella","text":"private subroutine init_mirror_semi_lagrange() Uses kt_grids zgrid species vpamu_grids Arguments None Contents None","tags":"","loc":"proc/init_mirror_semi_lagrange.html"},{"title":"init_invert_mirror_operator â€“ stella","text":"private subroutine init_invert_mirror_operator() Uses stella_geometry run_parameters physics_flags vpamu_grids mp species stella_layouts zgrid kt_grids neoclassical_terms mirror_int_fac = exp(vpa&#94;2 * (mu dB/dz)/(mu dB/dz + Z e dpihnc/dz))\nis the integrating factor needed to turn the dg/dvpa part of the GKE advance\ninto an advection equation\na, b and c contain the sub-, main- and super-diagonal terms, respectively\nif running in full-flux-surface mode, solve mirror advance\nin y-space rather than ky-space due to alpha-dependence of coefficients\ncorresponds to sign of mirror term positive on RHS of equation\nmust treat boundary carefully\ntreatment of boundary seems inconsistent\nimplicit piece below is pure upwind, while\nexplicit piece in fd_variable_upwind_vpa is mixed\nwith assumed zero BC at extremes in both +/- vpa\ncorresponds to sign of mirror term negative on RHS of equation\nmust treat boundary carefully\ntime_upwind = 0.0 corresponds to centered in time\ntime_upwind = 1.0 corresponds to fully implicit (upwinded)\naccount for fact that we have expanded d(gnorm)/dvpa, where gnorm = g/exp(-v&#94;s);\nthis gives rise to d(gnorm exp(-vpa&#94;2))/dvpa + 2 vpa gnorm exp(-vpa&#94;2) term\nwe solve for gnorm*exp(-vpa&#94;2) and later multiply by exp(vpa&#94;2) to get gnorm\nmultiply by mirror coefficient Arguments None Contents None","tags":"","loc":"proc/init_invert_mirror_operator.html"},{"title":"advance_mirror_explicit â€“ stella","text":"public subroutine advance_mirror_explicit(g, gout) Uses run_parameters physics_flags job_manage mp vpamu_grids stella_transforms dist_redistribute dist_fn_arrays stella_layouts zgrid redistribute kt_grids advance_mirror_explicit calculates the contribution to the RHS of the gyrokinetic equation\ndue to the mirror force term; it treats all terms explicitly in time start the timer for this subroutine assume we are simulating a single flux surface swap from ky >= 0 and all kx to kx >= 0 and all ky\nneeded for ky2y transform below\nfor upwinding of vpa, need to evaluate dg/dvpa in y-space\nthis is necessary because the advection speed contains dB/dz, which depends on y\nfirst must take g(ky,kx) and transform to g(y,kx)\nremap g so velocities are local\nnext, calculate dg/dvpa;\nwe enforce a boundary condition on , but with full_flux_surface = T,\ng = / F, so we use the chain rule to get two terms:\none with exp(vpa&#94;2)*d /dvpa and another that is proportional to exp(vpa&#94;2) * /F * d ln F /dvpa\nremove exp(-vpa&#94;2) normalisation from g before differentiating\nget d / dvpa\nthen take the results and remap again so y,kx,z local. finally add the mirror term to the RHS of the GK eqn Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout Contents None","tags":"","loc":"proc/advance_mirror_explicit.html"},{"title":"add_mirror_radial_variation â€“ stella","text":"public subroutine add_mirror_radial_variation(g, gout) Uses run_parameters physics_flags job_manage mp vpamu_grids dist_redistribute dist_fn_arrays stella_layouts zgrid redistribute Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout Contents None","tags":"","loc":"proc/add_mirror_radial_variation.html"},{"title":"get_dgdvpa_ffs â€“ stella","text":"private subroutine get_dgdvpa_ffs(g, ikxyz) Uses stella_layouts vpamu_grids finite_differences Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: g integer, intent(in) :: ikxyz Contents None","tags":"","loc":"proc/get_dgdvpa_ffs.html"},{"title":"get_dgdvpa_explicit â€“ stella","text":"private subroutine get_dgdvpa_explicit(g) Uses stella_layouts vpamu_grids finite_differences Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, kxkyz_lo%llim_proc:) :: g Contents None","tags":"","loc":"proc/get_dgdvpa_explicit.html"},{"title":"add_mirror_term â€“ stella","text":"private subroutine add_mirror_term(g, src) Uses stella_layouts zgrid kt_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: src Contents None","tags":"","loc":"proc/add_mirror_term.html"},{"title":"add_mirror_term_ffs â€“ stella","text":"private subroutine add_mirror_term_ffs(g, src) Uses stella_layouts zgrid kt_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: src Contents None","tags":"","loc":"proc/add_mirror_term_ffs.html"},{"title":"advance_mirror_implicit â€“ stella","text":"public subroutine advance_mirror_implicit(collisions_implicit, g) Uses run_parameters physics_flags job_manage mp vpamu_grids finite_differences constants dist_fn_arrays stella_transforms stella_layouts zgrid dist_redistribute redistribute kt_grids neoclassical_terms Arguments Type Intent Optional Attributes Name logical, intent(in) :: collisions_implicit complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g Contents None","tags":"","loc":"proc/advance_mirror_implicit.html"},{"title":"vpa_interpolation â€“ stella","text":"private subroutine vpa_interpolation(grid, interp) Uses run_parameters stella_layouts vpamu_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: grid complex, intent(out), dimension(:, :, kxkyz_lo%llim_proc:) :: interp Contents None","tags":"","loc":"proc/vpa_interpolation.html"},{"title":"invert_mirror_operator â€“ stella","text":"private subroutine invert_mirror_operator(imu, ilo, g) Uses finite_differences Arguments Type Intent Optional Attributes Name integer, intent(in) :: imu integer, intent(in) :: ilo complex, intent(inout), dimension(:) :: g Contents None","tags":"","loc":"proc/invert_mirror_operator.html"},{"title":"finish_mirror â€“ stella","text":"public subroutine finish_mirror() Uses run_parameters Arguments None Contents None","tags":"","loc":"proc/finish_mirror.html"},{"title":"finish_mirror_semi_lagrange â€“ stella","text":"private subroutine finish_mirror_semi_lagrange() Arguments None Contents None","tags":"","loc":"proc/finish_mirror_semi_lagrange.html"},{"title":"finish_invert_mirror_operator â€“ stella","text":"private subroutine finish_invert_mirror_operator() Arguments None Contents None","tags":"","loc":"proc/finish_invert_mirror_operator.html"},{"title":"init_init_g â€“ stella","text":"public subroutine init_init_g() Uses mp stella_layouts system_fortran stella_save Arguments None Contents None","tags":"","loc":"proc/init_init_g.html"},{"title":"ginit â€“ stella","text":"public subroutine ginit(restarted, istep0) Uses physics_flags stella_save if simulating a full flux surface, g is normalized by F0 (which is not the case otherwise)\nunless reading in g from a restart file, normalise g by F0 for a full flux surface simulation Arguments Type Intent Optional Attributes Name logical, intent(out) :: restarted integer, intent(out) :: istep0 Contents None","tags":"","loc":"proc/ginit.html"},{"title":"read_parameters â€“ stella","text":"private subroutine read_parameters() Uses text_options file_utils stella_save Arguments None Contents None","tags":"","loc":"proc/read_parameters~11.html"},{"title":"ginit_default â€“ stella","text":"private subroutine ginit_default() Uses zgrid species ran constants dist_fn_arrays stella_layouts vpamu_grids kt_grids Arguments None Contents None","tags":"","loc":"proc/ginit_default.html"},{"title":"ginit_noise â€“ stella","text":"private subroutine ginit_noise() Uses vpamu_grids mp species extended_zgrid ran file_utils dist_fn_arrays stella_layouts zgrid kt_grids Initialise the distribution function with random noise. This is the default Arguments None Contents None","tags":"","loc":"proc/ginit_noise.html"},{"title":"ginit_kpar â€“ stella","text":"private subroutine ginit_kpar() Uses vpamu_grids constants dist_fn_arrays stella_layouts zgrid kt_grids Arguments None Contents None","tags":"","loc":"proc/ginit_kpar.html"},{"title":"ginit_rh â€“ stella","text":"private subroutine ginit_rh() Uses species dist_fn_arrays stella_layouts vpamu_grids kt_grids Arguments None Contents None","tags":"","loc":"proc/ginit_rh.html"},{"title":"ginit_remap â€“ stella","text":"private subroutine ginit_remap() Uses dist_fn_arrays stella_layouts vpamu_grids species Arguments None Contents None","tags":"","loc":"proc/ginit_remap.html"},{"title":"ginit_restart_many â€“ stella","text":"private subroutine ginit_restart_many() Uses dist_fn_arrays mp file_utils stella_save Arguments None Contents None","tags":"","loc":"proc/ginit_restart_many.html"},{"title":"normalize_by_maxwellian â€“ stella","text":"private subroutine normalize_by_maxwellian() Uses dist_fn_arrays stella_layouts vpamu_grids gvmu is initialised with a Maxwellian weighting for flux tube simulations,\nwith the Maxwellian evaluated at ia = 1\nwe are undoing that weighting here, so also need to use ia = 1 Arguments None Contents None","tags":"","loc":"proc/normalize_by_maxwellian.html"},{"title":"reset_init â€“ stella","text":"public subroutine reset_init() Arguments None Contents None","tags":"","loc":"proc/reset_init.html"},{"title":"finish_init_g â€“ stella","text":"public subroutine finish_init_g() Uses stella_save Arguments None Contents None","tags":"","loc":"proc/finish_init_g.html"},{"title":"init_volume_averages â€“ stella","text":"public subroutine init_volume_averages() Uses stella_geometry zgrid kt_grids physics_flags Arguments None Contents None","tags":"","loc":"proc/init_volume_averages.html"},{"title":"finish_volume_averages â€“ stella","text":"public subroutine finish_volume_averages() Uses stella_geometry physics_flags Arguments None Contents None","tags":"","loc":"proc/finish_volume_averages.html"},{"title":"fieldline_average_real â€“ stella","text":"private subroutine fieldline_average_real(unavg, avg) Uses stella_geometry zgrid kt_grids Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :, -nzgrid:, :) :: unavg real, intent(out), dimension(:, :) :: avg Contents None","tags":"","loc":"proc/fieldline_average_real.html"},{"title":"fieldline_average_complex â€“ stella","text":"private subroutine fieldline_average_complex(unavg, avg) Uses stella_geometry zgrid kt_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: unavg complex, intent(out), dimension(:, :) :: avg Contents None","tags":"","loc":"proc/fieldline_average_complex.html"},{"title":"volume_average â€“ stella","text":"public subroutine volume_average(unavg, avg) Uses stella_geometry zgrid kt_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: unavg real, intent(out) :: avg Contents None","tags":"","loc":"proc/volume_average.html"},{"title":"init_flux_surface_average_ffs â€“ stella","text":"private subroutine init_flux_surface_average_ffs() Uses stella_geometry zgrid stella_transforms kt_grids calculate the Fourier coefficients in y of the Jacobian\nthis is needed in the computation of the flux surface average of phi Arguments None Contents None","tags":"","loc":"proc/init_flux_surface_average_ffs.html"},{"title":"flux_surface_average_ffs â€“ stella","text":"public subroutine flux_surface_average_ffs(no_fsa, fsa) Uses stella_geometry zgrid kt_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, -nzgrid:) :: no_fsa complex, intent(out) :: fsa Contents None","tags":"","loc":"proc/flux_surface_average_ffs.html"},{"title":"fieldline_average â€“ stella","text":"public interface fieldline_average Contents Module Procedures fieldline_average_real fieldline_average_complex Module Procedures private subroutine fieldline_average_real (unavg, avg) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :, -nzgrid:, :) :: unavg real, intent(out), dimension(:, :) :: avg private subroutine fieldline_average_complex (unavg, avg) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: unavg complex, intent(out), dimension(:, :) :: avg","tags":"","loc":"interface/fieldline_average.html"},{"title":"init_run_parameters â€“ stella","text":"public subroutine init_run_parameters() Arguments None Contents None","tags":"","loc":"proc/init_run_parameters.html"},{"title":"read_parameters â€“ stella","text":"private subroutine read_parameters() Uses mp text_options file_utils physics_flags print warning messages and override inconsistent or unsupported options for full_flux_surface = T Arguments None Contents None","tags":"","loc":"proc/read_parameters~2.html"},{"title":"finish_run_parameters â€“ stella","text":"public subroutine finish_run_parameters() Arguments None Contents None","tags":"","loc":"proc/finish_run_parameters.html"},{"title":"has_electron_species â€“ stella","text":"public pure function has_electron_species(spec) Uses common_types Arguments Type Intent Optional Attributes Name type( spec_type ), intent(in), dimension(:) :: spec Return Value logical Contents None","tags":"","loc":"proc/has_electron_species.html"},{"title":"has_slowing_down_species â€“ stella","text":"public pure function has_slowing_down_species(spec) Uses common_types Arguments Type Intent Optional Attributes Name type( spec_type ), intent(in), dimension(:) :: spec Return Value logical Contents None","tags":"","loc":"proc/has_slowing_down_species.html"},{"title":"init_species â€“ stella","text":"public subroutine init_species() Uses physics_flags euterpe_interface mp inputprofiles_interface physics_parameters Arguments None Contents None","tags":"","loc":"proc/init_species.html"},{"title":"read_species_knobs â€“ stella","text":"public subroutine read_species_knobs() Uses mp text_options file_utils physics_flags Arguments None Contents None","tags":"","loc":"proc/read_species_knobs.html"},{"title":"read_species_stella â€“ stella","text":"private subroutine read_species_stella() Uses stella_geometry text_options file_utils Arguments None Contents None","tags":"","loc":"proc/read_species_stella.html"},{"title":"broadcast_parameters â€“ stella","text":"private subroutine broadcast_parameters() Uses mp Arguments None Contents None","tags":"","loc":"proc/broadcast_parameters~2.html"},{"title":"finish_species â€“ stella","text":"public subroutine finish_species() Arguments None Contents None","tags":"","loc":"proc/finish_species.html"},{"title":"reinit_species â€“ stella","text":"public subroutine reinit_species(ntspec, dens, temp, fprim, tprim, bess_fac) Uses mp Arguments Type Intent Optional Attributes Name integer, intent(in) :: ntspec real, intent(in), dimension(:) :: dens real, intent(in), dimension(:) :: temp real, intent(in), dimension(:) :: fprim real, intent(in), dimension(:) :: tprim real, intent(in), dimension(:) :: bess_fac Contents None","tags":"","loc":"proc/reinit_species.html"},{"title":"communicate_species_multibox â€“ stella","text":"public subroutine communicate_species_multibox(dr_m, dr_p) Uses job_manage mp Arguments Type Intent Optional Attributes Name real, intent(in), optional :: dr_m real, intent(in), optional :: dr_p Contents None","tags":"","loc":"proc/communicate_species_multibox.html"},{"title":"dump_species_input â€“ stella","text":"private subroutine dump_species_input() Uses file_utils Arguments None Contents None","tags":"","loc":"proc/dump_species_input.html"},{"title":"read_multibox_parameters â€“ stella","text":"public subroutine read_multibox_parameters() Uses job_manage mp text_options file_utils kt_grids Arguments None Contents None","tags":"","loc":"proc/read_multibox_parameters.html"},{"title":"init_multibox â€“ stella","text":"public subroutine init_multibox() Uses stella_geometry job_manage mp constants file_utils stella_layouts zgrid physics_parameters kt_grids Arguments None Contents None","tags":"","loc":"proc/init_multibox.html"},{"title":"communicate_multibox_parameters â€“ stella","text":"public subroutine communicate_multibox_parameters() Uses job_manage mp Arguments None Contents None","tags":"","loc":"proc/communicate_multibox_parameters.html"},{"title":"finish_multibox â€“ stella","text":"public subroutine finish_multibox() Arguments None Contents None","tags":"","loc":"proc/finish_multibox.html"},{"title":"multibox_communicate â€“ stella","text":"public subroutine multibox_communicate(gin) Uses stella_geometry physics_flags job_manage mp file_utils constants stella_layouts fields_arrays zgrid physics_parameters kt_grids Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gin Contents None","tags":"","loc":"proc/multibox_communicate.html"},{"title":"apply_radial_boundary_conditions â€“ stella","text":"public subroutine apply_radial_boundary_conditions(gin) Uses stella_layouts zgrid kt_grids Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gin Contents None","tags":"","loc":"proc/apply_radial_boundary_conditions.html"},{"title":"add_multibox_krook â€“ stella","text":"public subroutine add_multibox_krook(g, rhs) Uses job_manage mp stella_time stella_layouts zgrid kt_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: rhs Contents None","tags":"","loc":"proc/add_multibox_krook.html"},{"title":"init_mb_get_phi â€“ stella","text":"public subroutine init_mb_get_phi(has_elec, adiabatic_elec, efac, efacp) Uses stella_geometry run_parameters physics_flags linear_solve fields_arrays zgrid kt_grids Arguments Type Intent Optional Attributes Name logical, intent(in) :: has_elec logical, intent(in) :: adiabatic_elec real, intent(in) :: efac real, intent(in) :: efacp Contents None","tags":"","loc":"proc/init_mb_get_phi.html"},{"title":"mb_get_phi â€“ stella","text":"public subroutine mb_get_phi(phi, has_elec, adiabatic_elec) Uses stella_geometry run_parameters linear_solve constants fields_arrays zgrid kt_grids Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi logical, intent(in) :: has_elec logical, intent(in) :: adiabatic_elec Contents None","tags":"","loc":"proc/mb_get_phi.html"},{"title":"init_mb_transforms â€“ stella","text":"private subroutine init_mb_transforms() Uses stella_layouts kt_grids Arguments None Contents None","tags":"","loc":"proc/init_mb_transforms.html"},{"title":"init_x_fft â€“ stella","text":"private subroutine init_x_fft() Uses fft_work Arguments None Contents None","tags":"","loc":"proc/init_x_fft~2.html"},{"title":"init_y_fft â€“ stella","text":"private subroutine init_y_fft() Uses fft_work kt_grids Arguments None Contents None","tags":"","loc":"proc/init_y_fft~2.html"},{"title":"transform_kx2x â€“ stella","text":"private subroutine transform_kx2x(gkx, gx) Uses kt_grids transform routines start here Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gkx complex, intent(out), dimension(:, :) :: gx Contents None","tags":"","loc":"proc/transform_kx2x.html"},{"title":"transform_x2kx â€“ stella","text":"private subroutine transform_x2kx(gx, gkx) Uses kt_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gx complex, intent(out), dimension(:, :) :: gkx Contents None","tags":"","loc":"proc/transform_x2kx~2.html"},{"title":"transform_ky2y â€“ stella","text":"private subroutine transform_ky2y(gky, gy) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gky real, intent(out), dimension(:, :) :: gy Contents None","tags":"","loc":"proc/transform_ky2y.html"},{"title":"finish_mb_transforms â€“ stella","text":"private subroutine finish_mb_transforms() Arguments None Contents None","tags":"","loc":"proc/finish_mb_transforms.html"},{"title":"init_parallel_streaming â€“ stella","text":"public subroutine init_parallel_streaming() Uses stella_geometry run_parameters physics_flags species zgrid finite_differences stella_time stella_layouts vpamu_grids kt_grids stream_sign set to +/- 1 depending on the sign of the parallel streaming term.\nNB: stream_sign = -1 corresponds to positive advection velocity\nonly need to consider ia=1, iz=0 and is=1 because alpha, z and species dependences\ndo not lead to change in sign of the streaming pre-factor\nget gradpar centred in zed for negative vpa (affects upwinding)\nget gradpar centred in zed for positive vpa (affects upwinding) Arguments None Contents None","tags":"","loc":"proc/init_parallel_streaming.html"},{"title":"init_invert_stream_operator â€“ stella","text":"private subroutine init_invert_stream_operator() Uses extended_zgrid run_parameters zgrid Arguments None Contents None","tags":"","loc":"proc/init_invert_stream_operator.html"},{"title":"advance_parallel_streaming_explicit â€“ stella","text":"public subroutine advance_parallel_streaming_explicit(g, phi, gout) Uses run_parameters vpamu_grids job_manage mp physics_flags gyro_averages species stella_transforms stella_layouts zgrid kt_grids if flux tube simulation parallel streaming stays in ky,kx,z space with ky,kx,z local\nif full flux surface (flux annulus), will need to calculate in y space\nstart the timer for the parallel streaming part of the time advance allocate arrays needed for intermmediate calculations\nif simulating a full flux surface, will also need version of the above arrays\nthat is Fourier transformed to y-space\nget (iv,imu,is) indices corresponding to ivmu super-index\nobtain (or -phi if driftkinetic_implicit=T)\nget d /dz, with z the parallel coordinate and store in dgphi_dz\nnote that this should be a centered difference to avoid numerical\nunpleasantness to do with inexact cancellations in later velocity integration\nsee appendix of the stella JCP 2019 for details if driftkinetic_implicit=T, then only want to treat vpar . grad ( -phi)*F0 term explicitly;\nin this case, zero out dg/dz term (or d(g/F)/dz for full-flux-surface)\ncompute dg/dz in k-space and store in g0\nif simulating a full flux surface, need to obtain the contribution from parallel streaming\nin y-space, so FFT d(g/F)/dz from ky to y\ntransform d /dz (fully explicit) or d( -phi)/dz (if driftkinetic_implicit)\nfrom kalpha (ky) to alpha (y) space and store in g1y\nover-write g0y with d/dz (g/F) + Ze/T * d /dz (or -phi for driftkinetic_implicit). multiply d(g/F)/dz and d /dz terms with vpa*(b . grad z) and add to source (RHS of GK equation)\ndeallocate intermediate arrays used in this subroutine\nfinish timing the subroutine Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout Contents None","tags":"","loc":"proc/advance_parallel_streaming_explicit.html"},{"title":"add_parallel_streaming_radial_variation â€“ stella","text":"public subroutine add_parallel_streaming_radial_variation(g, gout, rhs) Uses fields_arrays vpamu_grids job_manage gyro_averages species stella_layouts zgrid kt_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: rhs Contents None","tags":"","loc":"proc/add_parallel_streaming_radial_variation.html"},{"title":"get_dgdz â€“ stella","text":"private subroutine get_dgdz(g, ivmu, dgdz) Uses extended_zgrid finite_differences stella_layouts zgrid kt_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: g integer, intent(in) :: ivmu complex, intent(out), dimension(:, :, -nzgrid:, :) :: dgdz Contents None","tags":"","loc":"proc/get_dgdz.html"},{"title":"get_dgdz_centered â€“ stella","text":"private subroutine get_dgdz_centered(g, ivmu, dgdz) Uses extended_zgrid finite_differences stella_layouts zgrid kt_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: g integer, intent(in) :: ivmu complex, intent(out), dimension(:, :, -nzgrid:, :) :: dgdz Contents None","tags":"","loc":"proc/get_dgdz_centered.html"},{"title":"add_stream_term â€“ stella","text":"private subroutine add_stream_term(g, ivmu, src) Uses stella_layouts zgrid Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: g integer, intent(in) :: ivmu complex, intent(inout), dimension(:, :, -nzgrid:, :) :: src Contents None","tags":"","loc":"proc/add_stream_term.html"},{"title":"add_stream_term_ffs â€“ stella","text":"private subroutine add_stream_term_ffs(g, ivmu, src) Uses stella_layouts zgrid kt_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: g integer, intent(in) :: ivmu complex, intent(inout), dimension(:, :, -nzgrid:, :) :: src Contents None","tags":"","loc":"proc/add_stream_term_ffs.html"},{"title":"advance_parallel_streaming_implicit â€“ stella","text":"public subroutine advance_parallel_streaming_implicit(g, phi, apar) Uses run_parameters fields job_manage mp dist_fn_arrays stella_layouts zgrid kt_grids Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :) :: apar Contents None","tags":"","loc":"proc/advance_parallel_streaming_implicit.html"},{"title":"get_gke_rhs â€“ stella","text":"private subroutine get_gke_rhs(ivmu, gold, phiold, phi, g, eqn) Uses stella_geometry run_parameters vpamu_grids gyro_averages species stella_time stella_layouts zgrid kt_grids neoclassical_terms Arguments Type Intent Optional Attributes Name integer, intent(in) :: ivmu complex, intent(in), dimension(:, :, -nzgrid:, :) :: gold complex, intent(in), dimension(:, :, -nzgrid:, :) :: phiold complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :) :: g character, intent(in) :: eqn Contents None","tags":"","loc":"proc/get_gke_rhs.html"},{"title":"invert_parstream â€“ stella","text":"private subroutine invert_parstream(ivmu, g) Uses extended_zgrid stella_layouts zgrid kt_grids Arguments Type Intent Optional Attributes Name integer, intent(in) :: ivmu complex, intent(inout), dimension(:, :, -nzgrid:, :) :: g Contents None","tags":"","loc":"proc/invert_parstream.html"},{"title":"stream_tridiagonal_solve â€“ stella","text":"public subroutine stream_tridiagonal_solve(iky, ie, iv, is, g) Uses extended_zgrid finite_differences Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky integer, intent(in) :: ie integer, intent(in) :: iv integer, intent(in) :: is complex, intent(inout), dimension(:) :: g Contents None","tags":"","loc":"proc/stream_tridiagonal_solve.html"},{"title":"sweep_g_zed â€“ stella","text":"private subroutine sweep_g_zed(ivmu, g) Uses run_parameters extended_zgrid stella_layouts zgrid kt_grids Arguments Type Intent Optional Attributes Name integer, intent(in) :: ivmu complex, intent(inout), dimension(:, :, -nzgrid:, :) :: g Contents None","tags":"","loc":"proc/sweep_g_zed.html"},{"title":"sweep_zed_zonal â€“ stella","text":"private subroutine sweep_zed_zonal(iv, is, sgn, g) Uses run_parameters zgrid kt_grids Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv integer, intent(in) :: is integer, intent(in) :: sgn complex, intent(inout), dimension(:, -nzgrid:, :) :: g Contents None","tags":"","loc":"proc/sweep_zed_zonal.html"},{"title":"invert_parstream_response â€“ stella","text":"private subroutine invert_parstream_response(phi) Uses linear_solve extended_zgrid fields_arrays zgrid kt_grids Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi Contents None","tags":"","loc":"proc/invert_parstream_response.html"},{"title":"get_dzed â€“ stella","text":"private subroutine get_dzed(iv, g, dgdz) Uses extended_zgrid zgrid finite_differences kt_grids Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv complex, intent(in), dimension(:, :, -nzgrid:, :) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: dgdz Contents None","tags":"","loc":"proc/get_dzed.html"},{"title":"center_zed_extended â€“ stella","text":"private subroutine center_zed_extended(iv, g) Uses run_parameters extended_zgrid finite_differences zgrid kt_grids Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv complex, intent(inout), dimension(:, :, -nzgrid:, :) :: g Contents None","tags":"","loc":"proc/center_zed_extended.html"},{"title":"center_zed_segment_real â€“ stella","text":"private subroutine center_zed_segment_real(iv, g) Uses run_parameters zgrid Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv real, intent(inout), dimension(-nzgrid:) :: g Contents None","tags":"","loc":"proc/center_zed_segment_real.html"},{"title":"finish_parallel_streaming â€“ stella","text":"public subroutine finish_parallel_streaming() Uses run_parameters Arguments None Contents None","tags":"","loc":"proc/finish_parallel_streaming.html"},{"title":"finish_invert_stream_operator â€“ stella","text":"private subroutine finish_invert_stream_operator() Arguments None Contents None","tags":"","loc":"proc/finish_invert_stream_operator.html"},{"title":"center_zed â€“ stella","text":"private interface center_zed Contents Module Procedures center_zed_segment_real center_zed_extended Module Procedures private subroutine center_zed_segment_real (iv, g) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv real, intent(inout), dimension(-nzgrid:) :: g private subroutine center_zed_extended (iv, g) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv complex, intent(inout), dimension(:, :, -nzgrid:, :) :: g","tags":"","loc":"interface/center_zed.html"},{"title":"init_tstart â€“ stella","text":"public subroutine init_tstart(tstart) Arguments Type Intent Optional Attributes Name real, intent(in) :: tstart Contents None","tags":"","loc":"proc/init_tstart~2.html"},{"title":"init_delt â€“ stella","text":"public subroutine init_delt(delt) Arguments Type Intent Optional Attributes Name real, intent(in) :: delt Contents None","tags":"","loc":"proc/init_delt.html"},{"title":"update_time â€“ stella","text":"public subroutine update_time() Arguments None Contents None","tags":"","loc":"proc/update_time.html"},{"title":"save_dt_cfl â€“ stella","text":"public subroutine save_dt_cfl(delt_cfl) Arguments Type Intent Optional Attributes Name real, intent(in) :: delt_cfl Contents None","tags":"","loc":"proc/save_dt_cfl.html"},{"title":"save_dt_min â€“ stella","text":"public subroutine save_dt_min(dt_min) Arguments Type Intent Optional Attributes Name real, intent(in) :: dt_min Contents None","tags":"","loc":"proc/save_dt_min.html"},{"title":"save_dt â€“ stella","text":"public subroutine save_dt(delt) Arguments Type Intent Optional Attributes Name real, intent(in) :: delt Contents None","tags":"","loc":"proc/save_dt.html"},{"title":"write_dt â€“ stella","text":"public subroutine write_dt() Arguments None Contents None","tags":"","loc":"proc/write_dt.html"},{"title":"read_vpamu_grids_parameters â€“ stella","text":"public subroutine read_vpamu_grids_parameters() Uses mp file_utils Arguments None Contents None","tags":"","loc":"proc/read_vpamu_grids_parameters.html"},{"title":"init_vpamu_grids â€“ stella","text":"public subroutine init_vpamu_grids() Uses species set up the vpa grid points and integration weights\nset up the mu grid points and integration weights maxwell_fac = 1 unless radially global Arguments None Contents None","tags":"","loc":"proc/init_vpamu_grids.html"},{"title":"init_vpa_grid â€“ stella","text":"public subroutine init_vpa_grid() Uses mp constants species vpa is the parallel velocity at grid points\nwgts_vpa are the integration weights assigned\nto the parallel velocity grid points\nthis is the Maxwellian in vpa\nparallel velocity grid goes from -vpa_max to vpa_max,\nwith no point at vpa = 0;\nthe lack of a point at vpa=0 avoids treating\nthe vpa=z=0 phase space location, which\nis isolated from all other phase space points\nin the absence of collisions\nequal grid spacing in vpa obtain vpa grid for vpa > 0\nfill in vpa grid for vpa < 0 maxwell_vpa is the equilibrium Maxwellian in vpa\nztmax is the Maxwellian in vpa, multipliedd by charge number over normalized temperature get integration weights corresponding to vpa grid points\nfor now use Simpson's rule;\ni.e. subdivide grid into 3-point segments, with each segment spanning vpa_low to vpa_up\nthen the contribution of each segment to the integral is\n(vpa_up - vpa_low) * (f1 + 4*f2 + f3) / 6\ninner boundary points are used in two segments, so they get double the weight use simpson 3/8 rule at lower boundary and composite Simpson elsewhere\ncomposite simpson\nfor the sake of symmetry, do the same thing with 3/8 rule at upper boundary\nand composite elsewhere.\ndivide by 2 to account for double-counting Arguments None Contents None","tags":"","loc":"proc/init_vpa_grid.html"},{"title":"set_vpa_weights â€“ stella","text":"public subroutine set_vpa_weights(conservative) Uses constants Arguments Type Intent Optional Attributes Name logical, intent(in) :: conservative Contents None","tags":"","loc":"proc/set_vpa_weights.html"},{"title":"integrate_mu_local â€“ stella","text":"public subroutine integrate_mu_local(iz, g, total) Uses species Arguments Type Intent Optional Attributes Name integer, intent(in) :: iz real, intent(in), dimension(:, :) :: g real, intent(out), dimension(:) :: total Contents None","tags":"","loc":"proc/integrate_mu_local.html"},{"title":"integrate_mu_nonlocal â€“ stella","text":"public subroutine integrate_mu_nonlocal(iz, g, total) Uses mp stella_layouts Arguments Type Intent Optional Attributes Name integer, intent(in) :: iz real, intent(in), dimension(vmu_lo%llim_proc:) :: g real, intent(out), dimension(:, :) :: total Contents None","tags":"","loc":"proc/integrate_mu_nonlocal.html"},{"title":"integrate_vmu_local_real â€“ stella","text":"public subroutine integrate_vmu_local_real(g, iz, total) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: g integer, intent(in) :: iz real, intent(out) :: total Contents None","tags":"","loc":"proc/integrate_vmu_local_real.html"},{"title":"integrate_vmu_local_complex â€“ stella","text":"public subroutine integrate_vmu_local_complex(g, iz, total) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: g integer, intent(in) :: iz complex, intent(out) :: total Contents None","tags":"","loc":"proc/integrate_vmu_local_complex.html"},{"title":"integrate_vmu_vmulo_complex â€“ stella","text":"public subroutine integrate_vmu_vmulo_complex(g, weights, total) Uses mp zgrid stella_layouts Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g real, intent(in), dimension(:) :: weights complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: total Contents None","tags":"","loc":"proc/integrate_vmu_vmulo_complex.html"},{"title":"integrate_vmu_vmulo_ivmu_only_real â€“ stella","text":"public subroutine integrate_vmu_vmulo_ivmu_only_real(g, ia, iz, total) Uses mp stella_layouts Arguments Type Intent Optional Attributes Name real, intent(in), dimension(vmu_lo%llim_proc:) :: g integer, intent(in) :: ia integer, intent(in) :: iz real, intent(out), dimension(:) :: total Contents None","tags":"","loc":"proc/integrate_vmu_vmulo_ivmu_only_real.html"},{"title":"integrate_species_vmu_single â€“ stella","text":"public subroutine integrate_species_vmu_single(g, iz, weights, total, ia_in, reduce_in) Uses mp stella_layouts Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(vmu_lo%llim_proc:) :: g integer, intent(in) :: iz real, intent(in), dimension(:) :: weights complex, intent(out) :: total integer, intent(in), optional :: ia_in logical, intent(in), optional :: reduce_in Contents None","tags":"","loc":"proc/integrate_species_vmu_single.html"},{"title":"integrate_species_vmu_single_real â€“ stella","text":"public subroutine integrate_species_vmu_single_real(g, iz, weights, total, ia_in, reduce_in) Uses mp stella_layouts Arguments Type Intent Optional Attributes Name real, intent(in), dimension(vmu_lo%llim_proc:) :: g integer, intent(in) :: iz real, intent(in), dimension(:) :: weights real, intent(out) :: total integer, intent(in), optional :: ia_in logical, intent(in), optional :: reduce_in Contents None","tags":"","loc":"proc/integrate_species_vmu_single_real.html"},{"title":"integrate_species_vmu_block_complex â€“ stella","text":"public subroutine integrate_species_vmu_block_complex(g, iz, weights, pout, ia_in, reduce_in) Uses mp stella_layouts Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, vmu_lo%llim_proc:) :: g integer, intent(in) :: iz real, intent(in), dimension(:) :: weights complex, intent(out), dimension(:, :) :: pout integer, intent(in), optional :: ia_in logical, intent(in), optional :: reduce_in Contents None","tags":"","loc":"proc/integrate_species_vmu_block_complex.html"},{"title":"integrate_species_vmu_block_real â€“ stella","text":"public subroutine integrate_species_vmu_block_real(g, iz, weights, pout, ia_in, reduce_in) Uses mp stella_layouts Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :, vmu_lo%llim_proc:) :: g integer, intent(in) :: iz real, intent(in), dimension(:) :: weights real, intent(out), dimension(:, :) :: pout integer, intent(in), optional :: ia_in logical, intent(in), optional :: reduce_in Contents None","tags":"","loc":"proc/integrate_species_vmu_block_real.html"},{"title":"integrate_species_ffs â€“ stella","text":"public subroutine integrate_species_ffs(g, weights, pout, reduce_in) Uses mp stella_layouts Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, vmu_lo%llim_proc:) :: g real, intent(in), dimension(:) :: weights complex, intent(out), dimension(:, :) :: pout logical, intent(in), optional :: reduce_in Contents None","tags":"","loc":"proc/integrate_species_ffs.html"},{"title":"integrate_vmu_ffs â€“ stella","text":"public subroutine integrate_vmu_ffs(g, weights, ia, iz, pout, reduce_in) Uses mp stella_layouts the inclusion of the Maxwellian term below is due to the fact that\ng/F is evolved for FFS Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(vmu_lo%llim_proc:) :: g real, intent(in), dimension(:) :: weights integer, intent(in) :: ia integer, intent(in) :: iz complex, intent(out), dimension(:) :: pout logical, intent(in), optional :: reduce_in Contents None","tags":"","loc":"proc/integrate_vmu_ffs.html"},{"title":"finish_vpa_grid â€“ stella","text":"public subroutine finish_vpa_grid() Arguments None Contents None","tags":"","loc":"proc/finish_vpa_grid.html"},{"title":"init_mu_grid â€“ stella","text":"public subroutine init_mu_grid() Uses stella_geometry species zgrid gauss_quad kt_grids allocate arrays and initialize to zero\ndvpe * vpe = d(2 mu B0) * B/2B0\nfirst get equally spaced grid in mu with max value\nmu_max = vperp_max 2/(2 max(bmag))\nwant first grid point at dmu/2 to avoid mu=0 special point\ndmu/2 + (nmu-1) dmu = mu_max\nso dmu = mu_max/(nmu-1/2)\ndo simplest thing to start\nleave dmu(nmu) uninitialized. should never be used, so want\nvalgrind or similar to return error if it is maxwell_mu is the mu part of the v-space Maxwellian factor of 2. necessary to account for 2pi from\nintegration over gyro-angle and 1/pi&#94;(3/2) normalization\nof velocity space Jacobian add ghost cell at mu=0 and beyond mu_max for purposes of differentiation\nnote assuming here that grid spacing for ghost cell is equal to\ngrid spacing for last non-ghost cell\nthis is mu at cell centres (including to left and right of mu grid boundary points)\nthis is mu_{j+1/2} - mu_{j-1/2} Arguments None Contents None","tags":"","loc":"proc/init_mu_grid.html"},{"title":"finish_mu_grid â€“ stella","text":"public subroutine finish_mu_grid() Arguments None Contents None","tags":"","loc":"proc/finish_mu_grid.html"},{"title":"calculate_velocity_integrals â€“ stella","text":"public subroutine calculate_velocity_integrals() Uses zgrid species Arguments None Contents None","tags":"","loc":"proc/calculate_velocity_integrals.html"},{"title":"finish_vpamu_grids â€“ stella","text":"public subroutine finish_vpamu_grids() Arguments None Contents None","tags":"","loc":"proc/finish_vpamu_grids.html"},{"title":"integrate_species â€“ stella","text":"public interface integrate_species Contents Module Procedures integrate_species_vmu_single integrate_species_vmu_single_real integrate_species_vmu_block_complex integrate_species_vmu_block_real Module Procedures public subroutine integrate_species_vmu_single (g, iz, weights, total, ia_in, reduce_in) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(vmu_lo%llim_proc:) :: g integer, intent(in) :: iz real, intent(in), dimension(:) :: weights complex, intent(out) :: total integer, intent(in), optional :: ia_in logical, intent(in), optional :: reduce_in public subroutine integrate_species_vmu_single_real (g, iz, weights, total, ia_in, reduce_in) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(vmu_lo%llim_proc:) :: g integer, intent(in) :: iz real, intent(in), dimension(:) :: weights real, intent(out) :: total integer, intent(in), optional :: ia_in logical, intent(in), optional :: reduce_in public subroutine integrate_species_vmu_block_complex (g, iz, weights, pout, ia_in, reduce_in) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, vmu_lo%llim_proc:) :: g integer, intent(in) :: iz real, intent(in), dimension(:) :: weights complex, intent(out), dimension(:, :) :: pout integer, intent(in), optional :: ia_in logical, intent(in), optional :: reduce_in public subroutine integrate_species_vmu_block_real (g, iz, weights, pout, ia_in, reduce_in) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :, vmu_lo%llim_proc:) :: g integer, intent(in) :: iz real, intent(in), dimension(:) :: weights real, intent(out), dimension(:, :) :: pout integer, intent(in), optional :: ia_in logical, intent(in), optional :: reduce_in","tags":"","loc":"interface/integrate_species.html"},{"title":"integrate_vmu â€“ stella","text":"public interface integrate_vmu Contents Module Procedures integrate_vmu_local_real integrate_vmu_local_complex integrate_vmu_vmulo_complex integrate_vmu_vmulo_ivmu_only_real Module Procedures public subroutine integrate_vmu_local_real (g, iz, total) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: g integer, intent(in) :: iz real, intent(out) :: total public subroutine integrate_vmu_local_complex (g, iz, total) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: g integer, intent(in) :: iz complex, intent(out) :: total public subroutine integrate_vmu_vmulo_complex (g, weights, total) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g real, intent(in), dimension(:) :: weights complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: total public subroutine integrate_vmu_vmulo_ivmu_only_real (g, ia, iz, total) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(vmu_lo%llim_proc:) :: g integer, intent(in) :: ia integer, intent(in) :: iz real, intent(out), dimension(:) :: total","tags":"","loc":"interface/integrate_vmu.html"},{"title":"integrate_mu â€“ stella","text":"public interface integrate_mu Contents Module Procedures integrate_mu_local integrate_mu_nonlocal Module Procedures public subroutine integrate_mu_local (iz, g, total) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iz real, intent(in), dimension(:, :) :: g real, intent(out), dimension(:) :: total public subroutine integrate_mu_nonlocal (iz, g, total) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iz real, intent(in), dimension(vmu_lo%llim_proc:) :: g real, intent(out), dimension(:, :) :: total","tags":"","loc":"interface/integrate_mu.html"},{"title":"init_gxyz â€“ stella","text":"public subroutine init_gxyz(restarted) Uses stella_geometry physics_flags stella_transforms zgrid species dist_redistribute dist_fn_arrays stella_layouts vpamu_grids redistribute kt_grids Arguments Type Intent Optional Attributes Name logical, intent(in) :: restarted Contents None","tags":"","loc":"proc/init_gxyz.html"},{"title":"init_dist_fn â€“ stella","text":"public subroutine init_dist_fn() Uses mp gyro_averages stella_layouts allocate and initialise kperp2 and dkperp2dr\nallocate and initialise vperp2\ninit_bessel sets up arrays needed for gyro-averaging;\nfor a flux tube simulation, this is j0 and j1;\nfor a flux annulus simulation, gyro-averaging is non-local in ky\nand so more effort is required Arguments None Contents None","tags":"","loc":"proc/init_dist_fn.html"},{"title":"init_kperp2 â€“ stella","text":"private subroutine init_kperp2() Uses dist_fn_arrays kt_grids zgrid stella_geometry init_kperp2 allocates and initialises the kperp2 and dkperp2dr arrays Todo would be tidier if dkperp2dr were initialised separately in, e.g., init_dkperp2dr allocate the kperp2 array to contain |k_perp|&#94;2 Todo as dkperp2dr is only needed for radially global simulations\nshould only allocate/compute it when needed Arguments None Contents None","tags":"","loc":"proc/init_kperp2.html"},{"title":"enforce_single_valued_kperp2 â€“ stella","text":"private subroutine enforce_single_valued_kperp2() Uses dist_fn_arrays zgrid extended_zgrid kt_grids Arguments None Contents None","tags":"","loc":"proc/enforce_single_valued_kperp2.html"},{"title":"allocate_arrays â€“ stella","text":"private subroutine allocate_arrays() Uses vpamu_grids dist_fn_arrays stella_layouts zgrid kt_grids Arguments None Contents None","tags":"","loc":"proc/allocate_arrays~5.html"},{"title":"init_vperp2 â€“ stella","text":"private subroutine init_vperp2() Uses stella_geometry zgrid kt_grids vpamu_grids Arguments None Contents None","tags":"","loc":"proc/init_vperp2.html"},{"title":"finish_dist_fn â€“ stella","text":"public subroutine finish_dist_fn() Uses gyro_averages Arguments None Contents None","tags":"","loc":"proc/finish_dist_fn.html"},{"title":"deallocate_arrays â€“ stella","text":"private subroutine deallocate_arrays() Uses dist_fn_arrays Arguments None Contents None","tags":"","loc":"proc/deallocate_arrays~3.html"},{"title":"finish_kperp2 â€“ stella","text":"private subroutine finish_kperp2() Uses dist_fn_arrays Arguments None Contents None","tags":"","loc":"proc/finish_kperp2.html"},{"title":"finish_vperp2 â€“ stella","text":"private subroutine finish_vperp2() Uses vpamu_grids Arguments None Contents None","tags":"","loc":"proc/finish_vperp2.html"},{"title":"g_to_h_vmu â€“ stella","text":"private subroutine g_to_h_vmu(g, phi, facphi, phi_corr) Uses stella_geometry vpamu_grids physics_flags stella_transforms gyro_averages species dist_fn_arrays stella_layouts zgrid kt_grids Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi real, intent(in) :: facphi complex, intent(in), optional dimension(:, :, -nzgrid:, :) :: phi_corr Contents None","tags":"","loc":"proc/g_to_h_vmu.html"},{"title":"g_to_h_kxkyz â€“ stella","text":"private subroutine g_to_h_kxkyz(g, phi, facphi) Uses gyro_averages zgrid species stella_layouts vpamu_grids Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi real, intent(in) :: facphi Contents None","tags":"","loc":"proc/g_to_h_kxkyz.html"},{"title":"g_to_h â€“ stella","text":"public interface g_to_h Contents Module Procedures g_to_h_kxkyz g_to_h_vmu Module Procedures private subroutine g_to_h_kxkyz (g, phi, facphi) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi real, intent(in) :: facphi private subroutine g_to_h_vmu (g, phi, facphi, phi_corr) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi real, intent(in) :: facphi complex, intent(in), optional dimension(:, :, -nzgrid:, :) :: phi_corr","tags":"","loc":"interface/g_to_h.html"},{"title":"init_geometry â€“ stella","text":"public subroutine init_geometry(nalpha, naky) Uses millerlocal physics_flags mp inputprofiles_interface constants file_utils zgrid vmec_geo b_dot_grad_z is the alpha-dependent b . grad z,\nand gradpar is the constant-in-alpha part of it.\nfor axisymmetric systems, b_dot_grad_z is independent of alpha. | grad x |  = dx/drho * | grad rho | = dx/dpsi * dpsi/drho * | grad rho |\n= q/rho * dpsidrho * grho b_dot_grad_z is the alpha-dependent b . grad z,\nand gradpar is the constant-in-alpha part of it.\nfor axisymmetric systems, b_dot_grad_z is independent of alpha. | grad x |  = dx/drho * | grad rho | = dx/dpsi * dpsi/drho * | grad rho |\n= q/rho * dpsidrho * grho b_dot_grad_z is the alpha-dependent b . grad z,\nand gradpar is the constant-in-alpha part of it.\nfor axisymmetric systems, b_dot_grad_z is independent of alpha. | grad x |  = dx/drho * | grad rho | = dx/dpsi * dpsi/drho * | grad rho |\n= q/rho * dpsidrho * grho read in input parameters for vmec\nnalpha may be specified via input file\nallocate geometry arrays\nget geometry coefficients from vmec\nBref = 2 abs(psi_tor_LCFS)/a&#94;2\na Bref dx/dpsi_tor = sign(psi_tor)/rhotor\npsi = -psi_tor\ndxdXcoord = a Bref dx/dpsi = -a Bref dx/dpsi_tor = -sign(psi_tor)/rhotor\ndydalpha = (dy/dalpha) / a = sign(dydalpha) * rhotor\nif using vmec, rho = sqrt(psitor/psitor_lcfs)\npsiN = -psitor/(aref 2 Bref)\nso drho/dpsiN = -drho/d(rho 2) * (aref 2*Bref/psitor_lcfs) = -1.0/rho\nabs(twist_and_shift_geo_fac) is dkx/dky * jtwist\nminus its sign gives the direction of the shift in kx\nto be used for twist-and-shift BC\ngrad_x = | grad x | gds2 = |grad y|&#94;2 = |grad alpha|&#94;2 * (dy/dalpha)&#94;2\nnote that rhotor = sqrt(psi/psi_LCFS)\ngds21 = shat * grad x . grad y = shat * dx/dpsi_t * dy/dalpha * grad alpha . grad psi_t\nNB: psi = -psi_t and so dx/dpsi = = dx/dpsi_t, which is why there is a minus sign here\ngds22 = shat&#94;2 * |grad x|&#94;2 = shat&#94;2 * |grad psi_t|&#94;2 * (dx/dpsi_t)&#94;2 gbdrift_alpha and cvdrift_alpha contain\nthe grad-B and curvature drifts projected onto\nthe grad alpha direction\nneed the projections on grad y\ngbdrift0_psi and cvdrift0_psi contain\nthe grad-B and curvature drifts projected onto\nthe grad psi direction\nneed the projections on grad x\ncan test FFS implementation by setting all geometric coefficients\nto their values at a given alpha; i.e., make the system axisymmetric\njacob is the Jacobian from Cartesian coordinates to (y,x,z) coordinates\nis ((grad y x grad x) . grad z)&#94;(-1) = Lref (dalpha/dy) (dpsi/dx)/(Lref Bref) (B/Bref . grad z)&#94;(-1)\nLref (dalpha/dy) = 1/dydalpha; (dpsi/dx)/(Lref Bref) = 1 / dxdXcoord ; (B/Bref . grad z) = gradpar*bmag Arguments Type Intent Optional Attributes Name integer, intent(in) :: nalpha integer, intent(in) :: naky Contents None","tags":"","loc":"proc/init_geometry.html"},{"title":"allocate_arrays â€“ stella","text":"private subroutine allocate_arrays(nalpha, nzgrid) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nalpha integer, intent(in) :: nzgrid Contents None","tags":"","loc":"proc/allocate_arrays~6.html"},{"title":"read_parameters â€“ stella","text":"private subroutine read_parameters() Uses mp text_options file_utils physics_flags Arguments None Contents None","tags":"","loc":"proc/read_parameters~12.html"},{"title":"broadcast_arrays â€“ stella","text":"private subroutine broadcast_arrays() Uses mp Arguments None Contents None","tags":"","loc":"proc/broadcast_arrays.html"},{"title":"communicate_geo_multibox â€“ stella","text":"public subroutine communicate_geo_multibox(l_edge, r_edge) Uses mp millerlocal Arguments Type Intent Optional Attributes Name real, intent(in) :: l_edge real, intent(in) :: r_edge Contents None","tags":"","loc":"proc/communicate_geo_multibox.html"},{"title":"get_dzed â€“ stella","text":"private subroutine get_dzed(nz, dz, f, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nz real, intent(in), dimension(-nz:) :: dz real, intent(in), dimension(-nz:) :: f real, intent(out), dimension(-nz:) :: df Contents None","tags":"","loc":"proc/get_dzed~2.html"},{"title":"get_gradpar_eqarc â€“ stella","text":"private subroutine get_gradpar_eqarc(gp, z, dz, gp_eqarc) Uses zgrid constants Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nzgrid:) :: gp real, intent(in), dimension(-nzgrid:) :: z real, intent(in), dimension(-nzgrid:) :: dz real, intent(out) :: gp_eqarc Contents None","tags":"","loc":"proc/get_gradpar_eqarc.html"},{"title":"get_zed_eqarc â€“ stella","text":"private subroutine get_zed_eqarc(gp, dz, z, gp_eqarc, z_eqarc) Uses zgrid Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nzgrid:) :: gp real, intent(in), dimension(-nzgrid:) :: dz real, intent(in), dimension(-nzgrid:) :: z real, intent(in) :: gp_eqarc real, intent(out), dimension(-nzgrid:) :: z_eqarc Contents None","tags":"","loc":"proc/get_zed_eqarc.html"},{"title":"integrate_zed â€“ stella","text":"private subroutine integrate_zed(dz, f, intf) Uses zgrid Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nzgrid:) :: dz real, intent(in), dimension(-nzgrid:) :: f real, intent(out) :: intf Contents None","tags":"","loc":"proc/integrate_zed~2.html"},{"title":"get_x_to_rho â€“ stella","text":"public subroutine get_x_to_rho(llim, x_in, rho_out) Uses physics_parameters Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(:) :: x_in real, intent(out), dimension(:) :: rho_out Contents None","tags":"","loc":"proc/get_x_to_rho.html"},{"title":"write_geometric_coefficients â€“ stella","text":"private subroutine write_geometric_coefficients(nalpha) Uses zgrid file_utils Arguments Type Intent Optional Attributes Name integer, intent(in) :: nalpha Contents None","tags":"","loc":"proc/write_geometric_coefficients.html"},{"title":"finish_init_geometry â€“ stella","text":"public subroutine finish_init_geometry() Uses mp millerlocal Arguments None Contents None","tags":"","loc":"proc/finish_init_geometry.html"},{"title":"finish_geometry â€“ stella","text":"public subroutine finish_geometry() Arguments None Contents None","tags":"","loc":"proc/finish_geometry.html"},{"title":"read_inputprof_geo â€“ stella","text":"public subroutine read_inputprof_geo(surf) Uses common_types millerlocal splines finite_differences constants Arguments Type Intent Optional Attributes Name type( flux_surface_type ), intent(inout) :: surf Contents None","tags":"","loc":"proc/read_inputprof_geo.html"},{"title":"read_inputprof_spec â€“ stella","text":"public subroutine read_inputprof_spec(nspec, spec) Uses common_types millerlocal splines mp finite_differences physics_parameters Arguments Type Intent Optional Attributes Name integer, intent(in) :: nspec type( spec_type ), intent(inout), dimension(:) :: spec Contents None","tags":"","loc":"proc/read_inputprof_spec.html"},{"title":"allocate_arrays_geo â€“ stella","text":"private subroutine allocate_arrays_geo() Arguments None Contents None","tags":"","loc":"proc/allocate_arrays_geo.html"},{"title":"allocate_arrays_spec â€“ stella","text":"private subroutine allocate_arrays_spec() Arguments None Contents None","tags":"","loc":"proc/allocate_arrays_spec.html"},{"title":"deallocate_arrays_geo â€“ stella","text":"private subroutine deallocate_arrays_geo() Arguments None Contents None","tags":"","loc":"proc/deallocate_arrays_geo.html"},{"title":"deallocate_arrays_spec â€“ stella","text":"private subroutine deallocate_arrays_spec() Arguments None Contents None","tags":"","loc":"proc/deallocate_arrays_spec.html"},{"title":"read_vmec_parameters â€“ stella","text":"public subroutine read_vmec_parameters() Uses mp zgrid file_utils Arguments None Contents None","tags":"","loc":"proc/read_vmec_parameters.html"},{"title":"init_vmec_defaults â€“ stella","text":"public subroutine init_vmec_defaults() Uses zgrid Arguments None Contents None","tags":"","loc":"proc/init_vmec_defaults.html"},{"title":"get_vmec_geo â€“ stella","text":"public subroutine get_vmec_geo(nzgrid, nalpha, naky, surf, grho, bmag, gradpar, b_dot_grad_z, grad_alpha_grad_alpha, grad_alpha_grad_psi, grad_psi_grad_psi, gds23, gds24, gds25, gds26, gbdrift_alpha, gbdrift0_psi, cvdrift_alpha, cvdrift0_psi, sign_torflux, theta_vmec, zed_scalefac, L_reference, B_reference, alpha, zeta, field_period_ratio, x_displacement_fac) Uses common_types physics_flags splines vmec_to_stella_geometry_interface_mod constants file_utils zgrid first read in equilibrium information from vmec file\nthis is stored as a set of global variables in read_wout_mod\nin mini_libstell.  it will be accessible\nif desired, increase number of sampled zeta grid points in VMEC data\nto increase accuracy of later integration in zeta and interpolation\nonto stella zed grid allocate vmec geometry arrays of size 2*nzgrid_vmec+1\nget ratio of number of simulated field periods to the number of field periods of the device must interpolate geometric quantities from (zeta,alpha) grid to\n(zed,alpha) grid, with zed the normalised arc-length\nfirst need to get zed(zeta,alpha)\ndefined via H(alpha) = b . grad z = b . grad zeta * dz/dzeta\nand z_min = zeta_min, z_max = zeta_max (independent of alpha).\nnote that nzgrid zgrid_refinement_factor gives index\nfor the max zeta of the nominal zeta grid\nzed_domain_size is z(zeta_max) - z(zeta_min) for nominal zeta domain\nz(zeta_min) should be zeta_min\nb_dot_grad_z is the total arc-length for one toroidal turn,\nmultiplied by 2 pi\nnow that we know the min/max values of z corresponding to min/max values\nof the nominal zeta at each of the alphas, construct a regular z grid\nset the max z value on this regular grid to the maximum over all alpha\nof z(zeta_max,alpha) scale zed so that it is arc-length compressed (or expanded)\nto the range [-pi:pi]\nnow that we have z(alpha,zeta), interpolate from regular zeta grid (which is irregular in z)\nto regular zed grid (irregular in zeta)\ngradpar at this point is b . grad zeta\nbut want it to be b . grad z = b . grad zeta * dz/dzeta.\nwe have constructed b_dot_grad_z = b . grad to be a function purely of alpha,\nso dz/dzeta = b_dot_grad_z(alpha) / b_dot_grad_zeta(alpha,zeta)\ngds23 and gds24 involve grad z factors\nbut currently calculated in terms of grad zeta\nso convert via multiplication with dz/dzeta\ndefine gradpar to be the average value of b_dot_grad_z in alpha we now have geometric coefficients on an alpha-grid.\nas we will be multiplying this with functions of g and phi,\nwe must take care to avoid aliasing.\nthis is accomplished by filtering out the highest third of\nthe wavenumber spectra\nif zed_equal_arc = F, zed coordinate is the same as VMEC's zeta coordinate,\nso no need to interpolate onto a new grid\ngradpar is b . grad zed (or its alpha-average, in the case of full_flux_surface=T),\nwith zed = zeta or normalised arc-length, both scaled to run from -pi to pi Arguments Type Intent Optional Attributes Name integer, intent(in) :: nzgrid integer, intent(in) :: nalpha integer, intent(in) :: naky type( flux_surface_type ), intent(out) :: surf real, intent(out), dimension(:, -nzgrid:) :: grho real, intent(out), dimension(:, -nzgrid:) :: bmag real, intent(out), dimension(-nzgrid:) :: gradpar real, intent(out), dimension(:, -nzgrid:) :: b_dot_grad_z real, intent(out), dimension(:, -nzgrid:) :: grad_alpha_grad_alpha real, intent(out), dimension(:, -nzgrid:) :: grad_alpha_grad_psi real, intent(out), dimension(:, -nzgrid:) :: grad_psi_grad_psi real, intent(out), dimension(:, -nzgrid:) :: gds23 real, intent(out), dimension(:, -nzgrid:) :: gds24 real, intent(out), dimension(:, -nzgrid:) :: gds25 real, intent(out), dimension(:, -nzgrid:) :: gds26 real, intent(out), dimension(:, -nzgrid:) :: gbdrift_alpha real, intent(out), dimension(:, -nzgrid:) :: gbdrift0_psi real, intent(out), dimension(:, -nzgrid:) :: cvdrift_alpha real, intent(out), dimension(:, -nzgrid:) :: cvdrift0_psi integer, intent(out) :: sign_torflux real, intent(out), dimension(:, -nzgrid:) :: theta_vmec real, intent(out) :: zed_scalefac real, intent(out) :: L_reference real, intent(out) :: B_reference real, intent(out), dimension(:) :: alpha real, intent(out), dimension(:, -nzgrid:) :: zeta real, intent(out) :: field_period_ratio real, intent(out), dimension(:, -nzgrid:) :: x_displacement_fac Contents None","tags":"","loc":"proc/get_vmec_geo.html"},{"title":"filter_geo_coef â€“ stella","text":"public subroutine filter_geo_coef(naky, geocoef) Uses stella_transforms Arguments Type Intent Optional Attributes Name integer, intent(in) :: naky real, intent(inout), dimension(:) :: geocoef Contents None","tags":"","loc":"proc/filter_geo_coef.html"},{"title":"get_modified_vmec_zeta_grid â€“ stella","text":"public subroutine get_modified_vmec_zeta_grid(nzgrid_modified, dzeta_modified) Uses zgrid vmec_to_stella_geometry_interface_mod need to extend the maximum and minimum zeta values\nby zgrid_scalefac to ensure that we have information\nabout geometric coefficients everywhere on a fixed\nequal-arc grid in zed\nfirst figure out how many extra zeta grid points are\nrequired at the nominal grid spacing to get out\nto the ends of the extended zeta domain\nfirst calculate the nominal zeta grid used for vmec\nnote that nfield_periods is the number of field periods\nsampled in stella, while nfield_periods_device\nis the number of field periods in the device\nnfield_periods may be reasonably bigger than nfield_periods_device\nas the former is sampled while keeping alpha fixed (rather than theta) maximum zeta value for nominal zeta grid\nexcess_zeta is difference between expanded zeta_max and nominal zeta_max\nassumes equal grid spacing in zeta\nnzgrid_excess is the number of additional zeta grid points needed to\ncover at least excess_zeta\nnow refine the zeta grid by desired amount in\npreparation for interpolation Arguments Type Intent Optional Attributes Name integer, intent(out) :: nzgrid_modified real :: dzeta_modified Contents None","tags":"","loc":"proc/get_modified_vmec_zeta_grid.html"},{"title":"Rpos â€“ stella","text":"private function Rpos(r, theta, j) Uses constants Arguments Type Intent Optional Attributes Name real, intent(in) :: r real, intent(in) :: theta integer, intent(in) :: j Return Value real Contents None","tags":"","loc":"proc/rpos.html"},{"title":"Zpos â€“ stella","text":"private function Zpos(r, theta, j) Arguments Type Intent Optional Attributes Name real, intent(in) :: r real, intent(in) :: theta integer, intent(in) :: j Return Value real Contents None","tags":"","loc":"proc/zpos.html"},{"title":"mod2pi â€“ stella","text":"private function mod2pi(theta) Arguments Type Intent Optional Attributes Name real, intent(in) :: theta Return Value real Contents None","tags":"","loc":"proc/mod2pi.html"},{"title":"init_local_defaults â€“ stella","text":"public subroutine init_local_defaults() Arguments None Contents None","tags":"","loc":"proc/init_local_defaults.html"},{"title":"read_local_parameters â€“ stella","text":"public subroutine read_local_parameters(nzed, nzgrid, local_out) Uses common_types file_utils Arguments Type Intent Optional Attributes Name integer, intent(in) :: nzed integer, intent(in) :: nzgrid type( flux_surface_type ), intent(out) :: local_out Contents None","tags":"","loc":"proc/read_local_parameters.html"},{"title":"communicate_parameters_multibox â€“ stella","text":"public subroutine communicate_parameters_multibox(surf, drl, drr) Uses job_manage mp common_types Arguments Type Intent Optional Attributes Name type( flux_surface_type ), intent(inout) :: surf real, intent(in), optional :: drl real, intent(in), optional :: drr Contents None","tags":"","loc":"proc/communicate_parameters_multibox.html"},{"title":"get_local_geo â€“ stella","text":"public subroutine get_local_geo(nzed, nzgrid, zed_in, zed_equal_arc, dpsidrho_out, dpsidrho_psi0_out, dIdrho_out, grho_out, bmag_out, bmag_psi0_out, gds2_out, gds21_out, gds22_out, gds23_out, gds24_out, gradpar_out, gbdrift0_out, gbdrift_out, cvdrift0_out, cvdrift_out, dBdrho_out, d2Bdrdth_out, dgradpardrho_out, btor_out, rmajor_out, dcvdrift0drho_out, dcvdriftdrho_out, dgbdrift0drho_out, dgbdriftdrho_out, dgds2dr_out, dgds21dr_out, dgds22dr_out, djacdrho_out) Uses file_utils constants splines Arguments Type Intent Optional Attributes Name integer, intent(in) :: nzed integer, intent(in) :: nzgrid real, intent(in), dimension(-nzgrid:) :: zed_in logical, intent(in) :: zed_equal_arc real, intent(out) :: dpsidrho_out real, intent(out) :: dpsidrho_psi0_out real, intent(out) :: dIdrho_out real, intent(out), dimension(-nzgrid:) :: grho_out real, intent(out), dimension(-nzgrid:) :: bmag_out real, intent(out), dimension(-nzgrid:) :: bmag_psi0_out real, intent(out), dimension(-nzgrid:) :: gds2_out real, intent(out), dimension(-nzgrid:) :: gds21_out real, intent(out), dimension(-nzgrid:) :: gds22_out real, intent(out), dimension(-nzgrid:) :: gds23_out real, intent(out), dimension(-nzgrid:) :: gds24_out real, intent(out), dimension(-nzgrid:) :: gradpar_out real, intent(out), dimension(-nzgrid:) :: gbdrift0_out real, intent(out), dimension(-nzgrid:) :: gbdrift_out real, intent(out), dimension(-nzgrid:) :: cvdrift0_out real, intent(out), dimension(-nzgrid:) :: cvdrift_out real, intent(out), dimension(-nzgrid:) :: dBdrho_out real, intent(out), dimension(-nzgrid:) :: d2Bdrdth_out real, intent(out), dimension(-nzgrid:) :: dgradpardrho_out real, intent(out), dimension(-nzgrid:) :: btor_out real, intent(out), dimension(-nzgrid:) :: rmajor_out real, intent(out), dimension(-nzgrid:) :: dcvdrift0drho_out real, intent(out), dimension(-nzgrid:) :: dcvdriftdrho_out real, intent(out), dimension(-nzgrid:) :: dgbdrift0drho_out real, intent(out), dimension(-nzgrid:) :: dgbdriftdrho_out real, intent(out), dimension(-nzgrid:) :: dgds2dr_out real, intent(out), dimension(-nzgrid:) :: dgds21dr_out real, intent(out), dimension(-nzgrid:) :: dgds22dr_out real, intent(out), dimension(-nzgrid:) :: djacdrho_out Contents None","tags":"","loc":"proc/get_local_geo.html"},{"title":"allocate_arrays â€“ stella","text":"private subroutine allocate_arrays(nr, nz) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nr integer, intent(in) :: nz Contents None","tags":"","loc":"proc/allocate_arrays~7.html"},{"title":"deallocate_arrays â€“ stella","text":"private subroutine deallocate_arrays() Arguments None Contents None","tags":"","loc":"proc/deallocate_arrays~4.html"},{"title":"finish_local_geo â€“ stella","text":"public subroutine finish_local_geo() Arguments None Contents None","tags":"","loc":"proc/finish_local_geo.html"},{"title":"get_drho â€“ stella","text":"private subroutine get_drho(f, df) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, -nz:) :: f real, intent(out), dimension(-nz:) :: df Contents None","tags":"","loc":"proc/get_drho.html"},{"title":"get_d2dthet2 â€“ stella","text":"private subroutine get_d2dthet2(f, d2f) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nz:) :: f real, intent(out), dimension(-nz:) :: d2f Contents None","tags":"","loc":"proc/get_d2dthet2.html"},{"title":"get_dthet â€“ stella","text":"private subroutine get_dthet(f, df) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nz:) :: f real, intent(out), dimension(-nz:) :: df Contents None","tags":"","loc":"proc/get_dthet.html"},{"title":"get_jacrho â€“ stella","text":"private subroutine get_jacrho() Arguments None Contents None","tags":"","loc":"proc/get_jacrho.html"},{"title":"get_gradrho â€“ stella","text":"private subroutine get_gradrho(dpsidrho, grho) Arguments Type Intent Optional Attributes Name real, intent(in) :: dpsidrho real, intent(out), dimension(-nz:) :: grho Contents None","tags":"","loc":"proc/get_gradrho.html"},{"title":"get_dIdrho â€“ stella","text":"private subroutine get_dIdrho(dpsidrho, grho, dIdrho) Uses constants Arguments Type Intent Optional Attributes Name real, intent(in) :: dpsidrho real, intent(in), dimension(-nz:) :: grho real, intent(out) :: dIdrho Contents None","tags":"","loc":"proc/get_didrho.html"},{"title":"get_djacdrho â€“ stella","text":"private subroutine get_djacdrho(dpsidrho, dIdrho, grho) Arguments Type Intent Optional Attributes Name real, intent(in) :: dpsidrho real, intent(in) :: dIdrho real, intent(in), dimension(-nz:) :: grho Contents None","tags":"","loc":"proc/get_djacdrho.html"},{"title":"get_d2RZdr2 â€“ stella","text":"private subroutine get_d2RZdr2() Arguments None Contents None","tags":"","loc":"proc/get_d2rzdr2.html"},{"title":"get_dgr2dr â€“ stella","text":"private subroutine get_dgr2dr(dpsidrho, grho) Arguments Type Intent Optional Attributes Name real, intent(in) :: dpsidrho real, intent(in), dimension(-nz:) :: grho Contents None","tags":"","loc":"proc/get_dgr2dr.html"},{"title":"get_graddotgrad â€“ stella","text":"private subroutine get_graddotgrad(dpsidrho, grho) Arguments Type Intent Optional Attributes Name real, intent(in) :: dpsidrho real, intent(in), dimension(-nz:) :: grho Contents None","tags":"","loc":"proc/get_graddotgrad.html"},{"title":"get_gds â€“ stella","text":"private subroutine get_gds(gds2, gds21, gds22, gds23, gds24) Arguments Type Intent Optional Attributes Name real, intent(out), dimension(-nz:) :: gds2 real, intent(out), dimension(-nz:) :: gds21 real, intent(out), dimension(-nz:) :: gds22 real, intent(out), dimension(-nz:) :: gds23 real, intent(out), dimension(-nz:) :: gds24 Contents None","tags":"","loc":"proc/get_gds.html"},{"title":"get_dBdrho â€“ stella","text":"private subroutine get_dBdrho(bmag, dIdrho) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nz:) :: bmag real, intent(in) :: dIdrho Contents None","tags":"","loc":"proc/get_dbdrho.html"},{"title":"get_varthet â€“ stella","text":"private subroutine get_varthet(dpsidrho) Arguments Type Intent Optional Attributes Name real, intent(in) :: dpsidrho Contents None","tags":"","loc":"proc/get_varthet.html"},{"title":"get_dvarthdr â€“ stella","text":"private subroutine get_dvarthdr(dpsidrho, dIdrho) Arguments Type Intent Optional Attributes Name real, intent(in) :: dpsidrho real, intent(in) :: dIdrho Contents None","tags":"","loc":"proc/get_dvarthdr.html"},{"title":"get_d2Idr2_d2jacdr2 â€“ stella","text":"private subroutine get_d2Idr2_d2jacdr2(grho, dIdrho) Uses constants Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nz:) :: grho real, intent(in) :: dIdrho Contents None","tags":"","loc":"proc/get_d2idr2_d2jacdr2.html"},{"title":"get_d2varthdr2 â€“ stella","text":"private subroutine get_d2varthdr2(dpsidrho, dIdrho) Arguments Type Intent Optional Attributes Name real, intent(in) :: dpsidrho real, intent(in) :: dIdrho Contents None","tags":"","loc":"proc/get_d2varthdr2.html"},{"title":"get_d2Bdr2 â€“ stella","text":"private subroutine get_d2Bdr2(bmag, dIdrho) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nz:) :: bmag real, intent(in) :: dIdrho Contents None","tags":"","loc":"proc/get_d2bdr2.html"},{"title":"get_dcrossdr â€“ stella","text":"private subroutine get_dcrossdr(dpsidrho, dIdrho, grho) Arguments Type Intent Optional Attributes Name real, intent(in) :: dpsidrho real, intent(in) :: dIdrho real, intent(in), dimension(-nz:) :: grho Contents None","tags":"","loc":"proc/get_dcrossdr.html"},{"title":"theta_integrate â€“ stella","text":"private subroutine theta_integrate(integrand, integral) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nz2pi:) :: integrand real, intent(out) :: integral Contents None","tags":"","loc":"proc/theta_integrate.html"},{"title":"theta_integrate_indef â€“ stella","text":"private subroutine theta_integrate_indef(integrand, integral) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nz:) :: integrand real, intent(out), dimension(-nz:) :: integral Contents None","tags":"","loc":"proc/theta_integrate_indef.html"},{"title":"fzero_residual â€“ stella","text":"private function fzero_residual(theta_vmec_try) Arguments Type Intent Optional Attributes Name real :: theta_vmec_try Return Value real Contents None","tags":"","loc":"proc/fzero_residual.html"},{"title":"read_vmec_equilibrium â€“ stella","text":"public subroutine read_vmec_equilibrium(vmec_filename) Uses read_wout_mod Arguments Type Intent Optional Attributes Name character, intent(in) :: vmec_filename Contents None","tags":"","loc":"proc/read_vmec_equilibrium.html"},{"title":"get_nominal_vmec_zeta_grid â€“ stella","text":"public subroutine get_nominal_vmec_zeta_grid(nzgrid, zeta_center, number_of_field_periods_stella, number_of_field_periods_device, zeta) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nzgrid real, intent(in) :: zeta_center real, intent(inout) :: number_of_field_periods_stella real, intent(out) :: number_of_field_periods_device real, intent(out), dimension(-nzgrid:) :: zeta Contents None","tags":"","loc":"proc/get_nominal_vmec_zeta_grid.html"},{"title":"vmec_to_stella_geometry_interface â€“ stella","text":"public subroutine vmec_to_stella_geometry_interface(nalpha, alpha0, nzgrid, zeta_center, number_of_field_periods_to_include, desired_normalized_toroidal_flux, vmec_surface_option, verbose, normalized_toroidal_flux_used, safety_factor_q, shat, L_reference, B_reference, nfp_out, sign_toroidal_flux, alpha, zeta, bmag, gradpar_zeta, grad_alpha_grad_alpha, grad_alpha_grad_psi, grad_psi_grad_psi, gds23, gds24, gds25, gds26, gbdrift_alpha, gbdrift0_psi, cvdrift_alpha, cvdrift0_psi, theta_vmec, B_sub_zeta, B_sub_theta_vmec, x_displacement_fac) Uses fzero_mod Input parameters Determine which flux surface to use, based on\n desired_normalized_toroidal_flux and vmec_surface_option. Evaluate several radial-profile functions at the flux surface\n we ended up choosing. Set up the coordinate grids. We know theta_pest = alpha + iota * zeta, but we need to determine\n theta_vmec = theta_pest - Lambda. Initialize geometry arrays Now that we know the grid points in theta_vmec, we can evaluate\n all the geometric quantities on the grid points. Sanity check: If the conversion to theta_pest has been done\n correctly, we should find that\n (B dot grad theta_pest) / (B dot grad zeta) = iota.\n Let's verify this: Using R(theta,zeta) and Z(theta,zeta), compute the Cartesian\n components of the gradient basis vectors using the dual relations: Compute the Cartesian components of other quantities we need: Sanity tests: Verify that the Jacobian equals the appropriate\n cross product of the basis vectors. Sanity tests: Verify that\n \\vec{B} dot (each of the covariant and contravariant basis vectors)\n matches the corresponding term from VMEC. For gbdrift, we need \\vect{B} cross grad |B| dot grad alpha.\n For cvdrift, we also need \\vect{B} cross grad s dot grad alpha.\n Let us compute both of these quantities 2 ways, and make sure the two\n approaches give the same answer (within some tolerance). Finally, assemble the quantities needed for stella. Free all arrays that were allocated. Arguments Type Intent Optional Attributes Name integer, intent(in) :: nalpha real, intent(in) :: alpha0 integer, intent(in) :: nzgrid real, intent(in) :: zeta_center real, intent(in) :: number_of_field_periods_to_include real, intent(in) :: desired_normalized_toroidal_flux integer, intent(in) :: vmec_surface_option logical, intent(in) :: verbose Output quantities real, intent(out) :: normalized_toroidal_flux_used real, intent(out) :: safety_factor_q real, intent(out) :: shat real, intent(out) :: L_reference real, intent(out) :: B_reference real, intent(out) :: nfp_out integer, intent(out) :: sign_toroidal_flux real, intent(out), dimension(:) :: alpha real, intent(out), dimension(-nzgrid:) :: zeta real, intent(out), dimension(:, -nzgrid:) :: bmag real, intent(out), dimension(:, -nzgrid:) :: gradpar_zeta real, intent(out), dimension(:, -nzgrid:) :: grad_alpha_grad_alpha real, intent(out), dimension(:, -nzgrid:) :: grad_alpha_grad_psi real, intent(out), dimension(:, -nzgrid:) :: grad_psi_grad_psi real, intent(out), dimension(:, -nzgrid:) :: gds23 real, intent(out), dimension(:, -nzgrid:) :: gds24 real, intent(out), dimension(:, -nzgrid:) :: gds25 real, intent(out), dimension(:, -nzgrid:) :: gds26 real, intent(out), dimension(:, -nzgrid:) :: gbdrift_alpha real, intent(out), dimension(:, -nzgrid:) :: gbdrift0_psi real, intent(out), dimension(:, -nzgrid:) :: cvdrift_alpha real, intent(out), dimension(:, -nzgrid:) :: cvdrift0_psi real, intent(out), dimension(:, -nzgrid:) :: theta_vmec real, intent(out), dimension(:, -nzgrid:) :: B_sub_zeta real, intent(out), dimension(:, -nzgrid:) :: B_sub_theta_vmec real, intent(out), dimension(:, -nzgrid:) :: x_displacement_fac Variables used internally by this subroutine Contents None","tags":"","loc":"proc/vmec_to_stella_geometry_interface.html"},{"title":"get_root â€“ stella","text":"private subroutine get_root(a0, b0, root, converged) Arguments Type Intent Optional Attributes Name real, intent(in) :: a0 real, intent(in) :: b0 real, intent(out) :: root logical, intent(out) :: converged Contents None","tags":"","loc":"proc/get_root.html"},{"title":"FZERO â€“ stella","text":"public subroutine FZERO(F, B, C, R, RE, AE, IFLAG) BEGIN PROLOGUE  FZERO PURPOSE  Search for a zero of a function F(X) in a given interval\n            (B,C).  It is designed primarily for problems where F(B)\n            and F(C) have opposite signs. LIBRARY   SLATEC CATEGORY  F1B TYPE      SINGLE PRECISION (FZERO-S, DFZERO-D) KEYWORDS  BISECTION, NONLINEAR EQUATIONS, ROOTS, ZEROS AUTHOR  Shampine, L. F., (SNLA)\n           Watts, H. A., (SNLA) DESCRIPTION FZERO searches for a zero of a REAL function F(X) between the\n given REAL values B and C until the width of the interval (B,C)\n has collapsed to within a tolerance specified by the stopping\n criterion,\n    ABS(B-C) .LE. 2.*(RW*ABS(B)+AE).\n The method used is an efficient combination of bisection and the\n secant rule and is due to T. J. Dekker.\n\n Description Of Arguments F     :EXT   - Name of the REAL external function.  This name must\n                  be in an EXTERNAL statement in the calling program.\n                  F must be a function of one REAL argument. B     :INOUT - One end of the REAL interval (B,C).  The value\n                  returned for B usually is the better approximation\n                  to a zero of F. C     :INOUT - The other end of the REAL interval (B,C) R     :IN    - A (better) REAL guess of a zero of F which could help\n                  in speeding up convergence.  If F(B) and F(R) have\n                  opposite signs, a root will be found in the interval\n                  (B,R); if not, but F(R) and F(C) have opposite signs,\n                  a root will be found in the interval (R,C);\n                  otherwise, the interval (B,C) will be searched for a\n                  possible root.  When no better guess is known, it is\n                  recommended that r be set to B or C, since if R is\n                  not interior to the interval (B,C), it will be\n                  ignored. RE    :IN    - Relative error used for RW in the stopping criterion.\n                  If the requested RE is less than machine precision,\n                  then RW is set to approximately machine precision. AE    :IN    - Absolute error used in the stopping criterion.  If\n                  the given interval (B,C) contains the origin, then a\n                  nonzero value should be chosen for AE. IFLAG :OUT   - A status code.  User must check IFLAG after each\n                  call.  Control returns to the user from FZERO in all\n                  cases. 1  B is within the requested tolerance of a zero.\n               The interval (B,C) collapsed to the requested\n               tolerance, the function changes sign in (B,C), and\n               F(X) decreased in magnitude as (B,C) collapsed.\n\n            2  F(B) = 0.  However, the interval (B,C) may not have\n               collapsed to the requested tolerance.\n\n            3  B may be near a singular point of F(X).\n               The interval (B,C) collapsed to the requested tol-\n               erance and the function changes sign in (B,C), but\n               F(X) increased in magnitude as (B,C) collapsed, i.e.\n                 ABS(F(B out)) .GT. MAX(ABS(F(B in)),ABS(F(C in)))\n\n            4  No change in sign of F(X) was found although the\n               interval (B,C) collapsed to the requested tolerance.\n               The user must examine this case and decide whether\n               B is near a local minimum of F(X), or B is near a\n               zero of even multiplicity, or neither of these.\n\n            5  Too many (.GT. 500) function evaluations used. REFERENCES  L. F. Shampine and H. A. Watts, FZERO, a root-solving\n                 code, Report SC-TM-70-631, Sandia Laboratories,\n                 September 1970.\n               T. J. Dekker, Finding a zero by means of successive\n                 linear interpolation, Constructive Aspects of the\n                 Fundamental Theorem of Algebra, edited by B. Dejon\n                 and P. Henrici, Wiley-Interscience, 1969. ROUTINES CALLED  R1MACH REVISION HISTORY  (YYMMDD)\n   700901  DATE WRITTEN\n   890531  Changed all specific intrinsics to generic.  (WRB)\n   890531  REVISION DATE from Version 3.2\n   891214  Prologue converted to Version 4.0 format.  (BAB)\n   920501  Reformatted the REFERENCES section.  (WRB) END PROLOGUE  FZERO\n      USE stel_kinds\n**FIRST EXECUTABLE STATEMENT  FZERO ER is two times the computer unit roundoff value which is defined\n   here by the function EPSILON. Arguments Type Intent Optional Attributes Name real :: F real :: B real :: C real :: R real :: RE real :: AE integer :: IFLAG Contents None","tags":"","loc":"proc/fzero.html"},{"title":"safe_open â€“ stella","text":"public subroutine safe_open(iunit, istat, filename, filestat, fileform, record_in, access_in, delim_in) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: iunit integer, intent(out) :: istat character(len=*), intent(in) :: filename character(len=*), intent(in) :: filestat character(len=*), intent(in) :: fileform integer, intent(in), optional :: record_in character(len=*), intent(in), optional :: access_in character(len=*), intent(in), optional :: delim_in Contents None","tags":"","loc":"proc/safe_open.html"},{"title":"read_indata_namelist â€“ stella","text":"public subroutine read_indata_namelist(iunit, istat) Arguments Type Intent Optional Attributes Name integer :: iunit integer :: istat Contents None","tags":"","loc":"proc/read_indata_namelist.html"},{"title":"read_mse_namelist â€“ stella","text":"public subroutine read_mse_namelist(iunit, istat) Arguments Type Intent Optional Attributes Name integer :: iunit integer :: istat Contents None","tags":"","loc":"proc/read_mse_namelist.html"},{"title":"write_indata_namelist â€“ stella","text":"public subroutine write_indata_namelist(iunit, istat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iunit integer, intent(inout) :: istat Contents None","tags":"","loc":"proc/write_indata_namelist.html"},{"title":"read_mgrid â€“ stella","text":"public subroutine read_mgrid(mgrid_file, extcur, nv, nfp, lscreen, ier_flag) Uses system_mod Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: mgrid_file real(kind=rprec), intent(in) :: extcur (:) integer, intent(in) :: nv integer, intent(in) :: nfp logical, intent(in) :: lscreen integer, intent(out) :: ier_flag Contents None","tags":"","loc":"proc/read_mgrid.html"},{"title":"read_mgrid_bin â€“ stella","text":"private subroutine read_mgrid_bin(filename, extcur, nv, nfp, ier_flag, lscreen) Uses safe_open_mod Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=rprec), intent(in) :: extcur (:) integer, intent(in) :: nv integer, intent(in) :: nfp integer :: ier_flag logical :: lscreen Contents None","tags":"","loc":"proc/read_mgrid_bin.html"},{"title":"read_mgrid_nc â€“ stella","text":"private subroutine read_mgrid_nc(filename, extcur, nv, nfp, ier_flag, lscreen) Uses ezcdf Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=rprec), intent(in) :: extcur (:) integer, intent(in) :: nv integer, intent(in) :: nfp integer :: ier_flag logical :: lscreen Contents None","tags":"","loc":"proc/read_mgrid_nc.html"},{"title":"sum_bfield â€“ stella","text":"public subroutine sum_bfield(bfield, bf_add, cur, n1) Arguments Type Intent Optional Attributes Name real(kind=rprec), intent(inout) :: bfield (n1) real(kind=rprec), intent(in) :: bf_add (n1) real(kind=rprec) :: cur integer :: n1 Contents None","tags":"","loc":"proc/sum_bfield.html"},{"title":"assign_bptrs â€“ stella","text":"public subroutine assign_bptrs(bptr) Arguments Type Intent Optional Attributes Name real(kind=rprec), intent(in), TARGET :: bptr (nr0b,nz0b,np0b,3) Contents None","tags":"","loc":"proc/assign_bptrs.html"},{"title":"free_mgrid â€“ stella","text":"public subroutine free_mgrid(istat) Arguments Type Intent Optional Attributes Name integer :: istat Contents None","tags":"","loc":"proc/free_mgrid.html"},{"title":"cdfw_3i â€“ stella","text":"public subroutine cdfw_3i(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfw_3i.html"},{"title":"cdfw_3l â€“ stella","text":"public subroutine cdfw_3l(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfw_3l.html"},{"title":"cdfw_3d â€“ stella","text":"public subroutine cdfw_3d(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfw_3d.html"},{"title":"cdfw_3c16 â€“ stella","text":"public subroutine cdfw_3c16(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfw_3c16.html"},{"title":"cdfw_3f â€“ stella","text":"public subroutine cdfw_3f(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfw_3f.html"},{"title":"cdfw_3c8 â€“ stella","text":"public subroutine cdfw_3c8(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfw_3c8.html"},{"title":"cdfw_2i â€“ stella","text":"public subroutine cdfw_2i(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfw_2i.html"},{"title":"cdfw_2l â€“ stella","text":"public subroutine cdfw_2l(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfw_2l.html"},{"title":"cdfw_2d â€“ stella","text":"public subroutine cdfw_2d(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfw_2d.html"},{"title":"cdfw_2c16 â€“ stella","text":"public subroutine cdfw_2c16(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfw_2c16.html"},{"title":"cdfw_2f â€“ stella","text":"public subroutine cdfw_2f(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfw_2f.html"},{"title":"cdfw_2c8 â€“ stella","text":"public subroutine cdfw_2c8(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfw_2c8.html"},{"title":"cdfw_2c â€“ stella","text":"public subroutine cdfw_2c(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfw_2c.html"},{"title":"cdfw_1i â€“ stella","text":"public subroutine cdfw_1i(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in), dimension(:) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfw_1i.html"},{"title":"cdfw_1l â€“ stella","text":"public subroutine cdfw_1l(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in), dimension(:) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfw_1l.html"},{"title":"cdfw_1d â€“ stella","text":"public subroutine cdfw_1d(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfw_1d.html"},{"title":"cdfw_1c16 â€“ stella","text":"public subroutine cdfw_1c16(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfw_1c16.html"},{"title":"cdfw_1f â€“ stella","text":"public subroutine cdfw_1f(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfw_1f.html"},{"title":"cdfw_1c8 â€“ stella","text":"public subroutine cdfw_1c8(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfw_1c8.html"},{"title":"cdfw_1c â€“ stella","text":"public subroutine cdfw_1c(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(in) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfw_1c.html"},{"title":"cdfw_0i â€“ stella","text":"public subroutine cdfw_0i(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfw_0i.html"},{"title":"cdfw_0l â€“ stella","text":"public subroutine cdfw_0l(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfw_0l.html"},{"title":"cdfw_0d â€“ stella","text":"public subroutine cdfw_0d(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfw_0d.html"},{"title":"cdfw_0c16 â€“ stella","text":"public subroutine cdfw_0c16(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfw_0c16.html"},{"title":"cdfw_0f â€“ stella","text":"public subroutine cdfw_0f(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfw_0f.html"},{"title":"cdfw_0c8 â€“ stella","text":"public subroutine cdfw_0c8(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfw_0c8.html"},{"title":"cdfDefVar â€“ stella","text":"public subroutine cdfDefVar(ncid, varnam, dimlens, xtype, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in), dimension(:) :: dimlens character(len=*), intent(in) :: xtype integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname Contents None","tags":"","loc":"proc/cdfdefvar.html"},{"title":"cdfd_3i â€“ stella","text":"public subroutine cdfd_3i(ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname Contents None","tags":"","loc":"proc/cdfd_3i.html"},{"title":"cdfd_2i â€“ stella","text":"public subroutine cdfd_2i(ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname Contents None","tags":"","loc":"proc/cdfd_2i.html"},{"title":"cdfd_1i â€“ stella","text":"public subroutine cdfd_1i(ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in), dimension(:) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname Contents None","tags":"","loc":"proc/cdfd_1i.html"},{"title":"cdfd_0i â€“ stella","text":"public subroutine cdfd_0i(ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname Contents None","tags":"","loc":"proc/cdfd_0i.html"},{"title":"cdfd_3l â€“ stella","text":"public subroutine cdfd_3l(ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname Contents None","tags":"","loc":"proc/cdfd_3l.html"},{"title":"cdfd_2l â€“ stella","text":"public subroutine cdfd_2l(ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname Contents None","tags":"","loc":"proc/cdfd_2l.html"},{"title":"cdfd_1l â€“ stella","text":"public subroutine cdfd_1l(ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in), dimension(:) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname Contents None","tags":"","loc":"proc/cdfd_1l.html"},{"title":"cdfd_0l â€“ stella","text":"public subroutine cdfd_0l(ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname Contents None","tags":"","loc":"proc/cdfd_0l.html"},{"title":"cdfd_3d â€“ stella","text":"public subroutine cdfd_3d(ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname Contents None","tags":"","loc":"proc/cdfd_3d.html"},{"title":"cdfd_2d â€“ stella","text":"public subroutine cdfd_2d(ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname Contents None","tags":"","loc":"proc/cdfd_2d.html"},{"title":"cdfd_1d â€“ stella","text":"public subroutine cdfd_1d(ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname Contents None","tags":"","loc":"proc/cdfd_1d.html"},{"title":"cdfd_0d â€“ stella","text":"public subroutine cdfd_0d(ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname Contents None","tags":"","loc":"proc/cdfd_0d.html"},{"title":"cdfd_3f â€“ stella","text":"public subroutine cdfd_3f(ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname Contents None","tags":"","loc":"proc/cdfd_3f.html"},{"title":"cdfd_2f â€“ stella","text":"public subroutine cdfd_2f(ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname Contents None","tags":"","loc":"proc/cdfd_2f.html"},{"title":"cdfd_1f â€“ stella","text":"public subroutine cdfd_1f(ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname Contents None","tags":"","loc":"proc/cdfd_1f.html"},{"title":"cdfd_0f â€“ stella","text":"public subroutine cdfd_0f(ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname Contents None","tags":"","loc":"proc/cdfd_0f.html"},{"title":"cdfd_3c16 â€“ stella","text":"public subroutine cdfd_3c16(ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname Contents None","tags":"","loc":"proc/cdfd_3c16.html"},{"title":"cdfd_2c16 â€“ stella","text":"public subroutine cdfd_2c16(ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname Contents None","tags":"","loc":"proc/cdfd_2c16.html"},{"title":"cdfd_1c16 â€“ stella","text":"public subroutine cdfd_1c16(ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname Contents None","tags":"","loc":"proc/cdfd_1c16.html"},{"title":"cdfd_0c16 â€“ stella","text":"public subroutine cdfd_0c16(ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname Contents None","tags":"","loc":"proc/cdfd_0c16.html"},{"title":"cdfd_3c8 â€“ stella","text":"public subroutine cdfd_3c8(ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname Contents None","tags":"","loc":"proc/cdfd_3c8.html"},{"title":"cdfd_2c8 â€“ stella","text":"public subroutine cdfd_2c8(ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname Contents None","tags":"","loc":"proc/cdfd_2c8.html"},{"title":"cdfd_1c8 â€“ stella","text":"public subroutine cdfd_1c8(ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname Contents None","tags":"","loc":"proc/cdfd_1c8.html"},{"title":"cdfd_0c8 â€“ stella","text":"public subroutine cdfd_0c8(ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname Contents None","tags":"","loc":"proc/cdfd_0c8.html"},{"title":"cdfd_2c â€“ stella","text":"public subroutine cdfd_2c(ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname Contents None","tags":"","loc":"proc/cdfd_2c.html"},{"title":"cdfd_1c â€“ stella","text":"public subroutine cdfd_1c(ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(in) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname Contents None","tags":"","loc":"proc/cdfd_1c.html"},{"title":"cdf_write â€“ stella","text":"public interface cdf_write Contents Module Procedures cdfw_3i cdfw_3l cdfw_3d cdfw_3c16 cdfw_3f cdfw_3c8 cdfw_2i cdfw_2l cdfw_2d cdfw_2c16 cdfw_2f cdfw_2c8 cdfw_2c cdfw_1i cdfw_1l cdfw_1d cdfw_1c16 cdfw_1f cdfw_1c8 cdfw_1c cdfw_0i cdfw_0l cdfw_0d cdfw_0c16 cdfw_0f cdfw_0c8 Module Procedures public subroutine cdfw_3i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_3l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_3d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_3c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_3f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_3c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_2i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_2l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_2d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_2c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_2f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_2c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_2c (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfw_1i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfw_1l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfw_1d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfw_1c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfw_1f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfw_1c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfw_1c (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(in) :: varval integer, intent(out), optional :: ier public subroutine cdfw_0i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in) :: varval integer, intent(out), optional :: ier public subroutine cdfw_0l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in) :: varval integer, intent(out), optional :: ier public subroutine cdfw_0d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in) :: varval integer, intent(out), optional :: ier public subroutine cdfw_0c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in) :: varval integer, intent(out), optional :: ier public subroutine cdfw_0f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in) :: varval integer, intent(out), optional :: ier public subroutine cdfw_0c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in) :: varval integer, intent(out), optional :: ier","tags":"","loc":"interface/cdf_write.html"},{"title":"cdfPutVar â€“ stella","text":"public interface cdfPutVar Contents Module Procedures cdfw_3i cdfw_3l cdfw_3d cdfw_3c16 cdfw_3f cdfw_3c8 cdfw_2i cdfw_2l cdfw_2d cdfw_2c16 cdfw_2f cdfw_2c8 cdfw_2c cdfw_1i cdfw_1l cdfw_1d cdfw_1c16 cdfw_1f cdfw_1c8 cdfw_1c cdfw_0i cdfw_0l cdfw_0d cdfw_0c16 cdfw_0f cdfw_0c8 Module Procedures public subroutine cdfw_3i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_3l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_3d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_3c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_3f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_3c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_2i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_2l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_2d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_2c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_2f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_2c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_2c (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfw_1i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfw_1l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfw_1d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfw_1c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfw_1f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfw_1c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfw_1c (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(in) :: varval integer, intent(out), optional :: ier public subroutine cdfw_0i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in) :: varval integer, intent(out), optional :: ier public subroutine cdfw_0l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in) :: varval integer, intent(out), optional :: ier public subroutine cdfw_0d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in) :: varval integer, intent(out), optional :: ier public subroutine cdfw_0c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in) :: varval integer, intent(out), optional :: ier public subroutine cdfw_0f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in) :: varval integer, intent(out), optional :: ier public subroutine cdfw_0c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in) :: varval integer, intent(out), optional :: ier","tags":"","loc":"interface/cdfputvar.html"},{"title":"cdf_define â€“ stella","text":"public interface cdf_define Contents Module Procedures cdfDefVar cdfd_3i cdfd_3l cdfd_3d cdfd_3c16 cdfd_3f cdfd_3c8 cdfd_2i cdfd_2l cdfd_2d cdfd_2c16 cdfd_2f cdfd_2c8 cdfd_2c cdfd_1i cdfd_1l cdfd_1d cdfd_1c16 cdfd_1f cdfd_1c8 cdfd_1c cdfd_0i cdfd_0l cdfd_0d cdfd_0c16 cdfd_0f cdfd_0c8 Module Procedures public subroutine cdfDefVar (ncid, varnam, dimlens, xtype, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in), dimension(:) :: dimlens character(len=*), intent(in) :: xtype integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_3i (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_3l (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_3d (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_3c16 (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_3f (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_3c8 (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_2i (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_2l (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_2d (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_2c16 (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_2f (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_2c8 (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_2c (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_1i (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in), dimension(:) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_1l (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in), dimension(:) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_1d (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_1c16 (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_1f (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_1c8 (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_1c (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(in) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_0i (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_0l (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_0d (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_0c16 (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_0f (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_0c8 (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname","tags":"","loc":"interface/cdf_define.html"},{"title":"cdfSetatt â€“ stella","text":"public subroutine cdfSetatt(ncid, varnam, long_name, units, ier, varid) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(in), optional :: long_name character(len=*), intent(in), optional :: units integer, intent(out), optional :: ier integer, intent(out), optional :: varid Contents None","tags":"","loc":"proc/cdfsetatt.html"},{"title":"cdf_SetTitle â€“ stella","text":"public subroutine cdf_SetTitle(ncid, title, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: title integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdf_settitle.html"},{"title":"cdfsa_i â€“ stella","text":"public subroutine cdfsa_i(ncid, varnam, valid_range, long_name, units, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in), dimension(2) :: valid_range character(len=*), intent(in), optional :: long_name character(len=*), intent(in), optional :: units integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfsa_i.html"},{"title":"cdfsa_f â€“ stella","text":"public subroutine cdfsa_f(ncid, varnam, valid_range, long_name, units, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in), dimension(2) :: valid_range character(len=*), intent(in), optional :: long_name character(len=*), intent(in), optional :: units integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfsa_f.html"},{"title":"cdfsa_d â€“ stella","text":"public subroutine cdfsa_d(ncid, varnam, valid_range, long_name, units, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in), dimension(2) :: valid_range character(len=*), intent(in), optional :: long_name character(len=*), intent(in), optional :: units integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfsa_d.html"},{"title":"cdfGetatt â€“ stella","text":"public subroutine cdfGetatt(ncid, varnam, long_name, units, ier, varid) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(out), optional :: long_name character(len=*), intent(out), optional :: units integer, intent(out), optional :: ier integer, intent(out), optional :: varid Contents None","tags":"","loc":"proc/cdfgetatt.html"},{"title":"cdf_GetTitle â€“ stella","text":"public subroutine cdf_GetTitle(ncid, title, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(out) :: title integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdf_gettitle.html"},{"title":"cdfga_i â€“ stella","text":"public subroutine cdfga_i(ncid, varnam, valid_range, long_name, units, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(out), dimension(2) :: valid_range character(len=*), intent(out), optional :: long_name character(len=*), intent(out), optional :: units integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfga_i.html"},{"title":"cdfga_f â€“ stella","text":"public subroutine cdfga_f(ncid, varnam, valid_range, long_name, units, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(out), dimension(2) :: valid_range character(len=*), intent(out), optional :: long_name character(len=*), intent(out), optional :: units integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfga_f.html"},{"title":"cdfga_d â€“ stella","text":"public subroutine cdfga_d(ncid, varnam, valid_range, long_name, units, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(out), dimension(2) :: valid_range character(len=*), intent(out), optional :: long_name character(len=*), intent(out), optional :: units integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfga_d.html"},{"title":"cdf_setatt â€“ stella","text":"public interface cdf_setatt Contents Module Procedures cdfSetatt cdfsa_i cdfsa_d cdfsa_f Module Procedures public subroutine cdfSetatt (ncid, varnam, long_name, units, ier, varid) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(in), optional :: long_name character(len=*), intent(in), optional :: units integer, intent(out), optional :: ier integer, intent(out), optional :: varid public subroutine cdfsa_i (ncid, varnam, valid_range, long_name, units, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in), dimension(2) :: valid_range character(len=*), intent(in), optional :: long_name character(len=*), intent(in), optional :: units integer, intent(out), optional :: ier public subroutine cdfsa_d (ncid, varnam, valid_range, long_name, units, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in), dimension(2) :: valid_range character(len=*), intent(in), optional :: long_name character(len=*), intent(in), optional :: units integer, intent(out), optional :: ier public subroutine cdfsa_f (ncid, varnam, valid_range, long_name, units, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in), dimension(2) :: valid_range character(len=*), intent(in), optional :: long_name character(len=*), intent(in), optional :: units integer, intent(out), optional :: ier","tags":"","loc":"interface/cdf_setatt.html"},{"title":"cdf_getatt â€“ stella","text":"public interface cdf_getatt Contents Module Procedures cdfGetatt cdfga_i cdfga_d cdfga_f Module Procedures public subroutine cdfGetatt (ncid, varnam, long_name, units, ier, varid) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(out), optional :: long_name character(len=*), intent(out), optional :: units integer, intent(out), optional :: ier integer, intent(out), optional :: varid public subroutine cdfga_i (ncid, varnam, valid_range, long_name, units, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(out), dimension(2) :: valid_range character(len=*), intent(out), optional :: long_name character(len=*), intent(out), optional :: units integer, intent(out), optional :: ier public subroutine cdfga_d (ncid, varnam, valid_range, long_name, units, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(out), dimension(2) :: valid_range character(len=*), intent(out), optional :: long_name character(len=*), intent(out), optional :: units integer, intent(out), optional :: ier public subroutine cdfga_f (ncid, varnam, valid_range, long_name, units, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(out), dimension(2) :: valid_range character(len=*), intent(out), optional :: long_name character(len=*), intent(out), optional :: units integer, intent(out), optional :: ier","tags":"","loc":"interface/cdf_getatt.html"},{"title":"readw_and_open â€“ stella","text":"public subroutine readw_and_open(file_or_extension, ierr, iopen) Uses safe_open_mod Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_or_extension integer, intent(out) :: ierr integer, optional :: iopen Contents None","tags":"","loc":"proc/readw_and_open.html"},{"title":"readw_only â€“ stella","text":"public subroutine readw_only(iunit, ierr, iopen) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iunit integer, intent(out) :: ierr integer, optional :: iopen Contents None","tags":"","loc":"proc/readw_only.html"},{"title":"read_wout_text â€“ stella","text":"private subroutine read_wout_text(iunit, ierr) Uses stel_constants Arguments Type Intent Optional Attributes Name integer :: iunit integer :: ierr Contents None","tags":"","loc":"proc/read_wout_text.html"},{"title":"read_wout_nc â€“ stella","text":"private subroutine read_wout_nc(filename, ierr) Uses ezcdf stel_constants Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer, intent(out) :: ierr Contents None","tags":"","loc":"proc/read_wout_nc.html"},{"title":"write_wout_text â€“ stella","text":"public subroutine write_wout_text(filename, ierr) Uses safe_open_mod vsvd0 v3_utilities stel_constants Arguments Type Intent Optional Attributes Name character(len=*) :: filename integer, intent(out) :: ierr Contents None","tags":"","loc":"proc/write_wout_text.html"},{"title":"Compute_Currents â€“ stella","text":"public subroutine Compute_Currents(ierror) Uses stel_constants Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierror Contents None","tags":"","loc":"proc/compute_currents.html"},{"title":"read_wout_deallocate â€“ stella","text":"public subroutine read_wout_deallocate() Arguments None Contents None","tags":"","loc":"proc/read_wout_deallocate.html"},{"title":"tosuvspace â€“ stella","text":"public subroutine tosuvspace(s_in, u_in, v_in, gsqrt, bsupu, bsupv, jsupu, jsupv, lam) Uses stel_constants Arguments Type Intent Optional Attributes Name real(kind=rprec), intent(in) :: s_in real(kind=rprec), intent(in) :: u_in real(kind=rprec), intent(in) :: v_in real(kind=rprec), intent(out), optional :: gsqrt real(kind=rprec), intent(out), optional :: bsupu real(kind=rprec), intent(out), optional :: bsupv real(kind=rprec), intent(out), optional :: jsupu real(kind=rprec), intent(out), optional :: jsupv real(kind=rprec), intent(out), optional :: lam Contents None","tags":"","loc":"proc/tosuvspace.html"},{"title":"LoadRZL â€“ stella","text":"public subroutine LoadRZL() Arguments None Contents None","tags":"","loc":"proc/loadrzl.html"},{"title":"read_wout_file â€“ stella","text":"public interface read_wout_file Contents Module Procedures readw_and_open readw_only Module Procedures public subroutine readw_and_open (file_or_extension, ierr, iopen) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_or_extension integer, intent(out) :: ierr integer, optional :: iopen public subroutine readw_only (iunit, ierr, iopen) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iunit integer, intent(out) :: ierr integer, optional :: iopen","tags":"","loc":"interface/read_wout_file.html"},{"title":"system â€“ stella","text":"public interface system Contents Subroutines vmec_system Subroutines public subroutine vmec_system(cmd, error) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cmd integer, optional :: error","tags":"","loc":"interface/system.html"},{"title":"chdir â€“ stella","text":"public interface chdir Contents Functions vmec_chdir Functions public function vmec_chdir(path) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path Return Value integer","tags":"","loc":"interface/chdir.html"},{"title":"getenv â€“ stella","text":"public interface getenv Contents Subroutines vmec_getenv Subroutines public subroutine vmec_getenv(ename, evalue) Arguments Type Intent Optional Attributes Name character(len=*) :: ename character(len=*) :: evalue","tags":"","loc":"interface/getenv.html"},{"title":"putenv â€“ stella","text":"public interface putenv Contents Subroutines vmec_putenv Subroutines public subroutine vmec_putenv(ename, evalue, ierror) Arguments Type Intent Optional Attributes Name character(len=*) :: ename character(len=*) :: evalue integer :: ierror","tags":"","loc":"interface/putenv.html"},{"title":"PXFFORK â€“ stella","text":"public interface PXFFORK Contents Subroutines pxffork_g Subroutines public subroutine pxffork_g(ipid, ierror) Arguments Type Intent Optional Attributes Name integer :: ipid integer :: ierror","tags":"","loc":"interface/pxffork.html"},{"title":"getpid â€“ stella","text":"public interface getpid Contents Subroutines vmec_getpid Subroutines public subroutine vmec_getpid(ipid, ierror) Arguments Type Intent Optional Attributes Name integer :: ipid integer :: ierror","tags":"","loc":"interface/getpid.html"},{"title":"PXFWAIT â€“ stella","text":"public interface PXFWAIT Contents Subroutines pxfwait_g Subroutines public subroutine pxfwait_g(istat, iretpid, ierror) Arguments Type Intent Optional Attributes Name integer :: istat integer :: iretpid integer :: ierror","tags":"","loc":"interface/pxfwait.html"},{"title":"cdfr_3i â€“ stella","text":"public subroutine cdfr_3i(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfr_3i.html"},{"title":"cdfr_3l â€“ stella","text":"public subroutine cdfr_3l(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfr_3l.html"},{"title":"cdfr_3d â€“ stella","text":"public subroutine cdfr_3d(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfr_3d.html"},{"title":"cdfr_3c16 â€“ stella","text":"public subroutine cdfr_3c16(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfr_3c16.html"},{"title":"cdfr_3f â€“ stella","text":"public subroutine cdfr_3f(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfr_3f.html"},{"title":"cdfr_3c8 â€“ stella","text":"public subroutine cdfr_3c8(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfr_3c8.html"},{"title":"cdfr_2i â€“ stella","text":"public subroutine cdfr_2i(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfr_2i.html"},{"title":"cdfr_2l â€“ stella","text":"public subroutine cdfr_2l(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfr_2l.html"},{"title":"cdfr_2d â€“ stella","text":"public subroutine cdfr_2d(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfr_2d.html"},{"title":"cdfr_2c16 â€“ stella","text":"public subroutine cdfr_2c16(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfr_2c16.html"},{"title":"cdfr_2f â€“ stella","text":"public subroutine cdfr_2f(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfr_2f.html"},{"title":"cdfr_2c8 â€“ stella","text":"public subroutine cdfr_2c8(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfr_2c8.html"},{"title":"cdfr_2c â€“ stella","text":"public subroutine cdfr_2c(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfr_2c.html"},{"title":"cdfr_1i â€“ stella","text":"public subroutine cdfr_1i(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfr_1i.html"},{"title":"cdfr_1l â€“ stella","text":"public subroutine cdfr_1l(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfr_1l.html"},{"title":"cdfr_1d â€“ stella","text":"public subroutine cdfr_1d(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfr_1d.html"},{"title":"cdfr_1c16 â€“ stella","text":"public subroutine cdfr_1c16(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfr_1c16.html"},{"title":"cdfr_1f â€“ stella","text":"public subroutine cdfr_1f(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfr_1f.html"},{"title":"cdfr_1c8 â€“ stella","text":"public subroutine cdfr_1c8(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfr_1c8.html"},{"title":"cdfr_1c â€“ stella","text":"public subroutine cdfr_1c(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(inout) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfr_1c.html"},{"title":"cdfr_0i â€“ stella","text":"public subroutine cdfr_0i(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(out) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfr_0i.html"},{"title":"cdfr_0l â€“ stella","text":"public subroutine cdfr_0l(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(out) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfr_0l.html"},{"title":"cdfr_0d â€“ stella","text":"public subroutine cdfr_0d(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(out) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfr_0d.html"},{"title":"cdfr_0c16 â€“ stella","text":"public subroutine cdfr_0c16(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(out) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfr_0c16.html"},{"title":"cdfr_0f â€“ stella","text":"public subroutine cdfr_0f(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(out) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfr_0f.html"},{"title":"cdfr_0c8 â€“ stella","text":"public subroutine cdfr_0c8(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(out) :: varval integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfr_0c8.html"},{"title":"cdf_read â€“ stella","text":"public interface cdf_read Contents Module Procedures cdfr_3i cdfr_3l cdfr_3d cdfr_3c16 cdfr_3f cdfr_3c8 cdfr_2i cdfr_2l cdfr_2d cdfr_2c16 cdfr_2f cdfr_2c8 cdfr_2c cdfr_1i cdfr_1l cdfr_1d cdfr_1c16 cdfr_1f cdfr_1c8 cdfr_1c cdfr_0i cdfr_0l cdfr_0d cdfr_0c16 cdfr_0f cdfr_0c8 Module Procedures public subroutine cdfr_3i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_3l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_3d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_3c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_3f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_3c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_2i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_2l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_2d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_2c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_2f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_2c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_2c (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfr_1i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfr_1l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfr_1d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfr_1c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfr_1f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfr_1c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfr_1c (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(inout) :: varval integer, intent(out), optional :: ier public subroutine cdfr_0i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(out) :: varval integer, intent(out), optional :: ier public subroutine cdfr_0l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(out) :: varval integer, intent(out), optional :: ier public subroutine cdfr_0d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(out) :: varval integer, intent(out), optional :: ier public subroutine cdfr_0c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(out) :: varval integer, intent(out), optional :: ier public subroutine cdfr_0f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(out) :: varval integer, intent(out), optional :: ier public subroutine cdfr_0c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(out) :: varval integer, intent(out), optional :: ier","tags":"","loc":"interface/cdf_read.html"},{"title":"cdfGetVar â€“ stella","text":"public interface cdfGetVar Contents Module Procedures cdfr_3i cdfr_3l cdfr_3d cdfr_3c16 cdfr_3f cdfr_3c8 cdfr_2i cdfr_2l cdfr_2d cdfr_2c16 cdfr_2f cdfr_2c8 cdfr_2c cdfr_1i cdfr_1l cdfr_1d cdfr_1c16 cdfr_1f cdfr_1c8 cdfr_1c cdfr_0i cdfr_0l cdfr_0d cdfr_0c16 cdfr_0f cdfr_0c8 Module Procedures public subroutine cdfr_3i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_3l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_3d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_3c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_3f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_3c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_2i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_2l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_2d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_2c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_2f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_2c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_2c (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfr_1i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfr_1l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfr_1d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfr_1c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfr_1f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfr_1c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfr_1c (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(inout) :: varval integer, intent(out), optional :: ier public subroutine cdfr_0i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(out) :: varval integer, intent(out), optional :: ier public subroutine cdfr_0l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(out) :: varval integer, intent(out), optional :: ier public subroutine cdfr_0d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(out) :: varval integer, intent(out), optional :: ier public subroutine cdfr_0c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(out) :: varval integer, intent(out), optional :: ier public subroutine cdfr_0f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(out) :: varval integer, intent(out), optional :: ier public subroutine cdfr_0c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(out) :: varval integer, intent(out), optional :: ier","tags":"","loc":"interface/cdfgetvar.html"},{"title":"cdfInqVar â€“ stella","text":"public subroutine cdfInqVar(ncid, varnam, dimlens, eztype, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(out), dimension(:) :: dimlens character(len=*), intent(out) :: eztype integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdfinqvar.html"},{"title":"cdfgv â€“ stella","text":"public subroutine cdfgv(ncid, varnam, varid, dimlens, sizes, xtype, status) Arguments Type Intent Optional Attributes Name integer :: ncid character(len=*) :: varnam integer :: varid integer, dimension(:) :: dimlens integer, dimension(:) :: sizes character(len=1) :: xtype integer :: status Contents None","tags":"","loc":"proc/cdfgv.html"},{"title":"cdfInqV â€“ stella","text":"public subroutine cdfInqV(ncid, varnam, varid, dimlens, ndims, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(out) :: varid integer, intent(out), dimension(:) :: dimlens integer, intent(out) :: ndims integer, intent(out) :: status Contents None","tags":"","loc":"proc/cdfinqv.html"},{"title":"cdf_inquire â€“ stella","text":"public subroutine cdf_inquire(ncid, varnam, dimlens, xtype, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(out), dimension(:) :: dimlens character(len=*), intent(out), optional :: xtype integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/cdf_inquire.html"},{"title":"alpha_numeric â€“ stella","text":"public subroutine alpha_numeric(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: string Contents None","tags":"","loc":"proc/alpha_numeric.html"},{"title":"cdfInqVarDim â€“ stella","text":"public interface cdfInqVarDim Contents Module Procedures cdfInqV cdfgv cdf_inquire Module Procedures public subroutine cdfInqV (ncid, varnam, varid, dimlens, ndims, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(out) :: varid integer, intent(out), dimension(:) :: dimlens integer, intent(out) :: ndims integer, intent(out) :: status public subroutine cdfgv (ncid, varnam, varid, dimlens, sizes, xtype, status) Arguments Type Intent Optional Attributes Name integer :: ncid character(len=*) :: varnam integer :: varid integer, dimension(:) :: dimlens integer, dimension(:) :: sizes character(len=1) :: xtype integer :: status public subroutine cdf_inquire (ncid, varnam, dimlens, xtype, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(out), dimension(:) :: dimlens character(len=*), intent(out), optional :: xtype integer, intent(out), optional :: ier","tags":"","loc":"interface/cdfinqvardim.html"},{"title":"assert1 â€“ stella","text":"public subroutine assert1(n1, string, err_class) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n1 character(len=*), intent(in) :: string character(len=*), intent(in), optional :: err_class Contents None","tags":"","loc":"proc/assert1.html"},{"title":"assert2 â€“ stella","text":"public subroutine assert2(n1, n2, string, err_class) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n1 logical, intent(in) :: n2 character(len=*), intent(in) :: string character(len=*), intent(in), optional :: err_class Contents None","tags":"","loc":"proc/assert2.html"},{"title":"assert3 â€“ stella","text":"public subroutine assert3(n1, n2, n3, string, err_class) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n1 logical, intent(in) :: n2 logical, intent(in) :: n3 character(len=*), intent(in) :: string character(len=*), intent(in), optional :: err_class Contents None","tags":"","loc":"proc/assert3.html"},{"title":"assert4 â€“ stella","text":"public subroutine assert4(n1, n2, n3, n4, string, err_class) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n1 logical, intent(in) :: n2 logical, intent(in) :: n3 logical, intent(in) :: n4 character(len=*), intent(in) :: string character(len=*), intent(in), optional :: err_class Contents None","tags":"","loc":"proc/assert4.html"},{"title":"assert_v â€“ stella","text":"public subroutine assert_v(n, string, err_class) Arguments Type Intent Optional Attributes Name logical, intent(in), DIMENSION(:) :: n character(len=*), intent(in) :: string character(len=*), intent(in), optional :: err_class Contents None","tags":"","loc":"proc/assert_v.html"},{"title":"assert_eq2 â€“ stella","text":"public subroutine assert_eq2(n1, n2, string, err_class) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 character(len=*), intent(in) :: string character(len=*), intent(in), optional :: err_class Contents None","tags":"","loc":"proc/assert_eq2.html"},{"title":"assert_eq3 â€“ stella","text":"public subroutine assert_eq3(n1, n2, n3, string, err_class) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 character(len=*), intent(in) :: string character(len=*), intent(in), optional :: err_class Contents None","tags":"","loc":"proc/assert_eq3.html"},{"title":"assert_eq4 â€“ stella","text":"public subroutine assert_eq4(n1, n2, n3, n4, string, err_class) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: n4 character(len=*), intent(in) :: string character(len=*), intent(in), optional :: err_class Contents None","tags":"","loc":"proc/assert_eq4.html"},{"title":"assert_eqn â€“ stella","text":"public subroutine assert_eqn(nn, string, err_class) Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:) :: nn character(len=*), intent(in) :: string character(len=*), intent(in), optional :: err_class Contents None","tags":"","loc":"proc/assert_eqn.html"},{"title":"err_fatal â€“ stella","text":"public subroutine err_fatal(string, char, real1, int, log) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in), optional :: char real(kind=rprec), intent(in), optional :: real1 integer, intent(in), optional :: int logical, intent(in), optional :: log Contents None","tags":"","loc":"proc/err_fatal.html"},{"title":"err_warn â€“ stella","text":"public subroutine err_warn(string, char, real, int, log) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in), optional :: char real(kind=rprec), intent(in), optional :: real integer, intent(in), optional :: int logical, intent(in), optional :: log Contents None","tags":"","loc":"proc/err_warn.html"},{"title":"svdproducts â€“ stella","text":"public subroutine svdproducts(b, svprod, numzeros) Uses stel_kinds Arguments Type Intent Optional Attributes Name real(kind=rprec), intent(inout), DIMENSION(:,:) :: b real(kind=rprec), intent(inout), DIMENSION(:) :: svprod integer, intent(inout), DIMENSION(:) :: numzeros Contents None","tags":"","loc":"proc/svdproducts.html"},{"title":"most_redundant â€“ stella","text":"public subroutine most_redundant(a, ncol_array, svprod_array, j_col_elim) Uses stel_kinds Arguments Type Intent Optional Attributes Name real(kind=rprec), intent(inout), DIMENSION(:,:) :: a integer, intent(inout), DIMENSION(:) :: ncol_array real(kind=rprec), intent(inout), DIMENSION(:) :: svprod_array integer, intent(inout), DIMENSION(:) :: j_col_elim Contents None","tags":"","loc":"proc/most_redundant.html"},{"title":"assert â€“ stella","text":"public interface assert Contents Module Procedures assert1 assert2 assert3 assert4 assert_v Module Procedures public subroutine assert1 (n1, string, err_class) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n1 character(len=*), intent(in) :: string character(len=*), intent(in), optional :: err_class public subroutine assert2 (n1, n2, string, err_class) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n1 logical, intent(in) :: n2 character(len=*), intent(in) :: string character(len=*), intent(in), optional :: err_class public subroutine assert3 (n1, n2, n3, string, err_class) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n1 logical, intent(in) :: n2 logical, intent(in) :: n3 character(len=*), intent(in) :: string character(len=*), intent(in), optional :: err_class public subroutine assert4 (n1, n2, n3, n4, string, err_class) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n1 logical, intent(in) :: n2 logical, intent(in) :: n3 logical, intent(in) :: n4 character(len=*), intent(in) :: string character(len=*), intent(in), optional :: err_class public subroutine assert_v (n, string, err_class) Arguments Type Intent Optional Attributes Name logical, intent(in), DIMENSION(:) :: n character(len=*), intent(in) :: string character(len=*), intent(in), optional :: err_class","tags":"","loc":"interface/assert.html"},{"title":"assert_eq â€“ stella","text":"public interface assert_eq Contents Module Procedures assert_eq2 assert_eq3 assert_eq4 assert_eqn Module Procedures public subroutine assert_eq2 (n1, n2, string, err_class) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 character(len=*), intent(in) :: string character(len=*), intent(in), optional :: err_class public subroutine assert_eq3 (n1, n2, n3, string, err_class) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 character(len=*), intent(in) :: string character(len=*), intent(in), optional :: err_class public subroutine assert_eq4 (n1, n2, n3, n4, string, err_class) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: n4 character(len=*), intent(in) :: string character(len=*), intent(in), optional :: err_class public subroutine assert_eqn (nn, string, err_class) Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:) :: nn character(len=*), intent(in) :: string character(len=*), intent(in), optional :: err_class","tags":"","loc":"interface/assert_eq.html"},{"title":"ezcdf_open â€“ stella","text":"public subroutine ezcdf_open(ncid, filename, opt, ier) Arguments Type Intent Optional Attributes Name integer, intent(out) :: ncid character(len=*), intent(in) :: filename character(len=1), intent(in) :: opt integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/ezcdf_open.html"},{"title":"ezcdf_close â€“ stella","text":"public subroutine ezcdf_close(ncid, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(out), optional :: ier Contents None","tags":"","loc":"proc/ezcdf_close.html"},{"title":"cdfOpn â€“ stella","text":"public interface cdfOpn Contents Module Procedures ezcdf_open Module Procedures public subroutine ezcdf_open (ncid, filename, opt, ier) Arguments Type Intent Optional Attributes Name integer, intent(out) :: ncid character(len=*), intent(in) :: filename character(len=1), intent(in) :: opt integer, intent(out), optional :: ier","tags":"","loc":"interface/cdfopn.html"},{"title":"cdf_open â€“ stella","text":"public interface cdf_open Contents Module Procedures ezcdf_open Module Procedures public subroutine ezcdf_open (ncid, filename, opt, ier) Arguments Type Intent Optional Attributes Name integer, intent(out) :: ncid character(len=*), intent(in) :: filename character(len=1), intent(in) :: opt integer, intent(out), optional :: ier","tags":"","loc":"interface/cdf_open.html"},{"title":"cdfCls â€“ stella","text":"public interface cdfCls Contents Module Procedures ezcdf_close Module Procedures public subroutine ezcdf_close (ncid, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(out), optional :: ier","tags":"","loc":"interface/cdfcls.html"},{"title":"cdf_close â€“ stella","text":"public interface cdf_close Contents Module Procedures ezcdf_close Module Procedures public subroutine ezcdf_close (ncid, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(out), optional :: ier","tags":"","loc":"interface/cdf_close.html"},{"title":"time_average â€“ stella","text":"subroutine time_average(t, it, flx, flxavg) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: t integer, intent(in) :: it real, intent(in), dimension(:, :) :: flx real, intent(out), dimension(:) :: flxavg Contents None","tags":"","loc":"proc/time_average.html"},{"title":"get_git_version â€“ stella","text":"interface public module module function get_git_version() Implementation â†’ Arguments None Return Value character,\n  allocatable Description Returns the git version from git describe This looks like: {tag}-g{hash}[-dirty]","tags":"","loc":"interface/get_git_version.html"},{"title":"get_git_hash â€“ stella","text":"interface public module module function get_git_hash(length_in) Implementation â†’ Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: length_in Return Value character,\n  allocatable Description Returns the git hash of the current commit","tags":"","loc":"interface/get_git_hash.html"},{"title":"get_git_state â€“ stella","text":"interface public module module function get_git_state() Implementation â†’ Arguments None Return Value character,\n  allocatable Description Return \"-dirty\" if the repository has modifications to tracked\nfiles, or the empty string otherwise","tags":"","loc":"interface/get_git_state.html"},{"title":"get_git_date â€“ stella","text":"interface public module module function get_git_date() Implementation â†’ Arguments None Return Value character(len=10) Description Returns the short date (YYYY-MM-DD) of the current commit","tags":"","loc":"interface/get_git_date.html"},{"title":"get_netcdf_code_precision â€“ stella","text":"public function get_netcdf_code_precision() result(code_real) Uses file_utils constants Arguments None Return Value integer Contents None","tags":"","loc":"proc/get_netcdf_code_precision.html"},{"title":"check_netcdf_file_precision â€“ stella","text":"public subroutine check_netcdf_file_precision(ncid, filename) Uses file_utils Arguments Type Intent Optional Attributes Name integer(kind=kind_nf), intent(in), optional :: ncid character, intent(in), optional :: filename Contents None","tags":"","loc":"proc/check_netcdf_file_precision.html"},{"title":"netcdf_error â€“ stella","text":"public subroutine netcdf_error(istatus, ncid, varid, dimid, file, dim, var, att, message, abort) Uses mp file_utils Arguments Type Intent Optional Attributes Name integer(kind=kind_nf), intent(in) :: istatus integer(kind=kind_nf), intent(in), optional :: ncid integer(kind=kind_nf), intent(in), optional :: varid integer(kind=kind_nf), intent(in), optional :: dimid character, intent(in), optional :: file character, intent(in), optional :: dim character, intent(in), optional :: var character, intent(in), optional :: att character, intent(in), optional :: message logical, intent(in), optional :: abort Contents None","tags":"","loc":"proc/netcdf_error.html"},{"title":"imaxloc â€“ stella","text":"public function imaxloc(array) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: array Return Value integer Contents None","tags":"","loc":"proc/imaxloc.html"},{"title":"lu_decomposition_real â€“ stella","text":"public subroutine lu_decomposition_real(lu, idx, d) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :) :: lu integer, intent(out), dimension(:) :: idx real, intent(out) :: d Contents None","tags":"","loc":"proc/lu_decomposition_real.html"},{"title":"lu_decomposition_complex â€“ stella","text":"public subroutine lu_decomposition_complex(lu, idx, d) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: lu integer, intent(out), dimension(:) :: idx real, intent(out) :: d Contents None","tags":"","loc":"proc/lu_decomposition_complex.html"},{"title":"lu_back_substitution_real â€“ stella","text":"public subroutine lu_back_substitution_real(lu, idx, b) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx real, intent(inout), dimension(:) :: b Contents None","tags":"","loc":"proc/lu_back_substitution_real.html"},{"title":"lu_back_substitution_real_complex â€“ stella","text":"public subroutine lu_back_substitution_real_complex(lu, idx, b) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx complex, intent(inout), dimension(:) :: b Contents None","tags":"","loc":"proc/lu_back_substitution_real_complex.html"},{"title":"lu_back_substitution_complex â€“ stella","text":"public subroutine lu_back_substitution_complex(lu, idx, b) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx complex, intent(inout), dimension(:) :: b Contents None","tags":"","loc":"proc/lu_back_substitution_complex.html"},{"title":"lu_back_substitution_matrix_real â€“ stella","text":"public subroutine lu_back_substitution_matrix_real(lu, idx, b) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx real, intent(inout), dimension(:, :) :: b Contents None","tags":"","loc":"proc/lu_back_substitution_matrix_real.html"},{"title":"lu_back_substitution_matrix_complex â€“ stella","text":"public subroutine lu_back_substitution_matrix_complex(lu, idx, b) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx complex, intent(inout), dimension(:, :) :: b Contents None","tags":"","loc":"proc/lu_back_substitution_matrix_complex.html"},{"title":"lu_inverse_real â€“ stella","text":"public subroutine lu_inverse_real(lu, idx, inverse) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx real, intent(out), dimension(:, :) :: inverse Contents None","tags":"","loc":"proc/lu_inverse_real.html"},{"title":"lu_inverse_complex â€“ stella","text":"public subroutine lu_inverse_complex(lu, idx, inverse) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx complex, intent(out), dimension(:, :) :: inverse Contents None","tags":"","loc":"proc/lu_inverse_complex.html"},{"title":"lu_decomposition â€“ stella","text":"public interface lu_decomposition Contents Module Procedures lu_decomposition_real lu_decomposition_complex Module Procedures public subroutine lu_decomposition_real (lu, idx, d) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :) :: lu integer, intent(out), dimension(:) :: idx real, intent(out) :: d public subroutine lu_decomposition_complex (lu, idx, d) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: lu integer, intent(out), dimension(:) :: idx real, intent(out) :: d","tags":"","loc":"interface/lu_decomposition.html"},{"title":"lu_back_substitution â€“ stella","text":"public interface lu_back_substitution Contents Module Procedures lu_back_substitution_real lu_back_substitution_real_complex lu_back_substitution_complex lu_back_substitution_matrix_real lu_back_substitution_matrix_complex Module Procedures public subroutine lu_back_substitution_real (lu, idx, b) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx real, intent(inout), dimension(:) :: b public subroutine lu_back_substitution_real_complex (lu, idx, b) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx complex, intent(inout), dimension(:) :: b public subroutine lu_back_substitution_complex (lu, idx, b) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx complex, intent(inout), dimension(:) :: b public subroutine lu_back_substitution_matrix_real (lu, idx, b) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx real, intent(inout), dimension(:, :) :: b public subroutine lu_back_substitution_matrix_complex (lu, idx, b) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx complex, intent(inout), dimension(:, :) :: b","tags":"","loc":"interface/lu_back_substitution.html"},{"title":"lu_inverse â€“ stella","text":"public interface lu_inverse Contents Module Procedures lu_inverse_real lu_inverse_complex Module Procedures public subroutine lu_inverse_real (lu, idx, inverse) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx real, intent(out), dimension(:, :) :: inverse public subroutine lu_inverse_complex (lu, idx, inverse) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx complex, intent(out), dimension(:, :) :: inverse","tags":"","loc":"interface/lu_inverse.html"},{"title":"input_unit â€“ stella","text":"public function input_unit(nml) Arguments Type Intent Optional Attributes Name character, intent(in) :: nml Return Value integer Contents None","tags":"","loc":"proc/input_unit.html"},{"title":"input_unit_exist â€“ stella","text":"public function input_unit_exist(nml, exist) Arguments Type Intent Optional Attributes Name character, intent(in) :: nml logical, intent(out) :: exist Return Value integer Contents None","tags":"","loc":"proc/input_unit_exist.html"},{"title":"error_unit â€“ stella","text":"public function error_unit() Arguments None Return Value integer Contents None","tags":"","loc":"proc/error_unit.html"},{"title":"init_file_utils â€“ stella","text":"public subroutine init_file_utils(list, input, error, trin_run, name, n_ensembles) Arguments Type Intent Optional Attributes Name logical, intent(out) :: list logical, intent(in), optional :: input logical, intent(in), optional :: error logical, intent(in), optional :: trin_run character, intent(in), optional :: name integer, intent(in), optional :: n_ensembles Contents None","tags":"","loc":"proc/init_file_utils.html"},{"title":"run_type â€“ stella","text":"private subroutine run_type(list) Uses command_line Arguments Type Intent Optional Attributes Name logical, intent(out) :: list Contents None","tags":"","loc":"proc/run_type.html"},{"title":"init_run_name â€“ stella","text":"private subroutine init_run_name() Arguments None Contents None","tags":"","loc":"proc/init_run_name.html"},{"title":"init_job_name â€“ stella","text":"public subroutine init_job_name(jobname) Arguments Type Intent Optional Attributes Name character(len=500), intent(in) :: jobname Contents None","tags":"","loc":"proc/init_job_name.html"},{"title":"get_unused_unit â€“ stella","text":"public subroutine get_unused_unit(unit) Arguments Type Intent Optional Attributes Name integer, intent(out) :: unit Contents None","tags":"","loc":"proc/get_unused_unit.html"},{"title":"open_output_file â€“ stella","text":"public subroutine open_output_file(unit, ext, overwrite_in) Arguments Type Intent Optional Attributes Name integer, intent(out) :: unit character, intent(in) :: ext logical, intent(in), optional :: overwrite_in Contents None","tags":"","loc":"proc/open_output_file.html"},{"title":"close_output_file â€“ stella","text":"public subroutine close_output_file(unit) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Contents None","tags":"","loc":"proc/close_output_file.html"},{"title":"flush_output_file â€“ stella","text":"public subroutine flush_output_file(unit) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Contents None","tags":"","loc":"proc/flush_output_file.html"},{"title":"init_error_unit â€“ stella","text":"public subroutine init_error_unit(open_it) Arguments Type Intent Optional Attributes Name logical, intent(in) :: open_it Contents None","tags":"","loc":"proc/init_error_unit.html"},{"title":"strip_comments â€“ stella","text":"private subroutine strip_comments(line) Arguments Type Intent Optional Attributes Name character, intent(inout) :: line Contents None","tags":"","loc":"proc/strip_comments.html"},{"title":"init_input_unit â€“ stella","text":"public subroutine init_input_unit(open_it) Arguments Type Intent Optional Attributes Name logical, intent(in) :: open_it Contents None","tags":"","loc":"proc/init_input_unit.html"},{"title":"finish_file_utils â€“ stella","text":"public subroutine finish_file_utils() Arguments None Contents None","tags":"","loc":"proc/finish_file_utils.html"},{"title":"get_input_unit â€“ stella","text":"public subroutine get_input_unit(unit) Arguments Type Intent Optional Attributes Name integer, intent(out) :: unit Contents None","tags":"","loc":"proc/get_input_unit.html"},{"title":"get_indexed_namelist_unit â€“ stella","text":"public subroutine get_indexed_namelist_unit(unit, nml, index_in) Arguments Type Intent Optional Attributes Name integer, intent(out) :: unit character, intent(in) :: nml integer, intent(in) :: index_in Contents None","tags":"","loc":"proc/get_indexed_namelist_unit.html"},{"title":"init_ccfftw â€“ stella","text":"public subroutine init_ccfftw(fft, is, n, data_in, data_out) Uses mp Arguments Type Intent Optional Attributes Name type( fft_type ), intent(out) :: fft integer, intent(in) :: is integer, intent(in) :: n complex, intent(inout), dimension(:) :: data_in complex, intent(inout), dimension(:) :: data_out Contents None","tags":"","loc":"proc/init_ccfftw.html"},{"title":"init_crfftw â€“ stella","text":"public subroutine init_crfftw(fft, is, n, data_in, data_out) Uses mp Arguments Type Intent Optional Attributes Name type( fft_type ), intent(out) :: fft integer, intent(in) :: is integer, intent(in) :: n complex, intent(inout), dimension(:) :: data_in real, intent(inout), dimension(:) :: data_out Contents None","tags":"","loc":"proc/init_crfftw.html"},{"title":"init_rcfftw â€“ stella","text":"public subroutine init_rcfftw(fft, is, n, data_in, data_out) Uses mp Arguments Type Intent Optional Attributes Name type( fft_type ), intent(out) :: fft integer, intent(in) :: is integer, intent(in) :: n real, intent(inout), dimension(:) :: data_in complex, intent(inout), dimension(:) :: data_out Contents None","tags":"","loc":"proc/init_rcfftw.html"},{"title":"delete_fft â€“ stella","text":"public subroutine delete_fft(fft) Arguments Type Intent Optional Attributes Name type( fft_type ), intent(inout) :: fft Contents None","tags":"","loc":"proc/delete_fft.html"},{"title":"smoothstep â€“ stella","text":"public pure function smoothstep(x, N, minV, maxV) Arguments Type Intent Optional Attributes Name real, intent(in) :: x integer, intent(in) :: N real, intent(in), optional :: minV real, intent(in), optional :: maxV Return Value real Contents None","tags":"","loc":"proc/smoothstep.html"},{"title":"smoothstep0 â€“ stella","text":"public pure function smoothstep0(x) Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value real Contents None","tags":"","loc":"proc/smoothstep0.html"},{"title":"smoothstep1 â€“ stella","text":"public pure function smoothstep1(x) Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value real Contents None","tags":"","loc":"proc/smoothstep1.html"},{"title":"smoothstep2 â€“ stella","text":"public pure function smoothstep2(x) Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value real Contents None","tags":"","loc":"proc/smoothstep2.html"},{"title":"smoothstepN â€“ stella","text":"public pure function smoothstepN(x, N) Arguments Type Intent Optional Attributes Name real, intent(in) :: x integer, intent(in) :: N Return Value real Contents None","tags":"","loc":"proc/smoothstepn.html"},{"title":"pascalTriangle â€“ stella","text":"public pure function pascalTriangle(a, b) Arguments Type Intent Optional Attributes Name integer, intent(in) :: a integer, intent(in) :: b Return Value integer Contents None","tags":"","loc":"proc/pascaltriangle.html"},{"title":"systemf â€“ stella","text":"public subroutine systemf(command) Arguments Type Intent Optional Attributes Name character, intent(in) :: command Contents None","tags":"","loc":"proc/systemf.html"},{"title":"fitp_curv2 â€“ stella","text":"public function fitp_curv2(t, n, x, y, yp, sigma) Arguments Type Intent Optional Attributes Name real :: t integer :: n real :: x (n) real :: y (n) real :: yp (n) real :: sigma Return Value real Contents None","tags":"","loc":"proc/fitp_curv2.html"},{"title":"fitp_curvd â€“ stella","text":"public function fitp_curvd(t, n, x, y, yp, sigma) Arguments Type Intent Optional Attributes Name real :: t integer :: n real :: x (n) real :: y (n) real :: yp (n) real :: sigma Return Value real Contents None","tags":"","loc":"proc/fitp_curvd.html"},{"title":"fitp_curvi â€“ stella","text":"public function fitp_curvi(xl, xu, n, x, y, yp, sigma) Arguments Type Intent Optional Attributes Name real :: xl real :: xu integer :: n real :: x (n) real :: y (n) real :: yp (n) real :: sigma Return Value real Contents None","tags":"","loc":"proc/fitp_curvi.html"},{"title":"fitp_curvp2 â€“ stella","text":"public function fitp_curvp2(t, n, x, y, p, yp, sigma) Arguments Type Intent Optional Attributes Name real :: t integer :: n real, dimension(:) :: x real, dimension(:) :: y real :: p real, dimension(:) :: yp real :: sigma Return Value real Contents None","tags":"","loc":"proc/fitp_curvp2.html"},{"title":"fitp_curvpd â€“ stella","text":"public function fitp_curvpd(t, n, x, y, p, yp, sigma) Arguments Type Intent Optional Attributes Name real :: t integer :: n real :: x (n) real :: y (n) real :: p real :: yp (n) real :: sigma Return Value real Contents None","tags":"","loc":"proc/fitp_curvpd.html"},{"title":"fitp_curvpi â€“ stella","text":"public function fitp_curvpi(xl, xu, n, x, y, p, yp, sigma) Arguments Type Intent Optional Attributes Name real :: xl real :: xu integer :: n real :: x (n) real :: y (n) real :: p real :: yp (n) real :: sigma Return Value real Contents None","tags":"","loc":"proc/fitp_curvpi.html"},{"title":"fitp_surf2 â€“ stella","text":"public function fitp_surf2(xx, yy, m, n, x, y, z, iz, zp, sigma) Arguments Type Intent Optional Attributes Name real :: xx real :: yy integer :: m integer :: n real :: x (m) real :: y (n) real :: z (iz,n) integer :: iz real :: zp (m,n,3) real :: sigma Return Value real Contents None","tags":"","loc":"proc/fitp_surf2.html"},{"title":"fitp_intrvl â€“ stella","text":"public function fitp_intrvl(t, x, n) Arguments Type Intent Optional Attributes Name real :: t real :: x (n) integer :: n Return Value integer Contents None","tags":"","loc":"proc/fitp_intrvl.html"},{"title":"fitp_intrvp â€“ stella","text":"public function fitp_intrvp(t, x, n, p, tp) Arguments Type Intent Optional Attributes Name real :: t real :: x (n) integer :: n real :: p real :: tp Return Value integer Contents None","tags":"","loc":"proc/fitp_intrvp.html"},{"title":"dedge â€“ stella","text":"public function dedge(a, r, n, iside) Arguments Type Intent Optional Attributes Name real :: a (n) real :: r (n) integer :: n integer :: iside Return Value real Contents None","tags":"","loc":"proc/dedge.html"},{"title":"fitp_curv1 â€“ stella","text":"public subroutine fitp_curv1(n, x, y, slp1, slpn, islpsw, yp, temp, sigma, ierr) Arguments Type Intent Optional Attributes Name integer :: n real :: x (n) real :: y (n) real :: slp1 real :: slpn integer :: islpsw real :: yp (n) real :: temp (n) real :: sigma integer :: ierr Contents None","tags":"","loc":"proc/fitp_curv1.html"},{"title":"fitp_curvs â€“ stella","text":"public subroutine fitp_curvs(n, x, y, d, isw, s, eps, ys, ysp, sigma, temp, ierr) Arguments Type Intent Optional Attributes Name integer :: n real :: x (n) real :: y (n) real :: d (n) integer :: isw real :: s real :: eps real :: ys (n) real :: ysp (n) real :: sigma real :: temp (n,9) integer :: ierr Contents None","tags":"","loc":"proc/fitp_curvs.html"},{"title":"fitp_curvp1 â€“ stella","text":"public subroutine fitp_curvp1(n, x, y, p, yp, temp, sigma, ierr) Arguments Type Intent Optional Attributes Name integer :: n real, dimension(:) :: x real, dimension(:) :: y real :: p real, dimension(:) :: yp real, dimension(:) :: temp real :: sigma integer :: ierr Contents None","tags":"","loc":"proc/fitp_curvp1.html"},{"title":"fitp_curvps â€“ stella","text":"public subroutine fitp_curvps(n, x, y, p, d, isw, s, eps, ys, ysp, sigma, temp, ierr) Arguments Type Intent Optional Attributes Name integer :: n real :: x (n) real :: y (n) real :: p real :: d (n) integer :: isw real :: s real :: eps real :: ys (n) real :: ysp (n) real :: sigma real :: temp (n,11) integer :: ierr Contents None","tags":"","loc":"proc/fitp_curvps.html"},{"title":"fitp_kurv1 â€“ stella","text":"public subroutine fitp_kurv1(n, x, y, slp1, slpn, islpsw, xp, yp, temp, s, sigma, ierr) Arguments Type Intent Optional Attributes Name integer :: n real :: x (n) real :: y (n) real :: slp1 real :: slpn integer :: islpsw real :: xp (n) real :: yp (n) real :: temp (n) real :: s (n) real :: sigma integer :: ierr Contents None","tags":"","loc":"proc/fitp_kurv1.html"},{"title":"fitp_kurv2 â€“ stella","text":"public subroutine fitp_kurv2(t, xs, ys, n, x, y, xp, yp, s, sigma) Arguments Type Intent Optional Attributes Name real :: t real :: xs real :: ys integer :: n real :: x (n) real :: y (n) real :: xp (n) real :: yp (n) real :: s (n) real :: sigma Contents None","tags":"","loc":"proc/fitp_kurv2.html"},{"title":"fitp_kurvd â€“ stella","text":"public subroutine fitp_kurvd(t, xs, ys, xst, yst, xstt, ystt, n, x, y, xp, yp, s, sigma) Arguments Type Intent Optional Attributes Name real :: t real :: xs real :: ys real :: xst real :: yst real :: xstt real :: ystt integer :: n real :: x (n) real :: y (n) real :: xp (n) real :: yp (n) real :: s (n) real :: sigma Contents None","tags":"","loc":"proc/fitp_kurvd.html"},{"title":"fitp_kurvp1 â€“ stella","text":"public subroutine fitp_kurvp1(n, x, y, xp, yp, temp, s, sigma, ierr) Arguments Type Intent Optional Attributes Name integer :: n real :: x (n) real :: y (n) real :: xp (n) real :: yp (n) real :: temp (1) real :: s (n) real :: sigma integer :: ierr Contents None","tags":"","loc":"proc/fitp_kurvp1.html"},{"title":"fitp_kurvp2 â€“ stella","text":"public subroutine fitp_kurvp2(t, xs, ys, n, x, y, xp, yp, s, sigma) Arguments Type Intent Optional Attributes Name real :: t real :: xs real :: ys integer :: n real :: x (n) real :: y (n) real :: xp (n) real :: yp (n) real :: s (n) real :: sigma Contents None","tags":"","loc":"proc/fitp_kurvp2.html"},{"title":"fitp_kurvpd â€“ stella","text":"public subroutine fitp_kurvpd(t, xs, ys, xst, yst, xstt, ystt, n, x, y, xp, yp, s, sigma) Arguments Type Intent Optional Attributes Name real :: t real :: xs real :: ys real :: xst real :: yst real :: xstt real :: ystt integer :: n real :: x (n) real :: y (n) real :: xp (n) real :: yp (n) real :: s (n) real :: sigma Contents None","tags":"","loc":"proc/fitp_kurvpd.html"},{"title":"fitp_surf1 â€“ stella","text":"public subroutine fitp_surf1(m, n, x, y, z, iz, zx1, zxm, zy1, zyn, zxy11, zxym1, zxy1n, zxymn, islpsw, zp, temp, sigma, ierr) Arguments Type Intent Optional Attributes Name integer :: m integer :: n real :: x (m) real :: y (n) real :: z (iz,n) integer :: iz real :: zx1 (n) real :: zxm (n) real :: zy1 (m) real :: zyn (m) real :: zxy11 real :: zxym1 real :: zxy1n real :: zxymn integer :: islpsw real :: zp (m,n,3) real :: temp (n+n+m) real :: sigma integer :: ierr Contents None","tags":"","loc":"proc/fitp_surf1.html"},{"title":"fitp_ceez â€“ stella","text":"public subroutine fitp_ceez(del1, del2, sigma, c1, c2, c3, n) Arguments Type Intent Optional Attributes Name real :: del1 real :: del2 real :: sigma real :: c1 real :: c2 real :: c3 integer :: n Contents None","tags":"","loc":"proc/fitp_ceez.html"},{"title":"fitp_curvpp â€“ stella","text":"public subroutine fitp_curvpp(n, x, y, p, d, isw, s, eps, ys, ysp, sigma, td, tsd1, hd, hsd1, hsd2, rd, rsd1, rsd2, rnm1, rn, v, ierr) Arguments Type Intent Optional Attributes Name integer :: n real :: x (n) real :: y (n) real :: p real :: d (n) integer :: isw real :: s real :: eps real :: ys (n) real :: ysp (n) real :: sigma real :: td (n) real :: tsd1 (n) real :: hd (n) real :: hsd1 (n) real :: hsd2 (n) real :: rd (n) real :: rsd1 (n) real :: rsd2 (n) real :: rnm1 (n) real :: rn (n) real :: v (n) integer :: ierr Contents None","tags":"","loc":"proc/fitp_curvpp.html"},{"title":"fitp_curvss â€“ stella","text":"public subroutine fitp_curvss(n, x, y, d, isw, s, eps, ys, ysp, sigma, td, tsd1, hd, hsd1, hsd2, rd, rsd1, rsd2, v, ierr) Arguments Type Intent Optional Attributes Name integer :: n real :: x (n) real :: y (n) real :: d (n) integer :: isw real :: s real :: eps real :: ys (n) real :: ysp (n) real :: sigma real :: td (n) real :: tsd1 (n) real :: hd (n) real :: hsd1 (n) real :: hsd2 (n) real :: rd (n) real :: rsd1 (n) real :: rsd2 (n) real :: v (n) integer :: ierr Contents None","tags":"","loc":"proc/fitp_curvss.html"},{"title":"fitp_snhcsh â€“ stella","text":"public subroutine fitp_snhcsh(sinhm, coshm, x, isw) Arguments Type Intent Optional Attributes Name real :: sinhm real :: coshm real :: x integer :: isw Contents None","tags":"","loc":"proc/fitp_snhcsh.html"},{"title":"fitp_terms â€“ stella","text":"public subroutine fitp_terms(diag, sdiag, sigma, del) Arguments Type Intent Optional Attributes Name real :: diag real :: sdiag real :: sigma real :: del Contents None","tags":"","loc":"proc/fitp_terms.html"},{"title":"geo_spline_real â€“ stella","text":"public subroutine geo_spline_real(x, y, xint, yint) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: x real, intent(in), dimension(:) :: y real, intent(in) :: xint real, intent(out) :: yint Contents None","tags":"","loc":"proc/geo_spline_real.html"},{"title":"geo_spline_array â€“ stella","text":"public subroutine geo_spline_array(x, y, xint, yint) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: x real, intent(in), dimension(:) :: y real, intent(in), dimension(:) :: xint real, intent(out), dimension(:) :: yint Contents None","tags":"","loc":"proc/geo_spline_array.html"},{"title":"linear_interp_periodic â€“ stella","text":"public subroutine linear_interp_periodic(x, y, xint, yint, period) Uses constants Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: x real, intent(in), dimension(:) :: y real, intent(in), dimension(:) :: xint real, intent(out), dimension(:) :: yint real, intent(in), optional :: period Contents None","tags":"","loc":"proc/linear_interp_periodic.html"},{"title":"geo_spline â€“ stella","text":"public interface geo_spline Contents Module Procedures geo_spline_real geo_spline_array Module Procedures public subroutine geo_spline_real (x, y, xint, yint) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: x real, intent(in), dimension(:) :: y real, intent(in) :: xint real, intent(out) :: yint public subroutine geo_spline_array (x, y, xint, yint) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: x real, intent(in), dimension(:) :: y real, intent(in), dimension(:) :: xint real, intent(out), dimension(:) :: yint","tags":"","loc":"interface/geo_spline.html"},{"title":"sort_array_ascending â€“ stella","text":"public subroutine sort_array_ascending(array, sort_index) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: array integer, intent(out), dimension(:) :: sort_index Contents None","tags":"","loc":"proc/sort_array_ascending.html"},{"title":"unsort_array_ascending â€“ stella","text":"public subroutine unsort_array_ascending(array, sort_index) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: array integer, intent(in), dimension(:) :: sort_index Contents None","tags":"","loc":"proc/unsort_array_ascending.html"},{"title":"x5c2r â€“ stella","text":"private subroutine x5c2r(a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, :, :, :) :: a real, intent(out), dimension(:, :, :, :, :, :) :: a_ri Contents None","tags":"","loc":"proc/x5c2r.html"},{"title":"x6c2r â€“ stella","text":"private subroutine x6c2r(a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, :, :, :, :) :: a real, intent(out), dimension(:, :, :, :, :, :, :) :: a_ri Contents None","tags":"","loc":"proc/x6c2r.html"},{"title":"x5r2c â€“ stella","text":"private subroutine x5r2c(a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :, :, :, :) :: a real, intent(in), dimension(:, :, :, :, :, :) :: a_ri Contents None","tags":"","loc":"proc/x5r2c.html"},{"title":"x4c2r â€“ stella","text":"private subroutine x4c2r(a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, :, :) :: a real, intent(out), dimension(:, :, :, :, :) :: a_ri Contents None","tags":"","loc":"proc/x4c2r.html"},{"title":"x4r2c â€“ stella","text":"private subroutine x4r2c(a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :, :, :) :: a real, intent(in), dimension(:, :, :, :, :) :: a_ri Contents None","tags":"","loc":"proc/x4r2c.html"},{"title":"x3c2r â€“ stella","text":"private subroutine x3c2r(a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, :) :: a real, intent(out), dimension(:, :, :, :) :: a_ri Contents None","tags":"","loc":"proc/x3c2r.html"},{"title":"x3r2c â€“ stella","text":"private subroutine x3r2c(a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :, :) :: a real, intent(in), dimension(:, :, :, :) :: a_ri Contents None","tags":"","loc":"proc/x3r2c.html"},{"title":"x2c2r â€“ stella","text":"private subroutine x2c2r(a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: a real, intent(out), dimension(:, :, :) :: a_ri Contents None","tags":"","loc":"proc/x2c2r.html"},{"title":"x2r2c â€“ stella","text":"private subroutine x2r2c(a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :) :: a real, intent(in), dimension(:, :, :) :: a_ri Contents None","tags":"","loc":"proc/x2r2c.html"},{"title":"x1c2r â€“ stella","text":"private subroutine x1c2r(a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: a real, intent(out), dimension(:, :) :: a_ri Contents None","tags":"","loc":"proc/x1c2r.html"},{"title":"x1r2c â€“ stella","text":"private subroutine x1r2c(a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:) :: a real, intent(in), dimension(:, :) :: a_ri Contents None","tags":"","loc":"proc/x1r2c.html"},{"title":"Aborter â€“ stella","text":"private subroutine Aborter(iunit, ierrmsg) Arguments Type Intent Optional Attributes Name integer :: iunit character :: ierrmsg *(*) Contents Common Blocks abortcmn Common Blocks common /abortcmn/ Type Attributes Name Initial real :: zz0 real :: zz1","tags":"","loc":"proc/aborter.html"},{"title":"c2r â€“ stella","text":"public interface c2r Contents Module Procedures x1c2r x2c2r x3c2r x4c2r x5c2r x6c2r Module Procedures private subroutine x1c2r (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: a real, intent(out), dimension(:, :) :: a_ri private subroutine x2c2r (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: a real, intent(out), dimension(:, :, :) :: a_ri private subroutine x3c2r (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, :) :: a real, intent(out), dimension(:, :, :, :) :: a_ri private subroutine x4c2r (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, :, :) :: a real, intent(out), dimension(:, :, :, :, :) :: a_ri private subroutine x5c2r (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, :, :, :) :: a real, intent(out), dimension(:, :, :, :, :, :) :: a_ri private subroutine x6c2r (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, :, :, :, :) :: a real, intent(out), dimension(:, :, :, :, :, :, :) :: a_ri","tags":"","loc":"interface/c2r.html"},{"title":"r2c â€“ stella","text":"public interface r2c Contents Module Procedures x1r2c x2r2c x3r2c x4r2c x5r2c Module Procedures private subroutine x1r2c (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:) :: a real, intent(in), dimension(:, :) :: a_ri private subroutine x2r2c (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :) :: a real, intent(in), dimension(:, :, :) :: a_ri private subroutine x3r2c (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :, :) :: a real, intent(in), dimension(:, :, :, :) :: a_ri private subroutine x4r2c (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :, :, :) :: a real, intent(in), dimension(:, :, :, :, :) :: a_ri private subroutine x5r2c (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :, :, :, :) :: a real, intent(in), dimension(:, :, :, :, :, :) :: a_ri","tags":"","loc":"interface/r2c.html"},{"title":"legendre_p â€“ stella","text":"private elemental function legendre_p(n, x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision, intent(in) :: x Return Value double precision Contents None","tags":"","loc":"proc/legendre_p.html"},{"title":"legendre_pp â€“ stella","text":"private elemental function legendre_pp(n, x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision, intent(in) :: x Return Value double precision Contents None","tags":"","loc":"proc/legendre_pp.html"},{"title":"laguerre_l â€“ stella","text":"private elemental function laguerre_l(n, x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=qp), intent(in) :: x Return Value real(kind=qp) Contents None","tags":"","loc":"proc/laguerre_l.html"},{"title":"laguerre_lp â€“ stella","text":"private elemental function laguerre_lp(n, x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=qp), intent(in) :: x Return Value real(kind=qp) Contents None","tags":"","loc":"proc/laguerre_lp.html"},{"title":"get_legendre_grids_from_cheb â€“ stella","text":"public subroutine get_legendre_grids_from_cheb(x1, x2, zero, wgt) Uses constants Arguments Type Intent Optional Attributes Name real, intent(in) :: x1 real, intent(in) :: x2 real, intent(out), dimension(:) :: zero real, intent(out), dimension(:) :: wgt Contents None","tags":"","loc":"proc/get_legendre_grids_from_cheb.html"},{"title":"find_zero_bisect_newton â€“ stella","text":"private subroutine find_zero_bisect_newton(n, xold, xnew, pold, pnew, zz) Uses file_utils Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision, intent(in) :: xold double precision, intent(in) :: xnew double precision, intent(in) :: pold double precision, intent(in) :: pnew double precision, intent(out) :: zz Contents None","tags":"","loc":"proc/find_zero_bisect_newton.html"},{"title":"check_legendre_zero â€“ stella","text":"private subroutine check_legendre_zero(x0, x1, zero) Uses mp file_utils Arguments Type Intent Optional Attributes Name real, intent(in) :: x0 real, intent(in) :: x1 real, intent(in), dimension(:) :: zero Contents None","tags":"","loc":"proc/check_legendre_zero.html"},{"title":"check_legendre_weights â€“ stella","text":"private subroutine check_legendre_weights(norm, wgt) Uses mp file_utils Arguments Type Intent Optional Attributes Name real, intent(in) :: norm real, intent(in), dimension(:) :: wgt Contents None","tags":"","loc":"proc/check_legendre_weights.html"},{"title":"get_laguerre_grids â€“ stella","text":"public subroutine get_laguerre_grids(zero, wgt) Uses mp file_utils Arguments Type Intent Optional Attributes Name real, intent(out), dimension(:) :: zero real, intent(out), dimension(:) :: wgt Contents None","tags":"","loc":"proc/get_laguerre_grids.html"},{"title":"find_zero â€“ stella","text":"private subroutine find_zero(n, eps, xold, xnew, pold, pnew, zz) Uses file_utils Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision, intent(in) :: eps real(kind=qp), intent(in) :: xold real(kind=qp), intent(in) :: xnew real(kind=qp), intent(in) :: pold real(kind=qp), intent(in) :: pnew real(kind=qp), intent(out) :: zz Contents None","tags":"","loc":"proc/find_zero.html"},{"title":"check_laguerre_zeros â€“ stella","text":"private subroutine check_laguerre_zeros(zero) Uses mp file_utils Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: zero Contents None","tags":"","loc":"proc/check_laguerre_zeros.html"},{"title":"check_laguerre_weights â€“ stella","text":"private subroutine check_laguerre_weights(wgt, eps) Uses mp file_utils Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: wgt real, intent(in) :: eps Contents None","tags":"","loc":"proc/check_laguerre_weights.html"},{"title":"cl_iargc â€“ stella","text":"public function cl_iargc() Arguments None Return Value integer Contents None","tags":"","loc":"proc/cl_iargc.html"},{"title":"cl_getarg â€“ stella","text":"public subroutine cl_getarg(k, arg, len, ierr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: k character(len=*), intent(out) :: arg integer, intent(out) :: len integer, intent(out) :: ierr Contents None","tags":"","loc":"proc/cl_getarg.html"},{"title":"init_mp â€“ stella","text":"public subroutine init_mp(comm_in) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: comm_in Contents None","tags":"","loc":"proc/init_mp.html"},{"title":"scope â€“ stella","text":"public subroutine scope(focus) Arguments Type Intent Optional Attributes Name integer, intent(in) :: focus Contents None","tags":"","loc":"proc/scope.html"},{"title":"init_job_topology â€“ stella","text":"public subroutine init_job_topology(ncolumns, group0, ierr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncolumns integer, intent(out), dimension(0:) :: group0 integer :: ierr Contents None","tags":"","loc":"proc/init_job_topology.html"},{"title":"finish_mp â€“ stella","text":"public subroutine finish_mp() Arguments None Contents None","tags":"","loc":"proc/finish_mp.html"},{"title":"broadcast_character â€“ stella","text":"private subroutine broadcast_character(char) Arguments Type Intent Optional Attributes Name character, intent(inout) :: char Contents None","tags":"","loc":"proc/broadcast_character.html"},{"title":"broadcast_integer â€“ stella","text":"private subroutine broadcast_integer(i) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i Contents None","tags":"","loc":"proc/broadcast_integer.html"},{"title":"broadcast_integer_array â€“ stella","text":"private subroutine broadcast_integer_array(i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i Contents None","tags":"","loc":"proc/broadcast_integer_array.html"},{"title":"broadcast_real â€“ stella","text":"private subroutine broadcast_real(x) Arguments Type Intent Optional Attributes Name real, intent(inout) :: x Contents None","tags":"","loc":"proc/broadcast_real.html"},{"title":"broadcast_real_array â€“ stella","text":"private subroutine broadcast_real_array(x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: x Contents None","tags":"","loc":"proc/broadcast_real_array.html"},{"title":"broadcast_real_2array â€“ stella","text":"private subroutine broadcast_real_2array(x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :) :: x Contents None","tags":"","loc":"proc/broadcast_real_2array.html"},{"title":"broadcast_real_3array â€“ stella","text":"private subroutine broadcast_real_3array(x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :) :: x Contents None","tags":"","loc":"proc/broadcast_real_3array.html"},{"title":"broadcast_real_4array â€“ stella","text":"private subroutine broadcast_real_4array(x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :) :: x Contents None","tags":"","loc":"proc/broadcast_real_4array.html"},{"title":"broadcast_real_5array â€“ stella","text":"private subroutine broadcast_real_5array(x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :) :: x Contents None","tags":"","loc":"proc/broadcast_real_5array.html"},{"title":"broadcast_complex â€“ stella","text":"private subroutine broadcast_complex(z) Arguments Type Intent Optional Attributes Name complex, intent(inout) :: z Contents None","tags":"","loc":"proc/broadcast_complex.html"},{"title":"broadcast_complex_array â€“ stella","text":"private subroutine broadcast_complex_array(z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: z Contents None","tags":"","loc":"proc/broadcast_complex_array.html"},{"title":"broadcast_complex_2array â€“ stella","text":"private subroutine broadcast_complex_2array(z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: z Contents None","tags":"","loc":"proc/broadcast_complex_2array.html"},{"title":"broadcast_complex_3array â€“ stella","text":"private subroutine broadcast_complex_3array(z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :) :: z Contents None","tags":"","loc":"proc/broadcast_complex_3array.html"},{"title":"broadcast_complex_4array â€“ stella","text":"private subroutine broadcast_complex_4array(z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :) :: z Contents None","tags":"","loc":"proc/broadcast_complex_4array.html"},{"title":"broadcast_logical â€“ stella","text":"private subroutine broadcast_logical(f) Arguments Type Intent Optional Attributes Name logical, intent(inout) :: f Contents None","tags":"","loc":"proc/broadcast_logical.html"},{"title":"broadcast_logical_array â€“ stella","text":"private subroutine broadcast_logical_array(f) Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:) :: f Contents None","tags":"","loc":"proc/broadcast_logical_array.html"},{"title":"bcastfrom_logical â€“ stella","text":"private subroutine bcastfrom_logical(f, src) Arguments Type Intent Optional Attributes Name logical, intent(inout) :: f integer, intent(in) :: src Contents None","tags":"","loc":"proc/bcastfrom_logical.html"},{"title":"bcastfrom_logical_array â€“ stella","text":"private subroutine bcastfrom_logical_array(f, src) Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:) :: f integer, intent(in) :: src Contents None","tags":"","loc":"proc/bcastfrom_logical_array.html"},{"title":"bcastfrom_character â€“ stella","text":"private subroutine bcastfrom_character(c, src) Arguments Type Intent Optional Attributes Name character, intent(inout) :: c integer, intent(in) :: src Contents None","tags":"","loc":"proc/bcastfrom_character.html"},{"title":"bcastfrom_integer â€“ stella","text":"private subroutine bcastfrom_integer(i, src) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i integer, intent(in) :: src Contents None","tags":"","loc":"proc/bcastfrom_integer.html"},{"title":"bcastfrom_integer_array â€“ stella","text":"private subroutine bcastfrom_integer_array(i, src) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i integer, intent(in) :: src Contents None","tags":"","loc":"proc/bcastfrom_integer_array.html"},{"title":"bcastfrom_real â€“ stella","text":"private subroutine bcastfrom_real(x, src) Arguments Type Intent Optional Attributes Name real, intent(inout) :: x integer, intent(in) :: src Contents None","tags":"","loc":"proc/bcastfrom_real.html"},{"title":"bcastfrom_real_array â€“ stella","text":"private subroutine bcastfrom_real_array(x, src) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: x integer, intent(in) :: src Contents None","tags":"","loc":"proc/bcastfrom_real_array.html"},{"title":"bcastfrom_complex â€“ stella","text":"private subroutine bcastfrom_complex(z, src) Arguments Type Intent Optional Attributes Name complex, intent(inout) :: z integer, intent(in) :: src Contents None","tags":"","loc":"proc/bcastfrom_complex.html"},{"title":"bcastfrom_complex_array â€“ stella","text":"private subroutine bcastfrom_complex_array(z, src) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: z integer, intent(in) :: src Contents None","tags":"","loc":"proc/bcastfrom_complex_array.html"},{"title":"bcastfrom_complex_2array â€“ stella","text":"private subroutine bcastfrom_complex_2array(z, src) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: z integer, intent(in) :: src Contents None","tags":"","loc":"proc/bcastfrom_complex_2array.html"},{"title":"sum_reduce_integer â€“ stella","text":"private subroutine sum_reduce_integer(i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i integer, intent(in) :: dest Contents None","tags":"","loc":"proc/sum_reduce_integer.html"},{"title":"sum_reduce_integer_array â€“ stella","text":"private subroutine sum_reduce_integer_array(i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i integer, intent(in) :: dest Contents None","tags":"","loc":"proc/sum_reduce_integer_array.html"},{"title":"sum_reduce_real â€“ stella","text":"private subroutine sum_reduce_real(a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a integer, intent(in) :: dest Contents None","tags":"","loc":"proc/sum_reduce_real.html"},{"title":"sum_reduce_real_array â€“ stella","text":"private subroutine sum_reduce_real_array(a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a integer, intent(in) :: dest Contents None","tags":"","loc":"proc/sum_reduce_real_array.html"},{"title":"sum_reduce_real_2array â€“ stella","text":"private subroutine sum_reduce_real_2array(a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :) :: a integer, intent(in) :: dest Contents None","tags":"","loc":"proc/sum_reduce_real_2array.html"},{"title":"sum_reduce_real_3array â€“ stella","text":"private subroutine sum_reduce_real_3array(a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :) :: a integer, intent(in) :: dest Contents None","tags":"","loc":"proc/sum_reduce_real_3array.html"},{"title":"sum_reduce_real_4array â€“ stella","text":"private subroutine sum_reduce_real_4array(a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :) :: a integer, intent(in) :: dest Contents None","tags":"","loc":"proc/sum_reduce_real_4array.html"},{"title":"sum_reduce_real_5array â€“ stella","text":"private subroutine sum_reduce_real_5array(a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :) :: a integer, intent(in) :: dest Contents None","tags":"","loc":"proc/sum_reduce_real_5array.html"},{"title":"sum_reduce_complex â€“ stella","text":"private subroutine sum_reduce_complex(z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout) :: z integer, intent(in) :: dest Contents None","tags":"","loc":"proc/sum_reduce_complex.html"},{"title":"sum_reduce_complex_array â€“ stella","text":"private subroutine sum_reduce_complex_array(z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: z integer, intent(in) :: dest Contents None","tags":"","loc":"proc/sum_reduce_complex_array.html"},{"title":"sum_reduce_complex_2array â€“ stella","text":"private subroutine sum_reduce_complex_2array(z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: z integer, intent(in) :: dest Contents None","tags":"","loc":"proc/sum_reduce_complex_2array.html"},{"title":"sum_reduce_complex_3array â€“ stella","text":"private subroutine sum_reduce_complex_3array(z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :) :: z integer, intent(in) :: dest Contents None","tags":"","loc":"proc/sum_reduce_complex_3array.html"},{"title":"sum_reduce_complex_4array â€“ stella","text":"private subroutine sum_reduce_complex_4array(z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :) :: z integer, intent(in) :: dest Contents None","tags":"","loc":"proc/sum_reduce_complex_4array.html"},{"title":"sum_reduce_complex_5array â€“ stella","text":"private subroutine sum_reduce_complex_5array(z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :, :) :: z integer, intent(in) :: dest Contents None","tags":"","loc":"proc/sum_reduce_complex_5array.html"},{"title":"sum_allreduce_integer â€“ stella","text":"private subroutine sum_allreduce_integer(i) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i Contents None","tags":"","loc":"proc/sum_allreduce_integer.html"},{"title":"sum_allreduce_integer_array â€“ stella","text":"private subroutine sum_allreduce_integer_array(i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i Contents None","tags":"","loc":"proc/sum_allreduce_integer_array.html"},{"title":"sum_allreduce_integer_2array â€“ stella","text":"private subroutine sum_allreduce_integer_2array(i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:, :) :: i Contents None","tags":"","loc":"proc/sum_allreduce_integer_2array.html"},{"title":"sum_allreduce_real â€“ stella","text":"private subroutine sum_allreduce_real(a) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a Contents None","tags":"","loc":"proc/sum_allreduce_real.html"},{"title":"sum_allreduce_real_array â€“ stella","text":"private subroutine sum_allreduce_real_array(a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a Contents None","tags":"","loc":"proc/sum_allreduce_real_array.html"},{"title":"sum_allreduce_real_2array â€“ stella","text":"private subroutine sum_allreduce_real_2array(a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :) :: a Contents None","tags":"","loc":"proc/sum_allreduce_real_2array.html"},{"title":"sum_allreduce_real_3array â€“ stella","text":"private subroutine sum_allreduce_real_3array(a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :) :: a Contents None","tags":"","loc":"proc/sum_allreduce_real_3array.html"},{"title":"sum_allreduce_real_4array â€“ stella","text":"private subroutine sum_allreduce_real_4array(a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :) :: a Contents None","tags":"","loc":"proc/sum_allreduce_real_4array.html"},{"title":"sum_allreduce_real_5array â€“ stella","text":"private subroutine sum_allreduce_real_5array(a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :) :: a Contents None","tags":"","loc":"proc/sum_allreduce_real_5array.html"},{"title":"sum_allreduce_complex â€“ stella","text":"private subroutine sum_allreduce_complex(z) Arguments Type Intent Optional Attributes Name complex, intent(inout) :: z Contents None","tags":"","loc":"proc/sum_allreduce_complex.html"},{"title":"sum_allreduce_complex_array â€“ stella","text":"private subroutine sum_allreduce_complex_array(z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: z Contents None","tags":"","loc":"proc/sum_allreduce_complex_array.html"},{"title":"sum_allreduce_complex_2array â€“ stella","text":"private subroutine sum_allreduce_complex_2array(z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: z Contents None","tags":"","loc":"proc/sum_allreduce_complex_2array.html"},{"title":"sum_allreduce_complex_3array â€“ stella","text":"private subroutine sum_allreduce_complex_3array(z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :) :: z Contents None","tags":"","loc":"proc/sum_allreduce_complex_3array.html"},{"title":"sum_allreduce_complex_4array â€“ stella","text":"private subroutine sum_allreduce_complex_4array(z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :) :: z Contents None","tags":"","loc":"proc/sum_allreduce_complex_4array.html"},{"title":"sum_allreduce_complex_5array â€“ stella","text":"private subroutine sum_allreduce_complex_5array(z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :, :) :: z Contents None","tags":"","loc":"proc/sum_allreduce_complex_5array.html"},{"title":"max_reduce_integer â€“ stella","text":"private subroutine max_reduce_integer(i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i integer, intent(in) :: dest Contents None","tags":"","loc":"proc/max_reduce_integer.html"},{"title":"max_reduce_integer_array â€“ stella","text":"private subroutine max_reduce_integer_array(i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i integer, intent(in) :: dest Contents None","tags":"","loc":"proc/max_reduce_integer_array.html"},{"title":"max_reduce_real â€“ stella","text":"private subroutine max_reduce_real(a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a integer, intent(in) :: dest Contents None","tags":"","loc":"proc/max_reduce_real.html"},{"title":"max_reduce_real_array â€“ stella","text":"private subroutine max_reduce_real_array(a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a integer, intent(in) :: dest Contents None","tags":"","loc":"proc/max_reduce_real_array.html"},{"title":"max_allreduce_integer â€“ stella","text":"private subroutine max_allreduce_integer(i) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i Contents None","tags":"","loc":"proc/max_allreduce_integer.html"},{"title":"max_allreduce_integer_array â€“ stella","text":"private subroutine max_allreduce_integer_array(i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i Contents None","tags":"","loc":"proc/max_allreduce_integer_array.html"},{"title":"max_allreduce_real â€“ stella","text":"private subroutine max_allreduce_real(a) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a Contents None","tags":"","loc":"proc/max_allreduce_real.html"},{"title":"max_allreduce_real_array â€“ stella","text":"private subroutine max_allreduce_real_array(a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a Contents None","tags":"","loc":"proc/max_allreduce_real_array.html"},{"title":"min_reduce_integer â€“ stella","text":"private subroutine min_reduce_integer(i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i integer, intent(in) :: dest Contents None","tags":"","loc":"proc/min_reduce_integer.html"},{"title":"min_reduce_integer_array â€“ stella","text":"private subroutine min_reduce_integer_array(i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i integer, intent(in) :: dest Contents None","tags":"","loc":"proc/min_reduce_integer_array.html"},{"title":"min_reduce_real â€“ stella","text":"private subroutine min_reduce_real(a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a integer, intent(in) :: dest Contents None","tags":"","loc":"proc/min_reduce_real.html"},{"title":"min_reduce_real_array â€“ stella","text":"private subroutine min_reduce_real_array(a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a integer, intent(in) :: dest Contents None","tags":"","loc":"proc/min_reduce_real_array.html"},{"title":"min_allreduce_integer â€“ stella","text":"private subroutine min_allreduce_integer(i) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i Contents None","tags":"","loc":"proc/min_allreduce_integer.html"},{"title":"min_allreduce_integer_array â€“ stella","text":"private subroutine min_allreduce_integer_array(i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i Contents None","tags":"","loc":"proc/min_allreduce_integer_array.html"},{"title":"min_allreduce_real â€“ stella","text":"private subroutine min_allreduce_real(a) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a Contents None","tags":"","loc":"proc/min_allreduce_real.html"},{"title":"min_allreduce_real_array â€“ stella","text":"private subroutine min_allreduce_real_array(a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a Contents None","tags":"","loc":"proc/min_allreduce_real_array.html"},{"title":"comm_split â€“ stella","text":"public subroutine comm_split(color, comm_out, ierr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: color integer, intent(out) :: comm_out integer, intent(out) :: ierr Contents None","tags":"","loc":"proc/comm_split.html"},{"title":"comm_free â€“ stella","text":"public subroutine comm_free(comm_in, ierr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: comm_in integer, intent(out) :: ierr Contents None","tags":"","loc":"proc/comm_free.html"},{"title":"barrier â€“ stella","text":"public subroutine barrier() Arguments None Contents None","tags":"","loc":"proc/barrier.html"},{"title":"send_integer â€“ stella","text":"private subroutine send_integer(i, dest, tag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: dest integer, intent(in), optional :: tag Contents None","tags":"","loc":"proc/send_integer.html"},{"title":"send_integer_array â€“ stella","text":"private subroutine send_integer_array(i, dest, tag) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: i integer, intent(in) :: dest integer, intent(in), optional :: tag Contents None","tags":"","loc":"proc/send_integer_array.html"},{"title":"send_real â€“ stella","text":"private subroutine send_real(a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag Contents None","tags":"","loc":"proc/send_real.html"},{"title":"send_real_array â€“ stella","text":"private subroutine send_real_array(a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag Contents None","tags":"","loc":"proc/send_real_array.html"},{"title":"send_real_array_2d â€“ stella","text":"private subroutine send_real_array_2d(a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag Contents None","tags":"","loc":"proc/send_real_array_2d.html"},{"title":"send_complex â€“ stella","text":"private subroutine send_complex(z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag Contents None","tags":"","loc":"proc/send_complex.html"},{"title":"send_complex_array â€“ stella","text":"private subroutine send_complex_array(z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag Contents None","tags":"","loc":"proc/send_complex_array.html"},{"title":"nonblocking_send_complex_array â€“ stella","text":"private subroutine nonblocking_send_complex_array(z, dest, tag, request) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag integer, intent(out) :: request Contents None","tags":"","loc":"proc/nonblocking_send_complex_array.html"},{"title":"send_logical â€“ stella","text":"private subroutine send_logical(f, dest, tag) Arguments Type Intent Optional Attributes Name logical, intent(in) :: f integer, intent(in) :: dest integer, intent(in), optional :: tag Contents None","tags":"","loc":"proc/send_logical.html"},{"title":"send_logical_array â€“ stella","text":"private subroutine send_logical_array(f, dest, tag) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:) :: f integer, intent(in) :: dest integer, intent(in), optional :: tag Contents None","tags":"","loc":"proc/send_logical_array.html"},{"title":"send_character â€“ stella","text":"private subroutine send_character(s, dest, tag) Arguments Type Intent Optional Attributes Name character, intent(in) :: s integer, intent(in) :: dest integer, intent(in), optional :: tag Contents None","tags":"","loc":"proc/send_character.html"},{"title":"ssend_integer â€“ stella","text":"private subroutine ssend_integer(i, dest, tag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: dest integer, intent(in), optional :: tag Contents None","tags":"","loc":"proc/ssend_integer.html"},{"title":"ssend_integer_array â€“ stella","text":"private subroutine ssend_integer_array(i, dest, tag) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: i integer, intent(in) :: dest integer, intent(in), optional :: tag Contents None","tags":"","loc":"proc/ssend_integer_array.html"},{"title":"ssend_real â€“ stella","text":"private subroutine ssend_real(a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag Contents None","tags":"","loc":"proc/ssend_real.html"},{"title":"ssend_real_array â€“ stella","text":"private subroutine ssend_real_array(a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag Contents None","tags":"","loc":"proc/ssend_real_array.html"},{"title":"ssend_complex â€“ stella","text":"private subroutine ssend_complex(z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag Contents None","tags":"","loc":"proc/ssend_complex.html"},{"title":"ssend_complex_array â€“ stella","text":"private subroutine ssend_complex_array(z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag Contents None","tags":"","loc":"proc/ssend_complex_array.html"},{"title":"ssend_complex_2array â€“ stella","text":"private subroutine ssend_complex_2array(z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag Contents None","tags":"","loc":"proc/ssend_complex_2array.html"},{"title":"ssend_logical â€“ stella","text":"private subroutine ssend_logical(f, dest, tag) Arguments Type Intent Optional Attributes Name logical, intent(in) :: f integer, intent(in) :: dest integer, intent(in), optional :: tag Contents None","tags":"","loc":"proc/ssend_logical.html"},{"title":"ssend_logical_array â€“ stella","text":"private subroutine ssend_logical_array(f, dest, tag) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:) :: f integer, intent(in) :: dest integer, intent(in), optional :: tag Contents None","tags":"","loc":"proc/ssend_logical_array.html"},{"title":"receive_integer â€“ stella","text":"private subroutine receive_integer(i, src, tag) Arguments Type Intent Optional Attributes Name integer :: i integer, intent(in) :: src integer, intent(in), optional :: tag Contents None","tags":"","loc":"proc/receive_integer.html"},{"title":"receive_integer_array â€“ stella","text":"private subroutine receive_integer_array(i, src, tag) Arguments Type Intent Optional Attributes Name integer, dimension(:) :: i integer, intent(in) :: src integer, intent(in), optional :: tag Contents None","tags":"","loc":"proc/receive_integer_array.html"},{"title":"receive_real â€“ stella","text":"private subroutine receive_real(a, src, tag) Arguments Type Intent Optional Attributes Name real :: a integer, intent(in) :: src integer, intent(in), optional :: tag Contents None","tags":"","loc":"proc/receive_real.html"},{"title":"receive_real_array â€“ stella","text":"private subroutine receive_real_array(a, src, tag) Arguments Type Intent Optional Attributes Name real, dimension(:) :: a integer, intent(in) :: src integer, intent(in), optional :: tag Contents None","tags":"","loc":"proc/receive_real_array.html"},{"title":"receive_real_array_2d â€“ stella","text":"private subroutine receive_real_array_2d(a, src, tag) Arguments Type Intent Optional Attributes Name real, dimension(:, :) :: a integer, intent(in) :: src integer, intent(in), optional :: tag Contents None","tags":"","loc":"proc/receive_real_array_2d.html"},{"title":"receive_complex â€“ stella","text":"private subroutine receive_complex(z, src, tag) Arguments Type Intent Optional Attributes Name complex :: z integer, intent(in) :: src integer, intent(in), optional :: tag Contents None","tags":"","loc":"proc/receive_complex.html"},{"title":"receive_complex_array â€“ stella","text":"private subroutine receive_complex_array(z, src, tag) Arguments Type Intent Optional Attributes Name complex, dimension(:) :: z integer, intent(in) :: src integer, intent(in), optional :: tag Contents None","tags":"","loc":"proc/receive_complex_array.html"},{"title":"receive_complex_2array â€“ stella","text":"private subroutine receive_complex_2array(z, src, tag) Arguments Type Intent Optional Attributes Name complex, dimension(:, :) :: z integer, intent(in) :: src integer, intent(in), optional :: tag Contents None","tags":"","loc":"proc/receive_complex_2array.html"},{"title":"nonblocking_receive_complex_array â€“ stella","text":"private subroutine nonblocking_receive_complex_array(z, src, tag, request) Arguments Type Intent Optional Attributes Name complex, dimension(:) :: z integer, intent(in) :: src integer, intent(in), optional :: tag integer, intent(out) :: request Contents None","tags":"","loc":"proc/nonblocking_receive_complex_array.html"},{"title":"receive_logical â€“ stella","text":"private subroutine receive_logical(f, src, tag) Arguments Type Intent Optional Attributes Name logical :: f integer, intent(in) :: src integer, intent(in), optional :: tag Contents None","tags":"","loc":"proc/receive_logical.html"},{"title":"receive_logical_array â€“ stella","text":"private subroutine receive_logical_array(f, src, tag) Arguments Type Intent Optional Attributes Name logical, dimension(:) :: f integer, intent(in) :: src integer, intent(in), optional :: tag Contents None","tags":"","loc":"proc/receive_logical_array.html"},{"title":"receive_character â€“ stella","text":"private subroutine receive_character(s, src, tag) Arguments Type Intent Optional Attributes Name character :: s integer, intent(in) :: src integer, intent(in), optional :: tag Contents None","tags":"","loc":"proc/receive_character.html"},{"title":"waitany â€“ stella","text":"public subroutine waitany(count, requests, requestindex, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: count integer, intent(inout), dimension(:) :: requests integer, intent(out) :: requestindex integer, intent(out), dimension(1) :: status Contents None","tags":"","loc":"proc/waitany.html"},{"title":"all_to_group_real â€“ stella","text":"private subroutine all_to_group_real(all, group, njobs) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: all real, intent(out) :: group integer, intent(in) :: njobs Contents None","tags":"","loc":"proc/all_to_group_real.html"},{"title":"all_to_group_real_array â€“ stella","text":"private subroutine all_to_group_real_array(all, group, njobs) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: all real, intent(out), dimension(:) :: group integer, intent(in) :: njobs Contents None","tags":"","loc":"proc/all_to_group_real_array.html"},{"title":"group_to_all_real â€“ stella","text":"private subroutine group_to_all_real(group, all, njobs) Arguments Type Intent Optional Attributes Name real, intent(in) :: group real, intent(out), dimension(:) :: all integer, intent(in) :: njobs Contents None","tags":"","loc":"proc/group_to_all_real.html"},{"title":"group_to_all_real_array â€“ stella","text":"private subroutine group_to_all_real_array(group, all, njobs) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: group real, intent(out), dimension(:, :) :: all integer, intent(in) :: njobs Contents None","tags":"","loc":"proc/group_to_all_real_array.html"},{"title":"mp_abort â€“ stella","text":"public subroutine mp_abort(msg) Uses file_utils Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg Contents None","tags":"","loc":"proc/mp_abort.html"},{"title":"error â€“ stella","text":"private subroutine error(msg) Uses file_utils Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg Contents None","tags":"","loc":"proc/error.html"},{"title":"mp_gather â€“ stella","text":"public subroutine mp_gather(senddata, recvarray) Arguments Type Intent Optional Attributes Name integer, intent(in) :: senddata integer, intent(out), dimension(:) :: recvarray Contents None","tags":"","loc":"proc/mp_gather.html"},{"title":"broadcast_with_comm â€“ stella","text":"public subroutine broadcast_with_comm(x, comm) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: x integer, intent(in) :: comm Contents None","tags":"","loc":"proc/broadcast_with_comm.html"},{"title":"broadcast â€“ stella","text":"public interface broadcast Contents Module Procedures broadcast_integer broadcast_integer_array broadcast_real broadcast_real_array broadcast_real_2array broadcast_real_3array broadcast_real_4array broadcast_real_5array broadcast_complex broadcast_complex_array broadcast_complex_2array broadcast_complex_3array broadcast_complex_4array broadcast_logical broadcast_logical_array bcastfrom_integer bcastfrom_integer_array bcastfrom_real bcastfrom_real_array bcastfrom_complex bcastfrom_complex_array bcastfrom_complex_2array bcastfrom_logical bcastfrom_logical_array broadcast_character bcastfrom_character Module Procedures private subroutine broadcast_integer (i) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i private subroutine broadcast_integer_array (i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i private subroutine broadcast_real (x) Arguments Type Intent Optional Attributes Name real, intent(inout) :: x private subroutine broadcast_real_array (x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: x private subroutine broadcast_real_2array (x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :) :: x private subroutine broadcast_real_3array (x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :) :: x private subroutine broadcast_real_4array (x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :) :: x private subroutine broadcast_real_5array (x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :) :: x private subroutine broadcast_complex (z) Arguments Type Intent Optional Attributes Name complex, intent(inout) :: z private subroutine broadcast_complex_array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: z private subroutine broadcast_complex_2array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: z private subroutine broadcast_complex_3array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :) :: z private subroutine broadcast_complex_4array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :) :: z private subroutine broadcast_logical (f) Arguments Type Intent Optional Attributes Name logical, intent(inout) :: f private subroutine broadcast_logical_array (f) Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:) :: f private subroutine bcastfrom_integer (i, src) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i integer, intent(in) :: src private subroutine bcastfrom_integer_array (i, src) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i integer, intent(in) :: src private subroutine bcastfrom_real (x, src) Arguments Type Intent Optional Attributes Name real, intent(inout) :: x integer, intent(in) :: src private subroutine bcastfrom_real_array (x, src) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: x integer, intent(in) :: src private subroutine bcastfrom_complex (z, src) Arguments Type Intent Optional Attributes Name complex, intent(inout) :: z integer, intent(in) :: src private subroutine bcastfrom_complex_array (z, src) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: z integer, intent(in) :: src private subroutine bcastfrom_complex_2array (z, src) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: z integer, intent(in) :: src private subroutine bcastfrom_logical (f, src) Arguments Type Intent Optional Attributes Name logical, intent(inout) :: f integer, intent(in) :: src private subroutine bcastfrom_logical_array (f, src) Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:) :: f integer, intent(in) :: src private subroutine broadcast_character (char) Arguments Type Intent Optional Attributes Name character, intent(inout) :: char private subroutine bcastfrom_character (c, src) Arguments Type Intent Optional Attributes Name character, intent(inout) :: c integer, intent(in) :: src","tags":"","loc":"interface/broadcast.html"},{"title":"sum_reduce â€“ stella","text":"public interface sum_reduce Contents Module Procedures sum_reduce_integer sum_reduce_integer_array sum_reduce_real sum_reduce_real_array sum_reduce_real_2array sum_reduce_real_3array sum_reduce_real_4array sum_reduce_real_5array sum_reduce_complex sum_reduce_complex_array sum_reduce_complex_2array sum_reduce_complex_3array sum_reduce_complex_4array sum_reduce_complex_5array Module Procedures private subroutine sum_reduce_integer (i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i integer, intent(in) :: dest private subroutine sum_reduce_integer_array (i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i integer, intent(in) :: dest private subroutine sum_reduce_real (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a integer, intent(in) :: dest private subroutine sum_reduce_real_array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a integer, intent(in) :: dest private subroutine sum_reduce_real_2array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :) :: a integer, intent(in) :: dest private subroutine sum_reduce_real_3array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :) :: a integer, intent(in) :: dest private subroutine sum_reduce_real_4array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :) :: a integer, intent(in) :: dest private subroutine sum_reduce_real_5array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :) :: a integer, intent(in) :: dest private subroutine sum_reduce_complex (z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout) :: z integer, intent(in) :: dest private subroutine sum_reduce_complex_array (z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: z integer, intent(in) :: dest private subroutine sum_reduce_complex_2array (z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: z integer, intent(in) :: dest private subroutine sum_reduce_complex_3array (z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :) :: z integer, intent(in) :: dest private subroutine sum_reduce_complex_4array (z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :) :: z integer, intent(in) :: dest private subroutine sum_reduce_complex_5array (z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :, :) :: z integer, intent(in) :: dest","tags":"","loc":"interface/sum_reduce.html"},{"title":"sum_allreduce â€“ stella","text":"public interface sum_allreduce Contents Module Procedures sum_allreduce_integer sum_allreduce_integer_array sum_allreduce_integer_2array sum_allreduce_real sum_allreduce_real_array sum_allreduce_real_2array sum_allreduce_real_3array sum_allreduce_real_4array sum_allreduce_real_5array sum_allreduce_complex sum_allreduce_complex_array sum_allreduce_complex_2array sum_allreduce_complex_3array sum_allreduce_complex_4array sum_allreduce_complex_5array Module Procedures private subroutine sum_allreduce_integer (i) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i private subroutine sum_allreduce_integer_array (i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i private subroutine sum_allreduce_integer_2array (i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:, :) :: i private subroutine sum_allreduce_real (a) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a private subroutine sum_allreduce_real_array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a private subroutine sum_allreduce_real_2array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :) :: a private subroutine sum_allreduce_real_3array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :) :: a private subroutine sum_allreduce_real_4array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :) :: a private subroutine sum_allreduce_real_5array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :) :: a private subroutine sum_allreduce_complex (z) Arguments Type Intent Optional Attributes Name complex, intent(inout) :: z private subroutine sum_allreduce_complex_array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: z private subroutine sum_allreduce_complex_2array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: z private subroutine sum_allreduce_complex_3array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :) :: z private subroutine sum_allreduce_complex_4array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :) :: z private subroutine sum_allreduce_complex_5array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :, :) :: z","tags":"","loc":"interface/sum_allreduce.html"},{"title":"max_reduce â€“ stella","text":"public interface max_reduce Contents Module Procedures max_reduce_integer max_reduce_integer_array max_reduce_real max_reduce_real_array Module Procedures private subroutine max_reduce_integer (i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i integer, intent(in) :: dest private subroutine max_reduce_integer_array (i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i integer, intent(in) :: dest private subroutine max_reduce_real (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a integer, intent(in) :: dest private subroutine max_reduce_real_array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a integer, intent(in) :: dest","tags":"","loc":"interface/max_reduce.html"},{"title":"max_allreduce â€“ stella","text":"public interface max_allreduce Contents Module Procedures max_allreduce_integer max_allreduce_integer_array max_allreduce_real max_allreduce_real_array Module Procedures private subroutine max_allreduce_integer (i) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i private subroutine max_allreduce_integer_array (i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i private subroutine max_allreduce_real (a) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a private subroutine max_allreduce_real_array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a","tags":"","loc":"interface/max_allreduce.html"},{"title":"min_reduce â€“ stella","text":"public interface min_reduce Contents Module Procedures min_reduce_integer min_reduce_integer_array min_reduce_real min_reduce_real_array Module Procedures private subroutine min_reduce_integer (i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i integer, intent(in) :: dest private subroutine min_reduce_integer_array (i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i integer, intent(in) :: dest private subroutine min_reduce_real (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a integer, intent(in) :: dest private subroutine min_reduce_real_array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a integer, intent(in) :: dest","tags":"","loc":"interface/min_reduce.html"},{"title":"min_allreduce â€“ stella","text":"public interface min_allreduce Contents Module Procedures min_allreduce_integer min_allreduce_integer_array min_allreduce_real min_allreduce_real_array Module Procedures private subroutine min_allreduce_integer (i) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i private subroutine min_allreduce_integer_array (i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i private subroutine min_allreduce_real (a) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a private subroutine min_allreduce_real_array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a","tags":"","loc":"interface/min_allreduce.html"},{"title":"send â€“ stella","text":"public interface send Contents Module Procedures send_integer send_integer_array send_real send_real_array send_real_array_2d send_complex send_complex_array nonblocking_send_complex_array send_logical send_logical_array send_character Module Procedures private subroutine send_integer (i, dest, tag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine send_integer_array (i, dest, tag) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: i integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine send_real (a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine send_real_array (a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine send_real_array_2d (a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine send_complex (z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine send_complex_array (z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine nonblocking_send_complex_array (z, dest, tag, request) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag integer, intent(out) :: request private subroutine send_logical (f, dest, tag) Arguments Type Intent Optional Attributes Name logical, intent(in) :: f integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine send_logical_array (f, dest, tag) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:) :: f integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine send_character (s, dest, tag) Arguments Type Intent Optional Attributes Name character, intent(in) :: s integer, intent(in) :: dest integer, intent(in), optional :: tag","tags":"","loc":"interface/send.html"},{"title":"receive â€“ stella","text":"public interface receive Contents Module Procedures receive_integer receive_integer_array receive_real receive_real_array receive_real_array_2d receive_complex receive_complex_array receive_complex_2array nonblocking_receive_complex_array receive_logical receive_logical_array receive_character Module Procedures private subroutine receive_integer (i, src, tag) Arguments Type Intent Optional Attributes Name integer :: i integer, intent(in) :: src integer, intent(in), optional :: tag private subroutine receive_integer_array (i, src, tag) Arguments Type Intent Optional Attributes Name integer, dimension(:) :: i integer, intent(in) :: src integer, intent(in), optional :: tag private subroutine receive_real (a, src, tag) Arguments Type Intent Optional Attributes Name real :: a integer, intent(in) :: src integer, intent(in), optional :: tag private subroutine receive_real_array (a, src, tag) Arguments Type Intent Optional Attributes Name real, dimension(:) :: a integer, intent(in) :: src integer, intent(in), optional :: tag private subroutine receive_real_array_2d (a, src, tag) Arguments Type Intent Optional Attributes Name real, dimension(:, :) :: a integer, intent(in) :: src integer, intent(in), optional :: tag private subroutine receive_complex (z, src, tag) Arguments Type Intent Optional Attributes Name complex :: z integer, intent(in) :: src integer, intent(in), optional :: tag private subroutine receive_complex_array (z, src, tag) Arguments Type Intent Optional Attributes Name complex, dimension(:) :: z integer, intent(in) :: src integer, intent(in), optional :: tag private subroutine receive_complex_2array (z, src, tag) Arguments Type Intent Optional Attributes Name complex, dimension(:, :) :: z integer, intent(in) :: src integer, intent(in), optional :: tag private subroutine nonblocking_receive_complex_array (z, src, tag, request) Arguments Type Intent Optional Attributes Name complex, dimension(:) :: z integer, intent(in) :: src integer, intent(in), optional :: tag integer, intent(out) :: request private subroutine receive_logical (f, src, tag) Arguments Type Intent Optional Attributes Name logical :: f integer, intent(in) :: src integer, intent(in), optional :: tag private subroutine receive_logical_array (f, src, tag) Arguments Type Intent Optional Attributes Name logical, dimension(:) :: f integer, intent(in) :: src integer, intent(in), optional :: tag private subroutine receive_character (s, src, tag) Arguments Type Intent Optional Attributes Name character :: s integer, intent(in) :: src integer, intent(in), optional :: tag","tags":"","loc":"interface/receive.html"},{"title":"ssend â€“ stella","text":"public interface ssend Contents Module Procedures ssend_integer ssend_integer_array ssend_real ssend_real_array ssend_complex ssend_complex_array ssend_complex_2array ssend_logical ssend_logical_array Module Procedures private subroutine ssend_integer (i, dest, tag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine ssend_integer_array (i, dest, tag) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: i integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine ssend_real (a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine ssend_real_array (a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine ssend_complex (z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine ssend_complex_array (z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine ssend_complex_2array (z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine ssend_logical (f, dest, tag) Arguments Type Intent Optional Attributes Name logical, intent(in) :: f integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine ssend_logical_array (f, dest, tag) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:) :: f integer, intent(in) :: dest integer, intent(in), optional :: tag","tags":"","loc":"interface/ssend.html"},{"title":"all_to_group â€“ stella","text":"public interface all_to_group Contents Module Procedures all_to_group_real all_to_group_real_array Module Procedures private subroutine all_to_group_real (all, group, njobs) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: all real, intent(out) :: group integer, intent(in) :: njobs private subroutine all_to_group_real_array (all, group, njobs) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: all real, intent(out), dimension(:) :: group integer, intent(in) :: njobs","tags":"","loc":"interface/all_to_group.html"},{"title":"group_to_all â€“ stella","text":"public interface group_to_all Contents Module Procedures group_to_all_real group_to_all_real_array Module Procedures private subroutine group_to_all_real (group, all, njobs) Arguments Type Intent Optional Attributes Name real, intent(in) :: group real, intent(out), dimension(:) :: all integer, intent(in) :: njobs private subroutine group_to_all_real_array (group, all, njobs) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: group real, intent(out), dimension(:, :) :: all integer, intent(in) :: njobs","tags":"","loc":"interface/group_to_all.html"},{"title":"get_option_value â€“ stella","text":"public subroutine get_option_value(selection, options, value, error_unit, selection_name, stop_on_error) Uses mp Arguments Type Intent Optional Attributes Name character, intent(in) :: selection type( text_option ), intent(in), dimension(:) :: options integer, intent(inout) :: value integer, intent(in), optional :: error_unit character, intent(in), optional :: selection_name logical, intent(in), optional :: stop_on_error Contents None","tags":"","loc":"proc/get_option_value.html"},{"title":"grnd â€“ stella","text":"public function grnd() Arguments None Return Value real Contents None","tags":"","loc":"proc/grnd.html"},{"title":"sgrnd â€“ stella","text":"public subroutine sgrnd(seed) Arguments Type Intent Optional Attributes Name integer, intent(in) :: seed Contents None","tags":"","loc":"proc/sgrnd.html"},{"title":"set_redist_character_type â€“ stella","text":"public subroutine set_redist_character_type(r, chartype) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r character(len=3), intent(in) :: chartype Contents None","tags":"","loc":"proc/set_redist_character_type.html"},{"title":"init_redist â€“ stella","text":"public subroutine init_redist(r, char, to_low, to_high, to_list, from_low, from_high, from_list, ierr) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r character(len=1), intent(in) :: char integer, intent(in), dimension(:) :: to_low integer, intent(in), dimension(:) :: to_high type( index_list_type ), intent(in), dimension(0:nproc - 1) :: to_list integer, intent(in), dimension(:) :: from_low integer, intent(in), dimension(:) :: from_high type( index_list_type ), intent(in), dimension(0:nproc - 1) :: from_list integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/init_redist.html"},{"title":"init_fill â€“ stella","text":"public subroutine init_fill(f, char, to_low, to_list, from_low, from_list, ierr) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(out) :: f character(len=1), intent(in) :: char integer, intent(in), dimension(:) :: to_low type( index_list_type ), intent(in), dimension(0:nproc - 1) :: to_list integer, intent(in), dimension(:) :: from_low type( index_list_type ), intent(in), dimension(0:nproc - 1) :: from_list integer, intent(out), optional :: ierr Contents None","tags":"","loc":"proc/init_fill.html"},{"title":"delete_redist â€“ stella","text":"public subroutine delete_redist(r) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r Contents None","tags":"","loc":"proc/delete_redist.html"},{"title":"delete_list â€“ stella","text":"public subroutine delete_list(list) Uses mp Arguments Type Intent Optional Attributes Name type( index_list_type ), intent(inout), dimension(0:nproc - 1) :: list Contents None","tags":"","loc":"proc/delete_list.html"},{"title":"c_redist_12 â€“ stella","text":"private subroutine c_redist_12(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here Contents None","tags":"","loc":"proc/c_redist_12.html"},{"title":"c_redist_22 â€“ stella","text":"private subroutine c_redist_22(r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here Contents None","tags":"","loc":"proc/c_redist_22.html"},{"title":"c_redist_22_old_copy â€“ stella","text":"private subroutine c_redist_22_old_copy(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here Contents None","tags":"","loc":"proc/c_redist_22_old_copy.html"},{"title":"c_redist_22_mpi_copy â€“ stella","text":"private subroutine c_redist_22_mpi_copy(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here Contents None","tags":"","loc":"proc/c_redist_22_mpi_copy.html"},{"title":"c_redist_22_inv â€“ stella","text":"private subroutine c_redist_22_inv(r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here Contents None","tags":"","loc":"proc/c_redist_22_inv.html"},{"title":"c_redist_22_inv_old_copy â€“ stella","text":"private subroutine c_redist_22_inv_old_copy(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here Contents None","tags":"","loc":"proc/c_redist_22_inv_old_copy.html"},{"title":"c_redist_22_inv_mpi_copy â€“ stella","text":"private subroutine c_redist_22_inv_mpi_copy(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here Contents None","tags":"","loc":"proc/c_redist_22_inv_mpi_copy.html"},{"title":"c_redist_32 â€“ stella","text":"private subroutine c_redist_32(r, from_here, to_here) Uses job_manage Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here Contents None","tags":"","loc":"proc/c_redist_32.html"},{"title":"c_redist_32_old_copy â€“ stella","text":"private subroutine c_redist_32_old_copy(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here Contents None","tags":"","loc":"proc/c_redist_32_old_copy.html"},{"title":"c_redist_32_mpi_copy â€“ stella","text":"private subroutine c_redist_32_mpi_copy(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here Contents None","tags":"","loc":"proc/c_redist_32_mpi_copy.html"},{"title":"c_redist_32_inv â€“ stella","text":"private subroutine c_redist_32_inv(r, from_here, to_here) Uses job_manage Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here Contents None","tags":"","loc":"proc/c_redist_32_inv.html"},{"title":"c_redist_32_inv_old_copy â€“ stella","text":"private subroutine c_redist_32_inv_old_copy(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here Contents None","tags":"","loc":"proc/c_redist_32_inv_old_copy.html"},{"title":"c_redist_32_inv_mpi_copy â€“ stella","text":"private subroutine c_redist_32_inv_mpi_copy(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here Contents None","tags":"","loc":"proc/c_redist_32_inv_mpi_copy.html"},{"title":"c_redist_42 â€“ stella","text":"private subroutine c_redist_42(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here Contents None","tags":"","loc":"proc/c_redist_42.html"},{"title":"c_redist_42_inv â€“ stella","text":"private subroutine c_redist_42_inv(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: to_here Contents None","tags":"","loc":"proc/c_redist_42_inv.html"},{"title":"c_redist_23 â€“ stella","text":"private subroutine c_redist_23(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):) :: to_here Contents None","tags":"","loc":"proc/c_redist_23.html"},{"title":"c_redist_34 â€“ stella","text":"private subroutine c_redist_34(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):) :: to_here Contents None","tags":"","loc":"proc/c_redist_34.html"},{"title":"c_redist_34_inv â€“ stella","text":"private subroutine c_redist_34_inv(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here Contents None","tags":"","loc":"proc/c_redist_34_inv.html"},{"title":"r_redist_34 â€“ stella","text":"private subroutine r_redist_34(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):) :: to_here Contents None","tags":"","loc":"proc/r_redist_34.html"},{"title":"r_redist_34_inv â€“ stella","text":"private subroutine r_redist_34_inv(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here Contents None","tags":"","loc":"proc/r_redist_34_inv.html"},{"title":"c_redist_35 â€“ stella","text":"private subroutine c_redist_35(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):, r%to_low(5):) :: to_here Contents None","tags":"","loc":"proc/c_redist_35.html"},{"title":"r_redist_35 â€“ stella","text":"private subroutine r_redist_35(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):, r%to_low(5):) :: to_here Contents None","tags":"","loc":"proc/r_redist_35.html"},{"title":"c_redist_35_inv â€“ stella","text":"private subroutine c_redist_35_inv(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):, r%to_low(5):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here Contents None","tags":"","loc":"proc/c_redist_35_inv.html"},{"title":"r_redist_35_inv â€“ stella","text":"private subroutine r_redist_35_inv(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):, r%to_low(5):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here Contents None","tags":"","loc":"proc/r_redist_35_inv.html"},{"title":"r_redist_12 â€“ stella","text":"private subroutine r_redist_12(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here Contents None","tags":"","loc":"proc/r_redist_12.html"},{"title":"r_redist_22 â€“ stella","text":"private subroutine r_redist_22(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here Contents None","tags":"","loc":"proc/r_redist_22.html"},{"title":"r_redist_22_inv â€“ stella","text":"private subroutine r_redist_22_inv(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here Contents None","tags":"","loc":"proc/r_redist_22_inv.html"},{"title":"r_redist_32 â€“ stella","text":"private subroutine r_redist_32(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here Contents None","tags":"","loc":"proc/r_redist_32.html"},{"title":"r_redist_32_inv â€“ stella","text":"private subroutine r_redist_32_inv(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here Contents None","tags":"","loc":"proc/r_redist_32_inv.html"},{"title":"r_redist_42 â€“ stella","text":"private subroutine r_redist_42(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here Contents None","tags":"","loc":"proc/r_redist_42.html"},{"title":"r_redist_42_inv â€“ stella","text":"private subroutine r_redist_42_inv(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: to_here Contents None","tags":"","loc":"proc/r_redist_42_inv.html"},{"title":"i_redist_12 â€“ stella","text":"private subroutine i_redist_12(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%from_low(1):) :: from_here integer, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here Contents None","tags":"","loc":"proc/i_redist_12.html"},{"title":"i_redist_22 â€“ stella","text":"private subroutine i_redist_22(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here integer, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here Contents None","tags":"","loc":"proc/i_redist_22.html"},{"title":"i_redist_22_inv â€“ stella","text":"private subroutine i_redist_22_inv(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here integer, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here Contents None","tags":"","loc":"proc/i_redist_22_inv.html"},{"title":"i_redist_32 â€“ stella","text":"private subroutine i_redist_32(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here integer, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here Contents None","tags":"","loc":"proc/i_redist_32.html"},{"title":"i_redist_32_inv â€“ stella","text":"private subroutine i_redist_32_inv(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here integer, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here Contents None","tags":"","loc":"proc/i_redist_32_inv.html"},{"title":"i_redist_42 â€“ stella","text":"private subroutine i_redist_42(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: from_here integer, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here Contents None","tags":"","loc":"proc/i_redist_42.html"},{"title":"i_redist_42_inv â€“ stella","text":"private subroutine i_redist_42_inv(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here integer, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: to_here Contents None","tags":"","loc":"proc/i_redist_42_inv.html"},{"title":"l_redist_12 â€“ stella","text":"private subroutine l_redist_12(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%from_low(1):) :: from_here logical, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here Contents None","tags":"","loc":"proc/l_redist_12.html"},{"title":"l_redist_22 â€“ stella","text":"private subroutine l_redist_22(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here logical, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here Contents None","tags":"","loc":"proc/l_redist_22.html"},{"title":"l_redist_22_inv â€“ stella","text":"private subroutine l_redist_22_inv(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here logical, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here Contents None","tags":"","loc":"proc/l_redist_22_inv.html"},{"title":"l_redist_32 â€“ stella","text":"private subroutine l_redist_32(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here logical, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here Contents None","tags":"","loc":"proc/l_redist_32.html"},{"title":"l_redist_32_inv â€“ stella","text":"private subroutine l_redist_32_inv(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here logical, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here Contents None","tags":"","loc":"proc/l_redist_32_inv.html"},{"title":"l_redist_42 â€“ stella","text":"private subroutine l_redist_42(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: from_here logical, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here Contents None","tags":"","loc":"proc/l_redist_42.html"},{"title":"l_redist_42_inv â€“ stella","text":"private subroutine l_redist_42_inv(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here logical, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: to_here Contents None","tags":"","loc":"proc/l_redist_42_inv.html"},{"title":"c_redist_33 â€“ stella","text":"private subroutine c_redist_33(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):) :: to_here Contents None","tags":"","loc":"proc/c_redist_33.html"},{"title":"c_redist_33_inv â€“ stella","text":"private subroutine c_redist_33_inv(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here Contents None","tags":"","loc":"proc/c_redist_33_inv.html"},{"title":"c_fill_2 â€“ stella","text":"private subroutine c_fill_2(f, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f complex, intent(in), dimension(f%from_low(1):, f%from_low(2):) :: from_here complex, intent(inout), dimension(f%to_low(1):, f%to_low(2):) :: to_here Contents None","tags":"","loc":"proc/c_fill_2.html"},{"title":"c_fill_3 â€“ stella","text":"private subroutine c_fill_3(f, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f complex, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):) :: from_here complex, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):) :: to_here Contents None","tags":"","loc":"proc/c_fill_3.html"},{"title":"c_fill_4 â€“ stella","text":"private subroutine c_fill_4(f, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f complex, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):, f%from_low(4):) :: from_here complex, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):, f%to_low(4):) :: to_here Contents None","tags":"","loc":"proc/c_fill_4.html"},{"title":"r_fill_2 â€“ stella","text":"private subroutine r_fill_2(f, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f real, intent(in), dimension(f%from_low(1):, f%from_low(2):) :: from_here real, intent(inout), dimension(f%to_low(1):, f%to_low(2):) :: to_here Contents None","tags":"","loc":"proc/r_fill_2.html"},{"title":"r_fill_3 â€“ stella","text":"private subroutine r_fill_3(f, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f real, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):) :: from_here real, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):) :: to_here Contents None","tags":"","loc":"proc/r_fill_3.html"},{"title":"r_fill_4 â€“ stella","text":"private subroutine r_fill_4(f, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f real, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):, f%from_low(4):) :: from_here real, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):, f%to_low(4):) :: to_here Contents None","tags":"","loc":"proc/r_fill_4.html"},{"title":"i_fill_2 â€“ stella","text":"private subroutine i_fill_2(f, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f integer, intent(in), dimension(f%from_low(1):, f%from_low(2):) :: from_here integer, intent(inout), dimension(f%to_low(1):, f%to_low(2):) :: to_here Contents None","tags":"","loc":"proc/i_fill_2.html"},{"title":"i_fill_3 â€“ stella","text":"private subroutine i_fill_3(f, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f integer, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):) :: from_here integer, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):) :: to_here Contents None","tags":"","loc":"proc/i_fill_3.html"},{"title":"i_fill_4 â€“ stella","text":"private subroutine i_fill_4(f, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f integer, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):, f%from_low(4):) :: from_here integer, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):, f%to_low(4):) :: to_here Contents None","tags":"","loc":"proc/i_fill_4.html"},{"title":"l_fill_2 â€“ stella","text":"private subroutine l_fill_2(f, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f logical, intent(in), dimension(f%from_low(1):, f%from_low(2):) :: from_here logical, intent(inout), dimension(f%to_low(1):, f%to_low(2):) :: to_here Contents None","tags":"","loc":"proc/l_fill_2.html"},{"title":"l_fill_3 â€“ stella","text":"private subroutine l_fill_3(f, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f logical, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):) :: from_here logical, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):) :: to_here Contents None","tags":"","loc":"proc/l_fill_3.html"},{"title":"l_fill_4 â€“ stella","text":"private subroutine l_fill_4(f, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f logical, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):, f%from_low(4):) :: from_here logical, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):, f%to_low(4):) :: to_here Contents None","tags":"","loc":"proc/l_fill_4.html"},{"title":"report_map_property â€“ stella","text":"public subroutine report_map_property(r) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(in) :: r Contents None","tags":"","loc":"proc/report_map_property.html"},{"title":"measure_gather_32 â€“ stella","text":"private subroutine measure_gather_32(map, gin, gout) Uses job_manage mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :, :) :: gin complex, intent(out), dimension(:, :) :: gout Contents None","tags":"","loc":"proc/measure_gather_32.html"},{"title":"measure_scatter_23 â€“ stella","text":"private subroutine measure_scatter_23(map, gin, gout) Uses job_manage mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :, :) :: gout Contents None","tags":"","loc":"proc/measure_scatter_23.html"},{"title":"measure_gather_33 â€“ stella","text":"private subroutine measure_gather_33(map, gin, gout) Uses job_manage mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :, :) :: gin complex, intent(out), dimension(:, :, :) :: gout Contents None","tags":"","loc":"proc/measure_gather_33.html"},{"title":"measure_scatter_33 â€“ stella","text":"private subroutine measure_scatter_33(map, gin, gout) Uses job_manage mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :, :) :: gin complex, intent(out), dimension(:, :, :) :: gout Contents None","tags":"","loc":"proc/measure_scatter_33.html"},{"title":"measure_gather_22 â€“ stella","text":"private subroutine measure_gather_22(map, gin, gout) Uses job_manage mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout Contents None","tags":"","loc":"proc/measure_gather_22.html"},{"title":"measure_scatter_22 â€“ stella","text":"private subroutine measure_scatter_22(map, gin, gout) Uses job_manage mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout Contents None","tags":"","loc":"proc/measure_scatter_22.html"},{"title":"gather â€“ stella","text":"public interface gather Contents Module Procedures c_redist_22 r_redist_22 i_redist_22 l_redist_22 c_redist_32 r_redist_32 i_redist_32 l_redist_32 c_redist_42 r_redist_42 i_redist_42 l_redist_42 c_redist_23 c_redist_34 r_redist_34 c_redist_33 c_redist_35 r_redist_35 Module Procedures private subroutine c_redist_22 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine r_redist_22 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine i_redist_22 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here integer, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine l_redist_22 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here logical, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine c_redist_32 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine r_redist_32 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine i_redist_32 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here integer, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine l_redist_32 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here logical, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine c_redist_42 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine r_redist_42 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine i_redist_42 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: from_here integer, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine l_redist_42 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: from_here logical, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine c_redist_23 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):) :: to_here private subroutine c_redist_34 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):) :: to_here private subroutine r_redist_34 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):) :: to_here private subroutine c_redist_33 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):) :: to_here private subroutine c_redist_35 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):, r%to_low(5):) :: to_here private subroutine r_redist_35 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):, r%to_low(5):) :: to_here","tags":"","loc":"interface/gather.html"},{"title":"scatter â€“ stella","text":"public interface scatter Contents Module Procedures c_redist_12 r_redist_12 i_redist_12 l_redist_12 c_redist_22_inv r_redist_22_inv i_redist_22_inv l_redist_22_inv c_redist_32_inv r_redist_32_inv i_redist_32_inv l_redist_32_inv c_redist_42_inv r_redist_42_inv i_redist_42_inv l_redist_42_inv c_redist_33_inv c_redist_34_inv r_redist_34_inv c_redist_35_inv r_redist_35_inv Module Procedures private subroutine c_redist_12 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine r_redist_12 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine i_redist_12 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%from_low(1):) :: from_here integer, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine l_redist_12 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%from_low(1):) :: from_here logical, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine c_redist_22_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here private subroutine r_redist_22_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here private subroutine i_redist_22_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here integer, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here private subroutine l_redist_22_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here logical, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here private subroutine c_redist_32_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private subroutine r_redist_32_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private subroutine i_redist_32_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here integer, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private subroutine l_redist_32_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here logical, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private subroutine c_redist_42_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: to_here private subroutine r_redist_42_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: to_here private subroutine i_redist_42_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here integer, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: to_here private subroutine l_redist_42_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here logical, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: to_here private subroutine c_redist_33_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private subroutine c_redist_34_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private subroutine r_redist_34_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private subroutine c_redist_35_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):, r%to_low(5):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private subroutine r_redist_35_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):, r%to_low(5):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here","tags":"","loc":"interface/scatter.html"},{"title":"measure_gather â€“ stella","text":"public interface measure_gather Contents Module Procedures measure_gather_32 measure_gather_33 measure_gather_22 Module Procedures private subroutine measure_gather_32 (map, gin, gout) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :, :) :: gin complex, intent(out), dimension(:, :) :: gout private subroutine measure_gather_33 (map, gin, gout) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :, :) :: gin complex, intent(out), dimension(:, :, :) :: gout private subroutine measure_gather_22 (map, gin, gout) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout","tags":"","loc":"interface/measure_gather.html"},{"title":"measure_scatter â€“ stella","text":"public interface measure_scatter Contents Module Procedures measure_scatter_23 measure_scatter_33 measure_scatter_22 Module Procedures private subroutine measure_scatter_23 (map, gin, gout) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :, :) :: gout private subroutine measure_scatter_33 (map, gin, gout) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :, :) :: gin complex, intent(out), dimension(:, :, :) :: gout private subroutine measure_scatter_22 (map, gin, gout) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout","tags":"","loc":"interface/measure_scatter.html"},{"title":"fill â€“ stella","text":"public interface fill Contents Module Procedures c_fill_2 c_fill_3 c_fill_4 r_fill_2 r_fill_3 r_fill_4 i_fill_2 i_fill_3 i_fill_4 l_fill_2 l_fill_3 l_fill_4 Module Procedures private subroutine c_fill_2 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f complex, intent(in), dimension(f%from_low(1):, f%from_low(2):) :: from_here complex, intent(inout), dimension(f%to_low(1):, f%to_low(2):) :: to_here private subroutine c_fill_3 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f complex, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):) :: from_here complex, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):) :: to_here private subroutine c_fill_4 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f complex, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):, f%from_low(4):) :: from_here complex, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):, f%to_low(4):) :: to_here private subroutine r_fill_2 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f real, intent(in), dimension(f%from_low(1):, f%from_low(2):) :: from_here real, intent(inout), dimension(f%to_low(1):, f%to_low(2):) :: to_here private subroutine r_fill_3 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f real, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):) :: from_here real, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):) :: to_here private subroutine r_fill_4 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f real, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):, f%from_low(4):) :: from_here real, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):, f%to_low(4):) :: to_here private subroutine i_fill_2 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f integer, intent(in), dimension(f%from_low(1):, f%from_low(2):) :: from_here integer, intent(inout), dimension(f%to_low(1):, f%to_low(2):) :: to_here private subroutine i_fill_3 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f integer, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):) :: from_here integer, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):) :: to_here private subroutine i_fill_4 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f integer, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):, f%from_low(4):) :: from_here integer, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):, f%to_low(4):) :: to_here private subroutine l_fill_2 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f logical, intent(in), dimension(f%from_low(1):, f%from_low(2):) :: from_here logical, intent(inout), dimension(f%to_low(1):, f%to_low(2):) :: to_here private subroutine l_fill_3 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f logical, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):) :: from_here logical, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):) :: to_here private subroutine l_fill_4 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f logical, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):, f%from_low(4):) :: from_here logical, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):, f%to_low(4):) :: to_here","tags":"","loc":"interface/fill.html"},{"title":"timer_local â€“ stella","text":"public function timer_local() Arguments None Return Value real Contents None","tags":"","loc":"proc/timer_local.html"},{"title":"time_message â€“ stella","text":"public subroutine time_message(lprint, targ, chmessage) Arguments Type Intent Optional Attributes Name logical, intent(in) :: lprint real, intent(inout) :: targ (2) character(len=*), intent(in) :: chmessage Contents None","tags":"","loc":"proc/time_message.html"},{"title":"job_fork â€“ stella","text":"public subroutine job_fork(n_ensembles) Uses mp file_utils Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: n_ensembles Contents None","tags":"","loc":"proc/job_fork.html"},{"title":"checkstop â€“ stella","text":"public subroutine checkstop(exit, list) Uses mp file_utils Arguments Type Intent Optional Attributes Name logical, intent(inout) :: exit logical, intent(in), optional :: list Contents None","tags":"","loc":"proc/checkstop.html"},{"title":"checktime â€“ stella","text":"public subroutine checktime(avail_time, exit) Uses mp file_utils Arguments Type Intent Optional Attributes Name real, intent(in) :: avail_time logical, intent(inout) :: exit Contents None","tags":"","loc":"proc/checktime.html"},{"title":"ranf â€“ stella","text":"public function ranf(seed) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: seed Return Value real Contents None","tags":"","loc":"proc/ranf.html"},{"title":"get_rnd_seed_length â€“ stella","text":"public function get_rnd_seed_length() result(l) Arguments None Return Value integer Contents None","tags":"","loc":"proc/get_rnd_seed_length.html"},{"title":"get_rnd_seed â€“ stella","text":"public subroutine get_rnd_seed(seed) Arguments Type Intent Optional Attributes Name integer, intent(out), dimension(:) :: seed Contents None","tags":"","loc":"proc/get_rnd_seed.html"},{"title":"init_ranf â€“ stella","text":"public subroutine init_ranf(randomize, init_seed, mult) Arguments Type Intent Optional Attributes Name logical, intent(in) :: randomize integer, intent(inout), dimension(:) :: init_seed integer, intent(in), optional :: mult Contents None","tags":"","loc":"proc/init_ranf.html"},{"title":"get_git_version â€“ stella","text":"module procedure get_git_version module module function get_git_version() Interface â†’ Arguments None Return Value character,\n  allocatable Contents None","tags":"","loc":"proc/get_git_version.html"},{"title":"get_git_hash â€“ stella","text":"module procedure get_git_hash module module function get_git_hash(length_in) Interface â†’ Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: length_in Return Value character,\n  allocatable Contents None","tags":"","loc":"proc/get_git_hash.html"},{"title":"get_git_state â€“ stella","text":"module procedure get_git_state module module function get_git_state() Interface â†’ Arguments None Return Value character,\n  allocatable Contents None","tags":"","loc":"proc/get_git_state.html"},{"title":"get_git_date â€“ stella","text":"module procedure get_git_date module module function get_git_date() Interface â†’ Arguments None Return Value character(len=10) Contents None","tags":"","loc":"proc/get_git_date.html"},{"title":"stella_io â€“ stella","text":"Contents Variables zero Subroutines init_stella_io define_dims finish_stella_io save_input define_vars write_time_nc write_phi2_nc write_phi_nc write_omega_nc write_radial_fluxes_nc write_radial_moments_nc write_kspectra_nc write_fluxes_kxkyz_nc write_moments_nc write_gvmus_nc write_gzvs_nc nc_grids nc_species nc_geo get_nout sync_nc Variables Type Visibility Attributes Name Initial real, private :: zero Subroutines public subroutine init_stella_io (restart, write_phi_vs_t, write_kspectra, write_gvmus, write_gzvs, write_moments, write_omega, write_radial_fluxes, write_radial_moments, write_fluxes_kxky) Arguments Type Intent Optional Attributes Name logical, intent(in) :: restart logical, intent(in) :: write_phi_vs_t logical, intent(in) :: write_kspectra logical, intent(in) :: write_gvmus logical, intent(in) :: write_gzvs logical, intent(in) :: write_moments logical, intent(in) :: write_omega logical, intent(in) :: write_radial_fluxes logical, intent(in) :: write_radial_moments logical, intent(in) :: write_fluxes_kxky private subroutine define_dims () Arguments None public subroutine finish_stella_io () Arguments None private subroutine save_input () doc> Save the input file in the NetCDF file Arguments None private subroutine define_vars (write_phi_vs_t, write_kspectra, write_gvmus, write_gzvs, write_moments, write_omega, write_radial_fluxes, write_radial_moments, write_fluxes_kxky) Arguments Type Intent Optional Attributes Name logical, intent(in) :: write_phi_vs_t logical, intent(in) :: write_kspectra logical, intent(in) :: write_gvmus logical, intent(in) :: write_gzvs logical, intent(in) :: write_moments logical, intent(in) :: write_omega logical, intent(in) :: write_radial_fluxes logical, intent(in) :: write_radial_moments logical, intent(in) :: write_fluxes_kxky public subroutine write_time_nc (nout, time) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout real, intent(in) :: time public subroutine write_phi2_nc (nout, phi2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout real, intent(in) :: phi2 public subroutine write_phi_nc (nout, phi) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi public subroutine write_omega_nc (nout, omega) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout complex, intent(in), dimension(:, :) :: omega public subroutine write_radial_fluxes_nc (nout, pflux, vflux, qflux) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout real, intent(in), dimension(:, :) :: pflux real, intent(in), dimension(:, :) :: vflux real, intent(in), dimension(:, :) :: qflux public subroutine write_radial_moments_nc (nout, dens_x, upar_x, temp_x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout real, intent(in), dimension(:, :) :: dens_x real, intent(in), dimension(:, :) :: upar_x real, intent(in), dimension(:, :) :: temp_x public subroutine write_kspectra_nc (nout, phi2_vs_kxky) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout real, intent(in), dimension(:, :) :: phi2_vs_kxky public subroutine write_fluxes_kxkyz_nc (nout, pflx_kxkyz, vflx_kxkyz, qflx_kxkyz) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout real, intent(in), dimension(:, :, :, :, :) :: pflx_kxkyz real, intent(in), dimension(:, :, :, :, :) :: vflx_kxkyz real, intent(in), dimension(:, :, :, :, :) :: qflx_kxkyz public subroutine write_moments_nc (nout, density, upar, temperature, spitzer2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout complex, intent(in), dimension(:, :, :, :, :) :: density complex, intent(in), dimension(:, :, :, :, :) :: upar complex, intent(in), dimension(:, :, :, :, :) :: temperature complex, intent(in), dimension(:, :, :, :, :) :: spitzer2 public subroutine write_gvmus_nc (nout, g) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout real, intent(in), dimension(:, :, :) :: g public subroutine write_gzvs_nc (nout, g) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout real, intent(in), dimension(:, :, :, :) :: g private subroutine nc_grids () Arguments None private subroutine nc_species () Arguments None private subroutine nc_geo () Arguments None public subroutine get_nout (tstart, nout) Get the index of the time dimension in the netCDF file that corresponds to\na time no larger than tstart Arguments Type Intent Optional Attributes Name real, intent(in) :: tstart Simulation time to find integer, intent(out) :: nout Index of time dimension public subroutine sync_nc () Arguments None","tags":"","loc":"module/stella_io.html"},{"title":"physics_flags â€“ stella","text":"Contents Variables full_flux_surface radial_variation include_parallel_nonlinearity include_parallel_streaming include_pressure_variation include_geometric_variation include_mirror nonlinear prp_shear_enabled hammett_flow_shear const_alpha_geo adiabatic_option_switch adiabatic_option_default adiabatic_option_zero adiabatic_option_fieldlineavg initialized Subroutines init_physics_flags read_parameters finish_physics_flags Variables Type Visibility Attributes Name Initial logical, public :: full_flux_surface logical, public :: radial_variation logical, public :: include_parallel_nonlinearity logical, public :: include_parallel_streaming logical, public :: include_pressure_variation logical, public :: include_geometric_variation logical, public :: include_mirror logical, public :: nonlinear logical, public :: prp_shear_enabled logical, public :: hammett_flow_shear logical, public :: const_alpha_geo integer, public :: adiabatic_option_switch integer, private, parameter :: adiabatic_option_default = 1 integer, private, parameter :: adiabatic_option_zero = 2 integer, public, parameter :: adiabatic_option_fieldlineavg = 3 logical, private :: initialized = .false. Subroutines public subroutine init_physics_flags () Arguments None private subroutine read_parameters () Arguments None public subroutine finish_physics_flags () Arguments None","tags":"","loc":"module/physics_flags.html"},{"title":"extended_zgrid â€“ stella","text":"Contents Variables nzed_segment neigen iz_low iz_mid iz_up nsegments ikxmod it_left it_right phase_shift periodic extended_zgrid_initialized Subroutines init_extended_zgrid fill_zed_ghost_zones map_to_extended_zgrid map_from_extended_zgrid finish_extended_zgrid Variables Type Visibility Attributes Name Initial integer, public :: nzed_segment these arrays needed to keep track of connections between different\n2pi segments integer, public, dimension(:), allocatable :: neigen integer, public, dimension(:), allocatable :: iz_low integer, public, dimension(:), allocatable :: iz_mid integer, public, dimension(:), allocatable :: iz_up integer, public, dimension(:, :), allocatable :: nsegments integer, public, dimension(:, :, :), allocatable :: ikxmod integer, public, dimension(:), allocatable :: it_left arrays indicate which flux tube index to connect to\non the left and on the right\nas a function of current flux tube index\npre-compute to avoid conditionals in loops integer, public, dimension(:), allocatable :: it_right arrays indicate which flux tube index to connect to\non the left and on the right\nas a function of current flux tube index\npre-compute to avoid conditionals in loops complex, public, dimension(:), allocatable :: phase_shift logical, public, dimension(:), allocatable :: periodic logical, public :: extended_zgrid_initialized = .false. Subroutines public subroutine init_extended_zgrid () all periodic modes (e.g., the zonal mode) have no connections\nphi(kx-kx_shift,-nzgrid) = phi(kx,nzgrid) from twist-and-shift BC\nfor positive (negative) magnetic shear, kx_shift is positive (negative),\nso start at most positive (negative) kx and\nprogress to smaller (larger) kx values as connections occur\nfigure out how much to shift ikx by to get to the end of the kx chain\nfor positive (negative) magnetic shear, this is the left-most (right-most) theta-theta0\nin each set of connected 2pi segments\nnote that theta0 goes from 0 to theta0_max and then from theta0_min back\nto -dtheta0\nfirst ikx_max=nakx/2+1 theta0s are 0 and all positive theta0 values\nremainder are negative theta0s\ntheta_0 = kx / ky / shat\nif ky > 0, then most positive theta_0 corresponds to most positive kx\nfirst consider case where shift in kx is negative (corresponds to positive magnetic shear)\nthen consider case where shift in kx is positive\nnote that zero shift case is taken care of by initialization of ikx_shift_end Read moreâ€¦ Arguments None public subroutine fill_zed_ghost_zones (it, iseg, ie, iky, g, gleft, gright) Arguments Type Intent Optional Attributes Name integer, intent(in) :: it integer, intent(in) :: iseg integer, intent(in) :: ie integer, intent(in) :: iky complex, intent(in), dimension(:, :, -nzgrid:, :) :: g complex, intent(out), dimension(:) :: gleft complex, intent(out), dimension(:) :: gright public subroutine map_to_extended_zgrid (it, ie, iky, g, gext, ulim) Arguments Type Intent Optional Attributes Name integer, intent(in) :: it integer, intent(in) :: ie integer, intent(in) :: iky complex, intent(in), dimension(:, -nzgrid:, :) :: g complex, intent(out), dimension(:) :: gext integer, intent(out) :: ulim public subroutine map_from_extended_zgrid (it, ie, iky, gext, g) Arguments Type Intent Optional Attributes Name integer, intent(in) :: it integer, intent(in) :: ie integer, intent(in) :: iky complex, intent(in), dimension(:) :: gext complex, intent(inout), dimension(:, -nzgrid:, :) :: g public subroutine finish_extended_zgrid () Arguments None","tags":"","loc":"module/extended_zgrid.html"},{"title":"time_advance â€“ stella","text":"Contents Variables time_advance_initialized wdriftinit wstarinit parnlinit readinit radialinit driftimpinit explicit_option_switch explicit_option_rk3 explicit_option_rk2 explicit_option_rk4 xdriftknob ydriftknob wstarknob flip_flop gamtot_drifts gamtot3_drifts par_nl_fac d_par_nl_fac_dr par_nl_curv d_par_nl_curv_dr par_nl_driftx par_nl_drifty d_par_nl_driftx_dr d_par_nl_drifty_dr time_gke time_parallel_nl debug Interfaces get_dgdy get_dgdx checksum Subroutines init_time_advance read_parameters init_wdrift init_wstar init_drifts_implicit init_parallel_nonlinearity init_radial_variation allocate_arrays init_cfl reset_dt advance_stella advance_explicit advance_explicit_rk2 advance_explicit_rk3 advance_explicit_rk4 solve_gke advance_wstar_explicit advance_wdrifty_explicit advance_wdriftx_explicit advance_ExB_nonlinearity advance_parallel_nonlinearity advance_radial_variation get_dgdy_2d get_dgdy_3d get_dgdy_4d get_dgdx_2d get_dgdx_3d get_dgdx_4d add_explicit_term add_explicit_term_ffs advance_implicit advance_drifts_implicit mb_communicate checksum_field checksum_dist finish_time_advance finish_parallel_nonlinearity finish_wdrift finish_wstar finish_drifts_implicit deallocate_arrays Variables Type Visibility Attributes Name Initial logical, private :: time_advance_initialized = .false. logical, private :: wdriftinit = .false. logical, private :: wstarinit = .false. logical, private :: parnlinit = .false. logical, private :: readinit = .false. logical, private :: radialinit = .false. logical, private :: driftimpinit = .false. integer, private :: explicit_option_switch integer, private, parameter :: explicit_option_rk3 = 1 integer, private, parameter :: explicit_option_rk2 = 2 integer, private, parameter :: explicit_option_rk4 = 3 real, private :: xdriftknob real, private :: ydriftknob real, private :: wstarknob logical, private :: flip_flop complex, private, dimension(:, :, :), allocatable :: gamtot_drifts complex, private, dimension(:, :), allocatable :: gamtot3_drifts real, private, dimension(:, :), allocatable :: par_nl_fac real, private, dimension(:, :), allocatable :: d_par_nl_fac_dr real, private, dimension(:, :), allocatable :: par_nl_curv real, private, dimension(:, :), allocatable :: d_par_nl_curv_dr real, private, dimension(:), allocatable :: par_nl_driftx real, private, dimension(:), allocatable :: par_nl_drifty real, private, dimension(:), allocatable :: d_par_nl_driftx_dr real, private, dimension(:), allocatable :: d_par_nl_drifty_dr real, public, dimension(2, 10) :: time_gke = 0. real, public, dimension(2, 2) :: time_parallel_nl = 0. logical, private :: debug = .false. Interfaces private interface get_dgdy private subroutine get_dgdy_2d (g, dgdy) compute dg/dy in k-space\naccepts g(ky,kx) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: g complex, intent(out), dimension(:, :) :: dgdy private subroutine get_dgdy_3d (g, dgdy) compute dg/dy in k-space\naccepts g(ky,kx,z,tube) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: dgdy private subroutine get_dgdy_4d (g, dgdy) compute dg/dy in k-space\naccepts g(ky,kx,z,tube,(vpa,mu,spec)) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dgdy private interface get_dgdx private subroutine get_dgdx_2d (g, dgdx) compute dg/dx in k-space\naccepts g(ky,kx) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: g complex, intent(out), dimension(:, :) :: dgdx private subroutine get_dgdx_3d (g, dgdx) compute dg/dx in k-space\naccepts g(ky,kx,z,tube) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: dgdx private subroutine get_dgdx_4d (g, dgdx) compute dg/dx in k-space\naccepts g(ky,kx,z,tube,(vpa,mu,spec)) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dgdx public interface checksum private subroutine checksum_field (field, total) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: field real, intent(out) :: total private subroutine checksum_dist (dist, total, norm) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dist real, intent(out) :: total logical, intent(in), optional :: norm Subroutines public subroutine init_time_advance () read time_advance_knobs namelist from the input file;\nsets the explicit time advance option, as well as allows for scaling of\nthe x and y components of the magnetic drifts and of the drive term\nallocate distribution function sized arrays needed, e.g., for Runge-Kutta time advance\nset up neoclassical corrections to the equilibrium Maxwellian;\nonly calculated/needed when simulating higher order terms in rhostar for intrinsic rotation\ncalculate the term multiplying dg/dvpa in the mirror term\nand set up either the semi-Lagrange machinery or the tridiagonal matrix to be inverted\nif solving implicitly\ncalculate the term multiplying dg/dz in the parallel streaming term\nand set up the tridiagonal matrix to be inverted if solving implicitly\nallocate and calculate the factors multiplying dg/dx, dg/dy, dphi/dx and dphi/dy\nin the magnetic drift terms\nallocate and calculate the factor multiplying dphi/dy in the gradient drive term Arguments None private subroutine read_parameters () Arguments None private subroutine init_wdrift () allocate wdriftx_phi, the factor multiplying dphi/dx in the magnetic drift term\nallocate wdrifty_phi, the factor multiplying dphi/dy in the magnetic drift term\nallocate wdriftx_g, the factor multiplying dg/dx in the magnetic drift term\nallocate wdrifty_g, the factor multiplying dg/dy in the magnetic drift term\nthis is the curvature drift piece of wdrifty with missing factor of vpa\nvpa factor is missing to avoid singularity when including\nnon-Maxwellian corrections to equilibrium\nthis is the grad-B drift piece of wdrifty\nif including neoclassical correction to equilibrium Maxwellian,\nthen add in v_E&#94;{nc} . grad y dg/dy coefficient here\nif full_flux_surface, evolved distribution function is normalised by a Maxwellian\notherwise, it is not; a Maxwellian weighting factor must thus be included\nif including neoclassical corrections to equilibrium,\nadd in -(Ze/m) * v_curv/vpa . grad y d /dy * dF&#94;{nc}/dvpa term\nand v_E . grad z dF&#94;{nc}/dz (here get the dphi/dy part of v_E)\nNB: the below neoclassical correction needs to be divided by an equilibrium Maxwellian\nif running in full flux surface mode\nthis is the curvature drift piece of wdriftx with missing factor of vpa\nvpa factor is missing to avoid singularity when including\nnon-Maxwellian corrections to equilibrium\nthis is the grad-B drift piece of wdriftx\nif including neoclassical correction to equilibrium Maxwellian,\nthen add in v_E&#94;{nc} . grad x dg/dx coefficient here\nif full_flux_surface, evolved distribution function is normalised by a Maxwellian\notherwise, it is not; a Maxwellian weighting factor must thus be included\nif including neoclassical corrections to equilibrium,\nadd in (Ze/m) * v_curv/vpa . grad x d /dx * dF&#94;{nc}/dvpa term\nand v_E . grad z dF&#94;{nc}/dz (here get the dphi/dx part of v_E)\nand v_E . grad alpha dF&#94;{nc}/dalpha (dphi/dx part of v_E)\nNB: the below neoclassical correction needs to be divided by an equilibrium Maxwellian\nif running in full flux surface mode Arguments None private subroutine init_wstar () Arguments None private subroutine init_drifts_implicit () Arguments None private subroutine init_parallel_nonlinearity () Arguments None private subroutine init_radial_variation () Arguments None private subroutine allocate_arrays () Arguments None private subroutine init_cfl () Arguments None private subroutine reset_dt () Arguments None public subroutine advance_stella (istep) unless running in multibox mode, no need to worry about\nmb_communicate calls as the subroutine is immediately exited\nif not in multibox mode.\nsave value of phi\nfor use in diagnostics (to obtain frequency) Read moreâ€¦ Arguments Type Intent Optional Attributes Name integer, intent(in) :: istep private subroutine advance_explicit (g) advance_explicit takes as input the guiding centre distribution function\nin k-space and updates it to account for all of the terms in the GKE that\nare advanced explicitly in time Read moreâ€¦ Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g private subroutine advance_explicit_rk2 (g) advance_expliciit_rk2 uses strong stability-preserving RK2 to advance one time step Read moreâ€¦ Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g private subroutine advance_explicit_rk3 (g) strong stability-preserving RK3 Read moreâ€¦ Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g private subroutine advance_explicit_rk4 (g) standard RK4 Read moreâ€¦ Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g private subroutine solve_gke (gin, rhs_ky, restart_time_step) solve_gke accepts as argument gin, the guiding centre distribution function in k-space,\nand returns rhs_ky, the right-hand side of the gyrokinetic equation in k-space;\ni.e., if dg/dt = r, then rhs_ky = r*dt Read moreâ€¦ Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gin complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:), target :: rhs_ky logical, intent(out) :: restart_time_step private subroutine advance_wstar_explicit (phi, gout) start timing the time advance due to the driving gradients Read moreâ€¦ Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout private subroutine advance_wdrifty_explicit (g, phi, gout) advance_wdrifty_explicit subroutine calculates and adds the y-component of the\nmagnetic drift term to the RHS of the GK equation Read moreâ€¦ Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout private subroutine advance_wdriftx_explicit (g, phi, gout) advance_wdriftx_explicit subroutine calculates and adds the x-component of the\nmagnetic drift term to the RHS of the GK equation Read moreâ€¦ Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout private subroutine advance_ExB_nonlinearity (g, gout, restart_time_step) compute phase factor needed when running with equilibrium flow shear\ncompute i ky g\nFFT to get dg/dy in (y,x) space\ncompute i kx if running with equilibrium flow shear, make adjustment to\nthe term multiplying dg/dy\nFFT to get d /dx in (y,x) space\nmultiply by the geometric factor appearing in the Poisson bracket;\ni.e., (dx/dpsi dy/dalpha) 0.5\ncompute the contribution to the Poisson bracket from dg/dy*d /dx Read moreâ€¦ Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout logical, intent(out) :: restart_time_step private subroutine advance_parallel_nonlinearity (g, gout, restart_time_step) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout logical, intent(out) :: restart_time_step private subroutine advance_radial_variation (g, gout) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout private subroutine get_dgdy_2d (g, dgdy) compute dg/dy in k-space\naccepts g(ky,kx) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: g complex, intent(out), dimension(:, :) :: dgdy private subroutine get_dgdy_3d (g, dgdy) compute dg/dy in k-space\naccepts g(ky,kx,z,tube) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: dgdy private subroutine get_dgdy_4d (g, dgdy) compute dg/dy in k-space\naccepts g(ky,kx,z,tube,(vpa,mu,spec)) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dgdy private subroutine get_dgdx_2d (g, dgdx) compute dg/dx in k-space\naccepts g(ky,kx) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: g complex, intent(out), dimension(:, :) :: dgdx private subroutine get_dgdx_3d (g, dgdx) compute dg/dx in k-space\naccepts g(ky,kx,z,tube) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: dgdx private subroutine get_dgdx_4d (g, dgdx) compute dg/dx in k-space\naccepts g(ky,kx,z,tube,(vpa,mu,spec)) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dgdx private subroutine add_explicit_term (g, pre_factor, src) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g real, intent(in), dimension(-nzgrid:, vmu_lo%llim_proc:) :: pre_factor complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: src private subroutine add_explicit_term_ffs (g, pre_factor, src) add vM . grad y d /dy or vM . grad x d /dx (or equivalents with g) or omega_* * d /dy term to RHS of GK equation Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g real, intent(in), dimension(:, -nzgrid:, vmu_lo%llim_proc:) :: pre_factor complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: src private subroutine advance_implicit (istep, phi, apar, g) Arguments Type Intent Optional Attributes Name integer, intent(in) :: istep complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :) :: apar complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g private subroutine advance_drifts_implicit (g, phi, apar) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :) :: apar private subroutine mb_communicate (g_in) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g_in private subroutine checksum_field (field, total) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: field real, intent(out) :: total private subroutine checksum_dist (dist, total, norm) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dist real, intent(out) :: total logical, intent(in), optional :: norm public subroutine finish_time_advance () Arguments None private subroutine finish_parallel_nonlinearity () Arguments None private subroutine finish_wdrift () Arguments None private subroutine finish_wstar () Arguments None private subroutine finish_drifts_implicit () Arguments None private subroutine deallocate_arrays () Arguments None","tags":"","loc":"module/time_advance.html"},{"title":"euterpe_interface â€“ stella","text":"Contents Subroutines read_species_euterpe read_euterpe_parameters Subroutines public subroutine read_species_euterpe (nspec, spec) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nspec type( spec_type ), intent(inout), dimension(:) :: spec public subroutine read_euterpe_parameters (nradii_out, data_file_out) Arguments Type Intent Optional Attributes Name integer, intent(out) :: nradii_out character, intent(out) :: data_file_out","tags":"","loc":"module/euterpe_interface.html"},{"title":"finite_differences â€“ stella","text":"Contents Interfaces fd3pt fd5pt first_order_upwind third_order_upwind fifth_order_upwind tridag second_order_centered four_point_triangle fourth_order_centered second_order_centered_zed d2_3pt Subroutines first_order_upwind_real first_order_upwind_complex third_order_upwind_complex third_order_upwind_real fifth_order_upwind_complex fifth_order_upwind_real third_order_upwind_zed first_order_upwind_zed second_order_centered_real second_order_centered_complex four_point_triangle_real four_point_triangle_complex fourth_order_centered_real fourth_order_centered_complex second_order_centered_zed_real second_order_centered_zed_complex second_order_centered_vpa fd_cell_centres_zed cell_centres_zed fd_variable_upwinding_zed fd_variable_upwinding_vpa fd3pt_real fd3pt_real_array fd3pt_complex_array fd5pt_real fd5pt_array d2_3pt_real d2_3pt_complex tridag_real tridag_complex Interfaces public interface fd3pt public subroutine fd3pt_real (prof, profgrad, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: prof real, intent(out), dimension(:) :: profgrad real, intent(in) :: dr public subroutine fd3pt_real_array (prof, profgrad, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: prof real, intent(out), dimension(:) :: profgrad real, intent(in), dimension(:) :: dr public subroutine fd3pt_complex_array (prof, profgrad, dr) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: prof complex, intent(out), dimension(:) :: profgrad real, intent(in), dimension(:) :: dr public interface fd5pt public subroutine fd5pt_real (prof, profgrad, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: prof real, intent(out), dimension(:) :: profgrad real, intent(in) :: dr public subroutine fd5pt_array (prof, profgrad, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: prof real, intent(out), dimension(:) :: profgrad real, intent(in), dimension(:) :: dr public interface first_order_upwind public subroutine first_order_upwind_real (llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(out), dimension(llim:) :: df public subroutine first_order_upwind_complex (llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(out), dimension(llim:) :: df public interface third_order_upwind public subroutine third_order_upwind_complex (llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(out), dimension(llim:) :: df public subroutine third_order_upwind_real (llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(out), dimension(llim:) :: df public interface fifth_order_upwind public subroutine fifth_order_upwind_complex (llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(out), dimension(llim:) :: df public subroutine fifth_order_upwind_real (llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(out), dimension(llim:) :: df public interface tridag public subroutine tridag_real (aa, bb, cc, sol) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: aa real, intent(in), dimension(:) :: bb real, intent(in), dimension(:) :: cc real, intent(inout), dimension(:) :: sol public subroutine tridag_complex (llim, aa, bb, cc, sol) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: aa real, intent(in), dimension(llim:) :: bb real, intent(in), dimension(llim:) :: cc complex, intent(inout), dimension(llim:) :: sol public interface second_order_centered public subroutine second_order_centered_real (llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del real, intent(out), dimension(llim:) :: df public subroutine second_order_centered_complex (llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del complex, intent(out), dimension(llim:) :: df public interface four_point_triangle public subroutine four_point_triangle_real (llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del real, intent(out), dimension(llim:) :: df public subroutine four_point_triangle_complex (llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del complex, intent(out), dimension(llim:) :: df public interface fourth_order_centered public subroutine fourth_order_centered_real (llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del real, intent(out), dimension(llim:) :: df public subroutine fourth_order_centered_complex (llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del complex, intent(out), dimension(llim:) :: df public interface second_order_centered_zed public subroutine second_order_centered_zed_real (llim, iseg, nseg, f, del, sgn, fl, fr, periodic, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim integer, intent(in) :: iseg integer, intent(in) :: nseg real, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(in), dimension(:) :: fl real, intent(in), dimension(:) :: fr logical, intent(in) :: periodic real, intent(out), dimension(llim:) :: df public subroutine second_order_centered_zed_complex (llim, iseg, nseg, f, del, sgn, fl, fr, periodic, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim integer, intent(in) :: iseg integer, intent(in) :: nseg complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(in), dimension(:) :: fl complex, intent(in), dimension(:) :: fr logical, intent(in) :: periodic complex, intent(out), dimension(llim:) :: df public interface d2_3pt public subroutine d2_3pt_real (f, d2f, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: f real, intent(out), dimension(:) :: d2f real, intent(in), dimension(:) :: dr public subroutine d2_3pt_complex (f, d2f, dr) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: f complex, intent(out), dimension(:) :: d2f real, intent(in), dimension(:) :: dr Subroutines public subroutine first_order_upwind_real (llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(out), dimension(llim:) :: df public subroutine first_order_upwind_complex (llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(out), dimension(llim:) :: df public subroutine third_order_upwind_complex (llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(out), dimension(llim:) :: df public subroutine third_order_upwind_real (llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(out), dimension(llim:) :: df public subroutine fifth_order_upwind_complex (llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(out), dimension(llim:) :: df public subroutine fifth_order_upwind_real (llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(out), dimension(llim:) :: df public subroutine third_order_upwind_zed (llim, iseg, nseg, f, del, sgn, fl, fr, periodic, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim integer, intent(in) :: iseg integer, intent(in) :: nseg complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(in), dimension(:) :: fl complex, intent(in), dimension(:) :: fr logical, intent(in) :: periodic complex, intent(out), dimension(llim:) :: df public subroutine first_order_upwind_zed (llim, iseg, nseg, f, del, sgn, fl, fr, periodic, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim integer, intent(in) :: iseg integer, intent(in) :: nseg complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(in), dimension(:) :: fl complex, intent(in), dimension(:) :: fr logical, intent(in) :: periodic complex, intent(out), dimension(llim:) :: df public subroutine second_order_centered_real (llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del real, intent(out), dimension(llim:) :: df public subroutine second_order_centered_complex (llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del complex, intent(out), dimension(llim:) :: df public subroutine four_point_triangle_real (llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del real, intent(out), dimension(llim:) :: df public subroutine four_point_triangle_complex (llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del complex, intent(out), dimension(llim:) :: df public subroutine fourth_order_centered_real (llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del real, intent(out), dimension(llim:) :: df public subroutine fourth_order_centered_complex (llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del complex, intent(out), dimension(llim:) :: df public subroutine second_order_centered_zed_real (llim, iseg, nseg, f, del, sgn, fl, fr, periodic, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim integer, intent(in) :: iseg integer, intent(in) :: nseg real, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(in), dimension(:) :: fl real, intent(in), dimension(:) :: fr logical, intent(in) :: periodic real, intent(out), dimension(llim:) :: df public subroutine second_order_centered_zed_complex (llim, iseg, nseg, f, del, sgn, fl, fr, periodic, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim integer, intent(in) :: iseg integer, intent(in) :: nseg complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(in), dimension(:) :: fl complex, intent(in), dimension(:) :: fr logical, intent(in) :: periodic complex, intent(out), dimension(llim:) :: df public subroutine second_order_centered_vpa (llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del complex, intent(out), dimension(llim:) :: df public subroutine fd_cell_centres_zed (llim, f, del, sgn, fl, fr, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(in) :: fl complex, intent(in) :: fr complex, intent(out), dimension(llim:) :: df public subroutine cell_centres_zed (llim, f, upwnd, sgn, fl, fr, fc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: upwnd integer, intent(in) :: sgn complex, intent(in) :: fl complex, intent(in) :: fr complex, intent(out), dimension(llim:) :: fc public subroutine fd_variable_upwinding_zed (llim, iseg, nseg, f, del, sgn, upwnd, fl, fr, periodic, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim integer, intent(in) :: iseg integer, intent(in) :: nseg complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(in) :: upwnd complex, intent(in), dimension(:) :: fl complex, intent(in), dimension(:) :: fr logical, intent(in) :: periodic complex, intent(out), dimension(llim:) :: df public subroutine fd_variable_upwinding_vpa (llim, f, del, sgn, upwnd, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(in) :: upwnd complex, intent(out), dimension(llim:) :: df public subroutine fd3pt_real (prof, profgrad, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: prof real, intent(out), dimension(:) :: profgrad real, intent(in) :: dr public subroutine fd3pt_real_array (prof, profgrad, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: prof real, intent(out), dimension(:) :: profgrad real, intent(in), dimension(:) :: dr public subroutine fd3pt_complex_array (prof, profgrad, dr) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: prof complex, intent(out), dimension(:) :: profgrad real, intent(in), dimension(:) :: dr public subroutine fd5pt_real (prof, profgrad, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: prof real, intent(out), dimension(:) :: profgrad real, intent(in) :: dr public subroutine fd5pt_array (prof, profgrad, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: prof real, intent(out), dimension(:) :: profgrad real, intent(in), dimension(:) :: dr public subroutine d2_3pt_real (f, d2f, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: f real, intent(out), dimension(:) :: d2f real, intent(in), dimension(:) :: dr public subroutine d2_3pt_complex (f, d2f, dr) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: f complex, intent(out), dimension(:) :: d2f real, intent(in), dimension(:) :: dr public subroutine tridag_real (aa, bb, cc, sol) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: aa real, intent(in), dimension(:) :: bb real, intent(in), dimension(:) :: cc real, intent(inout), dimension(:) :: sol public subroutine tridag_complex (llim, aa, bb, cc, sol) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: aa real, intent(in), dimension(llim:) :: bb real, intent(in), dimension(llim:) :: cc complex, intent(inout), dimension(llim:) :: sol","tags":"","loc":"module/finite_differences.html"},{"title":"fields_arrays â€“ stella","text":"Uses common_types Contents Variables phi apar phi_old phi_shared phi_corr_QN apar_corr_QN phi_proj phi_proj_stage phi_corr_GA apar_corr_GA response_matrix shift_state gamtot dgamtotdr gamtot3 dgamtot3dr theta c_mat phi_ext phi_solve phizf_solve exclude_boundary_regions_qn tcorr_source_qn exp_fac_qn qn_window qn_zf_window Variables Type Visibility Attributes Name Initial complex, public, dimension(:, :, :, :), allocatable :: phi complex, public, dimension(:, :, :, :), allocatable :: apar complex, public, dimension(:, :, :, :), allocatable :: phi_old complex, public, dimension(:, :, :, :), pointer :: phi_shared complex, public, dimension(:, :, :, :), allocatable :: phi_corr_QN complex, public, dimension(:, :, :, :), allocatable :: apar_corr_QN complex, public, dimension(:, :, :), allocatable :: phi_proj complex, public, dimension(:, :, :), allocatable :: phi_proj_stage complex, public, dimension(:, :, :, :, :), allocatable :: phi_corr_GA complex, public, dimension(:, :, :, :, :), allocatable :: apar_corr_GA type( response_matrix_type ), public, dimension(:), allocatable :: response_matrix real, public, dimension(:), allocatable :: shift_state real, public, dimension(:, :, :), allocatable :: gamtot real, public, dimension(:, :, :), allocatable :: dgamtotdr real, public, dimension(:, :), allocatable :: gamtot3 real, public, dimension(:, :), allocatable :: dgamtot3dr complex, public, dimension(:, :, :), allocatable :: theta complex, public, dimension(:, :), allocatable :: c_mat complex, public, dimension(:), pointer :: phi_ext => null() type( eigen_type ), public, dimension(:, :), allocatable :: phi_solve type( eigen_type ), public :: phizf_solve logical, public :: exclude_boundary_regions_qn real, public :: tcorr_source_qn real, public :: exp_fac_qn integer, public :: qn_window integer, public :: qn_zf_window","tags":"","loc":"module/fields_arrays.html"},{"title":"stella_layouts â€“ stella","text":"Uses common_types Contents Variables xyzs_layout vms_layout exist kxkyz_lo kxyz_lo xyz_lo vmu_lo Interfaces it_idx iz_idx iv_idx iky_idx iy_idx ikx_idx ix_idx imu_idx is_idx proc_id idx idx_local Functions is_idx_kxkyz ikx_idx_kxkyz iky_idx_kxkyz iz_idx_kxkyz it_idx_kxkyz proc_id_kxkyz idx_kxkyz idx_local_kxkyz iz_local_kxkyz is_idx_kxyz ikx_idx_kxyz iy_idx_kxyz iz_idx_kxyz it_idx_kxyz proc_id_kxyz idx_kxyz idx_local_kxyz iz_local_kxyz is_idx_xyz ix_idx_xyz iy_idx_xyz iz_idx_xyz it_idx_xyz proc_id_xyz idx_xyz idx_local_xyz iz_local_xyz is_idx_vmu imu_idx_vmu iv_idx_vmu proc_id_vmu idx_vmu idx_local_vmu iz_local_vmu Subroutines init_stella_layouts read_parameters broadcast_results init_dist_fn_layouts init_kxkyz_layout init_kxyz_layout init_xyz_layout init_vmu_layout kxkyzidx2vmuidx kxyzidx2vmuidx xyzidx2vmuidx finish_layouts Variables Type Visibility Attributes Name Initial character(len=4), public :: xyzs_layout character(len=3), public :: vms_layout logical, private :: exist type( kxkyz_layout_type ), public :: kxkyz_lo type( kxyz_layout_type ), public :: kxyz_lo type( xyz_layout_type ), public :: xyz_lo type( vmu_layout_type ), public :: vmu_lo Interfaces public interface it_idx private elemental function it_idx_kxkyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function it_idx_kxyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function it_idx_xyz (lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer public interface iz_idx private elemental function iz_idx_kxkyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function iz_idx_kxyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function iz_idx_xyz (lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer public interface iv_idx private elemental function iv_idx_vmu (lo, i) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer public interface iky_idx private elemental function iky_idx_kxkyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer public interface iy_idx private elemental function iy_idx_kxyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function iy_idx_xyz (lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer public interface ikx_idx private elemental function ikx_idx_kxkyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function ikx_idx_kxyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private interface ix_idx private elemental function ix_idx_xyz (lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer public interface imu_idx private elemental function imu_idx_vmu (lo, i) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer public interface is_idx private elemental function is_idx_kxkyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function is_idx_kxyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function is_idx_xyz (lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function is_idx_vmu (lo, i) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer public interface proc_id private elemental function proc_id_kxkyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function proc_id_kxyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function proc_id_xyz (lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function proc_id_vmu (lo, i) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer public interface idx private elemental function idx_kxkyz (lo, iky, ikx, iz, it, is) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value integer private elemental function idx_kxyz (lo, iy, ikx, iz, it, is) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: iy integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value integer private elemental function idx_xyz (lo, iy, ix, iz, it, is) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: iy integer, intent(in) :: ix integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value integer private elemental function idx_vmu (lo, iv, imu, is) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: iv integer, intent(in) :: imu integer, intent(in) :: is Return Value integer public interface idx_local private elemental function idx_local_kxkyz (lo, iky, ikx, iz, it, is) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value logical private elemental function iz_local_kxkyz (lo, iz) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: iz Return Value logical private elemental function idx_local_kxyz (lo, iy, ikx, iz, it, is) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: iy integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value logical private elemental function iz_local_kxyz (lo, iz) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: iz Return Value logical private elemental function idx_local_xyz (lo, iy, ix, iz, it, is) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: iy integer, intent(in) :: ix integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value logical private elemental function iz_local_xyz (lo, iz) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: iz Return Value logical private elemental function idx_local_vmu (lo, iv, imu, is) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: iv integer, intent(in) :: imu integer, intent(in) :: is Return Value logical private elemental function iz_local_vmu (lo, iz) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: iz Return Value logical Functions private elemental function is_idx_kxkyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function ikx_idx_kxkyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function iky_idx_kxkyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function iz_idx_kxkyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function it_idx_kxkyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function proc_id_kxkyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function idx_kxkyz (lo, iky, ikx, iz, it, is) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value integer private elemental function idx_local_kxkyz (lo, iky, ikx, iz, it, is) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value logical private elemental function iz_local_kxkyz (lo, iz) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: iz Return Value logical private elemental function is_idx_kxyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function ikx_idx_kxyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function iy_idx_kxyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function iz_idx_kxyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function it_idx_kxyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function proc_id_kxyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function idx_kxyz (lo, iy, ikx, iz, it, is) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: iy integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value integer private elemental function idx_local_kxyz (lo, iy, ikx, iz, it, is) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: iy integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value logical private elemental function iz_local_kxyz (lo, iz) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: iz Return Value logical private elemental function is_idx_xyz (lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function ix_idx_xyz (lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function iy_idx_xyz (lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function iz_idx_xyz (lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function it_idx_xyz (lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function proc_id_xyz (lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function idx_xyz (lo, iy, ix, iz, it, is) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: iy integer, intent(in) :: ix integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value integer private elemental function idx_local_xyz (lo, iy, ix, iz, it, is) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: iy integer, intent(in) :: ix integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value logical private elemental function iz_local_xyz (lo, iz) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: iz Return Value logical private elemental function is_idx_vmu (lo, i) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function imu_idx_vmu (lo, i) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function iv_idx_vmu (lo, i) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function proc_id_vmu (lo, i) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function idx_vmu (lo, iv, imu, is) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: iv integer, intent(in) :: imu integer, intent(in) :: is Return Value integer private elemental function idx_local_vmu (lo, iv, imu, is) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: iv integer, intent(in) :: imu integer, intent(in) :: is Return Value logical private elemental function iz_local_vmu (lo, iz) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: iz Return Value logical Subroutines public subroutine init_stella_layouts () Arguments None private subroutine read_parameters () Arguments None private subroutine broadcast_results () Arguments None public subroutine init_dist_fn_layouts (nzgrid, ntubes, naky, nakx, nvgrid, nmu, nspec, ny, nx, nalpha) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nzgrid integer, intent(in) :: ntubes integer, intent(in) :: naky integer, intent(in) :: nakx integer, intent(in) :: nvgrid integer, intent(in) :: nmu integer, intent(in) :: nspec integer, intent(in) :: ny integer, intent(in) :: nx integer, intent(in) :: nalpha private subroutine init_kxkyz_layout (nzgrid, ntubes, naky, nakx, nvgrid, nmu, nspec) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nzgrid integer, intent(in) :: ntubes integer, intent(in) :: naky integer, intent(in) :: nakx integer, intent(in) :: nvgrid integer, intent(in) :: nmu integer, intent(in) :: nspec private subroutine init_kxyz_layout (nzgrid, ntubes, naky, nakx, nvgrid, nmu, nspec, ny) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nzgrid integer, intent(in) :: ntubes integer, intent(in) :: naky integer, intent(in) :: nakx integer, intent(in) :: nvgrid integer, intent(in) :: nmu integer, intent(in) :: nspec integer, intent(in) :: ny private subroutine init_xyz_layout (nzgrid, ntubes, naky, nakx, nvgrid, nmu, nspec, ny, nx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nzgrid integer, intent(in) :: ntubes integer, intent(in) :: naky integer, intent(in) :: nakx integer, intent(in) :: nvgrid integer, intent(in) :: nmu integer, intent(in) :: nspec integer, intent(in) :: ny integer, intent(in) :: nx private subroutine init_vmu_layout (nzgrid, ntubes, naky, nakx, nvgrid, nmu, nspec, ny, nx, nalpha) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nzgrid integer, intent(in) :: ntubes integer, intent(in) :: naky integer, intent(in) :: nakx integer, intent(in) :: nvgrid integer, intent(in) :: nmu integer, intent(in) :: nspec integer, intent(in) :: ny integer, intent(in) :: nx integer, intent(in) :: nalpha public elemental subroutine kxkyzidx2vmuidx (iv, imu, ikxkyz, kxkyz_lo, vmu_lo, iky, ikx, iz, it, ivmu) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv integer, intent(in) :: imu integer, intent(in) :: ikxkyz type( kxkyz_layout_type ), intent(in) :: kxkyz_lo type( vmu_layout_type ), intent(in) :: vmu_lo integer, intent(out) :: iky integer, intent(out) :: ikx integer, intent(out) :: iz integer, intent(out) :: it integer, intent(out) :: ivmu public elemental subroutine kxyzidx2vmuidx (iv, imu, ikxyz, kxyz_lo, vmu_lo, iy, ikx, iz, it, ivmu) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv integer, intent(in) :: imu integer, intent(in) :: ikxyz type( kxyz_layout_type ), intent(in) :: kxyz_lo type( vmu_layout_type ), intent(in) :: vmu_lo integer, intent(out) :: iy integer, intent(out) :: ikx integer, intent(out) :: iz integer, intent(out) :: it integer, intent(out) :: ivmu public elemental subroutine xyzidx2vmuidx (iv, imu, ixyz, xyz_lo, vmu_lo, iy, ix, iz, it, ivmu) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv integer, intent(in) :: imu integer, intent(in) :: ixyz type( xyz_layout_type ), intent(in) :: xyz_lo type( vmu_layout_type ), intent(in) :: vmu_lo integer, intent(out) :: iy integer, intent(out) :: ix integer, intent(out) :: iz integer, intent(out) :: it integer, intent(out) :: ivmu public subroutine finish_layouts () Arguments None","tags":"","loc":"module/stella_layouts.html"},{"title":"fields â€“ stella","text":"Uses common_types Contents Variables apar_denom gamtot_h gamtot3_h efac efacp save1 save2 gam0_ffs lu_gam0_ffs adiabatic_response_factor fields_updated fields_initialized debug zm time_field_solve Interfaces get_dchidy Subroutines init_fields init_fields_fluxtube init_fields_ffs init_gamma0_factor_ffs init_adiabatic_response_factor allocate_arrays enforce_reality_field advance_fields get_fields get_fields_vmulo get_fields_ffs get_fields_by_spec get_fields_by_spec_idx get_phi get_phi_ffs get_radial_correction get_dchidy_4d get_dchidy_2d get_dchidx finish_fields Variables Type Visibility Attributes Name Initial real, private, dimension(:, :, :), allocatable :: apar_denom real, public :: gamtot_h real, public :: gamtot3_h real, public :: efac real, public :: efacp complex, private, dimension(:, :), allocatable :: save1 complex, private, dimension(:, :), allocatable :: save2 type( coupled_alpha_type ), private, dimension(:, :, :), allocatable :: gam0_ffs arrays allocated/used if simulating a full flux surface type( gam0_ffs_type ), private, dimension(:, :), allocatable :: lu_gam0_ffs complex, private, dimension(:), allocatable :: adiabatic_response_factor logical, public :: fields_updated = .false. logical, private :: fields_initialized = .false. logical, private :: debug = .false. integer, private :: zm real, public, dimension(2, 5) :: time_field_solve Interfaces public interface get_dchidy private subroutine get_dchidy_4d (phi, apar, dchidy) compute d /dy in (ky,kx,z,tube) space Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(in), dimension(:, :, -nzgrid:, :) :: apar complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dchidy private subroutine get_dchidy_2d (iz, ivmu, phi, apar, dchidy) compute d /dy in (ky,kx) space Arguments Type Intent Optional Attributes Name integer, intent(in) :: iz integer, intent(in) :: ivmu complex, intent(in), dimension(:, :) :: phi complex, intent(in), dimension(:, :) :: apar complex, intent(out), dimension(:, :) :: dchidy Subroutines public subroutine init_fields () Arguments None private subroutine init_fields_fluxtube () Read moreâ€¦ Arguments None private subroutine init_fields_ffs () init_fields_ffs allocates and fills arrays needed during main time advance\nloop for the field solve for full_flux_surface simulations Read moreâ€¦ Arguments None private subroutine init_gamma0_factor_ffs () calculate and LU factorise the matrix multiplying the electrostatic potential in quasineutrality\nthis involves the factor 1-Gamma_0(kperp(alpha)) Read moreâ€¦ Arguments None private subroutine init_adiabatic_response_factor () solves Delta * phi_hom = -delta_{ky,0} * ne/Te for phi_hom\nthis is the vector describing the response of phi_hom to a unit impulse in phi_fsa\nit is the sum over ky and integral over kx of this that is needed, and this\nis stored in adiabatic_response_factor Read moreâ€¦ Arguments None private subroutine allocate_arrays () Arguments None public subroutine enforce_reality_field (fin) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: fin public subroutine advance_fields (g, phi, apar, dist) time the communications + field solve\nfields_kxkyz = F is the default\nfirst gather (vpa,mu) onto processor for v-space operations\nv-space operations are field solve, dg/dvpa, and collisions\ngiven gvmu with vpa and mu local, calculate the corresponding fields\nset a flag to indicate that the fields have been updated\nthis helps avoid unnecessary field solves\ntime the communications + field solve Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: phi complex, intent(out), dimension(:, :, -nzgrid:, :) :: apar character, intent(in) :: dist public subroutine get_fields (g, phi, apar, dist, skip_fsa) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: phi complex, intent(out), dimension(:, :, -nzgrid:, :) :: apar character, intent(in) :: dist logical, intent(in), optional :: skip_fsa private subroutine get_fields_vmulo (g, phi, apar, dist, skip_fsa) gather sub-sums from each processor and add them together\nstore result in phi, which will be further modified below to account for polarization term Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: phi complex, intent(out), dimension(:, :, -nzgrid:, :) :: apar character, intent(in) :: dist logical, intent(in), optional :: skip_fsa private subroutine get_fields_ffs (g, phi, apar) get_fields_ffs accepts as input the guiding centre distribution function g\nand calculates/returns the electronstatic potential phi for full_flux_surface simulations Read moreâ€¦ Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: phi complex, intent(out), dimension(:, :, -nzgrid:, :) :: apar public subroutine get_fields_by_spec (g, fld, skip_fsa) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: fld logical, intent(in), optional :: skip_fsa public subroutine get_fields_by_spec_idx (isa, g, fld) Arguments Type Intent Optional Attributes Name integer, intent(in) :: isa complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: fld private subroutine get_phi (phi, dist, skip_fsa) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi character, intent(in) :: dist logical, intent(in), optional :: skip_fsa private subroutine get_phi_ffs (rhs, phi) change from rhs defined on grid with ky >=0 and kx from 0,...,kxmax,-kxmax,...,-dkx\nto rhs_swap defined on grid with ky = -kymax,...,kymax and kx >= 0\nsolve sum_s Z_s int d&#94;3v = gam0*phi\nwhere sum_s Z_s int d&#94;3v is initially passed in as rhs_swap\nand then rhs_swap is over-written with the solution to the linear system Read moreâ€¦ Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:) :: rhs complex, intent(out), dimension(:, :, -nzgrid:) :: phi public subroutine get_radial_correction (g, phi_in, dist) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi_in character, intent(in) :: dist private subroutine get_dchidy_4d (phi, apar, dchidy) compute d /dy in (ky,kx,z,tube) space Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(in), dimension(:, :, -nzgrid:, :) :: apar complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dchidy private subroutine get_dchidy_2d (iz, ivmu, phi, apar, dchidy) compute d /dy in (ky,kx) space Arguments Type Intent Optional Attributes Name integer, intent(in) :: iz integer, intent(in) :: ivmu complex, intent(in), dimension(:, :) :: phi complex, intent(in), dimension(:, :) :: apar complex, intent(out), dimension(:, :) :: dchidy public subroutine get_dchidx (iz, ivmu, phi, apar, dchidx) compute d /dx in (ky,kx) space Arguments Type Intent Optional Attributes Name integer, intent(in) :: iz integer, intent(in) :: ivmu complex, intent(in), dimension(:, :) :: phi complex, intent(in), dimension(:, :) :: apar complex, intent(out), dimension(:, :) :: dchidx public subroutine finish_fields () arrays only allocated/used if simulating a full flux surface Arguments None","tags":"","loc":"module/fields.html"},{"title":"stella_transforms â€“ stella","text":"Uses fft_work Contents Variables yf_fft yb_fft xf_fft xb_fft yfnp_fft ybnp_fft xfnp_fft xbnp_fft xsf_fft xsb_fft ysf_fft ysb_fft alpha_f_fft alpha_b_fft transforms_initialized fft_y_in fft_y_out fft_x_k fft_x_x fft_xs_k fft_xs_x fft_ys_k fft_ys_y fftnp_x_k fftnp_x_x fftnp_y_k fftnp_y_y fft_alpha_alpha fft_alpha_kalpha Interfaces transform_ky2y transform_y2ky Subroutines init_transforms init_y_fft init_x_fft init_x_xfirst_fft init_y_xfirst_fft init_unpadded_x_fft init_unpadded_y_fft init_alpha_fft transform_ky2y_5d transform_ky2y_2d transform_y2ky_5d transform_y2ky_2d transform_kx2x transform_x2kx transform_kx2x_xfirst transform_x2kx_xfirst transform_ky2y_xfirst transform_y2ky_xfirst transform_kx2x_unpadded transform_x2kx_unpadded transform_ky2y_unpadded transform_y2ky_unpadded transform_kalpha2alpha transform_alpha2kalpha finish_transforms Variables Type Visibility Attributes Name Initial type( fft_type ), private :: yf_fft type( fft_type ), private :: yb_fft type( fft_type ), private :: xf_fft type( fft_type ), private :: xb_fft type( fft_type ), private :: yfnp_fft type( fft_type ), private :: ybnp_fft type( fft_type ), private :: xfnp_fft type( fft_type ), private :: xbnp_fft type( fft_type ), private :: xsf_fft type( fft_type ), private :: xsb_fft type( fft_type ), private :: ysf_fft type( fft_type ), private :: ysb_fft type( fft_type ), private :: alpha_f_fft type( fft_type ), private :: alpha_b_fft logical, private :: transforms_initialized = .false. complex, private, dimension(:), allocatable :: fft_y_in complex, private, dimension(:), allocatable :: fft_y_out complex, private, dimension(:), allocatable :: fft_x_k real, private, dimension(:), allocatable :: fft_x_x complex, private, dimension(:), allocatable :: fft_xs_k complex, private, dimension(:), allocatable :: fft_xs_x complex, private, dimension(:), allocatable :: fft_ys_k real, private, dimension(:), allocatable :: fft_ys_y complex, private, dimension(:), allocatable :: fftnp_x_k complex, private, dimension(:), allocatable :: fftnp_x_x complex, private, dimension(:), allocatable :: fftnp_y_k real, private, dimension(:), allocatable :: fftnp_y_y real, private, dimension(:), allocatable :: fft_alpha_alpha arrays for transforming from alpha-space to k-alpha space complex, private, dimension(:), allocatable :: fft_alpha_kalpha Interfaces public interface transform_ky2y private subroutine transform_ky2y_5d (gky_unpad, gy) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -vmu_lo%nzgrid:, :, vmu_lo%llim_proc:) :: gky_unpad complex, intent(out), dimension(:, :, -vmu_lo%nzgrid:, :, vmu_lo%llim_proc:) :: gy private subroutine transform_ky2y_2d (gky_unpad, gy) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gky_unpad complex, intent(out), dimension(:, :) :: gy public interface transform_y2ky private subroutine transform_y2ky_5d (gy, gky) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -vmu_lo%nzgrid:, :, vmu_lo%llim_proc:) :: gy complex, intent(out), dimension(:, :, -vmu_lo%nzgrid:, :, vmu_lo%llim_proc:) :: gky private subroutine transform_y2ky_2d (gy, gky) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: gy complex, intent(out), dimension(:, :) :: gky Subroutines public subroutine init_transforms () Arguments None private subroutine init_y_fft () Arguments None private subroutine init_x_fft () Arguments None private subroutine init_x_xfirst_fft () Arguments None private subroutine init_y_xfirst_fft () Arguments None private subroutine init_unpadded_x_fft () Arguments None private subroutine init_unpadded_y_fft () Arguments None private subroutine init_alpha_fft () Arguments None private subroutine transform_ky2y_5d (gky_unpad, gy) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -vmu_lo%nzgrid:, :, vmu_lo%llim_proc:) :: gky_unpad complex, intent(out), dimension(:, :, -vmu_lo%nzgrid:, :, vmu_lo%llim_proc:) :: gy private subroutine transform_ky2y_2d (gky_unpad, gy) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gky_unpad complex, intent(out), dimension(:, :) :: gy private subroutine transform_y2ky_5d (gy, gky) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -vmu_lo%nzgrid:, :, vmu_lo%llim_proc:) :: gy complex, intent(out), dimension(:, :, -vmu_lo%nzgrid:, :, vmu_lo%llim_proc:) :: gky private subroutine transform_y2ky_2d (gy, gky) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: gy complex, intent(out), dimension(:, :) :: gky public subroutine transform_kx2x (gkx, gx) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gkx real, intent(out), dimension(:, :) :: gx public subroutine transform_x2kx (gx, gkx) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: gx complex, intent(out), dimension(:, :) :: gkx public subroutine transform_kx2x_xfirst (gkx, gx) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gkx complex, intent(out), dimension(:, :) :: gx public subroutine transform_x2kx_xfirst (gx, gkx) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gx complex, intent(out), dimension(:, :) :: gkx public subroutine transform_ky2y_xfirst (gky, gy) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gky real, intent(out), dimension(:, :) :: gy public subroutine transform_y2ky_xfirst (gy, gky) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: gy complex, intent(out), dimension(:, :) :: gky public subroutine transform_kx2x_unpadded (gkx, gx) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gkx complex, intent(out), dimension(:, :) :: gx public subroutine transform_x2kx_unpadded (gx, gkx) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gx complex, intent(out), dimension(:, :) :: gkx public subroutine transform_ky2y_unpadded (gky, gy) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gky real, intent(out), dimension(:, :) :: gy public subroutine transform_y2ky_unpadded (gy, gky) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :) :: gy complex, intent(out), dimension(:, :) :: gky public subroutine transform_kalpha2alpha (gkalph, galph) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: gkalph real, intent(out), dimension(:) :: galph public subroutine transform_alpha2kalpha (galph, gkalph) input galph array is real and contains values on the padded alpha grid\ngkalph is output array; it contains the Fourier coefficients of galph\nfor positive ky values only (reality can be used to obtain the negative ky coefs)\nthe highest 1/3 of the ky modes from the FFT have been discarded to avoid de-aliasing Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: galph complex, intent(out), dimension(:) :: gkalph public subroutine finish_transforms () Arguments None","tags":"","loc":"module/stella_transforms.html"},{"title":"neoclassical_terms â€“ stella","text":"Contents Variables include_neoclassical_terms nradii drho neo_option_switch neo_option_sfincs dfneo_dzed dfneo_dvpa dfneo_drho dfneo_dalpha dphineo_dzed dphineo_drho dphineo_dalpha neoinit debug Subroutines init_neoclassical_terms read_parameters distribute_vmus_over_procs get_dfneo_dvpa get_dfneo_dzed get_dfneo_drho get_dphineo_dzed get_dphineo_drho write_neoclassical finish_neoclassical_terms Variables Type Visibility Attributes Name Initial logical, public :: include_neoclassical_terms integer, private :: nradii real, private :: drho integer, private :: neo_option_switch integer, private, parameter :: neo_option_sfincs = 1 real, public, dimension(:, :, :), allocatable :: dfneo_dzed real, public, dimension(:, :, :), allocatable :: dfneo_dvpa real, public, dimension(:, :, :), allocatable :: dfneo_drho real, public, dimension(:, :, :), allocatable :: dfneo_dalpha real, public, dimension(:, :), allocatable :: dphineo_dzed real, public, dimension(:, :), allocatable :: dphineo_drho real, public, dimension(:, :), allocatable :: dphineo_dalpha logical, private :: neoinit = .false. logical, private :: debug = .false. Subroutines public subroutine init_neoclassical_terms () Arguments None private subroutine read_parameters () Arguments None private subroutine distribute_vmus_over_procs (local, distributed) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :, :) :: local real, intent(out), dimension(vmu_lo%llim_proc:) :: distributed private subroutine get_dfneo_dvpa (fneo, dfneo) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, -nzgrid:, :, :, :) :: fneo real, intent(out), dimension(:, -nzgrid:, vmu_lo%llim_proc:) :: dfneo private subroutine get_dfneo_dzed (fneo, dfneo) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, -nzgrid:, :, :, :) :: fneo real, intent(out), dimension(:, -nzgrid:, vmu_lo%llim_proc:) :: dfneo private subroutine get_dfneo_drho (fneo, dfneo) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, -nzgrid:, :, :, :, -nradii/2:) :: fneo real, intent(out), dimension(:, -nzgrid:, vmu_lo%llim_proc:) :: dfneo private subroutine get_dphineo_dzed (phineo, dphineo) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, -nzgrid:) :: phineo real, intent(out), dimension(:, -nzgrid:) :: dphineo private subroutine get_dphineo_drho (phineo, dphineo) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, -nzgrid:, -nradii/2:) :: phineo real, intent(out), dimension(:, -nzgrid:) :: dphineo private subroutine write_neoclassical (fnc, phinc) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, -nzgrid:, :, :, :, -nradii/2:) :: fnc real, intent(in), dimension(:, -nzgrid:, -nradii/2:) :: phinc public subroutine finish_neoclassical_terms () Arguments None","tags":"","loc":"module/neoclassical_terms.html"},{"title":"dist_redistribute â€“ stella","text":"Uses redistribute Contents Variables kxkyz2vmu kxyz2vmu xyz2vmu redistribute_initialized Subroutines init_redistribute init_kxkyz_to_vmu_redistribute init_kxyz_to_vmu_redistribute init_xyz_to_vmu_redistribute finish_redistribute Variables Type Visibility Attributes Name Initial type( redist_type ), public :: kxkyz2vmu type( redist_type ), public :: kxyz2vmu type( redist_type ), public :: xyz2vmu logical, private :: redistribute_initialized = .false. Subroutines public subroutine init_redistribute () Arguments None private subroutine init_kxkyz_to_vmu_redistribute () Arguments None private subroutine init_kxyz_to_vmu_redistribute () Arguments None private subroutine init_xyz_to_vmu_redistribute () Arguments None public subroutine finish_redistribute () Arguments None","tags":"","loc":"module/dist_redistribute.html"},{"title":"gyro_averages â€“ stella","text":"inverse fourier transform coefs%fourier for several phase space points and compare with\nunfiltered version in alpha-space Uses common_types Contents Variables aj0x aj1x aj0v aj1v j0_ffs j0_B_maxwell_ffs bessinit debug Interfaces gyro_average gyro_average_j1 Subroutines init_bessel init_bessel_ffs find_max_required_kalpha_index finish_bessel gyro_average_kxky_local gyro_average_kxkyz_local gyro_average_ffs_kxky_local gyro_average_ffs_kxkyz_local gyro_average_ffs gyro_average_vmu_local gyro_average_vmus_nonlocal gyro_average_j1_kxky_local gyro_average_j1_kxkyz_local gyro_average_j1_vmu_local band_lu_solve_ffs band_lu_solve_ffs_single band_lu_factorisation_ffs band_lu_factorisation_single Variables Type Visibility Attributes Name Initial real, public, dimension(:, :, :, :), allocatable :: aj0x real, public, dimension(:, :, :, :), allocatable :: aj1x real, public, dimension(:, :), allocatable :: aj0v real, public, dimension(:, :), allocatable :: aj1v type( coupled_alpha_type ), public, dimension(:, :, :, :), allocatable :: j0_ffs type( coupled_alpha_type ), public, dimension(:, :, :, :), allocatable :: j0_B_maxwell_ffs logical, private :: bessinit = .false. logical, private :: debug = .false. Interfaces public interface gyro_average private subroutine gyro_average_kxky_local (field, iz, ivmu, gyro_field) if simulating a full flux surface, the alpha dependence present\nin kperp makes gyro-averaging non-local in k-space\nif simulating a flux tube, a gyro-average is local in k-space Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: field integer, intent(in) :: iz integer, intent(in) :: ivmu complex, intent(out), dimension(:, :) :: gyro_field private subroutine gyro_average_kxkyz_local (field, ivmu, gyro_field) if simulating a full flux surface, the alpha dependence present\nin kperp makes gyro-averaging non-local in k-space\nif simulating a flux tube, a gyro-average is local in k-space Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: field integer, intent(in) :: ivmu complex, intent(out), dimension(:, :, -nzgrid:, :) :: gyro_field private subroutine gyro_average_vmu_local (distfn, ikxkyz, gyro_distfn) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: distfn integer, intent(in) :: ikxkyz complex, intent(out), dimension(:, :) :: gyro_distfn private subroutine gyro_average_vmus_nonlocal (field, iky, ikx, iz, gyro_field) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(vmu_lo%llim_proc:) :: field integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz complex, intent(out), dimension(vmu_lo%llim_proc:) :: gyro_field private subroutine gyro_average_ffs_kxky_local (field, gyro_field, coefs) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: field complex, intent(out), dimension(:, :) :: gyro_field type( coupled_alpha_type ), intent(in), dimension(:, :) :: coefs private subroutine gyro_average_ffs_kxkyz_local (field, gyro_field, coefs) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: field complex, intent(out), dimension(:, :, -nzgrid:, :) :: gyro_field type( coupled_alpha_type ), intent(in), dimension(:, :, -nzgrid:) :: coefs private subroutine gyro_average_ffs (dist, gyro_dist, coefs) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dist complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gyro_dist type( coupled_alpha_type ), intent(in), dimension(:, :, -nzgrid:, vmu_lo%llim_proc:) :: coefs public interface gyro_average_j1 private subroutine gyro_average_j1_kxky_local (field, iz, ivmu, gyro_field) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: field integer, intent(in) :: iz integer, intent(in) :: ivmu complex, intent(out), dimension(:, :) :: gyro_field private subroutine gyro_average_j1_kxkyz_local (field, ivmu, gyro_field) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: field integer, intent(in) :: ivmu complex, intent(out), dimension(:, :, -nzgrid:, :) :: gyro_field private subroutine gyro_average_j1_vmu_local (distfn, ikxkyz, gyro_distfn) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: distfn integer, intent(in) :: ikxkyz complex, intent(out), dimension(:, :) :: gyro_distfn Subroutines public subroutine init_bessel () Arguments None private subroutine init_bessel_ffs () aj0_alpha will contain J_0 as a function of k_alpha and alpha\nj0_B_maxwell will contain J_0 B exp(-v&#94;2) as a function of k_alpha and alpha\nfor each value of alpha, take kperp&#94;2 calculated on domain kx = [-kx_max, kx_max] and ky = [0, ky_max]\nand use symmetry to obtain kperp&#94;2 on domain kx = [0, kx_max] and ky = [-ky_max, ky_max]\nthis makes later convolutions involving sums over all ky more straightforward\ncalculate the argument of the Bessel function, which depends on both alpha and k_alpha Read moreâ€¦ Arguments None private subroutine find_max_required_kalpha_index (ft, idx, imu, iz, is) subroutine takes a set of Fourier coefficients (ft)\nand returns the minimum number of coeffients that must be retained (idx)\nto ensure that the relative error in the total spectral energy is\nbelow a specified tolerance (tol_floor) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: ft integer, intent(out) :: idx integer, intent(in), optional :: imu integer, intent(in), optional :: iz integer, intent(in), optional :: is public subroutine finish_bessel () Arguments None private subroutine gyro_average_kxky_local (field, iz, ivmu, gyro_field) if simulating a full flux surface, the alpha dependence present\nin kperp makes gyro-averaging non-local in k-space\nif simulating a flux tube, a gyro-average is local in k-space Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: field integer, intent(in) :: iz integer, intent(in) :: ivmu complex, intent(out), dimension(:, :) :: gyro_field private subroutine gyro_average_kxkyz_local (field, ivmu, gyro_field) if simulating a full flux surface, the alpha dependence present\nin kperp makes gyro-averaging non-local in k-space\nif simulating a flux tube, a gyro-average is local in k-space Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: field integer, intent(in) :: ivmu complex, intent(out), dimension(:, :, -nzgrid:, :) :: gyro_field private subroutine gyro_average_ffs_kxky_local (field, gyro_field, coefs) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: field complex, intent(out), dimension(:, :) :: gyro_field type( coupled_alpha_type ), intent(in), dimension(:, :) :: coefs private subroutine gyro_average_ffs_kxkyz_local (field, gyro_field, coefs) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: field complex, intent(out), dimension(:, :, -nzgrid:, :) :: gyro_field type( coupled_alpha_type ), intent(in), dimension(:, :, -nzgrid:) :: coefs private subroutine gyro_average_ffs (dist, gyro_dist, coefs) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dist complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gyro_dist type( coupled_alpha_type ), intent(in), dimension(:, :, -nzgrid:, vmu_lo%llim_proc:) :: coefs private subroutine gyro_average_vmu_local (distfn, ikxkyz, gyro_distfn) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: distfn integer, intent(in) :: ikxkyz complex, intent(out), dimension(:, :) :: gyro_distfn private subroutine gyro_average_vmus_nonlocal (field, iky, ikx, iz, gyro_field) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(vmu_lo%llim_proc:) :: field integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz complex, intent(out), dimension(vmu_lo%llim_proc:) :: gyro_field private subroutine gyro_average_j1_kxky_local (field, iz, ivmu, gyro_field) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: field integer, intent(in) :: iz integer, intent(in) :: ivmu complex, intent(out), dimension(:, :) :: gyro_field private subroutine gyro_average_j1_kxkyz_local (field, ivmu, gyro_field) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: field integer, intent(in) :: ivmu complex, intent(out), dimension(:, :, -nzgrid:, :) :: gyro_field private subroutine gyro_average_j1_vmu_local (distfn, ikxkyz, gyro_distfn) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: distfn integer, intent(in) :: ikxkyz complex, intent(out), dimension(:, :) :: gyro_distfn public subroutine band_lu_solve_ffs (lu, solvec) Arguments Type Intent Optional Attributes Name type( gam0_ffs_type ), intent(in), dimension(:, -nzgrid:) :: lu complex, intent(inout), dimension(:, :, -nzgrid:) :: solvec private subroutine band_lu_solve_ffs_single (lu, solvec) Arguments Type Intent Optional Attributes Name type( gam0_ffs_type ), intent(in) :: lu complex, intent(inout), dimension(:) :: solvec public subroutine band_lu_factorisation_ffs (gam0, lu_gam0) Arguments Type Intent Optional Attributes Name type( coupled_alpha_type ), intent(in), dimension(:, :, -nzgrid:) :: gam0 type( gam0_ffs_type ), intent(out), dimension(:, -nzgrid:) :: lu_gam0 private subroutine band_lu_factorisation_single (gam0, lu_gam0) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gam0 type( gam0_ffs_type ), intent(out) :: lu_gam0","tags":"","loc":"module/gyro_averages.html"},{"title":"flow_shear â€“ stella","text":"Contents Variables flow_shear_initialized upwind_advect prl_shear prl_shear_p prp_shear shift_times shift_sign shift_start v_edge v_shift Subroutines init_flow_shear advance_parallel_flow_shear advance_perp_flow_shear finish_flow_shear Variables Type Visibility Attributes Name Initial logical, public :: flow_shear_initialized = .false. complex, private, dimension(:, :), allocatable :: upwind_advect real, public, dimension(:, :, :), allocatable :: prl_shear real, public, dimension(:, :, :), allocatable :: prl_shear_p real, public, dimension(:), allocatable :: prp_shear real, public, dimension(:), allocatable :: shift_times integer, private :: shift_sign integer, private :: shift_start real, public :: v_edge real, public :: v_shift = 0. Subroutines public subroutine init_flow_shear () Arguments None public subroutine advance_parallel_flow_shear (gout) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout public subroutine advance_perp_flow_shear (g) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g public subroutine finish_flow_shear () Arguments None","tags":"","loc":"module/flow_shear.html"},{"title":"stella_save â€“ stella","text":"Uses mp Contents Variables read_many save_many restart_file Interfaces stella_restore Subroutines stella_save_for_restart stella_restore_many init_save init_dt init_tstart finish_save Variables Type Visibility Attributes Name Initial logical, public :: read_many = .true. logical, public :: save_many = .true. character(len=300), private, save :: restart_file Interfaces public interface stella_restore private subroutine stella_restore_many (g, scale, istatus) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :, kxkyz_lo%llim_proc:) :: g real, intent(in) :: scale integer, intent(out) :: istatus Subroutines public subroutine stella_save_for_restart (g, istep0, t0, delt0, istatus, exit_in, fileopt) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g integer, intent(in) :: istep0 real, intent(in) :: t0 real, intent(in) :: delt0 integer, intent(out) :: istatus logical, intent(in), optional :: exit_in character(len=20), intent(in), optional :: fileopt private subroutine stella_restore_many (g, scale, istatus) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :, kxkyz_lo%llim_proc:) :: g real, intent(in) :: scale integer, intent(out) :: istatus public subroutine init_save (file) Arguments Type Intent Optional Attributes Name character(len=300), intent(in) :: file public subroutine init_dt (delt0, istatus) Arguments Type Intent Optional Attributes Name real, intent(inout) :: delt0 integer, intent(out) :: istatus public subroutine init_tstart (tstart, istep0, istatus) Arguments Type Intent Optional Attributes Name real, intent(inout) :: tstart integer, intent(out) :: istep0 integer, intent(out) :: istatus public subroutine finish_save () Arguments None","tags":"","loc":"module/stella_save.html"},{"title":"dissipation â€“ stella","text":"Contents Variables include_collisions vpa_operator mu_operator collisions_implicit momentum_conservation energy_conservation hyper_dissipation use_physical_ksqr D_hyper cfl_dt_vpadiff cfl_dt_mudiff density_conservation density_conservation_field density_conservation_tp exact_conservation_tp exact_conservation spitzer_problem no_j1l1 no_j1l2 no_j0l2 fieldpart testpart interspec intraspec advfield_coll collision_model nresponse nresponse_vpa nresponse_mu cfac cfac2 nuxfac iiknob ieknob eeknob eiknob eiediffknob eideflknob deflknob eimassr_approx jmax lmax nvel_local aa_vpa bb_vpa cc_vpa aa_mu cc_mu bb_mu vpadiff_response vpadiff_idx mudiff_response mudiff_idx fp_response diff_idx vpadiff_zf_response vpadiff_zf_idx mudiff_zf_response mudiff_zf_idx aa_blcs cc_blcs bb_blcs cdiffmat_band blockmatrix blockmatrix_sum ipiv nus nuD nupa nux mw modmw velvpamu info wgts_v vel deltaj deltaj_tp deltajint psijnorm legendre_vpamu jm jm0 mwnorm modmwnorm collisions_initialized time_collisions i1fac i2fac Functions associated_laguerre associated_legendre Subroutines init_dissipation read_parameters init_collisions init_nusDpa finish_nusDpa init_fp_diffmatrix init_legendre init_bessel_fn init_vgrid gamlow gamup calc_delta0 calc_deltaj_vmu vLj_vmu calc_psi_vmu init_deltaj_vmu get_testpart_density init_fp_conserve get_psi_response get_psi init_vpadiff_matrix init_mudiff_matrix init_vpadiff_conserve init_mudiff_conserve get_upar get_uperp get_temp get_temp_mu finish_dissipation finish_collisions finish_deltaj finish_fp_diffmatrix finish_fp_response finish_vpadiff_matrix finish_mudiff_matrix finish_vpadiff_response finish_mudiff_response advance_collisions_explicit vpa_differential_operator_fp mu_differential_operator_fp vpa_differential_operator_fp_conservative mu_differential_operator_fp_conservative vpa_differential_operator mu_differential_operator conserve_momentum conserve_energy conserve_momentum_vmulo conserve_energy_vmulo advance_collisions_implicit advance_implicit_fp advance_vpadiff_implicit advance_mudiff_implicit advance_hyper_dissipation Variables Type Visibility Attributes Name Initial logical, public :: include_collisions logical, public :: vpa_operator logical, public :: mu_operator logical, public :: collisions_implicit logical, private :: momentum_conservation logical, private :: energy_conservation logical, public :: hyper_dissipation logical, private :: use_physical_ksqr real, private :: D_hyper real, public :: cfl_dt_vpadiff real, public :: cfl_dt_mudiff logical, private :: density_conservation logical, private :: density_conservation_field logical, private :: density_conservation_tp logical, private :: exact_conservation_tp logical, private :: exact_conservation logical, private :: spitzer_problem logical, private :: no_j1l1 logical, private :: no_j1l2 logical, private :: no_j0l2 logical, public :: fieldpart logical, private :: testpart logical, private :: interspec logical, private :: intraspec logical, private :: advfield_coll character(len=30), private :: collision_model integer, private :: nresponse = 1 integer, private :: nresponse_vpa = 1 integer, private :: nresponse_mu = 1 real, private :: cfac real, private :: cfac2 real, private :: nuxfac real, private :: iiknob real, private :: ieknob real, private :: eeknob real, private :: eiknob real, private :: eiediffknob real, private :: eideflknob real, private :: deflknob logical, private :: eimassr_approx integer, private :: jmax = 1 integer, private :: lmax = 1 integer, private :: nvel_local real, private, dimension(:, :), allocatable :: aa_vpa real, private, dimension(:, :), allocatable :: bb_vpa real, private, dimension(:, :), allocatable :: cc_vpa real, private, dimension(:, :, :), allocatable :: aa_mu real, private, dimension(:, :, :), allocatable :: cc_mu real, private, dimension(:, :), allocatable :: bb_mu complex, private, dimension(:, :, :), allocatable :: vpadiff_response integer, private, dimension(:, :), allocatable :: vpadiff_idx complex, private, dimension(:, :, :), allocatable :: mudiff_response integer, private, dimension(:, :), allocatable :: mudiff_idx complex, private, dimension(:, :, :), allocatable :: fp_response integer, private, dimension(:, :), allocatable :: diff_idx complex, private, dimension(:, :, :), allocatable :: vpadiff_zf_response integer, private, dimension(:, :), allocatable :: vpadiff_zf_idx complex, private, dimension(:, :, :), allocatable :: mudiff_zf_response integer, private, dimension(:, :), allocatable :: mudiff_zf_idx complex, private, dimension(:, :, :, :, :), allocatable :: aa_blcs complex, private, dimension(:, :, :, :, :), allocatable :: cc_blcs complex, private, dimension(:, :, :, :, :), allocatable :: bb_blcs complex, private, dimension(:, :, :, :, :, :), allocatable :: cdiffmat_band complex, private, dimension(:, :, :, :), allocatable :: blockmatrix complex, private, dimension(:, :, :), allocatable :: blockmatrix_sum integer, private, dimension(:, :, :, :, :), allocatable :: ipiv real, private, dimension(:, :, :, :, :), allocatable :: nus real, private, dimension(:, :, :, :, :), allocatable :: nuD real, private, dimension(:, :, :, :, :), allocatable :: nupa real, private, dimension(:, :, :, :, :), allocatable :: nux real, private, dimension(:, :, :, :), allocatable :: mw real, private, dimension(:, :, :, :), allocatable :: modmw real, private, dimension(:, :, :), allocatable :: velvpamu integer, private :: info real, private, dimension(:), allocatable :: wgts_v real, private, dimension(:), allocatable :: vel real, private, dimension(:, :, :, :, :, :, :, :), allocatable :: deltaj real, private, dimension(:, :, :, :, :, :, :, :), allocatable :: deltaj_tp complex, private, dimension(:, :, :, :), allocatable :: deltajint real, private, dimension(:, :, :, :, :), allocatable :: psijnorm real, private, dimension(:, :, :, :, :), allocatable :: legendre_vpamu real, private, dimension(:, :, :, :, :, :), allocatable :: jm real, private, dimension(:, :, :, :, :), allocatable :: jm0 real, private, dimension(:), allocatable :: mwnorm real, private, dimension(:), allocatable :: modmwnorm logical, public :: collisions_initialized = .false. real, public, dimension(2, 2) :: time_collisions = 0. real, private :: i1fac real, private :: i2fac Functions private elemental function associated_laguerre (n, alpha, x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real, intent(in) :: alpha real, intent(in) :: x Return Value real private elemental function associated_legendre (l, m, x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: l integer, intent(in) :: m double precision, intent(in) :: x Return Value double precision Subroutines public subroutine init_dissipation () Arguments None private subroutine read_parameters () Arguments None public subroutine init_collisions () Arguments None private subroutine init_nusDpa () Arguments None private subroutine finish_nusDpa () Arguments None private subroutine init_fp_diffmatrix () Arguments None private subroutine init_legendre () Arguments None private subroutine init_bessel_fn () Arguments None private subroutine init_vgrid () Arguments None private recursive subroutine gamlow (a, x, gl) Arguments Type Intent Optional Attributes Name real, intent(in) :: a real, intent(in) :: x real, intent(out) :: gl private recursive subroutine gamup (a, x, gu) Arguments Type Intent Optional Attributes Name real, intent(in) :: a real, intent(in) :: x real, intent(out) :: gu private subroutine calc_delta0 (xa, jj, ll, isa, isb, delt0) Arguments Type Intent Optional Attributes Name real, intent(in) :: xa integer, intent(in) :: jj integer, intent(in) :: ll integer, intent(in) :: isa integer, intent(in) :: isb real, intent(out) :: delt0 private recursive subroutine calc_deltaj_vmu (jj, nn, ll, isa, isb, deltj) Arguments Type Intent Optional Attributes Name integer, intent(in) :: jj integer, intent(in) :: nn integer, intent(in) :: ll integer, intent(in) :: isa integer, intent(in) :: isb real, intent(out), dimension(nvpa, nmu, -nzgrid:nzgrid) :: deltj private subroutine vLj_vmu (jj, ll, vLj) Arguments Type Intent Optional Attributes Name integer, intent(in) :: jj integer, intent(in) :: ll real, intent(out), dimension(nvpa, nmu, -nzgrid:nzgrid) :: vLj private recursive subroutine calc_psi_vmu (jj, nn, ll, isa, isb, psij) Arguments Type Intent Optional Attributes Name integer, intent(in) :: jj integer, intent(in) :: nn integer, intent(in) :: ll integer, intent(in) :: isa integer, intent(in) :: isb real, intent(out), dimension(-nzgrid:nzgrid) :: psij private subroutine init_deltaj_vmu () Arguments None private subroutine get_testpart_density (isa, isb, g, fld) Arguments Type Intent Optional Attributes Name integer, intent(in) :: isa integer, intent(in) :: isb complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: fld private subroutine init_fp_conserve () Arguments None private subroutine get_psi_response (ll, mm, jj, isa, response) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ll integer, intent(in) :: mm integer, intent(in) :: jj integer, intent(in) :: isa complex, intent(out), dimension(:, :, kxkyz_lo%llim_proc:) :: response private subroutine get_psi (g, fld, isa, isb, ll, mm, jj) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: fld integer, intent(in) :: isa integer, intent(in) :: isb integer, intent(in) :: ll integer, intent(in) :: mm integer, intent(in) :: jj private subroutine init_vpadiff_matrix () Arguments None private subroutine init_mudiff_matrix () Arguments None private subroutine init_vpadiff_conserve () Arguments None private subroutine init_mudiff_conserve () Arguments None private subroutine get_upar (g, fld) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: fld private subroutine get_uperp (g, fld) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: fld private subroutine get_temp (g, fld) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: fld private subroutine get_temp_mu (g, fld) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: fld public subroutine finish_dissipation () Arguments None private subroutine finish_collisions () Arguments None private subroutine finish_deltaj () Arguments None private subroutine finish_fp_diffmatrix () Arguments None private subroutine finish_fp_response () Arguments None private subroutine finish_vpadiff_matrix () Arguments None private subroutine finish_mudiff_matrix () Arguments None private subroutine finish_vpadiff_response () Arguments None private subroutine finish_mudiff_response () Arguments None public subroutine advance_collisions_explicit (g, phi, gke_rhs) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gke_rhs private subroutine vpa_differential_operator_fp (h, Dh, imu, iz, is, ia) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: h complex, intent(out), dimension(:, :) :: Dh integer, intent(in) :: imu integer, intent(in) :: iz integer, intent(in) :: is integer, intent(in) :: ia private subroutine mu_differential_operator_fp (h, Dh, iv, iz, is, ia, iky, ikx, cfac) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: h complex, intent(out), dimension(:, :) :: Dh integer, intent(in) :: iv integer, intent(in) :: iz integer, intent(in) :: is integer, intent(in) :: ia integer, intent(in) :: iky integer, intent(in) :: ikx real, intent(in) :: cfac private subroutine vpa_differential_operator_fp_conservative (h, Dh, imu, iz, is, ia) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: h complex, intent(out), dimension(:, :) :: Dh integer, intent(in) :: imu integer, intent(in) :: iz integer, intent(in) :: is integer, intent(in) :: ia private subroutine mu_differential_operator_fp_conservative (h, Dh, iv, iz, is, ia, iky, ikx, cfac) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: h complex, intent(out), dimension(:, :) :: Dh integer, intent(in) :: iv integer, intent(in) :: iz integer, intent(in) :: is integer, intent(in) :: ia integer, intent(in) :: iky integer, intent(in) :: ikx real, intent(in) :: cfac private subroutine vpa_differential_operator (tfac, h, Dh) Arguments Type Intent Optional Attributes Name real, intent(in) :: tfac complex, intent(in), dimension(:) :: h complex, intent(out), dimension(:) :: Dh private subroutine mu_differential_operator (tfac, iz, ia, h, Dh) Arguments Type Intent Optional Attributes Name real, intent(in) :: tfac integer, intent(in) :: iz integer, intent(in) :: ia complex, intent(in), dimension(:) :: h complex, intent(out), dimension(:) :: Dh private subroutine conserve_momentum (iky, ikx, iz, is, ikxkyz, h, Ch) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: is integer, intent(in) :: ikxkyz complex, intent(in), dimension(:, :) :: h complex, intent(inout), dimension(:, :) :: Ch private subroutine conserve_energy (iz, is, ikxkyz, h, Ch) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iz integer, intent(in) :: is integer, intent(in) :: ikxkyz complex, intent(in), dimension(:, :) :: h complex, intent(inout), dimension(:, :) :: Ch private subroutine conserve_momentum_vmulo (h, gke_rhs) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: h complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gke_rhs private subroutine conserve_energy_vmulo (h, gke_rhs) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: h complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gke_rhs public subroutine advance_collisions_implicit (mirror_implicit, phi, apar, g) Arguments Type Intent Optional Attributes Name logical, intent(in) :: mirror_implicit complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :) :: apar complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g private subroutine advance_implicit_fp (phi, apar, g) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :) :: apar complex, intent(inout), dimension(:, :, kxkyz_lo%llim_proc:) :: g private subroutine advance_vpadiff_implicit (phi, apar, g) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :) :: apar complex, intent(inout), dimension(:, :, kxkyz_lo%llim_proc:) :: g private subroutine advance_mudiff_implicit (phi, apar, g) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :) :: apar complex, intent(inout), dimension(:, :, kxkyz_lo%llim_proc:) :: g public subroutine advance_hyper_dissipation (g) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g","tags":"","loc":"module/dissipation.html"},{"title":"kt_grids â€“ stella","text":"Contents Variables theta0 zed0 aky akx aky_all aky_all_ordered x x_d y rho rho_d rho_clamped rho_d_clamped g0x dx dy dkx dky dx_d jtwistfac phase_shift_fac naky nakx nx ny nalpha jtwist ikx_twist_shift ikx_max naky_all boundary_size copy_size krook_size reality centered_in_rho periodic_variation randomize_phase_shift grid_option zonal_mode gridopt_switch gridopt_range gridopt_box aky_min aky_max akx_min akx_max theta0_min theta0_max x0 y0 read_kt_grids_initialized init_kt_grids_initialized box Interfaces swap_kxky swap_kxky_ordered Subroutines read_kt_grids_parameters read_grid_option read_kt_grids_box read_kt_grids_range init_kt_grids init_kt_grids_box init_kt_grids_range broadcast_input dump_radial_grid allocate_arrays swap_kxky_complex swap_kxky_real swap_kxky_ordered_real swap_kxky_ordered_complex swap_kxky_back swap_kxky_back_ordered communicate_ktgrids_multibox finish_kt_grids multiply_by_rho Variables Type Visibility Attributes Name Initial real, public, dimension(:, :), allocatable :: theta0 real, public, dimension(:, :), allocatable :: zed0 real, public, dimension(:), allocatable :: aky real, public, dimension(:), allocatable :: akx real, public, dimension(:), allocatable :: aky_all real, public, dimension(:), allocatable :: aky_all_ordered real, public, dimension(:), allocatable :: x real, public, dimension(:), allocatable :: x_d real, public, dimension(:), allocatable :: y real, public, dimension(:), allocatable :: rho real, public, dimension(:), allocatable :: rho_d real, public, dimension(:), allocatable :: rho_clamped real, public, dimension(:), allocatable :: rho_d_clamped complex, private, dimension(:, :), allocatable :: g0x real, public :: dx real, public :: dy real, public :: dkx real, public :: dky real, public :: dx_d real, public :: jtwistfac real, public :: phase_shift_fac integer, public :: naky integer, public :: nakx integer, public :: nx integer, public :: ny integer, public :: nalpha integer, public :: jtwist integer, public :: ikx_twist_shift integer, public :: ikx_max integer, public :: naky_all integer, public :: boundary_size integer, public :: copy_size integer, public :: krook_size logical, public :: reality = .false. logical, public :: centered_in_rho logical, public :: periodic_variation logical, private :: randomize_phase_shift character(len=20), private :: grid_option logical, public, dimension(:), allocatable :: zonal_mode integer, private :: gridopt_switch integer, private, parameter :: gridopt_range = 1 integer, private, parameter :: gridopt_box = 2 real, private :: aky_min real, private :: aky_max real, private :: akx_min real, private :: akx_max real, private :: theta0_min real, private :: theta0_max real, public :: x0 real, public :: y0 logical, private :: read_kt_grids_initialized = .false. logical, private :: init_kt_grids_initialized = .false. logical, public :: box Interfaces public interface swap_kxky private subroutine swap_kxky_real (gin, gout) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: gin real, intent(out), dimension(:, :) :: gout private subroutine swap_kxky_complex (gin, gout) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout public interface swap_kxky_ordered private subroutine swap_kxky_ordered_real (gin, gout) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: gin real, intent(out), dimension(:, :) :: gout private subroutine swap_kxky_ordered_complex (gin, gout) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout Subroutines public subroutine read_kt_grids_parameters () Arguments None private subroutine read_grid_option () Arguments None private subroutine read_kt_grids_box () Arguments None private subroutine read_kt_grids_range () Arguments None public subroutine init_kt_grids () determine if iky corresponds to zonal mode Arguments None private subroutine init_kt_grids_box () set jtwist and y0 for cases where they have not been specified\nand for which it makes sense to set them automatically\nsigned version of jtwist, with sign determined by, e.g., magnetic shear Read moreâ€¦ Arguments None private subroutine init_kt_grids_range () Arguments None private subroutine broadcast_input () Arguments None private subroutine dump_radial_grid () Arguments None private subroutine allocate_arrays () Arguments None private subroutine swap_kxky_complex (gin, gout) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout private subroutine swap_kxky_real (gin, gout) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: gin real, intent(out), dimension(:, :) :: gout private subroutine swap_kxky_ordered_real (gin, gout) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: gin real, intent(out), dimension(:, :) :: gout private subroutine swap_kxky_ordered_complex (gin, gout) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout public subroutine swap_kxky_back (gin, gout) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout public subroutine swap_kxky_back_ordered (gin, gout) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout public subroutine communicate_ktgrids_multibox () Arguments None public subroutine finish_kt_grids () Arguments None public subroutine multiply_by_rho (gin) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: gin","tags":"","loc":"module/kt_grids.html"},{"title":"physics_parameters â€“ stella","text":"Contents Variables beta zeff tite nine rhostar irhostar vnew_ref g_exb g_exbfac omprimfac initialized Subroutines init_physics_parameters read_parameters finish_physics_parameters Variables Type Visibility Attributes Name Initial real, public :: beta real, public :: zeff real, public :: tite real, public :: nine real, public :: rhostar real, private :: irhostar real, public :: vnew_ref real, public :: g_exb real, public :: g_exbfac real, public :: omprimfac logical, private :: initialized = .false. Subroutines public subroutine init_physics_parameters () Arguments None private subroutine read_parameters () Arguments None public subroutine finish_physics_parameters () Arguments None","tags":"","loc":"module/physics_parameters.html"},{"title":"sfincs_interface â€“ stella","text":"Contents Subroutines get_neo_from_sfincs Subroutines public subroutine get_neo_from_sfincs (nradii, drho, f_neoclassical, phi_neoclassical, dfneo_dalpha, dphineo_dalpha) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nradii real, intent(in) :: drho real, intent(out), dimension(:, -nzgrid:, :, :, :, -nradii/2:) :: f_neoclassical real, intent(out), dimension(:, -nzgrid:, -nradii/2:) :: phi_neoclassical real, intent(out), dimension(:, -nzgrid:, :, :, :) :: dfneo_dalpha real, intent(out), dimension(:, -nzgrid:) :: dphineo_dalpha","tags":"","loc":"module/sfincs_interface.html"},{"title":"response_matrix â€“ stella","text":"Uses netcdf mpi Contents Variables response_matrix_initialized mat_unit Subroutines init_response_matrix read_response_matrix get_dgdphi_matrix_column sweep_zed_zonal_response integrate_over_velocity get_fields_for_response_matrix finish_response_matrix Variables Type Visibility Attributes Name Initial logical, public :: response_matrix_initialized = .false. integer, private, parameter :: mat_unit = 70 Subroutines public subroutine init_response_matrix () Arguments None public subroutine read_response_matrix () Arguments None private subroutine get_dgdphi_matrix_column (iky, ikx, iz, ie, idx, nz_ext, nresponse, phiext, gext) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: ie integer, intent(in) :: idx integer, intent(in) :: nz_ext integer, intent(in) :: nresponse complex, intent(inout), dimension(:) :: phiext complex, intent(inout), dimension(:, vmu_lo%llim_proc:) :: gext private subroutine sweep_zed_zonal_response (iv, is, sgn, g) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv integer, intent(in) :: is integer, intent(in) :: sgn complex, intent(inout), dimension(:) :: g private subroutine integrate_over_velocity (g, phi, iky, ie) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:) :: phi integer, intent(in) :: iky integer, intent(in) :: ie private subroutine get_fields_for_response_matrix (phi, iky, ie) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: phi integer, intent(in) :: iky integer, intent(in) :: ie public subroutine finish_response_matrix () Arguments None","tags":"","loc":"module/response_matrix.html"},{"title":"zgrid â€“ stella","text":"Contents Variables nzed nzgrid nztot nz2pi nperiod ntubes zed_equal_arc shat_zero grad_x_grad_y_zero zed delzed boundary_option_switch boundary_option_zero boundary_option_self_periodic boundary_option_linked twist_shift_option_switch twist_shift_option_std twist_shift_option_stellarator twist_shift_option_periodic zgridinit Subroutines init_zgrid read_parameters broadcast_parameters finish_zgrid get_total_arc_length get_arc_length_grid integrate_zed Variables Type Visibility Attributes Name Initial integer, public :: nzed integer, public :: nzgrid integer, public :: nztot integer, public :: nz2pi integer, public :: nperiod integer, public :: ntubes logical, public :: zed_equal_arc real, public :: shat_zero real, public :: grad_x_grad_y_zero real, public, dimension(:), allocatable :: zed real, public, dimension(:), allocatable :: delzed integer, public :: boundary_option_switch integer, public, parameter :: boundary_option_zero = 1 integer, public, parameter :: boundary_option_self_periodic = 2 integer, public, parameter :: boundary_option_linked = 3 integer, public :: twist_shift_option_switch integer, public, parameter :: twist_shift_option_std = 1 integer, public, parameter :: twist_shift_option_stellarator = 2 integer, public, parameter :: twist_shift_option_periodic = 3 logical, private :: zgridinit = .false. Subroutines public subroutine init_zgrid () Arguments None private subroutine read_parameters () Arguments None private subroutine broadcast_parameters () Arguments None public subroutine finish_zgrid () Arguments None public subroutine get_total_arc_length (nz, gp, dz, length) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nz real, intent(in), dimension(-nz:) :: gp real, intent(in) :: dz real, intent(out) :: length public subroutine get_arc_length_grid (nz_max, nzext_max, zboundary, gp, dz, zarc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nz_max integer, intent(in) :: nzext_max real, intent(in) :: zboundary real, intent(in), dimension(-nzext_max:) :: gp real, intent(in) :: dz real, intent(out), dimension(-nzext_max:) :: zarc private subroutine integrate_zed (nz, dz, f, intf) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nz real, intent(in) :: dz real, intent(in), dimension(-nz:) :: f real, intent(out) :: intf","tags":"","loc":"module/zgrid.html"},{"title":"stella_diagnostics â€“ stella","text":"Routines for calculating and writing various physical diagnostics Contents Variables ntg_out nwrite nsave navg nc_mult stdout_unit fluxes_unit omega_unit save_for_restart write_omega write_moments write_phi_vs_time write_gvmus write_gzvs write_kspectra write_radial_fluxes write_radial_moments write_fluxes_kxkyz flux_norm pflux_avg vflux_avg qflux_avg heat_avg pflux vflux qflux exchange omega_vs_time nout diagnostics_initialized debug Subroutines init_stella_diagnostics read_parameters allocate_arrays open_loop_ascii_files close_loop_ascii_files diagnose_stella get_fluxes get_fluxes_vmulo get_fluxes_ffs get_one_flux_ffs get_modified_fourier_coefficient get_one_flux get_one_flux_vmulo get_one_flux_radial get_moments get_moments_ffs g_to_f get_gvmus get_gzvs finish_stella_diagnostics write_loop_ascii_files write_final_ascii_files deallocate_arrays Variables Type Visibility Attributes Name Initial integer, private :: ntg_out integer, private :: nwrite integer, public :: nsave integer, private :: navg integer, private :: nc_mult integer, private :: stdout_unit integer, private :: fluxes_unit integer, private :: omega_unit logical, private :: save_for_restart logical, private :: write_omega logical, private :: write_moments logical, private :: write_phi_vs_time logical, private :: write_gvmus logical, private :: write_gzvs logical, private :: write_kspectra logical, private :: write_radial_fluxes logical, private :: write_radial_moments logical, private :: write_fluxes_kxkyz logical, private :: flux_norm real, private, dimension(:), allocatable :: pflux_avg Arrays needed for averaging in x,y,z real, private, dimension(:), allocatable :: vflux_avg Arrays needed for averaging in x,y,z real, private, dimension(:), allocatable :: qflux_avg Arrays needed for averaging in x,y,z real, private, dimension(:), allocatable :: heat_avg Arrays needed for averaging in x,y,z real, private, dimension(:, :, :), allocatable :: pflux real, private, dimension(:, :, :), allocatable :: vflux real, private, dimension(:, :, :), allocatable :: qflux real, private, dimension(:, :, :), allocatable :: exchange complex, private, dimension(:, :, :), allocatable :: omega_vs_time Needed for calculating growth rates and frequencies integer, private :: nout = 1 Current maximum index of the time dimension in the netCDF file logical, private :: diagnostics_initialized = .false. Has this module been initialised? logical, private :: debug = .false. Debugging Subroutines public subroutine init_stella_diagnostics (restart, tstart) Initialise the stella_diagnostics module Read moreâ€¦ Arguments Type Intent Optional Attributes Name logical, intent(in) :: restart Has this simulation been restarted? real, intent(in) :: tstart Current simulation time private subroutine read_parameters () Read the diagnostic input parameters from the input file Read moreâ€¦ Arguments None private subroutine allocate_arrays () Allocate the module-level arrays Arguments None private subroutine open_loop_ascii_files (restart) Open the '.out' and the '.fluxes' file. Read moreâ€¦ Arguments Type Intent Optional Attributes Name logical, intent(in) :: restart private subroutine close_loop_ascii_files () Close the text files opened by open_loop_ascii_files Arguments None public subroutine diagnose_stella (istep) Calculate and write diagnostics Read moreâ€¦ Arguments Type Intent Optional Attributes Name integer, intent(in) :: istep The current timestep private subroutine get_fluxes (g, pflx, vflx, qflx, pflx_vs_kxkyz, vflx_vs_kxkyz, qflx_vs_kxkyz) Calculate fluxes Read moreâ€¦ Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g real, intent(out), dimension(:) :: pflx real, intent(out), dimension(:) :: vflx real, intent(out), dimension(:) :: qflx real, intent(out), dimension(:, :, -nzgrid:, :, :) :: pflx_vs_kxkyz real, intent(out), dimension(:, :, -nzgrid:, :, :) :: vflx_vs_kxkyz real, intent(out), dimension(:, :, -nzgrid:, :, :) :: qflx_vs_kxkyz private subroutine get_fluxes_vmulo (g, phi, pflx, vflx, qflx, pflx_x, vflx_x, qflx_x) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi real, intent(out), dimension(:) :: pflx real, intent(out), dimension(:) :: vflx real, intent(out), dimension(:) :: qflx real, intent(out), dimension(:, :) :: pflx_x real, intent(out), dimension(:, :) :: vflx_x real, intent(out), dimension(:, :) :: qflx_x private subroutine get_fluxes_ffs (dens, upar, pres, pflx, vflx, qflx, pflx_vs_kxkyz, vflx_vs_kxkyz, qflx_vs_kxkyz) Calculate the total particle, momentum and heat fluxes (pflx, vflx, qflx)\nand the contributions from a given (kx,ky,z) location (pflx_kxkyz, vflx_kxkyz, qflx_kxkyz)\ninputs are the particle density (dens), parallel flow (upar) and pressure (pres) Read moreâ€¦ Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: dens complex, intent(in), dimension(:, :, -nzgrid:, :) :: upar complex, intent(in), dimension(:, :, -nzgrid:, :) :: pres real, intent(out), dimension(:) :: pflx real, intent(out), dimension(:) :: vflx real, intent(out), dimension(:) :: qflx real, intent(out), dimension(:, :, -nzgrid:, :, :) :: pflx_vs_kxkyz real, intent(out), dimension(:, :, -nzgrid:, :, :) :: vflx_vs_kxkyz real, intent(out), dimension(:, :, -nzgrid:, :, :) :: qflx_vs_kxkyz private subroutine get_one_flux_ffs (mom, dphidy, flxfac, flx, flx_vs_kxkyz) divide the input density by the magnetic field strength (due to Jacobian in flux-surfacee avg)\nand Fourier transform in y to get mom_ky = (density/B)(ky,kx,z,spec)\npflx_vs_kxkyz is the particle flux before summing over (kx,ky) and integrating over z\ncalculate the volume average of the particle flux\nnote that the factor of 1/B that appears in the Jacobian has already been taken into account\nin the numerator of the flux surface average Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: mom complex, intent(in), dimension(:, :, -nzgrid:) :: dphidy real, intent(in) :: flxfac real, intent(out), dimension(:) :: flx real, intent(out), dimension(:, :, -nzgrid:, :) :: flx_vs_kxkyz private subroutine get_modified_fourier_coefficient (moment, moment_ky) divide the input moment by the magnetic field strength\nto account for Jacobian in flux-surface average\ntransform the B-modified input moment from y to ky space\nswap from all ky and kx >= 0 to all kx and ky >= 0 Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: moment complex, intent(out), dimension(:, :, -nzgrid:, :) :: moment_ky private subroutine get_one_flux (iky, iz, norm, gin, fld, flxout) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky integer, intent(in) :: iz real, intent(in) :: norm complex, intent(in), dimension(:, :) :: gin complex, intent(in) :: fld real, intent(inout) :: flxout private subroutine get_one_flux_vmulo (weights, gin, fld, flxout) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: weights complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gin complex, intent(in), dimension(:, :, -nzgrid:, :) :: fld real, intent(inout), dimension(:) :: flxout private subroutine get_one_flux_radial (weights, gin, fld, flxout) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: weights complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gin complex, intent(in), dimension(:, :, -nzgrid:, :) :: fld real, intent(inout), dimension(:, :) :: flxout private subroutine get_moments (g, dens, upar, temp, dens_x, upar_x, temp_x, spitzer2) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: dens complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: upar complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: temp real, intent(out), dimension(:, :) :: dens_x real, intent(out), dimension(:, :) :: upar_x real, intent(out), dimension(:, :) :: temp_x complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: spitzer2 private subroutine get_moments_ffs (g, dens, upar, pres) species-dependent factor by which velocity moments must be multiplied\nto get density, pressure, etc.\nthe guiding centre distribution function, normalized by\nthe equilibrium Maxwellian, is passed in as g.\nto obtain moments such as density, flow and pressure,\nwe need to take moments of the distribution function, f,\nwhich is related to g via\nf/F0 = g + (Ze/T)*( _R - phi)\nobtain g0=f/F0 in Fourier space Read moreâ€¦ Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: dens complex, intent(out), dimension(:, :, -nzgrid:, :) :: upar complex, intent(out), dimension(:, :, -nzgrid:, :) :: pres private subroutine g_to_f (g, phi, f) the Fourier components of the guiding centre distribution function\nnormalized by the equilibrium Maxwellian is passed in as g,\nalong with the Fourier components of the electrostatic potential, phi.\ng_to_f calculates the Maxwellian-normalized distribution function f,\nwhich is related to g via\nf = g + (Ze/T)*( _R - phi) Read moreâ€¦ Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: f private subroutine get_gvmus (g, gv) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g real, intent(out), dimension(:, :, :) :: gv private subroutine get_gzvs (g, gz) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g real, intent(out), dimension(:, :, :, :) :: gz public subroutine finish_stella_diagnostics (istep) Arguments Type Intent Optional Attributes Name integer, intent(in) :: istep private subroutine write_loop_ascii_files (istep, phi2, apar2, pflx, vflx, qflx, om, om_avg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: istep real, intent(in) :: phi2 real, intent(in) :: apar2 real, intent(in), dimension(:) :: pflx real, intent(in), dimension(:) :: vflx real, intent(in), dimension(:) :: qflx complex, intent(in), dimension(:, :) :: om complex, intent(in), dimension(:, :) :: om_avg private subroutine write_final_ascii_files () Arguments None private subroutine deallocate_arrays () Arguments None","tags":"","loc":"module/stella_diagnostics.html"},{"title":"sources â€“ stella","text":"Contents Variables include_krook_operator remove_zero_projection krook_odd exclude_boundary_regions from_zero conserve_momentum conserve_density ikxmax_source nu_krook tcorr_source int_krook int_proj exp_fac qn_source_initialized include_qn_source debug time_sources Subroutines init_sources read_parameters init_source_timeaverage finish_sources add_krook_operator update_tcorr_krook enforce_momentum_conservation enforce_density_conservation project_out_zero init_quasineutrality_source update_quasineutrality_source Variables Type Visibility Attributes Name Initial logical, public :: include_krook_operator logical, public :: remove_zero_projection logical, private :: krook_odd logical, public :: exclude_boundary_regions logical, private :: from_zero logical, private :: conserve_momentum logical, private :: conserve_density integer, private :: ikxmax_source real, private :: nu_krook real, public :: tcorr_source real, public :: int_krook real, public :: int_proj real, public :: exp_fac logical, public :: qn_source_initialized logical, public :: include_qn_source logical, private :: debug = .false. real, public, dimension(2, 2) :: time_sources = 0. Subroutines public subroutine init_sources () Arguments None private subroutine read_parameters () Arguments None public subroutine init_source_timeaverage () Arguments None public subroutine finish_sources () Arguments None public subroutine add_krook_operator (g, gke_rhs) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:), target :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gke_rhs public subroutine update_tcorr_krook (g) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:), target :: g private subroutine enforce_momentum_conservation (g_work) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g_work private subroutine enforce_density_conservation (g_work) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, -nzgrid:, :, vmu_lo%llim_proc:) :: g_work public subroutine project_out_zero (gold, gnew) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gold complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gnew public subroutine init_quasineutrality_source () Arguments None public subroutine update_quasineutrality_source () Arguments None","tags":"","loc":"module/sources.html"},{"title":"mirror_terms â€“ stella","text":"Contents Variables mirror_initialized time_mirror mirror_sign mirror mirror_rad_var mirror_tri_a mirror_tri_b mirror_tri_c mirror_int_fac mirror_interp_loc mirror_interp_idx_shift Subroutines init_mirror init_mirror_semi_lagrange init_invert_mirror_operator advance_mirror_explicit add_mirror_radial_variation get_dgdvpa_ffs get_dgdvpa_explicit add_mirror_term add_mirror_term_ffs advance_mirror_implicit vpa_interpolation invert_mirror_operator finish_mirror finish_mirror_semi_lagrange finish_invert_mirror_operator Variables Type Visibility Attributes Name Initial logical, public :: mirror_initialized = .false. real, public, dimension(2, 2) :: time_mirror = 0. integer, private, dimension(:, :), allocatable :: mirror_sign real, public, dimension(:, :, :, :), allocatable :: mirror real, private, dimension(:, :, :, :), allocatable :: mirror_rad_var real, private, dimension(:, :, :), allocatable :: mirror_tri_a real, private, dimension(:, :, :), allocatable :: mirror_tri_b real, private, dimension(:, :, :), allocatable :: mirror_tri_c real, private, dimension(:, :, :), allocatable :: mirror_int_fac real, private, dimension(:, :, :, :), allocatable :: mirror_interp_loc integer, private, dimension(:, :, :, :), allocatable :: mirror_interp_idx_shift Subroutines public subroutine init_mirror () mirror has sign consistent with being on RHS of GKE;\nit is the factor multiplying dg/dvpa in the mirror term\nmirror_sign set to +/- 1 depending on the sign of the mirror term.\nNB: mirror_sign = -1 corresponds to positive advection velocity\nset up the tridiagonal matrix that must be inverted\nfor the implicit treatment of the mirror operator Arguments None private subroutine init_mirror_semi_lagrange () Arguments None private subroutine init_invert_mirror_operator () mirror_int_fac = exp(vpa&#94;2 * (mu dB/dz)/(mu dB/dz + Z e dpihnc/dz))\nis the integrating factor needed to turn the dg/dvpa part of the GKE advance\ninto an advection equation\na, b and c contain the sub-, main- and super-diagonal terms, respectively\nif running in full-flux-surface mode, solve mirror advance\nin y-space rather than ky-space due to alpha-dependence of coefficients\ncorresponds to sign of mirror term positive on RHS of equation\nmust treat boundary carefully\ntreatment of boundary seems inconsistent\nimplicit piece below is pure upwind, while\nexplicit piece in fd_variable_upwind_vpa is mixed\nwith assumed zero BC at extremes in both +/- vpa\ncorresponds to sign of mirror term negative on RHS of equation\nmust treat boundary carefully\ntime_upwind = 0.0 corresponds to centered in time\ntime_upwind = 1.0 corresponds to fully implicit (upwinded)\naccount for fact that we have expanded d(gnorm)/dvpa, where gnorm = g/exp(-v&#94;s);\nthis gives rise to d(gnorm exp(-vpa&#94;2))/dvpa + 2 vpa gnorm exp(-vpa&#94;2) term\nwe solve for gnorm*exp(-vpa&#94;2) and later multiply by exp(vpa&#94;2) to get gnorm\nmultiply by mirror coefficient Arguments None public subroutine advance_mirror_explicit (g, gout) advance_mirror_explicit calculates the contribution to the RHS of the gyrokinetic equation\ndue to the mirror force term; it treats all terms explicitly in time Read moreâ€¦ Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout public subroutine add_mirror_radial_variation (g, gout) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout private subroutine get_dgdvpa_ffs (g, ikxyz) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: g integer, intent(in) :: ikxyz private subroutine get_dgdvpa_explicit (g) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, kxkyz_lo%llim_proc:) :: g private subroutine add_mirror_term (g, src) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: src private subroutine add_mirror_term_ffs (g, src) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: src public subroutine advance_mirror_implicit (collisions_implicit, g) Arguments Type Intent Optional Attributes Name logical, intent(in) :: collisions_implicit complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g private subroutine vpa_interpolation (grid, interp) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: grid complex, intent(out), dimension(:, :, kxkyz_lo%llim_proc:) :: interp private subroutine invert_mirror_operator (imu, ilo, g) Arguments Type Intent Optional Attributes Name integer, intent(in) :: imu integer, intent(in) :: ilo complex, intent(inout), dimension(:) :: g public subroutine finish_mirror () Arguments None private subroutine finish_mirror_semi_lagrange () Arguments None private subroutine finish_invert_mirror_operator () Arguments None","tags":"","loc":"module/mirror_terms.html"},{"title":"init_g â€“ stella","text":"This module contains the subroutines which set the initial value of the Contents Variables ginitopt_switch ginitopt_default ginitopt_noise ginitopt_restart_many ginitopt_kpar ginitopt_nltest ginitopt_kxtest ginitopt_rh ginitopt_remap width0 phiinit imfac refac zf_init den0 upar0 tpar0 tperp0 den1 upar1 tpar1 tperp1 den2 upar2 tpar2 tperp2 tstart scale kxmax kxmin chop_side left even scale_to_phiinit restart_file restart_dir initialized exist Subroutines init_init_g ginit read_parameters ginit_default ginit_noise ginit_kpar ginit_rh ginit_remap ginit_restart_many normalize_by_maxwellian reset_init finish_init_g Variables Type Visibility Attributes Name Initial integer, private :: ginitopt_switch integer, private, parameter :: ginitopt_default = 1 integer, private, parameter :: ginitopt_noise = 2 integer, private, parameter :: ginitopt_restart_many = 3 integer, private, parameter :: ginitopt_kpar = 4 integer, private, parameter :: ginitopt_nltest = 5 integer, private, parameter :: ginitopt_kxtest = 6 integer, private, parameter :: ginitopt_rh = 7 integer, private, parameter :: ginitopt_remap = 8 real, public :: width0 real, public :: phiinit real, private :: imfac real, private :: refac real, private :: zf_init real, private :: den0 real, private :: upar0 real, private :: tpar0 real, private :: tperp0 real, private :: den1 real, private :: upar1 real, private :: tpar1 real, private :: tperp1 real, private :: den2 real, private :: upar2 real, private :: tpar2 real, private :: tperp2 real, public :: tstart real, private :: scale real, private :: kxmax real, private :: kxmin logical, private :: chop_side logical, private :: left logical, private :: even logical, public :: scale_to_phiinit character(len=300), public :: restart_file character(len=150), private :: restart_dir logical, private :: initialized = .false. logical, private :: exist Subroutines public subroutine init_init_g () Arguments None public subroutine ginit (restarted, istep0) if simulating a full flux surface, g is normalized by F0 (which is not the case otherwise)\nunless reading in g from a restart file, normalise g by F0 for a full flux surface simulation Arguments Type Intent Optional Attributes Name logical, intent(out) :: restarted integer, intent(out) :: istep0 private subroutine read_parameters () Arguments None private subroutine ginit_default () Arguments None private subroutine ginit_noise () Initialise the distribution function with random noise. This is the default Arguments None private subroutine ginit_kpar () Arguments None private subroutine ginit_rh () Arguments None private subroutine ginit_remap () Arguments None private subroutine ginit_restart_many () Arguments None private subroutine normalize_by_maxwellian () gvmu is initialised with a Maxwellian weighting for flux tube simulations,\nwith the Maxwellian evaluated at ia = 1\nwe are undoing that weighting here, so also need to use ia = 1 Arguments None public subroutine reset_init () Arguments None public subroutine finish_init_g () Arguments None","tags":"","loc":"module/init_g.html"},{"title":"volume_averages â€“ stella","text":"Contents Variables mode_fac jacobian_ky Interfaces fieldline_average Subroutines init_volume_averages finish_volume_averages fieldline_average_real fieldline_average_complex volume_average init_flux_surface_average_ffs flux_surface_average_ffs Variables Type Visibility Attributes Name Initial real, public, dimension(:), allocatable :: mode_fac complex, private, dimension(:, :), allocatable :: jacobian_ky Fourier coefficients in y of the Jacobian;\nneeded for full flux surface simulations Interfaces public interface fieldline_average private subroutine fieldline_average_real (unavg, avg) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :, -nzgrid:, :) :: unavg real, intent(out), dimension(:, :) :: avg private subroutine fieldline_average_complex (unavg, avg) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: unavg complex, intent(out), dimension(:, :) :: avg Subroutines public subroutine init_volume_averages () Arguments None public subroutine finish_volume_averages () Arguments None private subroutine fieldline_average_real (unavg, avg) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :, -nzgrid:, :) :: unavg real, intent(out), dimension(:, :) :: avg private subroutine fieldline_average_complex (unavg, avg) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: unavg complex, intent(out), dimension(:, :) :: avg public subroutine volume_average (unavg, avg) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: unavg real, intent(out) :: avg private subroutine init_flux_surface_average_ffs () calculate the Fourier coefficients in y of the Jacobian\nthis is needed in the computation of the flux surface average of phi Arguments None public subroutine flux_surface_average_ffs (no_fsa, fsa) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, -nzgrid:) :: no_fsa complex, intent(out) :: fsa","tags":"","loc":"module/volume_averages.html"},{"title":"run_parameters â€“ stella","text":"This module is basically a store for the input parameters that are specified in the namelists \\a knobs and \\a parameters. In general, the names of the public variables in this module are the same as the name of the input parameter they correspond to. Contents Variables cfl_cushion delt_adjust fphi fapar fbpar delt tend code_delt_max zed_upwind vpa_upwind time_upwind stream_implicit mirror_implicit driftkinetic_implicit fully_explicit drifts_implicit maxwellian_inside_zed_derivative stream_matrix_inversion mirror_semi_lagrange mirror_linear_interp fields_kxkyz mat_gen mat_read ky_solve_real avail_cpu_time nstep ky_solve_radial rng_seed delt_option_switch lu_option_switch delt_option_hand delt_option_auto lu_option_none lu_option_local lu_option_global initialized knexist Subroutines init_run_parameters read_parameters finish_run_parameters Variables Type Visibility Attributes Name Initial real, public :: cfl_cushion real, public :: delt_adjust real, public :: fphi real, public :: fapar real, public :: fbpar real, public :: delt real, public :: tend real, public :: code_delt_max real, public :: zed_upwind real, public :: vpa_upwind real, public :: time_upwind logical, public :: stream_implicit logical, public :: mirror_implicit logical, public :: driftkinetic_implicit logical, public :: fully_explicit logical, public :: drifts_implicit logical, public :: maxwellian_inside_zed_derivative logical, public :: stream_matrix_inversion logical, public :: mirror_semi_lagrange logical, public :: mirror_linear_interp logical, public :: fields_kxkyz logical, public :: mat_gen logical, public :: mat_read logical, public :: ky_solve_real real, public :: avail_cpu_time integer, public :: nstep integer, public :: ky_solve_radial integer, public :: rng_seed integer, public :: delt_option_switch integer, public :: lu_option_switch integer, public, parameter :: delt_option_hand = 1 integer, public, parameter :: delt_option_auto = 2 integer, public, parameter :: lu_option_none = 1 integer, public, parameter :: lu_option_local = 2 integer, public, parameter :: lu_option_global = 3 logical, private :: initialized = .false. logical, private :: knexist Subroutines public subroutine init_run_parameters () Arguments None private subroutine read_parameters () print warning messages and override inconsistent or unsupported options for full_flux_surface = T Arguments None public subroutine finish_run_parameters () Arguments None","tags":"","loc":"module/run_parameters.html"},{"title":"species â€“ stella","text":"Uses common_types Contents Variables ion_species electron_species slowing_down_species tracer_species species_option_switch species_option_stella species_option_inputprofs species_option_euterpe species_option_multibox nspec read_profile_variation write_profile_variation ecoll_zeff modified_adiabatic_electrons adiabatic_electrons spec ions electrons impurity pfac species_option initialized Functions has_electron_species has_slowing_down_species Subroutines init_species read_species_knobs read_species_stella broadcast_parameters finish_species reinit_species communicate_species_multibox dump_species_input Variables Type Visibility Attributes Name Initial integer, public, parameter :: ion_species = 1 integer, public, parameter :: electron_species = 2 integer, public, parameter :: slowing_down_species = 3 integer, public, parameter :: tracer_species = 4 integer, private :: species_option_switch integer, private, parameter :: species_option_stella = 1 integer, private, parameter :: species_option_inputprofs = 2 integer, private, parameter :: species_option_euterpe = 3 integer, private, parameter :: species_option_multibox = 4 integer, public :: nspec logical, private :: read_profile_variation logical, private :: write_profile_variation logical, private :: ecoll_zeff logical, public :: modified_adiabatic_electrons logical, public :: adiabatic_electrons type( spec_type ), public, dimension(:), allocatable :: spec integer, public :: ions integer, public :: electrons integer, public :: impurity real, public :: pfac character(len=20), private :: species_option logical, private :: initialized = .false. Functions public pure function has_electron_species (spec) Arguments Type Intent Optional Attributes Name type( spec_type ), intent(in), dimension(:) :: spec Return Value logical public pure function has_slowing_down_species (spec) Arguments Type Intent Optional Attributes Name type( spec_type ), intent(in), dimension(:) :: spec Return Value logical Subroutines public subroutine init_species () Arguments None public subroutine read_species_knobs () Arguments None private subroutine read_species_stella () Arguments None private subroutine broadcast_parameters () Arguments None public subroutine finish_species () Arguments None public subroutine reinit_species (ntspec, dens, temp, fprim, tprim, bess_fac) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ntspec real, intent(in), dimension(:) :: dens real, intent(in), dimension(:) :: temp real, intent(in), dimension(:) :: fprim real, intent(in), dimension(:) :: tprim real, intent(in), dimension(:) :: bess_fac public subroutine communicate_species_multibox (dr_m, dr_p) Arguments Type Intent Optional Attributes Name real, intent(in), optional :: dr_m real, intent(in), optional :: dr_p private subroutine dump_species_input () Arguments None","tags":"","loc":"module/species.html"},{"title":"multibox â€“ stella","text":"Uses fft_work Contents Variables g_buffer0 g_buffer1 phi_buffer0 phi_buffer1 fsa_x copy_mask_left copy_mask_right krook_mask_left krook_mask_right krook_fac b_mat x_mb rho_mb rho_mb_clamped time_multibox dx_mb fft_kxky fft_xky fft_xy yf_fft yb_fft xf_fft xb_fft fft_x_k fft_x_x fft_y_k fft_y_y mb_transforms_initialized get_phi_initialized use_multibox temp_ind bs_fullgrid mb_debug_step x_fft_size phi_bound phi_pow ikymin xL xR rhoL rhoR kx0_L kx0_R nu_krook_mb krook_exponent krook_efold smooth_ZFs use_dirichlet_BC RK_step include_multibox_krook comm_at_init krook_option_switch krook_option_default krook_option_flat krook_option_linear krook_option_exp krook_option_exp_rev mb_zf_option_switch mb_zf_option_default mb_zf_option_skip_ky0 mb_zf_option_zero_ky0 mb_zf_option_zero_fsa LR_debug_switch LR_debug_option_default LR_debug_option_L LR_debug_option_R Subroutines read_multibox_parameters init_multibox communicate_multibox_parameters finish_multibox multibox_communicate apply_radial_boundary_conditions add_multibox_krook init_mb_get_phi mb_get_phi init_mb_transforms init_x_fft init_y_fft transform_kx2x transform_x2kx transform_ky2y finish_mb_transforms Variables Type Visibility Attributes Name Initial complex, private, dimension(:), allocatable :: g_buffer0 complex, private, dimension(:), allocatable :: g_buffer1 complex, public, dimension(:), allocatable :: phi_buffer0 complex, public, dimension(:), allocatable :: phi_buffer1 complex, private, dimension(:), allocatable :: fsa_x real, private, dimension(:), allocatable :: copy_mask_left real, private, dimension(:), allocatable :: copy_mask_right real, private, dimension(:), allocatable :: krook_mask_left real, private, dimension(:), allocatable :: krook_mask_right real, private, dimension(:), allocatable :: krook_fac real, private, dimension(:), allocatable :: b_mat real, private, dimension(:), allocatable :: x_mb real, private, dimension(:), allocatable :: rho_mb real, private, dimension(:), allocatable :: rho_mb_clamped real, public, dimension(2, 2) :: time_multibox = 0. real, private :: dx_mb complex, private, dimension(:, :), allocatable :: fft_kxky complex, private, dimension(:, :), allocatable :: fft_xky real, private, dimension(:, :), allocatable :: fft_xy type( fft_type ), private :: yf_fft type( fft_type ), private :: yb_fft type( fft_type ), private :: xf_fft type( fft_type ), private :: xb_fft complex, private, dimension(:), allocatable :: fft_x_k complex, private, dimension(:), allocatable :: fft_x_x complex, private, dimension(:), allocatable :: fft_y_k real, private, dimension(:), allocatable :: fft_y_y logical, private :: mb_transforms_initialized = .false. logical, private :: get_phi_initialized = .false. logical, private :: use_multibox integer, private :: temp_ind = 0 integer, public :: bs_fullgrid integer, private :: mb_debug_step integer, private :: x_fft_size integer, private :: phi_bound integer, private :: phi_pow integer, private :: ikymin real, public :: xL = 0. real, public :: xR = 0. real, public :: rhoL = 0. real, public :: rhoR = 0. real, public :: kx0_L real, public :: kx0_R real, private :: nu_krook_mb real, private :: krook_exponent real, private :: krook_efold logical, private :: smooth_ZFs logical, public :: use_dirichlet_BC logical, public :: RK_step logical, public :: include_multibox_krook logical, public :: comm_at_init integer, private :: krook_option_switch integer, private, parameter :: krook_option_default = 1 integer, private, parameter :: krook_option_flat = 0 integer, private, parameter :: krook_option_linear = 1 integer, private, parameter :: krook_option_exp = 2 integer, private, parameter :: krook_option_exp_rev = 3 integer, private :: mb_zf_option_switch integer, private, parameter :: mb_zf_option_default = 0 integer, private, parameter :: mb_zf_option_skip_ky0 = 1 integer, private, parameter :: mb_zf_option_zero_ky0 = 2 integer, private, parameter :: mb_zf_option_zero_fsa = 3 integer, private :: LR_debug_switch integer, private, parameter :: LR_debug_option_default = 0 integer, private, parameter :: LR_debug_option_L = 1 integer, private, parameter :: LR_debug_option_R = 2 Subroutines public subroutine read_multibox_parameters () Arguments None public subroutine init_multibox () Arguments None public subroutine communicate_multibox_parameters () Arguments None public subroutine finish_multibox () Arguments None public subroutine multibox_communicate (gin) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gin public subroutine apply_radial_boundary_conditions (gin) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gin public subroutine add_multibox_krook (g, rhs) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: rhs public subroutine init_mb_get_phi (has_elec, adiabatic_elec, efac, efacp) Arguments Type Intent Optional Attributes Name logical, intent(in) :: has_elec logical, intent(in) :: adiabatic_elec real, intent(in) :: efac real, intent(in) :: efacp public subroutine mb_get_phi (phi, has_elec, adiabatic_elec) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi logical, intent(in) :: has_elec logical, intent(in) :: adiabatic_elec private subroutine init_mb_transforms () Arguments None private subroutine init_x_fft () Arguments None private subroutine init_y_fft () Arguments None private subroutine transform_kx2x (gkx, gx) transform routines start here Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gkx complex, intent(out), dimension(:, :) :: gx private subroutine transform_x2kx (gx, gkx) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gx complex, intent(out), dimension(:, :) :: gkx private subroutine transform_ky2y (gky, gy) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gky real, intent(out), dimension(:, :) :: gy private subroutine finish_mb_transforms () Arguments None","tags":"","loc":"module/multibox.html"},{"title":"dist_fn_arrays â€“ stella","text":"A container for the arrays that are used to store the distribution function among other things. Contents Variables gnew gold g_symm g0 g1 g2 g3 g_krook g_proj gvmu wstar wstarp wdriftx_g wdrifty_g wdriftx_phi wdrifty_phi wdriftpx_g wdriftpy_g wdriftpx_phi wdriftpy_phi kperp2 dkperp2dr Variables Type Visibility Attributes Name Initial complex, public, dimension(:, :, :, :, :), allocatable :: gnew complex, public, dimension(:, :, :, :, :), allocatable :: gold complex, public, dimension(:, :, :, :, :), target, allocatable :: g_symm complex, public, dimension(:, :, :, :, :), allocatable :: g0 complex, public, dimension(:, :, :, :, :), allocatable :: g1 complex, public, dimension(:, :, :, :, :), allocatable :: g2 complex, public, dimension(:, :, :, :, :), allocatable :: g3 complex, public, dimension(:, :, :, :), allocatable :: g_krook complex, public, dimension(:, :, :, :), allocatable :: g_proj complex, public, dimension(:, :, :), allocatable :: gvmu real, public, dimension(:, :, :), allocatable :: wstar real, public, dimension(:, :, :), allocatable :: wstarp real, public, dimension(:, :, :), allocatable :: wdriftx_g real, public, dimension(:, :, :), allocatable :: wdrifty_g real, public, dimension(:, :, :), allocatable :: wdriftx_phi real, public, dimension(:, :, :), allocatable :: wdrifty_phi real, public, dimension(:, :, :), allocatable :: wdriftpx_g real, public, dimension(:, :, :), allocatable :: wdriftpy_g real, public, dimension(:, :, :), allocatable :: wdriftpx_phi real, public, dimension(:, :, :), allocatable :: wdriftpy_phi real, public, dimension(:, :, :, :), allocatable :: kperp2 dkperp2dr will contain the radial variation of kperp2 real, public, dimension(:, :, :, :), allocatable :: dkperp2dr dkperp2dr will contain the radial variation of kperp2","tags":"","loc":"module/dist_fn_arrays.html"},{"title":"parallel_streaming â€“ stella","text":"Contents Variables parallel_streaming_initialized stream_sign stream stream_c stream_rad_var1 stream_rad_var2 stream_tri_a1 stream_tri_a2 stream_tri_b1 stream_tri_b2 stream_tri_c1 stream_tri_c2 gradpar_c time_parallel_streaming Interfaces center_zed Subroutines init_parallel_streaming init_invert_stream_operator advance_parallel_streaming_explicit add_parallel_streaming_radial_variation get_dgdz get_dgdz_centered add_stream_term add_stream_term_ffs advance_parallel_streaming_implicit get_gke_rhs invert_parstream stream_tridiagonal_solve sweep_g_zed sweep_zed_zonal invert_parstream_response get_dzed center_zed_extended center_zed_segment_real finish_parallel_streaming finish_invert_stream_operator Variables Type Visibility Attributes Name Initial logical, public :: parallel_streaming_initialized = .false. integer, public, dimension(:), allocatable :: stream_sign real, public, dimension(:, :, :, :), allocatable :: stream real, public, dimension(:, :, :), allocatable :: stream_c real, public, dimension(:, :, :), allocatable :: stream_rad_var1 real, public, dimension(:, :, :), allocatable :: stream_rad_var2 real, private, dimension(:, :), allocatable :: stream_tri_a1 real, private, dimension(:, :), allocatable :: stream_tri_a2 real, private, dimension(:, :), allocatable :: stream_tri_b1 real, private, dimension(:, :), allocatable :: stream_tri_b2 real, private, dimension(:, :), allocatable :: stream_tri_c1 real, private, dimension(:, :), allocatable :: stream_tri_c2 real, private, dimension(:, :), allocatable :: gradpar_c real, public, dimension(2) :: time_parallel_streaming Interfaces private interface center_zed private subroutine center_zed_segment_real (iv, g) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv real, intent(inout), dimension(-nzgrid:) :: g private subroutine center_zed_extended (iv, g) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv complex, intent(inout), dimension(:, :, -nzgrid:, :) :: g Subroutines public subroutine init_parallel_streaming () stream_sign set to +/- 1 depending on the sign of the parallel streaming term.\nNB: stream_sign = -1 corresponds to positive advection velocity\nonly need to consider ia=1, iz=0 and is=1 because alpha, z and species dependences\ndo not lead to change in sign of the streaming pre-factor\nget gradpar centred in zed for negative vpa (affects upwinding)\nget gradpar centred in zed for positive vpa (affects upwinding) Arguments None private subroutine init_invert_stream_operator () Arguments None public subroutine advance_parallel_streaming_explicit (g, phi, gout) if flux tube simulation parallel streaming stays in ky,kx,z space with ky,kx,z local\nif full flux surface (flux annulus), will need to calculate in y space\nstart the timer for the parallel streaming part of the time advance Read moreâ€¦ Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout public subroutine add_parallel_streaming_radial_variation (g, gout, rhs) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: rhs private subroutine get_dgdz (g, ivmu, dgdz) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: g integer, intent(in) :: ivmu complex, intent(out), dimension(:, :, -nzgrid:, :) :: dgdz private subroutine get_dgdz_centered (g, ivmu, dgdz) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: g integer, intent(in) :: ivmu complex, intent(out), dimension(:, :, -nzgrid:, :) :: dgdz private subroutine add_stream_term (g, ivmu, src) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: g integer, intent(in) :: ivmu complex, intent(inout), dimension(:, :, -nzgrid:, :) :: src private subroutine add_stream_term_ffs (g, ivmu, src) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: g integer, intent(in) :: ivmu complex, intent(inout), dimension(:, :, -nzgrid:, :) :: src public subroutine advance_parallel_streaming_implicit (g, phi, apar) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :) :: apar private subroutine get_gke_rhs (ivmu, gold, phiold, phi, g, eqn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ivmu complex, intent(in), dimension(:, :, -nzgrid:, :) :: gold complex, intent(in), dimension(:, :, -nzgrid:, :) :: phiold complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :) :: g character, intent(in) :: eqn private subroutine invert_parstream (ivmu, g) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ivmu complex, intent(inout), dimension(:, :, -nzgrid:, :) :: g public subroutine stream_tridiagonal_solve (iky, ie, iv, is, g) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky integer, intent(in) :: ie integer, intent(in) :: iv integer, intent(in) :: is complex, intent(inout), dimension(:) :: g private subroutine sweep_g_zed (ivmu, g) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ivmu complex, intent(inout), dimension(:, :, -nzgrid:, :) :: g private subroutine sweep_zed_zonal (iv, is, sgn, g) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv integer, intent(in) :: is integer, intent(in) :: sgn complex, intent(inout), dimension(:, -nzgrid:, :) :: g private subroutine invert_parstream_response (phi) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi private subroutine get_dzed (iv, g, dgdz) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv complex, intent(in), dimension(:, :, -nzgrid:, :) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: dgdz private subroutine center_zed_extended (iv, g) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv complex, intent(inout), dimension(:, :, -nzgrid:, :) :: g private subroutine center_zed_segment_real (iv, g) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv real, intent(inout), dimension(-nzgrid:) :: g public subroutine finish_parallel_streaming () Arguments None private subroutine finish_invert_stream_operator () Arguments None","tags":"","loc":"module/parallel_streaming.html"},{"title":"stella_time â€“ stella","text":"Contents Variables code_dt cfl_dt code_dt_min code_dt_max code_dt_old code_time Subroutines init_tstart init_delt update_time save_dt_cfl save_dt_min save_dt write_dt Variables Type Visibility Attributes Name Initial real, public :: code_dt real, public :: cfl_dt = -1. real, public :: code_dt_min real, public :: code_dt_max real, public :: code_dt_old = 0. real, public :: code_time = 0. Subroutines public subroutine init_tstart (tstart) Arguments Type Intent Optional Attributes Name real, intent(in) :: tstart public subroutine init_delt (delt) Arguments Type Intent Optional Attributes Name real, intent(in) :: delt public subroutine update_time () Arguments None public subroutine save_dt_cfl (delt_cfl) Arguments Type Intent Optional Attributes Name real, intent(in) :: delt_cfl public subroutine save_dt_min (dt_min) Arguments Type Intent Optional Attributes Name real, intent(in) :: dt_min public subroutine save_dt (delt) Arguments Type Intent Optional Attributes Name real, intent(in) :: delt public subroutine write_dt () Arguments None","tags":"","loc":"module/stella_time.html"},{"title":"vpamu_grids â€“ stella","text":"Contents Variables vpamu_initialized nvgrid nvpa nmu vpa_max vperp_max vpa wgts_vpa wgts_vpa_default wgts_mu_bare mu maxwell_fac maxwell_vpa int_unit int_vpa2 int_vperp2 int_vfrth wgts_mu maxwell_mu ztmax dvpa dmu dmu_ghost dmu_cell mu_cell rbuffer equally_spaced_mu_grid conservative_wgts_vpa vperp2 Interfaces integrate_species integrate_vmu integrate_mu Subroutines read_vpamu_grids_parameters init_vpamu_grids init_vpa_grid set_vpa_weights integrate_mu_local integrate_mu_nonlocal integrate_vmu_local_real integrate_vmu_local_complex integrate_vmu_vmulo_complex integrate_vmu_vmulo_ivmu_only_real integrate_species_vmu_single integrate_species_vmu_single_real integrate_species_vmu_block_complex integrate_species_vmu_block_real integrate_species_ffs integrate_vmu_ffs finish_vpa_grid init_mu_grid finish_mu_grid calculate_velocity_integrals finish_vpamu_grids Variables Type Visibility Attributes Name Initial logical, public :: vpamu_initialized = .false. integer, public :: nvgrid integer, public :: nvpa integer, public :: nmu real, public :: vpa_max real, public :: vperp_max real, public, dimension(:), allocatable :: vpa real, public, dimension(:), allocatable :: wgts_vpa real, public, dimension(:), allocatable :: wgts_vpa_default real, public, dimension(:), allocatable :: wgts_mu_bare real, public, dimension(:), allocatable :: mu real, public, dimension(:), allocatable :: maxwell_fac real, public, dimension(:, :), allocatable :: maxwell_vpa real, public, dimension(:, :, :), allocatable :: int_unit real, public, dimension(:, :, :), allocatable :: int_vpa2 real, public, dimension(:, :, :), allocatable :: int_vperp2 real, public, dimension(:, :, :), allocatable :: int_vfrth real, public, dimension(:, :, :), allocatable :: wgts_mu real, public, dimension(:, :, :, :), allocatable :: maxwell_mu real, public, dimension(:, :), allocatable :: ztmax real, public :: dvpa real, public, dimension(:), allocatable :: dmu real, public, dimension(:), allocatable :: dmu_ghost real, public, dimension(:), allocatable :: dmu_cell real, public, dimension(:), allocatable :: mu_cell complex, public, dimension(:), allocatable :: rbuffer logical, public :: equally_spaced_mu_grid logical, public :: conservative_wgts_vpa real, public, dimension(:, :, :), allocatable :: vperp2 Interfaces public interface integrate_species public subroutine integrate_species_vmu_single (g, iz, weights, total, ia_in, reduce_in) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(vmu_lo%llim_proc:) :: g integer, intent(in) :: iz real, intent(in), dimension(:) :: weights complex, intent(out) :: total integer, intent(in), optional :: ia_in logical, intent(in), optional :: reduce_in public subroutine integrate_species_vmu_single_real (g, iz, weights, total, ia_in, reduce_in) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(vmu_lo%llim_proc:) :: g integer, intent(in) :: iz real, intent(in), dimension(:) :: weights real, intent(out) :: total integer, intent(in), optional :: ia_in logical, intent(in), optional :: reduce_in public subroutine integrate_species_vmu_block_complex (g, iz, weights, pout, ia_in, reduce_in) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, vmu_lo%llim_proc:) :: g integer, intent(in) :: iz real, intent(in), dimension(:) :: weights complex, intent(out), dimension(:, :) :: pout integer, intent(in), optional :: ia_in logical, intent(in), optional :: reduce_in public subroutine integrate_species_vmu_block_real (g, iz, weights, pout, ia_in, reduce_in) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :, vmu_lo%llim_proc:) :: g integer, intent(in) :: iz real, intent(in), dimension(:) :: weights real, intent(out), dimension(:, :) :: pout integer, intent(in), optional :: ia_in logical, intent(in), optional :: reduce_in public interface integrate_vmu public subroutine integrate_vmu_local_real (g, iz, total) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: g integer, intent(in) :: iz real, intent(out) :: total public subroutine integrate_vmu_local_complex (g, iz, total) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: g integer, intent(in) :: iz complex, intent(out) :: total public subroutine integrate_vmu_vmulo_complex (g, weights, total) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g real, intent(in), dimension(:) :: weights complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: total public subroutine integrate_vmu_vmulo_ivmu_only_real (g, ia, iz, total) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(vmu_lo%llim_proc:) :: g integer, intent(in) :: ia integer, intent(in) :: iz real, intent(out), dimension(:) :: total public interface integrate_mu public subroutine integrate_mu_local (iz, g, total) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iz real, intent(in), dimension(:, :) :: g real, intent(out), dimension(:) :: total public subroutine integrate_mu_nonlocal (iz, g, total) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iz real, intent(in), dimension(vmu_lo%llim_proc:) :: g real, intent(out), dimension(:, :) :: total Subroutines public subroutine read_vpamu_grids_parameters () Arguments None public subroutine init_vpamu_grids () set up the vpa grid points and integration weights\nset up the mu grid points and integration weights Read moreâ€¦ Arguments None public subroutine init_vpa_grid () vpa is the parallel velocity at grid points\nwgts_vpa are the integration weights assigned\nto the parallel velocity grid points\nthis is the Maxwellian in vpa\nparallel velocity grid goes from -vpa_max to vpa_max,\nwith no point at vpa = 0;\nthe lack of a point at vpa=0 avoids treating\nthe vpa=z=0 phase space location, which\nis isolated from all other phase space points\nin the absence of collisions\nequal grid spacing in vpa Read moreâ€¦ Arguments None public subroutine set_vpa_weights (conservative) Arguments Type Intent Optional Attributes Name logical, intent(in) :: conservative public subroutine integrate_mu_local (iz, g, total) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iz real, intent(in), dimension(:, :) :: g real, intent(out), dimension(:) :: total public subroutine integrate_mu_nonlocal (iz, g, total) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iz real, intent(in), dimension(vmu_lo%llim_proc:) :: g real, intent(out), dimension(:, :) :: total public subroutine integrate_vmu_local_real (g, iz, total) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: g integer, intent(in) :: iz real, intent(out) :: total public subroutine integrate_vmu_local_complex (g, iz, total) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: g integer, intent(in) :: iz complex, intent(out) :: total public subroutine integrate_vmu_vmulo_complex (g, weights, total) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g real, intent(in), dimension(:) :: weights complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: total public subroutine integrate_vmu_vmulo_ivmu_only_real (g, ia, iz, total) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(vmu_lo%llim_proc:) :: g integer, intent(in) :: ia integer, intent(in) :: iz real, intent(out), dimension(:) :: total public subroutine integrate_species_vmu_single (g, iz, weights, total, ia_in, reduce_in) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(vmu_lo%llim_proc:) :: g integer, intent(in) :: iz real, intent(in), dimension(:) :: weights complex, intent(out) :: total integer, intent(in), optional :: ia_in logical, intent(in), optional :: reduce_in public subroutine integrate_species_vmu_single_real (g, iz, weights, total, ia_in, reduce_in) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(vmu_lo%llim_proc:) :: g integer, intent(in) :: iz real, intent(in), dimension(:) :: weights real, intent(out) :: total integer, intent(in), optional :: ia_in logical, intent(in), optional :: reduce_in public subroutine integrate_species_vmu_block_complex (g, iz, weights, pout, ia_in, reduce_in) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, vmu_lo%llim_proc:) :: g integer, intent(in) :: iz real, intent(in), dimension(:) :: weights complex, intent(out), dimension(:, :) :: pout integer, intent(in), optional :: ia_in logical, intent(in), optional :: reduce_in public subroutine integrate_species_vmu_block_real (g, iz, weights, pout, ia_in, reduce_in) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :, vmu_lo%llim_proc:) :: g integer, intent(in) :: iz real, intent(in), dimension(:) :: weights real, intent(out), dimension(:, :) :: pout integer, intent(in), optional :: ia_in logical, intent(in), optional :: reduce_in public subroutine integrate_species_ffs (g, weights, pout, reduce_in) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, vmu_lo%llim_proc:) :: g real, intent(in), dimension(:) :: weights complex, intent(out), dimension(:, :) :: pout logical, intent(in), optional :: reduce_in public subroutine integrate_vmu_ffs (g, weights, ia, iz, pout, reduce_in) the inclusion of the Maxwellian term below is due to the fact that\ng/F is evolved for FFS Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(vmu_lo%llim_proc:) :: g real, intent(in), dimension(:) :: weights integer, intent(in) :: ia integer, intent(in) :: iz complex, intent(out), dimension(:) :: pout logical, intent(in), optional :: reduce_in public subroutine finish_vpa_grid () Arguments None public subroutine init_mu_grid () allocate arrays and initialize to zero\ndvpe * vpe = d(2 mu B0) * B/2B0\nfirst get equally spaced grid in mu with max value\nmu_max = vperp_max 2/(2 max(bmag))\nwant first grid point at dmu/2 to avoid mu=0 special point\ndmu/2 + (nmu-1) dmu = mu_max\nso dmu = mu_max/(nmu-1/2)\ndo simplest thing to start\nleave dmu(nmu) uninitialized. should never be used, so want\nvalgrind or similar to return error if it is Read moreâ€¦ Arguments None public subroutine finish_mu_grid () Arguments None public subroutine calculate_velocity_integrals () Arguments None public subroutine finish_vpamu_grids () Arguments None","tags":"","loc":"module/vpamu_grids.html"},{"title":"dist_fn â€“ stella","text":"Contents Variables dist_fn_initialized gxyz_initialized kp2init vp2init debug Subroutines init_gxyz init_dist_fn init_kperp2 enforce_single_valued_kperp2 allocate_arrays init_vperp2 finish_dist_fn deallocate_arrays finish_kperp2 finish_vperp2 Variables Type Visibility Attributes Name Initial logical, private :: dist_fn_initialized = .false. logical, private :: gxyz_initialized = .false. logical, private :: kp2init = .false. logical, private :: vp2init = .false. logical, private :: debug = .false. Subroutines public subroutine init_gxyz (restarted) Arguments Type Intent Optional Attributes Name logical, intent(in) :: restarted public subroutine init_dist_fn () allocate and initialise kperp2 and dkperp2dr\nallocate and initialise vperp2\ninit_bessel sets up arrays needed for gyro-averaging;\nfor a flux tube simulation, this is j0 and j1;\nfor a flux annulus simulation, gyro-averaging is non-local in ky\nand so more effort is required Arguments None private subroutine init_kperp2 () init_kperp2 allocates and initialises the kperp2 and dkperp2dr arrays Read moreâ€¦ Arguments None private subroutine enforce_single_valued_kperp2 () Arguments None private subroutine allocate_arrays () Arguments None private subroutine init_vperp2 () Arguments None public subroutine finish_dist_fn () Arguments None private subroutine deallocate_arrays () Arguments None private subroutine finish_kperp2 () Arguments None private subroutine finish_vperp2 () Arguments None","tags":"","loc":"module/dist_fn.html"},{"title":"g_tofrom_h â€“ stella","text":"Contents Interfaces g_to_h Subroutines g_to_h_vmu g_to_h_kxkyz Interfaces public interface g_to_h private subroutine g_to_h_kxkyz (g, phi, facphi) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi real, intent(in) :: facphi private subroutine g_to_h_vmu (g, phi, facphi, phi_corr) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi real, intent(in) :: facphi complex, intent(in), optional dimension(:, :, -nzgrid:, :) :: phi_corr Subroutines private subroutine g_to_h_vmu (g, phi, facphi, phi_corr) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi real, intent(in) :: facphi complex, intent(in), optional dimension(:, :, -nzgrid:, :) :: phi_corr private subroutine g_to_h_kxkyz (g, phi, facphi) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi real, intent(in) :: facphi","tags":"","loc":"module/g_tofrom_h.html"},{"title":"common_types â€“ stella","text":"Contents Derived Types kxkyz_layout_type kxyz_layout_type xyz_layout_type vmu_layout_type flux_surface_type spec_type eigen_type response_matrix_type coupled_alpha_type gam0_ffs_type Derived Types type, public, sequence  :: kxkyz_layout_type Components Type Visibility Attributes Name Initial integer, public :: iproc integer, public :: nzgrid integer, public :: nzed integer, public :: ntubes integer, public :: naky integer, public :: nakx integer, public :: nvgrid integer, public :: nvpa integer, public :: nmu integer, public :: nspec integer, public :: llim_world integer, public :: ulim_world integer, public :: llim_proc integer, public :: ulim_proc integer, public :: ulim_alloc integer, public :: blocksize type, public, sequence  :: kxyz_layout_type Components Type Visibility Attributes Name Initial integer, public :: iproc integer, public :: nzgrid integer, public :: nzed integer, public :: ntubes integer, public :: ny integer, public :: naky integer, public :: nakx integer, public :: ikx_max integer, public :: nvgrid integer, public :: nvpa integer, public :: nmu integer, public :: nspec integer, public :: llim_world integer, public :: ulim_world integer, public :: llim_proc integer, public :: ulim_proc integer, public :: ulim_alloc integer, public :: blocksize type, public, sequence  :: xyz_layout_type Components Type Visibility Attributes Name Initial integer, public :: iproc integer, public :: nzgrid integer, public :: nzed integer, public :: ntubes integer, public :: ny integer, public :: naky integer, public :: nx integer, public :: nakx integer, public :: nvgrid integer, public :: nvpa integer, public :: nmu integer, public :: nspec integer, public :: llim_world integer, public :: ulim_world integer, public :: llim_proc integer, public :: ulim_proc integer, public :: ulim_alloc integer, public :: blocksize type, public, sequence  :: vmu_layout_type Components Type Visibility Attributes Name Initial logical, public :: xyz integer, public :: iproc integer, public :: nzgrid integer, public :: nzed integer, public :: ntubes integer, public :: nalpha integer, public :: ny integer, public :: naky integer, public :: nx integer, public :: nakx integer, public :: nvgrid integer, public :: nvpa integer, public :: nmu integer, public :: nspec integer, public :: llim_world integer, public :: ulim_world integer, public :: llim_proc integer, public :: ulim_proc integer, public :: ulim_alloc integer, public :: blocksize type, public :: flux_surface_type Components Type Visibility Attributes Name Initial real, public :: rmaj real, public :: rgeo real, public :: kappa real, public :: kapprim real, public :: tri real, public :: triprim real, public :: rhoc real, public :: dr real, public :: shift real, public :: qinp real, public :: shat real, public :: betaprim real, public :: betadbprim real, public :: d2qdr2 real, public :: d2psidr2 real, public :: dpsitordrho real, public :: d2psitordrho2 real, public :: rhotor real, public :: drhotordrho real, public :: psitor_lcfs real, public :: zed0_fac real, public :: rhoc_psi0 real, public :: qinp_psi0 real, public :: shat_psi0 type, public :: spec_type Components Type Visibility Attributes Name Initial integer, public :: nspec real, public :: z real, public :: mass real, public :: dens real, public :: temp real, public :: tprim real, public :: fprim real, public :: vnew_ref real, public :: stm real, public :: zstm real, public :: tz real, public :: smz real, public :: zt real, public :: d2ndr2 real, public :: d2Tdr2 real, public :: bess_fac real, public, dimension(10) :: vnew integer, public :: type real, public :: dens_psi0 real, public :: temp_psi0 real, public :: stm_psi0 real, public :: zstm_psi0 real, public :: tz_psi0 real, public :: smz_psi0 real, public :: zt_psi0 type, public :: eigen_type Components Type Visibility Attributes Name Initial complex, public, dimension(:, :), pointer :: zloc => null() integer, public, dimension(:), pointer :: idx => null() type, public :: response_matrix_type Components Type Visibility Attributes Name Initial type( eigen_type ), public, dimension(:), pointer :: eigen => null() type, public :: coupled_alpha_type Components Type Visibility Attributes Name Initial integer, public :: max_idx complex, public, dimension(:), pointer :: fourier => null() type, public :: gam0_ffs_type Components Type Visibility Attributes Name Initial integer, public, dimension(:), pointer :: pivot_index => null() complex, public, dimension(:, :), pointer :: matrix => null()","tags":"","loc":"module/common_types.html"},{"title":"stella_geometry â€“ stella","text":"Uses common_types Contents Variables geo_surf grad_x_grad_y_end aref bref dxdXcoord dydalpha dqdrho dIdrho grho_norm drhodpsi drhodpsi_psi0 shat qinp exb_nonlin_fac exb_nonlin_fac_p gradpar_eqarc zed_scalefac twist_and_shift_geo_fac gfac zed_eqarc gradpar b_dot_grad_z bmag bmag_psi0 dbdzed twist_and_shift_geo_fac_full cvdrift cvdrift0 gbdrift gbdrift0 dcvdriftdrho dcvdrift0drho dgbdriftdrho dgbdrift0drho gds2 gds21 gds22 gds23 gds24 gds25 gds26 dgds2dr dgds21dr dgds22dr theta_vmec jacob djacdrho grho grad_x dl_over_b d_dl_over_b_drho dVolume x_displacement_fac dBdrho d2Bdrdth dgradpardrho btor Rmajor alpha zeta geo_option_switch geo_option_local geo_option_inputprof geo_option_vmec geo_option_multibox overwrite_geometry overwrite_bmag overwrite_gradpar overwrite_gds2 overwrite_gds21 overwrite_gds22 overwrite_gds23 overwrite_gds24 overwrite_gbdrift overwrite_cvdrift overwrite_gbdrift0 q_as_x geo_file vmec_chosen geoinit set_bmag_const Subroutines init_geometry allocate_arrays read_parameters broadcast_arrays communicate_geo_multibox get_dzed get_gradpar_eqarc get_zed_eqarc integrate_zed get_x_to_rho write_geometric_coefficients finish_init_geometry finish_geometry Variables Type Visibility Attributes Name Initial type( flux_surface_type ), public :: geo_surf real, public :: grad_x_grad_y_end real, public :: aref real, public :: bref real, public :: dxdXcoord real, public :: dydalpha real, private :: dqdrho real, public :: dIdrho real, public :: grho_norm real, public :: drhodpsi real, public :: drhodpsi_psi0 real, private :: shat real, private :: qinp real, public :: exb_nonlin_fac real, public :: exb_nonlin_fac_p real, public :: gradpar_eqarc real, public :: zed_scalefac real, public :: twist_and_shift_geo_fac real, public :: gfac real, public, dimension(:), allocatable :: zed_eqarc real, public, dimension(:), allocatable :: gradpar real, public, dimension(:, :), allocatable :: b_dot_grad_z real, public, dimension(:, :), allocatable :: bmag real, public, dimension(:, :), allocatable :: bmag_psi0 real, public, dimension(:, :), allocatable :: dbdzed real, private, dimension(:, :), allocatable :: twist_and_shift_geo_fac_full real, public, dimension(:, :), allocatable :: cvdrift real, public, dimension(:, :), allocatable :: cvdrift0 real, public, dimension(:, :), allocatable :: gbdrift real, public, dimension(:, :), allocatable :: gbdrift0 real, public, dimension(:, :), allocatable :: dcvdriftdrho real, public, dimension(:, :), allocatable :: dcvdrift0drho real, public, dimension(:, :), allocatable :: dgbdriftdrho real, public, dimension(:, :), allocatable :: dgbdrift0drho real, public, dimension(:, :), allocatable :: gds2 real, public, dimension(:, :), allocatable :: gds21 real, public, dimension(:, :), allocatable :: gds22 real, public, dimension(:, :), allocatable :: gds23 real, public, dimension(:, :), allocatable :: gds24 real, public, dimension(:, :), allocatable :: gds25 real, public, dimension(:, :), allocatable :: gds26 real, public, dimension(:, :), allocatable :: dgds2dr real, public, dimension(:, :), allocatable :: dgds21dr real, public, dimension(:, :), allocatable :: dgds22dr real, public, dimension(:, :), allocatable :: theta_vmec real, public, dimension(:, :), allocatable :: jacob real, public, dimension(:, :), allocatable :: djacdrho real, public, dimension(:, :), allocatable :: grho real, public, dimension(:, :), allocatable :: grad_x real, public, dimension(:, :), allocatable :: dl_over_b real, public, dimension(:, :), allocatable :: d_dl_over_b_drho real, public, dimension(:, :, :), allocatable :: dVolume real, public, dimension(:, :), allocatable :: x_displacement_fac real, public, dimension(:), allocatable :: dBdrho real, public, dimension(:), allocatable :: d2Bdrdth real, public, dimension(:), allocatable :: dgradpardrho real, public, dimension(:), allocatable :: btor real, public, dimension(:), allocatable :: Rmajor real, public, dimension(:), allocatable :: alpha real, public, dimension(:, :), allocatable :: zeta integer, private :: geo_option_switch integer, private, parameter :: geo_option_local = 1 integer, private, parameter :: geo_option_inputprof = 2 integer, private, parameter :: geo_option_vmec = 3 integer, private, parameter :: geo_option_multibox = 4 logical, private :: overwrite_geometry logical, private :: overwrite_bmag logical, private :: overwrite_gradpar logical, private :: overwrite_gds2 logical, private :: overwrite_gds21 logical, private :: overwrite_gds22 logical, private :: overwrite_gds23 logical, private :: overwrite_gds24 logical, private :: overwrite_gbdrift logical, private :: overwrite_cvdrift logical, private :: overwrite_gbdrift0 logical, public :: q_as_x character(len=100), private :: geo_file logical, private :: vmec_chosen = .false. logical, private :: geoinit = .false. logical, private :: set_bmag_const Subroutines public subroutine init_geometry (nalpha, naky) b_dot_grad_z is the alpha-dependent b . grad z,\nand gradpar is the constant-in-alpha part of it.\nfor axisymmetric systems, b_dot_grad_z is independent of alpha. Read moreâ€¦ Arguments Type Intent Optional Attributes Name integer, intent(in) :: nalpha integer, intent(in) :: naky private subroutine allocate_arrays (nalpha, nzgrid) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nalpha integer, intent(in) :: nzgrid private subroutine read_parameters () Arguments None private subroutine broadcast_arrays () Arguments None public subroutine communicate_geo_multibox (l_edge, r_edge) Arguments Type Intent Optional Attributes Name real, intent(in) :: l_edge real, intent(in) :: r_edge private subroutine get_dzed (nz, dz, f, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nz real, intent(in), dimension(-nz:) :: dz real, intent(in), dimension(-nz:) :: f real, intent(out), dimension(-nz:) :: df private subroutine get_gradpar_eqarc (gp, z, dz, gp_eqarc) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nzgrid:) :: gp real, intent(in), dimension(-nzgrid:) :: z real, intent(in), dimension(-nzgrid:) :: dz real, intent(out) :: gp_eqarc private subroutine get_zed_eqarc (gp, dz, z, gp_eqarc, z_eqarc) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nzgrid:) :: gp real, intent(in), dimension(-nzgrid:) :: dz real, intent(in), dimension(-nzgrid:) :: z real, intent(in) :: gp_eqarc real, intent(out), dimension(-nzgrid:) :: z_eqarc private subroutine integrate_zed (dz, f, intf) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nzgrid:) :: dz real, intent(in), dimension(-nzgrid:) :: f real, intent(out) :: intf public subroutine get_x_to_rho (llim, x_in, rho_out) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(:) :: x_in real, intent(out), dimension(:) :: rho_out private subroutine write_geometric_coefficients (nalpha) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nalpha public subroutine finish_init_geometry () Arguments None public subroutine finish_geometry () Arguments None","tags":"","loc":"module/stella_geometry.html"},{"title":"inputprofiles_interface â€“ stella","text":"Contents Variables n_exp rhotor rmin rmaj_in qinp kappa delta Te ne z_eff omega0 ni Ti dr rhoc rmaj shift shat d2qdr2 tri triprim kapprim neprim Teprim niprim Tiprim nedbprim Tedbprim nidbprim Tidbprim betaprim betadbprim psitor drhotordrho dpsitordrho d2psitordrho2 pres_tot loglam bref omega_ref rho_ref bunit Subroutines read_inputprof_geo read_inputprof_spec allocate_arrays_geo allocate_arrays_spec deallocate_arrays_geo deallocate_arrays_spec Variables Type Visibility Attributes Name Initial integer, private :: n_exp real, private, dimension(:), allocatable :: rhotor real, private, dimension(:), allocatable :: rmin real, private, dimension(:), allocatable :: rmaj_in real, private, dimension(:), allocatable :: qinp real, private, dimension(:), allocatable :: kappa real, private, dimension(:), allocatable :: delta real, private, dimension(:), allocatable :: Te real, private, dimension(:), allocatable :: ne real, private, dimension(:), allocatable :: z_eff real, private, dimension(:), allocatable :: omega0 real, private, dimension(:), allocatable :: ni real, private, dimension(:), allocatable :: Ti real, private, dimension(:), allocatable :: dr real, private, dimension(:), allocatable :: rhoc real, private, dimension(:), allocatable :: rmaj real, private, dimension(:), allocatable :: shift real, private, dimension(:), allocatable :: shat real, private, dimension(:), allocatable :: d2qdr2 real, private, dimension(:), allocatable :: tri real, private, dimension(:), allocatable :: triprim real, private, dimension(:), allocatable :: kapprim real, private, dimension(:), allocatable :: neprim real, private, dimension(:), allocatable :: Teprim real, private, dimension(:), allocatable :: niprim real, private, dimension(:), allocatable :: Tiprim real, private, dimension(:), allocatable :: nedbprim real, private, dimension(:), allocatable :: Tedbprim real, private, dimension(:), allocatable :: nidbprim real, private, dimension(:), allocatable :: Tidbprim real, private, dimension(:), allocatable :: betaprim real, private, dimension(:), allocatable :: betadbprim real, private, dimension(:), allocatable :: psitor real, private, dimension(:), allocatable :: drhotordrho real, private, dimension(:), allocatable :: dpsitordrho real, private, dimension(:), allocatable :: d2psitordrho2 real, private, dimension(:), allocatable :: pres_tot real, private, dimension(:), allocatable :: loglam real, private :: bref real, private :: omega_ref real, private :: rho_ref real, private :: bunit Subroutines public subroutine read_inputprof_geo (surf) Arguments Type Intent Optional Attributes Name type( flux_surface_type ), intent(inout) :: surf public subroutine read_inputprof_spec (nspec, spec) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nspec type( spec_type ), intent(inout), dimension(:) :: spec private subroutine allocate_arrays_geo () Arguments None private subroutine allocate_arrays_spec () Arguments None private subroutine deallocate_arrays_geo () Arguments None private subroutine deallocate_arrays_spec () Arguments None","tags":"","loc":"module/inputprofiles_interface.html"},{"title":"vmec_geo â€“ stella","text":"Contents Variables alpha0 zgrid_refinement_factor zgrid_scalefac surface_option nfield_periods zeta_center torflux verbose vmec_filename Subroutines read_vmec_parameters init_vmec_defaults get_vmec_geo filter_geo_coef get_modified_vmec_zeta_grid Variables Type Visibility Attributes Name Initial real, public :: alpha0 integer, public :: zgrid_refinement_factor real, public :: zgrid_scalefac integer, public :: surface_option real, public :: nfield_periods real, public :: zeta_center real, public :: torflux logical, public :: verbose character(len=2000), public :: vmec_filename Subroutines public subroutine read_vmec_parameters () Arguments None public subroutine init_vmec_defaults () Arguments None public subroutine get_vmec_geo (nzgrid, nalpha, naky, surf, grho, bmag, gradpar, b_dot_grad_z, grad_alpha_grad_alpha, grad_alpha_grad_psi, grad_psi_grad_psi, gds23, gds24, gds25, gds26, gbdrift_alpha, gbdrift0_psi, cvdrift_alpha, cvdrift0_psi, sign_torflux, theta_vmec, zed_scalefac, L_reference, B_reference, alpha, zeta, field_period_ratio, x_displacement_fac) first read in equilibrium information from vmec file\nthis is stored as a set of global variables in read_wout_mod\nin mini_libstell.  it will be accessible\nif desired, increase number of sampled zeta grid points in VMEC data\nto increase accuracy of later integration in zeta and interpolation\nonto stella zed grid Read moreâ€¦ Arguments Type Intent Optional Attributes Name integer, intent(in) :: nzgrid integer, intent(in) :: nalpha integer, intent(in) :: naky type( flux_surface_type ), intent(out) :: surf real, intent(out), dimension(:, -nzgrid:) :: grho real, intent(out), dimension(:, -nzgrid:) :: bmag real, intent(out), dimension(-nzgrid:) :: gradpar real, intent(out), dimension(:, -nzgrid:) :: b_dot_grad_z real, intent(out), dimension(:, -nzgrid:) :: grad_alpha_grad_alpha real, intent(out), dimension(:, -nzgrid:) :: grad_alpha_grad_psi real, intent(out), dimension(:, -nzgrid:) :: grad_psi_grad_psi real, intent(out), dimension(:, -nzgrid:) :: gds23 real, intent(out), dimension(:, -nzgrid:) :: gds24 real, intent(out), dimension(:, -nzgrid:) :: gds25 real, intent(out), dimension(:, -nzgrid:) :: gds26 real, intent(out), dimension(:, -nzgrid:) :: gbdrift_alpha real, intent(out), dimension(:, -nzgrid:) :: gbdrift0_psi real, intent(out), dimension(:, -nzgrid:) :: cvdrift_alpha real, intent(out), dimension(:, -nzgrid:) :: cvdrift0_psi integer, intent(out) :: sign_torflux real, intent(out), dimension(:, -nzgrid:) :: theta_vmec real, intent(out) :: zed_scalefac real, intent(out) :: L_reference real, intent(out) :: B_reference real, intent(out), dimension(:) :: alpha real, intent(out), dimension(:, -nzgrid:) :: zeta real, intent(out) :: field_period_ratio real, intent(out), dimension(:, -nzgrid:) :: x_displacement_fac public subroutine filter_geo_coef (naky, geocoef) Arguments Type Intent Optional Attributes Name integer, intent(in) :: naky real, intent(inout), dimension(:) :: geocoef public subroutine get_modified_vmec_zeta_grid (nzgrid_modified, dzeta_modified) need to extend the maximum and minimum zeta values\nby zgrid_scalefac to ensure that we have information\nabout geometric coefficients everywhere on a fixed\nequal-arc grid in zed\nfirst figure out how many extra zeta grid points are\nrequired at the nominal grid spacing to get out\nto the ends of the extended zeta domain\nfirst calculate the nominal zeta grid used for vmec\nnote that nfield_periods is the number of field periods\nsampled in stella, while nfield_periods_device\nis the number of field periods in the device\nnfield_periods may be reasonably bigger than nfield_periods_device\nas the former is sampled while keeping alpha fixed (rather than theta) Read moreâ€¦ Arguments Type Intent Optional Attributes Name integer, intent(out) :: nzgrid_modified real :: dzeta_modified","tags":"","loc":"module/vmec_geo.html"},{"title":"millerlocal â€“ stella","text":"Uses common_types Contents Variables nzed_local rhoc rmaj shift kappa kapprim tri triprim betaprim betadbprim qinp shat d2qdr2 rgeo dpsidrho d2psidr2 dpsidrho_psi0 psitor_lcfs rhotor drhotordrho dIdrho dI rhoc0 write_profile_variation read_profile_variation load_psi0_variables nz nz2pi bi dqdr d2Idr2 grho bmag grho_psi0 bmag_psi0 gradpar gradpararc arc gds2 gds21 gds22 gds23 gds24 gbdrift0 gbdrift cvdrift0 cvdrift d2Rdth2 d2Zdth2 d2Rdrdth d2Zdrdth gpsi dBdrho d2Bdrdth dgradpardrho dgradparBdrho dBdth gradparb dcvdrift0drho dgbdrift0drho theta varthet dvarthdr gradrho_gradthet cross d2varthdr2 gradthet2 gradalph_gradthet gradrho_gradalph gradalph2 d2Bdr2 d2Rdr2 d2Zdr2 drz drzdth d2Rdr2dth d2Zdr2dth d2gpsidr2 dcrossdr dcvdriftdrho dgbdriftdrho dgds2dr dgds21dr dgds22dr dgr2dr dgpsi2dr dgrgt dgt2 dgagr dgagt dga2 Rr Zr jacrho delthet djacdrho djacrdrho d2jacdr2 dRdrho dZdrho dRdth dZdth d2R d2Z local defaults_initialized Functions Rpos Zpos mod2pi Subroutines init_local_defaults read_local_parameters communicate_parameters_multibox get_local_geo allocate_arrays deallocate_arrays finish_local_geo get_drho get_d2dthet2 get_dthet get_jacrho get_gradrho get_dIdrho get_djacdrho get_d2RZdr2 get_dgr2dr get_graddotgrad get_gds get_dBdrho get_varthet get_dvarthdr get_d2Idr2_d2jacdr2 get_d2varthdr2 get_d2Bdr2 get_dcrossdr theta_integrate theta_integrate_indef Variables Type Visibility Attributes Name Initial integer, private :: nzed_local real, private :: rhoc real, private :: rmaj real, private :: shift real, private :: kappa real, private :: kapprim real, private :: tri real, private :: triprim real, private :: betaprim real, private :: betadbprim real, private :: qinp real, private :: shat real, private :: d2qdr2 real, private :: rgeo real, private :: dpsidrho real, private :: d2psidr2 real, private :: dpsidrho_psi0 real, private :: psitor_lcfs real, private :: rhotor real, private :: drhotordrho real, private :: dIdrho real, private :: dI real, private :: rhoc0 logical, private :: write_profile_variation logical, private :: read_profile_variation logical, private :: load_psi0_variables integer, private :: nz integer, private :: nz2pi real, private :: bi real, private :: dqdr real, private :: d2Idr2 real, private, dimension(:), allocatable :: grho real, private, dimension(:), allocatable :: bmag real, private, dimension(:), allocatable :: grho_psi0 real, private, dimension(:), allocatable :: bmag_psi0 real, private, dimension(:), allocatable :: gradpar real, private, dimension(:), allocatable :: gradpararc real, private, dimension(:), allocatable :: arc real, private, dimension(:), allocatable :: gds2 real, private, dimension(:), allocatable :: gds21 real, private, dimension(:), allocatable :: gds22 real, private, dimension(:), allocatable :: gds23 real, private, dimension(:), allocatable :: gds24 real, private, dimension(:), allocatable :: gbdrift0 real, private, dimension(:), allocatable :: gbdrift real, private, dimension(:), allocatable :: cvdrift0 real, private, dimension(:), allocatable :: cvdrift real, private, dimension(:), allocatable :: d2Rdth2 real, private, dimension(:), allocatable :: d2Zdth2 real, private, dimension(:), allocatable :: d2Rdrdth real, private, dimension(:), allocatable :: d2Zdrdth real, private, dimension(:), allocatable :: gpsi real, private, dimension(:), allocatable :: dBdrho real, private, dimension(:), allocatable :: d2Bdrdth real, private, dimension(:), allocatable :: dgradpardrho real, private, dimension(:), allocatable :: dgradparBdrho real, private, dimension(:), allocatable :: dBdth real, private, dimension(:), allocatable :: gradparb real, private, dimension(:), allocatable :: dcvdrift0drho real, private, dimension(:), allocatable :: dgbdrift0drho real, private, dimension(:), allocatable :: theta real, private, dimension(:), allocatable :: varthet real, private, dimension(:), allocatable :: dvarthdr real, private, dimension(:), allocatable :: gradrho_gradthet real, private, dimension(:), allocatable :: cross real, private, dimension(:), allocatable :: d2varthdr2 real, private, dimension(:), allocatable :: gradthet2 real, private, dimension(:), allocatable :: gradalph_gradthet real, private, dimension(:), allocatable :: gradrho_gradalph real, private, dimension(:), allocatable :: gradalph2 real, private, dimension(:), allocatable :: d2Bdr2 real, private, dimension(:), allocatable :: d2Rdr2 real, private, dimension(:), allocatable :: d2Zdr2 real, private, dimension(:), allocatable :: drz real, private, dimension(:), allocatable :: drzdth real, private, dimension(:), allocatable :: d2Rdr2dth real, private, dimension(:), allocatable :: d2Zdr2dth real, private, dimension(:), allocatable :: d2gpsidr2 real, private, dimension(:), allocatable :: dcrossdr real, private, dimension(:), allocatable :: dcvdriftdrho real, private, dimension(:), allocatable :: dgbdriftdrho real, private, dimension(:), allocatable :: dgds2dr real, private, dimension(:), allocatable :: dgds21dr real, private, dimension(:), allocatable :: dgds22dr real, private, dimension(:), allocatable :: dgr2dr real, private, dimension(:), allocatable :: dgpsi2dr real, private, dimension(:), allocatable :: dgrgt real, private, dimension(:), allocatable :: dgt2 real, private, dimension(:), allocatable :: dgagr real, private, dimension(:), allocatable :: dgagt real, private, dimension(:), allocatable :: dga2 real, private, dimension(:, :), allocatable :: Rr real, private, dimension(:, :), allocatable :: Zr real, private, dimension(:), allocatable :: jacrho real, private, dimension(:), allocatable :: delthet real, private, dimension(:), allocatable :: djacdrho real, private, dimension(:), allocatable :: djacrdrho real, private, dimension(:), allocatable :: d2jacdr2 real, private, dimension(:), allocatable :: dRdrho real, private, dimension(:), allocatable :: dZdrho real, private, dimension(:), allocatable :: dRdth real, private, dimension(:), allocatable :: dZdth real, private, dimension(:), allocatable :: d2R real, private, dimension(:), allocatable :: d2Z type( flux_surface_type ), public :: local logical, private :: defaults_initialized = .false. Functions private function Rpos (r, theta, j) Arguments Type Intent Optional Attributes Name real, intent(in) :: r real, intent(in) :: theta integer, intent(in) :: j Return Value real private function Zpos (r, theta, j) Arguments Type Intent Optional Attributes Name real, intent(in) :: r real, intent(in) :: theta integer, intent(in) :: j Return Value real private function mod2pi (theta) Arguments Type Intent Optional Attributes Name real, intent(in) :: theta Return Value real Subroutines public subroutine init_local_defaults () Arguments None public subroutine read_local_parameters (nzed, nzgrid, local_out) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nzed integer, intent(in) :: nzgrid type( flux_surface_type ), intent(out) :: local_out public subroutine communicate_parameters_multibox (surf, drl, drr) Arguments Type Intent Optional Attributes Name type( flux_surface_type ), intent(inout) :: surf real, intent(in), optional :: drl real, intent(in), optional :: drr public subroutine get_local_geo (nzed, nzgrid, zed_in, zed_equal_arc, dpsidrho_out, dpsidrho_psi0_out, dIdrho_out, grho_out, bmag_out, bmag_psi0_out, gds2_out, gds21_out, gds22_out, gds23_out, gds24_out, gradpar_out, gbdrift0_out, gbdrift_out, cvdrift0_out, cvdrift_out, dBdrho_out, d2Bdrdth_out, dgradpardrho_out, btor_out, rmajor_out, dcvdrift0drho_out, dcvdriftdrho_out, dgbdrift0drho_out, dgbdriftdrho_out, dgds2dr_out, dgds21dr_out, dgds22dr_out, djacdrho_out) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nzed integer, intent(in) :: nzgrid real, intent(in), dimension(-nzgrid:) :: zed_in logical, intent(in) :: zed_equal_arc real, intent(out) :: dpsidrho_out real, intent(out) :: dpsidrho_psi0_out real, intent(out) :: dIdrho_out real, intent(out), dimension(-nzgrid:) :: grho_out real, intent(out), dimension(-nzgrid:) :: bmag_out real, intent(out), dimension(-nzgrid:) :: bmag_psi0_out real, intent(out), dimension(-nzgrid:) :: gds2_out real, intent(out), dimension(-nzgrid:) :: gds21_out real, intent(out), dimension(-nzgrid:) :: gds22_out real, intent(out), dimension(-nzgrid:) :: gds23_out real, intent(out), dimension(-nzgrid:) :: gds24_out real, intent(out), dimension(-nzgrid:) :: gradpar_out real, intent(out), dimension(-nzgrid:) :: gbdrift0_out real, intent(out), dimension(-nzgrid:) :: gbdrift_out real, intent(out), dimension(-nzgrid:) :: cvdrift0_out real, intent(out), dimension(-nzgrid:) :: cvdrift_out real, intent(out), dimension(-nzgrid:) :: dBdrho_out real, intent(out), dimension(-nzgrid:) :: d2Bdrdth_out real, intent(out), dimension(-nzgrid:) :: dgradpardrho_out real, intent(out), dimension(-nzgrid:) :: btor_out real, intent(out), dimension(-nzgrid:) :: rmajor_out real, intent(out), dimension(-nzgrid:) :: dcvdrift0drho_out real, intent(out), dimension(-nzgrid:) :: dcvdriftdrho_out real, intent(out), dimension(-nzgrid:) :: dgbdrift0drho_out real, intent(out), dimension(-nzgrid:) :: dgbdriftdrho_out real, intent(out), dimension(-nzgrid:) :: dgds2dr_out real, intent(out), dimension(-nzgrid:) :: dgds21dr_out real, intent(out), dimension(-nzgrid:) :: dgds22dr_out real, intent(out), dimension(-nzgrid:) :: djacdrho_out private subroutine allocate_arrays (nr, nz) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nr integer, intent(in) :: nz private subroutine deallocate_arrays () Arguments None public subroutine finish_local_geo () Arguments None private subroutine get_drho (f, df) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, -nz:) :: f real, intent(out), dimension(-nz:) :: df private subroutine get_d2dthet2 (f, d2f) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nz:) :: f real, intent(out), dimension(-nz:) :: d2f private subroutine get_dthet (f, df) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nz:) :: f real, intent(out), dimension(-nz:) :: df private subroutine get_jacrho () Arguments None private subroutine get_gradrho (dpsidrho, grho) Arguments Type Intent Optional Attributes Name real, intent(in) :: dpsidrho real, intent(out), dimension(-nz:) :: grho private subroutine get_dIdrho (dpsidrho, grho, dIdrho) Arguments Type Intent Optional Attributes Name real, intent(in) :: dpsidrho real, intent(in), dimension(-nz:) :: grho real, intent(out) :: dIdrho private subroutine get_djacdrho (dpsidrho, dIdrho, grho) Arguments Type Intent Optional Attributes Name real, intent(in) :: dpsidrho real, intent(in) :: dIdrho real, intent(in), dimension(-nz:) :: grho private subroutine get_d2RZdr2 () Arguments None private subroutine get_dgr2dr (dpsidrho, grho) Arguments Type Intent Optional Attributes Name real, intent(in) :: dpsidrho real, intent(in), dimension(-nz:) :: grho private subroutine get_graddotgrad (dpsidrho, grho) Arguments Type Intent Optional Attributes Name real, intent(in) :: dpsidrho real, intent(in), dimension(-nz:) :: grho private subroutine get_gds (gds2, gds21, gds22, gds23, gds24) Arguments Type Intent Optional Attributes Name real, intent(out), dimension(-nz:) :: gds2 real, intent(out), dimension(-nz:) :: gds21 real, intent(out), dimension(-nz:) :: gds22 real, intent(out), dimension(-nz:) :: gds23 real, intent(out), dimension(-nz:) :: gds24 private subroutine get_dBdrho (bmag, dIdrho) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nz:) :: bmag real, intent(in) :: dIdrho private subroutine get_varthet (dpsidrho) Arguments Type Intent Optional Attributes Name real, intent(in) :: dpsidrho private subroutine get_dvarthdr (dpsidrho, dIdrho) Arguments Type Intent Optional Attributes Name real, intent(in) :: dpsidrho real, intent(in) :: dIdrho private subroutine get_d2Idr2_d2jacdr2 (grho, dIdrho) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nz:) :: grho real, intent(in) :: dIdrho private subroutine get_d2varthdr2 (dpsidrho, dIdrho) Arguments Type Intent Optional Attributes Name real, intent(in) :: dpsidrho real, intent(in) :: dIdrho private subroutine get_d2Bdr2 (bmag, dIdrho) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nz:) :: bmag real, intent(in) :: dIdrho private subroutine get_dcrossdr (dpsidrho, dIdrho, grho) Arguments Type Intent Optional Attributes Name real, intent(in) :: dpsidrho real, intent(in) :: dIdrho real, intent(in), dimension(-nz:) :: grho private subroutine theta_integrate (integrand, integral) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nz2pi:) :: integrand real, intent(out) :: integral private subroutine theta_integrate_indef (integrand, integral) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nz:) :: integrand real, intent(out), dimension(-nz:) :: integral","tags":"","loc":"module/millerlocal.html"},{"title":"vmec_to_stella_geometry_interface_mod â€“ stella","text":"Contents Variables theta_pest_target zeta0 vmec_radial_weight_full vmec_radial_weight_half vmec_radial_index_full vmec_radial_index_half lasym nfp isigng ns mnmax mnmax_nyq mpol ntor Aminor xm xn xm_nyq xn_nyq rmnc rmns lmnc lmns zmnc zmns bmnc bmns gmnc gmns bsupumnc bsupumns bsupvmnc bsupvmns bsubumnc bsubumns bsubvmnc bsubvmns bsubsmnc bsubsmns phi phip iotas iotaf presf Functions fzero_residual Subroutines read_vmec_equilibrium get_nominal_vmec_zeta_grid vmec_to_stella_geometry_interface get_root Variables Type Visibility Attributes Name Initial real, private :: theta_pest_target real, private :: zeta0 real, private, dimension(2) :: vmec_radial_weight_full real, private, dimension(2) :: vmec_radial_weight_half integer, private, dimension(2) :: vmec_radial_index_full integer, private, dimension(2) :: vmec_radial_index_half logical, private :: lasym integer, private :: nfp integer, private :: isigng integer, private :: ns integer, private :: mnmax integer, private :: mnmax_nyq integer, private :: mpol integer, private :: ntor real, private :: Aminor real, private, dimension(:), allocatable :: xm real, private, dimension(:), allocatable :: xn real, private, dimension(:), allocatable :: xm_nyq real, private, dimension(:), allocatable :: xn_nyq real, private, dimension(:, :), allocatable :: rmnc real, private, dimension(:, :), allocatable :: rmns real, private, dimension(:, :), allocatable :: lmnc real, private, dimension(:, :), allocatable :: lmns real, private, dimension(:, :), allocatable :: zmnc real, private, dimension(:, :), allocatable :: zmns real, private, dimension(:, :), allocatable :: bmnc real, private, dimension(:, :), allocatable :: bmns real, private, dimension(:, :), allocatable :: gmnc real, private, dimension(:, :), allocatable :: gmns real, private, dimension(:, :), allocatable :: bsupumnc real, private, dimension(:, :), allocatable :: bsupumns real, private, dimension(:, :), allocatable :: bsupvmnc real, private, dimension(:, :), allocatable :: bsupvmns real, private, dimension(:, :), allocatable :: bsubumnc real, private, dimension(:, :), allocatable :: bsubumns real, private, dimension(:, :), allocatable :: bsubvmnc real, private, dimension(:, :), allocatable :: bsubvmns real, private, dimension(:, :), allocatable :: bsubsmnc real, private, dimension(:, :), allocatable :: bsubsmns real, private, dimension(:), allocatable :: phi real, private, dimension(:), allocatable :: phip real, private, dimension(:), allocatable :: iotas real, private, dimension(:), allocatable :: iotaf real, private, dimension(:), allocatable :: presf Functions private function fzero_residual (theta_vmec_try) Arguments Type Intent Optional Attributes Name real :: theta_vmec_try Return Value real Subroutines public subroutine read_vmec_equilibrium (vmec_filename) Arguments Type Intent Optional Attributes Name character, intent(in) :: vmec_filename public subroutine get_nominal_vmec_zeta_grid (nzgrid, zeta_center, number_of_field_periods_stella, number_of_field_periods_device, zeta) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nzgrid real, intent(in) :: zeta_center real, intent(inout) :: number_of_field_periods_stella real, intent(out) :: number_of_field_periods_device real, intent(out), dimension(-nzgrid:) :: zeta public subroutine vmec_to_stella_geometry_interface (nalpha, alpha0, nzgrid, zeta_center, number_of_field_periods_to_include, desired_normalized_toroidal_flux, vmec_surface_option, verbose, normalized_toroidal_flux_used, safety_factor_q, shat, L_reference, B_reference, nfp_out, sign_toroidal_flux, alpha, zeta, bmag, gradpar_zeta, grad_alpha_grad_alpha, grad_alpha_grad_psi, grad_psi_grad_psi, gds23, gds24, gds25, gds26, gbdrift_alpha, gbdrift0_psi, cvdrift_alpha, cvdrift0_psi, theta_vmec, B_sub_zeta, B_sub_theta_vmec, x_displacement_fac) Input parameters Read moreâ€¦ Arguments Type Intent Optional Attributes Name integer, intent(in) :: nalpha real, intent(in) :: alpha0 integer, intent(in) :: nzgrid real, intent(in) :: zeta_center real, intent(in) :: number_of_field_periods_to_include real, intent(in) :: desired_normalized_toroidal_flux integer, intent(in) :: vmec_surface_option logical, intent(in) :: verbose Output quantities real, intent(out) :: normalized_toroidal_flux_used real, intent(out) :: safety_factor_q real, intent(out) :: shat real, intent(out) :: L_reference real, intent(out) :: B_reference real, intent(out) :: nfp_out integer, intent(out) :: sign_toroidal_flux real, intent(out), dimension(:) :: alpha real, intent(out), dimension(-nzgrid:) :: zeta real, intent(out), dimension(:, -nzgrid:) :: bmag real, intent(out), dimension(:, -nzgrid:) :: gradpar_zeta real, intent(out), dimension(:, -nzgrid:) :: grad_alpha_grad_alpha real, intent(out), dimension(:, -nzgrid:) :: grad_alpha_grad_psi real, intent(out), dimension(:, -nzgrid:) :: grad_psi_grad_psi real, intent(out), dimension(:, -nzgrid:) :: gds23 real, intent(out), dimension(:, -nzgrid:) :: gds24 real, intent(out), dimension(:, -nzgrid:) :: gds25 real, intent(out), dimension(:, -nzgrid:) :: gds26 real, intent(out), dimension(:, -nzgrid:) :: gbdrift_alpha real, intent(out), dimension(:, -nzgrid:) :: gbdrift0_psi real, intent(out), dimension(:, -nzgrid:) :: cvdrift_alpha real, intent(out), dimension(:, -nzgrid:) :: cvdrift0_psi real, intent(out), dimension(:, -nzgrid:) :: theta_vmec real, intent(out), dimension(:, -nzgrid:) :: B_sub_zeta real, intent(out), dimension(:, -nzgrid:) :: B_sub_theta_vmec real, intent(out), dimension(:, -nzgrid:) :: x_displacement_fac Variables used internally by this subroutine private subroutine get_root (a0, b0, root, converged) Arguments Type Intent Optional Attributes Name real, intent(in) :: a0 real, intent(in) :: b0 real, intent(out) :: root logical, intent(out) :: converged","tags":"","loc":"module/vmec_to_stella_geometry_interface_mod.html"},{"title":"fzero_mod â€“ stella","text":"Contents Subroutines FZERO Subroutines public subroutine FZERO (F, B, C, R, RE, AE, IFLAG) BEGIN PROLOGUE  FZERO PURPOSE  Search for a zero of a function F(X) in a given interval\n            (B,C).  It is designed primarily for problems where F(B)\n            and F(C) have opposite signs. LIBRARY   SLATEC CATEGORY  F1B TYPE      SINGLE PRECISION (FZERO-S, DFZERO-D) KEYWORDS  BISECTION, NONLINEAR EQUATIONS, ROOTS, ZEROS AUTHOR  Shampine, L. F., (SNLA)\n           Watts, H. A., (SNLA) DESCRIPTION Read moreâ€¦ Arguments Type Intent Optional Attributes Name real :: F real :: B real :: C real :: R real :: RE real :: AE integer :: IFLAG","tags":"","loc":"module/fzero_mod.html"},{"title":"safe_open_mod â€“ stella","text":"Contents Subroutines safe_open Subroutines public subroutine safe_open (iunit, istat, filename, filestat, fileform, record_in, access_in, delim_in) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: iunit integer, intent(out) :: istat character(len=*), intent(in) :: filename character(len=*), intent(in) :: filestat character(len=*), intent(in) :: fileform integer, intent(in), optional :: record_in character(len=*), intent(in), optional :: access_in character(len=*), intent(in), optional :: delim_in","tags":"","loc":"module/safe_open_mod.html"},{"title":"stel_kinds â€“ stella","text":"Contents Variables rprec iprec cprec dp Variables Type Visibility Attributes Name Initial integer, public, parameter :: rprec = SELECTED_REAL_KIND(12, 100) integer, public, parameter :: iprec = SELECTED_INT_KIND(8) integer, public, parameter :: cprec = KIND((1.0_rprec, 1.0_rprec)) integer, public, parameter :: dp = rprec","tags":"","loc":"module/stel_kinds.html"},{"title":"vmec_input â€“ stella","text":"Uses vsvd0 vparams Contents Variables mpol_default ntor_default ns_default nfp ncurr nsin niter nstep nvacskip mpol ntor ntheta nzeta mfilter_fbdy nfilter_fbdy max_main_iterations ns_array niter_array imse isnodes itse ipnodes iopt_raxis imatch_phiedge nflxs nbfld indxflx indxbfld rbs zbc rbc zbs time_slice curtor delt ftol tcon0 gamma phiedge phidiam sigma_current sigma_delphid tensi tensp tensi2 fpolyi presfac mseangle_offset pres_offset mseangle_offsetm spres_ped bloat pres_scale prec2d_threshold am ai ac aphi pcurr_type piota_type pmass_type am_aux_s am_aux_f ai_aux_s ai_aux_f ac_aux_s ac_aux_f ah at bcrit pt_type ph_type ah_aux_s ah_aux_f at_aux_s at_aux_f raxis zaxis raxis_cc raxis_cs zaxis_cc zaxis_cs ftol_array extcur mseprof rthom datathom sigma_thom rstark datastark sigma_stark dsiobt sigma_flux bbc sigma_b psa pfa isa ifa lpofr lmac lfreeb lrecon loldout ledge_dump lasym lforbal lrfp lmovie lmove_axis lwouttxt ldiagno lgiveup fgiveup lbsubs mgrid_file trip3d_file precon_type arg1 input_extension Subroutines read_indata_namelist read_mse_namelist write_indata_namelist Variables Type Visibility Attributes Name Initial integer, public, parameter :: mpol_default = 6 integer, public, parameter :: ntor_default = 0 integer, public, parameter :: ns_default = 31 integer, public :: nfp integer, public :: ncurr integer, public :: nsin integer, public :: niter integer, public :: nstep integer, public :: nvacskip integer, public :: mpol integer, public :: ntor integer, public :: ntheta integer, public :: nzeta integer, public :: mfilter_fbdy integer, public :: nfilter_fbdy integer, public :: max_main_iterations integer, public, DIMENSION(100) :: ns_array integer, public, DIMENSION(100) :: niter_array integer, public :: imse integer, public :: isnodes integer, public :: itse integer, public :: ipnodes integer, public :: iopt_raxis integer, public :: imatch_phiedge integer, public :: nflxs integer, public, DIMENSION(nbsetsp) :: nbfld integer, public, DIMENSION(nfloops) :: indxflx integer, public, DIMENSION(nbcoilsp,nbsetsp) :: indxbfld real(kind=rprec), public, DIMENSION(-ntord:ntord,0:mpol1d) :: rbs real(kind=rprec), public, DIMENSION(-ntord:ntord,0:mpol1d) :: zbc real(kind=rprec), public, DIMENSION(-ntord:ntord,0:mpol1d) :: rbc real(kind=rprec), public, DIMENSION(-ntord:ntord,0:mpol1d) :: zbs real(kind=rprec), public :: time_slice real(kind=rprec), public :: curtor real(kind=rprec), public :: delt real(kind=rprec), public :: ftol real(kind=rprec), public :: tcon0 real(kind=rprec), public :: gamma real(kind=rprec), public :: phiedge real(kind=rprec), public :: phidiam real(kind=rprec), public :: sigma_current real(kind=rprec), public :: sigma_delphid real(kind=rprec), public :: tensi real(kind=rprec), public :: tensp real(kind=rprec), public :: tensi2 real(kind=rprec), public :: fpolyi real(kind=rprec), public :: presfac real(kind=rprec), public :: mseangle_offset real(kind=rprec), public :: pres_offset real(kind=rprec), public :: mseangle_offsetm real(kind=rprec), public :: spres_ped real(kind=rprec), public :: bloat real(kind=rprec), public :: pres_scale real(kind=rprec), public :: prec2d_threshold real(kind=rprec), public, DIMENSION(0:20) :: am real(kind=rprec), public, DIMENSION(0:20) :: ai real(kind=rprec), public, DIMENSION(0:20) :: ac real(kind=rprec), public, DIMENSION(1:20) :: aphi character(len=20), public :: pcurr_type character(len=20), public :: piota_type character(len=20), public :: pmass_type real(kind=rprec), public, DIMENSION(ndatafmax) :: am_aux_s real(kind=rprec), public, DIMENSION(ndatafmax) :: am_aux_f real(kind=rprec), public, DIMENSION(ndatafmax) :: ai_aux_s real(kind=rprec), public, DIMENSION(ndatafmax) :: ai_aux_f real(kind=rprec), public, DIMENSION(ndatafmax) :: ac_aux_s real(kind=rprec), public, DIMENSION(ndatafmax) :: ac_aux_f real(kind=rprec), public, DIMENSION(0:20) :: ah real(kind=rprec), public, DIMENSION(0:20) :: at real(kind=rprec), public :: bcrit character(len=20), public :: pt_type character(len=20), public :: ph_type real(kind=rprec), public, DIMENSION(ndatafmax) :: ah_aux_s real(kind=rprec), public, DIMENSION(ndatafmax) :: ah_aux_f real(kind=rprec), public, DIMENSION(ndatafmax) :: at_aux_s real(kind=rprec), public, DIMENSION(ndatafmax) :: at_aux_f real(kind=rprec), public, DIMENSION(0:ntord) :: raxis real(kind=rprec), public, DIMENSION(0:ntord) :: zaxis real(kind=rprec), public, DIMENSION(0:ntord) :: raxis_cc real(kind=rprec), public, DIMENSION(0:ntord) :: raxis_cs real(kind=rprec), public, DIMENSION(0:ntord) :: zaxis_cc real(kind=rprec), public, DIMENSION(0:ntord) :: zaxis_cs real(kind=rprec), public, DIMENSION(100) :: ftol_array real(kind=rprec), public, DIMENSION(nigroup), TARGET :: extcur real(kind=rprec), public, DIMENSION(nmse) :: mseprof real(kind=rprec), public, DIMENSION(ntse) :: rthom real(kind=rprec), public, DIMENSION(ntse) :: datathom real(kind=rprec), public, DIMENSION(ntse) :: sigma_thom real(kind=rprec), public, DIMENSION(nmse) :: rstark real(kind=rprec), public, DIMENSION(nmse) :: datastark real(kind=rprec), public, DIMENSION(nmse) :: sigma_stark real(kind=rprec), public, DIMENSION(nfloops) :: dsiobt real(kind=rprec), public, DIMENSION(nfloops) :: sigma_flux real(kind=rprec), public, DIMENSION(nbcoilsp,nbsetsp) :: bbc real(kind=rprec), public, DIMENSION(nbcoilsp,nbsetsp) :: sigma_b real(kind=rprec), public, DIMENSION(ndatafmax) :: psa real(kind=rprec), public, DIMENSION(ndatafmax) :: pfa real(kind=rprec), public, DIMENSION(ndatafmax) :: isa real(kind=rprec), public, DIMENSION(ndatafmax) :: ifa logical, public :: lpofr logical, public :: lmac logical, public :: lfreeb logical, public :: lrecon logical, public :: loldout logical, public :: ledge_dump logical, public :: lasym logical, public :: lforbal logical, public :: lrfp logical, public :: lmovie logical, public :: lmove_axis logical, public :: lwouttxt logical, public :: ldiagno logical, public :: logical, public :: lgiveup real(kind=rprec), public :: fgiveup logical, public :: lbsubs character(len=200), public :: mgrid_file character(len=200), public :: trip3d_file character(len=10), public :: precon_type character(len=120), public :: arg1 character(len=100), public :: input_extension Subroutines public subroutine read_indata_namelist (iunit, istat) Arguments Type Intent Optional Attributes Name integer :: iunit integer :: istat public subroutine read_mse_namelist (iunit, istat) Arguments Type Intent Optional Attributes Name integer :: iunit integer :: istat public subroutine write_indata_namelist (iunit, istat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iunit integer, intent(inout) :: istat","tags":"","loc":"module/vmec_input.html"},{"title":"mgrid_mod â€“ stella","text":"Uses vsvd0 stel_kinds vmec_input Contents Variables lnverror nlimset vn_br0 vn_bp0 vn_bz0 vn_ir vn_jz vn_kp vn_nfp vn_rmin vn_rmax vn_zmin vn_zmax vn_coilgrp vn_nextcur vn_mgmode vn_coilcur vn_flp vn_nobd vn_nbset vn_nbfld ln_flp ln_nobd ln_nbset ln_next ln_nbfld nr0b np0b nfper0 nz0b nobd nobser nextcur nbfldn nbsets nbcoilsn nbvac nbcoil_max nlim nlim_max nsets nrgrid nzgrid needflx nbcoils limitr nsetsn iconnect needbfld rminb zminb rmaxb zmaxb delrb delzb rx1 rx2 zy1 zy2 condif bvac brvac bzvac bpvac unpsiext plbfld rbcoil zbcoil abcoil bcoil rbcoilsqr raw_coil_current xobser zobser xobsqr dsiext psiext plflux b_chi mgrid_path mgrid_path_old curlabel dsilabel bloopnames tokid dbcoil pfcspec rlim zlim reslim seplim mgrid_mode Subroutines read_mgrid read_mgrid_bin read_mgrid_nc sum_bfield assign_bptrs free_mgrid Variables Type Visibility Attributes Name Initial logical, public :: lnverror = .true. integer, public, parameter :: nlimset = 2 character(len=*), public, parameter :: vn_br0 = 'br' character(len=*), public, parameter :: vn_bp0 = 'bp' character(len=*), public, parameter :: vn_bz0 = 'bz' character(len=*), public, parameter :: vn_ir = 'ir' character(len=*), public, parameter :: vn_jz = 'jz' character(len=*), public, parameter :: vn_kp = 'kp' character(len=*), public, parameter :: vn_nfp = 'nfp' character(len=*), public, parameter :: vn_rmin = 'rmin' character(len=*), public, parameter :: vn_rmax = 'rmax' character(len=*), public, parameter :: vn_zmin = 'zmin' character(len=*), public, parameter :: vn_zmax = 'zmax' character(len=*), public, parameter :: vn_coilgrp = 'coil_group' character(len=*), public, parameter :: vn_nextcur = 'nextcur' character(len=*), public, parameter :: vn_mgmode = 'mgrid_mode' character(len=*), public, parameter :: vn_coilcur = 'raw_coil_cur' character(len=*), public, parameter :: vn_flp = 'nobser' character(len=*), public, parameter :: vn_nobd = 'nobd' character(len=*), public, parameter :: vn_nbset = 'nbsets' character(len=*), public, parameter :: vn_nbfld = 'nbfld' character(len=*), public, parameter :: ln_flp = 'flux loops' character(len=*), public, parameter :: ln_nobd = 'Connected flux loops' character(len=*), public, parameter :: ln_nbset = 'B-coil loops' character(len=*), public, parameter :: ln_next = 'External currents' character(len=*), public, parameter :: ln_nbfld = 'B-coil measurements' integer, public :: nr0b integer, public :: np0b integer, public :: nfper0 integer, public :: nz0b integer, public :: nobd integer, public :: nobser integer, public :: nextcur integer, public :: nbfldn integer, public :: nbsets integer, public :: nbcoilsn integer, public :: nbvac integer, public :: nbcoil_max integer, public :: nlim integer, public :: nlim_max integer, public :: nsets integer, public :: nrgrid integer, public :: nzgrid integer, public, DIMENSION(:), ALLOCATABLE :: needflx integer, public, DIMENSION(:), ALLOCATABLE :: nbcoils integer, public, DIMENSION(:), ALLOCATABLE :: limitr integer, public, DIMENSION(:), ALLOCATABLE :: nsetsn integer, public, DIMENSION(:,:), ALLOCATABLE :: iconnect integer, public, DIMENSION(:,:), ALLOCATABLE :: needbfld real(kind=rprec), public :: rminb real(kind=rprec), public :: zminb real(kind=rprec), public :: rmaxb real(kind=rprec), public :: zmaxb real(kind=rprec), public :: delrb real(kind=rprec), public :: delzb real(kind=rprec), public :: rx1 real(kind=rprec), public :: rx2 real(kind=rprec), public :: zy1 real(kind=rprec), public :: zy2 real(kind=rprec), public :: condif real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE, TARGET :: bvac real(kind=rprec), public, DIMENSION(:,:,:), POINTER :: brvac real(kind=rprec), public, DIMENSION(:,:,:), POINTER :: bzvac real(kind=rprec), public, DIMENSION(:,:,:), POINTER :: bpvac real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: unpsiext real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: plbfld real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: rbcoil real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: zbcoil real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: abcoil real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: bcoil real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: rbcoilsqr real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: raw_coil_current real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: xobser real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: zobser real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: xobsqr real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: dsiext real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: psiext real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: plflux real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: b_chi character(len=300), public :: mgrid_path character(len=300), public :: mgrid_path_old = \" \" character(len=30), public, DIMENSION(:), ALLOCATABLE :: curlabel character(len=15), public, DIMENSION(:), ALLOCATABLE :: dsilabel character(len=15), public, DIMENSION(:), ALLOCATABLE :: bloopnames character(len=30), public :: tokid real(kind=rprec), public, DIMENSION(:,:,:), ALLOCATABLE :: dbcoil real(kind=rprec), public, DIMENSION(:,:,:), ALLOCATABLE :: pfcspec real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: rlim real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: zlim real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: reslim real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: seplim character(len=1), public :: mgrid_mode Subroutines public subroutine read_mgrid (mgrid_file, extcur, nv, nfp, lscreen, ier_flag) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: mgrid_file real(kind=rprec), intent(in) :: extcur (:) integer, intent(in) :: nv integer, intent(in) :: nfp logical, intent(in) :: lscreen integer, intent(out) :: ier_flag private subroutine read_mgrid_bin (filename, extcur, nv, nfp, ier_flag, lscreen) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=rprec), intent(in) :: extcur (:) integer, intent(in) :: nv integer, intent(in) :: nfp integer :: ier_flag logical :: lscreen private subroutine read_mgrid_nc (filename, extcur, nv, nfp, ier_flag, lscreen) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=rprec), intent(in) :: extcur (:) integer, intent(in) :: nv integer, intent(in) :: nfp integer :: ier_flag logical :: lscreen public subroutine sum_bfield (bfield, bf_add, cur, n1) Arguments Type Intent Optional Attributes Name real(kind=rprec), intent(inout) :: bfield (n1) real(kind=rprec), intent(in) :: bf_add (n1) real(kind=rprec) :: cur integer :: n1 public subroutine assign_bptrs (bptr) Arguments Type Intent Optional Attributes Name real(kind=rprec), intent(in), TARGET :: bptr (nr0b,nz0b,np0b,3) public subroutine free_mgrid (istat) Arguments Type Intent Optional Attributes Name integer :: istat","tags":"","loc":"module/mgrid_mod.html"},{"title":"ezcdf_GenPut â€“ stella","text":"Uses ezcdf_opncls ezcdf_inqvar Contents Variables nf_byte nf_int1 nf_char nf_short nf_int2 nf_int nf_float nf_real nf_double nf_ubyte nf_ushort nf_uint nf_int64 nf_uint64 nf_fill_byte nf_fill_int1 nf_fill_char nf_fill_short nf_fill_int2 nf_fill_int nf_fill_float nf_fill_real nf_fill_double nf_nowrite nf_write nf_clobber nf_noclobber nf_fill nf_nofill nf_lock nf_share nf_64bit_offset nf_64bit_data nf_cdf5 nf_sizehint_default nf_align_chunk nf_format_classic nf_format_64bit nf_format_64bit_offset nf_format_64bit_data nf_format_cdf5 nf_diskless nf_mmap nf_unlimited nf_global nf_max_dims nf_max_attrs nf_max_vars nf_max_name nf_max_var_dims nf_noerr nf_ebadid nf_eexist nf_einval nf_eperm nf_enotindefine nf_eindefine nf_einvalcoords nf_emaxdims nf_enameinuse nf_enotatt nf_emaxatts nf_ebadtype nf_ebaddim nf_eunlimpos nf_emaxvars nf_enotvar nf_eglobal nf_enotnc nf_ests nf_emaxname nf_eunlimit nf_enorecvars nf_echar nf_eedge nf_estride nf_ebadname nf_erange nf_enomem nf_evarsize nf_edimsize nf_etrunc nf_fatal nf_verbose nf_string nf_vlen nf_opaque nf_enum nf_compound nf_fill_ubyte nf_fill_ushort nf_format_netcdf4 nf_format_netcdf4_classic nf_netcdf4 nf_classic_model nf_chunk_seq nf_chunk_sub nf_chunk_sizes nf_endian_native nf_endian_little nf_endian_big nf_chunked nf_contiguous nf_nochecksum nf_fletcher32 nf_noshuffle nf_shuffle nf_szip_ec_option_mask nf_szip_nn_option_mask nf_mpiio nf_mpiposix nf_pnetcdf nf_independent nf_collective nf_ehdferr nf_ecantread nf_ecantwrite nf_ecantcreate nf_efilemeta nf_edimmeta nf_eattmeta nf_evarmeta nf_enocompound nf_eattexists nf_enotnc4 nf_estrictnc3 nf_enotnc3 nf_enopar nf_eparinit nf_ebadgrpid nf_ebadtypid nf_etypdefined nf_ebadfield nf_ebadclass nf_emaptype nf_elatefill nf_elatedef nf_edimscale nf_enogrp ncrdwr nccreat ncexcl ncindef ncnsync nchsync ncndirty nchdirty nclink ncnowrit ncwrite ncclob ncnoclob ncglobal ncfill ncnofill maxncop maxncdim maxncatt maxncvar maxncnam maxvdims ncnoerr ncebadid ncenfile nceexist nceinval nceperm ncenotin nceindef ncecoord ncemaxds ncename ncenoatt ncemaxat ncebadty ncebadd ncests nceunlim ncemaxvs ncenotvr nceglob ncenotnc ncfoobar ncsyserr ncfatal ncverbos ncentool ncbyte ncchar ncshort nclong ncfloat ncdouble ncunlim filbyte filchar filshort fillong filfloat fildoub r4 r8 cmplx_name varnam_noalpha Interfaces cdf_write cdfPutVar cdf_define Subroutines cdfw_3i cdfw_3l cdfw_3d cdfw_3c16 cdfw_3f cdfw_3c8 cdfw_2i cdfw_2l cdfw_2d cdfw_2c16 cdfw_2f cdfw_2c8 cdfw_2c cdfw_1i cdfw_1l cdfw_1d cdfw_1c16 cdfw_1f cdfw_1c8 cdfw_1c cdfw_0i cdfw_0l cdfw_0d cdfw_0c16 cdfw_0f cdfw_0c8 cdfDefVar cdfd_3i cdfd_2i cdfd_1i cdfd_0i cdfd_3l cdfd_2l cdfd_1l cdfd_0l cdfd_3d cdfd_2d cdfd_1d cdfd_0d cdfd_3f cdfd_2f cdfd_1f cdfd_0f cdfd_3c16 cdfd_2c16 cdfd_1c16 cdfd_0c16 cdfd_3c8 cdfd_2c8 cdfd_1c8 cdfd_0c8 cdfd_2c cdfd_1c Variables Type Visibility Attributes Name Initial integer, private, parameter :: nf_byte = 1 integer, private, parameter :: nf_int1 = nf_byte integer, private, parameter :: nf_char = 2 integer, private, parameter :: nf_short = 3 integer, private, parameter :: nf_int2 = nf_short integer, private, parameter :: nf_int = 4 integer, private, parameter :: nf_float = 5 integer, private, parameter :: nf_real = nf_float integer, private, parameter :: nf_double = 6 integer, private, parameter :: nf_ubyte = 7 integer, private, parameter :: nf_ushort = 8 integer, private, parameter :: nf_uint = 9 integer, private, parameter :: nf_int64 = 10 integer, private, parameter :: nf_uint64 = 11 integer, private, parameter :: nf_fill_byte = -127 integer, private, parameter :: nf_fill_int1 = nf_fill_byte integer, private, parameter :: nf_fill_char = 0 integer, private, parameter :: nf_fill_short = -32767 integer, private, parameter :: nf_fill_int2 = nf_fill_short integer, private, parameter :: nf_fill_int = -2147483647 real, private, parameter :: nf_fill_float = 9.9692099683868690e+36 real, private, parameter :: nf_fill_real = nf_fill_float doubleprecision, private, parameter :: nf_fill_double = 9.9692099683868690d+36 integer, private, parameter :: nf_nowrite = 0 integer, private, parameter :: nf_write = 1 integer, private, parameter :: nf_clobber = 0 integer, private, parameter :: nf_noclobber = 4 integer, private, parameter :: nf_fill = 0 integer, private, parameter :: nf_nofill = 256 integer, private, parameter :: nf_lock = 1024 integer, private, parameter :: nf_share = 2048 integer, private, parameter :: nf_64bit_offset = 512 integer, private, parameter :: nf_64bit_data = 32 integer, private, parameter :: nf_cdf5 = nf_64bit_data integer, private, parameter :: nf_sizehint_default = 0 integer, private, parameter :: nf_align_chunk = -1 integer, private, parameter :: nf_format_classic = 1 integer, private, parameter :: nf_format_64bit = 2 integer, private, parameter :: nf_format_64bit_offset = nf_format_64bit integer, private, parameter :: nf_format_64bit_data = 5 integer, private, parameter :: nf_format_cdf5 = nf_format_64bit_data integer, private, parameter :: nf_diskless = 8 integer, private, parameter :: nf_mmap = 16 integer, private, parameter :: nf_unlimited = 0 integer, private, parameter :: nf_global = 0 integer, private, parameter :: nf_max_dims = 1024 integer, private, parameter :: nf_max_attrs = 8192 integer, private, parameter :: nf_max_vars = 8192 integer, private, parameter :: nf_max_name = 256 integer, private, parameter :: nf_max_var_dims = nf_max_dims integer, private, parameter :: nf_noerr = 0 integer, private, parameter :: nf_ebadid = -33 integer, private, parameter :: nf_eexist = -35 integer, private, parameter :: nf_einval = -36 integer, private, parameter :: nf_eperm = -37 integer, private, parameter :: nf_enotindefine = -38 integer, private, parameter :: nf_eindefine = -39 integer, private, parameter :: nf_einvalcoords = -40 integer, private, parameter :: nf_emaxdims = -41 integer, private, parameter :: nf_enameinuse = -42 integer, private, parameter :: nf_enotatt = -43 integer, private, parameter :: nf_emaxatts = -44 integer, private, parameter :: nf_ebadtype = -45 integer, private, parameter :: nf_ebaddim = -46 integer, private, parameter :: nf_eunlimpos = -47 integer, private, parameter :: nf_emaxvars = -48 integer, private, parameter :: nf_enotvar = -49 integer, private, parameter :: nf_eglobal = -50 integer, private, parameter :: nf_enotnc = -51 integer, private, parameter :: nf_ests = -52 integer, private, parameter :: nf_emaxname = -53 integer, private, parameter :: nf_eunlimit = -54 integer, private, parameter :: nf_enorecvars = -55 integer, private, parameter :: nf_echar = -56 integer, private, parameter :: nf_eedge = -57 integer, private, parameter :: nf_estride = -58 integer, private, parameter :: nf_ebadname = -59 integer, private, parameter :: nf_erange = -60 integer, private, parameter :: nf_enomem = -61 integer, private, parameter :: nf_evarsize = -62 integer, private, parameter :: nf_edimsize = -63 integer, private, parameter :: nf_etrunc = -64 integer, private, parameter :: nf_fatal = 1 integer, private, parameter :: nf_verbose = 2 integer, private, parameter :: nf_string = 12 integer, private, parameter :: nf_vlen = 13 integer, private, parameter :: nf_opaque = 14 integer, private, parameter :: nf_enum = 15 integer, private, parameter :: nf_compound = 16 integer, private, parameter :: nf_fill_ubyte = 255 integer, private, parameter :: nf_fill_ushort = 65535 integer, private, parameter :: nf_format_netcdf4 = 3 integer, private, parameter :: nf_format_netcdf4_classic = 4 integer, private, parameter :: nf_netcdf4 = 4096 integer, private, parameter :: nf_classic_model = 256 integer, private, parameter :: nf_chunk_seq = 0 integer, private, parameter :: nf_chunk_sub = 1 integer, private, parameter :: nf_chunk_sizes = 2 integer, private, parameter :: nf_endian_native = 0 integer, private, parameter :: nf_endian_little = 1 integer, private, parameter :: nf_endian_big = 2 integer, private, parameter :: nf_chunked = 0 integer, private, parameter :: nf_contiguous = 1 integer, private, parameter :: nf_nochecksum = 0 integer, private, parameter :: nf_fletcher32 = 1 integer, private, parameter :: nf_noshuffle = 0 integer, private, parameter :: nf_shuffle = 1 integer, private, parameter :: nf_szip_ec_option_mask = 4 integer, private, parameter :: nf_szip_nn_option_mask = 32 integer, private, parameter :: nf_mpiio = 8192 integer, private, parameter :: nf_mpiposix = 16384 integer, private, parameter :: nf_pnetcdf = 32768 integer, private, parameter :: nf_independent = 0 integer, private, parameter :: nf_collective = 1 integer, private, parameter :: nf_ehdferr = -101 integer, private, parameter :: nf_ecantread = -102 integer, private, parameter :: nf_ecantwrite = -103 integer, private, parameter :: nf_ecantcreate = -104 integer, private, parameter :: nf_efilemeta = -105 integer, private, parameter :: nf_edimmeta = -106 integer, private, parameter :: nf_eattmeta = -107 integer, private, parameter :: nf_evarmeta = -108 integer, private, parameter :: nf_enocompound = -109 integer, private, parameter :: nf_eattexists = -110 integer, private, parameter :: nf_enotnc4 = -111 integer, private, parameter :: nf_estrictnc3 = -112 integer, private, parameter :: nf_enotnc3 = -113 integer, private, parameter :: nf_enopar = -114 integer, private, parameter :: nf_eparinit = -115 integer, private, parameter :: nf_ebadgrpid = -116 integer, private, parameter :: nf_ebadtypid = -117 integer, private, parameter :: nf_etypdefined = -118 integer, private, parameter :: nf_ebadfield = -119 integer, private, parameter :: nf_ebadclass = -120 integer, private, parameter :: nf_emaptype = -121 integer, private, parameter :: nf_elatefill = -122 integer, private, parameter :: nf_elatedef = -123 integer, private, parameter :: nf_edimscale = -124 integer, private, parameter :: nf_enogrp = -125 integer, private :: ncrdwr integer, private :: nccreat integer, private :: ncexcl integer, private :: ncindef integer, private :: ncnsync integer, private :: nchsync integer, private :: ncndirty integer, private :: nchdirty integer, private :: nclink integer, private :: ncnowrit integer, private :: ncwrite integer, private :: ncclob integer, private :: ncnoclob integer, private :: ncglobal integer, private :: ncfill integer, private :: ncnofill integer, private :: maxncop integer, private :: maxncdim integer, private :: maxncatt integer, private :: maxncvar integer, private :: maxncnam integer, private :: maxvdims integer, private :: ncnoerr integer, private :: ncebadid integer, private :: ncenfile integer, private :: nceexist integer, private :: nceinval integer, private :: nceperm integer, private :: ncenotin integer, private :: nceindef integer, private :: ncecoord integer, private :: ncemaxds integer, private :: ncename integer, private :: ncenoatt integer, private :: ncemaxat integer, private :: ncebadty integer, private :: ncebadd integer, private :: ncests integer, private :: nceunlim integer, private :: ncemaxvs integer, private :: ncenotvr integer, private :: nceglob integer, private :: ncenotnc integer, private :: ncfoobar integer, private :: ncsyserr integer, private :: ncfatal integer, private :: ncverbos integer, private, parameter :: ncentool = nf_emaxname integer, private :: ncbyte integer, private :: ncchar integer, private :: ncshort integer, private :: nclong integer, private :: ncfloat integer, private :: ncdouble integer, private :: ncunlim integer, private, parameter :: filbyte = -127 integer, private, parameter :: filchar = 0 integer, private, parameter :: filshort = -32767 integer, private, parameter :: fillong = -2147483647 real, private, parameter :: filfloat = 9.9692099683868690e+36 doubleprecision, private, parameter :: fildoub = 9.9692099683868690e+36 integer, private, parameter :: r4 = SELECTED_REAL_KIND(6, 37) integer, private, parameter :: r8 = SELECTED_REAL_KIND(12, 100) character(len=13), private, parameter :: cmplx_name = '__CmPlx_Re_Im' character(len=nf_max_name), private :: varnam_noalpha Interfaces public interface cdf_write public subroutine cdfw_3i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_3l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_3d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_3c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_3f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_3c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_2i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_2l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_2d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_2c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_2f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_2c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_2c (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfw_1i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfw_1l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfw_1d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfw_1c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfw_1f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfw_1c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfw_1c (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(in) :: varval integer, intent(out), optional :: ier public subroutine cdfw_0i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in) :: varval integer, intent(out), optional :: ier public subroutine cdfw_0l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in) :: varval integer, intent(out), optional :: ier public subroutine cdfw_0d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in) :: varval integer, intent(out), optional :: ier public subroutine cdfw_0c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in) :: varval integer, intent(out), optional :: ier public subroutine cdfw_0f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in) :: varval integer, intent(out), optional :: ier public subroutine cdfw_0c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in) :: varval integer, intent(out), optional :: ier public interface cdfPutVar public subroutine cdfw_3i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_3l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_3d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_3c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_3f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_3c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_2i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_2l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_2d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_2c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_2f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_2c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_2c (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfw_1i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfw_1l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfw_1d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfw_1c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfw_1f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfw_1c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfw_1c (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(in) :: varval integer, intent(out), optional :: ier public subroutine cdfw_0i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in) :: varval integer, intent(out), optional :: ier public subroutine cdfw_0l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in) :: varval integer, intent(out), optional :: ier public subroutine cdfw_0d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in) :: varval integer, intent(out), optional :: ier public subroutine cdfw_0c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in) :: varval integer, intent(out), optional :: ier public subroutine cdfw_0f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in) :: varval integer, intent(out), optional :: ier public subroutine cdfw_0c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in) :: varval integer, intent(out), optional :: ier public interface cdf_define public subroutine cdfDefVar (ncid, varnam, dimlens, xtype, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in), dimension(:) :: dimlens character(len=*), intent(in) :: xtype integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_3i (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_3l (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_3d (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_3c16 (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_3f (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_3c8 (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_2i (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_2l (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_2d (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_2c16 (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_2f (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_2c8 (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_2c (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_1i (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in), dimension(:) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_1l (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in), dimension(:) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_1d (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_1c16 (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_1f (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_1c8 (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_1c (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(in) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_0i (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_0l (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_0d (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_0c16 (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_0f (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_0c8 (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname Subroutines public subroutine cdfw_3i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_3l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_3d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_3c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_3f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_3c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_2i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_2l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_2d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_2c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_2f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_2c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfw_2c (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfw_1i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfw_1l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfw_1d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfw_1c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfw_1f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfw_1c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfw_1c (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(in) :: varval integer, intent(out), optional :: ier public subroutine cdfw_0i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in) :: varval integer, intent(out), optional :: ier public subroutine cdfw_0l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in) :: varval integer, intent(out), optional :: ier public subroutine cdfw_0d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in) :: varval integer, intent(out), optional :: ier public subroutine cdfw_0c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in) :: varval integer, intent(out), optional :: ier public subroutine cdfw_0f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in) :: varval integer, intent(out), optional :: ier public subroutine cdfw_0c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in) :: varval integer, intent(out), optional :: ier public subroutine cdfDefVar (ncid, varnam, dimlens, xtype, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in), dimension(:) :: dimlens character(len=*), intent(in) :: xtype integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_3i (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_2i (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_1i (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in), dimension(:) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_0i (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_3l (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_2l (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_1l (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in), dimension(:) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_0l (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(in) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_3d (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_2d (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_1d (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_0d (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_3f (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_2f (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_1f (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_0f (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_3c16 (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_2c16 (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_1c16 (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_0c16 (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(in) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_3c8 (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in), dimension(:, :, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_2c8 (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in), dimension(:, :) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_1c8 (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_0c8 (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(in) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_2c (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(in), dimension(:) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname public subroutine cdfd_1c (ncid, varnam, varval, ier, dimname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(in) :: varval integer, intent(out), optional :: ier character(len=*), intent(in), optional dimension(:) :: dimname","tags":"","loc":"module/ezcdf_genput.html"},{"title":"ezcdf_attrib â€“ stella","text":"Uses ezcdf_inqvar Contents Variables nf_byte nf_int1 nf_char nf_short nf_int2 nf_int nf_float nf_real nf_double nf_ubyte nf_ushort nf_uint nf_int64 nf_uint64 nf_fill_byte nf_fill_int1 nf_fill_char nf_fill_short nf_fill_int2 nf_fill_int nf_fill_float nf_fill_real nf_fill_double nf_nowrite nf_write nf_clobber nf_noclobber nf_fill nf_nofill nf_lock nf_share nf_64bit_offset nf_64bit_data nf_cdf5 nf_sizehint_default nf_align_chunk nf_format_classic nf_format_64bit nf_format_64bit_offset nf_format_64bit_data nf_format_cdf5 nf_diskless nf_mmap nf_unlimited nf_global nf_max_dims nf_max_attrs nf_max_vars nf_max_name nf_max_var_dims nf_noerr nf_ebadid nf_eexist nf_einval nf_eperm nf_enotindefine nf_eindefine nf_einvalcoords nf_emaxdims nf_enameinuse nf_enotatt nf_emaxatts nf_ebadtype nf_ebaddim nf_eunlimpos nf_emaxvars nf_enotvar nf_eglobal nf_enotnc nf_ests nf_emaxname nf_eunlimit nf_enorecvars nf_echar nf_eedge nf_estride nf_ebadname nf_erange nf_enomem nf_evarsize nf_edimsize nf_etrunc nf_fatal nf_verbose nf_string nf_vlen nf_opaque nf_enum nf_compound nf_fill_ubyte nf_fill_ushort nf_format_netcdf4 nf_format_netcdf4_classic nf_netcdf4 nf_classic_model nf_chunk_seq nf_chunk_sub nf_chunk_sizes nf_endian_native nf_endian_little nf_endian_big nf_chunked nf_contiguous nf_nochecksum nf_fletcher32 nf_noshuffle nf_shuffle nf_szip_ec_option_mask nf_szip_nn_option_mask nf_mpiio nf_mpiposix nf_pnetcdf nf_independent nf_collective nf_ehdferr nf_ecantread nf_ecantwrite nf_ecantcreate nf_efilemeta nf_edimmeta nf_eattmeta nf_evarmeta nf_enocompound nf_eattexists nf_enotnc4 nf_estrictnc3 nf_enotnc3 nf_enopar nf_eparinit nf_ebadgrpid nf_ebadtypid nf_etypdefined nf_ebadfield nf_ebadclass nf_emaptype nf_elatefill nf_elatedef nf_edimscale nf_enogrp ncrdwr nccreat ncexcl ncindef ncnsync nchsync ncndirty nchdirty nclink ncnowrit ncwrite ncclob ncnoclob ncglobal ncfill ncnofill maxncop maxncdim maxncatt maxncvar maxncnam maxvdims ncnoerr ncebadid ncenfile nceexist nceinval nceperm ncenotin nceindef ncecoord ncemaxds ncename ncenoatt ncemaxat ncebadty ncebadd ncests nceunlim ncemaxvs ncenotvr nceglob ncenotnc ncfoobar ncsyserr ncfatal ncverbos ncentool ncbyte ncchar ncshort nclong ncfloat ncdouble ncunlim filbyte filchar filshort fillong filfloat fildoub r4 r8 varnam_noalpha Interfaces cdf_setatt cdf_getatt Subroutines cdfSetatt cdf_SetTitle cdfsa_i cdfsa_f cdfsa_d cdfGetatt cdf_GetTitle cdfga_i cdfga_f cdfga_d Variables Type Visibility Attributes Name Initial integer, public, parameter :: nf_byte = 1 integer, public, parameter :: nf_int1 = nf_byte integer, public, parameter :: nf_char = 2 integer, public, parameter :: nf_short = 3 integer, public, parameter :: nf_int2 = nf_short integer, public, parameter :: nf_int = 4 integer, public, parameter :: nf_float = 5 integer, public, parameter :: nf_real = nf_float integer, public, parameter :: nf_double = 6 integer, public, parameter :: nf_ubyte = 7 integer, public, parameter :: nf_ushort = 8 integer, public, parameter :: nf_uint = 9 integer, public, parameter :: nf_int64 = 10 integer, public, parameter :: nf_uint64 = 11 integer, public, parameter :: nf_fill_byte = -127 integer, public, parameter :: nf_fill_int1 = nf_fill_byte integer, public, parameter :: nf_fill_char = 0 integer, public, parameter :: nf_fill_short = -32767 integer, public, parameter :: nf_fill_int2 = nf_fill_short integer, public, parameter :: nf_fill_int = -2147483647 real, public, parameter :: nf_fill_float = 9.9692099683868690e+36 real, public, parameter :: nf_fill_real = nf_fill_float doubleprecision, public, parameter :: nf_fill_double = 9.9692099683868690d+36 integer, public, parameter :: nf_nowrite = 0 integer, public, parameter :: nf_write = 1 integer, public, parameter :: nf_clobber = 0 integer, public, parameter :: nf_noclobber = 4 integer, public, parameter :: nf_fill = 0 integer, public, parameter :: nf_nofill = 256 integer, public, parameter :: nf_lock = 1024 integer, public, parameter :: nf_share = 2048 integer, public, parameter :: nf_64bit_offset = 512 integer, public, parameter :: nf_64bit_data = 32 integer, public, parameter :: nf_cdf5 = nf_64bit_data integer, public, parameter :: nf_sizehint_default = 0 integer, public, parameter :: nf_align_chunk = -1 integer, public, parameter :: nf_format_classic = 1 integer, public, parameter :: nf_format_64bit = 2 integer, public, parameter :: nf_format_64bit_offset = nf_format_64bit integer, public, parameter :: nf_format_64bit_data = 5 integer, public, parameter :: nf_format_cdf5 = nf_format_64bit_data integer, public, parameter :: nf_diskless = 8 integer, public, parameter :: nf_mmap = 16 integer, public, parameter :: nf_unlimited = 0 integer, public, parameter :: nf_global = 0 integer, public, parameter :: nf_max_dims = 1024 integer, public, parameter :: nf_max_attrs = 8192 integer, public, parameter :: nf_max_vars = 8192 integer, public, parameter :: nf_max_name = 256 integer, public, parameter :: nf_max_var_dims = nf_max_dims integer, public, parameter :: nf_noerr = 0 integer, public, parameter :: nf_ebadid = -33 integer, public, parameter :: nf_eexist = -35 integer, public, parameter :: nf_einval = -36 integer, public, parameter :: nf_eperm = -37 integer, public, parameter :: nf_enotindefine = -38 integer, public, parameter :: nf_eindefine = -39 integer, public, parameter :: nf_einvalcoords = -40 integer, public, parameter :: nf_emaxdims = -41 integer, public, parameter :: nf_enameinuse = -42 integer, public, parameter :: nf_enotatt = -43 integer, public, parameter :: nf_emaxatts = -44 integer, public, parameter :: nf_ebadtype = -45 integer, public, parameter :: nf_ebaddim = -46 integer, public, parameter :: nf_eunlimpos = -47 integer, public, parameter :: nf_emaxvars = -48 integer, public, parameter :: nf_enotvar = -49 integer, public, parameter :: nf_eglobal = -50 integer, public, parameter :: nf_enotnc = -51 integer, public, parameter :: nf_ests = -52 integer, public, parameter :: nf_emaxname = -53 integer, public, parameter :: nf_eunlimit = -54 integer, public, parameter :: nf_enorecvars = -55 integer, public, parameter :: nf_echar = -56 integer, public, parameter :: nf_eedge = -57 integer, public, parameter :: nf_estride = -58 integer, public, parameter :: nf_ebadname = -59 integer, public, parameter :: nf_erange = -60 integer, public, parameter :: nf_enomem = -61 integer, public, parameter :: nf_evarsize = -62 integer, public, parameter :: nf_edimsize = -63 integer, public, parameter :: nf_etrunc = -64 integer, public, parameter :: nf_fatal = 1 integer, public, parameter :: nf_verbose = 2 integer, public, parameter :: nf_string = 12 integer, public, parameter :: nf_vlen = 13 integer, public, parameter :: nf_opaque = 14 integer, public, parameter :: nf_enum = 15 integer, public, parameter :: nf_compound = 16 integer, public, parameter :: nf_fill_ubyte = 255 integer, public, parameter :: nf_fill_ushort = 65535 integer, public, parameter :: nf_format_netcdf4 = 3 integer, public, parameter :: nf_format_netcdf4_classic = 4 integer, public, parameter :: nf_netcdf4 = 4096 integer, public, parameter :: nf_classic_model = 256 integer, public, parameter :: nf_chunk_seq = 0 integer, public, parameter :: nf_chunk_sub = 1 integer, public, parameter :: nf_chunk_sizes = 2 integer, public, parameter :: nf_endian_native = 0 integer, public, parameter :: nf_endian_little = 1 integer, public, parameter :: nf_endian_big = 2 integer, public, parameter :: nf_chunked = 0 integer, public, parameter :: nf_contiguous = 1 integer, public, parameter :: nf_nochecksum = 0 integer, public, parameter :: nf_fletcher32 = 1 integer, public, parameter :: nf_noshuffle = 0 integer, public, parameter :: nf_shuffle = 1 integer, public, parameter :: nf_szip_ec_option_mask = 4 integer, public, parameter :: nf_szip_nn_option_mask = 32 integer, public, parameter :: nf_mpiio = 8192 integer, public, parameter :: nf_mpiposix = 16384 integer, public, parameter :: nf_pnetcdf = 32768 integer, public, parameter :: nf_independent = 0 integer, public, parameter :: nf_collective = 1 integer, public, parameter :: nf_ehdferr = -101 integer, public, parameter :: nf_ecantread = -102 integer, public, parameter :: nf_ecantwrite = -103 integer, public, parameter :: nf_ecantcreate = -104 integer, public, parameter :: nf_efilemeta = -105 integer, public, parameter :: nf_edimmeta = -106 integer, public, parameter :: nf_eattmeta = -107 integer, public, parameter :: nf_evarmeta = -108 integer, public, parameter :: nf_enocompound = -109 integer, public, parameter :: nf_eattexists = -110 integer, public, parameter :: nf_enotnc4 = -111 integer, public, parameter :: nf_estrictnc3 = -112 integer, public, parameter :: nf_enotnc3 = -113 integer, public, parameter :: nf_enopar = -114 integer, public, parameter :: nf_eparinit = -115 integer, public, parameter :: nf_ebadgrpid = -116 integer, public, parameter :: nf_ebadtypid = -117 integer, public, parameter :: nf_etypdefined = -118 integer, public, parameter :: nf_ebadfield = -119 integer, public, parameter :: nf_ebadclass = -120 integer, public, parameter :: nf_emaptype = -121 integer, public, parameter :: nf_elatefill = -122 integer, public, parameter :: nf_elatedef = -123 integer, public, parameter :: nf_edimscale = -124 integer, public, parameter :: nf_enogrp = -125 integer, public :: ncrdwr integer, public :: nccreat integer, public :: ncexcl integer, public :: ncindef integer, public :: ncnsync integer, public :: nchsync integer, public :: ncndirty integer, public :: nchdirty integer, public :: nclink integer, public :: ncnowrit integer, public :: ncwrite integer, public :: ncclob integer, public :: ncnoclob integer, public :: ncglobal integer, public :: ncfill integer, public :: ncnofill integer, public :: maxncop integer, public :: maxncdim integer, public :: maxncatt integer, public :: maxncvar integer, public :: maxncnam integer, public :: maxvdims integer, public :: ncnoerr integer, public :: ncebadid integer, public :: ncenfile integer, public :: nceexist integer, public :: nceinval integer, public :: nceperm integer, public :: ncenotin integer, public :: nceindef integer, public :: ncecoord integer, public :: ncemaxds integer, public :: ncename integer, public :: ncenoatt integer, public :: ncemaxat integer, public :: ncebadty integer, public :: ncebadd integer, public :: ncests integer, public :: nceunlim integer, public :: ncemaxvs integer, public :: ncenotvr integer, public :: nceglob integer, public :: ncenotnc integer, public :: ncfoobar integer, public :: ncsyserr integer, public :: ncfatal integer, public :: ncverbos integer, public, parameter :: ncentool = nf_emaxname integer, public :: ncbyte integer, public :: ncchar integer, public :: ncshort integer, public :: nclong integer, public :: ncfloat integer, public :: ncdouble integer, public :: ncunlim integer, public, parameter :: filbyte = -127 integer, public, parameter :: filchar = 0 integer, public, parameter :: filshort = -32767 integer, public, parameter :: fillong = -2147483647 real, public, parameter :: filfloat = 9.9692099683868690e+36 doubleprecision, public, parameter :: fildoub = 9.9692099683868690e+36 integer, private, parameter :: r4 = SELECTED_REAL_KIND(6, 37) integer, private, parameter :: r8 = SELECTED_REAL_KIND(12, 100) character(len=nf_max_name), private :: varnam_noalpha Interfaces public interface cdf_setatt public subroutine cdfSetatt (ncid, varnam, long_name, units, ier, varid) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(in), optional :: long_name character(len=*), intent(in), optional :: units integer, intent(out), optional :: ier integer, intent(out), optional :: varid public subroutine cdfsa_i (ncid, varnam, valid_range, long_name, units, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in), dimension(2) :: valid_range character(len=*), intent(in), optional :: long_name character(len=*), intent(in), optional :: units integer, intent(out), optional :: ier public subroutine cdfsa_d (ncid, varnam, valid_range, long_name, units, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in), dimension(2) :: valid_range character(len=*), intent(in), optional :: long_name character(len=*), intent(in), optional :: units integer, intent(out), optional :: ier public subroutine cdfsa_f (ncid, varnam, valid_range, long_name, units, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in), dimension(2) :: valid_range character(len=*), intent(in), optional :: long_name character(len=*), intent(in), optional :: units integer, intent(out), optional :: ier public interface cdf_getatt public subroutine cdfGetatt (ncid, varnam, long_name, units, ier, varid) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(out), optional :: long_name character(len=*), intent(out), optional :: units integer, intent(out), optional :: ier integer, intent(out), optional :: varid public subroutine cdfga_i (ncid, varnam, valid_range, long_name, units, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(out), dimension(2) :: valid_range character(len=*), intent(out), optional :: long_name character(len=*), intent(out), optional :: units integer, intent(out), optional :: ier public subroutine cdfga_d (ncid, varnam, valid_range, long_name, units, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(out), dimension(2) :: valid_range character(len=*), intent(out), optional :: long_name character(len=*), intent(out), optional :: units integer, intent(out), optional :: ier public subroutine cdfga_f (ncid, varnam, valid_range, long_name, units, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(out), dimension(2) :: valid_range character(len=*), intent(out), optional :: long_name character(len=*), intent(out), optional :: units integer, intent(out), optional :: ier Subroutines public subroutine cdfSetatt (ncid, varnam, long_name, units, ier, varid) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(in), optional :: long_name character(len=*), intent(in), optional :: units integer, intent(out), optional :: ier integer, intent(out), optional :: varid public subroutine cdf_SetTitle (ncid, title, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: title integer, intent(out), optional :: ier public subroutine cdfsa_i (ncid, varnam, valid_range, long_name, units, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(in), dimension(2) :: valid_range character(len=*), intent(in), optional :: long_name character(len=*), intent(in), optional :: units integer, intent(out), optional :: ier public subroutine cdfsa_f (ncid, varnam, valid_range, long_name, units, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(in), dimension(2) :: valid_range character(len=*), intent(in), optional :: long_name character(len=*), intent(in), optional :: units integer, intent(out), optional :: ier public subroutine cdfsa_d (ncid, varnam, valid_range, long_name, units, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(in), dimension(2) :: valid_range character(len=*), intent(in), optional :: long_name character(len=*), intent(in), optional :: units integer, intent(out), optional :: ier public subroutine cdfGetatt (ncid, varnam, long_name, units, ier, varid) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(out), optional :: long_name character(len=*), intent(out), optional :: units integer, intent(out), optional :: ier integer, intent(out), optional :: varid public subroutine cdf_GetTitle (ncid, title, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(out) :: title integer, intent(out), optional :: ier public subroutine cdfga_i (ncid, varnam, valid_range, long_name, units, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(out), dimension(2) :: valid_range character(len=*), intent(out), optional :: long_name character(len=*), intent(out), optional :: units integer, intent(out), optional :: ier public subroutine cdfga_f (ncid, varnam, valid_range, long_name, units, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(out), dimension(2) :: valid_range character(len=*), intent(out), optional :: long_name character(len=*), intent(out), optional :: units integer, intent(out), optional :: ier public subroutine cdfga_d (ncid, varnam, valid_range, long_name, units, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(out), dimension(2) :: valid_range character(len=*), intent(out), optional :: long_name character(len=*), intent(out), optional :: units integer, intent(out), optional :: ier","tags":"","loc":"module/ezcdf_attrib.html"},{"title":"ezcdf â€“ stella","text":"Uses ezcdf_attrib ezcdf_GenGet ezcdf_opncls ezcdf_GenPut Contents None","tags":"","loc":"module/ezcdf.html"},{"title":"vsvd0 â€“ stella","text":"Uses stel_kinds Contents Variables fturnon_axis fopt_axis isamecoil needit idontneed isymcoil ithom0 istark0 islope0 icurr0 idiam0 iflxs0 ibrzfld natur ideriv intder intfun nmse ntse nfloops nbsetsp nbcoilsp nbctotp jngrn jchix mstp jchix1 nparts npfcoil nigroup ipedsvd Variables Type Visibility Attributes Name Initial real(kind=rprec), public, parameter :: fturnon_axis = 3.e-9_dp real(kind=rprec), public, parameter :: fopt_axis = 3.e-2_dp*fturnon_axis integer, public, parameter :: isamecoil = -2 integer, public, parameter :: needit = -1 integer, public, parameter :: idontneed = 0 integer, public, parameter :: isymcoil = 1 integer, public, parameter :: ithom0 = 1 integer, public, parameter :: istark0 = 2 integer, public, parameter :: islope0 = 3 integer, public, parameter :: icurr0 = 4 integer, public, parameter :: idiam0 = 5 integer, public, parameter :: iflxs0 = 6 integer, public, parameter :: ibrzfld = 7 integer, public, parameter :: natur = 0 integer, public, parameter :: ideriv = 1 integer, public, parameter :: intder = 1 integer, public, parameter :: intfun = 2 integer, public, parameter :: nmse = 100 integer, public, parameter :: ntse = 100 integer, public, parameter :: nfloops = 100 integer, public, parameter :: nbsetsp = 5 integer, public, parameter :: nbcoilsp = 100 integer, public, parameter :: nbctotp = nbsetsp*nbcoilsp integer, public, parameter :: jngrn = 1001 integer, public, parameter :: jchix = 7 integer, public, parameter :: mstp = 100 integer, public, parameter :: jchix1 = jchix+1 integer, public, parameter :: nparts = 4 integer, public, parameter :: npfcoil = 40 integer, public, parameter :: nigroup = 100 integer, public, parameter :: ipedsvd = 8","tags":"","loc":"module/vsvd0.html"},{"title":"vparams â€“ stella","text":"Uses stel_kinds stel_constants Contents Variables nsd mpold ntord ndatafmax nstore_seq nthreed0 nmac0 indata0 nwout0 jxbout0 nfort8 nfort18 nlog0 nmercier0 nthreed nmac nlog mpol1d ntor1d c1pm2 cp15 cp25 cp5 c1pm8 cbig c2p0 c3p0 cp05 c1pm13 osqrt2 epstan dmu0 Variables Type Visibility Attributes Name Initial integer, public, parameter :: nsd = 10001 integer, public, parameter :: mpold = 101 integer, public, parameter :: ntord = 101 integer, public, parameter :: ndatafmax = 101 integer, public, parameter :: nstore_seq = 100 integer, public, parameter :: nthreed0 = 9 integer, public, parameter :: nmac0 = nthreed0+1 integer, public, parameter :: indata0 = nthreed0+2 integer, public, parameter :: nwout0 = nthreed0+3 integer, public, parameter :: jxbout0 = nthreed0+4 integer, public, parameter :: nfort8 = 8 integer, public, parameter :: nfort18 = 18 integer, public, parameter :: nlog0 = 51 integer, public, parameter :: nmercier0 = 52 integer, public :: nthreed integer, public :: nmac integer, public :: nlog = nlog0 integer, public, parameter :: mpol1d = mpold-1 integer, public, parameter :: ntor1d = 1+ntord real(kind=rprec), public, parameter :: c1pm2 = 1.e-2_dp real(kind=rprec), public, parameter :: cp15 = 0.15_dp real(kind=rprec), public, parameter :: cp25 = 0.25_dp real(kind=rprec), public, parameter :: cp5 = 0.50_dp real(kind=rprec), public, parameter :: c1pm8 = 1.0e-8_dp real(kind=rprec), public, parameter :: cbig = 0.9e30_dp real(kind=rprec), public, parameter :: c2p0 = 2 real(kind=rprec), public, parameter :: c3p0 = 3 real(kind=rprec), public, parameter :: cp05 = 0.05_dp real(kind=rprec), public, parameter :: c1pm13 = 1.0e-13_dp real(kind=rprec), public, parameter :: osqrt2 = 0.707106781186547462_dp real(kind=rprec), public, parameter :: epstan = EPSILON(zero) real(kind=rprec), public, parameter :: dmu0 = 2.0e-7_dp*twopi","tags":"","loc":"module/vparams.html"},{"title":"read_wout_mod â€“ stella","text":"Uses mgrid_mod stel_kinds vmec_input Contents Variables vn_version vn_extension vn_mgrid vn_magen vn_therm vn_gam vn_maxr vn_minr vn_maxz vn_fp vn_radnod vn_polmod vn_tormod vn_maxmod vn_maxit vn_actit vn_asym vn_recon vn_free vn_error vn_aspect vn_rfp vn_maxmod_nyq vn_beta vn_pbeta vn_tbeta vn_abeta vn_b0 vn_rbt0 vn_rbt1 vn_sgs vn_lar vn_modB vn_ctor vn_amin vn_Rmaj vn_vol vn_am vn_ai vn_ac vn_ah vn_atuname vn_pmass_type vn_piota_type vn_pcurr_type vn_am_aux_s vn_am_aux_f vn_ai_aux_s vn_ai_aux_f vn_ac_aux_s vn_ac_aux_f vn_mse vn_thom vn_pmod vn_tmod vn_pmod_nyq vn_tmod_nyq vn_racc vn_zacs vn_racs vn_zacc vn_iotaf vn_qfact vn_chi vn_chipf vn_presf vn_phi vn_phipf vn_jcuru vn_jcurv vn_iotah vn_mass vn_presh vn_betah vn_buco vn_bvco vn_vp vn_specw vn_phip vn_jdotb vn_overr vn_bgrv vn_merc vn_mshear vn_mwell vn_mcurr vn_mgeo vn_equif vn_fsq vn_wdot vn_ftolv vn_fsql vn_fsqr vn_fsqz vn_extcur vn_curlab vn_rmnc vn_zmns vn_lmns vn_gmnc vn_bmnc vn_bsubumnc vn_bsubvmnc vn_bsubsmns vn_bsupumnc vn_bsupvmnc vn_rmns vn_zmnc vn_lmnc vn_gmns vn_bmns vn_bsubumns vn_bsubvmns vn_bsubsmnc vn_bsupumns vn_bsupvmns vn_rbc vn_zbs vn_rbs vn_zbc vn_potvac vn_wpar vn_pparmnc vn_ppermnc vn_hotdmnc vn_pbprmnc vn_ppprmnc vn_sigmnc vn_taumnc vn_pparmns vn_ppermns vn_hotdmns vn_pbprmns vn_ppprmns vn_sigmns vn_taumns vn_machsq vn_protmnc vn_protrsqmnc vn_prprmnc vn_protmns vn_protrsqmns vn_prprmns vn_pmap vn_omega vn_tpotb ln_version ln_extension ln_mgrid ln_magen ln_therm ln_gam ln_maxr ln_minr ln_maxz ln_fp ln_radnod ln_polmod ln_tormod ln_maxmod ln_maxmod_nyq ln_maxit ln_actit ln_asym ln_recon ln_free ln_error ln_aspect ln_beta ln_pbeta ln_tbeta ln_abeta ln_b0 ln_rbt0 ln_rbt1 ln_sgs ln_lar ln_modB ln_ctor ln_amin ln_Rmaj ln_vol ln_mse ln_thom ln_am ln_ac ln_ai ln_pmass_type ln_pcurr_type ln_piota_type ln_am_aux_s ln_am_aux_f ln_ac_aux_s ln_ac_aux_f ln_ai_aux_s ln_ai_aux_f ln_pmod ln_tmod ln_pmod_nyq ln_tmod_nyq ln_racc ln_racs ln_zacs ln_zacc ln_iotaf ln_qfact ln_presf ln_phi ln_phipf ln_chi ln_chipf ln_jcuru ln_jcurv ln_iotah ln_mass ln_presh ln_betah ln_buco ln_bvco ln_vp ln_specw ln_phip ln_jdotb ln_bgrv ln_merc ln_mshear ln_mwell ln_mcurr ln_mgeo ln_equif ln_fsq ln_wdot ln_extcur ln_fsqr ln_fsqz ln_fsql ln_ftolv ln_curlab ln_rmnc ln_zmns ln_lmns ln_gmnc ln_bmnc ln_bsubumnc ln_bsubvmnc ln_bsubsmns ln_bsupumnc ln_bsupvmnc ln_rmns ln_zmnc ln_lmnc ln_gmns ln_bmns ln_bsubumns ln_bsubvmns ln_bsubsmnc ln_bsupumns ln_bsupvmns ln_rbc ln_zbs ln_rbs ln_zbc ln_potvac ln_wpar ln_pparmnc ln_ppermnc ln_hotdmnc ln_pbprmnc ln_ppprmnc ln_sigmnc ln_taumnc ln_pparmns ln_ppermns ln_hotdmns ln_pbprmns ln_ppprmns ln_sigmns ln_taumns ln_machsq ln_protmnc ln_protrsqmnc ln_prprmnc ln_protmns ln_protrsqmns ln_prprmns ln_pmap ln_omega ln_tpotb nfp ns mpol ntor mnmax mnmax_nyq itfsq niter iasym ireconstruct ierr_vmec imse itse nstore_seq isnodes ipnodes imatch_phiedge isigng mnyq nnyq ntmax vmec_type wb wp gamma pfac rmax_surf rmin_surf zmax_surf aspect betatot betapol betator betaxis b0 tswgt msewgt flmwgt bcwgt phidiam version_ delphid IonLarmor VolAvgB fsql fsqr fsqz ftolv Aminor Rmajor Volume RBtor RBtor0 Itor machsq rzl_local rmnc zmns lmns rmns zmnc lmnc bmnc gmnc bsubumnc bsubvmnc bsubsmns bsupumnc bsupvmnc currvmnc currumnc bbc raxis zaxis bmns gmns bsubumns bsubvmns bsubsmnc bsupumns bsupvmns currumns currvmns pparmnc ppermnc hotdmnc pbprmnc ppprmnc sigmnc taumnc iotas iotaf presf phipf mass pres beta_vol xm xn qfact chipf phi chi xm_nyq xn_nyq phip buco bvco vp overr jcuru jcurv specw jdotb bdotgradv fsqt wdot am ac ai am_aux_s am_aux_f ac_aux_s ac_aux_f ai_aux_s ai_aux_f Dmerc Dshear Dwell Dcurr Dgeod equif extcur sknots ystark y2stark pknots ythom y2thom anglemse rmid qmid shear presmid alfa curmid rstark qmeas datastark rthom datathom dsiobt potvac pmap omega tpotb lasym lthreed lwout_opened mgrid_file input_extension pmass_type pcurr_type piota_type norm_term_flag bad_jacobian_flag more_iter_flag jac75_flag Interfaces read_wout_file Subroutines readw_and_open readw_only read_wout_text read_wout_nc write_wout_text Compute_Currents read_wout_deallocate tosuvspace LoadRZL Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: vn_version = 'version_' character(len=*), public, parameter :: vn_extension = 'input_extension' character(len=*), public, parameter :: vn_mgrid = 'mgrid_file' character(len=*), public, parameter :: vn_magen = 'wb' character(len=*), public, parameter :: vn_therm = 'wp' character(len=*), public, parameter :: vn_gam = 'gamma' character(len=*), public, parameter :: vn_maxr = 'rmax_surf' character(len=*), public, parameter :: vn_minr = 'rmin_surf' character(len=*), public, parameter :: vn_maxz = 'zmax_surf' character(len=*), public, parameter :: vn_fp = 'nfp' character(len=*), public, parameter :: vn_radnod = 'ns' character(len=*), public, parameter :: vn_polmod = 'mpol' character(len=*), public, parameter :: vn_tormod = 'ntor' character(len=*), public, parameter :: vn_maxmod = 'mnmax' character(len=*), public, parameter :: vn_maxit = 'niter' character(len=*), public, parameter :: vn_actit = 'itfsq' character(len=*), public, parameter :: vn_asym = 'lasym' character(len=*), public, parameter :: vn_recon = 'lrecon' character(len=*), public, parameter :: vn_free = 'lfreeb' character(len=*), public, parameter :: vn_error = 'ier_flag' character(len=*), public, parameter :: vn_aspect = 'aspect' character(len=*), public, parameter :: vn_rfp = 'lrfp' character(len=*), public, parameter :: vn_maxmod_nyq = 'mnmax_nyq' character(len=*), public, parameter :: vn_beta = 'betatotal' character(len=*), public, parameter :: vn_pbeta = 'betapol' character(len=*), public, parameter :: vn_tbeta = 'betator' character(len=*), public, parameter :: vn_abeta = 'betaxis' character(len=*), public, parameter :: vn_b0 = 'b0' character(len=*), public, parameter :: vn_rbt0 = 'rbtor0' character(len=*), public, parameter :: vn_rbt1 = 'rbtor' character(len=*), public, parameter :: vn_sgs = 'signgs' character(len=*), public, parameter :: vn_lar = 'IonLarmor' character(len=*), public, parameter :: vn_modB = 'volavgB' character(len=*), public, parameter :: vn_ctor = 'ctor' character(len=*), public, parameter :: vn_amin = 'Aminor_p' character(len=*), public, parameter :: vn_Rmaj = 'Rmajor_p' character(len=*), public, parameter :: vn_vol = 'volume_p' character(len=*), public, parameter :: vn_am = 'am' character(len=*), public, parameter :: vn_ai = 'ai' character(len=*), public, parameter :: vn_ac = 'ac' character(len=*), public, parameter :: vn_ah = 'hot particle fraction' character(len=*), public, parameter :: vn_atuname = 'T-perp/T-par' character(len=*), public, parameter :: vn_pmass_type = 'pmass_type' character(len=*), public, parameter :: vn_piota_type = 'piota_type' character(len=*), public, parameter :: vn_pcurr_type = 'pcurr_type' character(len=*), public, parameter :: vn_am_aux_s = 'am_aux_s' character(len=*), public, parameter :: vn_am_aux_f = 'am_aux_f' character(len=*), public, parameter :: vn_ai_aux_s = 'ai_aux_s' character(len=*), public, parameter :: vn_ai_aux_f = 'ai_aux_f' character(len=*), public, parameter :: vn_ac_aux_s = 'ac_aux_s' character(len=*), public, parameter :: vn_ac_aux_f = 'ac_aux_f' character(len=*), public, parameter :: vn_mse = 'imse' character(len=*), public, parameter :: vn_thom = 'itse' character(len=*), public, parameter :: vn_pmod = 'xm' character(len=*), public, parameter :: vn_tmod = 'xn' character(len=*), public, parameter :: vn_pmod_nyq = 'xm_nyq' character(len=*), public, parameter :: vn_tmod_nyq = 'xn_nyq' character(len=*), public, parameter :: vn_racc = 'raxis_cc' character(len=*), public, parameter :: vn_zacs = 'zaxis_cs' character(len=*), public, parameter :: vn_racs = 'raxis_cs' character(len=*), public, parameter :: vn_zacc = 'zaxis_cc' character(len=*), public, parameter :: vn_iotaf = 'iotaf' character(len=*), public, parameter :: vn_qfact = 'q-factor' character(len=*), public, parameter :: vn_chi = 'chi' character(len=*), public, parameter :: vn_chipf = 'chipf' character(len=*), public, parameter :: vn_presf = 'presf' character(len=*), public, parameter :: vn_phi = 'phi' character(len=*), public, parameter :: vn_phipf = 'phipf' character(len=*), public, parameter :: vn_jcuru = 'jcuru' character(len=*), public, parameter :: vn_jcurv = 'jcurv' character(len=*), public, parameter :: vn_iotah = 'iotas' character(len=*), public, parameter :: vn_mass = 'mass' character(len=*), public, parameter :: vn_presh = 'pres' character(len=*), public, parameter :: vn_betah = 'beta_vol' character(len=*), public, parameter :: vn_buco = 'buco' character(len=*), public, parameter :: vn_bvco = 'bvco' character(len=*), public, parameter :: vn_vp = 'vp' character(len=*), public, parameter :: vn_specw = 'specw' character(len=*), public, parameter :: vn_phip = 'phips' character(len=*), public, parameter :: vn_jdotb = 'jdotb' character(len=*), public, parameter :: vn_overr = 'over_r' character(len=*), public, parameter :: vn_bgrv = 'bdotgradv' character(len=*), public, parameter :: vn_merc = 'DMerc' character(len=*), public, parameter :: vn_mshear = 'DShear' character(len=*), public, parameter :: vn_mwell = 'DWell' character(len=*), public, parameter :: vn_mcurr = 'DCurr' character(len=*), public, parameter :: vn_mgeo = 'DGeod' character(len=*), public, parameter :: vn_equif = 'equif' character(len=*), public, parameter :: vn_fsq = 'fsqt' character(len=*), public, parameter :: vn_wdot = 'wdot' character(len=*), public, parameter :: vn_ftolv = 'ftolv' character(len=*), public, parameter :: vn_fsql = 'fsql' character(len=*), public, parameter :: vn_fsqr = 'fsqr' character(len=*), public, parameter :: vn_fsqz = 'fsqz' character(len=*), public, parameter :: vn_extcur = 'extcur' character(len=*), public, parameter :: vn_curlab = 'curlabel' character(len=*), public, parameter :: vn_rmnc = 'rmnc' character(len=*), public, parameter :: vn_zmns = 'zmns' character(len=*), public, parameter :: vn_lmns = 'lmns' character(len=*), public, parameter :: vn_gmnc = 'gmnc' character(len=*), public, parameter :: vn_bmnc = 'bmnc' character(len=*), public, parameter :: vn_bsubumnc = 'bsubumnc' character(len=*), public, parameter :: vn_bsubvmnc = 'bsubvmnc' character(len=*), public, parameter :: vn_bsubsmns = 'bsubsmns' character(len=*), public, parameter :: vn_bsupumnc = 'bsupumnc' character(len=*), public, parameter :: vn_bsupvmnc = 'bsupvmnc' character(len=*), public, parameter :: vn_rmns = 'rmns' character(len=*), public, parameter :: vn_zmnc = 'zmnc' character(len=*), public, parameter :: vn_lmnc = 'lmnc' character(len=*), public, parameter :: vn_gmns = 'gmns' character(len=*), public, parameter :: vn_bmns = 'bmns' character(len=*), public, parameter :: vn_bsubumns = 'bsubumns' character(len=*), public, parameter :: vn_bsubvmns = 'bsubvmns' character(len=*), public, parameter :: vn_bsubsmnc = 'bsubsmnc' character(len=*), public, parameter :: vn_bsupumns = 'bsupumns' character(len=*), public, parameter :: vn_bsupvmns = 'bsupvmns' character(len=*), public, parameter :: vn_rbc = 'rbc' character(len=*), public, parameter :: vn_zbs = 'zbs' character(len=*), public, parameter :: vn_rbs = 'rbs' character(len=*), public, parameter :: vn_zbc = 'zbc' character(len=*), public, parameter :: vn_potvac = 'potvac' character(len=*), public, parameter :: vn_wpar = 'wpar' character(len=*), public, parameter :: vn_pparmnc = 'pparmnc' character(len=*), public, parameter :: vn_ppermnc = 'ppermnc' character(len=*), public, parameter :: vn_hotdmnc = 'hotdmnc' character(len=*), public, parameter :: vn_pbprmnc = 'pbprmnc' character(len=*), public, parameter :: vn_ppprmnc = 'ppprmnc' character(len=*), public, parameter :: vn_sigmnc = 'sigmnc' character(len=*), public, parameter :: vn_taumnc = 'taumnc' character(len=*), public, parameter :: vn_pparmns = 'pparmns' character(len=*), public, parameter :: vn_ppermns = 'ppermns' character(len=*), public, parameter :: vn_hotdmns = 'hotdmns' character(len=*), public, parameter :: vn_pbprmns = 'pbprmns' character(len=*), public, parameter :: vn_ppprmns = 'ppprmns' character(len=*), public, parameter :: vn_sigmns = 'sigmns' character(len=*), public, parameter :: vn_taumns = 'taumns' character(len=*), public, parameter :: vn_machsq = 'machsq' character(len=*), public, parameter :: vn_protmnc = 'protmnc' character(len=*), public, parameter :: vn_protrsqmnc = 'protrsqmnc' character(len=*), public, parameter :: vn_prprmnc = 'prprmnc' character(len=*), public, parameter :: vn_protmns = 'protmns' character(len=*), public, parameter :: vn_protrsqmns = 'protrsqmns' character(len=*), public, parameter :: vn_prprmns = 'prprmns' character(len=*), public, parameter :: vn_pmap = 'pmap' character(len=*), public, parameter :: vn_omega = 'omega' character(len=*), public, parameter :: vn_tpotb = 'tpotb' character(len=*), public, parameter :: ln_version = 'VMEC Version' character(len=*), public, parameter :: ln_extension = 'Input file extension' character(len=*), public, parameter :: ln_mgrid = 'MGRID file' character(len=*), public, parameter :: ln_magen = 'Magnetic Energy' character(len=*), public, parameter :: ln_therm = 'Thermal Energy' character(len=*), public, parameter :: ln_gam = 'Gamma' character(len=*), public, parameter :: ln_maxr = 'Maximum R' character(len=*), public, parameter :: ln_minr = 'Minimum R' character(len=*), public, parameter :: ln_maxz = 'Maximum Z' character(len=*), public, parameter :: ln_fp = 'Field Periods' character(len=*), public, parameter :: ln_radnod = 'Radial nodes' character(len=*), public, parameter :: ln_polmod = 'Poloidal modes' character(len=*), public, parameter :: ln_tormod = 'Toroidal modes' character(len=*), public, parameter :: ln_maxmod = 'Fourier modes' character(len=*), public, parameter :: ln_maxmod_nyq = 'Fourier modes (Nyquist)' character(len=*), public, parameter :: ln_maxit = 'Max iterations' character(len=*), public, parameter :: ln_actit = 'Actual iterations' character(len=*), public, parameter :: ln_asym = 'Asymmetry' character(len=*), public, parameter :: ln_recon = 'Reconstruction' character(len=*), public, parameter :: ln_free = 'Free boundary' character(len=*), public, parameter :: ln_error = 'Error flag' character(len=*), public, parameter :: ln_aspect = 'Aspect ratio' character(len=*), public, parameter :: ln_beta = 'Total beta' character(len=*), public, parameter :: ln_pbeta = 'Poloidal beta' character(len=*), public, parameter :: ln_tbeta = 'Toroidal beta' character(len=*), public, parameter :: ln_abeta = 'Beta axis' character(len=*), public, parameter :: ln_b0 = 'RB-t over R axis' character(len=*), public, parameter :: ln_rbt0 = 'RB-t axis' character(len=*), public, parameter :: ln_rbt1 = 'RB-t edge' character(len=*), public, parameter :: ln_sgs = 'Sign jacobian' character(len=*), public, parameter :: ln_lar = 'Ion Larmor radius' character(len=*), public, parameter :: ln_modB = 'avg mod B' character(len=*), public, parameter :: ln_ctor = 'Toroidal current' character(len=*), public, parameter :: ln_amin = 'minor radius' character(len=*), public, parameter :: ln_Rmaj = 'major radius' character(len=*), public, parameter :: ln_vol = 'Plasma volume' character(len=*), public, parameter :: ln_mse = 'Number of MSE points' character(len=*), public, parameter :: ln_thom = 'Number of Thompson scattering points' character(len=*), public, parameter :: ln_am = 'Specification parameters for mass(s)' character(len=*), public, parameter :: ln_ac = 'Specification parameters for (s)' character(len=*), public, parameter :: ln_ai = 'Specification parameters for iota(s)' character(len=*), public, parameter :: ln_pmass_type = 'Profile type specifier for mass(s)' character(len=*), public, parameter :: ln_pcurr_type = 'Profile type specifier for (s)' character(len=*), public, parameter :: ln_piota_type = 'Profile type specifier for iota(s)' character(len=*), public, parameter :: ln_am_aux_s = 'Auxiliary-s parameters for mass(s)' character(len=*), public, parameter :: ln_am_aux_f = 'Auxiliary-f parameters for mass(s)' character(len=*), public, parameter :: ln_ac_aux_s = 'Auxiliary-s parameters for (s)' character(len=*), public, parameter :: ln_ac_aux_f = 'Auxiliary-f parameters for (s)' character(len=*), public, parameter :: ln_ai_aux_s = 'Auxiliary-s parameters for iota(s)' character(len=*), public, parameter :: ln_ai_aux_f = 'Auxiliary-f parameters for iota(s)' character(len=*), public, parameter :: ln_pmod = 'Poloidal mode numbers' character(len=*), public, parameter :: ln_tmod = 'Toroidal mode numbers' character(len=*), public, parameter :: ln_pmod_nyq = 'Poloidal mode numbers (Nyquist)' character(len=*), public, parameter :: ln_tmod_nyq = 'Toroidal mode numbers (Nyquist)' character(len=*), public, parameter :: ln_racc = 'raxis (cosnv)' character(len=*), public, parameter :: ln_racs = 'raxis (sinnv)' character(len=*), public, parameter :: ln_zacs = 'zaxis (sinnv)' character(len=*), public, parameter :: ln_zacc = 'zaxis (cosnv)' character(len=*), public, parameter :: ln_iotaf = 'iota on full mesh' character(len=*), public, parameter :: ln_qfact = 'q-factor on full mesh' character(len=*), public, parameter :: ln_presf = 'pressure on full mesh' character(len=*), public, parameter :: ln_phi = 'Toroidal flux on full mesh' character(len=*), public, parameter :: ln_phipf = 'd(phi)/ds: Toroidal flux deriv on full mesh' character(len=*), public, parameter :: ln_chi = 'Poloidal flux on full mesh' character(len=*), public, parameter :: ln_chipf = 'd(chi)/ds: Poroidal flux deriv on full mesh' character(len=*), public, parameter :: ln_jcuru = 'j dot gradu full' character(len=*), public, parameter :: ln_jcurv = 'j dot gradv full' character(len=*), public, parameter :: ln_iotah = 'iota half' character(len=*), public, parameter :: ln_mass = 'mass half' character(len=*), public, parameter :: ln_presh = 'pressure half' character(len=*), public, parameter :: ln_betah = 'beta half' character(len=*), public, parameter :: ln_buco = 'bsubu half' character(len=*), public, parameter :: ln_bvco = 'bsubv half' character(len=*), public, parameter :: ln_vp = 'volume deriv half' character(len=*), public, parameter :: ln_specw = 'Spectral width half' character(len=*), public, parameter :: ln_phip = 'tor flux deriv over 2pi half' character(len=*), public, parameter :: ln_jdotb = 'J dot B' character(len=*), public, parameter :: ln_bgrv = 'B dot grad v' character(len=*), public, parameter :: ln_merc = 'Mercier criterion' character(len=*), public, parameter :: ln_mshear = 'Shear Mercier' character(len=*), public, parameter :: ln_mwell = 'Well Mercier' character(len=*), public, parameter :: ln_mcurr = 'Current Mercier' character(len=*), public, parameter :: ln_mgeo = 'Geodesic Mercier' character(len=*), public, parameter :: ln_equif = 'Average force balance' character(len=*), public, parameter :: ln_fsq = 'Residual decay' character(len=*), public, parameter :: ln_wdot = 'Wdot decay' character(len=*), public, parameter :: ln_extcur = 'External coil currents' character(len=*), public, parameter :: ln_fsqr = 'Residual decay - radial' character(len=*), public, parameter :: ln_fsqz = 'Residual decay - vertical' character(len=*), public, parameter :: ln_fsql = 'Residual decay - hoop' character(len=*), public, parameter :: ln_ftolv = 'Residual decay - requested' character(len=*), public, parameter :: ln_curlab = 'External current names' character(len=*), public, parameter :: ln_rmnc = 'cosmn component of cylindrical R, full mesh' character(len=*), public, parameter :: ln_zmns = 'sinmn component of cylindrical Z, full mesh' character(len=*), public, parameter :: ln_lmns = 'sinmn component of lambda, half mesh' character(len=*), public, parameter :: ln_gmnc = 'cosmn component of jacobian, half mesh' character(len=*), public, parameter :: ln_bmnc = 'cosmn component of mod-B, half mesh' character(len=*), public, parameter :: ln_bsubumnc = 'cosmn covariant u-component of B, half mesh' character(len=*), public, parameter :: ln_bsubvmnc = 'cosmn covariant v-component of B, half mesh' character(len=*), public, parameter :: ln_bsubsmns = 'sinmn covariant s-component of B, full mesh' character(len=*), public, parameter :: ln_bsupumnc = 'BSUPUmnc half' character(len=*), public, parameter :: ln_bsupvmnc = 'BSUPVmnc half' character(len=*), public, parameter :: ln_rmns = 'sinmn component of cylindrical R, full mesh' character(len=*), public, parameter :: ln_zmnc = 'cosmn component of cylindrical Z, full mesh' character(len=*), public, parameter :: ln_lmnc = 'cosmn component of lambda, half mesh' character(len=*), public, parameter :: ln_gmns = 'sinmn component of jacobian, half mesh' character(len=*), public, parameter :: ln_bmns = 'sinmn component of mod-B, half mesh' character(len=*), public, parameter :: ln_bsubumns = 'sinmn covariant u-component of B, half mesh' character(len=*), public, parameter :: ln_bsubvmns = 'sinmn covariant v-component of B, half mesh' character(len=*), public, parameter :: ln_bsubsmnc = 'cosmn covariant s-component of B, full mesh' character(len=*), public, parameter :: ln_bsupumns = 'BSUPUmns half' character(len=*), public, parameter :: ln_bsupvmns = 'BSUPVmns half' character(len=*), public, parameter :: ln_rbc = 'Initial boundary R cos(mu-nv) coefficients' character(len=*), public, parameter :: ln_zbs = 'Initial boundary Z sin(mu-nv) coefficients' character(len=*), public, parameter :: ln_rbs = 'Initial boundary R sin(mu-nv) coefficients' character(len=*), public, parameter :: ln_zbc = 'Initial boundary Z cos(mu-nv) coefficients' character(len=*), public, parameter :: ln_potvac = 'Vacuum Potential on Boundary' character(len=*), public, parameter :: ln_wpar = 'Energy' character(len=*), public, parameter :: ln_pparmnc = 'cosmn compoents of hot part. para. pressure' character(len=*), public, parameter :: ln_ppermnc = 'cosmn compoents of hot part. perp. pressure' character(len=*), public, parameter :: ln_hotdmnc = 'cosmn compoents of hot part. density' character(len=*), public, parameter :: ln_pbprmnc = 'cosmn compoents of hot part. para. pres. grad.' character(len=*), public, parameter :: ln_ppprmnc = 'cosmn compoents of hot part. perp. pres. grad.' character(len=*), public, parameter :: ln_sigmnc = 'cosmn firehose stability variable' character(len=*), public, parameter :: ln_taumnc = 'cosmn mirror stability variable' character(len=*), public, parameter :: ln_pparmns = 'sinmn compoents of hot part. para. pressure' character(len=*), public, parameter :: ln_ppermns = 'sinmn compoents of hot part. perp. pressure' character(len=*), public, parameter :: ln_hotdmns = 'sinmn compoents of hot part. density' character(len=*), public, parameter :: ln_pbprmns = 'sinmn compoents of hot part. para. pres. grad.' character(len=*), public, parameter :: ln_ppprmns = 'sinmn compoents of hot part. perp. pres. grad.' character(len=*), public, parameter :: ln_sigmns = 'sinmn firehose stability variable' character(len=*), public, parameter :: ln_taumns = 'sinmn mirror stability variable' character(len=*), public, parameter :: ln_machsq = 'Mach # on axis (squared)' character(len=*), public, parameter :: ln_protmnc = 'cosmn components of pressure' character(len=*), public, parameter :: ln_protrsqmnc = 'cosmn component of rotational energy' character(len=*), public, parameter :: ln_prprmnc = 'cosmn components of radial pressure gradient' character(len=*), public, parameter :: ln_protmns = 'sinmn components of pressure' character(len=*), public, parameter :: ln_protrsqmns = 'sinmn component of rotational energy' character(len=*), public, parameter :: ln_prprmns = 'sinmn components of radial pressure gradient' character(len=*), public, parameter :: ln_pmap = ' ' character(len=*), public, parameter :: ln_omega = 'Toroidal Angular Freq.' character(len=*), public, parameter :: ln_tpotb = 'T_perp/T_parallel or T(flow)' integer, public :: nfp integer, public :: ns integer, public :: mpol integer, public :: ntor integer, public :: mnmax integer, public :: mnmax_nyq integer, public :: itfsq integer, public :: niter integer, public :: iasym integer, public :: ireconstruct integer, public :: ierr_vmec integer, public :: imse integer, public :: itse integer, public :: nstore_seq integer, public :: isnodes integer, public :: ipnodes integer, public :: imatch_phiedge integer, public :: isigng integer, public :: mnyq integer, public :: nnyq integer, public :: ntmax integer, public :: vmec_type real(kind=rprec), public :: wb real(kind=rprec), public :: wp real(kind=rprec), public :: gamma real(kind=rprec), public :: pfac real(kind=rprec), public :: rmax_surf real(kind=rprec), public :: rmin_surf real(kind=rprec), public :: zmax_surf real(kind=rprec), public :: aspect real(kind=rprec), public :: betatot real(kind=rprec), public :: betapol real(kind=rprec), public :: betator real(kind=rprec), public :: betaxis real(kind=rprec), public :: b0 real(kind=rprec), public :: tswgt real(kind=rprec), public :: msewgt real(kind=rprec), public :: flmwgt real(kind=rprec), public :: bcwgt real(kind=rprec), public :: phidiam real(kind=rprec), public :: version_ real(kind=rprec), public :: delphid real(kind=rprec), public :: IonLarmor real(kind=rprec), public :: VolAvgB real(kind=rprec), public :: fsql real(kind=rprec), public :: fsqr real(kind=rprec), public :: fsqz real(kind=rprec), public :: ftolv real(kind=rprec), public :: Aminor real(kind=rprec), public :: Rmajor real(kind=rprec), public :: Volume real(kind=rprec), public :: RBtor real(kind=rprec), public :: RBtor0 real(kind=rprec), public :: Itor real(kind=rprec), public :: machsq real(kind=rprec), public, ALLOCATABLE :: rzl_local (:,:,:,:) real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: rmnc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: zmns real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: lmns real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: rmns real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: zmnc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: lmnc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: bmnc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: gmnc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: bsubumnc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: bsubvmnc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: bsubsmns real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: bsupumnc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: bsupvmnc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: currvmnc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: currumnc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: bbc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: raxis real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: zaxis real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: bmns real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: gmns real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: bsubumns real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: bsubvmns real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: bsubsmnc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: bsupumns real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: bsupvmns real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: currumns real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: currvmns real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: pparmnc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: ppermnc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: hotdmnc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: pbprmnc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: ppprmnc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: sigmnc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: taumnc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: iotas real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: iotaf real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: presf real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: phipf real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: mass real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: pres real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: beta_vol real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: xm real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: xn real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: qfact real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: chipf real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: phi real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: chi real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: xm_nyq real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: xn_nyq real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: phip real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: buco real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: bvco real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: vp real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: overr real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: jcuru real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: jcurv real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: specw real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: jdotb real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: bdotgradv real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: fsqt real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: wdot real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: am real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: ac real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: ai real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: am_aux_s real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: am_aux_f real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: ac_aux_s real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: ac_aux_f real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: ai_aux_s real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: ai_aux_f real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: Dmerc real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: Dshear real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: Dwell real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: Dcurr real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: Dgeod real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: equif real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: extcur real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: sknots real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: ystark real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: y2stark real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: pknots real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: ythom real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: y2thom real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: anglemse real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: rmid real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: qmid real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: shear real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: presmid real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: alfa real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: curmid real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: rstark real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: qmeas real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: datastark real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: rthom real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: datathom real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: dsiobt real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: potvac real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: pmap real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: omega real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: tpotb logical, public :: lasym logical, public :: lthreed logical, public :: lwout_opened = .false. character, public :: mgrid_file *200 character, public :: input_extension *100 character, public :: pmass_type *20 character, public :: pcurr_type *20 character, public :: piota_type *20 integer, private, parameter :: norm_term_flag = 0 integer, private, parameter :: bad_jacobian_flag = 1 integer, private, parameter :: more_iter_flag = 2 integer, private, parameter :: jac75_flag = 4 Interfaces public interface read_wout_file public subroutine readw_and_open (file_or_extension, ierr, iopen) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_or_extension integer, intent(out) :: ierr integer, optional :: iopen public subroutine readw_only (iunit, ierr, iopen) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iunit integer, intent(out) :: ierr integer, optional :: iopen Subroutines public subroutine readw_and_open (file_or_extension, ierr, iopen) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_or_extension integer, intent(out) :: ierr integer, optional :: iopen public subroutine readw_only (iunit, ierr, iopen) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iunit integer, intent(out) :: ierr integer, optional :: iopen private subroutine read_wout_text (iunit, ierr) Arguments Type Intent Optional Attributes Name integer :: iunit integer :: ierr private subroutine read_wout_nc (filename, ierr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer, intent(out) :: ierr public subroutine write_wout_text (filename, ierr) Arguments Type Intent Optional Attributes Name character(len=*) :: filename integer, intent(out) :: ierr public subroutine Compute_Currents (ierror) Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierror public subroutine read_wout_deallocate () Arguments None public subroutine tosuvspace (s_in, u_in, v_in, gsqrt, bsupu, bsupv, jsupu, jsupv, lam) Arguments Type Intent Optional Attributes Name real(kind=rprec), intent(in) :: s_in real(kind=rprec), intent(in) :: u_in real(kind=rprec), intent(in) :: v_in real(kind=rprec), intent(out), optional :: gsqrt real(kind=rprec), intent(out), optional :: bsupu real(kind=rprec), intent(out), optional :: bsupv real(kind=rprec), intent(out), optional :: jsupu real(kind=rprec), intent(out), optional :: jsupv real(kind=rprec), intent(out), optional :: lam public subroutine LoadRZL () Arguments None","tags":"","loc":"module/read_wout_mod.html"},{"title":"system_mod â€“ stella","text":"Contents Interfaces system chdir getenv putenv PXFFORK getpid PXFWAIT Interfaces public interface system public subroutine vmec_system(cmd, error) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cmd integer, optional :: error public interface chdir public function vmec_chdir(path) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path Return Value integer public interface getenv public subroutine vmec_getenv(ename, evalue) Arguments Type Intent Optional Attributes Name character(len=*) :: ename character(len=*) :: evalue public interface putenv public subroutine vmec_putenv(ename, evalue, ierror) Arguments Type Intent Optional Attributes Name character(len=*) :: ename character(len=*) :: evalue integer :: ierror public interface PXFFORK public subroutine pxffork_g(ipid, ierror) Arguments Type Intent Optional Attributes Name integer :: ipid integer :: ierror public interface getpid public subroutine vmec_getpid(ipid, ierror) Arguments Type Intent Optional Attributes Name integer :: ipid integer :: ierror public interface PXFWAIT public subroutine pxfwait_g(istat, iretpid, ierror) Arguments Type Intent Optional Attributes Name integer :: istat integer :: iretpid integer :: ierror","tags":"","loc":"module/system_mod.html"},{"title":"ezcdf_GenGet â€“ stella","text":"Uses ezcdf_opncls ezcdf_inqvar Contents Variables nf_byte nf_int1 nf_char nf_short nf_int2 nf_int nf_float nf_real nf_double nf_ubyte nf_ushort nf_uint nf_int64 nf_uint64 nf_fill_byte nf_fill_int1 nf_fill_char nf_fill_short nf_fill_int2 nf_fill_int nf_fill_float nf_fill_real nf_fill_double nf_nowrite nf_write nf_clobber nf_noclobber nf_fill nf_nofill nf_lock nf_share nf_64bit_offset nf_64bit_data nf_cdf5 nf_sizehint_default nf_align_chunk nf_format_classic nf_format_64bit nf_format_64bit_offset nf_format_64bit_data nf_format_cdf5 nf_diskless nf_mmap nf_unlimited nf_global nf_max_dims nf_max_attrs nf_max_vars nf_max_name nf_max_var_dims nf_noerr nf_ebadid nf_eexist nf_einval nf_eperm nf_enotindefine nf_eindefine nf_einvalcoords nf_emaxdims nf_enameinuse nf_enotatt nf_emaxatts nf_ebadtype nf_ebaddim nf_eunlimpos nf_emaxvars nf_enotvar nf_eglobal nf_enotnc nf_ests nf_emaxname nf_eunlimit nf_enorecvars nf_echar nf_eedge nf_estride nf_ebadname nf_erange nf_enomem nf_evarsize nf_edimsize nf_etrunc nf_fatal nf_verbose nf_string nf_vlen nf_opaque nf_enum nf_compound nf_fill_ubyte nf_fill_ushort nf_format_netcdf4 nf_format_netcdf4_classic nf_netcdf4 nf_classic_model nf_chunk_seq nf_chunk_sub nf_chunk_sizes nf_endian_native nf_endian_little nf_endian_big nf_chunked nf_contiguous nf_nochecksum nf_fletcher32 nf_noshuffle nf_shuffle nf_szip_ec_option_mask nf_szip_nn_option_mask nf_mpiio nf_mpiposix nf_pnetcdf nf_independent nf_collective nf_ehdferr nf_ecantread nf_ecantwrite nf_ecantcreate nf_efilemeta nf_edimmeta nf_eattmeta nf_evarmeta nf_enocompound nf_eattexists nf_enotnc4 nf_estrictnc3 nf_enotnc3 nf_enopar nf_eparinit nf_ebadgrpid nf_ebadtypid nf_etypdefined nf_ebadfield nf_ebadclass nf_emaptype nf_elatefill nf_elatedef nf_edimscale nf_enogrp ncrdwr nccreat ncexcl ncindef ncnsync nchsync ncndirty nchdirty nclink ncnowrit ncwrite ncclob ncnoclob ncglobal ncfill ncnofill maxncop maxncdim maxncatt maxncvar maxncnam maxvdims ncnoerr ncebadid ncenfile nceexist nceinval nceperm ncenotin nceindef ncecoord ncemaxds ncename ncenoatt ncemaxat ncebadty ncebadd ncests nceunlim ncemaxvs ncenotvr nceglob ncenotnc ncfoobar ncsyserr ncfatal ncverbos ncentool ncbyte ncchar ncshort nclong ncfloat ncdouble ncunlim filbyte filchar filshort fillong filfloat fildoub r4 r8 cmplx_name Interfaces cdf_read cdfGetVar Subroutines cdfr_3i cdfr_3l cdfr_3d cdfr_3c16 cdfr_3f cdfr_3c8 cdfr_2i cdfr_2l cdfr_2d cdfr_2c16 cdfr_2f cdfr_2c8 cdfr_2c cdfr_1i cdfr_1l cdfr_1d cdfr_1c16 cdfr_1f cdfr_1c8 cdfr_1c cdfr_0i cdfr_0l cdfr_0d cdfr_0c16 cdfr_0f cdfr_0c8 Variables Type Visibility Attributes Name Initial integer, private, parameter :: nf_byte = 1 integer, private, parameter :: nf_int1 = nf_byte integer, private, parameter :: nf_char = 2 integer, private, parameter :: nf_short = 3 integer, private, parameter :: nf_int2 = nf_short integer, private, parameter :: nf_int = 4 integer, private, parameter :: nf_float = 5 integer, private, parameter :: nf_real = nf_float integer, private, parameter :: nf_double = 6 integer, private, parameter :: nf_ubyte = 7 integer, private, parameter :: nf_ushort = 8 integer, private, parameter :: nf_uint = 9 integer, private, parameter :: nf_int64 = 10 integer, private, parameter :: nf_uint64 = 11 integer, private, parameter :: nf_fill_byte = -127 integer, private, parameter :: nf_fill_int1 = nf_fill_byte integer, private, parameter :: nf_fill_char = 0 integer, private, parameter :: nf_fill_short = -32767 integer, private, parameter :: nf_fill_int2 = nf_fill_short integer, private, parameter :: nf_fill_int = -2147483647 real, private, parameter :: nf_fill_float = 9.9692099683868690e+36 real, private, parameter :: nf_fill_real = nf_fill_float doubleprecision, private, parameter :: nf_fill_double = 9.9692099683868690d+36 integer, private, parameter :: nf_nowrite = 0 integer, private, parameter :: nf_write = 1 integer, private, parameter :: nf_clobber = 0 integer, private, parameter :: nf_noclobber = 4 integer, private, parameter :: nf_fill = 0 integer, private, parameter :: nf_nofill = 256 integer, private, parameter :: nf_lock = 1024 integer, private, parameter :: nf_share = 2048 integer, private, parameter :: nf_64bit_offset = 512 integer, private, parameter :: nf_64bit_data = 32 integer, private, parameter :: nf_cdf5 = nf_64bit_data integer, private, parameter :: nf_sizehint_default = 0 integer, private, parameter :: nf_align_chunk = -1 integer, private, parameter :: nf_format_classic = 1 integer, private, parameter :: nf_format_64bit = 2 integer, private, parameter :: nf_format_64bit_offset = nf_format_64bit integer, private, parameter :: nf_format_64bit_data = 5 integer, private, parameter :: nf_format_cdf5 = nf_format_64bit_data integer, private, parameter :: nf_diskless = 8 integer, private, parameter :: nf_mmap = 16 integer, private, parameter :: nf_unlimited = 0 integer, private, parameter :: nf_global = 0 integer, private, parameter :: nf_max_dims = 1024 integer, private, parameter :: nf_max_attrs = 8192 integer, private, parameter :: nf_max_vars = 8192 integer, private, parameter :: nf_max_name = 256 integer, private, parameter :: nf_max_var_dims = nf_max_dims integer, private, parameter :: nf_noerr = 0 integer, private, parameter :: nf_ebadid = -33 integer, private, parameter :: nf_eexist = -35 integer, private, parameter :: nf_einval = -36 integer, private, parameter :: nf_eperm = -37 integer, private, parameter :: nf_enotindefine = -38 integer, private, parameter :: nf_eindefine = -39 integer, private, parameter :: nf_einvalcoords = -40 integer, private, parameter :: nf_emaxdims = -41 integer, private, parameter :: nf_enameinuse = -42 integer, private, parameter :: nf_enotatt = -43 integer, private, parameter :: nf_emaxatts = -44 integer, private, parameter :: nf_ebadtype = -45 integer, private, parameter :: nf_ebaddim = -46 integer, private, parameter :: nf_eunlimpos = -47 integer, private, parameter :: nf_emaxvars = -48 integer, private, parameter :: nf_enotvar = -49 integer, private, parameter :: nf_eglobal = -50 integer, private, parameter :: nf_enotnc = -51 integer, private, parameter :: nf_ests = -52 integer, private, parameter :: nf_emaxname = -53 integer, private, parameter :: nf_eunlimit = -54 integer, private, parameter :: nf_enorecvars = -55 integer, private, parameter :: nf_echar = -56 integer, private, parameter :: nf_eedge = -57 integer, private, parameter :: nf_estride = -58 integer, private, parameter :: nf_ebadname = -59 integer, private, parameter :: nf_erange = -60 integer, private, parameter :: nf_enomem = -61 integer, private, parameter :: nf_evarsize = -62 integer, private, parameter :: nf_edimsize = -63 integer, private, parameter :: nf_etrunc = -64 integer, private, parameter :: nf_fatal = 1 integer, private, parameter :: nf_verbose = 2 integer, private, parameter :: nf_string = 12 integer, private, parameter :: nf_vlen = 13 integer, private, parameter :: nf_opaque = 14 integer, private, parameter :: nf_enum = 15 integer, private, parameter :: nf_compound = 16 integer, private, parameter :: nf_fill_ubyte = 255 integer, private, parameter :: nf_fill_ushort = 65535 integer, private, parameter :: nf_format_netcdf4 = 3 integer, private, parameter :: nf_format_netcdf4_classic = 4 integer, private, parameter :: nf_netcdf4 = 4096 integer, private, parameter :: nf_classic_model = 256 integer, private, parameter :: nf_chunk_seq = 0 integer, private, parameter :: nf_chunk_sub = 1 integer, private, parameter :: nf_chunk_sizes = 2 integer, private, parameter :: nf_endian_native = 0 integer, private, parameter :: nf_endian_little = 1 integer, private, parameter :: nf_endian_big = 2 integer, private, parameter :: nf_chunked = 0 integer, private, parameter :: nf_contiguous = 1 integer, private, parameter :: nf_nochecksum = 0 integer, private, parameter :: nf_fletcher32 = 1 integer, private, parameter :: nf_noshuffle = 0 integer, private, parameter :: nf_shuffle = 1 integer, private, parameter :: nf_szip_ec_option_mask = 4 integer, private, parameter :: nf_szip_nn_option_mask = 32 integer, private, parameter :: nf_mpiio = 8192 integer, private, parameter :: nf_mpiposix = 16384 integer, private, parameter :: nf_pnetcdf = 32768 integer, private, parameter :: nf_independent = 0 integer, private, parameter :: nf_collective = 1 integer, private, parameter :: nf_ehdferr = -101 integer, private, parameter :: nf_ecantread = -102 integer, private, parameter :: nf_ecantwrite = -103 integer, private, parameter :: nf_ecantcreate = -104 integer, private, parameter :: nf_efilemeta = -105 integer, private, parameter :: nf_edimmeta = -106 integer, private, parameter :: nf_eattmeta = -107 integer, private, parameter :: nf_evarmeta = -108 integer, private, parameter :: nf_enocompound = -109 integer, private, parameter :: nf_eattexists = -110 integer, private, parameter :: nf_enotnc4 = -111 integer, private, parameter :: nf_estrictnc3 = -112 integer, private, parameter :: nf_enotnc3 = -113 integer, private, parameter :: nf_enopar = -114 integer, private, parameter :: nf_eparinit = -115 integer, private, parameter :: nf_ebadgrpid = -116 integer, private, parameter :: nf_ebadtypid = -117 integer, private, parameter :: nf_etypdefined = -118 integer, private, parameter :: nf_ebadfield = -119 integer, private, parameter :: nf_ebadclass = -120 integer, private, parameter :: nf_emaptype = -121 integer, private, parameter :: nf_elatefill = -122 integer, private, parameter :: nf_elatedef = -123 integer, private, parameter :: nf_edimscale = -124 integer, private, parameter :: nf_enogrp = -125 integer, private :: ncrdwr integer, private :: nccreat integer, private :: ncexcl integer, private :: ncindef integer, private :: ncnsync integer, private :: nchsync integer, private :: ncndirty integer, private :: nchdirty integer, private :: nclink integer, private :: ncnowrit integer, private :: ncwrite integer, private :: ncclob integer, private :: ncnoclob integer, private :: ncglobal integer, private :: ncfill integer, private :: ncnofill integer, private :: maxncop integer, private :: maxncdim integer, private :: maxncatt integer, private :: maxncvar integer, private :: maxncnam integer, private :: maxvdims integer, private :: ncnoerr integer, private :: ncebadid integer, private :: ncenfile integer, private :: nceexist integer, private :: nceinval integer, private :: nceperm integer, private :: ncenotin integer, private :: nceindef integer, private :: ncecoord integer, private :: ncemaxds integer, private :: ncename integer, private :: ncenoatt integer, private :: ncemaxat integer, private :: ncebadty integer, private :: ncebadd integer, private :: ncests integer, private :: nceunlim integer, private :: ncemaxvs integer, private :: ncenotvr integer, private :: nceglob integer, private :: ncenotnc integer, private :: ncfoobar integer, private :: ncsyserr integer, private :: ncfatal integer, private :: ncverbos integer, private, parameter :: ncentool = nf_emaxname integer, private :: ncbyte integer, private :: ncchar integer, private :: ncshort integer, private :: nclong integer, private :: ncfloat integer, private :: ncdouble integer, private :: ncunlim integer, private, parameter :: filbyte = -127 integer, private, parameter :: filchar = 0 integer, private, parameter :: filshort = -32767 integer, private, parameter :: fillong = -2147483647 real, private, parameter :: filfloat = 9.9692099683868690e+36 doubleprecision, private, parameter :: fildoub = 9.9692099683868690e+36 integer, private, parameter :: r4 = SELECTED_REAL_KIND(6, 37) integer, private, parameter :: r8 = SELECTED_REAL_KIND(12, 100) character(len=*), private, parameter :: cmplx_name = '__CmPlx_Re_Im' Interfaces public interface cdf_read public subroutine cdfr_3i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_3l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_3d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_3c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_3f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_3c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_2i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_2l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_2d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_2c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_2f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_2c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_2c (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfr_1i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfr_1l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfr_1d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfr_1c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfr_1f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfr_1c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfr_1c (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(inout) :: varval integer, intent(out), optional :: ier public subroutine cdfr_0i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(out) :: varval integer, intent(out), optional :: ier public subroutine cdfr_0l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(out) :: varval integer, intent(out), optional :: ier public subroutine cdfr_0d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(out) :: varval integer, intent(out), optional :: ier public subroutine cdfr_0c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(out) :: varval integer, intent(out), optional :: ier public subroutine cdfr_0f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(out) :: varval integer, intent(out), optional :: ier public subroutine cdfr_0c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(out) :: varval integer, intent(out), optional :: ier public interface cdfGetVar public subroutine cdfr_3i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_3l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_3d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_3c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_3f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_3c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_2i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_2l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_2d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_2c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_2f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_2c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_2c (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfr_1i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfr_1l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfr_1d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfr_1c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfr_1f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfr_1c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfr_1c (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(inout) :: varval integer, intent(out), optional :: ier public subroutine cdfr_0i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(out) :: varval integer, intent(out), optional :: ier public subroutine cdfr_0l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(out) :: varval integer, intent(out), optional :: ier public subroutine cdfr_0d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(out) :: varval integer, intent(out), optional :: ier public subroutine cdfr_0c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(out) :: varval integer, intent(out), optional :: ier public subroutine cdfr_0f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(out) :: varval integer, intent(out), optional :: ier public subroutine cdfr_0c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(out) :: varval integer, intent(out), optional :: ier Subroutines public subroutine cdfr_3i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_3l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_3d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_3c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_3f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_3c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_2i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_2l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_2d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_2c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_2f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_2c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public subroutine cdfr_2c (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfr_1i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfr_1l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfr_1d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfr_1c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfr_1f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfr_1c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public subroutine cdfr_1c (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(inout) :: varval integer, intent(out), optional :: ier public subroutine cdfr_0i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(out) :: varval integer, intent(out), optional :: ier public subroutine cdfr_0l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(out) :: varval integer, intent(out), optional :: ier public subroutine cdfr_0d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(out) :: varval integer, intent(out), optional :: ier public subroutine cdfr_0c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(out) :: varval integer, intent(out), optional :: ier public subroutine cdfr_0f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(out) :: varval integer, intent(out), optional :: ier public subroutine cdfr_0c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(out) :: varval integer, intent(out), optional :: ier","tags":"","loc":"module/ezcdf_genget.html"},{"title":"ezcdf_inqvar â€“ stella","text":"Contents Variables nf_byte nf_int1 nf_char nf_short nf_int2 nf_int nf_float nf_real nf_double nf_ubyte nf_ushort nf_uint nf_int64 nf_uint64 nf_fill_byte nf_fill_int1 nf_fill_char nf_fill_short nf_fill_int2 nf_fill_int nf_fill_float nf_fill_real nf_fill_double nf_nowrite nf_write nf_clobber nf_noclobber nf_fill nf_nofill nf_lock nf_share nf_64bit_offset nf_64bit_data nf_cdf5 nf_sizehint_default nf_align_chunk nf_format_classic nf_format_64bit nf_format_64bit_offset nf_format_64bit_data nf_format_cdf5 nf_diskless nf_mmap nf_unlimited nf_global nf_max_dims nf_max_attrs nf_max_vars nf_max_name nf_max_var_dims nf_noerr nf_ebadid nf_eexist nf_einval nf_eperm nf_enotindefine nf_eindefine nf_einvalcoords nf_emaxdims nf_enameinuse nf_enotatt nf_emaxatts nf_ebadtype nf_ebaddim nf_eunlimpos nf_emaxvars nf_enotvar nf_eglobal nf_enotnc nf_ests nf_emaxname nf_eunlimit nf_enorecvars nf_echar nf_eedge nf_estride nf_ebadname nf_erange nf_enomem nf_evarsize nf_edimsize nf_etrunc nf_fatal nf_verbose nf_string nf_vlen nf_opaque nf_enum nf_compound nf_fill_ubyte nf_fill_ushort nf_format_netcdf4 nf_format_netcdf4_classic nf_netcdf4 nf_classic_model nf_chunk_seq nf_chunk_sub nf_chunk_sizes nf_endian_native nf_endian_little nf_endian_big nf_chunked nf_contiguous nf_nochecksum nf_fletcher32 nf_noshuffle nf_shuffle nf_szip_ec_option_mask nf_szip_nn_option_mask nf_mpiio nf_mpiposix nf_pnetcdf nf_independent nf_collective nf_ehdferr nf_ecantread nf_ecantwrite nf_ecantcreate nf_efilemeta nf_edimmeta nf_eattmeta nf_evarmeta nf_enocompound nf_eattexists nf_enotnc4 nf_estrictnc3 nf_enotnc3 nf_enopar nf_eparinit nf_ebadgrpid nf_ebadtypid nf_etypdefined nf_ebadfield nf_ebadclass nf_emaptype nf_elatefill nf_elatedef nf_edimscale nf_enogrp ncrdwr nccreat ncexcl ncindef ncnsync nchsync ncndirty nchdirty nclink ncnowrit ncwrite ncclob ncnoclob ncglobal ncfill ncnofill maxncop maxncdim maxncatt maxncvar maxncnam maxvdims ncnoerr ncebadid ncenfile nceexist nceinval nceperm ncenotin nceindef ncecoord ncemaxds ncename ncenoatt ncemaxat ncebadty ncebadd ncests nceunlim ncemaxvs ncenotvr nceglob ncenotnc ncfoobar ncsyserr ncfatal ncverbos ncentool ncbyte ncchar ncshort nclong ncfloat ncdouble ncunlim filbyte filchar filshort fillong filfloat fildoub varnam_noalpha Interfaces cdfInqVarDim Subroutines cdfInqVar cdfgv cdfInqV cdf_inquire alpha_numeric Variables Type Visibility Attributes Name Initial integer, private, parameter :: nf_byte = 1 integer, private, parameter :: nf_int1 = nf_byte integer, private, parameter :: nf_char = 2 integer, private, parameter :: nf_short = 3 integer, private, parameter :: nf_int2 = nf_short integer, private, parameter :: nf_int = 4 integer, private, parameter :: nf_float = 5 integer, private, parameter :: nf_real = nf_float integer, private, parameter :: nf_double = 6 integer, private, parameter :: nf_ubyte = 7 integer, private, parameter :: nf_ushort = 8 integer, private, parameter :: nf_uint = 9 integer, private, parameter :: nf_int64 = 10 integer, private, parameter :: nf_uint64 = 11 integer, private, parameter :: nf_fill_byte = -127 integer, private, parameter :: nf_fill_int1 = nf_fill_byte integer, private, parameter :: nf_fill_char = 0 integer, private, parameter :: nf_fill_short = -32767 integer, private, parameter :: nf_fill_int2 = nf_fill_short integer, private, parameter :: nf_fill_int = -2147483647 real, private, parameter :: nf_fill_float = 9.9692099683868690e+36 real, private, parameter :: nf_fill_real = nf_fill_float doubleprecision, private, parameter :: nf_fill_double = 9.9692099683868690d+36 integer, private, parameter :: nf_nowrite = 0 integer, private, parameter :: nf_write = 1 integer, private, parameter :: nf_clobber = 0 integer, private, parameter :: nf_noclobber = 4 integer, private, parameter :: nf_fill = 0 integer, private, parameter :: nf_nofill = 256 integer, private, parameter :: nf_lock = 1024 integer, private, parameter :: nf_share = 2048 integer, private, parameter :: nf_64bit_offset = 512 integer, private, parameter :: nf_64bit_data = 32 integer, private, parameter :: nf_cdf5 = nf_64bit_data integer, private, parameter :: nf_sizehint_default = 0 integer, private, parameter :: nf_align_chunk = -1 integer, private, parameter :: nf_format_classic = 1 integer, private, parameter :: nf_format_64bit = 2 integer, private, parameter :: nf_format_64bit_offset = nf_format_64bit integer, private, parameter :: nf_format_64bit_data = 5 integer, private, parameter :: nf_format_cdf5 = nf_format_64bit_data integer, private, parameter :: nf_diskless = 8 integer, private, parameter :: nf_mmap = 16 integer, private, parameter :: nf_unlimited = 0 integer, private, parameter :: nf_global = 0 integer, private, parameter :: nf_max_dims = 1024 integer, private, parameter :: nf_max_attrs = 8192 integer, private, parameter :: nf_max_vars = 8192 integer, private, parameter :: nf_max_name = 256 integer, private, parameter :: nf_max_var_dims = nf_max_dims integer, private, parameter :: nf_noerr = 0 integer, private, parameter :: nf_ebadid = -33 integer, private, parameter :: nf_eexist = -35 integer, private, parameter :: nf_einval = -36 integer, private, parameter :: nf_eperm = -37 integer, private, parameter :: nf_enotindefine = -38 integer, private, parameter :: nf_eindefine = -39 integer, private, parameter :: nf_einvalcoords = -40 integer, private, parameter :: nf_emaxdims = -41 integer, private, parameter :: nf_enameinuse = -42 integer, private, parameter :: nf_enotatt = -43 integer, private, parameter :: nf_emaxatts = -44 integer, private, parameter :: nf_ebadtype = -45 integer, private, parameter :: nf_ebaddim = -46 integer, private, parameter :: nf_eunlimpos = -47 integer, private, parameter :: nf_emaxvars = -48 integer, private, parameter :: nf_enotvar = -49 integer, private, parameter :: nf_eglobal = -50 integer, private, parameter :: nf_enotnc = -51 integer, private, parameter :: nf_ests = -52 integer, private, parameter :: nf_emaxname = -53 integer, private, parameter :: nf_eunlimit = -54 integer, private, parameter :: nf_enorecvars = -55 integer, private, parameter :: nf_echar = -56 integer, private, parameter :: nf_eedge = -57 integer, private, parameter :: nf_estride = -58 integer, private, parameter :: nf_ebadname = -59 integer, private, parameter :: nf_erange = -60 integer, private, parameter :: nf_enomem = -61 integer, private, parameter :: nf_evarsize = -62 integer, private, parameter :: nf_edimsize = -63 integer, private, parameter :: nf_etrunc = -64 integer, private, parameter :: nf_fatal = 1 integer, private, parameter :: nf_verbose = 2 integer, private, parameter :: nf_string = 12 integer, private, parameter :: nf_vlen = 13 integer, private, parameter :: nf_opaque = 14 integer, private, parameter :: nf_enum = 15 integer, private, parameter :: nf_compound = 16 integer, private, parameter :: nf_fill_ubyte = 255 integer, private, parameter :: nf_fill_ushort = 65535 integer, private, parameter :: nf_format_netcdf4 = 3 integer, private, parameter :: nf_format_netcdf4_classic = 4 integer, private, parameter :: nf_netcdf4 = 4096 integer, private, parameter :: nf_classic_model = 256 integer, private, parameter :: nf_chunk_seq = 0 integer, private, parameter :: nf_chunk_sub = 1 integer, private, parameter :: nf_chunk_sizes = 2 integer, private, parameter :: nf_endian_native = 0 integer, private, parameter :: nf_endian_little = 1 integer, private, parameter :: nf_endian_big = 2 integer, private, parameter :: nf_chunked = 0 integer, private, parameter :: nf_contiguous = 1 integer, private, parameter :: nf_nochecksum = 0 integer, private, parameter :: nf_fletcher32 = 1 integer, private, parameter :: nf_noshuffle = 0 integer, private, parameter :: nf_shuffle = 1 integer, private, parameter :: nf_szip_ec_option_mask = 4 integer, private, parameter :: nf_szip_nn_option_mask = 32 integer, private, parameter :: nf_mpiio = 8192 integer, private, parameter :: nf_mpiposix = 16384 integer, private, parameter :: nf_pnetcdf = 32768 integer, private, parameter :: nf_independent = 0 integer, private, parameter :: nf_collective = 1 integer, private, parameter :: nf_ehdferr = -101 integer, private, parameter :: nf_ecantread = -102 integer, private, parameter :: nf_ecantwrite = -103 integer, private, parameter :: nf_ecantcreate = -104 integer, private, parameter :: nf_efilemeta = -105 integer, private, parameter :: nf_edimmeta = -106 integer, private, parameter :: nf_eattmeta = -107 integer, private, parameter :: nf_evarmeta = -108 integer, private, parameter :: nf_enocompound = -109 integer, private, parameter :: nf_eattexists = -110 integer, private, parameter :: nf_enotnc4 = -111 integer, private, parameter :: nf_estrictnc3 = -112 integer, private, parameter :: nf_enotnc3 = -113 integer, private, parameter :: nf_enopar = -114 integer, private, parameter :: nf_eparinit = -115 integer, private, parameter :: nf_ebadgrpid = -116 integer, private, parameter :: nf_ebadtypid = -117 integer, private, parameter :: nf_etypdefined = -118 integer, private, parameter :: nf_ebadfield = -119 integer, private, parameter :: nf_ebadclass = -120 integer, private, parameter :: nf_emaptype = -121 integer, private, parameter :: nf_elatefill = -122 integer, private, parameter :: nf_elatedef = -123 integer, private, parameter :: nf_edimscale = -124 integer, private, parameter :: nf_enogrp = -125 integer, private :: ncrdwr integer, private :: nccreat integer, private :: ncexcl integer, private :: ncindef integer, private :: ncnsync integer, private :: nchsync integer, private :: ncndirty integer, private :: nchdirty integer, private :: nclink integer, private :: ncnowrit integer, private :: ncwrite integer, private :: ncclob integer, private :: ncnoclob integer, private :: ncglobal integer, private :: ncfill integer, private :: ncnofill integer, private :: maxncop integer, private :: maxncdim integer, private :: maxncatt integer, private :: maxncvar integer, private :: maxncnam integer, private :: maxvdims integer, private :: ncnoerr integer, private :: ncebadid integer, private :: ncenfile integer, private :: nceexist integer, private :: nceinval integer, private :: nceperm integer, private :: ncenotin integer, private :: nceindef integer, private :: ncecoord integer, private :: ncemaxds integer, private :: ncename integer, private :: ncenoatt integer, private :: ncemaxat integer, private :: ncebadty integer, private :: ncebadd integer, private :: ncests integer, private :: nceunlim integer, private :: ncemaxvs integer, private :: ncenotvr integer, private :: nceglob integer, private :: ncenotnc integer, private :: ncfoobar integer, private :: ncsyserr integer, private :: ncfatal integer, private :: ncverbos integer, private, parameter :: ncentool = nf_emaxname integer, private :: ncbyte integer, private :: ncchar integer, private :: ncshort integer, private :: nclong integer, private :: ncfloat integer, private :: ncdouble integer, private :: ncunlim integer, private, parameter :: filbyte = -127 integer, private, parameter :: filchar = 0 integer, private, parameter :: filshort = -32767 integer, private, parameter :: fillong = -2147483647 real, private, parameter :: filfloat = 9.9692099683868690e+36 doubleprecision, private, parameter :: fildoub = 9.9692099683868690e+36 character(len=nf_max_name), private :: varnam_noalpha Interfaces public interface cdfInqVarDim public subroutine cdfInqV (ncid, varnam, varid, dimlens, ndims, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(out) :: varid integer, intent(out), dimension(:) :: dimlens integer, intent(out) :: ndims integer, intent(out) :: status public subroutine cdfgv (ncid, varnam, varid, dimlens, sizes, xtype, status) Arguments Type Intent Optional Attributes Name integer :: ncid character(len=*) :: varnam integer :: varid integer, dimension(:) :: dimlens integer, dimension(:) :: sizes character(len=1) :: xtype integer :: status public subroutine cdf_inquire (ncid, varnam, dimlens, xtype, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(out), dimension(:) :: dimlens character(len=*), intent(out), optional :: xtype integer, intent(out), optional :: ier Subroutines public subroutine cdfInqVar (ncid, varnam, dimlens, eztype, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(out), dimension(:) :: dimlens character(len=*), intent(out) :: eztype integer, intent(out), optional :: ier public subroutine cdfgv (ncid, varnam, varid, dimlens, sizes, xtype, status) Arguments Type Intent Optional Attributes Name integer :: ncid character(len=*) :: varnam integer :: varid integer, dimension(:) :: dimlens integer, dimension(:) :: sizes character(len=1) :: xtype integer :: status public subroutine cdfInqV (ncid, varnam, varid, dimlens, ndims, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(out) :: varid integer, intent(out), dimension(:) :: dimlens integer, intent(out) :: ndims integer, intent(out) :: status public subroutine cdf_inquire (ncid, varnam, dimlens, xtype, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(out), dimension(:) :: dimlens character(len=*), intent(out), optional :: xtype integer, intent(out), optional :: ier public subroutine alpha_numeric (string) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: string","tags":"","loc":"module/ezcdf_inqvar.html"},{"title":"v3_utilities â€“ stella","text":"SECTION I. Variable Declarations SECTION II. INTERFACE BLOCKS assert, with varying numbers of arguments SECTION III. Error Trapping SECTION IV.   Input-Output Utilities ------------------------------------------------------------------------------- Contents Variables rprec iprec cprec pi twopi one zero Interfaces assert assert_eq Subroutines assert1 assert2 assert3 assert4 assert_v assert_eq2 assert_eq3 assert_eq4 assert_eqn err_fatal err_warn svdproducts most_redundant Variables Type Visibility Attributes Name Initial integer, private, parameter :: rprec = SELECTED_REAL_KIND(12, 100) integer, private, parameter :: iprec = SELECTED_INT_KIND(8) integer, private, parameter :: cprec = KIND((1.0_rprec, 1.0_rprec)) real(kind=rprec), private, parameter :: pi = 3.14159265358979323846264338328_rprec real(kind=rprec), private, parameter :: twopi = 6.28318530717958647692528677_rprec real(kind=rprec), private, parameter :: one = 1.0_rprec real(kind=rprec), private, parameter :: zero = 0.0_rprec Interfaces public interface assert public subroutine assert1 (n1, string, err_class) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n1 character(len=*), intent(in) :: string character(len=*), intent(in), optional :: err_class public subroutine assert2 (n1, n2, string, err_class) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n1 logical, intent(in) :: n2 character(len=*), intent(in) :: string character(len=*), intent(in), optional :: err_class public subroutine assert3 (n1, n2, n3, string, err_class) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n1 logical, intent(in) :: n2 logical, intent(in) :: n3 character(len=*), intent(in) :: string character(len=*), intent(in), optional :: err_class public subroutine assert4 (n1, n2, n3, n4, string, err_class) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n1 logical, intent(in) :: n2 logical, intent(in) :: n3 logical, intent(in) :: n4 character(len=*), intent(in) :: string character(len=*), intent(in), optional :: err_class public subroutine assert_v (n, string, err_class) Arguments Type Intent Optional Attributes Name logical, intent(in), DIMENSION(:) :: n character(len=*), intent(in) :: string character(len=*), intent(in), optional :: err_class public interface assert_eq public subroutine assert_eq2 (n1, n2, string, err_class) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 character(len=*), intent(in) :: string character(len=*), intent(in), optional :: err_class public subroutine assert_eq3 (n1, n2, n3, string, err_class) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 character(len=*), intent(in) :: string character(len=*), intent(in), optional :: err_class public subroutine assert_eq4 (n1, n2, n3, n4, string, err_class) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: n4 character(len=*), intent(in) :: string character(len=*), intent(in), optional :: err_class public subroutine assert_eqn (nn, string, err_class) Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:) :: nn character(len=*), intent(in) :: string character(len=*), intent(in), optional :: err_class Subroutines public subroutine assert1 (n1, string, err_class) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n1 character(len=*), intent(in) :: string character(len=*), intent(in), optional :: err_class public subroutine assert2 (n1, n2, string, err_class) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n1 logical, intent(in) :: n2 character(len=*), intent(in) :: string character(len=*), intent(in), optional :: err_class public subroutine assert3 (n1, n2, n3, string, err_class) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n1 logical, intent(in) :: n2 logical, intent(in) :: n3 character(len=*), intent(in) :: string character(len=*), intent(in), optional :: err_class public subroutine assert4 (n1, n2, n3, n4, string, err_class) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n1 logical, intent(in) :: n2 logical, intent(in) :: n3 logical, intent(in) :: n4 character(len=*), intent(in) :: string character(len=*), intent(in), optional :: err_class public subroutine assert_v (n, string, err_class) Arguments Type Intent Optional Attributes Name logical, intent(in), DIMENSION(:) :: n character(len=*), intent(in) :: string character(len=*), intent(in), optional :: err_class public subroutine assert_eq2 (n1, n2, string, err_class) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 character(len=*), intent(in) :: string character(len=*), intent(in), optional :: err_class public subroutine assert_eq3 (n1, n2, n3, string, err_class) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 character(len=*), intent(in) :: string character(len=*), intent(in), optional :: err_class public subroutine assert_eq4 (n1, n2, n3, n4, string, err_class) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: n4 character(len=*), intent(in) :: string character(len=*), intent(in), optional :: err_class public subroutine assert_eqn (nn, string, err_class) Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:) :: nn character(len=*), intent(in) :: string character(len=*), intent(in), optional :: err_class public subroutine err_fatal (string, char, real1, int, log) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in), optional :: char real(kind=rprec), intent(in), optional :: real1 integer, intent(in), optional :: int logical, intent(in), optional :: log public subroutine err_warn (string, char, real, int, log) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in), optional :: char real(kind=rprec), intent(in), optional :: real integer, intent(in), optional :: int logical, intent(in), optional :: log public subroutine svdproducts (b, svprod, numzeros) Arguments Type Intent Optional Attributes Name real(kind=rprec), intent(inout), DIMENSION(:,:) :: b real(kind=rprec), intent(inout), DIMENSION(:) :: svprod integer, intent(inout), DIMENSION(:) :: numzeros public subroutine most_redundant (a, ncol_array, svprod_array, j_col_elim) Arguments Type Intent Optional Attributes Name real(kind=rprec), intent(inout), DIMENSION(:,:) :: a integer, intent(inout), DIMENSION(:) :: ncol_array real(kind=rprec), intent(inout), DIMENSION(:) :: svprod_array integer, intent(inout), DIMENSION(:) :: j_col_elim","tags":"","loc":"module/v3_utilities.html"},{"title":"stel_constants â€“ stella","text":"Uses stel_kinds Contents Variables pi pio2 twopi sqrt2 degree one zero mu0 Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: pi = 3.14159265358979323846264338328_dp real(kind=dp), public, parameter :: pio2 = pi/2 real(kind=dp), public, parameter :: twopi = 2*pi real(kind=dp), public, parameter :: sqrt2 = 1.41421356237309504880168872_dp real(kind=dp), public, parameter :: degree = twopi/360 real(kind=dp), public, parameter :: one = 1 real(kind=dp), public, parameter :: zero = 0 real(kind=dp), public, parameter :: mu0 = 2*twopi*1.0e-7_dp","tags":"","loc":"module/stel_constants.html"},{"title":"ezcdf_opncls â€“ stella","text":"Contents Interfaces cdfOpn cdf_open cdfCls cdf_close Subroutines ezcdf_open ezcdf_close Interfaces public interface cdfOpn public subroutine ezcdf_open (ncid, filename, opt, ier) Arguments Type Intent Optional Attributes Name integer, intent(out) :: ncid character(len=*), intent(in) :: filename character(len=1), intent(in) :: opt integer, intent(out), optional :: ier public interface cdf_open public subroutine ezcdf_open (ncid, filename, opt, ier) Arguments Type Intent Optional Attributes Name integer, intent(out) :: ncid character(len=*), intent(in) :: filename character(len=1), intent(in) :: opt integer, intent(out), optional :: ier public interface cdfCls public subroutine ezcdf_close (ncid, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(out), optional :: ier public interface cdf_close public subroutine ezcdf_close (ncid, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(out), optional :: ier Subroutines public subroutine ezcdf_open (ncid, filename, opt, ier) Arguments Type Intent Optional Attributes Name integer, intent(out) :: ncid character(len=*), intent(in) :: filename character(len=1), intent(in) :: opt integer, intent(out), optional :: ier public subroutine ezcdf_close (ncid, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(out), optional :: ier","tags":"","loc":"module/ezcdf_opncls.html"},{"title":"git_version â€“ stella","text":"Some helper functions for returning a git commit or tag compiled\ninto the binary. The implementations are in a submodule to avoid\nrecompilation cascades. Used by Descendants: git_version_impl Contents Interfaces get_git_version get_git_hash get_git_state get_git_date Interfaces interface public module module function get_git_version() Implementation â†’ Returns the git version from git describe Read moreâ€¦ Arguments None Return Value character,\n  allocatable interface public module module function get_git_hash(length_in) Implementation â†’ Returns the git hash of the current commit Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: length_in Return Value character,\n  allocatable interface public module module function get_git_state() Implementation â†’ Return \"-dirty\" if the repository has modifications to tracked\nfiles, or the empty string otherwise Arguments None Return Value character,\n  allocatable interface public module module function get_git_date() Implementation â†’ Returns the short date (YYYY-MM-DD) of the current commit Arguments None Return Value character(len=10)","tags":"","loc":"module/git_version.html"},{"title":"netcdf_utils â€“ stella","text":"Contents Variables kind_nf netcdf_real netcdf_int test Functions get_netcdf_code_precision Subroutines check_netcdf_file_precision netcdf_error Variables Type Visibility Attributes Name Initial integer, public, parameter :: kind_nf = kind(1) integer(kind=kind_nf), public :: netcdf_real = 0 integer(kind=kind_nf), public :: netcdf_int = 0 logical, private :: test = .false. Functions public function get_netcdf_code_precision () result(code_real) Arguments None Return Value integer Subroutines public subroutine check_netcdf_file_precision (ncid, filename) Arguments Type Intent Optional Attributes Name integer(kind=kind_nf), intent(in), optional :: ncid character, intent(in), optional :: filename public subroutine netcdf_error (istatus, ncid, varid, dimid, file, dim, var, att, message, abort) Arguments Type Intent Optional Attributes Name integer(kind=kind_nf), intent(in) :: istatus integer(kind=kind_nf), intent(in), optional :: ncid integer(kind=kind_nf), intent(in), optional :: varid integer(kind=kind_nf), intent(in), optional :: dimid character, intent(in), optional :: file character, intent(in), optional :: dim character, intent(in), optional :: var character, intent(in), optional :: att character, intent(in), optional :: message logical, intent(in), optional :: abort","tags":"","loc":"module/netcdf_utils.html"},{"title":"linear_solve â€“ stella","text":"Contents Interfaces lu_decomposition lu_back_substitution lu_inverse Functions imaxloc Subroutines lu_decomposition_real lu_decomposition_complex lu_back_substitution_real lu_back_substitution_real_complex lu_back_substitution_complex lu_back_substitution_matrix_real lu_back_substitution_matrix_complex lu_inverse_real lu_inverse_complex Interfaces public interface lu_decomposition public subroutine lu_decomposition_real (lu, idx, d) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :) :: lu integer, intent(out), dimension(:) :: idx real, intent(out) :: d public subroutine lu_decomposition_complex (lu, idx, d) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: lu integer, intent(out), dimension(:) :: idx real, intent(out) :: d public interface lu_back_substitution public subroutine lu_back_substitution_real (lu, idx, b) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx real, intent(inout), dimension(:) :: b public subroutine lu_back_substitution_real_complex (lu, idx, b) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx complex, intent(inout), dimension(:) :: b public subroutine lu_back_substitution_complex (lu, idx, b) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx complex, intent(inout), dimension(:) :: b public subroutine lu_back_substitution_matrix_real (lu, idx, b) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx real, intent(inout), dimension(:, :) :: b public subroutine lu_back_substitution_matrix_complex (lu, idx, b) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx complex, intent(inout), dimension(:, :) :: b public interface lu_inverse public subroutine lu_inverse_real (lu, idx, inverse) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx real, intent(out), dimension(:, :) :: inverse public subroutine lu_inverse_complex (lu, idx, inverse) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx complex, intent(out), dimension(:, :) :: inverse Functions public function imaxloc (array) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: array Return Value integer Subroutines public subroutine lu_decomposition_real (lu, idx, d) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :) :: lu integer, intent(out), dimension(:) :: idx real, intent(out) :: d public subroutine lu_decomposition_complex (lu, idx, d) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: lu integer, intent(out), dimension(:) :: idx real, intent(out) :: d public subroutine lu_back_substitution_real (lu, idx, b) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx real, intent(inout), dimension(:) :: b public subroutine lu_back_substitution_real_complex (lu, idx, b) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx complex, intent(inout), dimension(:) :: b public subroutine lu_back_substitution_complex (lu, idx, b) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx complex, intent(inout), dimension(:) :: b public subroutine lu_back_substitution_matrix_real (lu, idx, b) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx real, intent(inout), dimension(:, :) :: b public subroutine lu_back_substitution_matrix_complex (lu, idx, b) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx complex, intent(inout), dimension(:, :) :: b public subroutine lu_inverse_real (lu, idx, inverse) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx real, intent(out), dimension(:, :) :: inverse public subroutine lu_inverse_complex (lu, idx, inverse) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx complex, intent(out), dimension(:, :) :: inverse","tags":"","loc":"module/linear_solve.html"},{"title":"file_utils â€“ stella","text":"Contents Variables run_name arun_name job_name list_name stdout_unit runtype_option_switch runtype_standalone runtype_list runtype_trinity runtype_multibox input_unit_no error_unit_no num_input_lines Functions input_unit input_unit_exist error_unit Subroutines init_file_utils run_type init_run_name init_job_name get_unused_unit open_output_file close_output_file flush_output_file init_error_unit strip_comments init_input_unit finish_file_utils get_input_unit get_indexed_namelist_unit Variables Type Visibility Attributes Name Initial character(len=500), public, pointer :: run_name character(len=500), private, target :: arun_name character(len=500), private, target :: job_name character(len=500), public :: list_name integer, public, parameter :: stdout_unit = 6 integer, public :: runtype_option_switch integer, public, parameter :: runtype_standalone = 0 integer, public, parameter :: runtype_list = 1 integer, public, parameter :: runtype_trinity = 2 integer, public, parameter :: runtype_multibox = 3 integer, private, save :: input_unit_no integer, private, save :: error_unit_no = stdout_unit integer, public, save :: num_input_lines Functions public function input_unit (nml) Arguments Type Intent Optional Attributes Name character, intent(in) :: nml Return Value integer public function input_unit_exist (nml, exist) Arguments Type Intent Optional Attributes Name character, intent(in) :: nml logical, intent(out) :: exist Return Value integer public function error_unit () Arguments None Return Value integer Subroutines public subroutine init_file_utils (list, input, error, trin_run, name, n_ensembles) Arguments Type Intent Optional Attributes Name logical, intent(out) :: list logical, intent(in), optional :: input logical, intent(in), optional :: error logical, intent(in), optional :: trin_run character, intent(in), optional :: name integer, intent(in), optional :: n_ensembles private subroutine run_type (list) Arguments Type Intent Optional Attributes Name logical, intent(out) :: list private subroutine init_run_name () Arguments None public subroutine init_job_name (jobname) Arguments Type Intent Optional Attributes Name character(len=500), intent(in) :: jobname public subroutine get_unused_unit (unit) Arguments Type Intent Optional Attributes Name integer, intent(out) :: unit public subroutine open_output_file (unit, ext, overwrite_in) Arguments Type Intent Optional Attributes Name integer, intent(out) :: unit character, intent(in) :: ext logical, intent(in), optional :: overwrite_in public subroutine close_output_file (unit) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit public subroutine flush_output_file (unit) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit public subroutine init_error_unit (open_it) Arguments Type Intent Optional Attributes Name logical, intent(in) :: open_it private subroutine strip_comments (line) Arguments Type Intent Optional Attributes Name character, intent(inout) :: line public subroutine init_input_unit (open_it) Arguments Type Intent Optional Attributes Name logical, intent(in) :: open_it public subroutine finish_file_utils () Arguments None public subroutine get_input_unit (unit) Arguments Type Intent Optional Attributes Name integer, intent(out) :: unit public subroutine get_indexed_namelist_unit (unit, nml, index_in) Arguments Type Intent Optional Attributes Name integer, intent(out) :: unit character, intent(in) :: nml integer, intent(in) :: index_in","tags":"","loc":"module/file_utils.html"},{"title":"fft_work â€“ stella","text":"Uses constants Contents Variables FFTW_R2HC FFTW_HC2R FFTW_DHT FFTW_REDFT00 FFTW_REDFT01 FFTW_REDFT10 FFTW_REDFT11 FFTW_RODFT00 FFTW_RODFT01 FFTW_RODFT10 FFTW_RODFT11 FFTW_FORWARD FFTW_BACKWARD FFTW_MEASURE FFTW_DESTROY_INPUT FFTW_UNALIGNED FFTW_CONSERVE_MEMORY FFTW_EXHAUSTIVE FFTW_PRESERVE_INPUT FFTW_PATIENT FFTW_ESTIMATE FFTW_WISDOM_ONLY FFTW_ESTIMATE_PATIENT FFTW_BELIEVE_PCOST FFTW_NO_DFT_R2HC FFTW_NO_NONTHREADED FFTW_NO_BUFFERING FFTW_NO_INDIRECT_OP FFTW_ALLOW_LARGE_GENERIC FFTW_NO_RANK_SPLITS FFTW_NO_VRANK_SPLITS FFTW_NO_VRECURSE FFTW_NO_SIMD FFTW_NO_SLOW FFTW_NO_FIXED_RADIX_LARGE_N FFTW_ALLOW_PRUNING FFT_BACKWARD FFT_FORWARD Derived Types fft_type Subroutines init_ccfftw init_crfftw init_rcfftw delete_fft Variables Type Visibility Attributes Name Initial integer, public, parameter :: FFTW_R2HC = 0 integer, public, parameter :: FFTW_HC2R = 1 integer, public, parameter :: FFTW_DHT = 2 integer, public, parameter :: FFTW_REDFT00 = 3 integer, public, parameter :: FFTW_REDFT01 = 4 integer, public, parameter :: FFTW_REDFT10 = 5 integer, public, parameter :: FFTW_REDFT11 = 6 integer, public, parameter :: FFTW_RODFT00 = 7 integer, public, parameter :: FFTW_RODFT01 = 8 integer, public, parameter :: FFTW_RODFT10 = 9 integer, public, parameter :: FFTW_RODFT11 = 10 integer, public, parameter :: FFTW_FORWARD = -1 integer, public, parameter :: FFTW_BACKWARD = +1 integer, public, parameter :: FFTW_MEASURE = 0 integer, public, parameter :: FFTW_DESTROY_INPUT = 1 integer, public, parameter :: FFTW_UNALIGNED = 2 integer, public, parameter :: FFTW_CONSERVE_MEMORY = 4 integer, public, parameter :: FFTW_EXHAUSTIVE = 8 integer, public, parameter :: FFTW_PRESERVE_INPUT = 16 integer, public, parameter :: FFTW_PATIENT = 32 integer, public, parameter :: FFTW_ESTIMATE = 64 integer, public, parameter :: FFTW_WISDOM_ONLY = 2097152 integer, public, parameter :: FFTW_ESTIMATE_PATIENT = 128 integer, public, parameter :: FFTW_BELIEVE_PCOST = 256 integer, public, parameter :: FFTW_NO_DFT_R2HC = 512 integer, public, parameter :: FFTW_NO_NONTHREADED = 1024 integer, public, parameter :: FFTW_NO_BUFFERING = 2048 integer, public, parameter :: FFTW_NO_INDIRECT_OP = 4096 integer, public, parameter :: FFTW_ALLOW_LARGE_GENERIC = 8192 integer, public, parameter :: FFTW_NO_RANK_SPLITS = 16384 integer, public, parameter :: FFTW_NO_VRANK_SPLITS = 32768 integer, public, parameter :: FFTW_NO_VRECURSE = 65536 integer, public, parameter :: FFTW_NO_SIMD = 131072 integer, public, parameter :: FFTW_NO_SLOW = 262144 integer, public, parameter :: FFTW_NO_FIXED_RADIX_LARGE_N = 524288 integer, public, parameter :: FFTW_ALLOW_PRUNING = 1048576 integer, public, parameter :: FFT_BACKWARD = FFTW_BACKWARD integer, public, parameter :: FFT_FORWARD = FFTW_FORWARD Derived Types type, public :: fft_type Components Type Visibility Attributes Name Initial integer, private :: n integer, private :: is integer, private :: type integer(kind=kind_id), private :: plan real, private :: scale Subroutines public subroutine init_ccfftw (fft, is, n, data_in, data_out) Arguments Type Intent Optional Attributes Name type( fft_type ), intent(out) :: fft integer, intent(in) :: is integer, intent(in) :: n complex, intent(inout), dimension(:) :: data_in complex, intent(inout), dimension(:) :: data_out public subroutine init_crfftw (fft, is, n, data_in, data_out) Arguments Type Intent Optional Attributes Name type( fft_type ), intent(out) :: fft integer, intent(in) :: is integer, intent(in) :: n complex, intent(inout), dimension(:) :: data_in real, intent(inout), dimension(:) :: data_out public subroutine init_rcfftw (fft, is, n, data_in, data_out) Arguments Type Intent Optional Attributes Name type( fft_type ), intent(out) :: fft integer, intent(in) :: is integer, intent(in) :: n real, intent(inout), dimension(:) :: data_in complex, intent(inout), dimension(:) :: data_out public subroutine delete_fft (fft) Arguments Type Intent Optional Attributes Name type( fft_type ), intent(inout) :: fft","tags":"","loc":"module/fft_work.html"},{"title":"smooth_step â€“ stella","text":"Contents Functions smoothstep smoothstep0 smoothstep1 smoothstep2 smoothstepN pascalTriangle Functions public pure function smoothstep (x, N, minV, maxV) Arguments Type Intent Optional Attributes Name real, intent(in) :: x integer, intent(in) :: N real, intent(in), optional :: minV real, intent(in), optional :: maxV Return Value real public pure function smoothstep0 (x) Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value real public pure function smoothstep1 (x) Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value real public pure function smoothstep2 (x) Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value real public pure function smoothstepN (x, N) Arguments Type Intent Optional Attributes Name real, intent(in) :: x integer, intent(in) :: N Return Value real public pure function pascalTriangle (a, b) Arguments Type Intent Optional Attributes Name integer, intent(in) :: a integer, intent(in) :: b Return Value integer","tags":"","loc":"module/smooth_step.html"},{"title":"system_fortran â€“ stella","text":"Contents Subroutines systemf Subroutines public subroutine systemf (command) Arguments Type Intent Optional Attributes Name character, intent(in) :: command","tags":"","loc":"module/system_fortran.html"},{"title":"splines â€“ stella","text":"Contents Interfaces geo_spline Derived Types spline periodic_spline Functions fitp_curv2 fitp_curvd fitp_curvi fitp_curvp2 fitp_curvpd fitp_curvpi fitp_surf2 fitp_intrvl fitp_intrvp dedge Subroutines fitp_curv1 fitp_curvs fitp_curvp1 fitp_curvps fitp_kurv1 fitp_kurv2 fitp_kurvd fitp_kurvp1 fitp_kurvp2 fitp_kurvpd fitp_surf1 fitp_ceez fitp_curvpp fitp_curvss fitp_snhcsh fitp_terms geo_spline_real geo_spline_array linear_interp_periodic Interfaces public interface geo_spline public subroutine geo_spline_real (x, y, xint, yint) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: x real, intent(in), dimension(:) :: y real, intent(in) :: xint real, intent(out) :: yint public subroutine geo_spline_array (x, y, xint, yint) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: x real, intent(in), dimension(:) :: y real, intent(in), dimension(:) :: xint real, intent(out), dimension(:) :: yint Derived Types type, public :: spline Components Type Visibility Attributes Name Initial integer, public :: n real, public, dimension(:), pointer :: x real, public, dimension(:), pointer :: y real, public, dimension(:), pointer :: y2 type, public :: periodic_spline Components Type Visibility Attributes Name Initial integer, public :: n real, public :: period real, public, dimension(:), pointer :: x real, public, dimension(:), pointer :: y real, public, dimension(:), pointer :: y2 Functions public function fitp_curv2 (t, n, x, y, yp, sigma) Arguments Type Intent Optional Attributes Name real :: t integer :: n real :: x (n) real :: y (n) real :: yp (n) real :: sigma Return Value real public function fitp_curvd (t, n, x, y, yp, sigma) Arguments Type Intent Optional Attributes Name real :: t integer :: n real :: x (n) real :: y (n) real :: yp (n) real :: sigma Return Value real public function fitp_curvi (xl, xu, n, x, y, yp, sigma) Arguments Type Intent Optional Attributes Name real :: xl real :: xu integer :: n real :: x (n) real :: y (n) real :: yp (n) real :: sigma Return Value real public function fitp_curvp2 (t, n, x, y, p, yp, sigma) Arguments Type Intent Optional Attributes Name real :: t integer :: n real, dimension(:) :: x real, dimension(:) :: y real :: p real, dimension(:) :: yp real :: sigma Return Value real public function fitp_curvpd (t, n, x, y, p, yp, sigma) Arguments Type Intent Optional Attributes Name real :: t integer :: n real :: x (n) real :: y (n) real :: p real :: yp (n) real :: sigma Return Value real public function fitp_curvpi (xl, xu, n, x, y, p, yp, sigma) Arguments Type Intent Optional Attributes Name real :: xl real :: xu integer :: n real :: x (n) real :: y (n) real :: p real :: yp (n) real :: sigma Return Value real public function fitp_surf2 (xx, yy, m, n, x, y, z, iz, zp, sigma) Arguments Type Intent Optional Attributes Name real :: xx real :: yy integer :: m integer :: n real :: x (m) real :: y (n) real :: z (iz,n) integer :: iz real :: zp (m,n,3) real :: sigma Return Value real public function fitp_intrvl (t, x, n) Arguments Type Intent Optional Attributes Name real :: t real :: x (n) integer :: n Return Value integer public function fitp_intrvp (t, x, n, p, tp) Arguments Type Intent Optional Attributes Name real :: t real :: x (n) integer :: n real :: p real :: tp Return Value integer public function dedge (a, r, n, iside) Arguments Type Intent Optional Attributes Name real :: a (n) real :: r (n) integer :: n integer :: iside Return Value real Subroutines public subroutine fitp_curv1 (n, x, y, slp1, slpn, islpsw, yp, temp, sigma, ierr) Arguments Type Intent Optional Attributes Name integer :: n real :: x (n) real :: y (n) real :: slp1 real :: slpn integer :: islpsw real :: yp (n) real :: temp (n) real :: sigma integer :: ierr public subroutine fitp_curvs (n, x, y, d, isw, s, eps, ys, ysp, sigma, temp, ierr) Arguments Type Intent Optional Attributes Name integer :: n real :: x (n) real :: y (n) real :: d (n) integer :: isw real :: s real :: eps real :: ys (n) real :: ysp (n) real :: sigma real :: temp (n,9) integer :: ierr public subroutine fitp_curvp1 (n, x, y, p, yp, temp, sigma, ierr) Arguments Type Intent Optional Attributes Name integer :: n real, dimension(:) :: x real, dimension(:) :: y real :: p real, dimension(:) :: yp real, dimension(:) :: temp real :: sigma integer :: ierr public subroutine fitp_curvps (n, x, y, p, d, isw, s, eps, ys, ysp, sigma, temp, ierr) Arguments Type Intent Optional Attributes Name integer :: n real :: x (n) real :: y (n) real :: p real :: d (n) integer :: isw real :: s real :: eps real :: ys (n) real :: ysp (n) real :: sigma real :: temp (n,11) integer :: ierr public subroutine fitp_kurv1 (n, x, y, slp1, slpn, islpsw, xp, yp, temp, s, sigma, ierr) Arguments Type Intent Optional Attributes Name integer :: n real :: x (n) real :: y (n) real :: slp1 real :: slpn integer :: islpsw real :: xp (n) real :: yp (n) real :: temp (n) real :: s (n) real :: sigma integer :: ierr public subroutine fitp_kurv2 (t, xs, ys, n, x, y, xp, yp, s, sigma) Arguments Type Intent Optional Attributes Name real :: t real :: xs real :: ys integer :: n real :: x (n) real :: y (n) real :: xp (n) real :: yp (n) real :: s (n) real :: sigma public subroutine fitp_kurvd (t, xs, ys, xst, yst, xstt, ystt, n, x, y, xp, yp, s, sigma) Arguments Type Intent Optional Attributes Name real :: t real :: xs real :: ys real :: xst real :: yst real :: xstt real :: ystt integer :: n real :: x (n) real :: y (n) real :: xp (n) real :: yp (n) real :: s (n) real :: sigma public subroutine fitp_kurvp1 (n, x, y, xp, yp, temp, s, sigma, ierr) Arguments Type Intent Optional Attributes Name integer :: n real :: x (n) real :: y (n) real :: xp (n) real :: yp (n) real :: temp (1) real :: s (n) real :: sigma integer :: ierr public subroutine fitp_kurvp2 (t, xs, ys, n, x, y, xp, yp, s, sigma) Arguments Type Intent Optional Attributes Name real :: t real :: xs real :: ys integer :: n real :: x (n) real :: y (n) real :: xp (n) real :: yp (n) real :: s (n) real :: sigma public subroutine fitp_kurvpd (t, xs, ys, xst, yst, xstt, ystt, n, x, y, xp, yp, s, sigma) Arguments Type Intent Optional Attributes Name real :: t real :: xs real :: ys real :: xst real :: yst real :: xstt real :: ystt integer :: n real :: x (n) real :: y (n) real :: xp (n) real :: yp (n) real :: s (n) real :: sigma public subroutine fitp_surf1 (m, n, x, y, z, iz, zx1, zxm, zy1, zyn, zxy11, zxym1, zxy1n, zxymn, islpsw, zp, temp, sigma, ierr) Arguments Type Intent Optional Attributes Name integer :: m integer :: n real :: x (m) real :: y (n) real :: z (iz,n) integer :: iz real :: zx1 (n) real :: zxm (n) real :: zy1 (m) real :: zyn (m) real :: zxy11 real :: zxym1 real :: zxy1n real :: zxymn integer :: islpsw real :: zp (m,n,3) real :: temp (n+n+m) real :: sigma integer :: ierr public subroutine fitp_ceez (del1, del2, sigma, c1, c2, c3, n) Arguments Type Intent Optional Attributes Name real :: del1 real :: del2 real :: sigma real :: c1 real :: c2 real :: c3 integer :: n public subroutine fitp_curvpp (n, x, y, p, d, isw, s, eps, ys, ysp, sigma, td, tsd1, hd, hsd1, hsd2, rd, rsd1, rsd2, rnm1, rn, v, ierr) Arguments Type Intent Optional Attributes Name integer :: n real :: x (n) real :: y (n) real :: p real :: d (n) integer :: isw real :: s real :: eps real :: ys (n) real :: ysp (n) real :: sigma real :: td (n) real :: tsd1 (n) real :: hd (n) real :: hsd1 (n) real :: hsd2 (n) real :: rd (n) real :: rsd1 (n) real :: rsd2 (n) real :: rnm1 (n) real :: rn (n) real :: v (n) integer :: ierr public subroutine fitp_curvss (n, x, y, d, isw, s, eps, ys, ysp, sigma, td, tsd1, hd, hsd1, hsd2, rd, rsd1, rsd2, v, ierr) Arguments Type Intent Optional Attributes Name integer :: n real :: x (n) real :: y (n) real :: d (n) integer :: isw real :: s real :: eps real :: ys (n) real :: ysp (n) real :: sigma real :: td (n) real :: tsd1 (n) real :: hd (n) real :: hsd1 (n) real :: hsd2 (n) real :: rd (n) real :: rsd1 (n) real :: rsd2 (n) real :: v (n) integer :: ierr public subroutine fitp_snhcsh (sinhm, coshm, x, isw) Arguments Type Intent Optional Attributes Name real :: sinhm real :: coshm real :: x integer :: isw public subroutine fitp_terms (diag, sdiag, sigma, del) Arguments Type Intent Optional Attributes Name real :: diag real :: sdiag real :: sigma real :: del public subroutine geo_spline_real (x, y, xint, yint) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: x real, intent(in), dimension(:) :: y real, intent(in) :: xint real, intent(out) :: yint public subroutine geo_spline_array (x, y, xint, yint) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: x real, intent(in), dimension(:) :: y real, intent(in), dimension(:) :: xint real, intent(out), dimension(:) :: yint public subroutine linear_interp_periodic (x, y, xint, yint, period) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: x real, intent(in), dimension(:) :: y real, intent(in), dimension(:) :: xint real, intent(out), dimension(:) :: yint real, intent(in), optional :: period","tags":"","loc":"module/splines.html"},{"title":"sort â€“ stella","text":"Contents Subroutines sort_array_ascending unsort_array_ascending Subroutines public subroutine sort_array_ascending (array, sort_index) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: array integer, intent(out), dimension(:) :: sort_index public subroutine unsort_array_ascending (array, sort_index) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: array integer, intent(in), dimension(:) :: sort_index","tags":"","loc":"module/sort.html"},{"title":"convert â€“ stella","text":"Contents Interfaces c2r r2c Subroutines x5c2r x6c2r x5r2c x4c2r x4r2c x3c2r x3r2c x2c2r x2r2c x1c2r x1r2c Aborter Interfaces public interface c2r private subroutine x1c2r (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: a real, intent(out), dimension(:, :) :: a_ri private subroutine x2c2r (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: a real, intent(out), dimension(:, :, :) :: a_ri private subroutine x3c2r (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, :) :: a real, intent(out), dimension(:, :, :, :) :: a_ri private subroutine x4c2r (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, :, :) :: a real, intent(out), dimension(:, :, :, :, :) :: a_ri private subroutine x5c2r (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, :, :, :) :: a real, intent(out), dimension(:, :, :, :, :, :) :: a_ri private subroutine x6c2r (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, :, :, :, :) :: a real, intent(out), dimension(:, :, :, :, :, :, :) :: a_ri public interface r2c private subroutine x1r2c (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:) :: a real, intent(in), dimension(:, :) :: a_ri private subroutine x2r2c (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :) :: a real, intent(in), dimension(:, :, :) :: a_ri private subroutine x3r2c (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :, :) :: a real, intent(in), dimension(:, :, :, :) :: a_ri private subroutine x4r2c (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :, :, :) :: a real, intent(in), dimension(:, :, :, :, :) :: a_ri private subroutine x5r2c (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :, :, :, :) :: a real, intent(in), dimension(:, :, :, :, :, :) :: a_ri Subroutines private subroutine x5c2r (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, :, :, :) :: a real, intent(out), dimension(:, :, :, :, :, :) :: a_ri private subroutine x6c2r (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, :, :, :, :) :: a real, intent(out), dimension(:, :, :, :, :, :, :) :: a_ri private subroutine x5r2c (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :, :, :, :) :: a real, intent(in), dimension(:, :, :, :, :, :) :: a_ri private subroutine x4c2r (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, :, :) :: a real, intent(out), dimension(:, :, :, :, :) :: a_ri private subroutine x4r2c (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :, :, :) :: a real, intent(in), dimension(:, :, :, :, :) :: a_ri private subroutine x3c2r (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, :) :: a real, intent(out), dimension(:, :, :, :) :: a_ri private subroutine x3r2c (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :, :) :: a real, intent(in), dimension(:, :, :, :) :: a_ri private subroutine x2c2r (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: a real, intent(out), dimension(:, :, :) :: a_ri private subroutine x2r2c (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :) :: a real, intent(in), dimension(:, :, :) :: a_ri private subroutine x1c2r (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: a real, intent(out), dimension(:, :) :: a_ri private subroutine x1r2c (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:) :: a real, intent(in), dimension(:, :) :: a_ri private subroutine Aborter (iunit, ierrmsg) Arguments Type Intent Optional Attributes Name integer :: iunit character :: ierrmsg *(*)","tags":"","loc":"module/convert.html"},{"title":"spfunc â€“ stella","text":"Uses constants Contents None","tags":"","loc":"module/spfunc.html"},{"title":"gauss_quad â€“ stella","text":"Contents Variables debug weight_roundoff_correction qp Functions legendre_p legendre_pp laguerre_l laguerre_lp Subroutines get_legendre_grids_from_cheb find_zero_bisect_newton check_legendre_zero check_legendre_weights get_laguerre_grids find_zero check_laguerre_zeros check_laguerre_weights Variables Type Visibility Attributes Name Initial logical, private :: debug = .false. logical, private :: weight_roundoff_correction = .false. integer, private, parameter :: qp = selected_real_kind(33, 4931) Functions private elemental function legendre_p (n, x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision, intent(in) :: x Return Value double precision private elemental function legendre_pp (n, x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision, intent(in) :: x Return Value double precision private elemental function laguerre_l (n, x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=qp), intent(in) :: x Return Value real(kind=qp) private elemental function laguerre_lp (n, x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=qp), intent(in) :: x Return Value real(kind=qp) Subroutines public subroutine get_legendre_grids_from_cheb (x1, x2, zero, wgt) Arguments Type Intent Optional Attributes Name real, intent(in) :: x1 real, intent(in) :: x2 real, intent(out), dimension(:) :: zero real, intent(out), dimension(:) :: wgt private subroutine find_zero_bisect_newton (n, xold, xnew, pold, pnew, zz) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision, intent(in) :: xold double precision, intent(in) :: xnew double precision, intent(in) :: pold double precision, intent(in) :: pnew double precision, intent(out) :: zz private subroutine check_legendre_zero (x0, x1, zero) Arguments Type Intent Optional Attributes Name real, intent(in) :: x0 real, intent(in) :: x1 real, intent(in), dimension(:) :: zero private subroutine check_legendre_weights (norm, wgt) Arguments Type Intent Optional Attributes Name real, intent(in) :: norm real, intent(in), dimension(:) :: wgt public subroutine get_laguerre_grids (zero, wgt) Arguments Type Intent Optional Attributes Name real, intent(out), dimension(:) :: zero real, intent(out), dimension(:) :: wgt private subroutine find_zero (n, eps, xold, xnew, pold, pnew, zz) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision, intent(in) :: eps real(kind=qp), intent(in) :: xold real(kind=qp), intent(in) :: xnew real(kind=qp), intent(in) :: pold real(kind=qp), intent(in) :: pnew real(kind=qp), intent(out) :: zz private subroutine check_laguerre_zeros (zero) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: zero private subroutine check_laguerre_weights (wgt, eps) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: wgt real, intent(in) :: eps","tags":"","loc":"module/gauss_quad.html"},{"title":"constants â€“ stella","text":"Contents Variables kind_i1 kind_ih kind_is kind_id kind_rs kind_rd kind_rq zi dpi dtwopi pi twopi Variables Type Visibility Attributes Name Initial integer, private, parameter :: kind_i1 = selected_int_kind(2) integer, private, parameter :: kind_ih = selected_int_kind(4) integer, public, parameter :: kind_is = selected_int_kind(8) integer, public, parameter :: kind_id = selected_int_kind(15) integer, public, parameter :: kind_rs = selected_real_kind(p=6) integer, public, parameter :: kind_rd = selected_real_kind(p=12) integer, private, parameter :: kind_rq = selected_real_kind(p=24) complex, public, parameter :: zi = (0.0, 1.0) double precision, public, parameter :: dpi = 3.14159265358979323846264338327950288419716939938 double precision, public, parameter :: dtwopi = 2.*dpi real, public, parameter :: pi = dpi real, public, parameter :: twopi = dtwopi","tags":"","loc":"module/constants.html"},{"title":"command_line â€“ stella","text":"Contents Functions cl_iargc Subroutines cl_getarg Functions public function cl_iargc () Arguments None Return Value integer Subroutines public subroutine cl_getarg (k, arg, len, ierr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: k character(len=*), intent(out) :: arg integer, intent(out) :: len integer, intent(out) :: ierr","tags":"","loc":"module/command_line.html"},{"title":"mp_lu_decomposition â€“ stella","text":"Contents None","tags":"","loc":"module/mp_lu_decomposition.html"},{"title":"mp â€“ stella","text":"Contents Variables nproc iproc proc0 mp_info job mp_comm mpireal mpicmplx real_size allprocs sharedprocs subprocs crossdomprocs sharedsubprocs scrossdomprocs nbytes_real grp0 trin_flag Interfaces broadcast sum_reduce sum_allreduce max_reduce max_allreduce min_reduce min_allreduce send receive ssend all_to_group group_to_all Subroutines init_mp scope init_job_topology finish_mp broadcast_character broadcast_integer broadcast_integer_array broadcast_real broadcast_real_array broadcast_real_2array broadcast_real_3array broadcast_real_4array broadcast_real_5array broadcast_complex broadcast_complex_array broadcast_complex_2array broadcast_complex_3array broadcast_complex_4array broadcast_logical broadcast_logical_array bcastfrom_logical bcastfrom_logical_array bcastfrom_character bcastfrom_integer bcastfrom_integer_array bcastfrom_real bcastfrom_real_array bcastfrom_complex bcastfrom_complex_array bcastfrom_complex_2array sum_reduce_integer sum_reduce_integer_array sum_reduce_real sum_reduce_real_array sum_reduce_real_2array sum_reduce_real_3array sum_reduce_real_4array sum_reduce_real_5array sum_reduce_complex sum_reduce_complex_array sum_reduce_complex_2array sum_reduce_complex_3array sum_reduce_complex_4array sum_reduce_complex_5array sum_allreduce_integer sum_allreduce_integer_array sum_allreduce_integer_2array sum_allreduce_real sum_allreduce_real_array sum_allreduce_real_2array sum_allreduce_real_3array sum_allreduce_real_4array sum_allreduce_real_5array sum_allreduce_complex sum_allreduce_complex_array sum_allreduce_complex_2array sum_allreduce_complex_3array sum_allreduce_complex_4array sum_allreduce_complex_5array max_reduce_integer max_reduce_integer_array max_reduce_real max_reduce_real_array max_allreduce_integer max_allreduce_integer_array max_allreduce_real max_allreduce_real_array min_reduce_integer min_reduce_integer_array min_reduce_real min_reduce_real_array min_allreduce_integer min_allreduce_integer_array min_allreduce_real min_allreduce_real_array comm_split comm_free barrier send_integer send_integer_array send_real send_real_array send_real_array_2d send_complex send_complex_array nonblocking_send_complex_array send_logical send_logical_array send_character ssend_integer ssend_integer_array ssend_real ssend_real_array ssend_complex ssend_complex_array ssend_complex_2array ssend_logical ssend_logical_array receive_integer receive_integer_array receive_real receive_real_array receive_real_array_2d receive_complex receive_complex_array receive_complex_2array nonblocking_receive_complex_array receive_logical receive_logical_array receive_character waitany all_to_group_real all_to_group_real_array group_to_all_real group_to_all_real_array mp_abort error mp_gather broadcast_with_comm Variables Type Visibility Attributes Name Initial integer, public, parameter :: nproc = 1 integer, public, parameter :: iproc = 0 logical, public, parameter :: proc0 = .true. integer, public, parameter :: mp_info = -1 integer, public, parameter :: job = 0 integer, public, parameter :: mp_comm = -1 integer, public :: mpireal integer, public :: mpicmplx integer, public :: real_size integer, public, parameter :: allprocs = 0 integer, public, parameter :: sharedprocs = 1 integer, public, parameter :: subprocs = 2 integer, public, parameter :: crossdomprocs = 3 integer, public, parameter :: sharedsubprocs = 4 integer, public, parameter :: scrossdomprocs = 5 integer, public :: nbytes_real integer, private, dimension(:), allocatable :: grp0 logical, public :: trin_flag = .false. Interfaces public interface broadcast private subroutine broadcast_integer (i) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i private subroutine broadcast_integer_array (i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i private subroutine broadcast_real (x) Arguments Type Intent Optional Attributes Name real, intent(inout) :: x private subroutine broadcast_real_array (x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: x private subroutine broadcast_real_2array (x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :) :: x private subroutine broadcast_real_3array (x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :) :: x private subroutine broadcast_real_4array (x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :) :: x private subroutine broadcast_real_5array (x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :) :: x private subroutine broadcast_complex (z) Arguments Type Intent Optional Attributes Name complex, intent(inout) :: z private subroutine broadcast_complex_array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: z private subroutine broadcast_complex_2array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: z private subroutine broadcast_complex_3array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :) :: z private subroutine broadcast_complex_4array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :) :: z private subroutine broadcast_logical (f) Arguments Type Intent Optional Attributes Name logical, intent(inout) :: f private subroutine broadcast_logical_array (f) Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:) :: f private subroutine bcastfrom_integer (i, src) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i integer, intent(in) :: src private subroutine bcastfrom_integer_array (i, src) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i integer, intent(in) :: src private subroutine bcastfrom_real (x, src) Arguments Type Intent Optional Attributes Name real, intent(inout) :: x integer, intent(in) :: src private subroutine bcastfrom_real_array (x, src) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: x integer, intent(in) :: src private subroutine bcastfrom_complex (z, src) Arguments Type Intent Optional Attributes Name complex, intent(inout) :: z integer, intent(in) :: src private subroutine bcastfrom_complex_array (z, src) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: z integer, intent(in) :: src private subroutine bcastfrom_complex_2array (z, src) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: z integer, intent(in) :: src private subroutine bcastfrom_logical (f, src) Arguments Type Intent Optional Attributes Name logical, intent(inout) :: f integer, intent(in) :: src private subroutine bcastfrom_logical_array (f, src) Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:) :: f integer, intent(in) :: src private subroutine broadcast_character (char) Arguments Type Intent Optional Attributes Name character, intent(inout) :: char private subroutine bcastfrom_character (c, src) Arguments Type Intent Optional Attributes Name character, intent(inout) :: c integer, intent(in) :: src public interface sum_reduce private subroutine sum_reduce_integer (i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i integer, intent(in) :: dest private subroutine sum_reduce_integer_array (i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i integer, intent(in) :: dest private subroutine sum_reduce_real (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a integer, intent(in) :: dest private subroutine sum_reduce_real_array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a integer, intent(in) :: dest private subroutine sum_reduce_real_2array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :) :: a integer, intent(in) :: dest private subroutine sum_reduce_real_3array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :) :: a integer, intent(in) :: dest private subroutine sum_reduce_real_4array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :) :: a integer, intent(in) :: dest private subroutine sum_reduce_real_5array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :) :: a integer, intent(in) :: dest private subroutine sum_reduce_complex (z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout) :: z integer, intent(in) :: dest private subroutine sum_reduce_complex_array (z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: z integer, intent(in) :: dest private subroutine sum_reduce_complex_2array (z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: z integer, intent(in) :: dest private subroutine sum_reduce_complex_3array (z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :) :: z integer, intent(in) :: dest private subroutine sum_reduce_complex_4array (z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :) :: z integer, intent(in) :: dest private subroutine sum_reduce_complex_5array (z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :, :) :: z integer, intent(in) :: dest public interface sum_allreduce private subroutine sum_allreduce_integer (i) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i private subroutine sum_allreduce_integer_array (i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i private subroutine sum_allreduce_integer_2array (i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:, :) :: i private subroutine sum_allreduce_real (a) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a private subroutine sum_allreduce_real_array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a private subroutine sum_allreduce_real_2array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :) :: a private subroutine sum_allreduce_real_3array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :) :: a private subroutine sum_allreduce_real_4array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :) :: a private subroutine sum_allreduce_real_5array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :) :: a private subroutine sum_allreduce_complex (z) Arguments Type Intent Optional Attributes Name complex, intent(inout) :: z private subroutine sum_allreduce_complex_array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: z private subroutine sum_allreduce_complex_2array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: z private subroutine sum_allreduce_complex_3array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :) :: z private subroutine sum_allreduce_complex_4array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :) :: z private subroutine sum_allreduce_complex_5array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :, :) :: z public interface max_reduce private subroutine max_reduce_integer (i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i integer, intent(in) :: dest private subroutine max_reduce_integer_array (i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i integer, intent(in) :: dest private subroutine max_reduce_real (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a integer, intent(in) :: dest private subroutine max_reduce_real_array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a integer, intent(in) :: dest public interface max_allreduce private subroutine max_allreduce_integer (i) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i private subroutine max_allreduce_integer_array (i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i private subroutine max_allreduce_real (a) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a private subroutine max_allreduce_real_array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a public interface min_reduce private subroutine min_reduce_integer (i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i integer, intent(in) :: dest private subroutine min_reduce_integer_array (i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i integer, intent(in) :: dest private subroutine min_reduce_real (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a integer, intent(in) :: dest private subroutine min_reduce_real_array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a integer, intent(in) :: dest public interface min_allreduce private subroutine min_allreduce_integer (i) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i private subroutine min_allreduce_integer_array (i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i private subroutine min_allreduce_real (a) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a private subroutine min_allreduce_real_array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a public interface send private subroutine send_integer (i, dest, tag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine send_integer_array (i, dest, tag) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: i integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine send_real (a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine send_real_array (a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine send_real_array_2d (a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine send_complex (z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine send_complex_array (z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine nonblocking_send_complex_array (z, dest, tag, request) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag integer, intent(out) :: request private subroutine send_logical (f, dest, tag) Arguments Type Intent Optional Attributes Name logical, intent(in) :: f integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine send_logical_array (f, dest, tag) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:) :: f integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine send_character (s, dest, tag) Arguments Type Intent Optional Attributes Name character, intent(in) :: s integer, intent(in) :: dest integer, intent(in), optional :: tag public interface receive private subroutine receive_integer (i, src, tag) Arguments Type Intent Optional Attributes Name integer :: i integer, intent(in) :: src integer, intent(in), optional :: tag private subroutine receive_integer_array (i, src, tag) Arguments Type Intent Optional Attributes Name integer, dimension(:) :: i integer, intent(in) :: src integer, intent(in), optional :: tag private subroutine receive_real (a, src, tag) Arguments Type Intent Optional Attributes Name real :: a integer, intent(in) :: src integer, intent(in), optional :: tag private subroutine receive_real_array (a, src, tag) Arguments Type Intent Optional Attributes Name real, dimension(:) :: a integer, intent(in) :: src integer, intent(in), optional :: tag private subroutine receive_real_array_2d (a, src, tag) Arguments Type Intent Optional Attributes Name real, dimension(:, :) :: a integer, intent(in) :: src integer, intent(in), optional :: tag private subroutine receive_complex (z, src, tag) Arguments Type Intent Optional Attributes Name complex :: z integer, intent(in) :: src integer, intent(in), optional :: tag private subroutine receive_complex_array (z, src, tag) Arguments Type Intent Optional Attributes Name complex, dimension(:) :: z integer, intent(in) :: src integer, intent(in), optional :: tag private subroutine receive_complex_2array (z, src, tag) Arguments Type Intent Optional Attributes Name complex, dimension(:, :) :: z integer, intent(in) :: src integer, intent(in), optional :: tag private subroutine nonblocking_receive_complex_array (z, src, tag, request) Arguments Type Intent Optional Attributes Name complex, dimension(:) :: z integer, intent(in) :: src integer, intent(in), optional :: tag integer, intent(out) :: request private subroutine receive_logical (f, src, tag) Arguments Type Intent Optional Attributes Name logical :: f integer, intent(in) :: src integer, intent(in), optional :: tag private subroutine receive_logical_array (f, src, tag) Arguments Type Intent Optional Attributes Name logical, dimension(:) :: f integer, intent(in) :: src integer, intent(in), optional :: tag private subroutine receive_character (s, src, tag) Arguments Type Intent Optional Attributes Name character :: s integer, intent(in) :: src integer, intent(in), optional :: tag public interface ssend private subroutine ssend_integer (i, dest, tag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine ssend_integer_array (i, dest, tag) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: i integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine ssend_real (a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine ssend_real_array (a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine ssend_complex (z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine ssend_complex_array (z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine ssend_complex_2array (z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine ssend_logical (f, dest, tag) Arguments Type Intent Optional Attributes Name logical, intent(in) :: f integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine ssend_logical_array (f, dest, tag) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:) :: f integer, intent(in) :: dest integer, intent(in), optional :: tag public interface all_to_group private subroutine all_to_group_real (all, group, njobs) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: all real, intent(out) :: group integer, intent(in) :: njobs private subroutine all_to_group_real_array (all, group, njobs) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: all real, intent(out), dimension(:) :: group integer, intent(in) :: njobs public interface group_to_all private subroutine group_to_all_real (group, all, njobs) Arguments Type Intent Optional Attributes Name real, intent(in) :: group real, intent(out), dimension(:) :: all integer, intent(in) :: njobs private subroutine group_to_all_real_array (group, all, njobs) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: group real, intent(out), dimension(:, :) :: all integer, intent(in) :: njobs Subroutines public subroutine init_mp (comm_in) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: comm_in public subroutine scope (focus) Arguments Type Intent Optional Attributes Name integer, intent(in) :: focus public subroutine init_job_topology (ncolumns, group0, ierr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncolumns integer, intent(out), dimension(0:) :: group0 integer :: ierr public subroutine finish_mp () Arguments None private subroutine broadcast_character (char) Arguments Type Intent Optional Attributes Name character, intent(inout) :: char private subroutine broadcast_integer (i) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i private subroutine broadcast_integer_array (i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i private subroutine broadcast_real (x) Arguments Type Intent Optional Attributes Name real, intent(inout) :: x private subroutine broadcast_real_array (x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: x private subroutine broadcast_real_2array (x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :) :: x private subroutine broadcast_real_3array (x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :) :: x private subroutine broadcast_real_4array (x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :) :: x private subroutine broadcast_real_5array (x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :) :: x private subroutine broadcast_complex (z) Arguments Type Intent Optional Attributes Name complex, intent(inout) :: z private subroutine broadcast_complex_array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: z private subroutine broadcast_complex_2array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: z private subroutine broadcast_complex_3array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :) :: z private subroutine broadcast_complex_4array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :) :: z private subroutine broadcast_logical (f) Arguments Type Intent Optional Attributes Name logical, intent(inout) :: f private subroutine broadcast_logical_array (f) Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:) :: f private subroutine bcastfrom_logical (f, src) Arguments Type Intent Optional Attributes Name logical, intent(inout) :: f integer, intent(in) :: src private subroutine bcastfrom_logical_array (f, src) Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:) :: f integer, intent(in) :: src private subroutine bcastfrom_character (c, src) Arguments Type Intent Optional Attributes Name character, intent(inout) :: c integer, intent(in) :: src private subroutine bcastfrom_integer (i, src) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i integer, intent(in) :: src private subroutine bcastfrom_integer_array (i, src) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i integer, intent(in) :: src private subroutine bcastfrom_real (x, src) Arguments Type Intent Optional Attributes Name real, intent(inout) :: x integer, intent(in) :: src private subroutine bcastfrom_real_array (x, src) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: x integer, intent(in) :: src private subroutine bcastfrom_complex (z, src) Arguments Type Intent Optional Attributes Name complex, intent(inout) :: z integer, intent(in) :: src private subroutine bcastfrom_complex_array (z, src) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: z integer, intent(in) :: src private subroutine bcastfrom_complex_2array (z, src) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: z integer, intent(in) :: src private subroutine sum_reduce_integer (i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i integer, intent(in) :: dest private subroutine sum_reduce_integer_array (i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i integer, intent(in) :: dest private subroutine sum_reduce_real (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a integer, intent(in) :: dest private subroutine sum_reduce_real_array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a integer, intent(in) :: dest private subroutine sum_reduce_real_2array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :) :: a integer, intent(in) :: dest private subroutine sum_reduce_real_3array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :) :: a integer, intent(in) :: dest private subroutine sum_reduce_real_4array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :) :: a integer, intent(in) :: dest private subroutine sum_reduce_real_5array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :) :: a integer, intent(in) :: dest private subroutine sum_reduce_complex (z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout) :: z integer, intent(in) :: dest private subroutine sum_reduce_complex_array (z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: z integer, intent(in) :: dest private subroutine sum_reduce_complex_2array (z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: z integer, intent(in) :: dest private subroutine sum_reduce_complex_3array (z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :) :: z integer, intent(in) :: dest private subroutine sum_reduce_complex_4array (z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :) :: z integer, intent(in) :: dest private subroutine sum_reduce_complex_5array (z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :, :) :: z integer, intent(in) :: dest private subroutine sum_allreduce_integer (i) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i private subroutine sum_allreduce_integer_array (i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i private subroutine sum_allreduce_integer_2array (i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:, :) :: i private subroutine sum_allreduce_real (a) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a private subroutine sum_allreduce_real_array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a private subroutine sum_allreduce_real_2array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :) :: a private subroutine sum_allreduce_real_3array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :) :: a private subroutine sum_allreduce_real_4array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :) :: a private subroutine sum_allreduce_real_5array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :) :: a private subroutine sum_allreduce_complex (z) Arguments Type Intent Optional Attributes Name complex, intent(inout) :: z private subroutine sum_allreduce_complex_array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: z private subroutine sum_allreduce_complex_2array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: z private subroutine sum_allreduce_complex_3array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :) :: z private subroutine sum_allreduce_complex_4array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :) :: z private subroutine sum_allreduce_complex_5array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :, :) :: z private subroutine max_reduce_integer (i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i integer, intent(in) :: dest private subroutine max_reduce_integer_array (i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i integer, intent(in) :: dest private subroutine max_reduce_real (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a integer, intent(in) :: dest private subroutine max_reduce_real_array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a integer, intent(in) :: dest private subroutine max_allreduce_integer (i) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i private subroutine max_allreduce_integer_array (i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i private subroutine max_allreduce_real (a) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a private subroutine max_allreduce_real_array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a private subroutine min_reduce_integer (i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i integer, intent(in) :: dest private subroutine min_reduce_integer_array (i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i integer, intent(in) :: dest private subroutine min_reduce_real (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a integer, intent(in) :: dest private subroutine min_reduce_real_array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a integer, intent(in) :: dest private subroutine min_allreduce_integer (i) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i private subroutine min_allreduce_integer_array (i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i private subroutine min_allreduce_real (a) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a private subroutine min_allreduce_real_array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a public subroutine comm_split (color, comm_out, ierr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: color integer, intent(out) :: comm_out integer, intent(out) :: ierr public subroutine comm_free (comm_in, ierr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: comm_in integer, intent(out) :: ierr public subroutine barrier () Arguments None private subroutine send_integer (i, dest, tag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine send_integer_array (i, dest, tag) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: i integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine send_real (a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine send_real_array (a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine send_real_array_2d (a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine send_complex (z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine send_complex_array (z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine nonblocking_send_complex_array (z, dest, tag, request) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag integer, intent(out) :: request private subroutine send_logical (f, dest, tag) Arguments Type Intent Optional Attributes Name logical, intent(in) :: f integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine send_logical_array (f, dest, tag) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:) :: f integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine send_character (s, dest, tag) Arguments Type Intent Optional Attributes Name character, intent(in) :: s integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine ssend_integer (i, dest, tag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine ssend_integer_array (i, dest, tag) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: i integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine ssend_real (a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine ssend_real_array (a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine ssend_complex (z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine ssend_complex_array (z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine ssend_complex_2array (z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine ssend_logical (f, dest, tag) Arguments Type Intent Optional Attributes Name logical, intent(in) :: f integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine ssend_logical_array (f, dest, tag) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:) :: f integer, intent(in) :: dest integer, intent(in), optional :: tag private subroutine receive_integer (i, src, tag) Arguments Type Intent Optional Attributes Name integer :: i integer, intent(in) :: src integer, intent(in), optional :: tag private subroutine receive_integer_array (i, src, tag) Arguments Type Intent Optional Attributes Name integer, dimension(:) :: i integer, intent(in) :: src integer, intent(in), optional :: tag private subroutine receive_real (a, src, tag) Arguments Type Intent Optional Attributes Name real :: a integer, intent(in) :: src integer, intent(in), optional :: tag private subroutine receive_real_array (a, src, tag) Arguments Type Intent Optional Attributes Name real, dimension(:) :: a integer, intent(in) :: src integer, intent(in), optional :: tag private subroutine receive_real_array_2d (a, src, tag) Arguments Type Intent Optional Attributes Name real, dimension(:, :) :: a integer, intent(in) :: src integer, intent(in), optional :: tag private subroutine receive_complex (z, src, tag) Arguments Type Intent Optional Attributes Name complex :: z integer, intent(in) :: src integer, intent(in), optional :: tag private subroutine receive_complex_array (z, src, tag) Arguments Type Intent Optional Attributes Name complex, dimension(:) :: z integer, intent(in) :: src integer, intent(in), optional :: tag private subroutine receive_complex_2array (z, src, tag) Arguments Type Intent Optional Attributes Name complex, dimension(:, :) :: z integer, intent(in) :: src integer, intent(in), optional :: tag private subroutine nonblocking_receive_complex_array (z, src, tag, request) Arguments Type Intent Optional Attributes Name complex, dimension(:) :: z integer, intent(in) :: src integer, intent(in), optional :: tag integer, intent(out) :: request private subroutine receive_logical (f, src, tag) Arguments Type Intent Optional Attributes Name logical :: f integer, intent(in) :: src integer, intent(in), optional :: tag private subroutine receive_logical_array (f, src, tag) Arguments Type Intent Optional Attributes Name logical, dimension(:) :: f integer, intent(in) :: src integer, intent(in), optional :: tag private subroutine receive_character (s, src, tag) Arguments Type Intent Optional Attributes Name character :: s integer, intent(in) :: src integer, intent(in), optional :: tag public subroutine waitany (count, requests, requestindex, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: count integer, intent(inout), dimension(:) :: requests integer, intent(out) :: requestindex integer, intent(out), dimension(1) :: status private subroutine all_to_group_real (all, group, njobs) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: all real, intent(out) :: group integer, intent(in) :: njobs private subroutine all_to_group_real_array (all, group, njobs) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: all real, intent(out), dimension(:) :: group integer, intent(in) :: njobs private subroutine group_to_all_real (group, all, njobs) Arguments Type Intent Optional Attributes Name real, intent(in) :: group real, intent(out), dimension(:) :: all integer, intent(in) :: njobs private subroutine group_to_all_real_array (group, all, njobs) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: group real, intent(out), dimension(:, :) :: all integer, intent(in) :: njobs public subroutine mp_abort (msg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg private subroutine error (msg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg public subroutine mp_gather (senddata, recvarray) Arguments Type Intent Optional Attributes Name integer, intent(in) :: senddata integer, intent(out), dimension(:) :: recvarray public subroutine broadcast_with_comm (x, comm) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: x integer, intent(in) :: comm","tags":"","loc":"module/mp.html"},{"title":"text_options â€“ stella","text":"Contents Variables maxlen Derived Types text_option Subroutines get_option_value Variables Type Visibility Attributes Name Initial integer, private, parameter :: maxlen = 30 Derived Types type, public :: text_option Components Type Visibility Attributes Name Initial character, private :: name integer, private :: value Subroutines public subroutine get_option_value (selection, options, value, error_unit, selection_name, stop_on_error) Arguments Type Intent Optional Attributes Name character, intent(in) :: selection type( text_option ), intent(in), dimension(:) :: options integer, intent(inout) :: value integer, intent(in), optional :: error_unit character, intent(in), optional :: selection_name logical, intent(in), optional :: stop_on_error","tags":"","loc":"module/text_options.html"},{"title":"mt19937 â€“ stella","text":"Contents Variables default_seed N M MATA LMASK UMASK TMASKB TMASKC mt mti mag01 Functions grnd Subroutines sgrnd Variables Type Visibility Attributes Name Initial integer, private, parameter :: default_seed = 4357 integer, private, parameter :: N = 624 integer, private, parameter :: M = 397 integer, private, parameter :: MATA = -1727483681 integer, private, parameter :: LMASK = 2147483647 integer, private, parameter :: UMASK = -LMASK-1 integer, private, parameter :: TMASKB = -1658038656 integer, private, parameter :: TMASKC = -272236544 integer, private, save :: mt (0:N-1) integer, private, save :: mti = N+1 integer, private, save :: mag01 (0:1) = (/0, MATA/) Functions public function grnd () Arguments None Return Value real Subroutines public subroutine sgrnd (seed) Arguments Type Intent Optional Attributes Name integer, intent(in) :: seed","tags":"","loc":"module/mt19937.html"},{"title":"redistribute â€“ stella","text":"Contents Variables gather_count scatter_count time_redist Interfaces gather scatter measure_gather measure_scatter fill Derived Types index_map redist_type index_list_type Subroutines set_redist_character_type init_redist init_fill delete_redist delete_list c_redist_12 c_redist_22 c_redist_22_old_copy c_redist_22_mpi_copy c_redist_22_inv c_redist_22_inv_old_copy c_redist_22_inv_mpi_copy c_redist_32 c_redist_32_old_copy c_redist_32_mpi_copy c_redist_32_inv c_redist_32_inv_old_copy c_redist_32_inv_mpi_copy c_redist_42 c_redist_42_inv c_redist_23 c_redist_34 c_redist_34_inv r_redist_34 r_redist_34_inv c_redist_35 r_redist_35 c_redist_35_inv r_redist_35_inv r_redist_12 r_redist_22 r_redist_22_inv r_redist_32 r_redist_32_inv r_redist_42 r_redist_42_inv i_redist_12 i_redist_22 i_redist_22_inv i_redist_32 i_redist_32_inv i_redist_42 i_redist_42_inv l_redist_12 l_redist_22 l_redist_22_inv l_redist_32 l_redist_32_inv l_redist_42 l_redist_42_inv c_redist_33 c_redist_33_inv c_fill_2 c_fill_3 c_fill_4 r_fill_2 r_fill_3 r_fill_4 i_fill_2 i_fill_3 i_fill_4 l_fill_2 l_fill_3 l_fill_4 report_map_property measure_gather_32 measure_scatter_23 measure_gather_33 measure_scatter_33 measure_gather_22 measure_scatter_22 Variables Type Visibility Attributes Name Initial integer, public :: gather_count = 0 integer, public :: scatter_count = 0 real, public, save :: time_redist (2) = 0. Interfaces public interface gather private subroutine c_redist_22 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine r_redist_22 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine i_redist_22 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here integer, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine l_redist_22 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here logical, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine c_redist_32 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine r_redist_32 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine i_redist_32 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here integer, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine l_redist_32 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here logical, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine c_redist_42 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine r_redist_42 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine i_redist_42 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: from_here integer, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine l_redist_42 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: from_here logical, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine c_redist_23 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):) :: to_here private subroutine c_redist_34 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):) :: to_here private subroutine r_redist_34 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):) :: to_here private subroutine c_redist_33 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):) :: to_here private subroutine c_redist_35 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):, r%to_low(5):) :: to_here private subroutine r_redist_35 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):, r%to_low(5):) :: to_here public interface scatter private subroutine c_redist_12 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine r_redist_12 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine i_redist_12 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%from_low(1):) :: from_here integer, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine l_redist_12 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%from_low(1):) :: from_here logical, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine c_redist_22_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here private subroutine r_redist_22_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here private subroutine i_redist_22_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here integer, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here private subroutine l_redist_22_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here logical, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here private subroutine c_redist_32_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private subroutine r_redist_32_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private subroutine i_redist_32_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here integer, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private subroutine l_redist_32_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here logical, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private subroutine c_redist_42_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: to_here private subroutine r_redist_42_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: to_here private subroutine i_redist_42_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here integer, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: to_here private subroutine l_redist_42_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here logical, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: to_here private subroutine c_redist_33_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private subroutine c_redist_34_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private subroutine r_redist_34_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private subroutine c_redist_35_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):, r%to_low(5):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private subroutine r_redist_35_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):, r%to_low(5):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here public interface measure_gather private subroutine measure_gather_32 (map, gin, gout) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :, :) :: gin complex, intent(out), dimension(:, :) :: gout private subroutine measure_gather_33 (map, gin, gout) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :, :) :: gin complex, intent(out), dimension(:, :, :) :: gout private subroutine measure_gather_22 (map, gin, gout) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout public interface measure_scatter private subroutine measure_scatter_23 (map, gin, gout) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :, :) :: gout private subroutine measure_scatter_33 (map, gin, gout) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :, :) :: gin complex, intent(out), dimension(:, :, :) :: gout private subroutine measure_scatter_22 (map, gin, gout) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout public interface fill private subroutine c_fill_2 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f complex, intent(in), dimension(f%from_low(1):, f%from_low(2):) :: from_here complex, intent(inout), dimension(f%to_low(1):, f%to_low(2):) :: to_here private subroutine c_fill_3 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f complex, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):) :: from_here complex, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):) :: to_here private subroutine c_fill_4 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f complex, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):, f%from_low(4):) :: from_here complex, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):, f%to_low(4):) :: to_here private subroutine r_fill_2 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f real, intent(in), dimension(f%from_low(1):, f%from_low(2):) :: from_here real, intent(inout), dimension(f%to_low(1):, f%to_low(2):) :: to_here private subroutine r_fill_3 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f real, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):) :: from_here real, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):) :: to_here private subroutine r_fill_4 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f real, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):, f%from_low(4):) :: from_here real, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):, f%to_low(4):) :: to_here private subroutine i_fill_2 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f integer, intent(in), dimension(f%from_low(1):, f%from_low(2):) :: from_here integer, intent(inout), dimension(f%to_low(1):, f%to_low(2):) :: to_here private subroutine i_fill_3 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f integer, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):) :: from_here integer, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):) :: to_here private subroutine i_fill_4 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f integer, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):, f%from_low(4):) :: from_here integer, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):, f%to_low(4):) :: to_here private subroutine l_fill_2 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f logical, intent(in), dimension(f%from_low(1):, f%from_low(2):) :: from_here logical, intent(inout), dimension(f%to_low(1):, f%to_low(2):) :: to_here private subroutine l_fill_3 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f logical, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):) :: from_here logical, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):) :: to_here private subroutine l_fill_4 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f logical, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):, f%from_low(4):) :: from_here logical, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):, f%to_low(4):) :: to_here Derived Types type, private :: index_map Components Type Visibility Attributes Name Initial integer, private :: nn integer, private, dimension(:), pointer :: k => null() integer, private, dimension(:), pointer :: l => null() integer, private, dimension(:), pointer :: m => null() integer, private, dimension(:), pointer :: n => null() integer, private, dimension(:), pointer :: o => null() type, public :: redist_type Components Type Visibility Attributes Name Initial integer, private, dimension(5) :: to_low integer, private, dimension(5) :: from_low integer, private, dimension(5) :: to_high integer, private, dimension(5) :: from_high type( index_map ), private, dimension(:), pointer :: to => null() type( index_map ), private, dimension(:), pointer :: from => null() complex, private, dimension(:), pointer :: complex_buff => null() real, private, dimension(:), pointer :: real_buff => null() integer, private, dimension(:), pointer :: integer_buff => null() logical, private, dimension(:), pointer :: logical_buff => null() character(len=3), private :: redistname = \"\" type, public :: index_list_type Components Type Visibility Attributes Name Initial integer, private, dimension(:), pointer :: first => null() integer, private, dimension(:), pointer :: second => null() integer, private, dimension(:), pointer :: third => null() integer, private, dimension(:), pointer :: fourth => null() integer, private, dimension(:), pointer :: fifth => null() Subroutines public subroutine set_redist_character_type (r, chartype) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r character(len=3), intent(in) :: chartype public subroutine init_redist (r, char, to_low, to_high, to_list, from_low, from_high, from_list, ierr) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r character(len=1), intent(in) :: char integer, intent(in), dimension(:) :: to_low integer, intent(in), dimension(:) :: to_high type( index_list_type ), intent(in), dimension(0:nproc - 1) :: to_list integer, intent(in), dimension(:) :: from_low integer, intent(in), dimension(:) :: from_high type( index_list_type ), intent(in), dimension(0:nproc - 1) :: from_list integer, intent(out), optional :: ierr public subroutine init_fill (f, char, to_low, to_list, from_low, from_list, ierr) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(out) :: f character(len=1), intent(in) :: char integer, intent(in), dimension(:) :: to_low type( index_list_type ), intent(in), dimension(0:nproc - 1) :: to_list integer, intent(in), dimension(:) :: from_low type( index_list_type ), intent(in), dimension(0:nproc - 1) :: from_list integer, intent(out), optional :: ierr public subroutine delete_redist (r) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r public subroutine delete_list (list) Arguments Type Intent Optional Attributes Name type( index_list_type ), intent(inout), dimension(0:nproc - 1) :: list private subroutine c_redist_12 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine c_redist_22 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine c_redist_22_old_copy (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine c_redist_22_mpi_copy (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine c_redist_22_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here private subroutine c_redist_22_inv_old_copy (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here private subroutine c_redist_22_inv_mpi_copy (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here private subroutine c_redist_32 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine c_redist_32_old_copy (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine c_redist_32_mpi_copy (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine c_redist_32_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private subroutine c_redist_32_inv_old_copy (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private subroutine c_redist_32_inv_mpi_copy (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private subroutine c_redist_42 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine c_redist_42_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: to_here private subroutine c_redist_23 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):) :: to_here private subroutine c_redist_34 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):) :: to_here private subroutine c_redist_34_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private subroutine r_redist_34 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):) :: to_here private subroutine r_redist_34_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private subroutine c_redist_35 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):, r%to_low(5):) :: to_here private subroutine r_redist_35 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):, r%to_low(5):) :: to_here private subroutine c_redist_35_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):, r%to_low(5):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private subroutine r_redist_35_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):, r%to_low(5):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private subroutine r_redist_12 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine r_redist_22 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine r_redist_22_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here private subroutine r_redist_32 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine r_redist_32_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private subroutine r_redist_42 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine r_redist_42_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: to_here private subroutine i_redist_12 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%from_low(1):) :: from_here integer, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine i_redist_22 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here integer, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine i_redist_22_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here integer, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here private subroutine i_redist_32 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here integer, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine i_redist_32_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here integer, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private subroutine i_redist_42 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: from_here integer, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine i_redist_42_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here integer, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: to_here private subroutine l_redist_12 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%from_low(1):) :: from_here logical, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine l_redist_22 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here logical, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine l_redist_22_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here logical, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here private subroutine l_redist_32 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here logical, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine l_redist_32_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here logical, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private subroutine l_redist_42 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: from_here logical, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private subroutine l_redist_42_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here logical, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: to_here private subroutine c_redist_33 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):) :: to_here private subroutine c_redist_33_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private subroutine c_fill_2 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f complex, intent(in), dimension(f%from_low(1):, f%from_low(2):) :: from_here complex, intent(inout), dimension(f%to_low(1):, f%to_low(2):) :: to_here private subroutine c_fill_3 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f complex, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):) :: from_here complex, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):) :: to_here private subroutine c_fill_4 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f complex, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):, f%from_low(4):) :: from_here complex, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):, f%to_low(4):) :: to_here private subroutine r_fill_2 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f real, intent(in), dimension(f%from_low(1):, f%from_low(2):) :: from_here real, intent(inout), dimension(f%to_low(1):, f%to_low(2):) :: to_here private subroutine r_fill_3 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f real, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):) :: from_here real, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):) :: to_here private subroutine r_fill_4 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f real, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):, f%from_low(4):) :: from_here real, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):, f%to_low(4):) :: to_here private subroutine i_fill_2 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f integer, intent(in), dimension(f%from_low(1):, f%from_low(2):) :: from_here integer, intent(inout), dimension(f%to_low(1):, f%to_low(2):) :: to_here private subroutine i_fill_3 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f integer, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):) :: from_here integer, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):) :: to_here private subroutine i_fill_4 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f integer, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):, f%from_low(4):) :: from_here integer, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):, f%to_low(4):) :: to_here private subroutine l_fill_2 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f logical, intent(in), dimension(f%from_low(1):, f%from_low(2):) :: from_here logical, intent(inout), dimension(f%to_low(1):, f%to_low(2):) :: to_here private subroutine l_fill_3 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f logical, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):) :: from_here logical, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):) :: to_here private subroutine l_fill_4 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f logical, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):, f%from_low(4):) :: from_here logical, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):, f%to_low(4):) :: to_here public subroutine report_map_property (r) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(in) :: r private subroutine measure_gather_32 (map, gin, gout) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :, :) :: gin complex, intent(out), dimension(:, :) :: gout private subroutine measure_scatter_23 (map, gin, gout) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :, :) :: gout private subroutine measure_gather_33 (map, gin, gout) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :, :) :: gin complex, intent(out), dimension(:, :, :) :: gout private subroutine measure_scatter_33 (map, gin, gout) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :, :) :: gin complex, intent(out), dimension(:, :, :) :: gout private subroutine measure_gather_22 (map, gin, gout) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout private subroutine measure_scatter_22 (map, gin, gout) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout","tags":"","loc":"module/redistribute.html"},{"title":"job_manage â€“ stella","text":"Contents Variables njobs Functions timer_local Subroutines time_message job_fork checkstop checktime Variables Type Visibility Attributes Name Initial integer, public :: njobs = 1 Functions public function timer_local () Arguments None Return Value real Subroutines public subroutine time_message (lprint, targ, chmessage) Arguments Type Intent Optional Attributes Name logical, intent(in) :: lprint real, intent(inout) :: targ (2) character(len=*), intent(in) :: chmessage public subroutine job_fork (n_ensembles) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: n_ensembles public subroutine checkstop (exit, list) Arguments Type Intent Optional Attributes Name logical, intent(inout) :: exit logical, intent(in), optional :: list public subroutine checktime (avail_time, exit) Arguments Type Intent Optional Attributes Name real, intent(in) :: avail_time logical, intent(inout) :: exit","tags":"","loc":"module/job_manage.html"},{"title":"ran â€“ stella","text":"Contents Functions ranf get_rnd_seed_length Subroutines get_rnd_seed init_ranf Functions public function ranf (seed) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: seed Return Value real public function get_rnd_seed_length () result(l) Arguments None Return Value integer Subroutines public subroutine get_rnd_seed (seed) Arguments Type Intent Optional Attributes Name integer, intent(out), dimension(:) :: seed public subroutine init_ranf (randomize, init_seed, mult) Arguments Type Intent Optional Attributes Name logical, intent(in) :: randomize integer, intent(inout), dimension(:) :: init_seed integer, intent(in), optional :: mult","tags":"","loc":"module/ran.html"},{"title":"git_version_impl â€“ stella","text":"Uses Ancestors: git_version Contents Module Procedures get_git_version get_git_hash get_git_state get_git_date Module Procedures module procedure get_git_version module module function get_git_version() Interface â†’ Arguments None Return Value character,\n  allocatable module procedure get_git_hash module module function get_git_hash(length_in) Interface â†’ Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: length_in Return Value character,\n  allocatable module procedure get_git_state module module function get_git_state() Interface â†’ Arguments None Return Value character,\n  allocatable module procedure get_git_date module module function get_git_date() Interface â†’ Arguments None Return Value character(len=10)","tags":"","loc":"module/git_version_impl.html"},{"title":"stella â€“ stella","text":"Uses run_parameters stella_save job_manage time_advance dist_redistribute file_utils stella_time dist_fn_arrays stella_diagnostics git_version redistribute Initialize stella Diagnose stella\nAdvance stella until istep=nstep\nFinish stella Contents Variables debug stop_stella mpi_initialized istep0 istep ierr istatus time_init time_diagnostics time_total Subroutines init_stella check_transforms write_start_message print_header parse_command_line finish_stella Variables Type Attributes Name Initial logical :: debug = .false. logical :: stop_stella = .false. logical :: mpi_initialized = .false. integer :: istep0 integer :: istep integer :: ierr integer :: istatus real, dimension(2) :: time_init = 0. real, dimension(2) :: time_diagnostics = 0. real, dimension(2) :: time_total = 0. Subroutines subroutine init_stella (istep0, VERNUM, VERDATE) Initialise stella Read moreâ€¦ Arguments Type Intent Optional Attributes Name integer, intent(out) :: istep0 Starting timestep: zero unless the simulation has been restarted character(len=*), intent(in) :: VERNUM stella version number character(len=10), intent(in) :: VERDATE Release date subroutine check_transforms (needs_transforms) check_transforms checks the various physics flag choices\nto determine if FFTs are needed for the simulation Read moreâ€¦ Arguments Type Intent Optional Attributes Name logical, intent(out) :: needs_transforms subroutine write_start_message (VERNUM, VERDATE) Write the start message to screen Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: VERNUM stella version number character(len=10), intent(in) :: VERDATE Release date subroutine print_header () Arguments None subroutine parse_command_line () Parse some basic command line arguments. Currently just 'version' and 'help'. Read moreâ€¦ Arguments None subroutine finish_stella (last_call) Finish a simulation, call the finialisation routines of all modules Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: last_call","tags":"","loc":"program/stella.html"},{"title":"test_vmec_to_stella_geometry_interface â€“ stella","text":"Uses vmec_to_stella_geometry_interface_mod Input parameters Contents Variables vmec_filename nalpha nzgrid alpha0 zeta_center number_of_field_periods_to_include desired_normalized_toroidal_flux vmec_surface_option verbose normalized_toroidal_flux_used safety_factor_q shat L_reference B_reference nfp sign_toroidal_flux alpha zeta bmag gradpar gds2 gds21 gds22 gds23 gds24 gds25 gds26 gbdrift gbdrift0 cvdrift cvdrift0 theta_vmec B_sub_zeta B_sub_theta_vmec displacement j iunit Variables Type Attributes Name Initial character(len=2000) :: vmec_filename = 'equilibria/wout_w7x_standardConfig.nc' integer, parameter :: nalpha = 5 integer, parameter :: nzgrid = 7 real :: alpha0 = 0.0 real :: zeta_center = 0.0 real :: number_of_field_periods_to_include = 1 real :: desired_normalized_toroidal_flux = 0.6354167d+0 integer :: vmec_surface_option = 0 logical :: verbose = .true. Output arrays real :: normalized_toroidal_flux_used real :: safety_factor_q real :: shat real :: L_reference real :: B_reference real :: nfp integer :: sign_toroidal_flux real, dimension(nalpha) :: alpha real, dimension(-nzgrid:nzgrid) :: zeta real, dimension(nalpha, -nzgrid:nzgrid) :: bmag real, dimension(nalpha, -nzgrid:nzgrid) :: gradpar real, dimension(nalpha, -nzgrid:nzgrid) :: gds2 real, dimension(nalpha, -nzgrid:nzgrid) :: gds21 real, dimension(nalpha, -nzgrid:nzgrid) :: gds22 real, dimension(nalpha, -nzgrid:nzgrid) :: gds23 real, dimension(nalpha, -nzgrid:nzgrid) :: gds24 real, dimension(nalpha, -nzgrid:nzgrid) :: gds25 real, dimension(nalpha, -nzgrid:nzgrid) :: gds26 real, dimension(nalpha, -nzgrid:nzgrid) :: gbdrift real, dimension(nalpha, -nzgrid:nzgrid) :: gbdrift0 real, dimension(nalpha, -nzgrid:nzgrid) :: cvdrift real, dimension(nalpha, -nzgrid:nzgrid) :: cvdrift0 real, dimension(nalpha, -nzgrid:nzgrid) :: theta_vmec real, dimension(nalpha, -nzgrid:nzgrid) :: B_sub_zeta Variables used internally by this program real, dimension(nalpha, -nzgrid:nzgrid) :: B_sub_theta_vmec Variables used internally by this program real, dimension(nalpha, -nzgrid:nzgrid) :: displacement Variables used internally by this program integer :: j Beginning of executable statements integer :: iunit Beginning of executable statements","tags":"","loc":"program/test_vmec_to_stella_geometry_interface.html"},{"title":"fluxes â€“ stella","text":"Contents Variables iargc flxunit it nstep nspec target_it tstart tstart_flag line flxfile time pflx vflx qflx pflxavg vflxavg qflxavg pi_over_q Subroutines time_average Variables Type Attributes Name Initial integer :: iargc integer :: flxunit = 101 integer :: it integer :: nstep integer :: nspec integer :: target_it real :: tstart = 0.0 logical :: tstart_flag character(len=500) :: line character(len=500) :: flxfile real, dimension(:), allocatable :: time real, dimension(:, :), allocatable :: pflx real, dimension(:, :), allocatable :: vflx real, dimension(:, :), allocatable :: qflx real, dimension(:), allocatable :: pflxavg real, dimension(:), allocatable :: vflxavg real, dimension(:), allocatable :: qflxavg real, dimension(:), allocatable :: pi_over_q Subroutines subroutine time_average (t, it, flx, flxavg) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: t integer, intent(in) :: it real, intent(in), dimension(:, :) :: flx real, intent(out), dimension(:) :: flxavg","tags":"","loc":"program/fluxes.html"},{"title":"README â€“ stella","text":"","tags":"","loc":"page//index.html"},{"title":"CMake in stella â€“ stella","text":"Stella now has (experimental) support for building with CMake. Using CMake CMake options All CMake options can be set on the command line with the syntax: -D<variable>=value . Boolean flags can use on/yes/true/1 or off/no/false/0 to turn them on/off -- these options are\ncase-insensitive. Optimisation vs debugging CMake has a built-in option for setting optimisation or debugging\nflags: CMAKE_BUILD_TYPE . If this is not set, by default stella will\nuse RelWithDebInfo , which is the equivalent of -O2 -g : moderate\noptimisation with debug symbols. This doesn't turn on any runtime\nchecking, it only keeps names of functions, variables, etc. for error\nmessages and backtraces in the event of a crash. Set -DCMAKE_BUILD_TYPE=Release to turn on full optimisations. Use -DCMAKE_BUILD_TYPE=Debug to turn off optimisations and turn on\nvarious compile- and run-time checks (depending on the compiler). Dependencies Stella has several optional dependencies, the location of which can be\nspecified by using the <package>_ROOT variables. The list of\ndependencies and their location variables are as follows: MPI: This is the odd-one-out, in that the best way to control which\n  MPI implementation is found is via MPIEXEC_EXECUTABLE . This is\n  already automatically set to the current mpirun/mpiexec in your PATH , so this shouldn't need to be set. LAPACK: LAPACK_ROOT . On Cray systems that use the Cray Programming\n  Environment, this is automatically handled by the Cray Compiler\n  Environment and so is not user-controllable. FFTW: FFTW_ROOT . Stella also searches for the fftw-wisdom executable in your PATH as a first guess NetCDF: netCDF_ROOT for the C library, and netCDFFortran_ROOT for the Fortran API. Stella searches for nc-config and nf-config in your PATH and uses those to query the netCDF configuration All of these dependencies, with the exception of MPI, can be turned on\nor off with the STELLA_ENABLE_<name> variable. Developing the stella CMake build system One important consideration when developing stella is that any new\nfiles must be listed in the STELLA_SOURCES_* variables: either STELLA_SOURCES_f90 or STELLA_SOURCES_fpp as appropriate. If you\nadd a new file and do not add it to exactly one of these variables,\nyou will get a build error.","tags":"","loc":"page/./CMake.html"},{"title":"Writing Documentation â€“ stella","text":"In-source documentation Out-of-source documentation Add a new page Converting LaTeX to Markdown Linking to sections Linking to source documentation Building the documentation locally Cheat sheet stella uses FORD to automatically build this online documentation. There are two\nsorts of documentation that get built: in-source and out-of-source. This page describes\nhow to write both sorts. The website will get built automatically when your changes are\nmerged into master . In-source documentation Special Fortran comments of the form !> are used to document procedures, variables and\nprograms using FORD . These comments are sometimes called \"docstrings\". FORD can\nunderstand these comments before, after or in-line with the thing to be documented, but\nthe preferred style in stella is to put the comment before the entity, like in this example: !> This is module-level documentation, describing the overall purpose of this module. !> Documentation comments can be over several lines. module my_module implicit none !> Docstrings can go on derived types type :: my_type !> Docstrings can include in-line LaTeX like this: R real :: R_major !> Or as a displayed equation: !>   \\frac{\\partial R}{\\partial \\psi} real :: R_major_prime !> Code-formatting uses `backticks` integer :: n_R end type my_type contains !> We can document functions/subroutines real function gradient ( R , psi ) !> In order to separate the docstring for each argument... real , intent ( in ) :: R !> ...it's best to have each argument on its own line real , intent ( in ) :: psi end function gradient end module my_module The FORD wiki has more documentation on how to write these docstrings. Please\nnote that while FORD accepts !< comments after or in-line with the thing to be\ndocumented, the stella style is to stick to !> before and on a separate line. Out-of-source documentation As well as the code documentation, we also have some extra documentation. The source for\nthese pages in still kept in the stella git repository, and are built into the website at the\nsame time. These extra pages are written in Markdown , with some\nextensions (see the Python markdown implementation ). There's a short cheat sheet at the bottom of this page. Add a new page All the out-of-source documentation is under docs/pages . FORD converts the directory\nhierarchy in to a hierarchy of HTML pages. To add a new page, simply create a new file\nunder docs/pages , and use the file extension .md . Your file must contain the\nfollowing at the very top : ---\ntitle: Page title\n--- Without this metadata section, FORD will not parse the file as part of the documentation. In this metadata section, you can also have author and date items. Another useful feature, is put [TOC] on its own line after the metadata section. This\nproduces a hyperlinked table of contents. See the FORD wiki for a more detailed description. Converting LaTeX to Markdown The easiest way to convert LaTeX to Markdown is to use Pandoc . This nifty tool\nunderstands tons of text formats and can convert between them easily, and will get the\nvast majority of the heavy lifting done for you. Due to the complexities of LaTeX and the\nsimplicity of Markdown, it may require some manual tidying up after the initial\nconversion. To get started, run Pandoc: $ pandoc --standalone --from = latex --to = gfm my_docs.tex --output docs/pages/my_docs.md FORD is a bit fussier about the metadata section at the top, compared to what Pandoc\nproduces, so you may need to manually adjust it. Acceptable: ---\ntitle: On the Electrodynamics of Moving Bodies\nauthor: A. Einstein\n--- Unacceptable: ---\ntitle: Does the Inertia of a Body Depend upon its Energy Content?\nauthor: \n- 'A. Einstein'\n--- which is a possible output from Pandoc. FORD can render LaTeX included in the markdown, with just a couple of gotchas. The most\nimportant one is that in-line maths must use ... rather than $...$ . Displayed\nequations can be written between ... , but note that this does not number the\nresulting equation. Normal \\begin{equation} ... \\end{equation} environments can be used to get numbered\nequations, along with \\label{eq:something} and \\eqref{eq:something} to refer to them. This example: To obtain the distribution function at the next time step, g&#94;{n+1}, we could combine\nthese equations\n\nA g&#94;{n+1} + B g&#94;{n} = DF&#94;{-1}Gg&#94;{n+1} + E\\phi&#94;{n}, is rendered as: To obtain the distribution function at the next time step, , we could combine\nthese equations while \\begin{equation}\nF \\phi&#94;{n+1} = G g&#94;{n+1}\n\\label{eq:QN}\n\\end{equation}\n\n\\eqref{eq:QN} is the quasi-neutrality equation is rendered as \\eqref{eq:QN} is the quasi-neutrality equation Linking to sections Section titles within a page get converted into HTML \"anchors\" which can be linked to. The\nsection names are first converted to lowercase and spaces replaced with hyphens. To link\nto a section, use the usual link syntax and add # in front of the converted section\nname. This: Link to [ this section ]( # linking - to - sections ) becomes: Link to this section Linking to source documentation Linking directly to the code documentation is possible using FORD's syntax, which is\ndescribed here : This: The two linear steps L are performed by the function dist_fn in dist_fn.fpp is rendered as: The two linear steps are performed by the function dist_fn in dist_fn.fpp Building the documentation locally FORD can be easily installed with pip : $ pip3 install --user ford After installing FORD, simply run make doc . This will build the documentation under docs/html : $ make doc Then open docs/html/index.html in your favourite browser. Cheat sheet See here for a comprehensive guide to Markdown. Here's a quick little cheat sheet: Syntax Description Heading # Top-level ## Section ### Sub-section Bold **bold text** Italic *italicised text* Code `code` Blockquote > Block quote Ordered lists 1. First item 2. Second item 3. Third item Unordered lists - First item - Second item - Third item Link [title](www.example.com) Image ![alt text](image.jpg)","tags":"","loc":"page/./writing_documentation.html"}]}