var tipuesearch = {"pages":[{"title":" stella ","text":"stella stella solves the gyrokinetic-Poisson system of equations in the local limit\nusing an operator-split, implicit-explicit numerical scheme. It is capable of\nevolving electrostatic fluctuations with fully kinetic electrons and an\narbitrary number of ion species in general magnetic geometry, including\nstellarators. Developer Info The stella team stella has been developed by many developers\nSee the citation\nfile for a complete list","tags":"home","loc":"index.html"},{"title":"fft_type – stella ","text":"type, public :: fft_type Components Type Visibility Attributes Name Initial integer, public :: n integer, public :: is integer, public :: type integer(kind=kind_id), public :: plan real, public :: scale","tags":"","loc":"type/fft_type.html"},{"title":"index_map – stella ","text":"type, private :: index_map Components Type Visibility Attributes Name Initial integer, public :: nn integer, public, dimension(:), pointer :: k => null() integer, public, dimension(:), pointer :: l => null() integer, public, dimension(:), pointer :: m => null() integer, public, dimension(:), pointer :: n => null() integer, public, dimension(:), pointer :: o => null()","tags":"","loc":"type/index_map.html"},{"title":"redist_type – stella ","text":"type, public :: redist_type Components Type Visibility Attributes Name Initial integer, private, dimension(5) :: to_low integer, private, dimension(5) :: from_low integer, private, dimension(5) :: to_high integer, private, dimension(5) :: from_high type( index_map ), private, dimension(:), pointer :: to => null() type( index_map ), private, dimension(:), pointer :: from => null() complex, private, dimension(:), pointer :: complex_buff => null() real, private, dimension(:), pointer :: real_buff => null() integer, private, dimension(:), pointer :: integer_buff => null() logical, private, dimension(:), pointer :: logical_buff => null() character(len=3), private :: redistname = \"\"","tags":"","loc":"type/redist_type.html"},{"title":"index_list_type – stella ","text":"type, public :: index_list_type Components Type Visibility Attributes Name Initial integer, public, dimension(:), pointer :: first => null() integer, public, dimension(:), pointer :: second => null() integer, public, dimension(:), pointer :: third => null() integer, public, dimension(:), pointer :: fourth => null() integer, public, dimension(:), pointer :: fifth => null()","tags":"","loc":"type/index_list_type.html"},{"title":"spline – stella ","text":"type, public :: spline Components Type Visibility Attributes Name Initial integer, public :: n real, public, dimension(:), pointer :: x real, public, dimension(:), pointer :: y real, public, dimension(:), pointer :: y2","tags":"","loc":"type/spline.html"},{"title":"periodic_spline – stella ","text":"type, public :: periodic_spline Components Type Visibility Attributes Name Initial integer, public :: n real, public :: period real, public, dimension(:), pointer :: x real, public, dimension(:), pointer :: y real, public, dimension(:), pointer :: y2","tags":"","loc":"type/periodic_spline.html"},{"title":"text_option – stella ","text":"type, public :: text_option Components Type Visibility Attributes Name Initial character(len=maxlen), public :: name integer, public :: value","tags":"","loc":"type/text_option.html"},{"title":"kxkyz_layout_type – stella ","text":"type, public :: kxkyz_layout_type sequence Components Type Visibility Attributes Name Initial integer, public :: iproc integer, public :: nzgrid integer, public :: nzed integer, public :: ntubes integer, public :: naky integer, public :: nakx integer, public :: nvgrid integer, public :: nvpa integer, public :: nmu integer, public :: nspec integer, public :: llim_world integer, public :: ulim_world integer, public :: llim_proc integer, public :: ulim_proc integer, public :: ulim_alloc integer, public :: blocksize","tags":"","loc":"type/kxkyz_layout_type.html"},{"title":"kxyz_layout_type – stella ","text":"type, public :: kxyz_layout_type sequence Components Type Visibility Attributes Name Initial integer, public :: iproc integer, public :: nzgrid integer, public :: nzed integer, public :: ntubes integer, public :: ny integer, public :: naky integer, public :: nakx integer, public :: ikx_max integer, public :: nvgrid integer, public :: nvpa integer, public :: nmu integer, public :: nspec integer, public :: llim_world integer, public :: ulim_world integer, public :: llim_proc integer, public :: ulim_proc integer, public :: ulim_alloc integer, public :: blocksize","tags":"","loc":"type/kxyz_layout_type.html"},{"title":"xyz_layout_type – stella ","text":"type, public :: xyz_layout_type sequence Components Type Visibility Attributes Name Initial integer, public :: iproc integer, public :: nzgrid integer, public :: nzed integer, public :: ntubes integer, public :: ny integer, public :: naky integer, public :: nx integer, public :: nakx integer, public :: nvgrid integer, public :: nvpa integer, public :: nmu integer, public :: nspec integer, public :: llim_world integer, public :: ulim_world integer, public :: llim_proc integer, public :: ulim_proc integer, public :: ulim_alloc integer, public :: blocksize","tags":"","loc":"type/xyz_layout_type.html"},{"title":"vmu_layout_type – stella ","text":"type, public :: vmu_layout_type sequence Components Type Visibility Attributes Name Initial logical, public :: xyz integer, public :: iproc integer, public :: nzgrid integer, public :: nzed integer, public :: ntubes integer, public :: nalpha integer, public :: ny integer, public :: naky integer, public :: nx integer, public :: nakx integer, public :: nvgrid integer, public :: nvpa integer, public :: nmu integer, public :: nspec integer, public :: llim_world integer, public :: ulim_world integer, public :: llim_proc integer, public :: ulim_proc integer, public :: ulim_alloc integer, public :: blocksize","tags":"","loc":"type/vmu_layout_type.html"},{"title":"flux_surface_type – stella ","text":"type, public :: flux_surface_type Components Type Visibility Attributes Name Initial real, public :: rmaj real, public :: rgeo real, public :: kappa real, public :: kapprim real, public :: tri real, public :: triprim real, public :: rhoc real, public :: dr real, public :: shift real, public :: qinp real, public :: shat real, public :: betaprim real, public :: betadbprim real, public :: d2qdr2 real, public :: d2psidr2 real, public :: dpsitordrho real, public :: d2psitordrho2 real, public :: rhotor real, public :: drhotordrho real, public :: psitor_lcfs real, public :: zed0_fac real, public :: rhoc_psi0 real, public :: qinp_psi0 real, public :: shat_psi0","tags":"","loc":"type/flux_surface_type.html"},{"title":"spec_type – stella ","text":"type, public :: spec_type Components Type Visibility Attributes Name Initial integer, public :: nspec real, public :: z real, public :: mass real, public :: dens real, public :: temp real, public :: tprim real, public :: fprim real, public :: vnew_ref real, public :: stm real, public :: zstm real, public :: tz real, public :: smz real, public :: zt real, public :: d2ndr2 real, public :: d2Tdr2 real, public :: bess_fac real, public, dimension(10) :: vnew integer, public :: type real, public :: dens_psi0 real, public :: temp_psi0 real, public :: stm_psi0 real, public :: zstm_psi0 real, public :: tz_psi0 real, public :: smz_psi0 real, public :: zt_psi0","tags":"","loc":"type/spec_type.html"},{"title":"eigen_type – stella ","text":"type, public :: eigen_type Components Type Visibility Attributes Name Initial complex, public, dimension(:, :), pointer :: zloc => null() integer, public, dimension(:), pointer :: idx => null()","tags":"","loc":"type/eigen_type.html"},{"title":"response_matrix_type – stella ","text":"type, public :: response_matrix_type Components Type Visibility Attributes Name Initial type( eigen_type ), public, dimension(:), pointer :: eigen => null()","tags":"","loc":"type/response_matrix_type.html"},{"title":"coupled_alpha_type – stella ","text":"type, public :: coupled_alpha_type Components Type Visibility Attributes Name Initial integer, public :: max_idx complex, public, dimension(:), pointer :: fourier => null()","tags":"","loc":"type/coupled_alpha_type.html"},{"title":"gam0_ffs_type – stella ","text":"type, public :: gam0_ffs_type Components Type Visibility Attributes Name Initial integer, public, dimension(:), pointer :: pivot_index => null() complex, public, dimension(:, :), pointer :: matrix => null()","tags":"","loc":"type/gam0_ffs_type.html"},{"title":"parse_extension – stella","text":"subroutine parse_extension(file_to_parse, file_or_extension, lnc) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: file_to_parse character(len=*), intent(in) :: file_or_extension logical, intent(out) :: lnc","tags":"","loc":"proc/parse_extension.html"},{"title":"curv2 – stella","text":"function curv2(t, n, x, y, yp, sigma) Arguments Type Intent Optional Attributes Name real :: t integer :: n real :: x (n) real :: y (n) real :: yp (n) real :: sigma Return Value real","tags":"","loc":"proc/curv2.html"},{"title":"curvd – stella","text":"function curvd(t, n, x, y, yp, sigma) Arguments Type Intent Optional Attributes Name real :: t integer :: n real :: x (n) real :: y (n) real :: yp (n) real :: sigma Return Value real","tags":"","loc":"proc/curvd.html"},{"title":"curvi – stella","text":"function curvi(xl, xu, n, x, y, yp, sigma) Arguments Type Intent Optional Attributes Name real :: xl real :: xu integer :: n real :: x (n) real :: y (n) real :: yp (n) real :: sigma Return Value real","tags":"","loc":"proc/curvi.html"},{"title":"curvp2 – stella","text":"function curvp2(t, n, x, y, p, yp, sigma) Arguments Type Intent Optional Attributes Name real :: t integer :: n real :: x (n) real :: y (n) real :: p real :: yp (n) real :: sigma Return Value real","tags":"","loc":"proc/curvp2.html"},{"title":"curvpi – stella","text":"function curvpi(xl, xu, n, x, y, p, yp, sigma) Arguments Type Intent Optional Attributes Name real :: xl real :: xu integer :: n real :: x (n) real :: y (n) real :: p real :: yp (n) real :: sigma Return Value real","tags":"","loc":"proc/curvpi.html"},{"title":"surf2 – stella","text":"function surf2(xx, yy, m, n, x, y, z, iz, zp, sigma) Arguments Type Intent Optional Attributes Name real :: xx real :: yy integer :: m integer :: n real :: x (m) real :: y (n) real :: z (iz,n) integer :: iz real :: zp (m,n,3) real :: sigma Return Value real","tags":"","loc":"proc/surf2.html"},{"title":"intrvl – stella","text":"function intrvl(t, x, n) Arguments Type Intent Optional Attributes Name real :: t real :: x (n) integer :: n Return Value integer","tags":"","loc":"proc/intrvl.html"},{"title":"intrvp – stella","text":"function intrvp(t, x, n, p, tp) Arguments Type Intent Optional Attributes Name real :: t real :: x (n) integer :: n real :: p real :: tp Return Value integer","tags":"","loc":"proc/intrvp.html"},{"title":"curv1 – stella","text":"subroutine curv1(n, x, y, slp1, slpn, islpsw, yp, temp, sigma, ierr) Arguments Type Intent Optional Attributes Name integer :: n real :: x (n) real :: y (n) real :: slp1 real :: slpn integer :: islpsw real :: yp (n) real :: temp (n) real :: sigma integer :: ierr","tags":"","loc":"proc/curv1.html"},{"title":"curvs – stella","text":"subroutine curvs(n, x, y, d, isw, s, eps, ys, ysp, sigma, temp, ierr) Arguments Type Intent Optional Attributes Name integer :: n real :: x (n) real :: y (n) real :: d (n) integer :: isw real :: s real :: eps real :: ys (n) real :: ysp (n) real :: sigma real :: temp (n,9) integer :: ierr","tags":"","loc":"proc/curvs.html"},{"title":"curvp1 – stella","text":"subroutine curvp1(n, x, y, p, yp, temp, sigma, ierr) Arguments Type Intent Optional Attributes Name integer :: n real :: x (n) real :: y (n) real :: p real :: yp (n) real :: temp (1) real :: sigma integer :: ierr","tags":"","loc":"proc/curvp1.html"},{"title":"curvps – stella","text":"subroutine curvps(n, x, y, p, d, isw, s, eps, ys, ysp, sigma, temp, ierr) Arguments Type Intent Optional Attributes Name integer :: n real :: x (n) real :: y (n) real :: p real :: d (n) integer :: isw real :: s real :: eps real :: ys (n) real :: ysp (n) real :: sigma real :: temp (n,11) integer :: ierr","tags":"","loc":"proc/curvps.html"},{"title":"kurv1 – stella","text":"subroutine kurv1(n, x, y, slp1, slpn, islpsw, xp, yp, temp, s, sigma, ierr) Arguments Type Intent Optional Attributes Name integer :: n real :: x (n) real :: y (n) real :: slp1 real :: slpn integer :: islpsw real :: xp (n) real :: yp (n) real :: temp (n) real :: s (n) real :: sigma integer :: ierr","tags":"","loc":"proc/kurv1.html"},{"title":"kurv2 – stella","text":"subroutine kurv2(t, xs, ys, n, x, y, xp, yp, s, sigma) Arguments Type Intent Optional Attributes Name real :: t real :: xs real :: ys integer :: n real :: x (n) real :: y (n) real :: xp (n) real :: yp (n) real :: s (n) real :: sigma","tags":"","loc":"proc/kurv2.html"},{"title":"kurvd – stella","text":"subroutine kurvd(t, xs, ys, xst, yst, xstt, ystt, n, x, y, xp, yp, s, sigma) Arguments Type Intent Optional Attributes Name real :: t real :: xs real :: ys real :: xst real :: yst real :: xstt real :: ystt integer :: n real :: x (n) real :: y (n) real :: xp (n) real :: yp (n) real :: s (n) real :: sigma","tags":"","loc":"proc/kurvd.html"},{"title":"kurvp1 – stella","text":"subroutine kurvp1(n, x, y, xp, yp, temp, s, sigma, ierr) Arguments Type Intent Optional Attributes Name integer :: n real :: x (n) real :: y (n) real :: xp (n) real :: yp (n) real :: temp (1) real :: s (n) real :: sigma integer :: ierr","tags":"","loc":"proc/kurvp1.html"},{"title":"kurvp2 – stella","text":"subroutine kurvp2(t, xs, ys, n, x, y, xp, yp, s, sigma) Arguments Type Intent Optional Attributes Name real :: t real :: xs real :: ys integer :: n real :: x (n) real :: y (n) real :: xp (n) real :: yp (n) real :: s (n) real :: sigma","tags":"","loc":"proc/kurvp2.html"},{"title":"kurvpd – stella","text":"subroutine kurvpd(t, xs, ys, xst, yst, xstt, ystt, n, x, y, xp, yp, s, sigma) Arguments Type Intent Optional Attributes Name real :: t real :: xs real :: ys real :: xst real :: yst real :: xstt real :: ystt integer :: n real :: x (n) real :: y (n) real :: xp (n) real :: yp (n) real :: s (n) real :: sigma","tags":"","loc":"proc/kurvpd.html"},{"title":"surf1 – stella","text":"subroutine surf1(m, n, x, y, z, iz, zx1, zxm, zy1, zyn, zxy11, zxym1, zxy1n, zxymn, islpsw, zp, temp, sigma, ierr) Arguments Type Intent Optional Attributes Name integer :: m integer :: n real :: x (m) real :: y (n) real :: z (iz,n) integer :: iz real :: zx1 (n) real :: zxm (n) real :: zy1 (m) real :: zyn (m) real :: zxy11 real :: zxym1 real :: zxy1n real :: zxymn integer :: islpsw real :: zp (m,n,3) real :: temp (1) real :: sigma integer :: ierr","tags":"","loc":"proc/surf1.html"},{"title":"ceez – stella","text":"subroutine ceez(del1, del2, sigma, c1, c2, c3, n) Arguments Type Intent Optional Attributes Name real :: del1 real :: del2 real :: sigma real :: c1 real :: c2 real :: c3 integer :: n","tags":"","loc":"proc/ceez.html"},{"title":"curvpp – stella","text":"subroutine curvpp(n, x, y, p, d, isw, s, eps, ys, ysp, sigma, td, tsd1, hd, hsd1, hsd2, rd, rsd1, rsd2, rnm1, rn, v, ierr) Arguments Type Intent Optional Attributes Name integer :: n real :: x (n) real :: y (n) real :: p real :: d (n) integer :: isw real :: s real :: eps real :: ys (n) real :: ysp (n) real :: sigma real :: td (n) real :: tsd1 (n) real :: hd (n) real :: hsd1 (n) real :: hsd2 (n) real :: rd (n) real :: rsd1 (n) real :: rsd2 (n) real :: rnm1 (n) real :: rn (n) real :: v (n) integer :: ierr","tags":"","loc":"proc/curvpp.html"},{"title":"curvss – stella","text":"subroutine curvss(n, x, y, d, isw, s, eps, ys, ysp, sigma, td, tsd1, hd, hsd1, hsd2, rd, rsd1, rsd2, v, ierr) Arguments Type Intent Optional Attributes Name integer :: n real :: x (n) real :: y (n) real :: d (n) integer :: isw real :: s real :: eps real :: ys (n) real :: ysp (n) real :: sigma real :: td (n) real :: tsd1 (n) real :: hd (n) real :: hsd1 (n) real :: hsd2 (n) real :: rd (n) real :: rsd1 (n) real :: rsd2 (n) real :: v (n) integer :: ierr","tags":"","loc":"proc/curvss.html"},{"title":"snhcsh – stella","text":"subroutine snhcsh(sinhm, coshm, x, isw) Arguments Type Intent Optional Attributes Name real :: sinhm real :: coshm real :: x integer :: isw","tags":"","loc":"proc/snhcsh.html"},{"title":"terms – stella","text":"subroutine terms(diag, sdiag, sigma, del) Arguments Type Intent Optional Attributes Name real :: diag real :: sdiag real :: sigma real :: del","tags":"","loc":"proc/terms.html"},{"title":"handle_err – stella","text":"subroutine handle_err(status, nam3, nam1, nam2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: status character(len=*), intent(in) :: nam3 character(len=*), intent(in) :: nam1 character(len=*), intent(in) :: nam2","tags":"","loc":"proc/handle_err.html"},{"title":"init_physics_flags – stella","text":"public  subroutine init_physics_flags() Arguments None","tags":"","loc":"proc/init_physics_flags.html"},{"title":"read_parameters – stella","text":"private  subroutine read_parameters() Uses file_utils text_options mp Arguments None Namelists Namelist physics_flags Variables Name Type Default Description full_flux_surface logical None radial_variation logical None include_parallel_nonlinearity logical None include_parallel_streaming logical None include_mirror logical None include_apar logical None include_bpar logical None nonlinear logical None include_pressure_variation logical None include_geometric_variation logical None adiabatic_option character(len=30) None const_alpha_geo logical None","tags":"","loc":"proc/read_parameters.html"},{"title":"finish_physics_flags – stella","text":"public  subroutine finish_physics_flags() Arguments None","tags":"","loc":"proc/finish_physics_flags.html"},{"title":"init_ccfftw – stella","text":"public  subroutine init_ccfftw(fft, is, n, data_in, data_out) Uses mp Arguments Type Intent Optional Attributes Name type( fft_type ), intent(out) :: fft integer, intent(in) :: is integer, intent(in) :: n complex, intent(inout), dimension(:) :: data_in complex, intent(inout), dimension(:) :: data_out","tags":"","loc":"proc/init_ccfftw.html"},{"title":"init_crfftw – stella","text":"public  subroutine init_crfftw(fft, is, n, data_in, data_out) Uses mp Arguments Type Intent Optional Attributes Name type( fft_type ), intent(out) :: fft integer, intent(in) :: is integer, intent(in) :: n complex, intent(inout), dimension(:) :: data_in real, intent(inout), dimension(:) :: data_out","tags":"","loc":"proc/init_crfftw.html"},{"title":"init_rcfftw – stella","text":"public  subroutine init_rcfftw(fft, is, n, data_in, data_out) Uses mp Arguments Type Intent Optional Attributes Name type( fft_type ), intent(out) :: fft integer, intent(in) :: is integer, intent(in) :: n real, intent(inout), dimension(:) :: data_in complex, intent(inout), dimension(:) :: data_out","tags":"","loc":"proc/init_rcfftw.html"},{"title":"delete_fft – stella","text":"public  subroutine delete_fft(fft) Arguments Type Intent Optional Attributes Name type( fft_type ), intent(inout) :: fft","tags":"","loc":"proc/delete_fft.html"},{"title":"init_extended_zgrid – stella","text":"public  subroutine init_extended_zgrid() Uses kt_grids zgrid constants phase shift due to the twist-and-shift boundary condition\nUsually set to zero for standard local simulation, but can\nhave an effect for global simulations and simulations with low\nmagnetic shear that use periodic boundary conditions everywhere all periodic modes (e.g., the zonal mode) have no connections\nphi(kx-kx_shift,-nzgrid) = phi(kx,nzgrid) from twist-and-shift BC\nfor positive (negative) magnetic shear, kx_shift is positive (negative),\nso start at most positive (negative) kx and\nprogress to smaller (larger) kx values as connections occur\nfigure out how much to shift ikx by to get to the end of the kx chain\nfor positive (negative) magnetic shear, this is the left-most (right-most) theta-theta0\nin each set of connected 2pi segments\nnote that theta0 goes from 0 to theta0_max and then from theta0_min back\nto -dtheta0\nfirst ikx_max=nakx/2+1 theta0s are 0 and all positive theta0 values\nremainder are negative theta0s\ntheta_0 = kx / ky / shat\nif ky > 0, then most positive theta_0 corresponds to most positive kx\nfirst consider case where shift in kx is negative (corresponds to positive magnetic shear)\nthen consider case where shift in kx is positive\nnote that zero shift case is taken care of by initialization of ikx_shift_end ikx_shift is how much to shift each ikx by to connect\nto the next theta0 (from most positive to most negative for positive magnetic shear\nand vice versa for negative magnetic shear)\nfirst consider shift in index for case where shift is negative\n(corresponds to positive magnetic shear)\nif ky > 0, then going to more negative theta0\ncorresponds to going to more negative kx\nif theta0 is sufficiently positive, shifting to more\nnegative theta0 corresponds to decreasing ikx\nif a positive theta0 connects to a negative theta0\nmust do more complicated mapping of ikx\nif theta0 is negative, then shifting to more negative\ntheta0 corresponds to decreasing ikx\nif theta0 is sufficiently negative, it has no\nmore negative theta0 with which it can connect\ntheta0 is positive\nif ky > 0, then going to more positive theta0\ncorresponds to going to more positive kx\nif shift in kx, kx_shift, is less than kx-kx_max,\nthen shift by the appropriate amount\notherwise, no kx on grid to connect with\nif kx+kx_shift < 0, then simple shift by neigen\nif 0 < kx+kx_shift <= kx_max, then more complicated shift\nto positive set of kx values\notherwise, no kx on grid with which to connect\nthis is the number of 2pi poloidal segments in the extended theta domain,\nwhich is needed in initializing the reponse matrix and doing the implicit sweep iz_low(j) is the ig index corresponding to the inboard midplane from below (theta=-pi) within the jth segment\niz_mid(j) is the ig index corresponding to the outboard midplane (theta=0) within the jth segment\ninitialize ikxmod to nakx\nshould not be necessary but just in case one tries to access\na value beyond nsegments(ie,iky)\nonly do the following once for each independent set of theta0s\nthe assumption here is that all kx are on processor and sequential\nremap to start at theta0 = theta0_max (theta0_min) for negative (positive) kx shift\nfor this set of connected theta0s\nthis is the number of unique zed values in all segments but the first\nthe first has one extra unique zed value (all others have one grid common\nwith the previous segment due to periodicity) Arguments None","tags":"","loc":"proc/init_extended_zgrid.html"},{"title":"fill_zed_ghost_zones – stella","text":"public  subroutine fill_zed_ghost_zones(it, iseg, ie, iky, g, gleft, gright) Uses zgrid Arguments Type Intent Optional Attributes Name integer, intent(in) :: it integer, intent(in) :: iseg integer, intent(in) :: ie integer, intent(in) :: iky complex, intent(in), dimension(:, :, -nzgrid:, :) :: g complex, intent(out), dimension(:) :: gleft complex, intent(out), dimension(:) :: gright","tags":"","loc":"proc/fill_zed_ghost_zones.html"},{"title":"fill_zext_ghost_zones – stella","text":"public  subroutine fill_zext_ghost_zones(iky, pdf_ext, pdf_left, pdf_right) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky complex, intent(in), dimension(:) :: pdf_ext complex, intent(out) :: pdf_left complex, intent(out) :: pdf_right","tags":"","loc":"proc/fill_zext_ghost_zones.html"},{"title":"map_to_extended_zgrid – stella","text":"public  subroutine map_to_extended_zgrid(it, ie, iky, g, gext, ulim) Uses zgrid Arguments Type Intent Optional Attributes Name integer, intent(in) :: it integer, intent(in) :: ie integer, intent(in) :: iky complex, intent(in), dimension(:, -nzgrid:, :) :: g complex, intent(out), dimension(:) :: gext integer, intent(out) :: ulim","tags":"","loc":"proc/map_to_extended_zgrid.html"},{"title":"map_from_extended_zgrid – stella","text":"public  subroutine map_from_extended_zgrid(it, ie, iky, gext, g) Uses zgrid Arguments Type Intent Optional Attributes Name integer, intent(in) :: it integer, intent(in) :: ie integer, intent(in) :: iky complex, intent(in), dimension(:) :: gext complex, intent(inout), dimension(:, -nzgrid:, :) :: g","tags":"","loc":"proc/map_from_extended_zgrid.html"},{"title":"map_to_iz_ikx_from_izext – stella","text":"public  subroutine map_to_iz_ikx_from_izext(iky, ie, iz_from_izext, ikx_from_izext) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky integer, intent(in) :: ie integer, intent(out), dimension(:) :: iz_from_izext integer, intent(out), dimension(:) :: ikx_from_izext","tags":"","loc":"proc/map_to_iz_ikx_from_izext.html"},{"title":"finish_extended_zgrid – stella","text":"public  subroutine finish_extended_zgrid() Arguments None","tags":"","loc":"proc/finish_extended_zgrid.html"},{"title":"init_tstart – stella","text":"public  subroutine init_tstart(tstart) Arguments Type Intent Optional Attributes Name real, intent(in) :: tstart","tags":"","loc":"proc/init_tstart.html"},{"title":"init_delt – stella","text":"public  subroutine init_delt(delt, delt_max, delt_min) Arguments Type Intent Optional Attributes Name real, intent(in) :: delt real, intent(in) :: delt_max real, intent(in) :: delt_min","tags":"","loc":"proc/init_delt.html"},{"title":"update_time – stella","text":"public  subroutine update_time() Arguments None","tags":"","loc":"proc/update_time.html"},{"title":"write_dt – stella","text":"public  subroutine write_dt() Arguments None","tags":"","loc":"proc/write_dt.html"},{"title":"checkcodedt – stella","text":"public  subroutine checkcodedt(stop_stella) Uses mp Arguments Type Intent Optional Attributes Name logical, intent(inout) :: stop_stella","tags":"","loc":"proc/checkcodedt.html"},{"title":"set_redist_character_type – stella","text":"public  subroutine set_redist_character_type(r, chartype) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r character(len=3), intent(in) :: chartype","tags":"","loc":"proc/set_redist_character_type.html"},{"title":"init_redist – stella","text":"public  subroutine init_redist(r, char, to_low, to_high, to_list, from_low, from_high, from_list, ierr) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r character(len=1), intent(in) :: char integer, intent(in), dimension(:) :: to_low integer, intent(in), dimension(:) :: to_high type( index_list_type ), intent(in), dimension(0:nproc - 1) :: to_list integer, intent(in), dimension(:) :: from_low integer, intent(in), dimension(:) :: from_high type( index_list_type ), intent(in), dimension(0:nproc - 1) :: from_list integer, intent(out), optional :: ierr","tags":"","loc":"proc/init_redist.html"},{"title":"init_fill – stella","text":"public  subroutine init_fill(f, char, to_low, to_list, from_low, from_list, ierr) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(out) :: f character(len=1), intent(in) :: char integer, intent(in), dimension(:) :: to_low type( index_list_type ), intent(in), dimension(0:nproc - 1) :: to_list integer, intent(in), dimension(:) :: from_low type( index_list_type ), intent(in), dimension(0:nproc - 1) :: from_list integer, intent(out), optional :: ierr","tags":"","loc":"proc/init_fill.html"},{"title":"delete_redist – stella","text":"public  subroutine delete_redist(r) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r","tags":"","loc":"proc/delete_redist.html"},{"title":"delete_list – stella","text":"public  subroutine delete_list(list) Uses mp Arguments Type Intent Optional Attributes Name type( index_list_type ), intent(inout), dimension(0:nproc - 1) :: list","tags":"","loc":"proc/delete_list.html"},{"title":"c_redist_12 – stella","text":"private  subroutine c_redist_12(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here","tags":"","loc":"proc/c_redist_12.html"},{"title":"c_redist_22 – stella","text":"private  subroutine c_redist_22(r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here","tags":"","loc":"proc/c_redist_22.html"},{"title":"c_redist_22_old_copy – stella","text":"private  subroutine c_redist_22_old_copy(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here","tags":"","loc":"proc/c_redist_22_old_copy.html"},{"title":"c_redist_22_mpi_copy – stella","text":"private  subroutine c_redist_22_mpi_copy(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here","tags":"","loc":"proc/c_redist_22_mpi_copy.html"},{"title":"c_redist_22_inv – stella","text":"private  subroutine c_redist_22_inv(r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here","tags":"","loc":"proc/c_redist_22_inv.html"},{"title":"c_redist_22_inv_old_copy – stella","text":"private  subroutine c_redist_22_inv_old_copy(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here","tags":"","loc":"proc/c_redist_22_inv_old_copy.html"},{"title":"c_redist_22_inv_mpi_copy – stella","text":"private  subroutine c_redist_22_inv_mpi_copy(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here","tags":"","loc":"proc/c_redist_22_inv_mpi_copy.html"},{"title":"c_redist_32 – stella","text":"private  subroutine c_redist_32(r, from_here, to_here) Uses job_manage Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here","tags":"","loc":"proc/c_redist_32.html"},{"title":"c_redist_32_old_copy – stella","text":"private  subroutine c_redist_32_old_copy(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here","tags":"","loc":"proc/c_redist_32_old_copy.html"},{"title":"c_redist_32_mpi_copy – stella","text":"private  subroutine c_redist_32_mpi_copy(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here","tags":"","loc":"proc/c_redist_32_mpi_copy.html"},{"title":"c_redist_32_inv – stella","text":"private  subroutine c_redist_32_inv(r, from_here, to_here) Uses job_manage Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here","tags":"","loc":"proc/c_redist_32_inv.html"},{"title":"c_redist_32_inv_old_copy – stella","text":"private  subroutine c_redist_32_inv_old_copy(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here","tags":"","loc":"proc/c_redist_32_inv_old_copy.html"},{"title":"c_redist_32_inv_mpi_copy – stella","text":"private  subroutine c_redist_32_inv_mpi_copy(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here","tags":"","loc":"proc/c_redist_32_inv_mpi_copy.html"},{"title":"c_redist_42 – stella","text":"private  subroutine c_redist_42(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here","tags":"","loc":"proc/c_redist_42.html"},{"title":"c_redist_42_inv – stella","text":"private  subroutine c_redist_42_inv(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: to_here","tags":"","loc":"proc/c_redist_42_inv.html"},{"title":"c_redist_23 – stella","text":"private  subroutine c_redist_23(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):) :: to_here","tags":"","loc":"proc/c_redist_23.html"},{"title":"c_redist_34 – stella","text":"private  subroutine c_redist_34(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):) :: to_here","tags":"","loc":"proc/c_redist_34.html"},{"title":"c_redist_34_inv – stella","text":"private  subroutine c_redist_34_inv(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here","tags":"","loc":"proc/c_redist_34_inv.html"},{"title":"r_redist_34 – stella","text":"private  subroutine r_redist_34(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):) :: to_here","tags":"","loc":"proc/r_redist_34.html"},{"title":"r_redist_34_inv – stella","text":"private  subroutine r_redist_34_inv(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here","tags":"","loc":"proc/r_redist_34_inv.html"},{"title":"c_redist_35 – stella","text":"private  subroutine c_redist_35(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):, r%to_low(5):) :: to_here","tags":"","loc":"proc/c_redist_35.html"},{"title":"r_redist_35 – stella","text":"private  subroutine r_redist_35(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):, r%to_low(5):) :: to_here","tags":"","loc":"proc/r_redist_35.html"},{"title":"c_redist_35_inv – stella","text":"private  subroutine c_redist_35_inv(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):, r%to_low(5):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here","tags":"","loc":"proc/c_redist_35_inv.html"},{"title":"r_redist_35_inv – stella","text":"private  subroutine r_redist_35_inv(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):, r%to_low(5):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here","tags":"","loc":"proc/r_redist_35_inv.html"},{"title":"r_redist_12 – stella","text":"private  subroutine r_redist_12(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here","tags":"","loc":"proc/r_redist_12.html"},{"title":"r_redist_22 – stella","text":"private  subroutine r_redist_22(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here","tags":"","loc":"proc/r_redist_22.html"},{"title":"r_redist_22_inv – stella","text":"private  subroutine r_redist_22_inv(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here","tags":"","loc":"proc/r_redist_22_inv.html"},{"title":"r_redist_32 – stella","text":"private  subroutine r_redist_32(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here","tags":"","loc":"proc/r_redist_32.html"},{"title":"r_redist_32_inv – stella","text":"private  subroutine r_redist_32_inv(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here","tags":"","loc":"proc/r_redist_32_inv.html"},{"title":"r_redist_42 – stella","text":"private  subroutine r_redist_42(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here","tags":"","loc":"proc/r_redist_42.html"},{"title":"r_redist_42_inv – stella","text":"private  subroutine r_redist_42_inv(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: to_here","tags":"","loc":"proc/r_redist_42_inv.html"},{"title":"i_redist_12 – stella","text":"private  subroutine i_redist_12(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%from_low(1):) :: from_here integer, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here","tags":"","loc":"proc/i_redist_12.html"},{"title":"i_redist_22 – stella","text":"private  subroutine i_redist_22(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here integer, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here","tags":"","loc":"proc/i_redist_22.html"},{"title":"i_redist_22_inv – stella","text":"private  subroutine i_redist_22_inv(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here integer, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here","tags":"","loc":"proc/i_redist_22_inv.html"},{"title":"i_redist_32 – stella","text":"private  subroutine i_redist_32(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here integer, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here","tags":"","loc":"proc/i_redist_32.html"},{"title":"i_redist_32_inv – stella","text":"private  subroutine i_redist_32_inv(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here integer, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here","tags":"","loc":"proc/i_redist_32_inv.html"},{"title":"i_redist_42 – stella","text":"private  subroutine i_redist_42(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: from_here integer, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here","tags":"","loc":"proc/i_redist_42.html"},{"title":"i_redist_42_inv – stella","text":"private  subroutine i_redist_42_inv(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here integer, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: to_here","tags":"","loc":"proc/i_redist_42_inv.html"},{"title":"l_redist_12 – stella","text":"private  subroutine l_redist_12(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%from_low(1):) :: from_here logical, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here","tags":"","loc":"proc/l_redist_12.html"},{"title":"l_redist_22 – stella","text":"private  subroutine l_redist_22(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here logical, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here","tags":"","loc":"proc/l_redist_22.html"},{"title":"l_redist_22_inv – stella","text":"private  subroutine l_redist_22_inv(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here logical, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here","tags":"","loc":"proc/l_redist_22_inv.html"},{"title":"l_redist_32 – stella","text":"private  subroutine l_redist_32(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here logical, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here","tags":"","loc":"proc/l_redist_32.html"},{"title":"l_redist_32_inv – stella","text":"private  subroutine l_redist_32_inv(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here logical, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here","tags":"","loc":"proc/l_redist_32_inv.html"},{"title":"l_redist_42 – stella","text":"private  subroutine l_redist_42(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: from_here logical, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here","tags":"","loc":"proc/l_redist_42.html"},{"title":"l_redist_42_inv – stella","text":"private  subroutine l_redist_42_inv(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here logical, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: to_here","tags":"","loc":"proc/l_redist_42_inv.html"},{"title":"c_redist_33 – stella","text":"private  subroutine c_redist_33(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):) :: to_here","tags":"","loc":"proc/c_redist_33.html"},{"title":"c_redist_33_inv – stella","text":"private  subroutine c_redist_33_inv(r, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here","tags":"","loc":"proc/c_redist_33_inv.html"},{"title":"c_fill_2 – stella","text":"private  subroutine c_fill_2(f, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f complex, intent(in), dimension(f%from_low(1):, f%from_low(2):) :: from_here complex, intent(inout), dimension(f%to_low(1):, f%to_low(2):) :: to_here","tags":"","loc":"proc/c_fill_2.html"},{"title":"c_fill_3 – stella","text":"private  subroutine c_fill_3(f, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f complex, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):) :: from_here complex, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):) :: to_here","tags":"","loc":"proc/c_fill_3.html"},{"title":"c_fill_4 – stella","text":"private  subroutine c_fill_4(f, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f complex, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):, f%from_low(4):) :: from_here complex, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):, f%to_low(4):) :: to_here","tags":"","loc":"proc/c_fill_4.html"},{"title":"r_fill_2 – stella","text":"private  subroutine r_fill_2(f, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f real, intent(in), dimension(f%from_low(1):, f%from_low(2):) :: from_here real, intent(inout), dimension(f%to_low(1):, f%to_low(2):) :: to_here","tags":"","loc":"proc/r_fill_2.html"},{"title":"r_fill_3 – stella","text":"private  subroutine r_fill_3(f, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f real, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):) :: from_here real, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):) :: to_here","tags":"","loc":"proc/r_fill_3.html"},{"title":"r_fill_4 – stella","text":"private  subroutine r_fill_4(f, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f real, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):, f%from_low(4):) :: from_here real, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):, f%to_low(4):) :: to_here","tags":"","loc":"proc/r_fill_4.html"},{"title":"i_fill_2 – stella","text":"private  subroutine i_fill_2(f, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f integer, intent(in), dimension(f%from_low(1):, f%from_low(2):) :: from_here integer, intent(inout), dimension(f%to_low(1):, f%to_low(2):) :: to_here","tags":"","loc":"proc/i_fill_2.html"},{"title":"i_fill_3 – stella","text":"private  subroutine i_fill_3(f, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f integer, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):) :: from_here integer, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):) :: to_here","tags":"","loc":"proc/i_fill_3.html"},{"title":"i_fill_4 – stella","text":"private  subroutine i_fill_4(f, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f integer, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):, f%from_low(4):) :: from_here integer, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):, f%to_low(4):) :: to_here","tags":"","loc":"proc/i_fill_4.html"},{"title":"l_fill_2 – stella","text":"private  subroutine l_fill_2(f, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f logical, intent(in), dimension(f%from_low(1):, f%from_low(2):) :: from_here logical, intent(inout), dimension(f%to_low(1):, f%to_low(2):) :: to_here","tags":"","loc":"proc/l_fill_2.html"},{"title":"l_fill_3 – stella","text":"private  subroutine l_fill_3(f, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f logical, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):) :: from_here logical, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):) :: to_here","tags":"","loc":"proc/l_fill_3.html"},{"title":"l_fill_4 – stella","text":"private  subroutine l_fill_4(f, from_here, to_here) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f logical, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):, f%from_low(4):) :: from_here logical, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):, f%to_low(4):) :: to_here","tags":"","loc":"proc/l_fill_4.html"},{"title":"report_map_property – stella","text":"public  subroutine report_map_property(r) Uses mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(in) :: r","tags":"","loc":"proc/report_map_property.html"},{"title":"measure_gather_32 – stella","text":"private  subroutine measure_gather_32(map, gin, gout) Uses job_manage mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :, :) :: gin complex, intent(out), dimension(:, :) :: gout","tags":"","loc":"proc/measure_gather_32.html"},{"title":"measure_scatter_23 – stella","text":"private  subroutine measure_scatter_23(map, gin, gout) Uses job_manage mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :, :) :: gout","tags":"","loc":"proc/measure_scatter_23.html"},{"title":"measure_gather_33 – stella","text":"private  subroutine measure_gather_33(map, gin, gout) Uses job_manage mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :, :) :: gin complex, intent(out), dimension(:, :, :) :: gout","tags":"","loc":"proc/measure_gather_33.html"},{"title":"measure_scatter_33 – stella","text":"private  subroutine measure_scatter_33(map, gin, gout) Uses job_manage mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :, :) :: gin complex, intent(out), dimension(:, :, :) :: gout","tags":"","loc":"proc/measure_scatter_33.html"},{"title":"measure_gather_22 – stella","text":"private  subroutine measure_gather_22(map, gin, gout) Uses job_manage mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout","tags":"","loc":"proc/measure_gather_22.html"},{"title":"measure_scatter_22 – stella","text":"private  subroutine measure_scatter_22(map, gin, gout) Uses job_manage mp Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout","tags":"","loc":"proc/measure_scatter_22.html"},{"title":"gather – stella","text":"public interface gather Module Procedures private  subroutine c_redist_22 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine r_redist_22 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine i_redist_22 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here integer, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine l_redist_22 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here logical, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine c_redist_32 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine r_redist_32 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine i_redist_32 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here integer, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine l_redist_32 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here logical, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine c_redist_42 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine r_redist_42 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine i_redist_42 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: from_here integer, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine l_redist_42 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: from_here logical, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine c_redist_23 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):) :: to_here private  subroutine c_redist_34 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):) :: to_here private  subroutine r_redist_34 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):) :: to_here private  subroutine c_redist_33 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):) :: to_here private  subroutine c_redist_35 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):, r%to_low(5):) :: to_here private  subroutine r_redist_35 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):, r%to_low(5):) :: to_here","tags":"","loc":"interface/gather.html"},{"title":"scatter – stella","text":"public interface scatter Module Procedures private  subroutine c_redist_12 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine r_redist_12 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine i_redist_12 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%from_low(1):) :: from_here integer, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine l_redist_12 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%from_low(1):) :: from_here logical, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine c_redist_22_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here private  subroutine r_redist_22_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here private  subroutine i_redist_22_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here integer, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here private  subroutine l_redist_22_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here logical, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here private  subroutine c_redist_32_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private  subroutine r_redist_32_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private  subroutine i_redist_32_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here integer, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private  subroutine l_redist_32_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here logical, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private  subroutine c_redist_42_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: to_here private  subroutine r_redist_42_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: to_here private  subroutine i_redist_42_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here integer, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: to_here private  subroutine l_redist_42_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here logical, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: to_here private  subroutine c_redist_33_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private  subroutine c_redist_34_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private  subroutine r_redist_34_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private  subroutine c_redist_35_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):, r%to_low(5):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private  subroutine r_redist_35_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):, r%to_low(5):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here","tags":"","loc":"interface/scatter.html"},{"title":"measure_gather – stella","text":"public interface measure_gather Module Procedures private  subroutine measure_gather_32 (map, gin, gout) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :, :) :: gin complex, intent(out), dimension(:, :) :: gout private  subroutine measure_gather_33 (map, gin, gout) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :, :) :: gin complex, intent(out), dimension(:, :, :) :: gout private  subroutine measure_gather_22 (map, gin, gout) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout","tags":"","loc":"interface/measure_gather.html"},{"title":"measure_scatter – stella","text":"public interface measure_scatter Module Procedures private  subroutine measure_scatter_23 (map, gin, gout) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :, :) :: gout private  subroutine measure_scatter_33 (map, gin, gout) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :, :) :: gin complex, intent(out), dimension(:, :, :) :: gout private  subroutine measure_scatter_22 (map, gin, gout) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout","tags":"","loc":"interface/measure_scatter.html"},{"title":"fill – stella","text":"public interface fill Module Procedures private  subroutine c_fill_2 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f complex, intent(in), dimension(f%from_low(1):, f%from_low(2):) :: from_here complex, intent(inout), dimension(f%to_low(1):, f%to_low(2):) :: to_here private  subroutine c_fill_3 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f complex, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):) :: from_here complex, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):) :: to_here private  subroutine c_fill_4 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f complex, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):, f%from_low(4):) :: from_here complex, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):, f%to_low(4):) :: to_here private  subroutine r_fill_2 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f real, intent(in), dimension(f%from_low(1):, f%from_low(2):) :: from_here real, intent(inout), dimension(f%to_low(1):, f%to_low(2):) :: to_here private  subroutine r_fill_3 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f real, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):) :: from_here real, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):) :: to_here private  subroutine r_fill_4 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f real, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):, f%from_low(4):) :: from_here real, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):, f%to_low(4):) :: to_here private  subroutine i_fill_2 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f integer, intent(in), dimension(f%from_low(1):, f%from_low(2):) :: from_here integer, intent(inout), dimension(f%to_low(1):, f%to_low(2):) :: to_here private  subroutine i_fill_3 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f integer, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):) :: from_here integer, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):) :: to_here private  subroutine i_fill_4 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f integer, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):, f%from_low(4):) :: from_here integer, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):, f%to_low(4):) :: to_here private  subroutine l_fill_2 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f logical, intent(in), dimension(f%from_low(1):, f%from_low(2):) :: from_here logical, intent(inout), dimension(f%to_low(1):, f%to_low(2):) :: to_here private  subroutine l_fill_3 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f logical, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):) :: from_here logical, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):) :: to_here private  subroutine l_fill_4 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f logical, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):, f%from_low(4):) :: from_here logical, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):, f%to_low(4):) :: to_here","tags":"","loc":"interface/fill.html"},{"title":"ranf – stella","text":"public  function ranf(seed) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: seed Return Value real","tags":"","loc":"proc/ranf.html"},{"title":"get_rnd_seed_length – stella","text":"public  function get_rnd_seed_length() result(l) Arguments None Return Value integer","tags":"","loc":"proc/get_rnd_seed_length.html"},{"title":"get_rnd_seed – stella","text":"public  subroutine get_rnd_seed(seed) Arguments Type Intent Optional Attributes Name integer, intent(out), dimension(:) :: seed","tags":"","loc":"proc/get_rnd_seed.html"},{"title":"init_ranf – stella","text":"public  subroutine init_ranf(randomize, init_seed, mult) Arguments Type Intent Optional Attributes Name logical, intent(in) :: randomize integer, intent(inout), dimension(:) :: init_seed integer, intent(in), optional :: mult","tags":"","loc":"proc/init_ranf.html"},{"title":"fitp_curv2 – stella","text":"public  function fitp_curv2(t, n, x, y, yp, sigma) Arguments Type Intent Optional Attributes Name real :: t integer :: n real :: x (n) real :: y (n) real :: yp (n) real :: sigma Return Value real","tags":"","loc":"proc/fitp_curv2.html"},{"title":"fitp_curvd – stella","text":"public  function fitp_curvd(t, n, x, y, yp, sigma) Arguments Type Intent Optional Attributes Name real :: t integer :: n real :: x (n) real :: y (n) real :: yp (n) real :: sigma Return Value real","tags":"","loc":"proc/fitp_curvd.html"},{"title":"fitp_curvi – stella","text":"public  function fitp_curvi(xl, xu, n, x, y, yp, sigma) Arguments Type Intent Optional Attributes Name real :: xl real :: xu integer :: n real :: x (n) real :: y (n) real :: yp (n) real :: sigma Return Value real","tags":"","loc":"proc/fitp_curvi.html"},{"title":"fitp_curvp2 – stella","text":"public  function fitp_curvp2(t, n, x, y, p, yp, sigma) Arguments Type Intent Optional Attributes Name real :: t integer :: n real, dimension(:) :: x real, dimension(:) :: y real :: p real, dimension(:) :: yp real :: sigma Return Value real","tags":"","loc":"proc/fitp_curvp2.html"},{"title":"fitp_curvpd – stella","text":"public  function fitp_curvpd(t, n, x, y, p, yp, sigma) Arguments Type Intent Optional Attributes Name real :: t integer :: n real :: x (n) real :: y (n) real :: p real :: yp (n) real :: sigma Return Value real","tags":"","loc":"proc/fitp_curvpd.html"},{"title":"fitp_curvpi – stella","text":"public  function fitp_curvpi(xl, xu, n, x, y, p, yp, sigma) Arguments Type Intent Optional Attributes Name real :: xl real :: xu integer :: n real :: x (n) real :: y (n) real :: p real :: yp (n) real :: sigma Return Value real","tags":"","loc":"proc/fitp_curvpi.html"},{"title":"fitp_surf2 – stella","text":"public  function fitp_surf2(xx, yy, m, n, x, y, z, iz, zp, sigma) Arguments Type Intent Optional Attributes Name real :: xx real :: yy integer :: m integer :: n real :: x (m) real :: y (n) real :: z (iz,n) integer :: iz real :: zp (m,n,3) real :: sigma Return Value real","tags":"","loc":"proc/fitp_surf2.html"},{"title":"fitp_intrvl – stella","text":"public  function fitp_intrvl(t, x, n) Arguments Type Intent Optional Attributes Name real :: t real :: x (n) integer :: n Return Value integer","tags":"","loc":"proc/fitp_intrvl.html"},{"title":"fitp_intrvp – stella","text":"public  function fitp_intrvp(t, x, n, p, tp) Arguments Type Intent Optional Attributes Name real :: t real :: x (n) integer :: n real :: p real :: tp Return Value integer","tags":"","loc":"proc/fitp_intrvp.html"},{"title":"dedge – stella","text":"public  function dedge(a, r, n, iside) Arguments Type Intent Optional Attributes Name real :: a (n) real :: r (n) integer :: n integer :: iside Return Value real","tags":"","loc":"proc/dedge.html"},{"title":"fitp_curv1 – stella","text":"public  subroutine fitp_curv1(n, x, y, slp1, slpn, islpsw, yp, temp, sigma, ierr) Arguments Type Intent Optional Attributes Name integer :: n real :: x (n) real :: y (n) real :: slp1 real :: slpn integer :: islpsw real :: yp (n) real :: temp (n) real :: sigma integer :: ierr","tags":"","loc":"proc/fitp_curv1.html"},{"title":"fitp_curvs – stella","text":"public  subroutine fitp_curvs(n, x, y, d, isw, s, eps, ys, ysp, sigma, temp, ierr) Arguments Type Intent Optional Attributes Name integer :: n real :: x (n) real :: y (n) real :: d (n) integer :: isw real :: s real :: eps real :: ys (n) real :: ysp (n) real :: sigma real :: temp (n,9) integer :: ierr","tags":"","loc":"proc/fitp_curvs.html"},{"title":"fitp_curvp1 – stella","text":"public  subroutine fitp_curvp1(n, x, y, p, yp, temp, sigma, ierr) Arguments Type Intent Optional Attributes Name integer :: n real, dimension(:) :: x real, dimension(:) :: y real :: p real, dimension(:) :: yp real, dimension(:) :: temp real :: sigma integer :: ierr","tags":"","loc":"proc/fitp_curvp1.html"},{"title":"fitp_curvps – stella","text":"public  subroutine fitp_curvps(n, x, y, p, d, isw, s, eps, ys, ysp, sigma, temp, ierr) Arguments Type Intent Optional Attributes Name integer :: n real :: x (n) real :: y (n) real :: p real :: d (n) integer :: isw real :: s real :: eps real :: ys (n) real :: ysp (n) real :: sigma real :: temp (n,11) integer :: ierr","tags":"","loc":"proc/fitp_curvps.html"},{"title":"fitp_kurv1 – stella","text":"public  subroutine fitp_kurv1(n, x, y, slp1, slpn, islpsw, xp, yp, temp, s, sigma, ierr) Arguments Type Intent Optional Attributes Name integer :: n real :: x (n) real :: y (n) real :: slp1 real :: slpn integer :: islpsw real :: xp (n) real :: yp (n) real :: temp (n) real :: s (n) real :: sigma integer :: ierr","tags":"","loc":"proc/fitp_kurv1.html"},{"title":"fitp_kurv2 – stella","text":"public  subroutine fitp_kurv2(t, xs, ys, n, x, y, xp, yp, s, sigma) Arguments Type Intent Optional Attributes Name real :: t real :: xs real :: ys integer :: n real :: x (n) real :: y (n) real :: xp (n) real :: yp (n) real :: s (n) real :: sigma","tags":"","loc":"proc/fitp_kurv2.html"},{"title":"fitp_kurvd – stella","text":"public  subroutine fitp_kurvd(t, xs, ys, xst, yst, xstt, ystt, n, x, y, xp, yp, s, sigma) Arguments Type Intent Optional Attributes Name real :: t real :: xs real :: ys real :: xst real :: yst real :: xstt real :: ystt integer :: n real :: x (n) real :: y (n) real :: xp (n) real :: yp (n) real :: s (n) real :: sigma","tags":"","loc":"proc/fitp_kurvd.html"},{"title":"fitp_kurvp1 – stella","text":"public  subroutine fitp_kurvp1(n, x, y, xp, yp, temp, s, sigma, ierr) Arguments Type Intent Optional Attributes Name integer :: n real :: x (n) real :: y (n) real :: xp (n) real :: yp (n) real :: temp (1) real :: s (n) real :: sigma integer :: ierr","tags":"","loc":"proc/fitp_kurvp1.html"},{"title":"fitp_kurvp2 – stella","text":"public  subroutine fitp_kurvp2(t, xs, ys, n, x, y, xp, yp, s, sigma) Arguments Type Intent Optional Attributes Name real :: t real :: xs real :: ys integer :: n real :: x (n) real :: y (n) real :: xp (n) real :: yp (n) real :: s (n) real :: sigma","tags":"","loc":"proc/fitp_kurvp2.html"},{"title":"fitp_kurvpd – stella","text":"public  subroutine fitp_kurvpd(t, xs, ys, xst, yst, xstt, ystt, n, x, y, xp, yp, s, sigma) Arguments Type Intent Optional Attributes Name real :: t real :: xs real :: ys real :: xst real :: yst real :: xstt real :: ystt integer :: n real :: x (n) real :: y (n) real :: xp (n) real :: yp (n) real :: s (n) real :: sigma","tags":"","loc":"proc/fitp_kurvpd.html"},{"title":"fitp_surf1 – stella","text":"public  subroutine fitp_surf1(m, n, x, y, z, iz, zx1, zxm, zy1, zyn, zxy11, zxym1, zxy1n, zxymn, islpsw, zp, temp, sigma, ierr) Arguments Type Intent Optional Attributes Name integer :: m integer :: n real :: x (m) real :: y (n) real :: z (iz,n) integer :: iz real :: zx1 (n) real :: zxm (n) real :: zy1 (m) real :: zyn (m) real :: zxy11 real :: zxym1 real :: zxy1n real :: zxymn integer :: islpsw real :: zp (m,n,3) real :: temp (n+n+m) real :: sigma integer :: ierr","tags":"","loc":"proc/fitp_surf1.html"},{"title":"fitp_ceez – stella","text":"public  subroutine fitp_ceez(del1, del2, sigma, c1, c2, c3, n) Arguments Type Intent Optional Attributes Name real :: del1 real :: del2 real :: sigma real :: c1 real :: c2 real :: c3 integer :: n","tags":"","loc":"proc/fitp_ceez.html"},{"title":"fitp_curvpp – stella","text":"public  subroutine fitp_curvpp(n, x, y, p, d, isw, s, eps, ys, ysp, sigma, td, tsd1, hd, hsd1, hsd2, rd, rsd1, rsd2, rnm1, rn, v, ierr) Arguments Type Intent Optional Attributes Name integer :: n real :: x (n) real :: y (n) real :: p real :: d (n) integer :: isw real :: s real :: eps real :: ys (n) real :: ysp (n) real :: sigma real :: td (n) real :: tsd1 (n) real :: hd (n) real :: hsd1 (n) real :: hsd2 (n) real :: rd (n) real :: rsd1 (n) real :: rsd2 (n) real :: rnm1 (n) real :: rn (n) real :: v (n) integer :: ierr","tags":"","loc":"proc/fitp_curvpp.html"},{"title":"fitp_curvss – stella","text":"public  subroutine fitp_curvss(n, x, y, d, isw, s, eps, ys, ysp, sigma, td, tsd1, hd, hsd1, hsd2, rd, rsd1, rsd2, v, ierr) Arguments Type Intent Optional Attributes Name integer :: n real :: x (n) real :: y (n) real :: d (n) integer :: isw real :: s real :: eps real :: ys (n) real :: ysp (n) real :: sigma real :: td (n) real :: tsd1 (n) real :: hd (n) real :: hsd1 (n) real :: hsd2 (n) real :: rd (n) real :: rsd1 (n) real :: rsd2 (n) real :: v (n) integer :: ierr","tags":"","loc":"proc/fitp_curvss.html"},{"title":"fitp_snhcsh – stella","text":"public  subroutine fitp_snhcsh(sinhm, coshm, x, isw) Arguments Type Intent Optional Attributes Name real :: sinhm real :: coshm real :: x integer :: isw","tags":"","loc":"proc/fitp_snhcsh.html"},{"title":"fitp_terms – stella","text":"public  subroutine fitp_terms(diag, sdiag, sigma, del) Arguments Type Intent Optional Attributes Name real :: diag real :: sdiag real :: sigma real :: del","tags":"","loc":"proc/fitp_terms.html"},{"title":"geo_spline_real – stella","text":"public  subroutine geo_spline_real(x, y, xint, yint) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: x real, intent(in), dimension(:) :: y real, intent(in) :: xint real, intent(out) :: yint","tags":"","loc":"proc/geo_spline_real.html"},{"title":"geo_spline_array – stella","text":"public  subroutine geo_spline_array(x, y, xint, yint) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: x real, intent(in), dimension(:) :: y real, intent(in), dimension(:) :: xint real, intent(out), dimension(:) :: yint","tags":"","loc":"proc/geo_spline_array.html"},{"title":"linear_interp_periodic – stella","text":"public  subroutine linear_interp_periodic(x, y, xint, yint, period) Uses constants Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: x real, intent(in), dimension(:) :: y real, intent(in), dimension(:) :: xint real, intent(out), dimension(:) :: yint real, intent(in), optional :: period","tags":"","loc":"proc/linear_interp_periodic.html"},{"title":"geo_spline – stella","text":"public interface geo_spline Module Procedures public  subroutine geo_spline_real (x, y, xint, yint) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: x real, intent(in), dimension(:) :: y real, intent(in) :: xint real, intent(out) :: yint public  subroutine geo_spline_array (x, y, xint, yint) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: x real, intent(in), dimension(:) :: y real, intent(in), dimension(:) :: xint real, intent(out), dimension(:) :: yint","tags":"","loc":"interface/geo_spline.html"},{"title":"sort_array_ascending – stella","text":"public  subroutine sort_array_ascending(array, sort_index) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: array integer, intent(out), dimension(:) :: sort_index","tags":"","loc":"proc/sort_array_ascending.html"},{"title":"unsort_array_ascending – stella","text":"public  subroutine unsort_array_ascending(array, sort_index) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: array integer, intent(in), dimension(:) :: sort_index","tags":"","loc":"proc/unsort_array_ascending.html"},{"title":"stella_save_for_restart – stella","text":"public  subroutine stella_save_for_restart(g, istep0, t0, delt0, istatus, exit_in, fileopt) Uses mp common_types zgrid stella_layouts file_utils sources vpamu_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g integer, intent(in) :: istep0 real, intent(in) :: t0 real, intent(in) :: delt0 integer, intent(out) :: istatus logical, intent(in), optional :: exit_in character(len=20), intent(in), optional :: fileopt","tags":"","loc":"proc/stella_save_for_restart.html"},{"title":"stella_restore_many – stella","text":"private  subroutine stella_restore_many(g, scale, istatus) Uses mp zgrid stella_layouts file_utils sources vpamu_grids Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :, kxkyz_lo%llim_proc:) :: g real, intent(in) :: scale integer, intent(out) :: istatus","tags":"","loc":"proc/stella_restore_many.html"},{"title":"init_save – stella","text":"public  subroutine init_save(file) Arguments Type Intent Optional Attributes Name character(len=300), intent(in) :: file","tags":"","loc":"proc/init_save.html"},{"title":"init_dt – stella","text":"public  subroutine init_dt(delt0, istatus) Arguments Type Intent Optional Attributes Name real, intent(inout) :: delt0 integer, intent(out) :: istatus","tags":"","loc":"proc/init_dt.html"},{"title":"init_tstart – stella","text":"public  subroutine init_tstart(tstart, istep0, istatus) Arguments Type Intent Optional Attributes Name real, intent(inout) :: tstart integer, intent(out) :: istep0 integer, intent(out) :: istatus","tags":"","loc":"proc/init_tstart~2.html"},{"title":"finish_save – stella","text":"public  subroutine finish_save() Arguments None","tags":"","loc":"proc/finish_save.html"},{"title":"stella_restore – stella","text":"public interface stella_restore Module Procedures private  subroutine stella_restore_many (g, scale, istatus) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :, kxkyz_lo%llim_proc:) :: g real, intent(in) :: scale integer, intent(out) :: istatus","tags":"","loc":"interface/stella_restore.html"},{"title":"init_gxyz – stella","text":"public  subroutine init_gxyz(restarted) Uses zgrid dist_fn_arrays dist_redistribute species stella_layouts physics_flags stella_geometry kt_grids vpamu_grids stella_transforms redistribute Arguments Type Intent Optional Attributes Name logical, intent(in) :: restarted","tags":"","loc":"proc/init_gxyz.html"},{"title":"init_dist_fn – stella","text":"public  subroutine init_dist_fn() Uses physics_flags mp stella_layouts gyro_averages allocate and initialise kperp2 and dkperp2dr\nallocate and initialise vperp2\ninit_bessel sets up arrays needed for gyro-averaging;\nfor a flux tube simulation, this is j0 and j1;\nfor a flux annulus simulation, gyro-averaging is non-local in ky\nand so more effort is required Arguments None","tags":"","loc":"proc/init_dist_fn.html"},{"title":"init_kperp2 – stella","text":"private  subroutine init_kperp2() Uses kt_grids zgrid stella_geometry dist_fn_arrays init_kperp2 allocates and initialises the kperp2 array allocate the kperp2 array to contain |k_perp|&#94;2 Arguments None","tags":"","loc":"proc/init_kperp2.html"},{"title":"init_dkperp2dr – stella","text":"private  subroutine init_dkperp2dr() Uses kt_grids zgrid stella_geometry dist_fn_arrays init_dkperp2dr allocates and initialises the dkperp2dr array, needed for radial variation Arguments None","tags":"","loc":"proc/init_dkperp2dr.html"},{"title":"enforce_single_valued_kperp2 – stella","text":"private  subroutine enforce_single_valued_kperp2() Uses kt_grids zgrid dist_fn_arrays extended_zgrid Arguments None","tags":"","loc":"proc/enforce_single_valued_kperp2.html"},{"title":"allocate_arrays – stella","text":"private  subroutine allocate_arrays() Uses zgrid dist_fn_arrays stella_layouts kt_grids vpamu_grids Arguments None","tags":"","loc":"proc/allocate_arrays.html"},{"title":"init_vperp2 – stella","text":"private  subroutine init_vperp2() Uses kt_grids vpamu_grids zgrid stella_geometry Arguments None","tags":"","loc":"proc/init_vperp2.html"},{"title":"finish_dist_fn – stella","text":"public  subroutine finish_dist_fn() Uses gyro_averages Arguments None","tags":"","loc":"proc/finish_dist_fn.html"},{"title":"deallocate_arrays – stella","text":"private  subroutine deallocate_arrays() Uses dist_fn_arrays Arguments None","tags":"","loc":"proc/deallocate_arrays.html"},{"title":"finish_kperp2 – stella","text":"private  subroutine finish_kperp2() Uses dist_fn_arrays Arguments None","tags":"","loc":"proc/finish_kperp2.html"},{"title":"finish_vperp2 – stella","text":"private  subroutine finish_vperp2() Uses vpamu_grids Arguments None","tags":"","loc":"proc/finish_vperp2.html"},{"title":"checksum_field – stella","text":"private  subroutine checksum_field(field, total) Uses kt_grids zgrid extended_zgrid Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: field real, intent(out) :: total","tags":"","loc":"proc/checksum_field.html"},{"title":"checksum_dist – stella","text":"private  subroutine checksum_dist(dist, total, norm) Uses mp zgrid stella_layouts kt_grids vpamu_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dist real, intent(out) :: total logical, intent(in), optional :: norm","tags":"","loc":"proc/checksum_dist.html"},{"title":"checksum – stella","text":"public interface checksum Module Procedures private  subroutine checksum_field (field, total) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: field real, intent(out) :: total private  subroutine checksum_dist (dist, total, norm) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dist real, intent(out) :: total logical, intent(in), optional :: norm","tags":"","loc":"interface/checksum.html"},{"title":"init_response_matrix – stella","text":"public  subroutine init_response_matrix() Uses kt_grids mp run_parameters fields_arrays Arguments None","tags":"","loc":"proc/init_response_matrix.html"},{"title":"write_response_matrix_message – stella","text":"private  subroutine write_response_matrix_message() Arguments None","tags":"","loc":"proc/write_response_matrix_message.html"},{"title":"setup_response_matrix_timings – stella","text":"private  subroutine setup_response_matrix_timings() Arguments None","tags":"","loc":"proc/setup_response_matrix_timings.html"},{"title":"setup_response_matrix_file_io – stella","text":"private  subroutine setup_response_matrix_file_io() Uses kt_grids system_fortran mp run_parameters Arguments None","tags":"","loc":"proc/setup_response_matrix_file_io.html"},{"title":"setup_shared_memory_window – stella","text":"private  subroutine setup_shared_memory_window() Uses mp mpi fields extended_zgrid fields_arrays kt_grids iso_c_binding Arguments None","tags":"","loc":"proc/setup_shared_memory_window.html"},{"title":"construct_response_matrix – stella","text":"private  subroutine construct_response_matrix() Uses job_manage mp extended_zgrid fields_arrays kt_grids run_parameters Arguments None","tags":"","loc":"proc/construct_response_matrix.html"},{"title":"calculate_vspace_integrated_response – stella","text":"private  subroutine calculate_vspace_integrated_response(iky) Uses mp stella_layouts physics_flags fields extended_zgrid run_parameters Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky","tags":"","loc":"proc/calculate_vspace_integrated_response.html"},{"title":"setup_response_matrix_zloc_idx – stella","text":"private  subroutine setup_response_matrix_zloc_idx(iky, ie, nresponse) Uses fields_arrays Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky integer, intent(in) :: ie integer, intent(in) :: nresponse","tags":"","loc":"proc/setup_response_matrix_zloc_idx.html"},{"title":"apply_field_solve_to_finish_response_matrix – stella","text":"private  subroutine apply_field_solve_to_finish_response_matrix(iky) Uses physics_flags extended_zgrid fields_arrays set up offset_apar and offset_bpar consistently\nso that the array slices below are consistent with\nthe size of the response matrix Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky","tags":"","loc":"proc/apply_field_solve_to_finish_response_matrix.html"},{"title":"lu_decompose_response_matrix – stella","text":"private  subroutine lu_decompose_response_matrix(iky) Uses mp linear_solve extended_zgrid fields_arrays run_parameters Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky","tags":"","loc":"proc/lu_decompose_response_matrix.html"},{"title":"read_response_matrix – stella","text":"public  subroutine read_response_matrix() Uses mp common_types fields extended_zgrid fields_arrays kt_grids Arguments None","tags":"","loc":"proc/read_response_matrix.html"},{"title":"get_dpdf_dphi_matrix_column – stella","text":"private  subroutine get_dpdf_dphi_matrix_column(iky, ie, idx, nz_ext, nresponse, phi_ext, apar_ext, bpar_ext, pdf_ext) Uses physics_flags stella_layouts implicit_solve extended_zgrid fields_arrays run_parameters Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky integer, intent(in) :: ie integer, intent(in) :: idx integer, intent(in) :: nz_ext integer, intent(in) :: nresponse complex, intent(out), dimension(:) :: phi_ext complex, intent(out), dimension(:) :: apar_ext complex, intent(out), dimension(:) :: bpar_ext complex, intent(out), dimension(:, vmu_lo%llim_proc:) :: pdf_ext","tags":"","loc":"proc/get_dpdf_dphi_matrix_column.html"},{"title":"get_dpdf_dapar_matrix_column – stella","text":"private  subroutine get_dpdf_dapar_matrix_column(iky, ie, idx, nz_ext, nresponse, phi_ext, apar_ext, bpar_ext, pdf_ext) Uses physics_flags stella_layouts implicit_solve extended_zgrid fields_arrays run_parameters Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky integer, intent(in) :: ie integer, intent(in) :: idx integer, intent(in) :: nz_ext integer, intent(in) :: nresponse complex, intent(out), dimension(:) :: phi_ext complex, intent(out), dimension(:) :: apar_ext complex, intent(out), dimension(:) :: bpar_ext complex, intent(out), dimension(:, vmu_lo%llim_proc:) :: pdf_ext","tags":"","loc":"proc/get_dpdf_dapar_matrix_column.html"},{"title":"get_dpdf_dbpar_matrix_column – stella","text":"private  subroutine get_dpdf_dbpar_matrix_column(iky, ie, idx, nz_ext, nresponse, phi_ext, apar_ext, bpar_ext, pdf_ext) Uses physics_flags stella_layouts implicit_solve extended_zgrid fields_arrays run_parameters Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky integer, intent(in) :: ie integer, intent(in) :: idx integer, intent(in) :: nz_ext integer, intent(in) :: nresponse complex, intent(out), dimension(:) :: phi_ext complex, intent(out), dimension(:) :: apar_ext complex, intent(out), dimension(:) :: bpar_ext complex, intent(out), dimension(:, vmu_lo%llim_proc:) :: pdf_ext","tags":"","loc":"proc/get_dpdf_dbpar_matrix_column.html"},{"title":"integrate_over_velocity – stella","text":"private  subroutine integrate_over_velocity(g, phi, apar, bpar, iky, ie) Uses physics_flags stella_layouts Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:) :: phi complex, intent(out), dimension(:) :: apar complex, intent(out), dimension(:) :: bpar integer, intent(in) :: iky integer, intent(in) :: ie","tags":"","loc":"proc/integrate_over_velocity.html"},{"title":"integrate_over_velocity_phi – stella","text":"private  subroutine integrate_over_velocity_phi(g, phi, iky, ie) Uses mp species stella_layouts gyro_averages extended_zgrid vpamu_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:) :: phi integer, intent(in) :: iky integer, intent(in) :: ie","tags":"","loc":"proc/integrate_over_velocity_phi.html"},{"title":"integrate_over_velocity_bpar – stella","text":"private  subroutine integrate_over_velocity_bpar(g, bpar, iky, ie) Uses physics_parameters mp species stella_layouts gyro_averages extended_zgrid vpamu_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:) :: bpar integer, intent(in) :: iky integer, intent(in) :: ie","tags":"","loc":"proc/integrate_over_velocity_bpar.html"},{"title":"integrate_over_velocity_apar – stella","text":"private  subroutine integrate_over_velocity_apar(g, apar, iky, ie) Uses physics_parameters mp species stella_layouts gyro_averages extended_zgrid vpamu_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:) :: apar integer, intent(in) :: iky integer, intent(in) :: ie","tags":"","loc":"proc/integrate_over_velocity_apar.html"},{"title":"get_fields_for_response_matrix – stella","text":"private  subroutine get_fields_for_response_matrix(phi, apar, bpar, iky, ie, dist) Uses physics_flags Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: phi complex, intent(inout), dimension(:) :: apar complex, intent(inout), dimension(:) :: bpar integer, intent(in) :: iky integer, intent(in) :: ie character(len=*), intent(in) :: dist","tags":"","loc":"proc/get_fields_for_response_matrix.html"},{"title":"get_phi_for_response_matrix – stella","text":"private  subroutine get_phi_for_response_matrix(phi, iky, ie, dist) Uses zgrid species physics_flags fields extended_zgrid fields_arrays kt_grids stella_geometry Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: phi integer, intent(in) :: iky integer, intent(in) :: ie character(len=*), intent(in) :: dist","tags":"","loc":"proc/get_phi_for_response_matrix.html"},{"title":"get_phi_and_bpar_for_response_matrix – stella","text":"private  subroutine get_phi_and_bpar_for_response_matrix(phi, bpar, iky, ie, dist) Uses zgrid mp species physics_flags fields extended_zgrid fields_arrays kt_grids Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: phi complex, intent(inout), dimension(:) :: bpar integer, intent(in) :: iky integer, intent(in) :: ie character(len=*), intent(in) :: dist","tags":"","loc":"proc/get_phi_and_bpar_for_response_matrix.html"},{"title":"get_apar_for_response_matrix – stella","text":"private  subroutine get_apar_for_response_matrix(apar, iky, ie, dist) Uses zgrid dist_fn_arrays fields extended_zgrid kt_grids Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: apar integer, intent(in) :: iky integer, intent(in) :: ie character(len=*), intent(in) :: dist","tags":"","loc":"proc/get_apar_for_response_matrix.html"},{"title":"finish_response_matrix – stella","text":"public  subroutine finish_response_matrix() Uses fields_arrays Arguments None","tags":"","loc":"proc/finish_response_matrix.html"},{"title":"parallel_LU_decomposition_global – stella","text":"private  subroutine parallel_LU_decomposition_global(iky) Uses job_manage mp linear_solve extended_zgrid fields_arrays mpi Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky","tags":"","loc":"proc/parallel_lu_decomposition_global.html"},{"title":"init_geometry – stella","text":"public  subroutine init_geometry(nalpha, naky) Uses mp zgrid vmec_to_stella_geometry_interface_mod millerlocal file_utils physics_flags vmec_geo constants inputprofiles_interface b_dot_grad_z is the alpha-dependent b . grad z,\nand gradpar is the constant-in-alpha part of it.\nfor axisymmetric systems, b_dot_grad_z is independent of alpha. | grad x |  = dx/drho * | grad rho | = dx/dpsi * dpsi/drho * | grad rho |\n= q/rho * dpsidrho * grho b_dot_grad_z is the alpha-dependent b . grad z,\nand gradpar is the constant-in-alpha part of it.\nfor axisymmetric systems, b_dot_grad_z is independent of alpha. | grad x |  = dx/drho * | grad rho | = dx/dpsi * dpsi/drho * | grad rho |\n= q/rho * dpsidrho * grho b_dot_grad_z is the alpha-dependent b . grad z,\nand gradpar is the constant-in-alpha part of it.\nfor axisymmetric systems, b_dot_grad_z is independent of alpha. | grad x |  = dx/drho * | grad rho | = dx/dpsi * dpsi/drho * | grad rho |\n= q/rho * dpsidrho * grho read in input parameters for vmec\nnalpha may be specified via input file\nallocate geometry arrays\nget geometry coefficients from vmec\nabs(twist_and_shift_geo_fac) is dkx/dky * jtwist\nminus its sign gives the direction of the shift in kx\nto be used for twist-and-shift BC\nThe code will start computing for the initial zgrid\nDefine = (ρref/a)(dx̃/dψ̃) and use dx/dψ = 1/(a ρ0 Bref)\ndxdXcoord = (ρref/a)(dx̃/dψ̃) = (ρref/a)(d(x/ρref)/d(ψ/(a&#94;2 Bref)) = a Bref (dx/dψ) = 1/ρ0 Define = (ρref/a)(dỹ/dα̃) and use dy/dα = a*ρ0\ndydalpha = (ρref/a)(dỹ/dα̃) = (ρref/a)(d(y/ρref)/dα) = (1/a) (dy/dα) = ρ0 Define = dρ0/dψ̃ and use ρ0 = sqrt(psi_t/psi_{t,LCFS}) and ψ = sgn(psi_t)*psi_t\nUse dρ0/dpsi_t = d(sqrt(psi_t/psi_{t,LCFS}))/dpsi_t = sgn(psi_t)/(a&#94;2 ρ0 Bref) with Bref = 2 |psi_{t,LCFS}| / a&#94;2\ndrhodpsi = dρ0/dψ̃ = dρ0/d(ψ/(a&#94;2 Bref)) = a&#94;2 Bref sgn(psi_t) dρ0/dpsi_t = 1/ρ0\ngrad_x = | grad x | gds2 = |grad y|&#94;2 = |grad alpha|&#94;2 * (dy/dalpha)&#94;2\nnote that rhotor = sqrt(psi/psi_LCFS) Define = hat{s} ∇x . ∇y\nUse (dx/dψ)*(dy/dα) = 1/(a ρ0 Bref) * (a ρ0) = 1/Bref\nUse ∇x . ∇y = (dx/dψ)(dy/dα) ∇ψ . ∇α = (1/Bref) ∇ψ . ∇α = gds22 = shat&#94;2 * |grad x|&#94;2 = shat&#94;2 * |grad psi_t|&#94;2 * (dx/dpsi_t)&#94;2 gbdrift_alpha and cvdrift_alpha contain\nthe grad-B and curvature drifts projected onto\nthe grad alpha direction\nneed the projections on grad y\ngbdrift0_psi and cvdrift0_psi contain\nthe grad-B and curvature drifts projected onto\nthe grad psi direction\nneed the projections on grad x\ncan test FFS implementation by setting all geometric coefficients\nto their values at a given alpha; i.e., make the system axisymmetric\njacob is the Jacobian from Cartesian coordinates to (y,x,z) coordinates\nis ((grad y x grad x) . grad z)&#94;(-1) = Lref (dalpha/dy) (dpsi/dx)/(Lref Bref) (B/Bref . grad z)&#94;(-1)\nLref (dalpha/dy) = 1/dydalpha; (dpsi/dx)/(Lref Bref) = 1 / dxdXcoord ; (B/Bref . grad z) = gradpar*bmag Arguments Type Intent Optional Attributes Name integer, intent(in) :: nalpha integer, intent(in) :: naky","tags":"","loc":"proc/init_geometry.html"},{"title":"allocate_arrays – stella","text":"private  subroutine allocate_arrays(nalpha, nzgrid) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nalpha integer, intent(in) :: nzgrid","tags":"","loc":"proc/allocate_arrays~2.html"},{"title":"read_parameters – stella","text":"private  subroutine read_parameters() Uses file_utils text_options physics_flags mp Arguments None Namelists Namelist geo_knobs Variables Name Type Default Description geo_option character(len=20) None geo_file character(len=100) None overwrite_bmag logical None overwrite_gradpar logical None overwrite_gds2 logical None overwrite_gds21 logical None overwrite_gds22 logical None overwrite_gds23 logical None overwrite_gds24 logical None overwrite_gbdrift logical None overwrite_cvdrift logical None overwrite_gbdrift0 logical None q_as_x logical None set_bmag_const logical None","tags":"","loc":"proc/read_parameters~2.html"},{"title":"broadcast_arrays – stella","text":"private  subroutine broadcast_arrays() Uses mp Arguments None","tags":"","loc":"proc/broadcast_arrays.html"},{"title":"communicate_geo_multibox – stella","text":"public  subroutine communicate_geo_multibox(l_edge, r_edge) Uses mp millerlocal Arguments Type Intent Optional Attributes Name real, intent(in) :: l_edge real, intent(in) :: r_edge","tags":"","loc":"proc/communicate_geo_multibox.html"},{"title":"get_dzed – stella","text":"private  subroutine get_dzed(nz, dz, f, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nz real, intent(in), dimension(-nz:) :: dz real, intent(in), dimension(-nz:) :: f real, intent(out), dimension(-nz:) :: df","tags":"","loc":"proc/get_dzed.html"},{"title":"get_gradpar_eqarc – stella","text":"private  subroutine get_gradpar_eqarc(gp, z, dz, gp_eqarc) Uses zgrid constants Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nzgrid:) :: gp real, intent(in), dimension(-nzgrid:) :: z real, intent(in), dimension(-nzgrid:) :: dz real, intent(out) :: gp_eqarc","tags":"","loc":"proc/get_gradpar_eqarc.html"},{"title":"get_zed_eqarc – stella","text":"private  subroutine get_zed_eqarc(gp, dz, z, gp_eqarc, z_eqarc) Uses zgrid Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nzgrid:) :: gp real, intent(in), dimension(-nzgrid:) :: dz real, intent(in), dimension(-nzgrid:) :: z real, intent(in) :: gp_eqarc real, intent(out), dimension(-nzgrid:) :: z_eqarc","tags":"","loc":"proc/get_zed_eqarc.html"},{"title":"integrate_zed – stella","text":"private  subroutine integrate_zed(dz, f, intf) Uses zgrid Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nzgrid:) :: dz real, intent(in), dimension(-nzgrid:) :: f real, intent(out) :: intf","tags":"","loc":"proc/integrate_zed.html"},{"title":"get_x_to_rho – stella","text":"public  subroutine get_x_to_rho(llim, x_in, rho_out) Uses physics_parameters Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(:) :: x_in real, intent(out), dimension(:) :: rho_out","tags":"","loc":"proc/get_x_to_rho.html"},{"title":"write_geometric_coefficients – stella","text":"private  subroutine write_geometric_coefficients(nalpha) Uses file_utils zgrid Arguments Type Intent Optional Attributes Name integer, intent(in) :: nalpha","tags":"","loc":"proc/write_geometric_coefficients.html"},{"title":"finish_init_geometry – stella","text":"public  subroutine finish_init_geometry() Uses mp millerlocal Arguments None","tags":"","loc":"proc/finish_init_geometry.html"},{"title":"finish_geometry – stella","text":"public  subroutine finish_geometry() Arguments None","tags":"","loc":"proc/finish_geometry.html"},{"title":"get_option_value – stella","text":"public  subroutine get_option_value(selection, options, value, error_unit, selection_name, stop_on_error) Uses mp Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: selection type( text_option ), intent(in), dimension(:) :: options integer, intent(inout) :: value integer, intent(in), optional :: error_unit character(len=*), intent(in), optional :: selection_name logical, intent(in), optional :: stop_on_error","tags":"","loc":"proc/get_option_value.html"},{"title":"init_zgrid – stella","text":"public  subroutine init_zgrid() Uses mp constants Arguments None","tags":"","loc":"proc/init_zgrid.html"},{"title":"read_parameters – stella","text":"private  subroutine read_parameters() Uses physics_flags file_utils text_options Arguments None Namelists Namelist zgrid_parameters Variables Name Type Default Description nzed integer None nperiod integer None ntubes integer None shat_zero real None boundary_option character(len=20) None zed_equal_arc logical None grad_x_grad_y_zero real None dkx_over_dky real None","tags":"","loc":"proc/read_parameters~3.html"},{"title":"broadcast_parameters – stella","text":"private  subroutine broadcast_parameters() Uses mp Arguments None","tags":"","loc":"proc/broadcast_parameters.html"},{"title":"finish_zgrid – stella","text":"public  subroutine finish_zgrid() Arguments None","tags":"","loc":"proc/finish_zgrid.html"},{"title":"get_total_arc_length – stella","text":"public  subroutine get_total_arc_length(nz, gp, dz, length) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nz real, intent(in), dimension(-nz:) :: gp real, intent(in) :: dz real, intent(out) :: length","tags":"","loc":"proc/get_total_arc_length.html"},{"title":"get_arc_length_grid – stella","text":"public  subroutine get_arc_length_grid(nz_max, nzext_max, zboundary, gp, dz, zarc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nz_max integer, intent(in) :: nzext_max real, intent(in) :: zboundary real, intent(in), dimension(-nzext_max:) :: gp real, intent(in) :: dz real, intent(out), dimension(-nzext_max:) :: zarc","tags":"","loc":"proc/get_arc_length_grid.html"},{"title":"integrate_zed – stella","text":"private  subroutine integrate_zed(nz, dz, f, intf) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nz real, intent(in) :: dz real, intent(in), dimension(-nz:) :: f real, intent(out) :: intf","tags":"","loc":"proc/integrate_zed~2.html"},{"title":"readw_and_open – stella","text":"public  subroutine readw_and_open(file_or_extension, ierr, iopen) Uses safe_open_mod Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_or_extension integer, intent(out) :: ierr integer, optional :: iopen","tags":"","loc":"proc/readw_and_open.html"},{"title":"readw_only – stella","text":"public  subroutine readw_only(iunit, ierr, iopen) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iunit integer, intent(out) :: ierr integer, optional :: iopen","tags":"","loc":"proc/readw_only.html"},{"title":"read_wout_text – stella","text":"private  subroutine read_wout_text(iunit, ierr) Uses stel_constants Arguments Type Intent Optional Attributes Name integer :: iunit integer :: ierr","tags":"","loc":"proc/read_wout_text.html"},{"title":"read_wout_nc – stella","text":"private  subroutine read_wout_nc(filename, ierr) Uses stel_constants ezcdf Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer, intent(out) :: ierr","tags":"","loc":"proc/read_wout_nc.html"},{"title":"write_wout_text – stella","text":"public  subroutine write_wout_text(filename, ierr) Uses stel_constants safe_open_mod vsvd0 Arguments Type Intent Optional Attributes Name character(len=*) :: filename integer, intent(out) :: ierr","tags":"","loc":"proc/write_wout_text.html"},{"title":"Compute_Currents – stella","text":"public  subroutine Compute_Currents(ierror) Uses stel_constants Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierror","tags":"","loc":"proc/compute_currents.html"},{"title":"read_wout_deallocate – stella","text":"public  subroutine read_wout_deallocate(ierr) Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr","tags":"","loc":"proc/read_wout_deallocate.html"},{"title":"read_wout_file – stella","text":"public interface read_wout_file Module Procedures public  subroutine readw_and_open (file_or_extension, ierr, iopen) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_or_extension integer, intent(out) :: ierr integer, optional :: iopen public  subroutine readw_only (iunit, ierr, iopen) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iunit integer, intent(out) :: ierr integer, optional :: iopen","tags":"","loc":"interface/read_wout_file.html"},{"title":"fzero_residual – stella","text":"private  function fzero_residual(theta_vmec_try) Arguments Type Intent Optional Attributes Name real :: theta_vmec_try Return Value real","tags":"","loc":"proc/fzero_residual.html"},{"title":"read_vmec_equilibrium – stella","text":"public  subroutine read_vmec_equilibrium(vmec_filename, verbose, ierr) Uses read_wout_mod Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: vmec_filename logical, intent(in) :: verbose integer, intent(out) :: ierr","tags":"","loc":"proc/read_vmec_equilibrium.html"},{"title":"get_nominal_vmec_zeta_grid – stella","text":"public  subroutine get_nominal_vmec_zeta_grid(new_zeta_min, stellarator_symmetric_BC, nzgrid, zeta_center, number_of_field_periods_stella, number_of_field_periods_device, zeta) Arguments Type Intent Optional Attributes Name real, intent(in) :: new_zeta_min logical, intent(in) :: stellarator_symmetric_BC integer, intent(in) :: nzgrid real, intent(in) :: zeta_center real, intent(inout) :: number_of_field_periods_stella real, intent(out) :: number_of_field_periods_device real, intent(out), dimension(-nzgrid:) :: zeta","tags":"","loc":"proc/get_nominal_vmec_zeta_grid.html"},{"title":"vmec_to_stella_geometry_interface – stella","text":"public  subroutine vmec_to_stella_geometry_interface(nalpha, alpha0, nzgrid, zeta_center, number_of_field_periods_to_include, desired_normalized_toroidal_flux, vmec_surface_option, verbose, normalized_toroidal_flux_used, safety_factor_q, shat, L_reference, B_reference, nfp_out, sign_toroidal_flux, alpha, zeta, bmag, gradpar_zeta, grad_alpha_grad_alpha, grad_alpha_grad_psi, grad_psi_grad_psi, gds23, gds24, gds25, gds26, gbdrift_alpha, gbdrift0_psi, cvdrift_alpha, cvdrift0_psi, theta_vmec, B_sub_zeta, B_sub_theta_vmec, x_displacement_fac, gradpar_zeta_prefac, ierr) Uses fzero_mod Input parameters Determine which flux surface to use, based on\n desired_normalized_toroidal_flux and vmec_surface_option. Evaluate several radial-profile functions at the flux surface\n we ended up choosing. Set up the coordinate grids. We know theta_pest = alpha + iota * zeta, but we need to determine\n theta_vmec = theta_pest - Lambda. Initialize geometry arrays Now that we know the grid points in theta_vmec, we can evaluate\n all the geometric quantities on the grid points. Sanity check: If the conversion to theta_pest has been done\n correctly, we should find that\n (B dot grad theta_pest) / (B dot grad zeta) = iota.\n Let's verify this: Using R(theta,zeta) and Z(theta,zeta), compute the Cartesian\n components of the gradient basis vectors using the dual relations: Compute the Cartesian components of other quantities we need: Sanity tests: Verify that the Jacobian equals the appropriate\n cross product of the basis vectors. Sanity tests: Verify that\n \\vec{B} dot (each of the covariant and contravariant basis vectors)\n matches the corresponding term from VMEC. For gbdrift, we need \\vect{B} cross grad |B| dot grad alpha.\n For cvdrift, we also need \\vect{B} cross grad s dot grad alpha.\n Let us compute both of these quantities 2 ways, and make sure the two\n approaches give the same answer (within some tolerance). Finally, assemble the quantities needed for stella. Free all arrays that were allocated. Arguments Type Intent Optional Attributes Name integer, intent(in) :: nalpha real, intent(in) :: alpha0 integer, intent(in) :: nzgrid real, intent(in) :: zeta_center real, intent(in) :: number_of_field_periods_to_include real, intent(in) :: desired_normalized_toroidal_flux integer, intent(in) :: vmec_surface_option logical, intent(in) :: verbose Output quantities real, intent(out) :: normalized_toroidal_flux_used real, intent(out) :: safety_factor_q real, intent(out) :: shat real, intent(out) :: L_reference real, intent(out) :: B_reference real, intent(out) :: nfp_out integer, intent(out) :: sign_toroidal_flux real, intent(out), dimension(:) :: alpha real, intent(out), dimension(-nzgrid:) :: zeta real, intent(out), dimension(:, -nzgrid:) :: bmag real, intent(out), dimension(:, -nzgrid:) :: gradpar_zeta real, intent(out), dimension(:, -nzgrid:) :: grad_alpha_grad_alpha real, intent(out), dimension(:, -nzgrid:) :: grad_alpha_grad_psi real, intent(out), dimension(:, -nzgrid:) :: grad_psi_grad_psi real, intent(out), dimension(:, -nzgrid:) :: gds23 real, intent(out), dimension(:, -nzgrid:) :: gds24 real, intent(out), dimension(:, -nzgrid:) :: gds25 real, intent(out), dimension(:, -nzgrid:) :: gds26 real, intent(out), dimension(:, -nzgrid:) :: gbdrift_alpha real, intent(out), dimension(:, -nzgrid:) :: gbdrift0_psi real, intent(out), dimension(:, -nzgrid:) :: cvdrift_alpha real, intent(out), dimension(:, -nzgrid:) :: cvdrift0_psi real, intent(out), dimension(:, -nzgrid:) :: theta_vmec real, intent(out), dimension(:, -nzgrid:) :: B_sub_zeta real, intent(out), dimension(:, -nzgrid:) :: B_sub_theta_vmec real, intent(out), dimension(:, -nzgrid:) :: x_displacement_fac real, intent(in) :: gradpar_zeta_prefac integer, intent(out) :: ierr","tags":"","loc":"proc/vmec_to_stella_geometry_interface.html"},{"title":"get_root – stella","text":"private  subroutine get_root(a0, b0, root, converged) Arguments Type Intent Optional Attributes Name real, intent(in) :: a0 real, intent(in) :: b0 real, intent(out) :: root logical, intent(out) :: converged","tags":"","loc":"proc/get_root.html"},{"title":"desired_zmin – stella","text":"public  subroutine desired_zmin(nalpha, nzgrid, zeta, twist_shift_factor_full, dkx_over_dky, new_zeta_min) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nalpha integer, intent(in) :: nzgrid real, intent(in), dimension(nalpha, -nzgrid:nzgrid) :: zeta real, intent(in), dimension(nalpha, -nzgrid:nzgrid) :: twist_shift_factor_full real, intent(in) :: dkx_over_dky real, intent(out) :: new_zeta_min","tags":"","loc":"proc/desired_zmin.html"},{"title":"read_parameters_dougherty – stella","text":"public  subroutine read_parameters_dougherty() Uses file_utils mp Arguments None Namelists Namelist collisions_dougherty Variables Name Type Default Description momentum_conservation logical None energy_conservation logical None vpa_operator logical None mu_operator logical None","tags":"","loc":"proc/read_parameters_dougherty.html"},{"title":"init_collisions_dougherty – stella","text":"public  subroutine init_collisions_dougherty(collisions_implicit, cfl_dt_vpadiff, cfl_dt_mudiff) Uses species stella_geometry vpamu_grids Arguments Type Intent Optional Attributes Name logical, intent(in) :: collisions_implicit real, intent(out) :: cfl_dt_vpadiff real, intent(out) :: cfl_dt_mudiff","tags":"","loc":"proc/init_collisions_dougherty.html"},{"title":"init_vpadiff_matrix – stella","text":"private  subroutine init_vpadiff_matrix() Uses dist_fn_arrays species stella_layouts vpamu_grids stella_time stella_geometry Arguments None","tags":"","loc":"proc/init_vpadiff_matrix.html"},{"title":"init_mudiff_matrix – stella","text":"private  subroutine init_mudiff_matrix() Uses zgrid dist_fn_arrays species stella_layouts vpamu_grids stella_time stella_geometry Arguments None","tags":"","loc":"proc/init_mudiff_matrix.html"},{"title":"init_vpadiff_conserve – stella","text":"private  subroutine init_vpadiff_conserve() Uses mp zgrid linear_solve dist_fn_arrays species stella_layouts physics_flags gyro_averages fields finite_differences kt_grids vpamu_grids stella_time stella_geometry Arguments None","tags":"","loc":"proc/init_vpadiff_conserve.html"},{"title":"init_mudiff_conserve – stella","text":"private  subroutine init_mudiff_conserve() Uses mp zgrid linear_solve dist_fn_arrays species stella_layouts physics_flags gyro_averages fields finite_differences kt_grids vpamu_grids stella_time stella_geometry Arguments None","tags":"","loc":"proc/init_mudiff_conserve.html"},{"title":"finish_collisions_dougherty – stella","text":"public  subroutine finish_collisions_dougherty() Arguments None","tags":"","loc":"proc/finish_collisions_dougherty.html"},{"title":"finish_vpadiff_matrix – stella","text":"private  subroutine finish_vpadiff_matrix() Arguments None","tags":"","loc":"proc/finish_vpadiff_matrix.html"},{"title":"finish_mudiff_matrix – stella","text":"private  subroutine finish_mudiff_matrix() Arguments None","tags":"","loc":"proc/finish_mudiff_matrix.html"},{"title":"finish_vpadiff_response – stella","text":"private  subroutine finish_vpadiff_response() Arguments None","tags":"","loc":"proc/finish_vpadiff_response.html"},{"title":"finish_mudiff_response – stella","text":"private  subroutine finish_mudiff_response() Arguments None","tags":"","loc":"proc/finish_mudiff_response.html"},{"title":"get_upar – stella","text":"private  subroutine get_upar(g, fld) Uses mp zgrid stella_layouts gyro_averages vpamu_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: fld","tags":"","loc":"proc/get_upar.html"},{"title":"get_uperp – stella","text":"private  subroutine get_uperp(g, fld) Uses mp zgrid stella_layouts gyro_averages vpamu_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: fld","tags":"","loc":"proc/get_uperp.html"},{"title":"get_temp – stella","text":"private  subroutine get_temp(g, fld) Uses mp zgrid stella_layouts gyro_averages vpamu_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: fld","tags":"","loc":"proc/get_temp.html"},{"title":"get_temp_mu – stella","text":"private  subroutine get_temp_mu(g, fld) Uses mp zgrid stella_layouts gyro_averages vpamu_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: fld","tags":"","loc":"proc/get_temp_mu.html"},{"title":"advance_collisions_dougherty_explicit – stella","text":"public  subroutine advance_collisions_dougherty_explicit(g, phi, bpar, gke_rhs, time_collisions) Uses g_tofrom_h job_manage mp zgrid dist_fn_arrays stella_transforms dist_redistribute species physics_flags stella_layouts run_parameters fields_arrays kt_grids vpamu_grids stella_time stella_geometry redistribute Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(in), dimension(:, :, -nzgrid:, :) :: bpar complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gke_rhs real, intent(inout), dimension(:, :) :: time_collisions","tags":"","loc":"proc/advance_collisions_dougherty_explicit.html"},{"title":"vpa_differential_operator – stella","text":"private  subroutine vpa_differential_operator(tfac, h, Dh) Uses vpamu_grids Arguments Type Intent Optional Attributes Name real, intent(in) :: tfac complex, intent(in), dimension(:) :: h complex, intent(out), dimension(:) :: Dh","tags":"","loc":"proc/vpa_differential_operator.html"},{"title":"mu_differential_operator – stella","text":"private  subroutine mu_differential_operator(tfac, iz, ia, h, Dh) Uses vpamu_grids stella_geometry Arguments Type Intent Optional Attributes Name real, intent(in) :: tfac integer, intent(in) :: iz integer, intent(in) :: ia complex, intent(in), dimension(:) :: h complex, intent(out), dimension(:) :: Dh","tags":"","loc":"proc/mu_differential_operator.html"},{"title":"conserve_momentum – stella","text":"private  subroutine conserve_momentum(iky, ikx, iz, is, ikxkyz, h, Ch) Uses dist_fn_arrays species gyro_averages vpamu_grids stella_geometry Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: is integer, intent(in) :: ikxkyz complex, intent(in), dimension(:, :) :: h complex, intent(inout), dimension(:, :) :: Ch","tags":"","loc":"proc/conserve_momentum.html"},{"title":"conserve_energy – stella","text":"private  subroutine conserve_energy(iz, is, ikxkyz, h, Ch) Uses vpamu_grids gyro_averages Arguments Type Intent Optional Attributes Name integer, intent(in) :: iz integer, intent(in) :: is integer, intent(in) :: ikxkyz complex, intent(in), dimension(:, :) :: h complex, intent(inout), dimension(:, :) :: Ch","tags":"","loc":"proc/conserve_energy.html"},{"title":"conserve_momentum_vmulo – stella","text":"private  subroutine conserve_momentum_vmulo(h, gke_rhs) Uses mp zgrid dist_fn_arrays species stella_layouts physics_flags gyro_averages kt_grids vpamu_grids stella_time stella_geometry Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: h complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gke_rhs","tags":"","loc":"proc/conserve_momentum_vmulo.html"},{"title":"conserve_energy_vmulo – stella","text":"private  subroutine conserve_energy_vmulo(h, gke_rhs) Uses mp zgrid dist_fn_arrays species stella_layouts physics_flags gyro_averages kt_grids vpamu_grids stella_time stella_geometry Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: h complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gke_rhs","tags":"","loc":"proc/conserve_energy_vmulo.html"},{"title":"advance_collisions_dougherty_implicit – stella","text":"public  subroutine advance_collisions_dougherty_implicit(phi, apar, bpar) Uses zgrid dist_fn_arrays Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :) :: apar complex, intent(inout), dimension(:, :, -nzgrid:, :) :: bpar","tags":"","loc":"proc/advance_collisions_dougherty_implicit.html"},{"title":"advance_vpadiff_implicit – stella","text":"private  subroutine advance_vpadiff_implicit(phi, apar, bpar, g) Uses g_tofrom_h mp zgrid linear_solve species stella_layouts physics_flags gyro_averages fields finite_differences kt_grids vpamu_grids stella_time stella_geometry run_parameters Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :) :: apar complex, intent(inout), dimension(:, :, -nzgrid:, :) :: bpar complex, intent(inout), dimension(:, :, kxkyz_lo%llim_proc:) :: g","tags":"","loc":"proc/advance_vpadiff_implicit.html"},{"title":"advance_mudiff_implicit – stella","text":"private  subroutine advance_mudiff_implicit(phi, apar, bpar, g) Uses g_tofrom_h mp zgrid linear_solve dist_fn_arrays species stella_layouts physics_flags gyro_averages fields finite_differences kt_grids vpamu_grids stella_time stella_geometry run_parameters Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :) :: apar complex, intent(inout), dimension(:, :, -nzgrid:, :) :: bpar complex, intent(inout), dimension(:, :, kxkyz_lo%llim_proc:) :: g","tags":"","loc":"proc/advance_mudiff_implicit.html"},{"title":"init_sources – stella","text":"public  subroutine init_sources() Uses mp zgrid dist_fn_arrays species stella_layouts physics_flags file_utils fields_arrays kt_grids run_parameters Arguments None","tags":"","loc":"proc/init_sources.html"},{"title":"read_parameters – stella","text":"private  subroutine read_parameters() Uses mp physics_flags file_utils fields_arrays kt_grids text_options Arguments None Namelists Namelist sources Variables Name Type Default Description source_option character(len=30) None nu_krook real None tcorr_source real None ikxmax_source integer None krook_odd logical None exclude_boundary_regions logical None tcorr_source_qn real None exclude_boundary_regions_qn logical None from_zero logical None conserve_momentum logical None conserve_density logical None","tags":"","loc":"proc/read_parameters~4.html"},{"title":"init_source_timeaverage – stella","text":"public  subroutine init_source_timeaverage() Uses stella_time fields_arrays Arguments None","tags":"","loc":"proc/init_source_timeaverage.html"},{"title":"finish_sources – stella","text":"public  subroutine finish_sources() Uses dist_fn_arrays fields_arrays Arguments None","tags":"","loc":"proc/finish_sources.html"},{"title":"add_krook_operator – stella","text":"public  subroutine add_krook_operator(g, gke_rhs) Uses job_manage mp zgrid dist_fn_arrays stella_layouts constants kt_grids stella_time stella_transforms Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:), target :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gke_rhs","tags":"","loc":"proc/add_krook_operator.html"},{"title":"update_tcorr_krook – stella","text":"public  subroutine update_tcorr_krook(g) Uses job_manage mp zgrid dist_fn_arrays stella_layouts constants kt_grids stella_time stella_transforms Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:), target :: g","tags":"","loc":"proc/update_tcorr_krook.html"},{"title":"enforce_momentum_conservation – stella","text":"private  subroutine enforce_momentum_conservation(g_work) Uses job_manage mp zgrid dist_fn_arrays dist_redistribute stella_layouts vpamu_grids redistribute Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g_work","tags":"","loc":"proc/enforce_momentum_conservation.html"},{"title":"enforce_density_conservation – stella","text":"private  subroutine enforce_density_conservation(g_work) Uses mp zgrid dist_fn_arrays species physics_flags stella_layouts gyro_averages kt_grids vpamu_grids stella_transforms stella_geometry Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, -nzgrid:, :, vmu_lo%llim_proc:) :: g_work","tags":"","loc":"proc/enforce_density_conservation.html"},{"title":"project_out_zero – stella","text":"public  subroutine project_out_zero(gold, gnew) Uses job_manage mp zgrid dist_fn_arrays stella_layouts constants kt_grids stella_time stella_transforms Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gold complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gnew","tags":"","loc":"proc/project_out_zero.html"},{"title":"init_quasineutrality_source – stella","text":"public  subroutine init_quasineutrality_source() Uses zgrid linear_solve stella_geometry fields_arrays kt_grids stella_transforms Arguments None","tags":"","loc":"proc/init_quasineutrality_source.html"},{"title":"update_quasineutrality_source – stella","text":"public  subroutine update_quasineutrality_source() Uses fields_arrays Arguments None","tags":"","loc":"proc/update_quasineutrality_source.html"},{"title":"has_electron_species – stella","text":"public pure function has_electron_species(spec) Uses common_types Arguments Type Intent Optional Attributes Name type( spec_type ), intent(in), dimension(:) :: spec Return Value logical","tags":"","loc":"proc/has_electron_species.html"},{"title":"has_slowing_down_species – stella","text":"public pure function has_slowing_down_species(spec) Uses common_types Arguments Type Intent Optional Attributes Name type( spec_type ), intent(in), dimension(:) :: spec Return Value logical","tags":"","loc":"proc/has_slowing_down_species.html"},{"title":"init_species – stella","text":"public  subroutine init_species() Uses physics_parameters mp physics_flags euterpe_interface inputprofiles_interface Arguments None","tags":"","loc":"proc/init_species.html"},{"title":"read_species_knobs – stella","text":"public  subroutine read_species_knobs() Uses file_utils mp physics_flags text_options Arguments None Namelists Namelist species_knobs Variables Name Type Default Description nspec integer None species_option character(len=20) None read_profile_variation logical None write_profile_variation logical None ecoll_zeff logical None","tags":"","loc":"proc/read_species_knobs.html"},{"title":"read_species_stella – stella","text":"private  subroutine read_species_stella() Uses file_utils stella_geometry text_options Arguments None Namelists Namelist species_parameters Variables Name Type Default Description z real None mass real None dens real None temp real None tprim real None fprim real None d2ndr2 real None d2Tdr2 real None bess_fac real None type character(len=20) None","tags":"","loc":"proc/read_species_stella.html"},{"title":"broadcast_parameters – stella","text":"private  subroutine broadcast_parameters() Uses mp Arguments None","tags":"","loc":"proc/broadcast_parameters~2.html"},{"title":"finish_species – stella","text":"public  subroutine finish_species() Arguments None","tags":"","loc":"proc/finish_species.html"},{"title":"reinit_species – stella","text":"public  subroutine reinit_species(ntspec, dens, temp, fprim, tprim, bess_fac) Uses mp Arguments Type Intent Optional Attributes Name integer, intent(in) :: ntspec real, intent(in), dimension(:) :: dens real, intent(in), dimension(:) :: temp real, intent(in), dimension(:) :: fprim real, intent(in), dimension(:) :: tprim real, intent(in), dimension(:) :: bess_fac","tags":"","loc":"proc/reinit_species.html"},{"title":"communicate_species_multibox – stella","text":"public  subroutine communicate_species_multibox(dr_m, dr_p) Uses job_manage mp Arguments Type Intent Optional Attributes Name real, intent(in), optional :: dr_m real, intent(in), optional :: dr_p","tags":"","loc":"proc/communicate_species_multibox.html"},{"title":"dump_species_input – stella","text":"private  subroutine dump_species_input() Uses file_utils Arguments None","tags":"","loc":"proc/dump_species_input.html"},{"title":"advance_implicit_terms – stella","text":"public  subroutine advance_implicit_terms(g, phi, apar, bpar) Uses job_manage mp zgrid dist_fn_arrays stella_layouts physics_flags fields extended_zgrid kt_grids run_parameters dist_choice indicates whether the non-Boltzmann part of the pdf (h) is evolved\nin parallel streaming or if the guiding centre distribution (g = ) is evolved\nif using delphi formulation for response matrix, then phi = phi&#94;n replaces\nphi&#94;{n+1} in the inhomogeneous GKE; else set phi_{n+1} to zero in inhomogeneous equation\nIf using deltaphi formulation, must account for fact that phi = phi&#94;{n+1}-phi&#94;{n*}, but\ntupwnd_p should multiply phi&#94;{n+1} Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :) :: apar complex, intent(inout), dimension(:, :, -nzgrid:, :) :: bpar","tags":"","loc":"proc/advance_implicit_terms.html"},{"title":"get_gke_rhs – stella","text":"public  subroutine get_gke_rhs(ivmu, iky, ie, pdf, phi, apar, aparnew, aparold, bpar, rhs) Uses kt_grids get_gke_rhs calculates the RHS of the GK equation.\nas the response matrix approach requires separate solution of the 'inhomogeneous' GKE,\nthe homogeneous GKE (to obtain the response matrix itself),\nand the full GKE, which RHS is obtained depends on the input values\nfor 'pdf', 'phi', 'apar', 'aparnew' and 'aparold' Arguments Type Intent Optional Attributes Name integer, intent(in) :: ivmu integer, intent(in) :: iky integer, intent(in) :: ie complex, intent(in), dimension(:) :: pdf complex, intent(in), dimension(:) :: phi complex, intent(in), dimension(:) :: apar complex, intent(in), dimension(:) :: aparnew complex, intent(in), dimension(:) :: aparold complex, intent(in), dimension(:) :: bpar complex, intent(out), dimension(:) :: rhs","tags":"","loc":"proc/get_gke_rhs.html"},{"title":"get_contributions_from_fields – stella","text":"private  subroutine get_contributions_from_fields(phi, apar, aparnew, bpar, ivmu, iky, ie, scratch, rhs) Uses physics_flags extended_zgrid get_contributions_from_fields takes as input the appropriately averaged\nelectrostatic potential phi and magnetic vector potential components apar\nand returns in rhs the sum of the source terms\ninvolving phi and apar that appear on the RHS of the GK equation when g is the pdf Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: phi complex, intent(in), dimension(:) :: apar complex, intent(in), dimension(:) :: aparnew complex, intent(in), dimension(:) :: bpar integer, intent(in) :: ivmu integer, intent(in) :: iky integer, intent(in) :: ie complex, intent(out), dimension(:) :: scratch complex, intent(out), dimension(:) :: rhs","tags":"","loc":"proc/get_contributions_from_fields.html"},{"title":"get_contributions_from_phi – stella","text":"private  subroutine get_contributions_from_phi(phi, ivmu, iky, iz_from_izext, ikx_from_izext, scratch, rhs) Uses zgrid species stella_layouts neoclassical_terms extended_zgrid kt_grids vpamu_grids stella_time run_parameters get_contributions_from_phi takes as input the appropriately averaged\nelectrostatic potential phi and returns in rhs the sum of the source terms\ninvolving phi that appear on the RHS of the GK equation when g is the pdf Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: phi integer, intent(in) :: ivmu integer, intent(in) :: iky integer, intent(in), dimension(:) :: iz_from_izext integer, intent(in), dimension(:) :: ikx_from_izext complex, intent(out), dimension(:) :: scratch complex, intent(out), dimension(:) :: rhs","tags":"","loc":"proc/get_contributions_from_phi.html"},{"title":"get_contributions_from_bpar – stella","text":"private  subroutine get_contributions_from_bpar(bpar, ivmu, iky, iz_from_izext, ikx_from_izext, scratch, rhs) Uses zgrid species stella_layouts neoclassical_terms extended_zgrid kt_grids vpamu_grids stella_time run_parameters get_contributions_from_bpar takes as input the appropriately averaged\nelectrostatic potential bpar and returns in rhs the sum of the source terms\ninvolving bpar that appear on the RHS of the GK equation when g is the pdf Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: bpar integer, intent(in) :: ivmu integer, intent(in) :: iky integer, intent(in), dimension(:) :: iz_from_izext integer, intent(in), dimension(:) :: ikx_from_izext complex, intent(out), dimension(:) :: scratch complex, intent(out), dimension(:) :: rhs","tags":"","loc":"proc/get_contributions_from_bpar.html"},{"title":"get_contributions_from_apar – stella","text":"private  subroutine get_contributions_from_apar(apar, aparnew, ivmu, iky, iz_from_izext, ikx_from_izext, scratch, rhs) Uses stella_layouts run_parameters get_contributions_from_apar takes as input the appropriately averaged\nparallel component of the vector potential, apar, and returns in rhs the sum of the source terms\ninvolving apar that appear on the RHS of the GK equation when g is the pdf Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: apar complex, intent(in), dimension(:) :: aparnew integer, intent(in) :: ivmu integer, intent(in) :: iky integer, intent(in), dimension(:) :: iz_from_izext integer, intent(in), dimension(:) :: ikx_from_izext complex, intent(out), dimension(:) :: scratch complex, intent(inout), dimension(:) :: rhs","tags":"","loc":"proc/get_contributions_from_apar.html"},{"title":"add_gbar_to_g_contribution_apar – stella","text":"private  subroutine add_gbar_to_g_contribution_apar(scratch2, iky, ia, iv, imu, is, nz_ext, iz_from_izext, rhs) Uses species parallel_streaming extended_zgrid vpamu_grids run_parameters adds the contributions to the GKE RHS that comes from switching from\ngbar&#94;{n+1} = g&#94;{n+1} + (Ze/T) (vpa/c) *F0 to g&#94;{n+1} = in the time derivative; Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: scratch2 integer, intent(in) :: iky integer, intent(in) :: ia integer, intent(in) :: iv integer, intent(in) :: imu integer, intent(in) :: is integer, intent(in) :: nz_ext integer, intent(in), dimension(:) :: iz_from_izext complex, intent(inout), dimension(:) :: rhs","tags":"","loc":"proc/add_gbar_to_g_contribution_apar.html"},{"title":"add_drifts_contribution_apar – stella","text":"private  subroutine add_drifts_contribution_apar(scratch, iky, ia, ivmu, iv, is, nz_ext, iz_from_izext, rhs) Uses dist_fn_arrays species parallel_streaming constants extended_zgrid kt_grids vpamu_grids Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: scratch integer, intent(in) :: iky integer, intent(in) :: ia integer, intent(in) :: ivmu integer, intent(in) :: iv integer, intent(in) :: is integer, intent(in) :: nz_ext integer, intent(in), dimension(:) :: iz_from_izext complex, intent(inout), dimension(:) :: rhs","tags":"","loc":"proc/add_drifts_contribution_apar.html"},{"title":"gbar_to_g_zext – stella","text":"private  subroutine gbar_to_g_zext(pdf, apar, facapar, iky, ivmu, ikx_from_izext, iz_from_izext) Uses vpamu_grids species stella_layouts run_parameters Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: pdf complex, intent(in), dimension(:) :: apar real, intent(in) :: facapar integer, intent(in) :: iky integer, intent(in) :: ivmu integer, intent(in), dimension(:) :: ikx_from_izext integer, intent(in), dimension(:) :: iz_from_izext","tags":"","loc":"proc/gbar_to_g_zext.html"},{"title":"gyro_average_zext – stella","text":"private  subroutine gyro_average_zext(iky, ivmu, ikx_from_izext, iz_from_izext, fld, gyro_fld) Uses gyro_averages Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky integer, intent(in) :: ivmu integer, intent(in), dimension(:) :: ikx_from_izext integer, intent(in), dimension(:) :: iz_from_izext complex, intent(in), dimension(:) :: fld complex, intent(out), dimension(:) :: gyro_fld","tags":"","loc":"proc/gyro_average_zext.html"},{"title":"gyro_average_j1_zext – stella","text":"private  subroutine gyro_average_j1_zext(iky, ivmu, ikx_from_izext, iz_from_izext, fld, gyro_fld) Uses gyro_averages Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky integer, intent(in) :: ivmu integer, intent(in), dimension(:) :: ikx_from_izext integer, intent(in), dimension(:) :: iz_from_izext complex, intent(in), dimension(:) :: fld complex, intent(out), dimension(:) :: gyro_fld","tags":"","loc":"proc/gyro_average_j1_zext.html"},{"title":"get_contributions_from_pdf – stella","text":"private  subroutine get_contributions_from_pdf(pdf, apar, ivmu, iky, ie, rhs) Uses zgrid dist_fn_arrays species physics_flags stella_layouts parallel_streaming constants extended_zgrid kt_grids vpamu_grids stella_time run_parameters get_contributions_from_pdf takes as an argument the evolved pdf\n(either guiding centre distribution g= or maxwellian-normlized, non-Boltzmann distribution h/F0=f/F0+(Ze*phi/T))\nand the scratch array rhs, and returns the source terms that depend on the pdf in rhs Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: pdf complex, intent(in), dimension(:) :: apar integer, intent(in) :: ivmu integer, intent(in) :: iky integer, intent(in) :: ie complex, intent(out), dimension(:) :: rhs","tags":"","loc":"proc/get_contributions_from_pdf.html"},{"title":"sweep_g_zext – stella","text":"public  subroutine sweep_g_zext(iky, ie, it, ivmu, pdf) Uses zgrid dist_fn_arrays stella_layouts parallel_streaming constants extended_zgrid kt_grids run_parameters Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky integer, intent(in) :: ie integer, intent(in) :: it integer, intent(in) :: ivmu complex, intent(inout), dimension(:) :: pdf","tags":"","loc":"proc/sweep_g_zext.html"},{"title":"get_updated_pdf – stella","text":"private  subroutine get_updated_pdf(iz, iv, is, sgn, iz1, iz2, wdrift_ext, pdf) Uses parallel_streaming zgrid run_parameters Arguments Type Intent Optional Attributes Name integer, intent(inout) :: iz integer, intent(in) :: iv integer, intent(in) :: is integer, intent(in) :: sgn integer, intent(in) :: iz1 integer, intent(in) :: iz2 complex, intent(in), dimension(:) :: wdrift_ext complex, intent(inout), dimension(:) :: pdf","tags":"","loc":"proc/get_updated_pdf.html"},{"title":"sweep_zed_zonal – stella","text":"public  subroutine sweep_zed_zonal(iky, iv, is, sgn, g, llim) Uses parallel_streaming zgrid run_parameters extended_zgrid Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky integer, intent(in) :: iv integer, intent(in) :: is integer, intent(in) :: sgn complex, intent(inout), dimension(llim:) :: g integer, intent(in) :: llim","tags":"","loc":"proc/sweep_zed_zonal.html"},{"title":"invert_parstream_response – stella","text":"private  subroutine invert_parstream_response(phi, apar, bpar) Uses zgrid linear_solve physics_flags fields extended_zgrid fields_arrays kt_grids use the LU-decomposed response matrix and the contributions from the\n'inhomogeneous' fields (phi, apar) to solve for (phi&#94;{n+1}, apar&#94;{n+1}) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :) :: apar complex, intent(inout), dimension(:, :, -nzgrid:, :) :: bpar","tags":"","loc":"proc/invert_parstream_response.html"},{"title":"init_stella_io – stella","text":"public  subroutine init_stella_io(restart) Arguments Type Intent Optional Attributes Name logical, intent(in) :: restart Is this run a restart?","tags":"","loc":"proc/init_stella_io.html"},{"title":"write_grids – stella","text":"private  subroutine write_grids(file_id) Ensure the netCDF file contains all the dimensions and grids,\ncreating them if necessary Arguments Type Intent Optional Attributes Name integer, intent(in) :: file_id NetCDF ID of the file","tags":"","loc":"proc/write_grids.html"},{"title":"finish_stella_io – stella","text":"public  subroutine finish_stella_io() Uses mp Arguments None","tags":"","loc":"proc/finish_stella_io.html"},{"title":"save_input – stella","text":"private  subroutine save_input(file_id) Save the input file in the NetCDF file Arguments Type Intent Optional Attributes Name integer, intent(in) :: file_id NetCDF ID of the file to write to","tags":"","loc":"proc/save_input.html"},{"title":"define_vars – stella","text":"private  subroutine define_vars() Arguments None","tags":"","loc":"proc/define_vars.html"},{"title":"write_time_nc – stella","text":"public  subroutine write_time_nc(nout, time) Write simulation time to netCDF output file Also flushes to disk Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout Current timestep real, intent(in) :: time Current simulation time","tags":"","loc":"proc/write_time_nc.html"},{"title":"write_phi2_nc – stella","text":"public  subroutine write_phi2_nc(nout, phi2) Write amplitude of electrostatic potential to netCDF Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout Current timestep real, intent(in) :: phi2 Amplitude of electrostatic potential","tags":"","loc":"proc/write_phi2_nc.html"},{"title":"write_apar2_nc – stella","text":"public  subroutine write_apar2_nc(nout, apar2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout Current timestep real, intent(in) :: apar2 Amplitude of parallel vector potential","tags":"","loc":"proc/write_apar2_nc.html"},{"title":"write_bpar2_nc – stella","text":"public  subroutine write_bpar2_nc(nout, bpar2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout Current timestep real, intent(in) :: bpar2 Amplitude of parallel vector potential","tags":"","loc":"proc/write_bpar2_nc.html"},{"title":"write_phi_nc – stella","text":"public  subroutine write_phi_nc(nout, phi) Uses zgrid Write time trace of electrostatic potential to netCDF Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout Current timestep complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi Electrostatic potential","tags":"","loc":"proc/write_phi_nc.html"},{"title":"write_apar_nc – stella","text":"public  subroutine write_apar_nc(nout, apar) Uses zgrid Write time trace of electromagnetic field A|| to netCDF Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout Current timestep complex, intent(in), dimension(:, :, -nzgrid:, :) :: apar","tags":"","loc":"proc/write_apar_nc.html"},{"title":"write_bpar_nc – stella","text":"public  subroutine write_bpar_nc(nout, bpar) Uses zgrid Write time trace of electromagnetic field B|| to netCDF Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout Current timestep complex, intent(in), dimension(:, :, -nzgrid:, :) :: bpar","tags":"","loc":"proc/write_bpar_nc.html"},{"title":"write_omega_nc – stella","text":"public  subroutine write_omega_nc(nout, omega) Write the complex frequency to netCDF Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout complex, intent(in), dimension(:, :) :: omega","tags":"","loc":"proc/write_omega_nc.html"},{"title":"write_radial_fluxes_nc – stella","text":"public  subroutine write_radial_fluxes_nc(nout, pflux, vflux, qflux) Write fluxes to netCDF Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout Current timestep real, intent(in), dimension(:, :) :: pflux Particle, velocity, heat flux real, intent(in), dimension(:, :) :: vflux Particle, velocity, heat flux real, intent(in), dimension(:, :) :: qflux Particle, velocity, heat flux","tags":"","loc":"proc/write_radial_fluxes_nc.html"},{"title":"write_radial_moments_nc – stella","text":"public  subroutine write_radial_moments_nc(nout, dens_x, upar_x, temp_x) Write radial moments to netCDF Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout Current timestep real, intent(in), dimension(:, :) :: dens_x Radial moments for density, parallel velocity, temperature real, intent(in), dimension(:, :) :: upar_x Radial moments for density, parallel velocity, temperature real, intent(in), dimension(:, :) :: temp_x Radial moments for density, parallel velocity, temperature","tags":"","loc":"proc/write_radial_moments_nc.html"},{"title":"write_kspectra_nc – stella","text":"public  subroutine write_kspectra_nc(nout, field_vs_kxky, keyname, longname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout Current timestep real, intent(in), dimension(:, :) :: field_vs_kxky character(len=*), intent(in) :: keyname character(len=*), intent(in) :: longname","tags":"","loc":"proc/write_kspectra_nc.html"},{"title":"write_kspectra_species_nc – stella","text":"public  subroutine write_kspectra_species_nc(nout, field_vs_kxkys, keyname, longname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout Current timestep real, intent(in), dimension(:, :, :) :: field_vs_kxkys character(len=*), intent(in) :: keyname character(len=*), intent(in) :: longname","tags":"","loc":"proc/write_kspectra_species_nc.html"},{"title":"write_fluxes_nc – stella","text":"public  subroutine write_fluxes_nc(nout, pflx, vflx, qflx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout Current timestep real, intent(in), dimension(:) :: pflx real, intent(in), dimension(:) :: vflx real, intent(in), dimension(:) :: qflx","tags":"","loc":"proc/write_fluxes_nc.html"},{"title":"write_fluxes_kxkyz_nc – stella","text":"public  subroutine write_fluxes_kxkyz_nc(nout, pflx_kxkyz, vflx_kxkyz, qflx_kxkyz) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout Current timestep real, intent(in), dimension(:, :, :, :, :) :: pflx_kxkyz real, intent(in), dimension(:, :, :, :, :) :: vflx_kxkyz real, intent(in), dimension(:, :, :, :, :) :: qflx_kxkyz","tags":"","loc":"proc/write_fluxes_kxkyz_nc.html"},{"title":"write_moments_nc – stella","text":"public  subroutine write_moments_nc(nout, density, upar, temperature, spitzer2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout complex, intent(in), dimension(:, :, :, :, :) :: density complex, intent(in), dimension(:, :, :, :, :) :: upar complex, intent(in), dimension(:, :, :, :, :) :: temperature complex, intent(in), dimension(:, :, :, :, :) :: spitzer2","tags":"","loc":"proc/write_moments_nc.html"},{"title":"write_gvmus_nc – stella","text":"public  subroutine write_gvmus_nc(nout, gvmus) Write guiding center distribution function averaged over real space Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout Current timestep real, intent(in), dimension(:, :, :) :: gvmus Guiding centre distribution function","tags":"","loc":"proc/write_gvmus_nc.html"},{"title":"write_gzvs_nc – stella","text":"public  subroutine write_gzvs_nc(nout, gzvs) Write guiding center distribution function averaged over (kx, ky, mu) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout Current timestep real, intent(in), dimension(:, :, :, :) :: gzvs Guiding centre distribution function","tags":"","loc":"proc/write_gzvs_nc.html"},{"title":"nc_species – stella","text":"private  subroutine nc_species(file_id) Write spec to output netCDF file Arguments Type Intent Optional Attributes Name integer, intent(in) :: file_id NetCDF ID of the file to write to","tags":"","loc":"proc/nc_species.html"},{"title":"nc_geo – stella","text":"private  subroutine nc_geo(file_id) Write various geometric quantities to output netCDF file Arguments Type Intent Optional Attributes Name integer, intent(in) :: file_id NetCDF ID of the file to write to","tags":"","loc":"proc/nc_geo.html"},{"title":"get_nout – stella","text":"public  subroutine get_nout(tstart, nout) Uses netcdf neasyf Get the index of the time dimension in the netCDF file that corresponds to\na time no larger than tstart Arguments Type Intent Optional Attributes Name real, intent(in) :: tstart Simulation time to find integer, intent(out) :: nout Index of time dimension","tags":"","loc":"proc/get_nout.html"},{"title":"sync_nc – stella","text":"public  subroutine sync_nc() Flush netCDF file to disk Arguments None","tags":"","loc":"proc/sync_nc.html"},{"title":"write_complex_rank2 – stella","text":"private  subroutine write_complex_rank2(parent_id, name, values, dim_names, units, long_name, start) Uses neasyf convert Arguments Type Intent Optional Attributes Name integer, intent(in) :: parent_id NetCDF ID of the parent group/file character(len=*), intent(in) :: name Name of the variable complex, intent(in), dimension(:, :) :: values Array to be written character(len=*), intent(in), dimension(:) :: dim_names Array of dimension names character(len=*), intent(in), optional :: units Units of coordinate character(len=*), intent(in), optional :: long_name Long descriptive name integer, intent(in), optional, dimension(:) :: start","tags":"","loc":"proc/write_complex_rank2.html"},{"title":"write_complex_rank4 – stella","text":"private  subroutine write_complex_rank4(parent_id, name, values, dim_names, units, long_name, start) Uses neasyf convert Arguments Type Intent Optional Attributes Name integer, intent(in) :: parent_id NetCDF ID of the parent group/file character(len=*), intent(in) :: name Name of the variable complex, intent(in), dimension(:, :, :, :) :: values Array to be written character(len=*), intent(in), dimension(:) :: dim_names Array of dimension names character(len=*), intent(in), optional :: units Units of coordinate character(len=*), intent(in), optional :: long_name Long descriptive name integer, intent(in), optional, dimension(:) :: start","tags":"","loc":"proc/write_complex_rank4.html"},{"title":"write_complex_rank5 – stella","text":"private  subroutine write_complex_rank5(parent_id, name, values, dim_names, units, long_name, start) Uses neasyf convert Arguments Type Intent Optional Attributes Name integer, intent(in) :: parent_id NetCDF ID of the parent group/file character(len=*), intent(in) :: name Name of the variable complex, intent(in), dimension(:, :, :, :, :) :: values Array to be written character(len=*), intent(in), dimension(:) :: dim_names Array of dimension names character(len=*), intent(in), optional :: units Units of coordinate character(len=*), intent(in), optional :: long_name Long descriptive name integer, intent(in), optional, dimension(:) :: start","tags":"","loc":"proc/write_complex_rank5.html"},{"title":"read_vmec_parameters – stella","text":"public  subroutine read_vmec_parameters() Uses file_utils zgrid mp Arguments None Namelists Namelist vmec_parameters Variables Name Type Default Description alpha0 real None zeta_center real None nfield_periods real None torflux real None zgrid_scalefac real None zgrid_refinement_factor integer None surface_option integer None verbose logical None vmec_filename character(len=2000) None gradpar_zeta_prefac real None n_tolerated_test_arrays_inconsistencies integer None","tags":"","loc":"proc/read_vmec_parameters.html"},{"title":"init_vmec_defaults – stella","text":"public  subroutine init_vmec_defaults() Uses zgrid Arguments None","tags":"","loc":"proc/init_vmec_defaults.html"},{"title":"get_vmec_geo – stella","text":"public  subroutine get_vmec_geo(new_zeta_min, stellarator_symmetric_BC, nzgrid, nalpha, naky, surf, grho, bmag, gradpar, b_dot_grad_z, grad_alpha_grad_alpha, grad_alpha_grad_psi, grad_psi_grad_psi, gds23, gds24, gds25, gds26, gbdrift_alpha, gbdrift0_psi, cvdrift_alpha, cvdrift0_psi, sign_torflux, theta_vmec, zed_scalefac, L_reference, B_reference, alpha, zeta, field_period_ratio, x_displacement_fac) Uses zgrid common_types mp vmec_to_stella_geometry_interface_mod splines physics_flags file_utils constants To avoid writting twice in the output file when recomputing zeta.\nfirst read in equilibrium information from vmec file\nthis is stored as a set of global variables in read_wout_mod\nin mini_libstell.  it will be accessible\nif desired, increase number of sampled zeta grid points in VMEC data\nto increase accuracy of later integration in zeta and interpolation\nonto stella zed grid allocate vmec geometry arrays of size 2*nzgrid_vmec+1\nget ratio of number of simulated field periods to the number of field periods of the device must interpolate geometric quantities from (zeta,alpha) grid to\n(zed,alpha) grid, with zed the normalised arc-length\nfirst need to get zed(zeta,alpha)\ndefined via H(alpha) = b . grad z = b . grad zeta * dz/dzeta\nand z_min = zeta_min, z_max = zeta_max (independent of alpha).\nnote that nzgrid zgrid_refinement_factor gives index\nfor the max zeta of the nominal zeta grid\nzed_domain_size is z(zeta_max) - z(zeta_min) for nominal zeta domain\nz(zeta_min) should be zeta_min\nb_dot_grad_z is the total arc-length for one toroidal turn,\nmultiplied by 2 pi\nnow that we know the min/max values of z corresponding to min/max values\nof the nominal zeta at each of the alphas, construct a regular z grid\nset the max z value on this regular grid to the maximum over all alpha\nof z(zeta_max,alpha) scale zed so that it is arc-length compressed (or expanded)\nto the range [-pi:pi]\nnow that we have z(alpha,zeta), interpolate from regular zeta grid (which is irregular in z)\nto regular zed grid (irregular in zeta)\ngradpar at this point is b . grad zeta\nbut want it to be b . grad z = b . grad zeta * dz/dzeta.\nwe have constructed b_dot_grad_z = b . grad to be a function purely of alpha,\nso dz/dzeta = b_dot_grad_z(alpha) / b_dot_grad_zeta(alpha,zeta)\ngds23 and gds24 involve grad z factors\nbut currently calculated in terms of grad zeta\nso convert via multiplication with dz/dzeta\ndefine gradpar to be the average value of b_dot_grad_z in alpha we now have geometric coefficients on an alpha-grid.\nas we will be multiplying this with functions of g and phi,\nwe must take care to avoid aliasing.\nthis is accomplished by filtering out the highest third of\nthe wavenumber spectra\nif zed_equal_arc = F, zed coordinate is the same as VMEC's zeta coordinate,\nso no need to interpolate onto a new grid\ngradpar is b . grad zed (or its alpha-average, in the case of full_flux_surface=T),\nwith zed = zeta or normalised arc-length, both scaled to run from -pi to pi\nvmec_to_stella_geometry_interface returns psitor/psitor_lcfs as rhoc\nstella uses rhoc = sqrt(psitor/psitor_lcfs) = rhotor Arguments Type Intent Optional Attributes Name real, intent(in) :: new_zeta_min logical, intent(in) :: stellarator_symmetric_BC integer, intent(in) :: nzgrid integer, intent(in) :: nalpha integer, intent(in) :: naky type( flux_surface_type ), intent(out) :: surf real, intent(out), dimension(:, -nzgrid:) :: grho real, intent(out), dimension(:, -nzgrid:) :: bmag real, intent(out), dimension(-nzgrid:) :: gradpar real, intent(out), dimension(:, -nzgrid:) :: b_dot_grad_z real, intent(out), dimension(:, -nzgrid:) :: grad_alpha_grad_alpha real, intent(out), dimension(:, -nzgrid:) :: grad_alpha_grad_psi real, intent(out), dimension(:, -nzgrid:) :: grad_psi_grad_psi real, intent(out), dimension(:, -nzgrid:) :: gds23 real, intent(out), dimension(:, -nzgrid:) :: gds24 real, intent(out), dimension(:, -nzgrid:) :: gds25 real, intent(out), dimension(:, -nzgrid:) :: gds26 real, intent(out), dimension(:, -nzgrid:) :: gbdrift_alpha real, intent(out), dimension(:, -nzgrid:) :: gbdrift0_psi real, intent(out), dimension(:, -nzgrid:) :: cvdrift_alpha real, intent(out), dimension(:, -nzgrid:) :: cvdrift0_psi integer, intent(out) :: sign_torflux real, intent(out), dimension(:, -nzgrid:) :: theta_vmec real, intent(out) :: zed_scalefac real, intent(out) :: L_reference real, intent(out) :: B_reference real, intent(out), dimension(:) :: alpha real, intent(out), dimension(:, -nzgrid:) :: zeta real, intent(out) :: field_period_ratio real, intent(out), dimension(:, -nzgrid:) :: x_displacement_fac","tags":"","loc":"proc/get_vmec_geo.html"},{"title":"filter_geo_coef – stella","text":"public  subroutine filter_geo_coef(naky, geocoef) Uses stella_transforms Arguments Type Intent Optional Attributes Name integer, intent(in) :: naky real, intent(inout), dimension(:) :: geocoef","tags":"","loc":"proc/filter_geo_coef.html"},{"title":"get_modified_vmec_zeta_grid – stella","text":"public  subroutine get_modified_vmec_zeta_grid(new_zeta_min, stellarator_symmetric_BC, nzgrid_modified, dzeta_modified) Uses zgrid vmec_to_stella_geometry_interface_mod need to extend the maximum and minimum zeta values\nby zgrid_scalefac to ensure that we have information\nabout geometric coefficients everywhere on a fixed\nequal-arc grid in zed\nfirst figure out how many extra zeta grid points are\nrequired at the nominal grid spacing to get out\nto the ends of the extended zeta domain\nfirst calculate the nominal zeta grid used for vmec\nnote that nfield_periods is the number of field periods\nsampled in stella, while nfield_periods_device\nis the number of field periods in the device\nnfield_periods may be reasonably bigger than nfield_periods_device\nas the former is sampled while keeping alpha fixed (rather than theta) maximum zeta value for nominal zeta grid\nexcess_zeta is difference between expanded zeta_max and nominal zeta_max\nassumes equal grid spacing in zeta\nnzgrid_excess is the number of additional zeta grid points needed to\ncover at least excess_zeta\nnow refine the zeta grid by desired amount in\npreparation for interpolation Arguments Type Intent Optional Attributes Name real, intent(in) :: new_zeta_min logical, intent(in) :: stellarator_symmetric_BC integer, intent(out) :: nzgrid_modified real :: dzeta_modified","tags":"","loc":"proc/get_modified_vmec_zeta_grid.html"},{"title":"init_fields – stella","text":"public  subroutine init_fields() Uses physics_flags mp linear_solve Arguments None","tags":"","loc":"proc/init_fields.html"},{"title":"init_fields_fluxtube – stella","text":"private  subroutine init_fields_fluxtube() Uses physics_parameters mp zgrid dist_fn_arrays species stella_layouts physics_flags gyro_averages fields_arrays kt_grids vpamu_grids stella_geometry run_parameters Todo would be tidier if the code related to radial profile variation\nwere gathered into a separate subroutine or subroutines\ninit_fields_fluxtube allocates and fills arrays needed during main time advance\nloop for the field solve for flux tube simulations compute coefficients for even part of field solve (phi, bpar)\ngamtotinv11\ngamtotinv13, gamtotinv31, gamtotinv33 Arguments None","tags":"","loc":"proc/init_fields_fluxtube.html"},{"title":"init_radial_field_solve – stella","text":"private  subroutine init_radial_field_solve() Uses mp zgrid linear_solve species physics_flags file_utils multibox fields_arrays kt_grids stella_transforms run_parameters Arguments None","tags":"","loc":"proc/init_radial_field_solve.html"},{"title":"init_fields_ffs – stella","text":"private  subroutine init_fields_ffs() Uses species init_fields_ffs allocates and fills arrays needed during main time advance\nloop for the field solve for full_flux_surface simulations allocate arrays such as phi that are needed\nthroughout the simulation calculate and LU factorise the matrix multiplying the electrostatic potential in quasineutrality\nthis involves the factor 1-Gamma_0(kperp(alpha)) if using a modified Boltzmann response for the electrons\nobtain the response of phi_homogeneous to a unit perturbation in flux-surface-averaged phi Arguments None","tags":"","loc":"proc/init_fields_ffs.html"},{"title":"init_gamma0_factor_ffs – stella","text":"private  subroutine init_gamma0_factor_ffs() Uses physics_parameters zgrid dist_fn_arrays species stella_geometry stella_layouts gyro_averages spfunc kt_grids vpamu_grids stella_transforms calculate and LU factorise the matrix multiplying the electrostatic potential in quasineutrality\nthis involves the factor 1-Gamma_0(kperp(alpha)) wgts are species-dependent factors appearing in Gamma0 factor\nallocate gam0_ffs array, which will contain the Fourier coefficients in y\nof the Gamma0 factor that appears in quasineutrality\nin calculating the Fourier coefficients for Gamma_0, change loop orders\nso that inner loop is over ivmu super-index;\nthis is done because we must integrate over v-space and sum over species,\nand we want to minimise memory usage where possible (so, e.g., aj0_alpha need\nonly be a function of ivmu and can be over-written for each (ia,iky,ikx)).\nget J0 for all vpar, mu, spec values\ncalculate the argument of the Bessel function J0\ncompute J0 corresponding to the given argument arg\nform coefficient needed to calculate 1-Gamma_0\ncalculate gamma0(kalpha,alpha,...) = sum_s Zs&#94;2 * ns / Ts int d3v (1-J0&#94;2)*F_{Maxwellian}\nnote that v-space Jacobian contains alpha-dependent factor, B(z,alpha),\nbut this is not a problem as we have yet to transform from alpha to k_alpha\nif Boltzmann response used, account for non-flux-surface-averaged component of electron density\nif kx = ky = 0, 1-Gam0 factor is zero;\nthis leads to eqn of form 0 * phi_00 = int d3v g.\nhack for now is to set phi_00 = 0, as above inversion is singular.\nto avoid singular inversion, set gam0_alpha = 1.0\nfourier transform Gamma_0(alpha) from alpha to k_alpha space\nallocate array to hold the Fourier coefficients\nfill the array with the requisite coefficients LU factorise array of gam0, using the LAPACK zgbtrf routine for banded matrices Arguments None","tags":"","loc":"proc/init_gamma0_factor_ffs.html"},{"title":"init_adiabatic_response_factor – stella","text":"private  subroutine init_adiabatic_response_factor() Uses physics_parameters zgrid volume_averages gyro_averages kt_grids stella_transforms solves Delta * phi_hom = -delta_{ky,0} * ne/Te for phi_hom\nthis is the vector describing the response of phi_hom to a unit impulse in phi_fsa\nit is the sum over ky and integral over kx of this that is needed, and this\nis stored in adiabatic_response_factor adiabatic_response_vector is initialised to be the rhs of the equation for the\n'homogeneous' part of phi, with a unit impulse assumed for the flux-surface-averaged phi\nonly the ky=0 component contributes to the flux-surface-averaged potential\npass in the rhs and overwrite with the solution for phi_homogeneous obtain the flux surface average of the response vector Arguments None","tags":"","loc":"proc/init_adiabatic_response_factor.html"},{"title":"allocate_arrays – stella","text":"private  subroutine allocate_arrays() Uses zgrid stella_layouts physics_flags fields_arrays kt_grids Arguments None","tags":"","loc":"proc/allocate_arrays~3.html"},{"title":"enforce_reality_field – stella","text":"public  subroutine enforce_reality_field(fin) Uses kt_grids zgrid Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: fin","tags":"","loc":"proc/enforce_reality_field.html"},{"title":"advance_fields_vmu_lo – stella","text":"private  subroutine advance_fields_vmu_lo(g, phi, apar, bpar, dist) Uses job_manage mp zgrid dist_fn_arrays dist_redistribute stella_layouts physics_flags run_parameters redistribute time the communications + field solve\nfields_kxkyz = F is the default\nfirst gather (vpa,mu) onto processor for v-space operations\nv-space operations are field solve, dg/dvpa, and collisions\ngiven gvmu with vpa and mu local, calculate the corresponding fields\nset a flag to indicate that the fields have been updated\nthis helps avoid unnecessary field solves\ntime the communications + field solve Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: phi complex, intent(out), dimension(:, :, -nzgrid:, :) :: apar complex, intent(out), dimension(:, :, -nzgrid:, :) :: bpar character(len=*), intent(in) :: dist","tags":"","loc":"proc/advance_fields_vmu_lo.html"},{"title":"advance_fields_kxkyz_lo – stella","text":"private  subroutine advance_fields_kxkyz_lo(gvmu, phi, apar, bpar, dist) Uses job_manage mp zgrid stella_layouts physics_flags run_parameters redistribute time the communications + field solve given gvmu with vpa and mu local, calculate the corresponding fields\nset a flag to indicate that the fields have been updated\nthis helps avoid unnecessary field solves\ntime the communications + field solve Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: gvmu complex, intent(out), dimension(:, :, -nzgrid:, :) :: phi complex, intent(out), dimension(:, :, -nzgrid:, :) :: apar complex, intent(out), dimension(:, :, -nzgrid:, :) :: bpar character(len=*), intent(in) :: dist","tags":"","loc":"proc/advance_fields_kxkyz_lo.html"},{"title":"get_fields – stella","text":"public  subroutine get_fields(g, phi, apar, bpar, dist, skip_fsa) Uses physics_parameters job_manage mp zgrid dist_fn_arrays species stella_layouts physics_flags gyro_averages vpamu_grids run_parameters integrate g to get sum_s Z_s n_s J0 g and store in phi\nintegrate g to get - 2 beta sum_s n_s T_s J1 mu g and store in bpar Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: phi complex, intent(out), dimension(:, :, -nzgrid:, :) :: apar complex, intent(out), dimension(:, :, -nzgrid:, :) :: bpar character(len=*), intent(in) :: dist logical, intent(in), optional :: skip_fsa","tags":"","loc":"proc/get_fields.html"},{"title":"get_fields_vmulo – stella","text":"private  subroutine get_fields_vmulo(g, phi, apar, bpar, dist, skip_fsa) Uses physics_parameters job_manage mp zgrid dist_fn_arrays species stella_layouts physics_flags gyro_averages vpamu_grids run_parameters store result in phi, which will be further modified below to account for polarization term\nstore result in phi, which will be further modified below to account for polarization term\nstore result in bpar, which will be further modified below to account for polarization term\nstore result in apar, which will be further modified below to account for apar pre-factor Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: phi complex, intent(out), dimension(:, :, -nzgrid:, :) :: apar complex, intent(out), dimension(:, :, -nzgrid:, :) :: bpar character(len=*), intent(in) :: dist logical, intent(in), optional :: skip_fsa","tags":"","loc":"proc/get_fields_vmulo.html"},{"title":"get_fields_ffs – stella","text":"private  subroutine get_fields_ffs(g, phi, apar) Uses physics_parameters mp zgrid volume_averages species stella_layouts physics_flags kt_grids run_parameters get_fields_ffs accepts as input the guiding centre distribution function g\nand calculates/returns the electronstatic potential phi for full_flux_surface simulations calculate the contribution to quasineutrality coming from the velocity space\nintegration of the guiding centre distribution function g;\nthe sign is consistent with phi appearing on the RHS of the eqn and int g appearing on the LHS.\nthis is returned in source\nuse sum_s int d3v and QN to solve for phi\nNB: assuming here that ntubes = 1 for FFS sim\nif using a modified Boltzmann response for the electrons, then phi\nat this stage is the 'inhomogeneous' part of phi.\nfirst must get phi on grid that includes positive and negative ky (but only positive kx)\ncalculate the flux surface average of this phi_inhomogeneous\nuse the flux surface average of phi_inhomogeneous, together with the\nadiabatic_response_factor, to obtain the flux-surface-averaged phi\nuse the computed flux surface average of phi as an additional sosurce in quasineutrality\nto obtain the electrostatic potential; only affects the ky=0 component of QN\nif adiabatic electrons are not employed, then\nno explicit equation for the ky=kx=0 component of phi;\nhack for now is to set it equal to zero. Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: phi complex, intent(out), dimension(:, :, -nzgrid:, :) :: apar","tags":"","loc":"proc/get_fields_ffs.html"},{"title":"get_fields_by_spec – stella","text":"public  subroutine get_fields_by_spec(g, fld, skip_fsa) Uses mp zgrid species stella_layouts physics_flags gyro_averages kt_grids vpamu_grids stella_geometry run_parameters Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: fld logical, intent(in), optional :: skip_fsa","tags":"","loc":"proc/get_fields_by_spec.html"},{"title":"get_fields_by_spec_idx – stella","text":"public  subroutine get_fields_by_spec_idx(isa, g, fld) Uses mp zgrid dist_fn_arrays species stella_layouts physics_flags gyro_averages spfunc kt_grids vpamu_grids stella_geometry run_parameters Arguments Type Intent Optional Attributes Name integer, intent(in) :: isa complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: fld","tags":"","loc":"proc/get_fields_by_spec_idx.html"},{"title":"get_phi – stella","text":"private  subroutine get_phi(phi, dist, skip_fsa) Uses job_manage mp zgrid species physics_flags file_utils multibox fields_arrays kt_grids stella_geometry run_parameters Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi character(len=*), intent(in) :: dist logical, intent(in), optional :: skip_fsa","tags":"","loc":"proc/get_phi.html"},{"title":"get_phi_and_bpar – stella","text":"private  subroutine get_phi_and_bpar(phi, bpar, dist, skip_fsa) Uses job_manage mp zgrid species physics_flags file_utils multibox fields_arrays kt_grids stella_geometry run_parameters divide sum ( Zs int J0 h d&#94;3 v) by sum(Zs&#94;2 ns / Ts)\ndo nothing for bpar because\nbpar = - 2 * beta * sum(Ts ns int (J1/bs) mu h d&#94;3 v)\nwhich is already stored in bpar when dist = 'h'. Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :) :: bpar character(len=*), intent(in) :: dist logical, intent(in), optional :: skip_fsa","tags":"","loc":"proc/get_phi_and_bpar.html"},{"title":"get_phi_radial – stella","text":"private  subroutine get_phi_radial(phi) Uses zgrid linear_solve species physics_flags fields_arrays kt_grids stella_transforms run_parameters Non-perturbative approach to solving quasineutrality for radially\nglobal simulations Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi","tags":"","loc":"proc/get_phi_radial.html"},{"title":"get_apar – stella","text":"private  subroutine get_apar(apar, dist) Uses mp dist_fn_arrays zgrid Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: apar character(len=*), intent(in) :: dist","tags":"","loc":"proc/get_apar.html"},{"title":"advance_apar – stella","text":"public  subroutine advance_apar(g, dist, apar) Uses physics_parameters mp zgrid species stella_layouts physics_flags gyro_averages vpamu_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g character(len=*), intent(in) :: dist complex, intent(out), dimension(:, :, -nzgrid:, :) :: apar","tags":"","loc":"proc/advance_apar.html"},{"title":"add_adiabatic_response_radial – stella","text":"private  subroutine add_adiabatic_response_radial(phi) Uses zgrid linear_solve fields_arrays kt_grids stella_transforms stella_geometry Add the adiabatic eletron contribution for globally radial simulations.\nThis actually entails solving for the whole ky = 0 slice of phi at once (not really adding!) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi","tags":"","loc":"proc/add_adiabatic_response_radial.html"},{"title":"get_phi_ffs – stella","text":"private  subroutine get_phi_ffs(rhs, phi) Uses kt_grids zgrid gyro_averages change from rhs defined on grid with ky >=0 and kx from 0,...,kxmax,-kxmax,...,-dkx\nto rhs_swap defined on grid with ky = -kymax,...,kymax and kx >= 0\nsolve sum_s Z_s int d&#94;3v = gam0*phi\nwhere sum_s Z_s int d&#94;3v is initially passed in as rhs_swap\nand then rhs_swap is over-written with the solution to the linear system swap back from the ordered grid in ky to the original (kx,ky) grid Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:) :: rhs complex, intent(out), dimension(:, :, -nzgrid:) :: phi","tags":"","loc":"proc/get_phi_ffs.html"},{"title":"add_radial_correction_int_species – stella","text":"private  subroutine add_radial_correction_int_species(g_in) Uses zgrid dist_fn_arrays species stella_layouts gyro_averages kt_grids vpamu_grids stella_geometry run_parameters Add radial variation of the Jacobian and gyroaveraing in the velocity integration of , needed for radially global simulations Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g_in","tags":"","loc":"proc/add_radial_correction_int_species.html"},{"title":"get_radial_correction – stella","text":"public  subroutine get_radial_correction(g, phi0, dist) Uses mp zgrid dist_fn_arrays species stella_layouts physics_flags gyro_averages fields_arrays kt_grids vpamu_grids stella_transforms stella_geometry run_parameters the following routine gets the correction in phi both from gyroaveraging and quasineutrality collect quasineutrality corrections in wavenumber space zero out the ones we have already solved for using the full method\ncollect gyroaveraging corrections in wavenumber space Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi0 character(len=*), intent(in) :: dist","tags":"","loc":"proc/get_radial_correction.html"},{"title":"rescale_fields – stella","text":"public  subroutine rescale_fields(target_amplitude) Uses job_manage mp volume_averages dist_fn_arrays file_utils fields_arrays rescale fields, including the distribution function Arguments Type Intent Optional Attributes Name real, intent(in) :: target_amplitude","tags":"","loc":"proc/rescale_fields.html"},{"title":"get_dchidy_4d – stella","text":"private  subroutine get_dchidy_4d(phi, apar, bpar, dchidy) Uses zgrid species physics_flags stella_layouts gyro_averages constants kt_grids vpamu_grids run_parameters compute d /dy in (ky,kx,z,tube) space include bpar contribution Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(in), dimension(:, :, -nzgrid:, :) :: apar complex, intent(in), dimension(:, :, -nzgrid:, :) :: bpar complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dchidy","tags":"","loc":"proc/get_dchidy_4d.html"},{"title":"get_dchidy_2d – stella","text":"private  subroutine get_dchidy_2d(iz, ivmu, phi, apar, bpar, dchidy) Uses species physics_flags stella_layouts gyro_averages constants kt_grids vpamu_grids run_parameters compute d /dy in (ky,kx) space include bpar contribution Arguments Type Intent Optional Attributes Name integer, intent(in) :: iz integer, intent(in) :: ivmu complex, intent(in), dimension(:, :) :: phi complex, intent(in), dimension(:, :) :: apar complex, intent(in), dimension(:, :) :: bpar complex, intent(out), dimension(:, :) :: dchidy","tags":"","loc":"proc/get_dchidy_2d.html"},{"title":"get_dchidx – stella","text":"public  subroutine get_dchidx(iz, ivmu, phi, apar, bpar, dchidx) Uses species physics_flags stella_layouts gyro_averages constants kt_grids vpamu_grids run_parameters compute d /dx in (ky,kx) space include bpar contribution Arguments Type Intent Optional Attributes Name integer, intent(in) :: iz integer, intent(in) :: ivmu complex, intent(in), dimension(:, :) :: phi complex, intent(in), dimension(:, :) :: apar complex, intent(in), dimension(:, :) :: bpar complex, intent(out), dimension(:, :) :: dchidx","tags":"","loc":"proc/get_dchidx.html"},{"title":"finish_fields – stella","text":"public  subroutine finish_fields() Uses fields_arrays arrays only allocated/used if simulating a full flux surface Arguments None","tags":"","loc":"proc/finish_fields.html"},{"title":"get_dchidy – stella","text":"public interface get_dchidy Module Procedures private  subroutine get_dchidy_4d (phi, apar, bpar, dchidy) compute d /dy in (ky,kx,z,tube) space Read more… Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(in), dimension(:, :, -nzgrid:, :) :: apar complex, intent(in), dimension(:, :, -nzgrid:, :) :: bpar complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dchidy private  subroutine get_dchidy_2d (iz, ivmu, phi, apar, bpar, dchidy) compute d /dy in (ky,kx) space Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: iz integer, intent(in) :: ivmu complex, intent(in), dimension(:, :) :: phi complex, intent(in), dimension(:, :) :: apar complex, intent(in), dimension(:, :) :: bpar complex, intent(out), dimension(:, :) :: dchidy","tags":"","loc":"interface/get_dchidy.html"},{"title":"advance_fields – stella","text":"public interface advance_fields Module Procedures private  subroutine advance_fields_vmu_lo (g, phi, apar, bpar, dist) time the communications + field solve\nfields_kxkyz = F is the default\nfirst gather (vpa,mu) onto processor for v-space operations\nv-space operations are field solve, dg/dvpa, and collisions\ngiven gvmu with vpa and mu local, calculate the corresponding fields\nset a flag to indicate that the fields have been updated\nthis helps avoid unnecessary field solves\ntime the communications + field solve Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: phi complex, intent(out), dimension(:, :, -nzgrid:, :) :: apar complex, intent(out), dimension(:, :, -nzgrid:, :) :: bpar character(len=*), intent(in) :: dist private  subroutine advance_fields_kxkyz_lo (gvmu, phi, apar, bpar, dist) time the communications + field solve Read more… Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: gvmu complex, intent(out), dimension(:, :, -nzgrid:, :) :: phi complex, intent(out), dimension(:, :, -nzgrid:, :) :: apar complex, intent(out), dimension(:, :, -nzgrid:, :) :: bpar character(len=*), intent(in) :: dist","tags":"","loc":"interface/advance_fields.html"},{"title":"cdfr_3i – stella","text":"public  subroutine cdfr_3i(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier","tags":"","loc":"proc/cdfr_3i.html"},{"title":"cdfr_3l – stella","text":"public  subroutine cdfr_3l(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier","tags":"","loc":"proc/cdfr_3l.html"},{"title":"cdfr_3d – stella","text":"public  subroutine cdfr_3d(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier","tags":"","loc":"proc/cdfr_3d.html"},{"title":"cdfr_3c16 – stella","text":"public  subroutine cdfr_3c16(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier","tags":"","loc":"proc/cdfr_3c16.html"},{"title":"cdfr_3f – stella","text":"public  subroutine cdfr_3f(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier","tags":"","loc":"proc/cdfr_3f.html"},{"title":"cdfr_3c8 – stella","text":"public  subroutine cdfr_3c8(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier","tags":"","loc":"proc/cdfr_3c8.html"},{"title":"cdfr_2i – stella","text":"public  subroutine cdfr_2i(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier","tags":"","loc":"proc/cdfr_2i.html"},{"title":"cdfr_2l – stella","text":"public  subroutine cdfr_2l(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier","tags":"","loc":"proc/cdfr_2l.html"},{"title":"cdfr_2d – stella","text":"public  subroutine cdfr_2d(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier","tags":"","loc":"proc/cdfr_2d.html"},{"title":"cdfr_2c16 – stella","text":"public  subroutine cdfr_2c16(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier","tags":"","loc":"proc/cdfr_2c16.html"},{"title":"cdfr_2f – stella","text":"public  subroutine cdfr_2f(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier","tags":"","loc":"proc/cdfr_2f.html"},{"title":"cdfr_2c8 – stella","text":"public  subroutine cdfr_2c8(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier","tags":"","loc":"proc/cdfr_2c8.html"},{"title":"cdfr_2c – stella","text":"public  subroutine cdfr_2c(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier","tags":"","loc":"proc/cdfr_2c.html"},{"title":"cdfr_1i – stella","text":"public  subroutine cdfr_1i(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier","tags":"","loc":"proc/cdfr_1i.html"},{"title":"cdfr_1l – stella","text":"public  subroutine cdfr_1l(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier","tags":"","loc":"proc/cdfr_1l.html"},{"title":"cdfr_1d – stella","text":"public  subroutine cdfr_1d(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier","tags":"","loc":"proc/cdfr_1d.html"},{"title":"cdfr_1c16 – stella","text":"public  subroutine cdfr_1c16(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier","tags":"","loc":"proc/cdfr_1c16.html"},{"title":"cdfr_1f – stella","text":"public  subroutine cdfr_1f(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier","tags":"","loc":"proc/cdfr_1f.html"},{"title":"cdfr_1c8 – stella","text":"public  subroutine cdfr_1c8(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier","tags":"","loc":"proc/cdfr_1c8.html"},{"title":"cdfr_1c – stella","text":"public  subroutine cdfr_1c(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(inout) :: varval integer, intent(out), optional :: ier","tags":"","loc":"proc/cdfr_1c.html"},{"title":"cdfr_0i – stella","text":"public  subroutine cdfr_0i(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(out) :: varval integer, intent(out), optional :: ier","tags":"","loc":"proc/cdfr_0i.html"},{"title":"cdfr_0l – stella","text":"public  subroutine cdfr_0l(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(out) :: varval integer, intent(out), optional :: ier","tags":"","loc":"proc/cdfr_0l.html"},{"title":"cdfr_0d – stella","text":"public  subroutine cdfr_0d(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(out) :: varval integer, intent(out), optional :: ier","tags":"","loc":"proc/cdfr_0d.html"},{"title":"cdfr_0c16 – stella","text":"public  subroutine cdfr_0c16(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(out) :: varval integer, intent(out), optional :: ier","tags":"","loc":"proc/cdfr_0c16.html"},{"title":"cdfr_0f – stella","text":"public  subroutine cdfr_0f(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(out) :: varval integer, intent(out), optional :: ier","tags":"","loc":"proc/cdfr_0f.html"},{"title":"cdfr_0c8 – stella","text":"public  subroutine cdfr_0c8(ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(out) :: varval integer, intent(out), optional :: ier","tags":"","loc":"proc/cdfr_0c8.html"},{"title":"cdf_read – stella","text":"public interface cdf_read Module Procedures public  subroutine cdfr_3i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_3l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_3d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_3c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_3f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_3c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_2i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_2l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_2d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_2c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_2f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_2c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_2c (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_1i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_1l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_1d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_1c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_1f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_1c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_1c (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(inout) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_0i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(out) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_0l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(out) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_0d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(out) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_0c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(out) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_0f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(out) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_0c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(out) :: varval integer, intent(out), optional :: ier","tags":"","loc":"interface/cdf_read.html"},{"title":"cdfGetVar – stella","text":"public interface cdfGetVar Module Procedures public  subroutine cdfr_3i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_3l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_3d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_3c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_3f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_3c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_2i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_2l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_2d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_2c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_2f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_2c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_2c (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_1i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_1l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_1d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_1c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_1f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_1c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_1c (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(inout) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_0i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(out) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_0l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(out) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_0d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(out) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_0c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(out) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_0f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(out) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_0c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(out) :: varval integer, intent(out), optional :: ier","tags":"","loc":"interface/cdfgetvar.html"},{"title":"get_netcdf_code_precision – stella","text":"public  function get_netcdf_code_precision() result(code_real) Uses file_utils constants Arguments None Return Value integer","tags":"","loc":"proc/get_netcdf_code_precision.html"},{"title":"check_netcdf_file_precision – stella","text":"public  subroutine check_netcdf_file_precision(ncid, filename) Uses file_utils Arguments Type Intent Optional Attributes Name integer(kind=kind_nf), intent(in), optional :: ncid character(len=*), intent(in), optional :: filename","tags":"","loc":"proc/check_netcdf_file_precision.html"},{"title":"netcdf_error – stella","text":"public  subroutine netcdf_error(istatus, ncid, varid, dimid, file, dim, var, att, message, abort) Uses file_utils mp Arguments Type Intent Optional Attributes Name integer(kind=kind_nf), intent(in) :: istatus integer(kind=kind_nf), intent(in), optional :: ncid integer(kind=kind_nf), intent(in), optional :: varid integer(kind=kind_nf), intent(in), optional :: dimid character(len=*), intent(in), optional :: file character(len=*), intent(in), optional :: dim character(len=*), intent(in), optional :: var character(len=*), intent(in), optional :: att character(len=*), intent(in), optional :: message logical, intent(in), optional :: abort","tags":"","loc":"proc/netcdf_error.html"},{"title":"init_dissipation – stella","text":"public  subroutine init_dissipation() Uses mp hyper Arguments None","tags":"","loc":"proc/init_dissipation.html"},{"title":"read_parameters – stella","text":"public  subroutine read_parameters() Uses coll_fokkerplanck mp coll_dougherty file_utils hyper run_parameters Arguments None Namelists Namelist dissipation Variables Name Type Default Description include_collisions logical None collisions_implicit logical None collision_model character(len=30) None hyper_dissipation logical None","tags":"","loc":"proc/read_parameters~5.html"},{"title":"init_collisions – stella","text":"public  subroutine init_collisions() Uses coll_dougherty coll_fokkerplanck Arguments None","tags":"","loc":"proc/init_collisions.html"},{"title":"finish_dissipation – stella","text":"public  subroutine finish_dissipation() Arguments None","tags":"","loc":"proc/finish_dissipation.html"},{"title":"finish_collisions – stella","text":"private  subroutine finish_collisions() Uses coll_dougherty coll_fokkerplanck Arguments None","tags":"","loc":"proc/finish_collisions.html"},{"title":"advance_collisions_explicit – stella","text":"public  subroutine advance_collisions_explicit(g, phi, bpar, gke_rhs) Uses coll_fokkerplanck mp zgrid coll_dougherty physics_flags stella_layouts Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(in), dimension(:, :, -nzgrid:, :) :: bpar complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gke_rhs","tags":"","loc":"proc/advance_collisions_explicit.html"},{"title":"advance_collisions_implicit – stella","text":"public  subroutine advance_collisions_implicit(mirror_implicit, phi, apar, bpar, g) Uses coll_fokkerplanck job_manage mp zgrid dist_fn_arrays dist_redistribute coll_dougherty stella_layouts vpamu_grids redistribute switch the vpa integration weights to ensure correct integration by parts Arguments Type Intent Optional Attributes Name logical, intent(in) :: mirror_implicit complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :) :: apar complex, intent(inout), dimension(:, :, -nzgrid:, :) :: bpar complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g","tags":"","loc":"proc/advance_collisions_implicit.html"},{"title":"associated_laguerre – stella","text":"private elemental function associated_laguerre(n, alpha, x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real, intent(in) :: alpha real, intent(in) :: x Return Value real","tags":"","loc":"proc/associated_laguerre.html"},{"title":"associated_legendre – stella","text":"private elemental function associated_legendre(l, m, x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: l integer, intent(in) :: m double precision, intent(in) :: x Return Value double precision","tags":"","loc":"proc/associated_legendre.html"},{"title":"read_parameters_fp – stella","text":"public  subroutine read_parameters_fp() Uses physics_flags file_utils mp Arguments None Namelists Namelist collisions_fp Variables Name Type Default Description testpart logical None fieldpart logical None lmax integer 1 jmax integer 1 nvel_local integer None interspec logical None intraspec logical None iiknob real None ieknob real None eeknob real None eiknob real None eiediffknob real None eideflknob real None deflknob real None eimassr_approx logical None advfield_coll logical None spitzer_problem logical None density_conservation logical None density_conservation_field logical None density_conservation_tp logical None exact_conservation logical None exact_conservation_tp logical None vpa_operator logical None mu_operator logical None cfac real None cfac2 real None nuxfac real None i1fac real None i2fac real None no_j1l1 logical None no_j1l2 logical None no_j0l2 logical None","tags":"","loc":"proc/read_parameters_fp.html"},{"title":"init_collisions_fp – stella","text":"public  subroutine init_collisions_fp(collisions_implicit, cfl_dt_vpadiff, cfl_dt_mudiff) Uses common_types species stella_layouts vpamu_grids stella_geometry run_parameters Arguments Type Intent Optional Attributes Name logical, intent(in) :: collisions_implicit real, intent(out) :: cfl_dt_vpadiff real, intent(out) :: cfl_dt_mudiff","tags":"","loc":"proc/init_collisions_fp.html"},{"title":"init_nusDpa – stella","text":"private  subroutine init_nusDpa() Uses zgrid species spfunc constants finite_differences vpamu_grids stella_geometry Arguments None","tags":"","loc":"proc/init_nusdpa.html"},{"title":"finish_nusDpa – stella","text":"private  subroutine finish_nusDpa() Arguments None","tags":"","loc":"proc/finish_nusdpa.html"},{"title":"init_fp_diffmatrix – stella","text":"private  subroutine init_fp_diffmatrix() Uses physics_parameters zgrid common_types dist_fn_arrays species stella_layouts file_utils spfunc constants kt_grids vpamu_grids stella_time stella_geometry Arguments None","tags":"","loc":"proc/init_fp_diffmatrix.html"},{"title":"init_legendre – stella","text":"private  subroutine init_legendre() Uses zgrid stella_layouts file_utils vpamu_grids stella_geometry Arguments None","tags":"","loc":"proc/init_legendre.html"},{"title":"init_bessel_fn – stella","text":"private  subroutine init_bessel_fn() Uses zgrid dist_fn_arrays species stella_layouts file_utils gyro_averages kt_grids vpamu_grids stella_geometry Arguments None","tags":"","loc":"proc/init_bessel_fn.html"},{"title":"init_vgrid – stella","text":"private  subroutine init_vgrid() Uses vpamu_grids stella_geometry Arguments None","tags":"","loc":"proc/init_vgrid.html"},{"title":"gamlow – stella","text":"private recursive subroutine gamlow(a, x, gl) Uses spfunc constants Arguments Type Intent Optional Attributes Name real, intent(in) :: a real, intent(in) :: x real, intent(out) :: gl","tags":"","loc":"proc/gamlow.html"},{"title":"gamup – stella","text":"private recursive subroutine gamup(a, x, gu) Uses spfunc constants Arguments Type Intent Optional Attributes Name real, intent(in) :: a real, intent(in) :: x real, intent(out) :: gu","tags":"","loc":"proc/gamup.html"},{"title":"calc_delta0 – stella","text":"private  subroutine calc_delta0(xa, jj, ll, isa, isb, delt0) Uses species constants Arguments Type Intent Optional Attributes Name real, intent(in) :: xa integer, intent(in) :: jj integer, intent(in) :: ll integer, intent(in) :: isa integer, intent(in) :: isb real, intent(out) :: delt0","tags":"","loc":"proc/calc_delta0.html"},{"title":"calc_deltaj_vmu – stella","text":"private recursive subroutine calc_deltaj_vmu(jj, nn, ll, isa, isb, deltj) Uses species zgrid stella_geometry vpamu_grids Arguments Type Intent Optional Attributes Name integer, intent(in) :: jj integer, intent(in) :: nn integer, intent(in) :: ll integer, intent(in) :: isa integer, intent(in) :: isb real, intent(out), dimension(nvpa, nmu, -nzgrid:nzgrid) :: deltj","tags":"","loc":"proc/calc_deltaj_vmu.html"},{"title":"vLj_vmu – stella","text":"private  subroutine vLj_vmu(jj, ll, vLj) Uses species zgrid stella_geometry vpamu_grids Arguments Type Intent Optional Attributes Name integer, intent(in) :: jj integer, intent(in) :: ll real, intent(out), dimension(nvpa, nmu, -nzgrid:nzgrid) :: vLj","tags":"","loc":"proc/vlj_vmu.html"},{"title":"calc_psi_vmu – stella","text":"private recursive subroutine calc_psi_vmu(jj, nn, ll, isa, isb, psij) Uses species zgrid vpamu_grids Arguments Type Intent Optional Attributes Name integer, intent(in) :: jj integer, intent(in) :: nn integer, intent(in) :: ll integer, intent(in) :: isa integer, intent(in) :: isb real, intent(out), dimension(-nzgrid:nzgrid) :: psij","tags":"","loc":"proc/calc_psi_vmu.html"},{"title":"init_deltaj_vmu – stella","text":"private  subroutine init_deltaj_vmu() Uses zgrid species file_utils stella_layouts constants kt_grids vpamu_grids stella_time stella_geometry Arguments None","tags":"","loc":"proc/init_deltaj_vmu.html"},{"title":"get_testpart_density – stella","text":"private  subroutine get_testpart_density(isa, isb, g, fld) Uses mp zgrid species stella_layouts file_utils constants vpamu_grids stella_time Arguments Type Intent Optional Attributes Name integer, intent(in) :: isa integer, intent(in) :: isb complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: fld","tags":"","loc":"proc/get_testpart_density.html"},{"title":"init_fp_conserve – stella","text":"private  subroutine init_fp_conserve() Uses zgrid job_manage linear_solve dist_fn_arrays species stella_layouts file_utils fields constants kt_grids vpamu_grids stella_time Arguments None","tags":"","loc":"proc/init_fp_conserve.html"},{"title":"get_psi_response – stella","text":"private  subroutine get_psi_response(ll, mm, jj, isa, response) Uses zgrid job_manage linear_solve species stella_layouts file_utils fields constants finite_differences kt_grids vpamu_grids stella_time Arguments Type Intent Optional Attributes Name integer, intent(in) :: ll integer, intent(in) :: mm integer, intent(in) :: jj integer, intent(in) :: isa complex, intent(out), dimension(:, :, kxkyz_lo%llim_proc:) :: response","tags":"","loc":"proc/get_psi_response.html"},{"title":"get_psi – stella","text":"private  subroutine get_psi(g, fld, isa, isb, ll, mm, jj) Uses mp zgrid species stella_layouts file_utils constants vpamu_grids stella_time Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: fld integer, intent(in) :: isa integer, intent(in) :: isb integer, intent(in) :: ll integer, intent(in) :: mm integer, intent(in) :: jj","tags":"","loc":"proc/get_psi.html"},{"title":"finish_collisions_fp – stella","text":"public  subroutine finish_collisions_fp() Arguments None","tags":"","loc":"proc/finish_collisions_fp.html"},{"title":"finish_deltaj – stella","text":"private  subroutine finish_deltaj() Arguments None","tags":"","loc":"proc/finish_deltaj.html"},{"title":"finish_fp_diffmatrix – stella","text":"private  subroutine finish_fp_diffmatrix() Arguments None","tags":"","loc":"proc/finish_fp_diffmatrix.html"},{"title":"finish_fp_response – stella","text":"private  subroutine finish_fp_response() Arguments None","tags":"","loc":"proc/finish_fp_response.html"},{"title":"advance_collisions_fp_explicit – stella","text":"public  subroutine advance_collisions_fp_explicit(g, phi, bpar, gke_rhs, time_collisions) Uses g_tofrom_h job_manage mp zgrid dist_fn_arrays dist_redistribute physics_flags stella_layouts run_parameters kt_grids vpamu_grids stella_time redistribute Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(in), dimension(:, :, -nzgrid:, :) :: bpar complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gke_rhs real, intent(inout), dimension(:, :) :: time_collisions","tags":"","loc":"proc/advance_collisions_fp_explicit.html"},{"title":"vpa_differential_operator_fp – stella","text":"private  subroutine vpa_differential_operator_fp(h, Dh, imu, iz, is, ia) Uses vpamu_grids stella_geometry species constants Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: h complex, intent(out), dimension(:, :) :: Dh integer, intent(in) :: imu integer, intent(in) :: iz integer, intent(in) :: is integer, intent(in) :: ia","tags":"","loc":"proc/vpa_differential_operator_fp.html"},{"title":"mu_differential_operator_fp – stella","text":"private  subroutine mu_differential_operator_fp(h, Dh, iv, iz, is, ia, iky, ikx, cfac) Uses job_manage dist_fn_arrays species constants vpamu_grids stella_geometry Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: h complex, intent(out), dimension(:, :) :: Dh integer, intent(in) :: iv integer, intent(in) :: iz integer, intent(in) :: is integer, intent(in) :: ia integer, intent(in) :: iky integer, intent(in) :: ikx real, intent(in) :: cfac","tags":"","loc":"proc/mu_differential_operator_fp.html"},{"title":"vpa_differential_operator_fp_conservative – stella","text":"private  subroutine vpa_differential_operator_fp_conservative(h, Dh, imu, iz, is, ia) Uses vpamu_grids stella_geometry species constants Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: h complex, intent(out), dimension(:, :) :: Dh integer, intent(in) :: imu integer, intent(in) :: iz integer, intent(in) :: is integer, intent(in) :: ia","tags":"","loc":"proc/vpa_differential_operator_fp_conservative.html"},{"title":"mu_differential_operator_fp_conservative – stella","text":"private  subroutine mu_differential_operator_fp_conservative(h, Dh, iv, iz, is, ia, iky, ikx, cfac) Uses job_manage dist_fn_arrays species constants vpamu_grids stella_geometry Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: h complex, intent(out), dimension(:, :) :: Dh integer, intent(in) :: iv integer, intent(in) :: iz integer, intent(in) :: is integer, intent(in) :: ia integer, intent(in) :: iky integer, intent(in) :: ikx real, intent(in) :: cfac","tags":"","loc":"proc/mu_differential_operator_fp_conservative.html"},{"title":"advance_collisions_fp_implicit – stella","text":"public  subroutine advance_collisions_fp_implicit(phi, apar, bpar) Uses vpamu_grids zgrid dist_fn_arrays Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :) :: apar complex, intent(inout), dimension(:, :, -nzgrid:, :) :: bpar","tags":"","loc":"proc/advance_collisions_fp_implicit.html"},{"title":"advance_implicit_fp – stella","text":"private  subroutine advance_implicit_fp(phi, apar, bpar, g) Uses g_tofrom_h mp zgrid linear_solve species stella_layouts fields constants finite_differences kt_grids vpamu_grids stella_time run_parameters Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :) :: apar complex, intent(inout), dimension(:, :, -nzgrid:, :) :: bpar complex, intent(inout), dimension(:, :, kxkyz_lo%llim_proc:) :: g","tags":"","loc":"proc/advance_implicit_fp.html"},{"title":"cdfInqVar – stella","text":"public  subroutine cdfInqVar(ncid, varnam, dimlens, eztype, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(out), dimension(:) :: dimlens character(len=*), intent(out) :: eztype integer, intent(out), optional :: ier","tags":"","loc":"proc/cdfinqvar.html"},{"title":"cdfgv – stella","text":"public  subroutine cdfgv(ncid, varnam, varid, dimlens, sizes, xtype, status) Arguments Type Intent Optional Attributes Name integer :: ncid character(len=*) :: varnam integer :: varid integer, dimension(:) :: dimlens integer, dimension(:) :: sizes character(len=1) :: xtype integer :: status","tags":"","loc":"proc/cdfgv.html"},{"title":"cdfInqV – stella","text":"public  subroutine cdfInqV(ncid, varnam, varid, dimlens, ndims, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(out) :: varid integer, intent(out), dimension(:) :: dimlens integer, intent(out) :: ndims integer, intent(out) :: status","tags":"","loc":"proc/cdfinqv.html"},{"title":"cdf_inquire – stella","text":"public  subroutine cdf_inquire(ncid, varnam, dimlens, xtype, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(out), dimension(:) :: dimlens character(len=*), intent(out), optional :: xtype integer, intent(out), optional :: ier","tags":"","loc":"proc/cdf_inquire.html"},{"title":"alpha_numeric – stella","text":"public  subroutine alpha_numeric(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: string","tags":"","loc":"proc/alpha_numeric.html"},{"title":"cdfInqVarDim – stella","text":"public interface cdfInqVarDim Module Procedures public  subroutine cdfInqV (ncid, varnam, varid, dimlens, ndims, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(out) :: varid integer, intent(out), dimension(:) :: dimlens integer, intent(out) :: ndims integer, intent(out) :: status public  subroutine cdfgv (ncid, varnam, varid, dimlens, sizes, xtype, status) Arguments Type Intent Optional Attributes Name integer :: ncid character(len=*) :: varnam integer :: varid integer, dimension(:) :: dimlens integer, dimension(:) :: sizes character(len=1) :: xtype integer :: status public  subroutine cdf_inquire (ncid, varnam, dimlens, xtype, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(out), dimension(:) :: dimlens character(len=*), intent(out), optional :: xtype integer, intent(out), optional :: ier","tags":"","loc":"interface/cdfinqvardim.html"},{"title":"safe_open – stella","text":"public  subroutine safe_open(iunit, istat, filename, filestat, fileform, record_in, access_in, delim_in) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: iunit integer, intent(out) :: istat character(len=*), intent(in) :: filename character(len=*), intent(in) :: filestat character(len=*), intent(in) :: fileform integer, intent(in), optional :: record_in character(len=*), intent(in), optional :: access_in character(len=*), intent(in), optional :: delim_in","tags":"","loc":"proc/safe_open.html"},{"title":"x5c2r – stella","text":"private  subroutine x5c2r(a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, :, :, :) :: a real, intent(out), dimension(:, :, :, :, :, :) :: a_ri","tags":"","loc":"proc/x5c2r.html"},{"title":"x6c2r – stella","text":"private  subroutine x6c2r(a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, :, :, :, :) :: a real, intent(out), dimension(:, :, :, :, :, :, :) :: a_ri","tags":"","loc":"proc/x6c2r.html"},{"title":"x5r2c – stella","text":"private  subroutine x5r2c(a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :, :, :, :) :: a real, intent(in), dimension(:, :, :, :, :, :) :: a_ri","tags":"","loc":"proc/x5r2c.html"},{"title":"x4c2r – stella","text":"private  subroutine x4c2r(a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, :, :) :: a real, intent(out), dimension(:, :, :, :, :) :: a_ri","tags":"","loc":"proc/x4c2r.html"},{"title":"x4r2c – stella","text":"private  subroutine x4r2c(a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :, :, :) :: a real, intent(in), dimension(:, :, :, :, :) :: a_ri","tags":"","loc":"proc/x4r2c.html"},{"title":"x3c2r – stella","text":"private  subroutine x3c2r(a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, :) :: a real, intent(out), dimension(:, :, :, :) :: a_ri","tags":"","loc":"proc/x3c2r.html"},{"title":"x3r2c – stella","text":"private  subroutine x3r2c(a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :, :) :: a real, intent(in), dimension(:, :, :, :) :: a_ri","tags":"","loc":"proc/x3r2c.html"},{"title":"x2c2r – stella","text":"private  subroutine x2c2r(a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: a real, intent(out), dimension(:, :, :) :: a_ri","tags":"","loc":"proc/x2c2r.html"},{"title":"x2r2c – stella","text":"private  subroutine x2r2c(a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :) :: a real, intent(in), dimension(:, :, :) :: a_ri","tags":"","loc":"proc/x2r2c.html"},{"title":"x1c2r – stella","text":"private  subroutine x1c2r(a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: a real, intent(out), dimension(:, :) :: a_ri","tags":"","loc":"proc/x1c2r.html"},{"title":"x1r2c – stella","text":"private  subroutine x1r2c(a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:) :: a real, intent(in), dimension(:, :) :: a_ri","tags":"","loc":"proc/x1r2c.html"},{"title":"Aborter – stella","text":"private  subroutine Aborter(iunit, ierrmsg) Arguments Type Intent Optional Attributes Name integer :: iunit character(len=1) :: ierrmsg *(*) Common Blocks common /abortcmn/ Type Attributes Name Initial real :: zz0 real :: zz1","tags":"","loc":"proc/aborter.html"},{"title":"c2r – stella","text":"public interface c2r Module Procedures private  subroutine x1c2r (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: a real, intent(out), dimension(:, :) :: a_ri private  subroutine x2c2r (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: a real, intent(out), dimension(:, :, :) :: a_ri private  subroutine x3c2r (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, :) :: a real, intent(out), dimension(:, :, :, :) :: a_ri private  subroutine x4c2r (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, :, :) :: a real, intent(out), dimension(:, :, :, :, :) :: a_ri private  subroutine x5c2r (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, :, :, :) :: a real, intent(out), dimension(:, :, :, :, :, :) :: a_ri private  subroutine x6c2r (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, :, :, :, :) :: a real, intent(out), dimension(:, :, :, :, :, :, :) :: a_ri","tags":"","loc":"interface/c2r.html"},{"title":"r2c – stella","text":"public interface r2c Module Procedures private  subroutine x1r2c (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:) :: a real, intent(in), dimension(:, :) :: a_ri private  subroutine x2r2c (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :) :: a real, intent(in), dimension(:, :, :) :: a_ri private  subroutine x3r2c (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :, :) :: a real, intent(in), dimension(:, :, :, :) :: a_ri private  subroutine x4r2c (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :, :, :) :: a real, intent(in), dimension(:, :, :, :, :) :: a_ri private  subroutine x5r2c (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :, :, :, :) :: a real, intent(in), dimension(:, :, :, :, :, :) :: a_ri","tags":"","loc":"interface/r2c.html"},{"title":"init_mirror – stella","text":"public  subroutine init_mirror() Uses zgrid species physics_flags run_parameters kt_grids vpamu_grids stella_time stella_geometry neoclassical_terms mirror has sign consistent with being on RHS of GKE;\nit is the factor multiplying dg/dvpa in the mirror term\nmirror_sign set to +/- 1 depending on the sign of the mirror term.\nNB: mirror_sign = -1 corresponds to positive advection velocity\nset up the tridiagonal matrix that must be inverted\nfor the implicit treatment of the mirror operator Arguments None","tags":"","loc":"proc/init_mirror.html"},{"title":"init_mirror_semi_lagrange – stella","text":"private  subroutine init_mirror_semi_lagrange() Uses kt_grids vpamu_grids zgrid species Arguments None","tags":"","loc":"proc/init_mirror_semi_lagrange.html"},{"title":"init_invert_mirror_operator – stella","text":"private  subroutine init_invert_mirror_operator() Uses mp zgrid species stella_layouts physics_flags run_parameters kt_grids vpamu_grids stella_geometry neoclassical_terms mirror_int_fac = exp(vpa&#94;2 * (mu dB/dz)/(mu dB/dz + Z e dpihnc/dz))\nis the integrating factor needed to turn the dg/dvpa part of the GKE advance\ninto an advection equation\na, b and c contain the sub-, main- and super-diagonal terms, respectively\nif running in full-flux-surface mode, solve mirror advance\nin y-space rather than ky-space due to alpha-dependence of coefficients\ncorresponds to sign of mirror term positive on RHS of equation\nmust treat boundary carefully\nassumes fully upwinded at outgoing boundary\ncorresponds to sign of mirror term negative on RHS of equation\nmust treat boundary carefully\nassumes fully upwinded at outgoing boundary\ntime_upwind = 0.0 corresponds to centered in time\ntime_upwind = 1.0 corresponds to fully implicit (upwinded)\naccount for fact that we have expanded d(gnorm)/dvpa, where gnorm = g/exp(-v&#94;s);\nthis gives rise to d(gnorm exp(-vpa&#94;2))/dvpa + 2 vpa gnorm exp(-vpa&#94;2) term\nwe solve for gnorm*exp(-vpa&#94;2) and later multiply by exp(vpa&#94;2) to get gnorm\nmultiply by mirror coefficient Arguments None","tags":"","loc":"proc/init_invert_mirror_operator.html"},{"title":"init_mirror_response – stella","text":"private  subroutine init_mirror_response() Uses zgrid stella_layouts fields kt_grids vpamu_grids Arguments None","tags":"","loc":"proc/init_mirror_response.html"},{"title":"advance_mirror_explicit – stella","text":"public  subroutine advance_mirror_explicit(g, gout) Uses job_manage mp zgrid dist_fn_arrays dist_redistribute stella_layouts physics_flags run_parameters kt_grids vpamu_grids stella_transforms redistribute advance_mirror_explicit calculates the contribution to the RHS of the gyrokinetic equation\ndue to the mirror force term; it treats all terms explicitly in time start the timer for this subroutine assume we are simulating a single flux surface swap from ky >= 0 and all kx to kx >= 0 and all ky\nneeded for ky2y transform below\nfor upwinding of vpa, need to evaluate dg/dvpa in y-space\nthis is necessary because the advection speed contains dB/dz, which depends on y\nfirst must take g(ky,kx) and transform to g(y,kx)\nremap g so velocities are local\nnext, calculate dg/dvpa;\nwe enforce a boundary condition on , but with full_flux_surface = T,\ng = / F, so we use the chain rule to get two terms:\none with exp(vpa&#94;2)*d /dvpa and another that is proportional to exp(vpa&#94;2) * /F * d ln F /dvpa\nremove exp(-vpa&#94;2) normalisation from g before differentiating\nget d / dvpa\nthen take the results and remap again so y,kx,z local. finally add the mirror term to the RHS of the GK eqn Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout","tags":"","loc":"proc/advance_mirror_explicit.html"},{"title":"add_mirror_radial_variation – stella","text":"public  subroutine add_mirror_radial_variation(g, gout) Uses job_manage mp zgrid dist_fn_arrays dist_redistribute stella_layouts physics_flags run_parameters vpamu_grids redistribute Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout","tags":"","loc":"proc/add_mirror_radial_variation.html"},{"title":"get_dgdvpa_ffs – stella","text":"private  subroutine get_dgdvpa_ffs(g, ikxyz) Uses vpamu_grids stella_layouts finite_differences Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: g integer, intent(in) :: ikxyz","tags":"","loc":"proc/get_dgdvpa_ffs.html"},{"title":"get_dgdvpa_explicit – stella","text":"private  subroutine get_dgdvpa_explicit(g) Uses vpamu_grids stella_layouts finite_differences Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, kxkyz_lo%llim_proc:) :: g","tags":"","loc":"proc/get_dgdvpa_explicit.html"},{"title":"add_mirror_term – stella","text":"private  subroutine add_mirror_term(g, src) Uses kt_grids stella_layouts zgrid Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: src","tags":"","loc":"proc/add_mirror_term.html"},{"title":"add_mirror_term_ffs – stella","text":"private  subroutine add_mirror_term_ffs(g, src) Uses kt_grids stella_layouts zgrid Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: src","tags":"","loc":"proc/add_mirror_term_ffs.html"},{"title":"advance_mirror_implicit – stella","text":"public  subroutine advance_mirror_implicit(collisions_implicit, g, apar) Uses g_tofrom_h job_manage mp zgrid dist_fn_arrays dist_redistribute stella_layouts physics_flags neoclassical_terms fields constants finite_differences run_parameters kt_grids vpamu_grids stella_transforms redistribute Arguments Type Intent Optional Attributes Name logical, intent(in) :: collisions_implicit complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :) :: apar","tags":"","loc":"proc/advance_mirror_implicit.html"},{"title":"get_mirror_rhs_g_contribution – stella","text":"private  subroutine get_mirror_rhs_g_contribution(g_in, apar, imu, ikxkyz, rhs) Uses g_tofrom_h stella_layouts physics_flags finite_differences fields_arrays vpamu_grids run_parameters Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: g_in complex, intent(in) :: apar integer, intent(in) :: imu integer, intent(in) :: ikxkyz complex, intent(out), dimension(:) :: rhs","tags":"","loc":"proc/get_mirror_rhs_g_contribution.html"},{"title":"get_mirror_rhs_apar_contribution – stella","text":"private  subroutine get_mirror_rhs_apar_contribution(rhs, apar, imu, ikxkyz) Uses species stella_layouts gyro_averages vpamu_grids run_parameters Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:) :: rhs complex, intent(in) :: apar integer, intent(in) :: imu integer, intent(in) :: ikxkyz","tags":"","loc":"proc/get_mirror_rhs_apar_contribution.html"},{"title":"vpa_interpolation – stella","text":"private  subroutine vpa_interpolation(grid, interp) Uses vpamu_grids stella_layouts run_parameters Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: grid complex, intent(out), dimension(:, :, kxkyz_lo%llim_proc:) :: interp","tags":"","loc":"proc/vpa_interpolation.html"},{"title":"invert_mirror_operator – stella","text":"private  subroutine invert_mirror_operator(imu, ilo, g) Uses finite_differences Arguments Type Intent Optional Attributes Name integer, intent(in) :: imu integer, intent(in) :: ilo complex, intent(inout), dimension(:) :: g","tags":"","loc":"proc/invert_mirror_operator.html"},{"title":"finish_mirror – stella","text":"public  subroutine finish_mirror() Uses run_parameters Arguments None","tags":"","loc":"proc/finish_mirror.html"},{"title":"finish_mirror_semi_lagrange – stella","text":"private  subroutine finish_mirror_semi_lagrange() Arguments None","tags":"","loc":"proc/finish_mirror_semi_lagrange.html"},{"title":"finish_invert_mirror_operator – stella","text":"private  subroutine finish_invert_mirror_operator() Arguments None","tags":"","loc":"proc/finish_invert_mirror_operator.html"},{"title":"finish_mirror_response – stella","text":"private  subroutine finish_mirror_response() Arguments None","tags":"","loc":"proc/finish_mirror_response.html"},{"title":"init_stella – stella","text":"subroutine init_stella(istep0, VERNUM, VERDATE) Uses mp zgrid dist_fn_arrays volume_averages response_matrix fields multibox ran dist_fn species extended_zgrid kt_grids file_utils physics_flags stella_layouts sources fields_arrays vpamu_grids stella_geometry run_parameters stella_transforms time_advance physics_parameters job_manage dist_redistribute init_g dissipation stella_time stella_diagnostics stella_save Initialise stella Calls the initialisation routines for all the geometry, physics, and\ndiagnostic modules initialize mpi message passing\ninitialize timer\nwrite message to screen with useful info regarding start of simulation\ninitialize file i/o\nread the physics_flags namelist from the input file\nread the physics_parameters namelist from the input file\nread the zgrid_parameters namelist from the input file and setup the z grid\nread the species_knobs namelist from the input file\nread the grid option from the kt_grids_knobs namelist in the input file;\ndepending on the grid option chosen, read the corresponding kt_grids_XXXX_parameters\nnamelist from the input file and allocate some kx and ky arrays\nread the vpamu_grids_parameters namelist from the input file\nsetup the various data layouts for the distribution function;\ne.g., vmu_lo is the layout in which vpa, mu and species may be distributed\namongst processors, depending on the number of phase space points and processors\nneeds_transforms indicates whether or not FFTs will be needed in the simulation\nif FFTs are needed, init_transforms sets up the various FFTW plans\nand allocates the necessary arrays\nread in the geometry option and any necessary magnetic geometry info\nand use it to calculate all of the required geometric coefficients\nread species_parameters from input file and use the info to, e.g.,\ndetermine if a modified Boltzmann response is to be used\nread init_g_knobs namelist from the input file\nand prepare for reading in from restart file if requested\nread knobs namelist from the input file\nand the info to determine the mixture of implicit and explicit time advance\nread layouts_knobs namelist from the input file,\nwhich determines the order of parallelisation within the different layouts\nsetup the (kx,ky) grids and (x,y) grids, if applicable\nfinish_init_geometry deallocates various geometric arrays that\nwere defined locally within the millerlocal module when using Miller geometry\nsetup the (vpa,mu) grids and associated integration weights\nset up all of the logic needed to do calculations on an extended grid in z.\nthis extended grid could be due to use of a ballooning angle so that\nz goes from -N pi to N pi, or it could be due to the coupling of different\nkx modes arising from the twist-and-shift boundary condition\nwhen doing a volume average using Fourier coefficients, the\nky=0 mode gets a different weighting than finite ky modes, due\nto the reality condition being imposed; init_volume_averages accounts for this\nallocates and initialises kperp2, vperp2 and arrays needed\nfor gyro-averaging (j0 and j1 or equivalents)\nsets up the mappings between different layouts, needed\nto redistribute data when going from one layout to another\nread dissipation namelist from the input file and print information\nabout chosen options to stdout\nallocate and initialise time-independent arrays needed to\nsolve the field equations; e.g., sum_s (Z_s&#94;2 n_s / T_s)*(1-Gamma0_s)\ninitialise the distribution function in the kxkyz_lo and store in gvmu\nuse mapping from kxkyz_lo to vmu_lo to get a copy of g that has ky, kx and z local to each core;\nstored in gnew and copied to gold\nif initializing from restart file, set the initial time step size appropriately\nset the internal time step size variable code_dt from the input variable delt\nallocate and calculate arrays needed for the mirror, parallel streaming,\nmagnetic drifts, gradient drive, etc. terms during time advance\nget initial field from initial distribution function\nfill in the boundary regions using auxilliary simulations if using\nmultibox, or zero it out if using Dirichlet boundary conditions\nrescale to phiinit if just beginning a new run read stella_diagnostics_knob namelist from the input file,\nopen ascii output files and initialise the neetcdf file with extension .out.nc\ninitialise the code_time\nAdd a header to the output file\nstop the timing of the initialization Arguments Type Intent Optional Attributes Name integer, intent(out) :: istep0 Starting timestep: zero unless the simulation has been restarted character(len=*), intent(in) :: VERNUM stella version number character(len=10), intent(in) :: VERDATE Release date","tags":"","loc":"proc/init_stella.html"},{"title":"init_multibox_subcalls – stella","text":"subroutine init_multibox_subcalls() Uses mp species file_utils physics_flags multibox kt_grids stella_geometry call all the multibox communication subroutines to make sure all the jobs have\nthe appropriate information Arguments None","tags":"","loc":"proc/init_multibox_subcalls.html"},{"title":"check_transforms – stella","text":"subroutine check_transforms(needs_transforms) Uses physics_flags file_utils physics_parameters stella_diagnostics check_transforms checks the various physics flag choices\nto determine if FFTs are needed for the simulation if ExB or parallel nonlinearity included in the simulations, need FFTs\nif 'global' in radial or bi-normal directions, need FFTs\nif running in multibox mode, need FFTs\nif including flow shear using anything other than wavenumber re-mapping, need FFTs\nif printing out flux-surface-averaged radial fluxes or moments, need FFTs Arguments Type Intent Optional Attributes Name logical, intent(out) :: needs_transforms","tags":"","loc":"proc/check_transforms.html"},{"title":"write_start_message – stella","text":"subroutine write_start_message(VERNUM, VERDATE) Uses mp Write the start message to screen Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: VERNUM stella version number character(len=10), intent(in) :: VERDATE Release date","tags":"","loc":"proc/write_start_message.html"},{"title":"print_header – stella","text":"subroutine print_header() Uses mp Arguments None","tags":"","loc":"proc/print_header.html"},{"title":"parse_command_line – stella","text":"subroutine parse_command_line() Uses git_version Parse some basic command line arguments. Currently just 'version' and 'help'. This should be called before anything else, but especially before initialising MPI. Arguments None","tags":"","loc":"proc/parse_command_line.html"},{"title":"finish_stella – stella","text":"subroutine finish_stella(last_call) Uses mp zgrid volume_averages response_matrix parallel_streaming fields multibox implicit_solve dist_fn mirror_terms species extended_zgrid kt_grids file_utils physics_flags sources vpamu_grids stella_geometry run_parameters time_advance physics_parameters job_manage dist_redistribute init_g dissipation stella_diagnostics Finish a simulation, call the finialisation routines of all modules Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: last_call","tags":"","loc":"proc/finish_stella.html"},{"title":"read_stella_diagnostics_knobs – stella","text":"public  subroutine read_stella_diagnostics_knobs() Uses mp Read-in the parameters for the stella_diagnostics module Broadcast the parameters from the namelist \"stella_diagnostics_knobs\" Read the namelist \"stella_diagnostics_knobs\" in the input file Broadcast the variables to all processors Arguments None","tags":"","loc":"proc/read_stella_diagnostics_knobs.html"},{"title":"init_stella_diagnostics – stella","text":"public  subroutine init_stella_diagnostics(restart, tstart) Uses dist_fn physics_parameters zgrid mp species init_g kt_grids stella_io run_parameters Initialise the stella_diagnostics module Broadcast the parameters from the namelist \"stella_diagnostics_knobs\"\nand open/append the netcdf file and the ascii files. Make sure the other routines are intialized\nAllocate the necessary arrays Initiate the netcdf file with extension '.out.nc' Open the '.out', '.fluxes' and '.omega' file Get the final position nout of the time axis in the netcdf file Arguments Type Intent Optional Attributes Name logical, intent(in) :: restart Has this simulation been restarted? real, intent(in) :: tstart Current simulation time","tags":"","loc":"proc/init_stella_diagnostics.html"},{"title":"read_parameters – stella","text":"private  subroutine read_parameters() Uses file_utils mp physics_flags Read the diagnostic input parameters from the input file Namelist: stella_diagnostics_knobs Arguments None Namelists Namelist stella_diagnostics_knobs Variables Name Type Default Description nwrite integer None navg integer None nsave integer None save_for_restart logical None write_phi_vs_time logical None write_apar_vs_time logical None write_bpar_vs_time logical None write_gvmus logical None write_gzvs logical None write_omega logical None write_kspectra logical None write_moments logical None write_radial_fluxes logical None write_radial_moments logical None write_fluxes_kxkyz logical None flux_norm logical None nc_mult integer None","tags":"","loc":"proc/read_parameters~6.html"},{"title":"allocate_arrays – stella","text":"private  subroutine allocate_arrays() Uses kt_grids species Allocate the module-level arrays Arguments None","tags":"","loc":"proc/allocate_arrays~4.html"},{"title":"open_loop_ascii_files – stella","text":"private  subroutine open_loop_ascii_files(restart) Uses species file_utils Open the '.out' and the '.fluxes' file. When running a new simulation, create a new file or replace an old file.\nWhen restarting a simulation, append the old files. Arguments Type Intent Optional Attributes Name logical, intent(in) :: restart","tags":"","loc":"proc/open_loop_ascii_files.html"},{"title":"close_loop_ascii_files – stella","text":"private  subroutine close_loop_ascii_files() Uses file_utils Close the text files opened by open_loop_ascii_files Arguments None","tags":"","loc":"proc/close_loop_ascii_files.html"},{"title":"diagnose_stella – stella","text":"public  subroutine diagnose_stella(istep) Uses g_tofrom_h mp zgrid dist_fn_arrays volume_averages dist_redistribute species physics_flags stella_time fields constants run_parameters fields_arrays kt_grids vpamu_grids stella_io redistribute Calculate and write diagnostics only write data to file every nwrite time steps get the updated fields corresponding to gnew obtain turbulent fluxes calculate the particle density, parallel flow and pressure in (y,kx,z) space\nfor all species\ncalculate the (ky,kx) contributions to the particle, parallel momentum and energy fluxes\nredistribute data so that data for each vpa and mu are guaranteed to be on each processor\nget_fluxes assumes the non-Boltzmann part of the distribution, h, is passed in;\nconvert from = g to h\ncompute the fluxes\nconvert back from h to g\nhere write out the spectrum of contributions to the fluxes, after averaging over zed Arguments Type Intent Optional Attributes Name integer, intent(in) :: istep The current timestep","tags":"","loc":"proc/diagnose_stella.html"},{"title":"get_fluxes – stella","text":"private  subroutine get_fluxes(g, pflx, vflx, qflx, pflx_vs_kxkyz, vflx_vs_kxkyz, qflx_vs_kxkyz) Uses mp zgrid species stella_layouts physics_flags gyro_averages constants fields_arrays kt_grids vpamu_grids stella_geometry run_parameters Calculate fluxes Assumes that the non-Boltzmann part of df is passed in (aka h) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g real, intent(out), dimension(:) :: pflx real, intent(out), dimension(:) :: vflx real, intent(out), dimension(:) :: qflx real, intent(out), dimension(:, :, -nzgrid:, :, :) :: pflx_vs_kxkyz real, intent(out), dimension(:, :, -nzgrid:, :, :) :: vflx_vs_kxkyz real, intent(out), dimension(:, :, -nzgrid:, :, :) :: qflx_vs_kxkyz","tags":"","loc":"proc/get_fluxes.html"},{"title":"get_fluxes_vmulo – stella","text":"private  subroutine get_fluxes_vmulo(g, phi, pflx, vflx, qflx, pflx_x, vflx_x, qflx_x, pflx_vs_kxkyz, vflx_vs_kxkyz, qflx_vs_kxkyz) Uses mp zgrid dist_fn_arrays species stella_layouts physics_flags gyro_averages constants kt_grids vpamu_grids stella_geometry run_parameters Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi real, intent(out), dimension(:) :: pflx real, intent(out), dimension(:) :: vflx real, intent(out), dimension(:) :: qflx real, intent(out), dimension(:, :) :: pflx_x real, intent(out), dimension(:, :) :: vflx_x real, intent(out), dimension(:, :) :: qflx_x real, intent(out), dimension(:, :, -nzgrid:, :, :) :: pflx_vs_kxkyz real, intent(out), dimension(:, :, -nzgrid:, :, :) :: vflx_vs_kxkyz real, intent(out), dimension(:, :, -nzgrid:, :, :) :: qflx_vs_kxkyz","tags":"","loc":"proc/get_fluxes_vmulo.html"},{"title":"get_fluxes_ffs – stella","text":"private  subroutine get_fluxes_ffs(dens, upar, pres, pflx, vflx, qflx, pflx_vs_kxkyz, vflx_vs_kxkyz, qflx_vs_kxkyz) Uses zgrid constants fields_arrays kt_grids stella_geometry Calculate the total particle, momentum and heat fluxes (pflx, vflx, qflx)\nand the contributions from a given (kx,ky,z) location (pflx_kxkyz, vflx_kxkyz, qflx_kxkyz)\ninputs are the particle density (dens), parallel flow (upar) and pressure (pres) assume a single flux annulus obtain the y-component of the electric field that appears as a factor\nin the flux expression due to the radial component of the ExB velocity\ncompute the flux surface area = int dy dz (dalpha/dy)*(dpsi/dx)  / (B . grad z)\ncompute the flux surface average of |grad x|\nflxfac is pre-factor in front of fluxes Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: dens complex, intent(in), dimension(:, :, -nzgrid:, :) :: upar complex, intent(in), dimension(:, :, -nzgrid:, :) :: pres real, intent(out), dimension(:) :: pflx real, intent(out), dimension(:) :: vflx real, intent(out), dimension(:) :: qflx real, intent(out), dimension(:, :, -nzgrid:, :, :) :: pflx_vs_kxkyz real, intent(out), dimension(:, :, -nzgrid:, :, :) :: vflx_vs_kxkyz real, intent(out), dimension(:, :, -nzgrid:, :, :) :: qflx_vs_kxkyz","tags":"","loc":"proc/get_fluxes_ffs.html"},{"title":"get_one_flux_ffs – stella","text":"private  subroutine get_one_flux_ffs(mom, dphidy, flxfac, flx, flx_vs_kxkyz) Uses kt_grids species zgrid volume_averages divide the input density by the magnetic field strength (due to Jacobian in flux-surfacee avg)\nand Fourier transform in y to get mom_ky = (density/B)(ky,kx,z,spec)\npflx_vs_kxkyz is the particle flux before summing over (kx,ky) and integrating over z\ncalculate the volume average of the particle flux\nnote that the factor of 1/B that appears in the Jacobian has already been taken into account\nin the numerator of the flux surface average Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: mom complex, intent(in), dimension(:, :, -nzgrid:) :: dphidy real, intent(in) :: flxfac real, intent(out), dimension(:) :: flx real, intent(out), dimension(:, :, -nzgrid:, :) :: flx_vs_kxkyz","tags":"","loc":"proc/get_one_flux_ffs.html"},{"title":"get_modified_fourier_coefficient – stella","text":"private  subroutine get_modified_fourier_coefficient(moment, moment_ky) Uses zgrid species kt_grids stella_transforms stella_geometry divide the input moment by the magnetic field strength\nto account for Jacobian in flux-surface average\ntransform the B-modified input moment from y to ky space\nswap from all ky and kx >= 0 to all kx and ky >= 0 Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: moment complex, intent(out), dimension(:, :, -nzgrid:, :) :: moment_ky","tags":"","loc":"proc/get_modified_fourier_coefficient.html"},{"title":"get_one_flux – stella","text":"private  subroutine get_one_flux(iky, iz, norm, gin, fld, flxout) Uses kt_grids vpamu_grids stella_geometry volume_averages Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky integer, intent(in) :: iz real, intent(in) :: norm complex, intent(in), dimension(:, :) :: gin complex, intent(in) :: fld real, intent(inout) :: flxout","tags":"","loc":"proc/get_one_flux.html"},{"title":"get_one_flux_vmulo_int – stella","text":"private  subroutine get_one_flux_vmulo_int(weights, gin, fld, flxout) Uses zgrid volume_averages species stella_layouts physics_flags kt_grids vpamu_grids stella_transforms stella_geometry Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: weights complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gin complex, intent(in), dimension(:, :, -nzgrid:, :) :: fld real, intent(inout), dimension(:) :: flxout","tags":"","loc":"proc/get_one_flux_vmulo_int.html"},{"title":"get_one_flux_vmulo_kxkyz – stella","text":"private  subroutine get_one_flux_vmulo_kxkyz(weights, gin, fld, flxout) Uses zgrid volume_averages species stella_layouts kt_grids vpamu_grids stella_geometry Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: weights complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gin complex, intent(in), dimension(:, :, -nzgrid:, :) :: fld real, intent(inout), dimension(:, :, -nzgrid:, :, :) :: flxout","tags":"","loc":"proc/get_one_flux_vmulo_kxkyz.html"},{"title":"get_one_flux_radial – stella","text":"private  subroutine get_one_flux_radial(weights, gin, fld, flxout) Uses zgrid volume_averages species stella_layouts kt_grids vpamu_grids stella_transforms stella_geometry Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: weights complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gin complex, intent(in), dimension(:, :, -nzgrid:, :) :: fld real, intent(inout), dimension(:, :) :: flxout","tags":"","loc":"proc/get_one_flux_radial.html"},{"title":"get_moments – stella","text":"private  subroutine get_moments(g, dens, upar, temp, dens_x, upar_x, temp_x, spitzer2) Uses zgrid dist_fn_arrays species stella_layouts physics_flags gyro_averages fields_arrays kt_grids vpamu_grids stella_transforms stella_geometry run_parameters Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: dens complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: upar complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: temp real, intent(out), dimension(:, :) :: dens_x real, intent(out), dimension(:, :) :: upar_x real, intent(out), dimension(:, :) :: temp_x complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: spitzer2","tags":"","loc":"proc/get_moments.html"},{"title":"get_moments_ffs – stella","text":"private  subroutine get_moments_ffs(g, dens, upar, pres) Uses zgrid dist_fn_arrays species stella_layouts gyro_averages fields_arrays kt_grids vpamu_grids stella_transforms species-dependent factor by which velocity moments must be multiplied\nto get density, pressure, etc.\nthe guiding centre distribution function, normalized by\nthe equilibrium Maxwellian, is passed in as g.\nto obtain moments such as density, flow and pressure,\nwe need to take moments of the distribution function, f,\nwhich is related to g via\nf/F0 = g + (Ze/T)*( _R - phi)\nobtain g0=f/F0 in Fourier space calculate the Fourier components of the gyro-average f at fixed particle position\ng0=f/F0 is passed in, along with j0_ffs = the Fourier coefficients of J0\ng1= _r is returned assume only a single flux annulus\nfor every (z,vpa,mu,spec) point\nswitch from ky >= 0 and kx = [-kxmax, kxmax]\nto ky = [-kymax, kymax] and kx >= 0\nfor every (z,vpa,mu,spec) point, Fourier tranform from ky to y space to get\nthe kx component of _r\nset species-dependent factors needed for density, parallel flow and pressure\nthe integrand for the density moment is the distribution function\nintegrate over v-space to get the density, normalised by the reference density. the integrand for the pressure moment is the energy-weighted distribution function\nintegrate over v-space to get the pressure, normalised by the reference pressure. the integrand for the parallel flow moment is the parallel velocity\nintegrate over v-space to get the parallel flow, normalised by the reference thermal speed. Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: dens complex, intent(out), dimension(:, :, -nzgrid:, :) :: upar complex, intent(out), dimension(:, :, -nzgrid:, :) :: pres","tags":"","loc":"proc/get_moments_ffs.html"},{"title":"g_to_f – stella","text":"private  subroutine g_to_f(g, phi, f) Uses species stella_layouts gyro_averages zgrid the Fourier components of the guiding centre distribution function\nnormalized by the equilibrium Maxwellian is passed in as g,\nalong with the Fourier components of the electrostatic potential, phi.\ng_to_f calculates the Maxwellian-normalized distribution function f,\nwhich is related to g via\nf = g + (Ze/T)*( _R - phi) compute _R and store in f\nj0_ffs are the fourier coefficients of J0(k_perp(y))\ncalculate the normalized f, given phi and _R (temporarily stored in f) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: f","tags":"","loc":"proc/g_to_f.html"},{"title":"get_gvmus – stella","text":"private  subroutine get_gvmus(g, gv) Uses mp zgrid volume_averages stella_layouts vpamu_grids stella_geometry Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g real, intent(out), dimension(:, :, :) :: gv","tags":"","loc":"proc/get_gvmus.html"},{"title":"get_gzvs – stella","text":"private  subroutine get_gzvs(g, gz) Uses zgrid volume_averages stella_layouts kt_grids vpamu_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g real, intent(out), dimension(:, :, :, :) :: gz","tags":"","loc":"proc/get_gzvs.html"},{"title":"finish_stella_diagnostics – stella","text":"public  subroutine finish_stella_diagnostics(istep) Uses mp dist_fn_arrays dist_redistribute stella_time stella_io redistribute stella_save Arguments Type Intent Optional Attributes Name integer, intent(in) :: istep","tags":"","loc":"proc/finish_stella_diagnostics.html"},{"title":"write_loop_ascii_files – stella","text":"private  subroutine write_loop_ascii_files(istep, phi2, apar2, bpar2, pflx, vflx, qflx, om, om_avg) Uses kt_grids species stella_time Arguments Type Intent Optional Attributes Name integer, intent(in) :: istep real, intent(in) :: phi2 real, intent(in) :: apar2 real, intent(in) :: bpar2 real, intent(in), dimension(:) :: pflx real, intent(in), dimension(:) :: vflx real, intent(in), dimension(:) :: qflx complex, intent(in), dimension(:, :) :: om complex, intent(in), dimension(:, :) :: om_avg","tags":"","loc":"proc/write_loop_ascii_files.html"},{"title":"write_final_ascii_files – stella","text":"private  subroutine write_final_ascii_files() Uses zgrid dist_fn_arrays file_utils fields_arrays kt_grids stella_geometry Arguments None","tags":"","loc":"proc/write_final_ascii_files.html"},{"title":"deallocate_arrays – stella","text":"private  subroutine deallocate_arrays() Arguments None","tags":"","loc":"proc/deallocate_arrays~2.html"},{"title":"get_one_flux_vmulo – stella","text":"private interface get_one_flux_vmulo Module Procedures private  subroutine get_one_flux_vmulo_int (weights, gin, fld, flxout) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: weights complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gin complex, intent(in), dimension(:, :, -nzgrid:, :) :: fld real, intent(inout), dimension(:) :: flxout private  subroutine get_one_flux_vmulo_kxkyz (weights, gin, fld, flxout) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: weights complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gin complex, intent(in), dimension(:, :, -nzgrid:, :) :: fld real, intent(inout), dimension(:, :, -nzgrid:, :, :) :: flxout","tags":"","loc":"interface/get_one_flux_vmulo.html"},{"title":"init_transforms – stella","text":"public  subroutine init_transforms() Uses stella_layouts physics_flags Arguments None","tags":"","loc":"proc/init_transforms.html"},{"title":"init_y_fft – stella","text":"private  subroutine init_y_fft() Uses stella_layouts fft_work Arguments None","tags":"","loc":"proc/init_y_fft.html"},{"title":"init_x_fft – stella","text":"private  subroutine init_x_fft() Uses stella_layouts fft_work Arguments None","tags":"","loc":"proc/init_x_fft.html"},{"title":"init_x_xfirst_fft – stella","text":"private  subroutine init_x_xfirst_fft() Uses stella_layouts fft_work Arguments None","tags":"","loc":"proc/init_x_xfirst_fft.html"},{"title":"init_y_xfirst_fft – stella","text":"private  subroutine init_y_xfirst_fft() Uses stella_layouts fft_work Arguments None","tags":"","loc":"proc/init_y_xfirst_fft.html"},{"title":"init_unpadded_x_fft – stella","text":"private  subroutine init_unpadded_x_fft() Uses stella_layouts fft_work Arguments None","tags":"","loc":"proc/init_unpadded_x_fft.html"},{"title":"init_unpadded_y_fft – stella","text":"private  subroutine init_unpadded_y_fft() Uses stella_layouts fft_work Arguments None","tags":"","loc":"proc/init_unpadded_y_fft.html"},{"title":"init_alpha_fft – stella","text":"private  subroutine init_alpha_fft() Uses stella_layouts fft_work Arguments None","tags":"","loc":"proc/init_alpha_fft.html"},{"title":"transform_ky2y_5d – stella","text":"private  subroutine transform_ky2y_5d(gky_unpad, gy) Uses stella_layouts Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -vmu_lo%nzgrid:, :, vmu_lo%llim_proc:) :: gky_unpad complex, intent(out), dimension(:, :, -vmu_lo%nzgrid:, :, vmu_lo%llim_proc:) :: gy","tags":"","loc":"proc/transform_ky2y_5d.html"},{"title":"transform_ky2y_2d – stella","text":"private  subroutine transform_ky2y_2d(gky_unpad, gy) Uses stella_layouts Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gky_unpad complex, intent(out), dimension(:, :) :: gy","tags":"","loc":"proc/transform_ky2y_2d.html"},{"title":"transform_y2ky_5d – stella","text":"private  subroutine transform_y2ky_5d(gy, gky) Uses stella_layouts Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -vmu_lo%nzgrid:, :, vmu_lo%llim_proc:) :: gy complex, intent(out), dimension(:, :, -vmu_lo%nzgrid:, :, vmu_lo%llim_proc:) :: gky","tags":"","loc":"proc/transform_y2ky_5d.html"},{"title":"transform_y2ky_2d – stella","text":"private  subroutine transform_y2ky_2d(gy, gky) Uses stella_layouts Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: gy complex, intent(out), dimension(:, :) :: gky","tags":"","loc":"proc/transform_y2ky_2d.html"},{"title":"transform_kx2x – stella","text":"public  subroutine transform_kx2x(gkx, gx) Uses stella_layouts Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gkx real, intent(out), dimension(:, :) :: gx","tags":"","loc":"proc/transform_kx2x.html"},{"title":"transform_x2kx – stella","text":"public  subroutine transform_x2kx(gx, gkx) Uses stella_layouts Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: gx complex, intent(out), dimension(:, :) :: gkx","tags":"","loc":"proc/transform_x2kx.html"},{"title":"transform_kx2x_xfirst – stella","text":"public  subroutine transform_kx2x_xfirst(gkx, gx) Uses stella_layouts Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gkx complex, intent(out), dimension(:, :) :: gx","tags":"","loc":"proc/transform_kx2x_xfirst.html"},{"title":"transform_x2kx_xfirst – stella","text":"public  subroutine transform_x2kx_xfirst(gx, gkx) Uses stella_layouts Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gx complex, intent(out), dimension(:, :) :: gkx","tags":"","loc":"proc/transform_x2kx_xfirst.html"},{"title":"transform_ky2y_xfirst – stella","text":"public  subroutine transform_ky2y_xfirst(gky, gy) Uses stella_layouts Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gky real, intent(out), dimension(:, :) :: gy","tags":"","loc":"proc/transform_ky2y_xfirst.html"},{"title":"transform_y2ky_xfirst – stella","text":"public  subroutine transform_y2ky_xfirst(gy, gky) Uses stella_layouts Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: gy complex, intent(out), dimension(:, :) :: gky","tags":"","loc":"proc/transform_y2ky_xfirst.html"},{"title":"transform_kx2x_unpadded – stella","text":"public  subroutine transform_kx2x_unpadded(gkx, gx) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gkx complex, intent(out), dimension(:, :) :: gx","tags":"","loc":"proc/transform_kx2x_unpadded.html"},{"title":"transform_x2kx_unpadded – stella","text":"public  subroutine transform_x2kx_unpadded(gx, gkx) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gx complex, intent(out), dimension(:, :) :: gkx","tags":"","loc":"proc/transform_x2kx_unpadded.html"},{"title":"transform_ky2y_unpadded – stella","text":"public  subroutine transform_ky2y_unpadded(gky, gy) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gky real, intent(out), dimension(:, :) :: gy","tags":"","loc":"proc/transform_ky2y_unpadded.html"},{"title":"transform_y2ky_unpadded – stella","text":"public  subroutine transform_y2ky_unpadded(gy, gky) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :) :: gy complex, intent(out), dimension(:, :) :: gky","tags":"","loc":"proc/transform_y2ky_unpadded.html"},{"title":"transform_kalpha2alpha – stella","text":"public  subroutine transform_kalpha2alpha(gkalph, galph) Uses stella_layouts Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: gkalph real, intent(out), dimension(:) :: galph","tags":"","loc":"proc/transform_kalpha2alpha.html"},{"title":"transform_alpha2kalpha – stella","text":"public  subroutine transform_alpha2kalpha(galph, gkalph) Uses stella_layouts input galph array is real and contains values on the padded alpha grid\ngkalph is output array; it contains the Fourier coefficients of galph\nfor positive ky values only (reality can be used to obtain the negative ky coefs)\nthe highest 1/3 of the ky modes from the FFT have been discarded to avoid de-aliasing Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: galph complex, intent(out), dimension(:) :: gkalph","tags":"","loc":"proc/transform_alpha2kalpha.html"},{"title":"finish_transforms – stella","text":"public  subroutine finish_transforms() Uses physics_flags Arguments None","tags":"","loc":"proc/finish_transforms.html"},{"title":"transform_ky2y – stella","text":"public interface transform_ky2y Module Procedures private  subroutine transform_ky2y_5d (gky_unpad, gy) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -vmu_lo%nzgrid:, :, vmu_lo%llim_proc:) :: gky_unpad complex, intent(out), dimension(:, :, -vmu_lo%nzgrid:, :, vmu_lo%llim_proc:) :: gy private  subroutine transform_ky2y_2d (gky_unpad, gy) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gky_unpad complex, intent(out), dimension(:, :) :: gy","tags":"","loc":"interface/transform_ky2y.html"},{"title":"transform_y2ky – stella","text":"public interface transform_y2ky Module Procedures private  subroutine transform_y2ky_5d (gy, gky) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -vmu_lo%nzgrid:, :, vmu_lo%llim_proc:) :: gy complex, intent(out), dimension(:, :, -vmu_lo%nzgrid:, :, vmu_lo%llim_proc:) :: gky private  subroutine transform_y2ky_2d (gy, gky) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: gy complex, intent(out), dimension(:, :) :: gky","tags":"","loc":"interface/transform_y2ky.html"},{"title":"read_parameters_hyper – stella","text":"public  subroutine read_parameters_hyper() Uses physics_flags file_utils mp Arguments None Namelists Namelist hyper Variables Name Type Default Description D_hyper real None use_physical_ksqr logical None scale_to_outboard logical None","tags":"","loc":"proc/read_parameters_hyper.html"},{"title":"init_hyper – stella","text":"public  subroutine init_hyper() Uses kt_grids zgrid stella_geometry dist_fn_arrays avoid spatially dependent kperp (through the geometric coefficients)\nstill allowed to vary along zed with global magnetic shear\nuseful for full_flux_surface and radial_variation runs q_as_x uses a different definition of theta0 get k2max at outboard midplane Arguments None","tags":"","loc":"proc/init_hyper.html"},{"title":"advance_hyper_dissipation – stella","text":"public  subroutine advance_hyper_dissipation(g) Uses zgrid dist_fn_arrays stella_layouts kt_grids stella_time avoid spatially dependent kperp\nadd in hyper-dissipation of form dg/dt = -D (k/kmax)&#94;4 g\nadd in hyper-dissipation of form dg/dt = -D (k/kmax)&#94;4 g Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g","tags":"","loc":"proc/advance_hyper_dissipation.html"},{"title":"FZERO – stella","text":"public  subroutine FZERO(F, B, C, R, RE, AE, IFLAG) BEGIN PROLOGUE  FZERO PURPOSE  Search for a zero of a function F(X) in a given interval\n            (B,C).  It is designed primarily for problems where F(B)\n            and F(C) have opposite signs. LIBRARY   SLATEC CATEGORY  F1B TYPE      SINGLE PRECISION (FZERO-S, DFZERO-D) KEYWORDS  BISECTION, NONLINEAR EQUATIONS, ROOTS, ZEROS AUTHOR  Shampine, L. F., (SNLA)\n           Watts, H. A., (SNLA) DESCRIPTION FZERO searches for a zero of a REAL function F(X) between the\n given REAL values B and C until the width of the interval (B,C)\n has collapsed to within a tolerance specified by the stopping\n criterion,\n    ABS(B-C) .LE. 2.*(RW*ABS(B)+AE).\n The method used is an efficient combination of bisection and the\n secant rule and is due to T. J. Dekker.\n\n Description Of Arguments F     :EXT   - Name of the REAL external function.  This name must\n                  be in an EXTERNAL statement in the calling program.\n                  F must be a function of one REAL argument. B     :INOUT - One end of the REAL interval (B,C).  The value\n                  returned for B usually is the better approximation\n                  to a zero of F. C     :INOUT - The other end of the REAL interval (B,C) R     :IN    - A (better) REAL guess of a zero of F which could help\n                  in speeding up convergence.  If F(B) and F(R) have\n                  opposite signs, a root will be found in the interval\n                  (B,R); if not, but F(R) and F(C) have opposite signs,\n                  a root will be found in the interval (R,C);\n                  otherwise, the interval (B,C) will be searched for a\n                  possible root.  When no better guess is known, it is\n                  recommended that r be set to B or C, since if R is\n                  not interior to the interval (B,C), it will be\n                  ignored. RE    :IN    - Relative error used for RW in the stopping criterion.\n                  If the requested RE is less than machine precision,\n                  then RW is set to approximately machine precision. AE    :IN    - Absolute error used in the stopping criterion.  If\n                  the given interval (B,C) contains the origin, then a\n                  nonzero value should be chosen for AE. IFLAG :OUT   - A status code.  User must check IFLAG after each\n                  call.  Control returns to the user from FZERO in all\n                  cases. 1  B is within the requested tolerance of a zero.\n               The interval (B,C) collapsed to the requested\n               tolerance, the function changes sign in (B,C), and\n               F(X) decreased in magnitude as (B,C) collapsed.\n\n            2  F(B) = 0.  However, the interval (B,C) may not have\n               collapsed to the requested tolerance.\n\n            3  B may be near a singular point of F(X).\n               The interval (B,C) collapsed to the requested tol-\n               erance and the function changes sign in (B,C), but\n               F(X) increased in magnitude as (B,C) collapsed, i.e.\n                 ABS(F(B out)) .GT. MAX(ABS(F(B in)),ABS(F(C in)))\n\n            4  No change in sign of F(X) was found although the\n               interval (B,C) collapsed to the requested tolerance.\n               The user must examine this case and decide whether\n               B is near a local minimum of F(X), or B is near a\n               zero of even multiplicity, or neither of these.\n\n            5  Too many (.GT. 500) function evaluations used. REFERENCES  L. F. Shampine and H. A. Watts, FZERO, a root-solving\n                 code, Report SC-TM-70-631, Sandia Laboratories,\n                 September 1970.\n               T. J. Dekker, Finding a zero by means of successive\n                 linear interpolation, Constructive Aspects of the\n                 Fundamental Theorem of Algebra, edited by B. Dejon\n                 and P. Henrici, Wiley-Interscience, 1969. ROUTINES CALLED  R1MACH REVISION HISTORY  (YYMMDD)\n   700901  DATE WRITTEN\n   890531  Changed all specific intrinsics to generic.  (WRB)\n   890531  REVISION DATE from Version 3.2\n   891214  Prologue converted to Version 4.0 format.  (BAB)\n   920501  Reformatted the REFERENCES section.  (WRB) END PROLOGUE  FZERO\n      USE stel_kinds\n**FIRST EXECUTABLE STATEMENT  FZERO ER is two times the computer unit roundoff value which is defined\n   here by the function EPSILON. Arguments Type Intent Optional Attributes Name real :: F real :: B real :: C real :: R real :: RE real :: AE integer :: IFLAG","tags":"","loc":"proc/fzero.html"},{"title":"gbar_to_g_kxkyz – stella","text":"private  subroutine gbar_to_g_kxkyz(g, apar, facapar) Uses zgrid species stella_layouts gyro_averages vpamu_grids run_parameters adjust apar part of Zs / Ts Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: apar real, intent(in) :: facapar","tags":"","loc":"proc/gbar_to_g_kxkyz.html"},{"title":"gbar_to_g_1d_vpa – stella","text":"private  subroutine gbar_to_g_1d_vpa(g, apar, imu, ikxkyz, facapar) Uses species stella_layouts gyro_averages vpamu_grids run_parameters adjust apar part of Zs / Ts Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: g complex, intent(in) :: apar integer, intent(in) :: imu integer, intent(in) :: ikxkyz real, intent(in) :: facapar","tags":"","loc":"proc/gbar_to_g_1d_vpa.html"},{"title":"gbar_to_g_vmu – stella","text":"private  subroutine gbar_to_g_vmu(g, apar, facapar) Uses stella_layouts zgrid Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: apar real, intent(in) :: facapar","tags":"","loc":"proc/gbar_to_g_vmu.html"},{"title":"gbar_to_g_vmu_single – stella","text":"private  subroutine gbar_to_g_vmu_single(ivmu, g0, apar, facapar) Uses zgrid species stella_layouts gyro_averages kt_grids vpamu_grids run_parameters adjust apar part of Arguments Type Intent Optional Attributes Name integer, intent(in) :: ivmu complex, intent(inout), dimension(:, :, -nzgrid:, :) :: g0 complex, intent(in), dimension(:, :, -nzgrid:, :) :: apar real, intent(in) :: facapar","tags":"","loc":"proc/gbar_to_g_vmu_single.html"},{"title":"g_to_h_vmu – stella","text":"private  subroutine g_to_h_vmu(g, phi, bpar, facphi, phi_corr) Uses stella_layouts zgrid Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(in), dimension(:, :, -nzgrid:, :) :: bpar real, intent(in) :: facphi complex, intent(in), optional, dimension(:, :, -nzgrid:, :) :: phi_corr","tags":"","loc":"proc/g_to_h_vmu.html"},{"title":"g_to_h_vmu_single – stella","text":"private  subroutine g_to_h_vmu_single(ivmu, g0, phi, bpar, facphi, phi_corr) Uses zgrid dist_fn_arrays species stella_layouts physics_flags gyro_averages kt_grids vpamu_grids stella_geometry run_parameters adjust bpar part of Zs / Ts Arguments Type Intent Optional Attributes Name integer, intent(in) :: ivmu complex, intent(inout), dimension(:, :, -nzgrid:, :) :: g0 complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(in), dimension(:, :, -nzgrid:, :) :: bpar real, intent(in) :: facphi complex, intent(in), optional, dimension(:, :, -nzgrid:, :) :: phi_corr","tags":"","loc":"proc/g_to_h_vmu_single.html"},{"title":"g_to_h_kxkyz – stella","text":"private  subroutine g_to_h_kxkyz(g, phi, bpar, facphi) Uses zgrid species stella_layouts physics_flags gyro_averages vpamu_grids run_parameters adjust bpar part of Zs / Ts Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(in), dimension(:, :, -nzgrid:, :) :: bpar real, intent(in) :: facphi","tags":"","loc":"proc/g_to_h_kxkyz.html"},{"title":"gbar_to_g – stella","text":"public interface gbar_to_g Module Procedures private  subroutine gbar_to_g_kxkyz (g, apar, facapar) adjust apar part of Zs / Ts Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: apar real, intent(in) :: facapar private  subroutine gbar_to_g_1d_vpa (g, apar, imu, ikxkyz, facapar) adjust apar part of Zs / Ts Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: g complex, intent(in) :: apar integer, intent(in) :: imu integer, intent(in) :: ikxkyz real, intent(in) :: facapar private  subroutine gbar_to_g_vmu (g, apar, facapar) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: apar real, intent(in) :: facapar private  subroutine gbar_to_g_vmu_single (ivmu, g0, apar, facapar) adjust apar part of Arguments Type Intent Optional Attributes Name integer, intent(in) :: ivmu complex, intent(inout), dimension(:, :, -nzgrid:, :) :: g0 complex, intent(in), dimension(:, :, -nzgrid:, :) :: apar real, intent(in) :: facapar","tags":"","loc":"interface/gbar_to_g.html"},{"title":"g_to_h – stella","text":"public interface g_to_h Module Procedures private  subroutine g_to_h_kxkyz (g, phi, bpar, facphi) adjust bpar part of Zs / Ts Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(in), dimension(:, :, -nzgrid:, :) :: bpar real, intent(in) :: facphi private  subroutine g_to_h_vmu (g, phi, bpar, facphi, phi_corr) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(in), dimension(:, :, -nzgrid:, :) :: bpar real, intent(in) :: facphi complex, intent(in), optional, dimension(:, :, -nzgrid:, :) :: phi_corr private  subroutine g_to_h_vmu_single (ivmu, g0, phi, bpar, facphi, phi_corr) adjust bpar part of Zs / Ts Arguments Type Intent Optional Attributes Name integer, intent(in) :: ivmu complex, intent(inout), dimension(:, :, -nzgrid:, :) :: g0 complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(in), dimension(:, :, -nzgrid:, :) :: bpar real, intent(in) :: facphi complex, intent(in), optional, dimension(:, :, -nzgrid:, :) :: phi_corr","tags":"","loc":"interface/g_to_h.html"},{"title":"read_kt_grids_parameters – stella","text":"public  subroutine read_kt_grids_parameters() Uses mp Arguments None","tags":"","loc":"proc/read_kt_grids_parameters.html"},{"title":"read_grid_option – stella","text":"private  subroutine read_grid_option() Uses file_utils text_options Arguments None","tags":"","loc":"proc/read_grid_option.html"},{"title":"read_kt_grids_box – stella","text":"private  subroutine read_kt_grids_box() Uses physics_flags file_utils Arguments None Namelists Namelist kt_grids_box_parameters Variables Name Type Default Description nx integer None ny integer None jtwist integer None jtwistfac real None x0 real None y0 real None centered_in_rho logical None periodic_variation logical None randomize_phase_shift logical None phase_shift_angle real None","tags":"","loc":"proc/read_kt_grids_box.html"},{"title":"read_kt_grids_range – stella","text":"private  subroutine read_kt_grids_range() Uses file_utils mp physics_flags text_options Arguments None Namelists Namelist kt_grids_range_parameters Variables Name Type Default Description naky integer None nakx integer None aky_min real None aky_max real None theta0_min real None theta0_max real None akx_min real None akx_max real None kyspacing_option character(len=20) 'default'","tags":"","loc":"proc/read_kt_grids_range.html"},{"title":"init_kt_grids – stella","text":"public  subroutine init_kt_grids() Uses zgrid common_types determine if iky corresponds to zonal mode Arguments None","tags":"","loc":"proc/init_kt_grids.html"},{"title":"init_kt_grids_box – stella","text":"private  subroutine init_kt_grids_box() Uses physics_parameters mp common_types zgrid physics_flags file_utils constants stella_geometry ran set jtwist and y0 for cases where they have not been specified\nand for which it makes sense to set them automatically\nsigned version of jtwist, with sign determined by, e.g., magnetic shear if simulating a flux annulus, then\ny0 determined by the physical\nextent of the device if simulating a flux tube\nmakes no sense to have y0 < 0.0\nso abort\nget the grid spacing in ky and then in kx using twist-and-shift BC ky goes from zero to ky_max\nget the ikx index corresponding to kx_max aky_all contains all ky values (positive and negative),\nstored in the same order as akx (0 -> ky_max, -ky_max -> -dky)\nfirst set arrays equal for ky >= 0\naky_all_ordered contains all ky values, stored from\nmost negative to most positive (-ky_max -> ky_max)\nnext fill in ky < 0\nthis is the ky index corresponding to +ky in original array\nkx goes from zero to kx_max down to zero...\nand then from -kx_max to -|kx_min|\nset theta0=0 for ky=0\ntheta0 = kx/ky\ntheta0 = kx/ky/shat\nMAB: a lot of the radial variation coding below should probably be tidied away\ninto one or more separate subroutines\nfor radial variation Arguments None","tags":"","loc":"proc/init_kt_grids_box.html"},{"title":"init_kt_grids_range – stella","text":"private  subroutine init_kt_grids_range() Uses stella_geometry mp common_types zgrid Arguments None","tags":"","loc":"proc/init_kt_grids_range.html"},{"title":"broadcast_input – stella","text":"private  subroutine broadcast_input() Uses mp Arguments None","tags":"","loc":"proc/broadcast_input.html"},{"title":"dump_radial_grid – stella","text":"private  subroutine dump_radial_grid() Uses physics_parameters file_utils stella_geometry Arguments None","tags":"","loc":"proc/dump_radial_grid.html"},{"title":"allocate_arrays – stella","text":"private  subroutine allocate_arrays() Arguments None","tags":"","loc":"proc/allocate_arrays~5.html"},{"title":"swap_kxky_complex – stella","text":"private  subroutine swap_kxky_complex(gin, gout) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout","tags":"","loc":"proc/swap_kxky_complex.html"},{"title":"swap_kxky_real – stella","text":"private  subroutine swap_kxky_real(gin, gout) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: gin real, intent(out), dimension(:, :) :: gout","tags":"","loc":"proc/swap_kxky_real.html"},{"title":"swap_kxky_ordered_real – stella","text":"private  subroutine swap_kxky_ordered_real(gin, gout) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: gin real, intent(out), dimension(:, :) :: gout","tags":"","loc":"proc/swap_kxky_ordered_real.html"},{"title":"swap_kxky_ordered_complex – stella","text":"private  subroutine swap_kxky_ordered_complex(gin, gout) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout","tags":"","loc":"proc/swap_kxky_ordered_complex.html"},{"title":"swap_kxky_back – stella","text":"public  subroutine swap_kxky_back(gin, gout) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout","tags":"","loc":"proc/swap_kxky_back.html"},{"title":"swap_kxky_back_ordered – stella","text":"public  subroutine swap_kxky_back_ordered(gin, gout) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout","tags":"","loc":"proc/swap_kxky_back_ordered.html"},{"title":"communicate_ktgrids_multibox – stella","text":"public  subroutine communicate_ktgrids_multibox() Uses job_manage mp Arguments None","tags":"","loc":"proc/communicate_ktgrids_multibox.html"},{"title":"finish_kt_grids – stella","text":"public  subroutine finish_kt_grids() Arguments None","tags":"","loc":"proc/finish_kt_grids.html"},{"title":"multiply_by_rho – stella","text":"public  subroutine multiply_by_rho(gin) Uses stella_transforms Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: gin","tags":"","loc":"proc/multiply_by_rho.html"},{"title":"swap_kxky – stella","text":"public interface swap_kxky Module Procedures private  subroutine swap_kxky_real (gin, gout) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: gin real, intent(out), dimension(:, :) :: gout private  subroutine swap_kxky_complex (gin, gout) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout","tags":"","loc":"interface/swap_kxky.html"},{"title":"swap_kxky_ordered – stella","text":"public interface swap_kxky_ordered Module Procedures private  subroutine swap_kxky_ordered_real (gin, gout) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: gin real, intent(out), dimension(:, :) :: gout private  subroutine swap_kxky_ordered_complex (gin, gout) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout","tags":"","loc":"interface/swap_kxky_ordered.html"},{"title":"init_time_advance – stella","text":"public  subroutine init_time_advance() Uses mp mirror_terms physics_flags sources dissipation parallel_streaming neoclassical_terms flow_shear read time_advance_knobs namelist from the input file;\nsets the explicit time advance option, as well as allows for scaling of\nthe x and y components of the magnetic drifts and of the drive term\nallocate distribution function sized arrays needed, e.g., for Runge-Kutta time advance\nset up neoclassical corrections to the equilibrium Maxwellian;\nonly calculated/needed when simulating higher order terms in rhostar for intrinsic rotation\ncalculate the term multiplying dg/dvpa in the mirror term\nand set up either the semi-Lagrange machinery or the tridiagonal matrix to be inverted\nif solving implicitly\ncalculate the term multiplying dg/dz in the parallel streaming term\nand set up the tridiagonal matrix to be inverted if solving implicitly\nallocate and calculate the factors multiplying dg/dx, dg/dy, dphi/dx and dphi/dy\nin the magnetic drift terms\nallocate and calculate the factor multiplying dphi/dy in the gradient drive term Arguments None","tags":"","loc":"proc/init_time_advance.html"},{"title":"read_parameters – stella","text":"private  subroutine read_parameters() Uses file_utils run_parameters mp text_options Arguments None Namelists Namelist time_advance_knobs Variables Name Type Default Description xdriftknob real None ydriftknob real None wstarknob real None explicit_option character(len=10) None flip_flop logical None","tags":"","loc":"proc/read_parameters~7.html"},{"title":"init_wdrift – stella","text":"private  subroutine init_wdrift() Uses mp zgrid dist_fn_arrays species stella_layouts run_parameters kt_grids vpamu_grids stella_time stella_geometry neoclassical_terms allocate wdriftx_phi, the factor multiplying dphi/dx in the magnetic drift term\nallocate wdrifty_phi, the factor multiplying dphi/dy in the magnetic drift term\nallocate wdriftx_bpar, the factor multiplying dbpar/dx in the magnetic drift term\nallocate wdrifty_bpar, the factor multiplying dbpar/dy in the magnetic drift term\nallocate wdriftx_g, the factor multiplying dg/dx in the magnetic drift term\nallocate wdrifty_g, the factor multiplying dg/dy in the magnetic drift term\nthis is the curvature drift piece of wdrifty with missing factor of vpa\nvpa factor is missing to avoid singularity when including\nnon-Maxwellian corrections to equilibrium\nthis is the grad-B drift piece of wdrifty\nif including neoclassical correction to equilibrium Maxwellian,\nthen add in v_E&#94;{nc} . grad y dg/dy coefficient here\nif maxwwellian_normalization = .true., evolved distribution function is normalised by a Maxwellian\notherwise, it is not; a Maxwellian weighting factor must thus be included\nassign wdrifty_bpar, neoclassical terms not supported\nif including neoclassical corrections to equilibrium,\nadd in -(Ze/m) * v_curv/vpa . grad y d /dy * dF&#94;{nc}/dvpa term\nand v_E . grad z dF&#94;{nc}/dz (here get the dphi/dy part of v_E)\nNB: the below neoclassical correction needs to be divided by an equilibrium Maxwellian\nif maxwellian_normalization = .true.\nthis is the curvature drift piece of wdriftx with missing factor of vpa\nvpa factor is missing to avoid singularity when including\nnon-Maxwellian corrections to equilibrium\nthis is the grad-B drift piece of wdriftx\nif including neoclassical correction to equilibrium Maxwellian,\nthen add in v_E&#94;{nc} . grad x dg/dx coefficient here\nif maxwellian_normalizatiion = .true., evolved distribution function is normalised by a Maxwellian\notherwise, it is not; a Maxwellian weighting factor must thus be included\nassign wdriftx_bpar, neoclassical terms not supported\nif including neoclassical corrections to equilibrium,\nadd in (Ze/m) * v_curv/vpa . grad x d /dx * dF&#94;{nc}/dvpa term\nand v_E . grad z dF&#94;{nc}/dz (here get the dphi/dx part of v_E)\nand v_E . grad alpha dF&#94;{nc}/dalpha (dphi/dx part of v_E)\nNB: the below neoclassical correction needs to be divided by an equilibrium Maxwellian\nif running with maxwellian_normalzation = .true. Arguments None","tags":"","loc":"proc/init_wdrift.html"},{"title":"init_wstar – stella","text":"private  subroutine init_wstar() Uses mp zgrid dist_fn_arrays species stella_layouts run_parameters kt_grids vpamu_grids stella_time stella_geometry neoclassical_terms Arguments None","tags":"","loc":"proc/init_wstar.html"},{"title":"init_parallel_nonlinearity – stella","text":"private  subroutine init_parallel_nonlinearity() Uses physics_parameters zgrid species physics_flags stella_geometry Arguments None","tags":"","loc":"proc/init_parallel_nonlinearity.html"},{"title":"init_radial_variation – stella","text":"private  subroutine init_radial_variation() Uses zgrid dist_fn_arrays species stella_layouts kt_grids vpamu_grids stella_time stella_geometry Arguments None","tags":"","loc":"proc/init_radial_variation.html"},{"title":"allocate_arrays – stella","text":"private  subroutine allocate_arrays() Uses kt_grids stella_layouts dist_fn_arrays zgrid Arguments None","tags":"","loc":"proc/allocate_arrays~6.html"},{"title":"init_cfl – stella","text":"private  subroutine init_cfl() Uses mp zgrid mirror_terms dist_fn_arrays physics_flags file_utils parallel_streaming dissipation kt_grids vpamu_grids stella_time run_parameters flow_shear Arguments None","tags":"","loc":"proc/init_cfl.html"},{"title":"reset_dt – stella","text":"private  subroutine reset_dt() Uses mirror_terms physics_flags response_matrix sources parallel_streaming dissipation run_parameters flow_shear Arguments None","tags":"","loc":"proc/reset_dt.html"},{"title":"advance_stella – stella","text":"public  subroutine advance_stella(istep, stop_stella) Uses mp dist_fn_arrays sources fields multibox fields_arrays run_parameters unless running in multibox mode, no need to worry about\nmb_communicate calls as the subroutine is immediately exited\nif not in multibox mode.\nsave value of phi & apar\nfor use in diagnostics (to obtain frequency)\nreverse the order of operations every time step\nas part of alternating direction operator splitting\nthis is needed to ensure 2nd order accuracy in time Advance the explicit parts of the GKE\nUse operator splitting to separately evolve all terms treated implicitly\nEnsure fields are updated so that omega calculation is correct. Arguments Type Intent Optional Attributes Name integer, intent(in) :: istep logical, intent(inout) :: stop_stella","tags":"","loc":"proc/advance_stella.html"},{"title":"advance_explicit – stella","text":"private  subroutine advance_explicit(g, restart_time_step, istep) Uses g_tofrom_h job_manage mp zgrid stella_layouts physics_flags parallel_streaming fields extended_zgrid fields_arrays kt_grids advance_explicit takes as input the guiding centre distribution function\nin k-space and updates it to account for all of the terms in the GKE that\nare advanced explicitly in time start the timer for the explicit part of the solve forward Euler\nSSP RK2\ndefault is SSP RK3\nRK4\nenforce periodicity for periodic (including zonal) modes\nstream_sign > 0 corresponds to dz/dt < 0\nstop the timer for the explicit part of the solve Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g logical, intent(inout) :: restart_time_step integer, intent(in) :: istep","tags":"","loc":"proc/advance_explicit.html"},{"title":"advance_explicit_euler – stella","text":"private  subroutine advance_explicit_euler(g, restart_time_step, istep) Uses stella_layouts zgrid multibox dist_fn_arrays advance_explicit_euler uses forward Euler to advance one time step RK_step only true if running in multibox mode Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g logical, intent(inout) :: restart_time_step integer, intent(in) :: istep","tags":"","loc":"proc/advance_explicit_euler.html"},{"title":"advance_explicit_rk2 – stella","text":"private  subroutine advance_explicit_rk2(g, restart_time_step, istep) Uses stella_layouts zgrid multibox dist_fn_arrays advance_expliciit_rk2 uses strong stability-preserving RK2 to advance one time step RK_step only true if running in multibox mode SSP rk2 algorithm to advance explicit part of code\nif GK equation written as dg/dt = rhs - vpar . grad h,\nsolve_gke returns rhs*dt\nthis is g at intermediate time level Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g logical, intent(inout) :: restart_time_step integer, intent(in) :: istep","tags":"","loc":"proc/advance_explicit_rk2.html"},{"title":"advance_explicit_rk3 – stella","text":"private  subroutine advance_explicit_rk3(g, restart_time_step, istep) Uses stella_layouts zgrid multibox dist_fn_arrays strong stability-preserving RK3 RK_STEP = false unless in multibox mode SSP rk3 algorithm to advance explicit part of code\nif GK equation written as dg/dt = rhs - vpar . grad h,\nsolve_gke returns rhs*dt\nthis is g at intermediate time level Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g logical, intent(inout) :: restart_time_step integer, intent(in) :: istep","tags":"","loc":"proc/advance_explicit_rk3.html"},{"title":"advance_explicit_rk4 – stella","text":"private  subroutine advance_explicit_rk4(g, restart_time_step, istep) Uses stella_layouts zgrid multibox dist_fn_arrays standard RK4 RK_step is false unless in multibox mode RK4 algorithm to advance explicit part of code\nif GK equation written as dg/dt = rhs - vpar . grad h,\nsolve_gke returns rhs*dt\nthis is g at intermediate time level Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g logical, intent(inout) :: restart_time_step integer, intent(in) :: istep","tags":"","loc":"proc/advance_explicit_rk4.html"},{"title":"solve_gke – stella","text":"private  subroutine solve_gke(pdf, rhs_ky, restart_time_step, istep) Uses physics_parameters job_manage zgrid mirror_terms g_tofrom_h stella_layouts physics_flags sources dissipation parallel_streaming fields run_parameters multibox fields_arrays kt_grids stella_transforms redistribute flow_shear solve_gke accepts as argument pdf, the guiding centre distribution function in k-space,\nand returns rhs_ky, the right-hand side of the gyrokinetic equation in k-space;\ni.e., if dg/dt = r, then rhs_ky = r dt;\nnote that if include_apar = T, then the input pdf is actually gbar = g + (Ze/T) (vpa/c) F0 if full_flux_surface = .true., then initially obtain the RHS of the GKE in alpha-space;\nwill later inverse Fourier transform to get RHS in k_alpha-space\nrhs_ky will always be needed as the array returned by the subroutine,\nbut intermediate array rhs_y (RHS of gke in alpha-space) only needed for full_flux_surface = .true.\nrhs is array referred to for both flux tube and full-flux-surface simulations;\nfor full-flux-surface it should point to rhs_y\nrhs is array referred to for both flux tube and full-flux-surface simulations;\nfor flux tube it should point to rhs_ky\nstart with g in k-space and (ky,kx,z) local\nobtain fields corresponding to g default is to continue with same time step size.\nif estimated CFL condition for nonlinear terms is violated\nthen restart_time_step will be set to .true.\ncalculate and add ExB nonlinearity to RHS of GK eqn\ndo this first, as the CFL condition may require a change in time step\nand thus recomputation of mirror, wdrift, wstar, and parstream\ninclude contribution from the parallel nonlinearity (aka turbulent acceleration) include contribution from perp flow shear in the parallel component of the toroidal flow calculate and add mirror term to RHS of GK eqn\ncalculate and add alpha-component of magnetic drift term to RHS of GK eqn\ncalculate and add psi-component of magnetic drift term to RHS of GK eqn\ncalculate and add omega_* term to RHS of GK eqn\ncalculate and add contribution from collisions to RHS of GK eqn calculate and add parallel streaming term to RHS of GK eqn\nif simulating a full flux surface (flux annulus), all terms to this point have been calculated\nin real-space in alpha (y); transform to kalpha (ky) space before adding to RHS of GKE.\nNB: it may be that for fully explicit calculation, this transform can be eliminated with additional code changes Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: pdf complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:), target :: rhs_ky logical, intent(out) :: restart_time_step integer, intent(in) :: istep","tags":"","loc":"proc/solve_gke.html"},{"title":"advance_wstar_explicit – stella","text":"private  subroutine advance_wstar_explicit(phi, gout) Uses job_manage mp zgrid dist_fn_arrays stella_layouts physics_flags fields fields_arrays kt_grids stella_transforms start timing the time advance due to the driving gradients get d /dy in k-space assume only a single flux surface simulated\ntransform d /dy from k-space to y-space\nmultiply d /dy with omega_ coefficient and add to source (RHS of GK eqn)\nomega_ stays in ky,kx,z space with ky,kx,z local\nmultiply d /dy with omega_* coefficient and add to source (RHS of GK eqn) stop timing the time advance due to the driving gradients Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout","tags":"","loc":"proc/advance_wstar_explicit.html"},{"title":"advance_wdrifty_explicit – stella","text":"private  subroutine advance_wdrifty_explicit(g, phi, bpar, gout) Uses job_manage mp zgrid dist_fn_arrays stella_layouts physics_flags gyro_averages kt_grids stella_transforms advance_wdrifty_explicit subroutine calculates and adds the y-component of the\nmagnetic drift term to the RHS of the GK equation start the timing of the y component of the magnetic drift advance calculate dg/dy in (ky,kx) space\ncalculate dphi/dy in (ky,kx) space\ncalculate dbpar/dy in (ky,kx) space assume only a single flux surface simulated\ntransform dg/dy from k-space to y-space\nadd vM . grad y dg/dy term to equation get in k-space\ntransform d /dy from k-space to y-space\nadd vM . grad y d /dy term to equation stop the timing of the y component of the magnetic drift advance Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(in), dimension(:, :, -nzgrid:, :) :: bpar complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout","tags":"","loc":"proc/advance_wdrifty_explicit.html"},{"title":"advance_wdriftx_explicit – stella","text":"private  subroutine advance_wdriftx_explicit(g, phi, bpar, gout) Uses job_manage mp zgrid dist_fn_arrays stella_layouts physics_flags gyro_averages kt_grids stella_transforms advance_wdriftx_explicit subroutine calculates and adds the x-component of the\nmagnetic drift term to the RHS of the GK equation start the timing of the x component of the magnetic drift advance do not calculate if wdriftx terms are all zero\ncalculate dg/dx in (ky,kx) space\ncalculate dphi/dx in (ky,kx) space\ncalculate dbpar/dx in (ky,kx) space assume a single flux surface is simulated\ntransform dg/dx from k-space to y-space\nadd vM . grad x dg/dx term to equation\nget in k-space\ntransform d /dx from k-space to y-space\nadd vM . grad x d /dx term to equation\nadd vM . grad x dg/dx term to equation\nget in k-space\nadd vM . grad x d /dx term to equation\nget in k-space\nadd vM . grad x ( 4 mu d /dx ) term to equation\nstop the timing of the x component of the magnetic drift advance Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(in), dimension(:, :, -nzgrid:, :) :: bpar complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout","tags":"","loc":"proc/advance_wdriftx_explicit.html"},{"title":"advance_ExB_nonlinearity – stella","text":"private  subroutine advance_ExB_nonlinearity(g, gout, restart_time_step, istep) Uses physics_parameters job_manage mp zgrid g_tofrom_h stella_layouts stella_geometry physics_flags file_utils gyro_averages fields constants fields_arrays kt_grids stella_time stella_transforms run_parameters compute phase factor needed when running with equilibrium flow shear\ncompute i ky g\nFFT to get dg/dy in (y,x) space\ncompute i kx if running with equilibrium flow shear, make adjustment to\nthe term multiplying dg/dy\nFFT to get d /dx in (y,x) space\nmultiply by the geometric factor appearing in the Poisson bracket;\ni.e., (dx/dpsi dy/dalpha) 0.5\ncompute the contribution to the Poisson bracket from dg/dy*d /dx estimate the CFL dt due to the above contribution estimate the CFL dt due to the above contribution\ncompute dg/dx in k-space (= i kx g)\nif running with equilibrium flow shear, correct dg/dx term\nFFT to get dg/dx in (y,x) space\ncompute d /dy in k-space\nFFT to get d /dy in (y,x) space\nmultiply by the geometric factor appearing in the Poisson bracket;\ni.e., (dx/dpsi dy/dalpha) 0.5\ncompute the contribution to the Poisson bracket from dg/dy*d /dx estimate the CFL dt due to the above contribution estimate the CFL dt due to the above contribution\ncheck estimated cfl_dt to see if the time step size needs to be changed Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout logical, intent(out) :: restart_time_step integer, intent(in) :: istep","tags":"","loc":"proc/advance_exb_nonlinearity.html"},{"title":"advance_parallel_nonlinearity – stella","text":"private  subroutine advance_parallel_nonlinearity(g, gout, restart_time_step) Uses mp zgrid parallel_streaming finite_differences gyro_averages extended_zgrid kt_grids stella_layouts physics_flags file_utils constants fields_arrays vpamu_grids stella_transforms run_parameters job_manage dist_redistribute stella_time redistribute check estimated cfl_dt to see if the time step size needs to be changed Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout logical, intent(out) :: restart_time_step","tags":"","loc":"proc/advance_parallel_nonlinearity.html"},{"title":"advance_radial_variation – stella","text":"private  subroutine advance_radial_variation(g, gout) Uses job_manage mp zgrid dist_fn_arrays mirror_terms stella_layouts physics_flags gyro_averages parallel_streaming fields fields_arrays kt_grids stella_transforms run_parameters flow_shear Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout","tags":"","loc":"proc/advance_radial_variation.html"},{"title":"get_dgdy_2d – stella","text":"private  subroutine get_dgdy_2d(g, dgdy) Uses kt_grids constants compute dg/dy in k-space\naccepts g(ky,kx) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: g complex, intent(out), dimension(:, :) :: dgdy","tags":"","loc":"proc/get_dgdy_2d.html"},{"title":"get_dgdy_3d – stella","text":"private  subroutine get_dgdy_3d(g, dgdy) Uses kt_grids zgrid constants compute dg/dy in k-space\naccepts g(ky,kx,z,tube) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: dgdy","tags":"","loc":"proc/get_dgdy_3d.html"},{"title":"get_dgdy_4d – stella","text":"private  subroutine get_dgdy_4d(g, dgdy) Uses kt_grids stella_layouts constants zgrid compute dg/dy in k-space\naccepts g(ky,kx,z,tube,(vpa,mu,spec)) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dgdy","tags":"","loc":"proc/get_dgdy_4d.html"},{"title":"get_dgdx_2d – stella","text":"private  subroutine get_dgdx_2d(g, dgdx) Uses kt_grids constants compute dg/dx in k-space\naccepts g(ky,kx) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: g complex, intent(out), dimension(:, :) :: dgdx","tags":"","loc":"proc/get_dgdx_2d.html"},{"title":"get_dgdx_3d – stella","text":"private  subroutine get_dgdx_3d(g, dgdx) Uses kt_grids zgrid constants compute dg/dx in k-space\naccepts g(ky,kx,z,tube) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: dgdx","tags":"","loc":"proc/get_dgdx_3d.html"},{"title":"get_dgdx_4d – stella","text":"private  subroutine get_dgdx_4d(g, dgdx) Uses kt_grids stella_layouts constants zgrid compute dg/dx in k-space\naccepts g(ky,kx,z,tube,(vpa,mu,spec)) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dgdx","tags":"","loc":"proc/get_dgdx_4d.html"},{"title":"add_explicit_term – stella","text":"private  subroutine add_explicit_term(g, pre_factor, src) Uses kt_grids stella_layouts zgrid Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g real, intent(in), dimension(-nzgrid:, vmu_lo%llim_proc:) :: pre_factor complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: src","tags":"","loc":"proc/add_explicit_term.html"},{"title":"add_explicit_term_ffs – stella","text":"private  subroutine add_explicit_term_ffs(g, pre_factor, src) Uses kt_grids stella_layouts zgrid add vM . grad y d /dy or vM . grad x d /dx (or equivalents with g) or omega_* * d /dy term to RHS of GK equation Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g real, intent(in), dimension(:, -nzgrid:, vmu_lo%llim_proc:) :: pre_factor complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: src","tags":"","loc":"proc/add_explicit_term_ffs.html"},{"title":"advance_implicit – stella","text":"private  subroutine advance_implicit(istep, phi, apar, bpar, g) Uses job_manage mp zgrid mirror_terms stella_layouts physics_flags dissipation implicit_solve fields multibox hyper run_parameters flow_shear Arguments Type Intent Optional Attributes Name integer, intent(in) :: istep complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :) :: apar complex, intent(inout), dimension(:, :, -nzgrid:, :) :: bpar complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g","tags":"","loc":"proc/advance_implicit.html"},{"title":"mb_communicate – stella","text":"private  subroutine mb_communicate(g_in) Uses mp zgrid stella_layouts file_utils fields multibox fields_arrays Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g_in","tags":"","loc":"proc/mb_communicate.html"},{"title":"checksum_field – stella","text":"private  subroutine checksum_field(field, total) Uses kt_grids zgrid extended_zgrid Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: field real, intent(out) :: total","tags":"","loc":"proc/checksum_field~2.html"},{"title":"checksum_dist – stella","text":"private  subroutine checksum_dist(dist, total, norm) Uses mp zgrid stella_layouts kt_grids vpamu_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dist real, intent(out) :: total logical, intent(in), optional :: norm","tags":"","loc":"proc/checksum_dist~2.html"},{"title":"finish_time_advance – stella","text":"public  subroutine finish_time_advance() Uses mirror_terms physics_flags parallel_streaming dissipation extended_zgrid stella_transforms neoclassical_terms flow_shear Arguments None","tags":"","loc":"proc/finish_time_advance.html"},{"title":"finish_parallel_nonlinearity – stella","text":"private  subroutine finish_parallel_nonlinearity() Arguments None","tags":"","loc":"proc/finish_parallel_nonlinearity.html"},{"title":"finish_wdrift – stella","text":"private  subroutine finish_wdrift() Uses dist_fn_arrays Arguments None","tags":"","loc":"proc/finish_wdrift.html"},{"title":"finish_wstar – stella","text":"private  subroutine finish_wstar() Uses dist_fn_arrays Arguments None","tags":"","loc":"proc/finish_wstar.html"},{"title":"deallocate_arrays – stella","text":"private  subroutine deallocate_arrays() Uses dist_fn_arrays Arguments None","tags":"","loc":"proc/deallocate_arrays~3.html"},{"title":"get_dgdy – stella","text":"private interface get_dgdy Module Procedures private  subroutine get_dgdy_2d (g, dgdy) compute dg/dy in k-space\naccepts g(ky,kx) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: g complex, intent(out), dimension(:, :) :: dgdy private  subroutine get_dgdy_3d (g, dgdy) compute dg/dy in k-space\naccepts g(ky,kx,z,tube) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: dgdy private  subroutine get_dgdy_4d (g, dgdy) compute dg/dy in k-space\naccepts g(ky,kx,z,tube,(vpa,mu,spec)) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dgdy","tags":"","loc":"interface/get_dgdy.html"},{"title":"get_dgdx – stella","text":"private interface get_dgdx Module Procedures private  subroutine get_dgdx_2d (g, dgdx) compute dg/dx in k-space\naccepts g(ky,kx) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: g complex, intent(out), dimension(:, :) :: dgdx private  subroutine get_dgdx_3d (g, dgdx) compute dg/dx in k-space\naccepts g(ky,kx,z,tube) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: dgdx private  subroutine get_dgdx_4d (g, dgdx) compute dg/dx in k-space\naccepts g(ky,kx,z,tube,(vpa,mu,spec)) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dgdx","tags":"","loc":"interface/get_dgdx.html"},{"title":"checksum – stella","text":"public interface checksum Module Procedures private  subroutine checksum_field (field, total) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: field real, intent(out) :: total private  subroutine checksum_dist (dist, total, norm) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dist real, intent(out) :: total logical, intent(in), optional :: norm","tags":"","loc":"interface/checksum~2.html"},{"title":"first_order_upwind_real – stella","text":"public  subroutine first_order_upwind_real(llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(out), dimension(llim:) :: df","tags":"","loc":"proc/first_order_upwind_real.html"},{"title":"first_order_upwind_complex – stella","text":"public  subroutine first_order_upwind_complex(llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(out), dimension(llim:) :: df","tags":"","loc":"proc/first_order_upwind_complex.html"},{"title":"third_order_upwind_complex – stella","text":"public  subroutine third_order_upwind_complex(llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(out), dimension(llim:) :: df","tags":"","loc":"proc/third_order_upwind_complex.html"},{"title":"third_order_upwind_real – stella","text":"public  subroutine third_order_upwind_real(llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(out), dimension(llim:) :: df","tags":"","loc":"proc/third_order_upwind_real.html"},{"title":"fifth_order_upwind_complex – stella","text":"public  subroutine fifth_order_upwind_complex(llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(out), dimension(llim:) :: df","tags":"","loc":"proc/fifth_order_upwind_complex.html"},{"title":"fifth_order_upwind_real – stella","text":"public  subroutine fifth_order_upwind_real(llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(out), dimension(llim:) :: df","tags":"","loc":"proc/fifth_order_upwind_real.html"},{"title":"third_order_upwind_zed – stella","text":"public  subroutine third_order_upwind_zed(llim, iseg, nseg, f, del, sgn, fl, fr, periodic, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim integer, intent(in) :: iseg integer, intent(in) :: nseg complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(in), dimension(:) :: fl complex, intent(in), dimension(:) :: fr logical, intent(in) :: periodic complex, intent(out), dimension(llim:) :: df","tags":"","loc":"proc/third_order_upwind_zed.html"},{"title":"first_order_upwind_zed – stella","text":"public  subroutine first_order_upwind_zed(llim, iseg, nseg, f, del, sgn, fl, fr, periodic, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim integer, intent(in) :: iseg integer, intent(in) :: nseg complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(in), dimension(:) :: fl complex, intent(in), dimension(:) :: fr logical, intent(in) :: periodic complex, intent(out), dimension(llim:) :: df","tags":"","loc":"proc/first_order_upwind_zed.html"},{"title":"second_order_centered_real – stella","text":"public  subroutine second_order_centered_real(llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del real, intent(out), dimension(llim:) :: df","tags":"","loc":"proc/second_order_centered_real.html"},{"title":"second_order_centered_complex – stella","text":"public  subroutine second_order_centered_complex(llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del complex, intent(out), dimension(llim:) :: df","tags":"","loc":"proc/second_order_centered_complex.html"},{"title":"four_point_triangle_real – stella","text":"public  subroutine four_point_triangle_real(llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del real, intent(out), dimension(llim:) :: df","tags":"","loc":"proc/four_point_triangle_real.html"},{"title":"four_point_triangle_complex – stella","text":"public  subroutine four_point_triangle_complex(llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del complex, intent(out), dimension(llim:) :: df","tags":"","loc":"proc/four_point_triangle_complex.html"},{"title":"fourth_order_centered_real – stella","text":"public  subroutine fourth_order_centered_real(llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del real, intent(out), dimension(llim:) :: df","tags":"","loc":"proc/fourth_order_centered_real.html"},{"title":"fourth_order_centered_complex – stella","text":"public  subroutine fourth_order_centered_complex(llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del complex, intent(out), dimension(llim:) :: df","tags":"","loc":"proc/fourth_order_centered_complex.html"},{"title":"second_order_centered_zed_real – stella","text":"public  subroutine second_order_centered_zed_real(llim, iseg, nseg, f, del, sgn, fl, fr, periodic, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim integer, intent(in) :: iseg integer, intent(in) :: nseg real, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(in), dimension(:) :: fl real, intent(in), dimension(:) :: fr logical, intent(in) :: periodic real, intent(out), dimension(llim:) :: df","tags":"","loc":"proc/second_order_centered_zed_real.html"},{"title":"second_order_centered_zed_complex – stella","text":"public  subroutine second_order_centered_zed_complex(llim, iseg, nseg, f, del, sgn, fl, fr, periodic, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim integer, intent(in) :: iseg integer, intent(in) :: nseg complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(in), dimension(:) :: fl complex, intent(in), dimension(:) :: fr logical, intent(in) :: periodic complex, intent(out), dimension(llim:) :: df","tags":"","loc":"proc/second_order_centered_zed_complex.html"},{"title":"second_order_centered_vpa – stella","text":"public  subroutine second_order_centered_vpa(llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del complex, intent(out), dimension(llim:) :: df","tags":"","loc":"proc/second_order_centered_vpa.html"},{"title":"fd_cell_centres_zed – stella","text":"public  subroutine fd_cell_centres_zed(llim, f, del, sgn, fl, fr, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(in) :: fl complex, intent(in) :: fr complex, intent(out), dimension(llim:) :: df","tags":"","loc":"proc/fd_cell_centres_zed.html"},{"title":"cell_centres_zed – stella","text":"public  subroutine cell_centres_zed(llim, f, upwnd, sgn, fl, fr, fc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: upwnd integer, intent(in) :: sgn complex, intent(in) :: fl complex, intent(in) :: fr complex, intent(out), dimension(llim:) :: fc","tags":"","loc":"proc/cell_centres_zed.html"},{"title":"fd_variable_upwinding_zed – stella","text":"public  subroutine fd_variable_upwinding_zed(llim, iseg, nseg, f, del, sgn, upwnd, fl, fr, periodic, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim integer, intent(in) :: iseg integer, intent(in) :: nseg complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(in) :: upwnd complex, intent(in), dimension(:) :: fl complex, intent(in), dimension(:) :: fr logical, intent(in) :: periodic complex, intent(out), dimension(llim:) :: df","tags":"","loc":"proc/fd_variable_upwinding_zed.html"},{"title":"fd_variable_upwinding_vpa – stella","text":"public  subroutine fd_variable_upwinding_vpa(llim, f, del, sgn, upwnd, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(in) :: upwnd complex, intent(out), dimension(llim:) :: df","tags":"","loc":"proc/fd_variable_upwinding_vpa.html"},{"title":"fd3pt_real – stella","text":"public  subroutine fd3pt_real(prof, profgrad, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: prof real, intent(out), dimension(:) :: profgrad real, intent(in) :: dr","tags":"","loc":"proc/fd3pt_real.html"},{"title":"fd3pt_real_array – stella","text":"public  subroutine fd3pt_real_array(prof, profgrad, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: prof real, intent(out), dimension(:) :: profgrad real, intent(in), dimension(:) :: dr","tags":"","loc":"proc/fd3pt_real_array.html"},{"title":"fd3pt_complex_array – stella","text":"public  subroutine fd3pt_complex_array(prof, profgrad, dr) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: prof complex, intent(out), dimension(:) :: profgrad real, intent(in), dimension(:) :: dr","tags":"","loc":"proc/fd3pt_complex_array.html"},{"title":"fd5pt_real – stella","text":"public  subroutine fd5pt_real(prof, profgrad, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: prof real, intent(out), dimension(:) :: profgrad real, intent(in) :: dr","tags":"","loc":"proc/fd5pt_real.html"},{"title":"fd5pt_array – stella","text":"public  subroutine fd5pt_array(prof, profgrad, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: prof real, intent(out), dimension(:) :: profgrad real, intent(in), dimension(:) :: dr","tags":"","loc":"proc/fd5pt_array.html"},{"title":"d2_3pt_real – stella","text":"public  subroutine d2_3pt_real(f, d2f, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: f real, intent(out), dimension(:) :: d2f real, intent(in), dimension(:) :: dr","tags":"","loc":"proc/d2_3pt_real.html"},{"title":"d2_3pt_complex – stella","text":"public  subroutine d2_3pt_complex(f, d2f, dr) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: f complex, intent(out), dimension(:) :: d2f real, intent(in), dimension(:) :: dr","tags":"","loc":"proc/d2_3pt_complex.html"},{"title":"tridag_real – stella","text":"public  subroutine tridag_real(aa, bb, cc, sol) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: aa real, intent(in), dimension(:) :: bb real, intent(in), dimension(:) :: cc real, intent(inout), dimension(:) :: sol","tags":"","loc":"proc/tridag_real.html"},{"title":"tridag_complex – stella","text":"public  subroutine tridag_complex(llim, aa, bb, cc, sol) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: aa real, intent(in), dimension(llim:) :: bb real, intent(in), dimension(llim:) :: cc complex, intent(inout), dimension(llim:) :: sol","tags":"","loc":"proc/tridag_complex.html"},{"title":"fd3pt – stella","text":"public interface fd3pt Module Procedures public  subroutine fd3pt_real (prof, profgrad, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: prof real, intent(out), dimension(:) :: profgrad real, intent(in) :: dr public  subroutine fd3pt_real_array (prof, profgrad, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: prof real, intent(out), dimension(:) :: profgrad real, intent(in), dimension(:) :: dr public  subroutine fd3pt_complex_array (prof, profgrad, dr) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: prof complex, intent(out), dimension(:) :: profgrad real, intent(in), dimension(:) :: dr","tags":"","loc":"interface/fd3pt.html"},{"title":"fd5pt – stella","text":"public interface fd5pt Module Procedures public  subroutine fd5pt_real (prof, profgrad, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: prof real, intent(out), dimension(:) :: profgrad real, intent(in) :: dr public  subroutine fd5pt_array (prof, profgrad, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: prof real, intent(out), dimension(:) :: profgrad real, intent(in), dimension(:) :: dr","tags":"","loc":"interface/fd5pt.html"},{"title":"first_order_upwind – stella","text":"public interface first_order_upwind Module Procedures public  subroutine first_order_upwind_real (llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(out), dimension(llim:) :: df public  subroutine first_order_upwind_complex (llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(out), dimension(llim:) :: df","tags":"","loc":"interface/first_order_upwind.html"},{"title":"third_order_upwind – stella","text":"public interface third_order_upwind Module Procedures public  subroutine third_order_upwind_complex (llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(out), dimension(llim:) :: df public  subroutine third_order_upwind_real (llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(out), dimension(llim:) :: df","tags":"","loc":"interface/third_order_upwind.html"},{"title":"fifth_order_upwind – stella","text":"public interface fifth_order_upwind Module Procedures public  subroutine fifth_order_upwind_complex (llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(out), dimension(llim:) :: df public  subroutine fifth_order_upwind_real (llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(out), dimension(llim:) :: df","tags":"","loc":"interface/fifth_order_upwind.html"},{"title":"tridag – stella","text":"public interface tridag Module Procedures public  subroutine tridag_real (aa, bb, cc, sol) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: aa real, intent(in), dimension(:) :: bb real, intent(in), dimension(:) :: cc real, intent(inout), dimension(:) :: sol public  subroutine tridag_complex (llim, aa, bb, cc, sol) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: aa real, intent(in), dimension(llim:) :: bb real, intent(in), dimension(llim:) :: cc complex, intent(inout), dimension(llim:) :: sol","tags":"","loc":"interface/tridag.html"},{"title":"second_order_centered – stella","text":"public interface second_order_centered Module Procedures public  subroutine second_order_centered_real (llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del real, intent(out), dimension(llim:) :: df public  subroutine second_order_centered_complex (llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del complex, intent(out), dimension(llim:) :: df","tags":"","loc":"interface/second_order_centered.html"},{"title":"four_point_triangle – stella","text":"public interface four_point_triangle Module Procedures public  subroutine four_point_triangle_real (llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del real, intent(out), dimension(llim:) :: df public  subroutine four_point_triangle_complex (llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del complex, intent(out), dimension(llim:) :: df","tags":"","loc":"interface/four_point_triangle.html"},{"title":"fourth_order_centered – stella","text":"public interface fourth_order_centered Module Procedures public  subroutine fourth_order_centered_real (llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del real, intent(out), dimension(llim:) :: df public  subroutine fourth_order_centered_complex (llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del complex, intent(out), dimension(llim:) :: df","tags":"","loc":"interface/fourth_order_centered.html"},{"title":"second_order_centered_zed – stella","text":"public interface second_order_centered_zed Module Procedures public  subroutine second_order_centered_zed_real (llim, iseg, nseg, f, del, sgn, fl, fr, periodic, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim integer, intent(in) :: iseg integer, intent(in) :: nseg real, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(in), dimension(:) :: fl real, intent(in), dimension(:) :: fr logical, intent(in) :: periodic real, intent(out), dimension(llim:) :: df public  subroutine second_order_centered_zed_complex (llim, iseg, nseg, f, del, sgn, fl, fr, periodic, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim integer, intent(in) :: iseg integer, intent(in) :: nseg complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(in), dimension(:) :: fl complex, intent(in), dimension(:) :: fr logical, intent(in) :: periodic complex, intent(out), dimension(llim:) :: df","tags":"","loc":"interface/second_order_centered_zed.html"},{"title":"d2_3pt – stella","text":"public interface d2_3pt Module Procedures public  subroutine d2_3pt_real (f, d2f, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: f real, intent(out), dimension(:) :: d2f real, intent(in), dimension(:) :: dr public  subroutine d2_3pt_complex (f, d2f, dr) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: f complex, intent(out), dimension(:) :: d2f real, intent(in), dimension(:) :: dr","tags":"","loc":"interface/d2_3pt.html"},{"title":"smoothstep – stella","text":"public pure function smoothstep(x, N, minV, maxV) Arguments Type Intent Optional Attributes Name real, intent(in) :: x integer, intent(in) :: N real, intent(in), optional :: minV real, intent(in), optional :: maxV Return Value real","tags":"","loc":"proc/smoothstep.html"},{"title":"smoothstep0 – stella","text":"public pure function smoothstep0(x) Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value real","tags":"","loc":"proc/smoothstep0.html"},{"title":"smoothstep1 – stella","text":"public pure function smoothstep1(x) Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value real","tags":"","loc":"proc/smoothstep1.html"},{"title":"smoothstep2 – stella","text":"public pure function smoothstep2(x) Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value real","tags":"","loc":"proc/smoothstep2.html"},{"title":"smoothstepN – stella","text":"public pure function smoothstepN(x, N) Arguments Type Intent Optional Attributes Name real, intent(in) :: x integer, intent(in) :: N Return Value real","tags":"","loc":"proc/smoothstepn.html"},{"title":"pascalTriangle – stella","text":"public pure function pascalTriangle(a, b) Arguments Type Intent Optional Attributes Name integer, intent(in) :: a integer, intent(in) :: b Return Value integer","tags":"","loc":"proc/pascaltriangle.html"},{"title":"read_species_euterpe – stella","text":"public  subroutine read_species_euterpe(nspec, spec) Uses physics_parameters mp common_types splines finite_differences stella_geometry Arguments Type Intent Optional Attributes Name integer, intent(in) :: nspec type( spec_type ), intent(inout), dimension(:) :: spec","tags":"","loc":"proc/read_species_euterpe.html"},{"title":"read_euterpe_parameters – stella","text":"public  subroutine read_euterpe_parameters(nradii_out, data_file_out) Uses file_utils Arguments Type Intent Optional Attributes Name integer, intent(out) :: nradii_out character(len=*), intent(out) :: data_file_out Namelists Namelist euterpe_parameters Variables Name Type Default Description nradii integer None data_file character(len=1000) None","tags":"","loc":"proc/read_euterpe_parameters.html"},{"title":"grnd – stella","text":"public  function grnd() Arguments None Return Value real","tags":"","loc":"proc/grnd.html"},{"title":"sgrnd – stella","text":"public  subroutine sgrnd(seed) Arguments Type Intent Optional Attributes Name integer, intent(in) :: seed","tags":"","loc":"proc/sgrnd.html"},{"title":"is_idx_kxkyz – stella","text":"private elemental function is_idx_kxkyz(lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"proc/is_idx_kxkyz.html"},{"title":"ikx_idx_kxkyz – stella","text":"private elemental function ikx_idx_kxkyz(lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"proc/ikx_idx_kxkyz.html"},{"title":"iky_idx_kxkyz – stella","text":"private elemental function iky_idx_kxkyz(lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"proc/iky_idx_kxkyz.html"},{"title":"iz_idx_kxkyz – stella","text":"private elemental function iz_idx_kxkyz(lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"proc/iz_idx_kxkyz.html"},{"title":"it_idx_kxkyz – stella","text":"private elemental function it_idx_kxkyz(lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"proc/it_idx_kxkyz.html"},{"title":"proc_id_kxkyz – stella","text":"private elemental function proc_id_kxkyz(lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"proc/proc_id_kxkyz.html"},{"title":"idx_kxkyz – stella","text":"private elemental function idx_kxkyz(lo, iky, ikx, iz, it, is) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value integer","tags":"","loc":"proc/idx_kxkyz.html"},{"title":"idx_local_kxkyz – stella","text":"private elemental function idx_local_kxkyz(lo, iky, ikx, iz, it, is) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value logical","tags":"","loc":"proc/idx_local_kxkyz.html"},{"title":"iz_local_kxkyz – stella","text":"private elemental function iz_local_kxkyz(lo, iz) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: iz Return Value logical","tags":"","loc":"proc/iz_local_kxkyz.html"},{"title":"is_idx_kxyz – stella","text":"private elemental function is_idx_kxyz(lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"proc/is_idx_kxyz.html"},{"title":"ikx_idx_kxyz – stella","text":"private elemental function ikx_idx_kxyz(lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"proc/ikx_idx_kxyz.html"},{"title":"iy_idx_kxyz – stella","text":"private elemental function iy_idx_kxyz(lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"proc/iy_idx_kxyz.html"},{"title":"iz_idx_kxyz – stella","text":"private elemental function iz_idx_kxyz(lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"proc/iz_idx_kxyz.html"},{"title":"it_idx_kxyz – stella","text":"private elemental function it_idx_kxyz(lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"proc/it_idx_kxyz.html"},{"title":"proc_id_kxyz – stella","text":"private elemental function proc_id_kxyz(lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"proc/proc_id_kxyz.html"},{"title":"idx_kxyz – stella","text":"private elemental function idx_kxyz(lo, iy, ikx, iz, it, is) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: iy integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value integer","tags":"","loc":"proc/idx_kxyz.html"},{"title":"idx_local_kxyz – stella","text":"private elemental function idx_local_kxyz(lo, iy, ikx, iz, it, is) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: iy integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value logical","tags":"","loc":"proc/idx_local_kxyz.html"},{"title":"iz_local_kxyz – stella","text":"private elemental function iz_local_kxyz(lo, iz) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: iz Return Value logical","tags":"","loc":"proc/iz_local_kxyz.html"},{"title":"is_idx_xyz – stella","text":"private elemental function is_idx_xyz(lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"proc/is_idx_xyz.html"},{"title":"ix_idx_xyz – stella","text":"private elemental function ix_idx_xyz(lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"proc/ix_idx_xyz.html"},{"title":"iy_idx_xyz – stella","text":"private elemental function iy_idx_xyz(lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"proc/iy_idx_xyz.html"},{"title":"iz_idx_xyz – stella","text":"private elemental function iz_idx_xyz(lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"proc/iz_idx_xyz.html"},{"title":"it_idx_xyz – stella","text":"private elemental function it_idx_xyz(lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"proc/it_idx_xyz.html"},{"title":"proc_id_xyz – stella","text":"private elemental function proc_id_xyz(lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"proc/proc_id_xyz.html"},{"title":"idx_xyz – stella","text":"private elemental function idx_xyz(lo, iy, ix, iz, it, is) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: iy integer, intent(in) :: ix integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value integer","tags":"","loc":"proc/idx_xyz.html"},{"title":"idx_local_xyz – stella","text":"private elemental function idx_local_xyz(lo, iy, ix, iz, it, is) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: iy integer, intent(in) :: ix integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value logical","tags":"","loc":"proc/idx_local_xyz.html"},{"title":"iz_local_xyz – stella","text":"private elemental function iz_local_xyz(lo, iz) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: iz Return Value logical","tags":"","loc":"proc/iz_local_xyz.html"},{"title":"is_idx_vmu – stella","text":"private elemental function is_idx_vmu(lo, i) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"proc/is_idx_vmu.html"},{"title":"imu_idx_vmu – stella","text":"private elemental function imu_idx_vmu(lo, i) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"proc/imu_idx_vmu.html"},{"title":"iv_idx_vmu – stella","text":"private elemental function iv_idx_vmu(lo, i) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"proc/iv_idx_vmu.html"},{"title":"proc_id_vmu – stella","text":"private elemental function proc_id_vmu(lo, i) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"proc/proc_id_vmu.html"},{"title":"idx_vmu – stella","text":"private elemental function idx_vmu(lo, iv, imu, is) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: iv integer, intent(in) :: imu integer, intent(in) :: is Return Value integer","tags":"","loc":"proc/idx_vmu.html"},{"title":"idx_local_vmu – stella","text":"private elemental function idx_local_vmu(lo, iv, imu, is) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: iv integer, intent(in) :: imu integer, intent(in) :: is Return Value logical","tags":"","loc":"proc/idx_local_vmu.html"},{"title":"iz_local_vmu – stella","text":"private elemental function iz_local_vmu(lo, iz) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: iz Return Value logical","tags":"","loc":"proc/iz_local_vmu.html"},{"title":"init_stella_layouts – stella","text":"public  subroutine init_stella_layouts() Uses mp Arguments None","tags":"","loc":"proc/init_stella_layouts.html"},{"title":"read_parameters – stella","text":"private  subroutine read_parameters() Uses file_utils mp Arguments None Namelists Namelist layouts_knobs Variables Name Type Default Description xyzs_layout character(len=4) None vms_layout character(len=3) None","tags":"","loc":"proc/read_parameters~8.html"},{"title":"broadcast_results – stella","text":"private  subroutine broadcast_results() Uses mp Arguments None","tags":"","loc":"proc/broadcast_results.html"},{"title":"init_dist_fn_layouts – stella","text":"public  subroutine init_dist_fn_layouts(nzgrid, ntubes, naky, nakx, nvgrid, nmu, nspec, ny, nx, nalpha) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nzgrid integer, intent(in) :: ntubes integer, intent(in) :: naky integer, intent(in) :: nakx integer, intent(in) :: nvgrid integer, intent(in) :: nmu integer, intent(in) :: nspec integer, intent(in) :: ny integer, intent(in) :: nx integer, intent(in) :: nalpha","tags":"","loc":"proc/init_dist_fn_layouts.html"},{"title":"init_kxkyz_layout – stella","text":"private  subroutine init_kxkyz_layout(nzgrid, ntubes, naky, nakx, nvgrid, nmu, nspec) Uses mp Arguments Type Intent Optional Attributes Name integer, intent(in) :: nzgrid integer, intent(in) :: ntubes integer, intent(in) :: naky integer, intent(in) :: nakx integer, intent(in) :: nvgrid integer, intent(in) :: nmu integer, intent(in) :: nspec","tags":"","loc":"proc/init_kxkyz_layout.html"},{"title":"init_kxyz_layout – stella","text":"private  subroutine init_kxyz_layout(nzgrid, ntubes, naky, nakx, nvgrid, nmu, nspec, ny) Uses mp Arguments Type Intent Optional Attributes Name integer, intent(in) :: nzgrid integer, intent(in) :: ntubes integer, intent(in) :: naky integer, intent(in) :: nakx integer, intent(in) :: nvgrid integer, intent(in) :: nmu integer, intent(in) :: nspec integer, intent(in) :: ny","tags":"","loc":"proc/init_kxyz_layout.html"},{"title":"init_xyz_layout – stella","text":"private  subroutine init_xyz_layout(nzgrid, ntubes, naky, nakx, nvgrid, nmu, nspec, ny, nx) Uses mp Arguments Type Intent Optional Attributes Name integer, intent(in) :: nzgrid integer, intent(in) :: ntubes integer, intent(in) :: naky integer, intent(in) :: nakx integer, intent(in) :: nvgrid integer, intent(in) :: nmu integer, intent(in) :: nspec integer, intent(in) :: ny integer, intent(in) :: nx","tags":"","loc":"proc/init_xyz_layout.html"},{"title":"init_vmu_layout – stella","text":"private  subroutine init_vmu_layout(nzgrid, ntubes, naky, nakx, nvgrid, nmu, nspec, ny, nx, nalpha) Uses mp Arguments Type Intent Optional Attributes Name integer, intent(in) :: nzgrid integer, intent(in) :: ntubes integer, intent(in) :: naky integer, intent(in) :: nakx integer, intent(in) :: nvgrid integer, intent(in) :: nmu integer, intent(in) :: nspec integer, intent(in) :: ny integer, intent(in) :: nx integer, intent(in) :: nalpha","tags":"","loc":"proc/init_vmu_layout.html"},{"title":"kxkyzidx2vmuidx – stella","text":"public elemental subroutine kxkyzidx2vmuidx(iv, imu, ikxkyz, kxkyz_lo, vmu_lo, iky, ikx, iz, it, ivmu) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv integer, intent(in) :: imu integer, intent(in) :: ikxkyz type( kxkyz_layout_type ), intent(in) :: kxkyz_lo type( vmu_layout_type ), intent(in) :: vmu_lo integer, intent(out) :: iky integer, intent(out) :: ikx integer, intent(out) :: iz integer, intent(out) :: it integer, intent(out) :: ivmu","tags":"","loc":"proc/kxkyzidx2vmuidx.html"},{"title":"kxyzidx2vmuidx – stella","text":"public elemental subroutine kxyzidx2vmuidx(iv, imu, ikxyz, kxyz_lo, vmu_lo, iy, ikx, iz, it, ivmu) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv integer, intent(in) :: imu integer, intent(in) :: ikxyz type( kxyz_layout_type ), intent(in) :: kxyz_lo type( vmu_layout_type ), intent(in) :: vmu_lo integer, intent(out) :: iy integer, intent(out) :: ikx integer, intent(out) :: iz integer, intent(out) :: it integer, intent(out) :: ivmu","tags":"","loc":"proc/kxyzidx2vmuidx.html"},{"title":"xyzidx2vmuidx – stella","text":"public elemental subroutine xyzidx2vmuidx(iv, imu, ixyz, xyz_lo, vmu_lo, iy, ix, iz, it, ivmu) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv integer, intent(in) :: imu integer, intent(in) :: ixyz type( xyz_layout_type ), intent(in) :: xyz_lo type( vmu_layout_type ), intent(in) :: vmu_lo integer, intent(out) :: iy integer, intent(out) :: ix integer, intent(out) :: iz integer, intent(out) :: it integer, intent(out) :: ivmu","tags":"","loc":"proc/xyzidx2vmuidx.html"},{"title":"finish_layouts – stella","text":"public  subroutine finish_layouts() Arguments None","tags":"","loc":"proc/finish_layouts.html"},{"title":"it_idx – stella","text":"public interface it_idx Module Procedures private elemental function it_idx_kxkyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function it_idx_kxyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function it_idx_xyz (lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"interface/it_idx.html"},{"title":"iz_idx – stella","text":"public interface iz_idx Module Procedures private elemental function iz_idx_kxkyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function iz_idx_kxyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function iz_idx_xyz (lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"interface/iz_idx.html"},{"title":"iv_idx – stella","text":"public interface iv_idx Module Procedures private elemental function iv_idx_vmu (lo, i) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"interface/iv_idx.html"},{"title":"iky_idx – stella","text":"public interface iky_idx Module Procedures private elemental function iky_idx_kxkyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"interface/iky_idx.html"},{"title":"iy_idx – stella","text":"public interface iy_idx Module Procedures private elemental function iy_idx_kxyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function iy_idx_xyz (lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"interface/iy_idx.html"},{"title":"ikx_idx – stella","text":"public interface ikx_idx Module Procedures private elemental function ikx_idx_kxkyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function ikx_idx_kxyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"interface/ikx_idx.html"},{"title":"ix_idx – stella","text":"private interface ix_idx Module Procedures private elemental function ix_idx_xyz (lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"interface/ix_idx.html"},{"title":"imu_idx – stella","text":"public interface imu_idx Module Procedures private elemental function imu_idx_vmu (lo, i) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"interface/imu_idx.html"},{"title":"is_idx – stella","text":"public interface is_idx Module Procedures private elemental function is_idx_kxkyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function is_idx_kxyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function is_idx_xyz (lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function is_idx_vmu (lo, i) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"interface/is_idx.html"},{"title":"proc_id – stella","text":"public interface proc_id Module Procedures private elemental function proc_id_kxkyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function proc_id_kxyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function proc_id_xyz (lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function proc_id_vmu (lo, i) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer","tags":"","loc":"interface/proc_id.html"},{"title":"idx – stella","text":"public interface idx Module Procedures private elemental function idx_kxkyz (lo, iky, ikx, iz, it, is) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value integer private elemental function idx_kxyz (lo, iy, ikx, iz, it, is) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: iy integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value integer private elemental function idx_xyz (lo, iy, ix, iz, it, is) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: iy integer, intent(in) :: ix integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value integer private elemental function idx_vmu (lo, iv, imu, is) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: iv integer, intent(in) :: imu integer, intent(in) :: is Return Value integer","tags":"","loc":"interface/idx.html"},{"title":"idx_local – stella","text":"public interface idx_local Module Procedures private elemental function idx_local_kxkyz (lo, iky, ikx, iz, it, is) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value logical private elemental function iz_local_kxkyz (lo, iz) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: iz Return Value logical private elemental function idx_local_kxyz (lo, iy, ikx, iz, it, is) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: iy integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value logical private elemental function iz_local_kxyz (lo, iz) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: iz Return Value logical private elemental function idx_local_xyz (lo, iy, ix, iz, it, is) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: iy integer, intent(in) :: ix integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value logical private elemental function iz_local_xyz (lo, iz) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: iz Return Value logical private elemental function idx_local_vmu (lo, iv, imu, is) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: iv integer, intent(in) :: imu integer, intent(in) :: is Return Value logical private elemental function iz_local_vmu (lo, iz) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: iz Return Value logical","tags":"","loc":"interface/idx_local.html"},{"title":"read_inputprof_geo – stella","text":"public  subroutine read_inputprof_geo(surf) Uses common_types millerlocal splines constants finite_differences Arguments Type Intent Optional Attributes Name type( flux_surface_type ), intent(inout) :: surf","tags":"","loc":"proc/read_inputprof_geo.html"},{"title":"read_inputprof_spec – stella","text":"public  subroutine read_inputprof_spec(nspec, spec) Uses physics_parameters mp common_types millerlocal splines finite_differences Arguments Type Intent Optional Attributes Name integer, intent(in) :: nspec type( spec_type ), intent(inout), dimension(:) :: spec","tags":"","loc":"proc/read_inputprof_spec.html"},{"title":"allocate_arrays_geo – stella","text":"private  subroutine allocate_arrays_geo() Arguments None","tags":"","loc":"proc/allocate_arrays_geo.html"},{"title":"allocate_arrays_spec – stella","text":"private  subroutine allocate_arrays_spec() Arguments None","tags":"","loc":"proc/allocate_arrays_spec.html"},{"title":"deallocate_arrays_geo – stella","text":"private  subroutine deallocate_arrays_geo() Arguments None","tags":"","loc":"proc/deallocate_arrays_geo.html"},{"title":"deallocate_arrays_spec – stella","text":"private  subroutine deallocate_arrays_spec() Arguments None","tags":"","loc":"proc/deallocate_arrays_spec.html"},{"title":"read_multibox_parameters – stella","text":"public  subroutine read_multibox_parameters() Uses job_manage mp file_utils kt_grids text_options Arguments None Namelists Namelist multibox_parameters Variables Name Type Default Description boundary_size integer None krook_size integer None smooth_ZFs logical None zf_option character(len=30) None LR_debug_option character(len=30) None krook_option character(len=30) None RK_step logical None nu_krook_mb real None mb_debug_step integer None krook_exponent real None comm_at_init logical None phi_bound integer None phi_pow integer None krook_efold real None use_dirichlet_BC logical None","tags":"","loc":"proc/read_multibox_parameters.html"},{"title":"init_multibox – stella","text":"public  subroutine init_multibox() Uses physics_parameters zgrid job_manage mp stella_layouts file_utils constants kt_grids stella_geometry Arguments None","tags":"","loc":"proc/init_multibox.html"},{"title":"communicate_multibox_parameters – stella","text":"public  subroutine communicate_multibox_parameters() Uses job_manage mp Arguments None","tags":"","loc":"proc/communicate_multibox_parameters.html"},{"title":"finish_multibox – stella","text":"public  subroutine finish_multibox() Arguments None","tags":"","loc":"proc/finish_multibox.html"},{"title":"multibox_communicate – stella","text":"public  subroutine multibox_communicate(gin) Uses physics_parameters job_manage zgrid mp file_utils physics_flags stella_layouts constants fields_arrays kt_grids stella_geometry Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gin","tags":"","loc":"proc/multibox_communicate.html"},{"title":"apply_radial_boundary_conditions – stella","text":"public  subroutine apply_radial_boundary_conditions(gin) Uses kt_grids stella_layouts zgrid Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gin","tags":"","loc":"proc/apply_radial_boundary_conditions.html"},{"title":"add_multibox_krook – stella","text":"public  subroutine add_multibox_krook(g, rhs) Uses mp zgrid job_manage stella_layouts kt_grids stella_time Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: rhs","tags":"","loc":"proc/add_multibox_krook.html"},{"title":"init_mb_get_phi – stella","text":"public  subroutine init_mb_get_phi(has_elec, adiabatic_elec, efac, efacp) Uses zgrid linear_solve physics_flags fields_arrays kt_grids stella_geometry run_parameters Arguments Type Intent Optional Attributes Name logical, intent(in) :: has_elec logical, intent(in) :: adiabatic_elec real, intent(in) :: efac real, intent(in) :: efacp","tags":"","loc":"proc/init_mb_get_phi.html"},{"title":"mb_get_phi – stella","text":"public  subroutine mb_get_phi(phi, has_elec, adiabatic_elec) Uses zgrid linear_solve constants fields_arrays kt_grids stella_geometry run_parameters Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi logical, intent(in) :: has_elec logical, intent(in) :: adiabatic_elec","tags":"","loc":"proc/mb_get_phi.html"},{"title":"init_mb_transforms – stella","text":"private  subroutine init_mb_transforms() Uses kt_grids stella_layouts Arguments None","tags":"","loc":"proc/init_mb_transforms.html"},{"title":"init_x_fft – stella","text":"private  subroutine init_x_fft() Uses fft_work Arguments None","tags":"","loc":"proc/init_x_fft~2.html"},{"title":"init_y_fft – stella","text":"private  subroutine init_y_fft() Uses kt_grids fft_work Arguments None","tags":"","loc":"proc/init_y_fft~2.html"},{"title":"transform_kx2x – stella","text":"private  subroutine transform_kx2x(gkx, gx) Uses kt_grids transform routines start here Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gkx complex, intent(out), dimension(:, :) :: gx","tags":"","loc":"proc/transform_kx2x~2.html"},{"title":"transform_x2kx – stella","text":"private  subroutine transform_x2kx(gx, gkx) Uses kt_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gx complex, intent(out), dimension(:, :) :: gkx","tags":"","loc":"proc/transform_x2kx~2.html"},{"title":"transform_ky2y – stella","text":"private  subroutine transform_ky2y(gky, gy) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gky real, intent(out), dimension(:, :) :: gy","tags":"","loc":"proc/transform_ky2y.html"},{"title":"finish_mb_transforms – stella","text":"private  subroutine finish_mb_transforms() Arguments None","tags":"","loc":"proc/finish_mb_transforms.html"},{"title":"init_mp – stella","text":"public  subroutine init_mp(comm_in) Uses file_utils constants Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: comm_in","tags":"","loc":"proc/init_mp.html"},{"title":"scope – stella","text":"public  subroutine scope(focus) Arguments Type Intent Optional Attributes Name integer, intent(in) :: focus","tags":"","loc":"proc/scope.html"},{"title":"init_job_topology – stella","text":"public  subroutine init_job_topology(ncolumns, group0, ierr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncolumns integer, intent(out), dimension(0:) :: group0 integer :: ierr","tags":"","loc":"proc/init_job_topology.html"},{"title":"split_n_tasks – stella","text":"public  subroutine split_n_tasks(n, lo, hi) split n tasks over current communicator. Returns the low and high\nindices for a given processor. Assumes indices start at 1 Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(out) :: lo integer, intent(out) :: hi","tags":"","loc":"proc/split_n_tasks.html"},{"title":"finish_mp – stella","text":"public  subroutine finish_mp() Arguments None","tags":"","loc":"proc/finish_mp.html"},{"title":"broadcast_character – stella","text":"private  subroutine broadcast_character(char) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: char","tags":"","loc":"proc/broadcast_character.html"},{"title":"broadcast_integer – stella","text":"private  subroutine broadcast_integer(i) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i","tags":"","loc":"proc/broadcast_integer.html"},{"title":"broadcast_integer_array – stella","text":"private  subroutine broadcast_integer_array(i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i","tags":"","loc":"proc/broadcast_integer_array.html"},{"title":"broadcast_real – stella","text":"private  subroutine broadcast_real(x) Arguments Type Intent Optional Attributes Name real, intent(inout) :: x","tags":"","loc":"proc/broadcast_real.html"},{"title":"broadcast_real_array – stella","text":"private  subroutine broadcast_real_array(x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: x","tags":"","loc":"proc/broadcast_real_array.html"},{"title":"broadcast_real_2array – stella","text":"private  subroutine broadcast_real_2array(x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :) :: x","tags":"","loc":"proc/broadcast_real_2array.html"},{"title":"broadcast_real_3array – stella","text":"private  subroutine broadcast_real_3array(x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :) :: x","tags":"","loc":"proc/broadcast_real_3array.html"},{"title":"broadcast_real_4array – stella","text":"private  subroutine broadcast_real_4array(x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :) :: x","tags":"","loc":"proc/broadcast_real_4array.html"},{"title":"broadcast_real_5array – stella","text":"private  subroutine broadcast_real_5array(x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :) :: x","tags":"","loc":"proc/broadcast_real_5array.html"},{"title":"broadcast_complex – stella","text":"private  subroutine broadcast_complex(z) Arguments Type Intent Optional Attributes Name complex, intent(inout) :: z","tags":"","loc":"proc/broadcast_complex.html"},{"title":"broadcast_complex_array – stella","text":"private  subroutine broadcast_complex_array(z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: z","tags":"","loc":"proc/broadcast_complex_array.html"},{"title":"broadcast_complex_2array – stella","text":"private  subroutine broadcast_complex_2array(z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: z","tags":"","loc":"proc/broadcast_complex_2array.html"},{"title":"broadcast_complex_3array – stella","text":"private  subroutine broadcast_complex_3array(z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :) :: z","tags":"","loc":"proc/broadcast_complex_3array.html"},{"title":"broadcast_complex_4array – stella","text":"private  subroutine broadcast_complex_4array(z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :) :: z","tags":"","loc":"proc/broadcast_complex_4array.html"},{"title":"broadcast_logical – stella","text":"private  subroutine broadcast_logical(f) Arguments Type Intent Optional Attributes Name logical, intent(inout) :: f","tags":"","loc":"proc/broadcast_logical.html"},{"title":"broadcast_logical_array – stella","text":"private  subroutine broadcast_logical_array(f) Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:) :: f","tags":"","loc":"proc/broadcast_logical_array.html"},{"title":"bcastfrom_logical – stella","text":"private  subroutine bcastfrom_logical(f, src) Arguments Type Intent Optional Attributes Name logical, intent(inout) :: f integer, intent(in) :: src","tags":"","loc":"proc/bcastfrom_logical.html"},{"title":"bcastfrom_logical_array – stella","text":"private  subroutine bcastfrom_logical_array(f, src) Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:) :: f integer, intent(in) :: src","tags":"","loc":"proc/bcastfrom_logical_array.html"},{"title":"bcastfrom_character – stella","text":"private  subroutine bcastfrom_character(c, src) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: c integer, intent(in) :: src","tags":"","loc":"proc/bcastfrom_character.html"},{"title":"bcastfrom_integer – stella","text":"private  subroutine bcastfrom_integer(i, src) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i integer, intent(in) :: src","tags":"","loc":"proc/bcastfrom_integer.html"},{"title":"bcastfrom_integer_array – stella","text":"private  subroutine bcastfrom_integer_array(i, src) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i integer, intent(in) :: src","tags":"","loc":"proc/bcastfrom_integer_array.html"},{"title":"bcastfrom_real – stella","text":"private  subroutine bcastfrom_real(x, src) Arguments Type Intent Optional Attributes Name real, intent(inout) :: x integer, intent(in) :: src","tags":"","loc":"proc/bcastfrom_real.html"},{"title":"bcastfrom_real_array – stella","text":"private  subroutine bcastfrom_real_array(x, src) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: x integer, intent(in) :: src","tags":"","loc":"proc/bcastfrom_real_array.html"},{"title":"bcastfrom_complex – stella","text":"private  subroutine bcastfrom_complex(z, src) Arguments Type Intent Optional Attributes Name complex, intent(inout) :: z integer, intent(in) :: src","tags":"","loc":"proc/bcastfrom_complex.html"},{"title":"bcastfrom_complex_array – stella","text":"private  subroutine bcastfrom_complex_array(z, src) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: z integer, intent(in) :: src","tags":"","loc":"proc/bcastfrom_complex_array.html"},{"title":"bcastfrom_complex_2array – stella","text":"private  subroutine bcastfrom_complex_2array(z, src) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: z integer, intent(in) :: src","tags":"","loc":"proc/bcastfrom_complex_2array.html"},{"title":"sum_reduce_integer – stella","text":"private  subroutine sum_reduce_integer(i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i integer, intent(in) :: dest","tags":"","loc":"proc/sum_reduce_integer.html"},{"title":"sum_reduce_integer_array – stella","text":"private  subroutine sum_reduce_integer_array(i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i integer, intent(in) :: dest","tags":"","loc":"proc/sum_reduce_integer_array.html"},{"title":"sum_reduce_real – stella","text":"private  subroutine sum_reduce_real(a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a integer, intent(in) :: dest","tags":"","loc":"proc/sum_reduce_real.html"},{"title":"sum_reduce_real_array – stella","text":"private  subroutine sum_reduce_real_array(a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a integer, intent(in) :: dest","tags":"","loc":"proc/sum_reduce_real_array.html"},{"title":"sum_reduce_real_2array – stella","text":"private  subroutine sum_reduce_real_2array(a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :) :: a integer, intent(in) :: dest","tags":"","loc":"proc/sum_reduce_real_2array.html"},{"title":"sum_reduce_real_3array – stella","text":"private  subroutine sum_reduce_real_3array(a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :) :: a integer, intent(in) :: dest","tags":"","loc":"proc/sum_reduce_real_3array.html"},{"title":"sum_reduce_real_4array – stella","text":"private  subroutine sum_reduce_real_4array(a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :) :: a integer, intent(in) :: dest","tags":"","loc":"proc/sum_reduce_real_4array.html"},{"title":"sum_reduce_real_5array – stella","text":"private  subroutine sum_reduce_real_5array(a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :) :: a integer, intent(in) :: dest","tags":"","loc":"proc/sum_reduce_real_5array.html"},{"title":"sum_reduce_complex – stella","text":"private  subroutine sum_reduce_complex(z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout) :: z integer, intent(in) :: dest","tags":"","loc":"proc/sum_reduce_complex.html"},{"title":"sum_reduce_complex_array – stella","text":"private  subroutine sum_reduce_complex_array(z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: z integer, intent(in) :: dest","tags":"","loc":"proc/sum_reduce_complex_array.html"},{"title":"sum_reduce_complex_2array – stella","text":"private  subroutine sum_reduce_complex_2array(z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: z integer, intent(in) :: dest","tags":"","loc":"proc/sum_reduce_complex_2array.html"},{"title":"sum_reduce_complex_3array – stella","text":"private  subroutine sum_reduce_complex_3array(z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :) :: z integer, intent(in) :: dest","tags":"","loc":"proc/sum_reduce_complex_3array.html"},{"title":"sum_reduce_complex_4array – stella","text":"private  subroutine sum_reduce_complex_4array(z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :) :: z integer, intent(in) :: dest","tags":"","loc":"proc/sum_reduce_complex_4array.html"},{"title":"sum_reduce_complex_5array – stella","text":"private  subroutine sum_reduce_complex_5array(z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :, :) :: z integer, intent(in) :: dest","tags":"","loc":"proc/sum_reduce_complex_5array.html"},{"title":"sum_allreduce_integer – stella","text":"private  subroutine sum_allreduce_integer(i) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i","tags":"","loc":"proc/sum_allreduce_integer.html"},{"title":"sum_allreduce_integer_array – stella","text":"private  subroutine sum_allreduce_integer_array(i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i","tags":"","loc":"proc/sum_allreduce_integer_array.html"},{"title":"sum_allreduce_integer_2array – stella","text":"private  subroutine sum_allreduce_integer_2array(i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:, :) :: i","tags":"","loc":"proc/sum_allreduce_integer_2array.html"},{"title":"sum_allreduce_real – stella","text":"private  subroutine sum_allreduce_real(a) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a","tags":"","loc":"proc/sum_allreduce_real.html"},{"title":"sum_allreduce_real_array – stella","text":"private  subroutine sum_allreduce_real_array(a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a","tags":"","loc":"proc/sum_allreduce_real_array.html"},{"title":"sum_allreduce_real_2array – stella","text":"private  subroutine sum_allreduce_real_2array(a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :) :: a","tags":"","loc":"proc/sum_allreduce_real_2array.html"},{"title":"sum_allreduce_real_3array – stella","text":"private  subroutine sum_allreduce_real_3array(a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :) :: a","tags":"","loc":"proc/sum_allreduce_real_3array.html"},{"title":"sum_allreduce_real_4array – stella","text":"private  subroutine sum_allreduce_real_4array(a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :) :: a","tags":"","loc":"proc/sum_allreduce_real_4array.html"},{"title":"sum_allreduce_real_5array – stella","text":"private  subroutine sum_allreduce_real_5array(a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :) :: a","tags":"","loc":"proc/sum_allreduce_real_5array.html"},{"title":"sum_allreduce_complex – stella","text":"private  subroutine sum_allreduce_complex(z) Arguments Type Intent Optional Attributes Name complex, intent(inout) :: z","tags":"","loc":"proc/sum_allreduce_complex.html"},{"title":"sum_allreduce_complex_array – stella","text":"private  subroutine sum_allreduce_complex_array(z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: z","tags":"","loc":"proc/sum_allreduce_complex_array.html"},{"title":"sum_allreduce_complex_2array – stella","text":"private  subroutine sum_allreduce_complex_2array(z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: z","tags":"","loc":"proc/sum_allreduce_complex_2array.html"},{"title":"sum_allreduce_complex_3array – stella","text":"private  subroutine sum_allreduce_complex_3array(z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :) :: z","tags":"","loc":"proc/sum_allreduce_complex_3array.html"},{"title":"sum_allreduce_complex_4array – stella","text":"private  subroutine sum_allreduce_complex_4array(z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :) :: z","tags":"","loc":"proc/sum_allreduce_complex_4array.html"},{"title":"sum_allreduce_complex_5array – stella","text":"private  subroutine sum_allreduce_complex_5array(z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :, :) :: z","tags":"","loc":"proc/sum_allreduce_complex_5array.html"},{"title":"max_reduce_integer – stella","text":"private  subroutine max_reduce_integer(i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i integer, intent(in) :: dest","tags":"","loc":"proc/max_reduce_integer.html"},{"title":"max_reduce_integer_array – stella","text":"private  subroutine max_reduce_integer_array(i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i integer, intent(in) :: dest","tags":"","loc":"proc/max_reduce_integer_array.html"},{"title":"max_reduce_real – stella","text":"private  subroutine max_reduce_real(a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a integer, intent(in) :: dest","tags":"","loc":"proc/max_reduce_real.html"},{"title":"max_reduce_real_array – stella","text":"private  subroutine max_reduce_real_array(a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a integer, intent(in) :: dest","tags":"","loc":"proc/max_reduce_real_array.html"},{"title":"max_allreduce_integer – stella","text":"private  subroutine max_allreduce_integer(i) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i","tags":"","loc":"proc/max_allreduce_integer.html"},{"title":"max_allreduce_integer_array – stella","text":"private  subroutine max_allreduce_integer_array(i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i","tags":"","loc":"proc/max_allreduce_integer_array.html"},{"title":"max_allreduce_real – stella","text":"private  subroutine max_allreduce_real(a) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a","tags":"","loc":"proc/max_allreduce_real.html"},{"title":"max_allreduce_real_array – stella","text":"private  subroutine max_allreduce_real_array(a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a","tags":"","loc":"proc/max_allreduce_real_array.html"},{"title":"min_reduce_integer – stella","text":"private  subroutine min_reduce_integer(i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i integer, intent(in) :: dest","tags":"","loc":"proc/min_reduce_integer.html"},{"title":"min_reduce_integer_array – stella","text":"private  subroutine min_reduce_integer_array(i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i integer, intent(in) :: dest","tags":"","loc":"proc/min_reduce_integer_array.html"},{"title":"min_reduce_real – stella","text":"private  subroutine min_reduce_real(a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a integer, intent(in) :: dest","tags":"","loc":"proc/min_reduce_real.html"},{"title":"min_reduce_real_array – stella","text":"private  subroutine min_reduce_real_array(a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a integer, intent(in) :: dest","tags":"","loc":"proc/min_reduce_real_array.html"},{"title":"min_allreduce_integer – stella","text":"private  subroutine min_allreduce_integer(i) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i","tags":"","loc":"proc/min_allreduce_integer.html"},{"title":"min_allreduce_integer_array – stella","text":"private  subroutine min_allreduce_integer_array(i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i","tags":"","loc":"proc/min_allreduce_integer_array.html"},{"title":"min_allreduce_real – stella","text":"private  subroutine min_allreduce_real(a) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a","tags":"","loc":"proc/min_allreduce_real.html"},{"title":"min_allreduce_real_array – stella","text":"private  subroutine min_allreduce_real_array(a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a","tags":"","loc":"proc/min_allreduce_real_array.html"},{"title":"comm_split – stella","text":"public  subroutine comm_split(color, comm_out, ierr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: color integer, intent(out) :: comm_out integer, intent(out) :: ierr","tags":"","loc":"proc/comm_split.html"},{"title":"comm_free – stella","text":"public  subroutine comm_free(comm_in, ierr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: comm_in integer, intent(out) :: ierr","tags":"","loc":"proc/comm_free.html"},{"title":"barrier – stella","text":"public  subroutine barrier() Arguments None","tags":"","loc":"proc/barrier.html"},{"title":"send_integer – stella","text":"private  subroutine send_integer(i, dest, tag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: dest integer, intent(in), optional :: tag","tags":"","loc":"proc/send_integer.html"},{"title":"send_integer_array – stella","text":"private  subroutine send_integer_array(i, dest, tag) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: i integer, intent(in) :: dest integer, intent(in), optional :: tag","tags":"","loc":"proc/send_integer_array.html"},{"title":"send_real – stella","text":"private  subroutine send_real(a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag","tags":"","loc":"proc/send_real.html"},{"title":"send_real_array – stella","text":"private  subroutine send_real_array(a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag","tags":"","loc":"proc/send_real_array.html"},{"title":"send_real_array_2d – stella","text":"private  subroutine send_real_array_2d(a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag","tags":"","loc":"proc/send_real_array_2d.html"},{"title":"send_complex – stella","text":"private  subroutine send_complex(z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag","tags":"","loc":"proc/send_complex.html"},{"title":"send_complex_array – stella","text":"private  subroutine send_complex_array(z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag","tags":"","loc":"proc/send_complex_array.html"},{"title":"nonblocking_send_complex_array – stella","text":"private  subroutine nonblocking_send_complex_array(z, dest, tag, request) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag integer, intent(out) :: request","tags":"","loc":"proc/nonblocking_send_complex_array.html"},{"title":"send_logical – stella","text":"private  subroutine send_logical(f, dest, tag) Arguments Type Intent Optional Attributes Name logical, intent(in) :: f integer, intent(in) :: dest integer, intent(in), optional :: tag","tags":"","loc":"proc/send_logical.html"},{"title":"send_logical_array – stella","text":"private  subroutine send_logical_array(f, dest, tag) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:) :: f integer, intent(in) :: dest integer, intent(in), optional :: tag","tags":"","loc":"proc/send_logical_array.html"},{"title":"send_character – stella","text":"private  subroutine send_character(s, dest, tag) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s integer, intent(in) :: dest integer, intent(in), optional :: tag","tags":"","loc":"proc/send_character.html"},{"title":"ssend_integer – stella","text":"private  subroutine ssend_integer(i, dest, tag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: dest integer, intent(in), optional :: tag","tags":"","loc":"proc/ssend_integer.html"},{"title":"ssend_integer_array – stella","text":"private  subroutine ssend_integer_array(i, dest, tag) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: i integer, intent(in) :: dest integer, intent(in), optional :: tag","tags":"","loc":"proc/ssend_integer_array.html"},{"title":"ssend_real – stella","text":"private  subroutine ssend_real(a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag","tags":"","loc":"proc/ssend_real.html"},{"title":"ssend_real_array – stella","text":"private  subroutine ssend_real_array(a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag","tags":"","loc":"proc/ssend_real_array.html"},{"title":"ssend_complex – stella","text":"private  subroutine ssend_complex(z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag","tags":"","loc":"proc/ssend_complex.html"},{"title":"ssend_complex_array – stella","text":"private  subroutine ssend_complex_array(z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag","tags":"","loc":"proc/ssend_complex_array.html"},{"title":"ssend_complex_2array – stella","text":"private  subroutine ssend_complex_2array(z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag","tags":"","loc":"proc/ssend_complex_2array.html"},{"title":"ssend_logical – stella","text":"private  subroutine ssend_logical(f, dest, tag) Arguments Type Intent Optional Attributes Name logical, intent(in) :: f integer, intent(in) :: dest integer, intent(in), optional :: tag","tags":"","loc":"proc/ssend_logical.html"},{"title":"ssend_logical_array – stella","text":"private  subroutine ssend_logical_array(f, dest, tag) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:) :: f integer, intent(in) :: dest integer, intent(in), optional :: tag","tags":"","loc":"proc/ssend_logical_array.html"},{"title":"receive_integer – stella","text":"private  subroutine receive_integer(i, src, tag) Arguments Type Intent Optional Attributes Name integer, intent(out) :: i integer, intent(in) :: src integer, intent(in), optional :: tag","tags":"","loc":"proc/receive_integer.html"},{"title":"receive_integer_array – stella","text":"private  subroutine receive_integer_array(i, src, tag) Arguments Type Intent Optional Attributes Name integer, intent(out), dimension(:) :: i integer, intent(in) :: src integer, intent(in), optional :: tag","tags":"","loc":"proc/receive_integer_array.html"},{"title":"receive_real – stella","text":"private  subroutine receive_real(a, src, tag) Arguments Type Intent Optional Attributes Name real, intent(out) :: a integer, intent(in) :: src integer, intent(in), optional :: tag","tags":"","loc":"proc/receive_real.html"},{"title":"receive_real_array – stella","text":"private  subroutine receive_real_array(a, src, tag) Arguments Type Intent Optional Attributes Name real, intent(out), dimension(:) :: a integer, intent(in) :: src integer, intent(in), optional :: tag","tags":"","loc":"proc/receive_real_array.html"},{"title":"receive_real_array_2d – stella","text":"private  subroutine receive_real_array_2d(a, src, tag) Arguments Type Intent Optional Attributes Name real, intent(out), dimension(:, :) :: a integer, intent(in) :: src integer, intent(in), optional :: tag","tags":"","loc":"proc/receive_real_array_2d.html"},{"title":"receive_complex – stella","text":"private  subroutine receive_complex(z, src, tag) Arguments Type Intent Optional Attributes Name complex, intent(out) :: z integer, intent(in) :: src integer, intent(in), optional :: tag","tags":"","loc":"proc/receive_complex.html"},{"title":"receive_complex_array – stella","text":"private  subroutine receive_complex_array(z, src, tag) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:) :: z integer, intent(in) :: src integer, intent(in), optional :: tag","tags":"","loc":"proc/receive_complex_array.html"},{"title":"receive_complex_2array – stella","text":"private  subroutine receive_complex_2array(z, src, tag) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :) :: z integer, intent(in) :: src integer, intent(in), optional :: tag","tags":"","loc":"proc/receive_complex_2array.html"},{"title":"nonblocking_receive_complex_array – stella","text":"private  subroutine nonblocking_receive_complex_array(z, src, tag, request) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: z integer, intent(in) :: src integer, intent(in), optional :: tag integer, intent(out) :: request","tags":"","loc":"proc/nonblocking_receive_complex_array.html"},{"title":"receive_logical – stella","text":"private  subroutine receive_logical(f, src, tag) Arguments Type Intent Optional Attributes Name logical, intent(out) :: f integer, intent(in) :: src integer, intent(in), optional :: tag","tags":"","loc":"proc/receive_logical.html"},{"title":"receive_logical_array – stella","text":"private  subroutine receive_logical_array(f, src, tag) Arguments Type Intent Optional Attributes Name logical, intent(out), dimension(:) :: f integer, intent(in) :: src integer, intent(in), optional :: tag","tags":"","loc":"proc/receive_logical_array.html"},{"title":"receive_character – stella","text":"private  subroutine receive_character(s, src, tag) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: s integer, intent(in) :: src integer, intent(in), optional :: tag","tags":"","loc":"proc/receive_character.html"},{"title":"waitany – stella","text":"public  subroutine waitany(count, requests, requestindex, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: count integer, intent(inout), dimension(:) :: requests integer, intent(out) :: requestindex integer, intent(out), dimension(MPI_STATUS_SIZE) :: status","tags":"","loc":"proc/waitany.html"},{"title":"all_to_group_real – stella","text":"private  subroutine all_to_group_real(all, group, njobs) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: all real, intent(out) :: group integer, intent(in) :: njobs","tags":"","loc":"proc/all_to_group_real.html"},{"title":"all_to_group_real_array – stella","text":"private  subroutine all_to_group_real_array(all, group, njobs) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: all real, intent(out), dimension(:) :: group integer, intent(in) :: njobs","tags":"","loc":"proc/all_to_group_real_array.html"},{"title":"group_to_all_real – stella","text":"private  subroutine group_to_all_real(group, all, njobs) Arguments Type Intent Optional Attributes Name real, intent(in) :: group real, intent(out), dimension(:) :: all integer, intent(in) :: njobs","tags":"","loc":"proc/group_to_all_real.html"},{"title":"group_to_all_real_array – stella","text":"private  subroutine group_to_all_real_array(group, all, njobs) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: group real, intent(out), dimension(:, :) :: all integer, intent(in) :: njobs","tags":"","loc":"proc/group_to_all_real_array.html"},{"title":"mp_abort – stella","text":"public  subroutine mp_abort(msg) Uses file_utils Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg","tags":"","loc":"proc/mp_abort.html"},{"title":"mp_gather – stella","text":"public  subroutine mp_gather(senddata, recvarray) Arguments Type Intent Optional Attributes Name integer, intent(in) :: senddata integer, intent(out), dimension(:) :: recvarray","tags":"","loc":"proc/mp_gather.html"},{"title":"broadcast_with_comm – stella","text":"public  subroutine broadcast_with_comm(x, comm) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: x integer, intent(in) :: comm","tags":"","loc":"proc/broadcast_with_comm.html"},{"title":"broadcast – stella","text":"public interface broadcast Module Procedures private  subroutine broadcast_integer (i) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i private  subroutine broadcast_integer_array (i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i private  subroutine broadcast_real (x) Arguments Type Intent Optional Attributes Name real, intent(inout) :: x private  subroutine broadcast_real_array (x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: x private  subroutine broadcast_real_2array (x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :) :: x private  subroutine broadcast_real_3array (x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :) :: x private  subroutine broadcast_real_4array (x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :) :: x private  subroutine broadcast_real_5array (x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :) :: x private  subroutine broadcast_complex (z) Arguments Type Intent Optional Attributes Name complex, intent(inout) :: z private  subroutine broadcast_complex_array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: z private  subroutine broadcast_complex_2array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: z private  subroutine broadcast_complex_3array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :) :: z private  subroutine broadcast_complex_4array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :) :: z private  subroutine broadcast_logical (f) Arguments Type Intent Optional Attributes Name logical, intent(inout) :: f private  subroutine broadcast_logical_array (f) Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:) :: f private  subroutine bcastfrom_integer (i, src) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i integer, intent(in) :: src private  subroutine bcastfrom_integer_array (i, src) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i integer, intent(in) :: src private  subroutine bcastfrom_real (x, src) Arguments Type Intent Optional Attributes Name real, intent(inout) :: x integer, intent(in) :: src private  subroutine bcastfrom_real_array (x, src) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: x integer, intent(in) :: src private  subroutine bcastfrom_complex (z, src) Arguments Type Intent Optional Attributes Name complex, intent(inout) :: z integer, intent(in) :: src private  subroutine bcastfrom_complex_array (z, src) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: z integer, intent(in) :: src private  subroutine bcastfrom_complex_2array (z, src) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: z integer, intent(in) :: src private  subroutine bcastfrom_logical (f, src) Arguments Type Intent Optional Attributes Name logical, intent(inout) :: f integer, intent(in) :: src private  subroutine bcastfrom_logical_array (f, src) Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:) :: f integer, intent(in) :: src private  subroutine broadcast_character (char) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: char private  subroutine bcastfrom_character (c, src) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: c integer, intent(in) :: src","tags":"","loc":"interface/broadcast.html"},{"title":"sum_reduce – stella","text":"public interface sum_reduce Module Procedures private  subroutine sum_reduce_integer (i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i integer, intent(in) :: dest private  subroutine sum_reduce_integer_array (i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i integer, intent(in) :: dest private  subroutine sum_reduce_real (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a integer, intent(in) :: dest private  subroutine sum_reduce_real_array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a integer, intent(in) :: dest private  subroutine sum_reduce_real_2array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :) :: a integer, intent(in) :: dest private  subroutine sum_reduce_real_3array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :) :: a integer, intent(in) :: dest private  subroutine sum_reduce_real_4array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :) :: a integer, intent(in) :: dest private  subroutine sum_reduce_real_5array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :) :: a integer, intent(in) :: dest private  subroutine sum_reduce_complex (z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout) :: z integer, intent(in) :: dest private  subroutine sum_reduce_complex_array (z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: z integer, intent(in) :: dest private  subroutine sum_reduce_complex_2array (z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: z integer, intent(in) :: dest private  subroutine sum_reduce_complex_3array (z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :) :: z integer, intent(in) :: dest private  subroutine sum_reduce_complex_4array (z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :) :: z integer, intent(in) :: dest private  subroutine sum_reduce_complex_5array (z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :, :) :: z integer, intent(in) :: dest","tags":"","loc":"interface/sum_reduce.html"},{"title":"sum_allreduce – stella","text":"public interface sum_allreduce Module Procedures private  subroutine sum_allreduce_integer (i) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i private  subroutine sum_allreduce_integer_array (i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i private  subroutine sum_allreduce_integer_2array (i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:, :) :: i private  subroutine sum_allreduce_real (a) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a private  subroutine sum_allreduce_real_array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a private  subroutine sum_allreduce_real_2array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :) :: a private  subroutine sum_allreduce_real_3array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :) :: a private  subroutine sum_allreduce_real_4array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :) :: a private  subroutine sum_allreduce_real_5array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :) :: a private  subroutine sum_allreduce_complex (z) Arguments Type Intent Optional Attributes Name complex, intent(inout) :: z private  subroutine sum_allreduce_complex_array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: z private  subroutine sum_allreduce_complex_2array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: z private  subroutine sum_allreduce_complex_3array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :) :: z private  subroutine sum_allreduce_complex_4array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :) :: z private  subroutine sum_allreduce_complex_5array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :, :) :: z","tags":"","loc":"interface/sum_allreduce.html"},{"title":"max_reduce – stella","text":"public interface max_reduce Module Procedures private  subroutine max_reduce_integer (i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i integer, intent(in) :: dest private  subroutine max_reduce_integer_array (i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i integer, intent(in) :: dest private  subroutine max_reduce_real (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a integer, intent(in) :: dest private  subroutine max_reduce_real_array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a integer, intent(in) :: dest","tags":"","loc":"interface/max_reduce.html"},{"title":"max_allreduce – stella","text":"public interface max_allreduce Module Procedures private  subroutine max_allreduce_integer (i) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i private  subroutine max_allreduce_integer_array (i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i private  subroutine max_allreduce_real (a) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a private  subroutine max_allreduce_real_array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a","tags":"","loc":"interface/max_allreduce.html"},{"title":"min_reduce – stella","text":"public interface min_reduce Module Procedures private  subroutine min_reduce_integer (i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i integer, intent(in) :: dest private  subroutine min_reduce_integer_array (i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i integer, intent(in) :: dest private  subroutine min_reduce_real (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a integer, intent(in) :: dest private  subroutine min_reduce_real_array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a integer, intent(in) :: dest","tags":"","loc":"interface/min_reduce.html"},{"title":"min_allreduce – stella","text":"public interface min_allreduce Module Procedures private  subroutine min_allreduce_integer (i) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i private  subroutine min_allreduce_integer_array (i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i private  subroutine min_allreduce_real (a) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a private  subroutine min_allreduce_real_array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a","tags":"","loc":"interface/min_allreduce.html"},{"title":"send – stella","text":"public interface send Module Procedures private  subroutine send_integer (i, dest, tag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine send_integer_array (i, dest, tag) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: i integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine send_real (a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine send_real_array (a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine send_real_array_2d (a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine send_complex (z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine send_complex_array (z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine nonblocking_send_complex_array (z, dest, tag, request) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag integer, intent(out) :: request private  subroutine send_logical (f, dest, tag) Arguments Type Intent Optional Attributes Name logical, intent(in) :: f integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine send_logical_array (f, dest, tag) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:) :: f integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine send_character (s, dest, tag) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s integer, intent(in) :: dest integer, intent(in), optional :: tag","tags":"","loc":"interface/send.html"},{"title":"receive – stella","text":"public interface receive Module Procedures private  subroutine receive_integer (i, src, tag) Arguments Type Intent Optional Attributes Name integer, intent(out) :: i integer, intent(in) :: src integer, intent(in), optional :: tag private  subroutine receive_integer_array (i, src, tag) Arguments Type Intent Optional Attributes Name integer, intent(out), dimension(:) :: i integer, intent(in) :: src integer, intent(in), optional :: tag private  subroutine receive_real (a, src, tag) Arguments Type Intent Optional Attributes Name real, intent(out) :: a integer, intent(in) :: src integer, intent(in), optional :: tag private  subroutine receive_real_array (a, src, tag) Arguments Type Intent Optional Attributes Name real, intent(out), dimension(:) :: a integer, intent(in) :: src integer, intent(in), optional :: tag private  subroutine receive_real_array_2d (a, src, tag) Arguments Type Intent Optional Attributes Name real, intent(out), dimension(:, :) :: a integer, intent(in) :: src integer, intent(in), optional :: tag private  subroutine receive_complex (z, src, tag) Arguments Type Intent Optional Attributes Name complex, intent(out) :: z integer, intent(in) :: src integer, intent(in), optional :: tag private  subroutine receive_complex_array (z, src, tag) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:) :: z integer, intent(in) :: src integer, intent(in), optional :: tag private  subroutine receive_complex_2array (z, src, tag) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :) :: z integer, intent(in) :: src integer, intent(in), optional :: tag private  subroutine nonblocking_receive_complex_array (z, src, tag, request) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: z integer, intent(in) :: src integer, intent(in), optional :: tag integer, intent(out) :: request private  subroutine receive_logical (f, src, tag) Arguments Type Intent Optional Attributes Name logical, intent(out) :: f integer, intent(in) :: src integer, intent(in), optional :: tag private  subroutine receive_logical_array (f, src, tag) Arguments Type Intent Optional Attributes Name logical, intent(out), dimension(:) :: f integer, intent(in) :: src integer, intent(in), optional :: tag private  subroutine receive_character (s, src, tag) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: s integer, intent(in) :: src integer, intent(in), optional :: tag","tags":"","loc":"interface/receive.html"},{"title":"ssend – stella","text":"public interface ssend Module Procedures private  subroutine ssend_integer (i, dest, tag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine ssend_integer_array (i, dest, tag) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: i integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine ssend_real (a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine ssend_real_array (a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine ssend_complex (z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine ssend_complex_array (z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine ssend_complex_2array (z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine ssend_logical (f, dest, tag) Arguments Type Intent Optional Attributes Name logical, intent(in) :: f integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine ssend_logical_array (f, dest, tag) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:) :: f integer, intent(in) :: dest integer, intent(in), optional :: tag","tags":"","loc":"interface/ssend.html"},{"title":"all_to_group – stella","text":"public interface all_to_group Module Procedures private  subroutine all_to_group_real (all, group, njobs) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: all real, intent(out) :: group integer, intent(in) :: njobs private  subroutine all_to_group_real_array (all, group, njobs) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: all real, intent(out), dimension(:) :: group integer, intent(in) :: njobs","tags":"","loc":"interface/all_to_group.html"},{"title":"group_to_all – stella","text":"public interface group_to_all Module Procedures private  subroutine group_to_all_real (group, all, njobs) Arguments Type Intent Optional Attributes Name real, intent(in) :: group real, intent(out), dimension(:) :: all integer, intent(in) :: njobs private  subroutine group_to_all_real_array (group, all, njobs) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: group real, intent(out), dimension(:, :) :: all integer, intent(in) :: njobs","tags":"","loc":"interface/group_to_all.html"},{"title":"legendre_p – stella","text":"private elemental function legendre_p(n, x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision, intent(in) :: x Return Value double precision","tags":"","loc":"proc/legendre_p.html"},{"title":"legendre_pp – stella","text":"private elemental function legendre_pp(n, x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision, intent(in) :: x Return Value double precision","tags":"","loc":"proc/legendre_pp.html"},{"title":"laguerre_l – stella","text":"private elemental function laguerre_l(n, x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=qp), intent(in) :: x Return Value real(kind=qp)","tags":"","loc":"proc/laguerre_l.html"},{"title":"laguerre_lp – stella","text":"private elemental function laguerre_lp(n, x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=qp), intent(in) :: x Return Value real(kind=qp)","tags":"","loc":"proc/laguerre_lp.html"},{"title":"get_legendre_grids_from_cheb – stella","text":"public  subroutine get_legendre_grids_from_cheb(x1, x2, zero, wgt) Uses constants Arguments Type Intent Optional Attributes Name real, intent(in) :: x1 real, intent(in) :: x2 real, intent(out), dimension(:) :: zero real, intent(out), dimension(:) :: wgt","tags":"","loc":"proc/get_legendre_grids_from_cheb.html"},{"title":"find_zero_bisect_newton – stella","text":"private  subroutine find_zero_bisect_newton(n, xold, xnew, pold, pnew, zz) Uses file_utils Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision, intent(in) :: xold double precision, intent(in) :: xnew double precision, intent(in) :: pold double precision, intent(in) :: pnew double precision, intent(out) :: zz","tags":"","loc":"proc/find_zero_bisect_newton.html"},{"title":"check_legendre_zero – stella","text":"private  subroutine check_legendre_zero(x0, x1, zero) Uses file_utils mp Arguments Type Intent Optional Attributes Name real, intent(in) :: x0 real, intent(in) :: x1 real, intent(in), dimension(:) :: zero","tags":"","loc":"proc/check_legendre_zero.html"},{"title":"check_legendre_weights – stella","text":"private  subroutine check_legendre_weights(norm, wgt) Uses file_utils mp Arguments Type Intent Optional Attributes Name real, intent(in) :: norm real, intent(in), dimension(:) :: wgt","tags":"","loc":"proc/check_legendre_weights.html"},{"title":"get_laguerre_grids – stella","text":"public  subroutine get_laguerre_grids(zero, wgt) Uses file_utils mp Arguments Type Intent Optional Attributes Name real, intent(out), dimension(:) :: zero real, intent(out), dimension(:) :: wgt","tags":"","loc":"proc/get_laguerre_grids.html"},{"title":"find_zero – stella","text":"private  subroutine find_zero(n, eps, xold, xnew, pold, pnew, zz) Uses file_utils Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision, intent(in) :: eps real(kind=qp), intent(in) :: xold real(kind=qp), intent(in) :: xnew real(kind=qp), intent(in) :: pold real(kind=qp), intent(in) :: pnew real(kind=qp), intent(out) :: zz","tags":"","loc":"proc/find_zero.html"},{"title":"check_laguerre_zeros – stella","text":"private  subroutine check_laguerre_zeros(zero) Uses file_utils mp Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: zero","tags":"","loc":"proc/check_laguerre_zeros.html"},{"title":"check_laguerre_weights – stella","text":"private  subroutine check_laguerre_weights(wgt, eps) Uses file_utils mp Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: wgt real, intent(in) :: eps","tags":"","loc":"proc/check_laguerre_weights.html"},{"title":"init_redistribute – stella","text":"public  subroutine init_redistribute() Uses physics_flags Arguments None","tags":"","loc":"proc/init_redistribute.html"},{"title":"init_kxkyz_to_vmu_redistribute – stella","text":"private  subroutine init_kxkyz_to_vmu_redistribute() Uses mp zgrid stella_layouts vpamu_grids redistribute Arguments None","tags":"","loc":"proc/init_kxkyz_to_vmu_redistribute.html"},{"title":"init_kxyz_to_vmu_redistribute – stella","text":"private  subroutine init_kxyz_to_vmu_redistribute() Uses mp zgrid stella_layouts vpamu_grids redistribute Arguments None","tags":"","loc":"proc/init_kxyz_to_vmu_redistribute.html"},{"title":"init_xyz_to_vmu_redistribute – stella","text":"private  subroutine init_xyz_to_vmu_redistribute() Uses mp zgrid stella_layouts vpamu_grids redistribute Arguments None","tags":"","loc":"proc/init_xyz_to_vmu_redistribute.html"},{"title":"finish_redistribute – stella","text":"public  subroutine finish_redistribute() Arguments None","tags":"","loc":"proc/finish_redistribute.html"},{"title":"init_parallel_streaming – stella","text":"public  subroutine init_parallel_streaming() Uses zgrid species stella_layouts physics_flags finite_differences kt_grids vpamu_grids stella_time stella_geometry run_parameters stream_sign set to +/- 1 depending on the sign of the parallel streaming term.\nNB: stream_sign = -1 corresponds to positive advection velocity\nonly need to consider ia=1, iz=0 and is=1 because alpha, z and species dependences\ndo not lead to change in sign of the streaming pre-factor\nget gradpar centred in zed for negative vpa (affects upwinding)\nget gradpar centred in zed for positive vpa (affects upwinding) Arguments None","tags":"","loc":"proc/init_parallel_streaming.html"},{"title":"init_invert_stream_operator – stella","text":"private  subroutine init_invert_stream_operator() Uses zgrid run_parameters extended_zgrid Arguments None","tags":"","loc":"proc/init_invert_stream_operator.html"},{"title":"advance_parallel_streaming_explicit – stella","text":"public  subroutine advance_parallel_streaming_explicit(g, phi, bpar, gout) Uses job_manage mp zgrid species stella_layouts physics_flags gyro_averages kt_grids vpamu_grids stella_transforms run_parameters if flux tube simulation parallel streaming stays in ky,kx,z space with ky,kx,z local\nif full flux surface (flux annulus), will need to calculate in y space\nstart the timer for the parallel streaming part of the time advance allocate arrays needed for intermmediate calculations\nif simulating a full flux surface, will also need version of the above arrays\nthat is Fourier transformed to y-space\nget (iv,imu,is) indices corresponding to ivmu super-index\nobtain (or -phi if driftkinetic_implicit=T)\nget d /dz, with z the parallel coordinate and store in dgphi_dz\nnote that this should be a centered difference to avoid numerical\nunpleasantness to do with inexact cancellations in later velocity integration\nsee appendix of the stella JCP 2019 for details if driftkinetic_implicit=T, then only want to treat vpar . grad ( -phi)*F0 term explicitly;\nin this case, zero out dg/dz term (or d(g/F)/dz for full-flux-surface)\ncompute dg/dz in k-space and store in g0\nif simulating a full flux surface, need to obtain the contribution from parallel streaming\nin y-space, so FFT d(g/F)/dz from ky to y\ntransform d /dz (fully explicit) or d( -phi)/dz (if driftkinetic_implicit)\nfrom kalpha (ky) to alpha (y) space and store in g1y\nover-write g0y with d/dz (g/F) + Ze/T * d /dz (or -phi for driftkinetic_implicit). multiply d(g/F)/dz and d /dz terms with vpa*(b . grad z) and add to source (RHS of GK equation)\nbpar term is zero unless include_bpar = T, see if statement above.\ndeallocate intermediate arrays used in this subroutine\nfinish timing the subroutine Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(in), dimension(:, :, -nzgrid:, :) :: bpar complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout","tags":"","loc":"proc/advance_parallel_streaming_explicit.html"},{"title":"add_parallel_streaming_radial_variation – stella","text":"public  subroutine add_parallel_streaming_radial_variation(g, gout, rhs) Uses job_manage zgrid species stella_layouts gyro_averages fields_arrays kt_grids vpamu_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: rhs","tags":"","loc":"proc/add_parallel_streaming_radial_variation.html"},{"title":"get_dgdz – stella","text":"private  subroutine get_dgdz(g, ivmu, dgdz) Uses zgrid stella_layouts finite_differences extended_zgrid kt_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: g integer, intent(in) :: ivmu complex, intent(out), dimension(:, :, -nzgrid:, :) :: dgdz","tags":"","loc":"proc/get_dgdz.html"},{"title":"get_dgdz_centered – stella","text":"private  subroutine get_dgdz_centered(g, ivmu, dgdz) Uses zgrid stella_layouts finite_differences extended_zgrid kt_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: g integer, intent(in) :: ivmu complex, intent(out), dimension(:, :, -nzgrid:, :) :: dgdz","tags":"","loc":"proc/get_dgdz_centered.html"},{"title":"add_stream_term – stella","text":"private  subroutine add_stream_term(g, ivmu, src) Uses stella_layouts zgrid Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: g integer, intent(in) :: ivmu complex, intent(inout), dimension(:, :, -nzgrid:, :) :: src","tags":"","loc":"proc/add_stream_term.html"},{"title":"add_stream_term_ffs – stella","text":"private  subroutine add_stream_term_ffs(g, ivmu, src) Uses kt_grids stella_layouts zgrid Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: g integer, intent(in) :: ivmu complex, intent(inout), dimension(:, :, -nzgrid:, :) :: src","tags":"","loc":"proc/add_stream_term_ffs.html"},{"title":"stream_tridiagonal_solve – stella","text":"public  subroutine stream_tridiagonal_solve(iky, ie, iv, is, g) Uses finite_differences extended_zgrid Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky integer, intent(in) :: ie integer, intent(in) :: iv integer, intent(in) :: is complex, intent(inout), dimension(:) :: g","tags":"","loc":"proc/stream_tridiagonal_solve.html"},{"title":"get_dzed – stella","text":"public  subroutine get_dzed(iv, g, dgdz) Uses kt_grids zgrid finite_differences extended_zgrid Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv complex, intent(in), dimension(:, :, -nzgrid:, :) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: dgdz","tags":"","loc":"proc/get_dzed~2.html"},{"title":"get_zed_derivative_extended_domain – stella","text":"public  subroutine get_zed_derivative_extended_domain(iv, f, f_left, f_right, df_dz) Uses zgrid finite_differences Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv complex, intent(in), dimension(:) :: f complex, intent(in) :: f_left complex, intent(in) :: f_right complex, intent(out), dimension(:) :: df_dz","tags":"","loc":"proc/get_zed_derivative_extended_domain.html"},{"title":"center_zed_extended – stella","text":"private  subroutine center_zed_extended(iv, g) Uses zgrid finite_differences extended_zgrid kt_grids run_parameters Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv complex, intent(inout), dimension(:, :, -nzgrid:, :) :: g","tags":"","loc":"proc/center_zed_extended.html"},{"title":"center_zed_segment_real – stella","text":"private  subroutine center_zed_segment_real(iv, f, llim) Uses run_parameters center_zed_segment_real takes as arguments the vpa index (iv)\nthe z-depenendent real function f, and the starting iz index for the array f (llim),\nand overwrites f with the cell-centered version Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv real, intent(inout), dimension(llim:) :: f integer, intent(in) :: llim","tags":"","loc":"proc/center_zed_segment_real.html"},{"title":"center_zed_segment_complex – stella","text":"private  subroutine center_zed_segment_complex(iv, f, llim, periodic) Uses run_parameters center_zed_segment_complex takes as arguments the vpa index (iv)\nthe z-depenendent conplex function f, and the starting iz index for the array f (llim),\nand overwrites f with the cell-centered version; Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv complex, intent(inout), dimension(llim:) :: f integer, intent(in) :: llim logical, intent(in) :: periodic","tags":"","loc":"proc/center_zed_segment_complex.html"},{"title":"finish_parallel_streaming – stella","text":"public  subroutine finish_parallel_streaming() Uses run_parameters Arguments None","tags":"","loc":"proc/finish_parallel_streaming.html"},{"title":"finish_invert_stream_operator – stella","text":"private  subroutine finish_invert_stream_operator() Arguments None","tags":"","loc":"proc/finish_invert_stream_operator.html"},{"title":"center_zed – stella","text":"public interface center_zed Module Procedures private  subroutine center_zed_segment_real (iv, f, llim) center_zed_segment_real takes as arguments the vpa index (iv)\nthe z-depenendent real function f, and the starting iz index for the array f (llim),\nand overwrites f with the cell-centered version Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv real, intent(inout), dimension(llim:) :: f integer, intent(in) :: llim private  subroutine center_zed_segment_complex (iv, f, llim, periodic) center_zed_segment_complex takes as arguments the vpa index (iv)\nthe z-depenendent conplex function f, and the starting iz index for the array f (llim),\nand overwrites f with the cell-centered version; Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv complex, intent(inout), dimension(llim:) :: f integer, intent(in) :: llim logical, intent(in) :: periodic private  subroutine center_zed_extended (iv, g) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv complex, intent(inout), dimension(:, :, -nzgrid:, :) :: g","tags":"","loc":"interface/center_zed.html"},{"title":"init_neoclassical_terms – stella","text":"public  subroutine init_neoclassical_terms() Uses zgrid species stella_layouts sfincs_interface kt_grids vpamu_grids Arguments None","tags":"","loc":"proc/init_neoclassical_terms.html"},{"title":"read_parameters – stella","text":"private  subroutine read_parameters() Uses file_utils mp text_options Arguments None Namelists Namelist neoclassical_input Variables Name Type Default Description include_neoclassical_terms logical None neo_option character(len=10) None nradii integer None drho real None","tags":"","loc":"proc/read_parameters~9.html"},{"title":"distribute_vmus_over_procs – stella","text":"private  subroutine distribute_vmus_over_procs(local, distributed) Uses stella_layouts Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :, :) :: local real, intent(out), dimension(vmu_lo%llim_proc:) :: distributed","tags":"","loc":"proc/distribute_vmus_over_procs.html"},{"title":"get_dfneo_dvpa – stella","text":"private  subroutine get_dfneo_dvpa(fneo, dfneo) Uses zgrid species stella_layouts finite_differences kt_grids vpamu_grids Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, -nzgrid:, :, :, :) :: fneo real, intent(out), dimension(:, -nzgrid:, vmu_lo%llim_proc:) :: dfneo","tags":"","loc":"proc/get_dfneo_dvpa.html"},{"title":"get_dfneo_dzed – stella","text":"private  subroutine get_dfneo_dzed(fneo, dfneo) Uses zgrid species stella_layouts finite_differences kt_grids vpamu_grids Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, -nzgrid:, :, :, :) :: fneo real, intent(out), dimension(:, -nzgrid:, vmu_lo%llim_proc:) :: dfneo","tags":"","loc":"proc/get_dfneo_dzed.html"},{"title":"get_dfneo_drho – stella","text":"private  subroutine get_dfneo_drho(fneo, dfneo) Uses zgrid species stella_layouts finite_differences kt_grids vpamu_grids Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, -nzgrid:, :, :, :, -nradii/2:) :: fneo real, intent(out), dimension(:, -nzgrid:, vmu_lo%llim_proc:) :: dfneo","tags":"","loc":"proc/get_dfneo_drho.html"},{"title":"get_dphineo_dzed – stella","text":"private  subroutine get_dphineo_dzed(phineo, dphineo) Uses kt_grids zgrid finite_differences Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, -nzgrid:) :: phineo real, intent(out), dimension(:, -nzgrid:) :: dphineo","tags":"","loc":"proc/get_dphineo_dzed.html"},{"title":"get_dphineo_drho – stella","text":"private  subroutine get_dphineo_drho(phineo, dphineo) Uses kt_grids zgrid finite_differences Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, -nzgrid:, -nradii/2:) :: phineo real, intent(out), dimension(:, -nzgrid:) :: dphineo","tags":"","loc":"proc/get_dphineo_drho.html"},{"title":"write_neoclassical – stella","text":"private  subroutine write_neoclassical(fnc, phinc) Uses mp zgrid stella_layouts file_utils kt_grids vpamu_grids Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, -nzgrid:, :, :, :, -nradii/2:) :: fnc real, intent(in), dimension(:, -nzgrid:, -nradii/2:) :: phinc","tags":"","loc":"proc/write_neoclassical.html"},{"title":"finish_neoclassical_terms – stella","text":"public  subroutine finish_neoclassical_terms() Arguments None","tags":"","loc":"proc/finish_neoclassical_terms.html"},{"title":"init_run_parameters – stella","text":"public  subroutine init_run_parameters() Arguments None","tags":"","loc":"proc/init_run_parameters.html"},{"title":"read_parameters – stella","text":"private  subroutine read_parameters() Uses physics_parameters mp physics_flags file_utils text_options print warning messages and override inconsistent or unsupported options for full_flux_surface = T Arguments None Namelists Namelist knobs Variables Name Type Default Description fphi real None fapar real None fbpar real None delt real None nstep integer None tend real None delt_option character(len=20) None lu_option character(len=20) None avail_cpu_time real None delt_max real None delt_min real None cfl_cushion_upper real None cfl_cushion_middle real None cfl_cushion_lower real None stream_implicit logical None mirror_implicit logical None driftkinetic_implicit logical None drifts_implicit logical None use_deltaphi_for_response_matrix logical None maxwellian_normalization logical None stream_matrix_inversion logical None maxwellian_inside_zed_derivative logical None mirror_semi_lagrange logical None mirror_linear_interp logical None zed_upwind real None vpa_upwind real None time_upwind real None fields_kxkyz logical None mat_gen logical None mat_read logical None rng_seed integer None ky_solve_radial integer None ky_solve_real logical None","tags":"","loc":"proc/read_parameters~10.html"},{"title":"finish_run_parameters – stella","text":"public  subroutine finish_run_parameters() Arguments None","tags":"","loc":"proc/finish_run_parameters.html"},{"title":"read_vpamu_grids_parameters – stella","text":"public  subroutine read_vpamu_grids_parameters() Uses file_utils mp Arguments None Namelists Namelist vpamu_grids_parameters Variables Name Type Default Description nvgrid integer None nmu integer None vpa_max real None vperp_max real None equally_spaced_mu_grid logical None conservative_wgts_vpa logical None","tags":"","loc":"proc/read_vpamu_grids_parameters.html"},{"title":"init_vpamu_grids – stella","text":"public  subroutine init_vpamu_grids() Uses species set up the vpa grid points and integration weights\nset up the mu grid points and integration weights maxwell_fac = 1 unless radially global Arguments None","tags":"","loc":"proc/init_vpamu_grids.html"},{"title":"init_vpa_grid – stella","text":"public  subroutine init_vpa_grid() Uses species mp constants run_parameters vpa is the parallel velocity at grid points\nwgts_vpa are the integration weights assigned\nto the parallel velocity grid points\nthis is the Maxwellian in vpa\nparallel velocity grid goes from -vpa_max to vpa_max,\nwith no point at vpa = 0;\nthe lack of a point at vpa=0 avoids treating\nthe vpa=z=0 phase space location, which\nis isolated from all other phase space points\nin the absence of collisions\nequal grid spacing in vpa obtain vpa grid for vpa > 0\nfill in vpa grid for vpa < 0 maxwell_vpa is the equilibrium Maxwellian in vpa\nztmax is the Maxwellian in vpa, multipliedd by charge number over normalized temperature get integration weights corresponding to vpa grid points\nfor now use Simpson's rule;\ni.e. subdivide grid into 3-point segments, with each segment spanning vpa_low to vpa_up\nthen the contribution of each segment to the integral is\n(vpa_up - vpa_low) * (f1 + 4*f2 + f3) / 6\ninner boundary points are used in two segments, so they get double the weight use simpson 3/8 rule at lower boundary and composite Simpson elsewhere\ncomposite simpson\nfor the sake of symmetry, do the same thing with 3/8 rule at upper boundary\nand composite elsewhere.\ndivide by 2 to account for double-counting if maxwellian_normalization = .true., then the evolved pdf\nis normalized by a Maxwellian; this normalization must be accounted\nfor in the velocity space integrals, so include exp(-vpa&#94;2) factor\nin the vpa weights. Arguments None","tags":"","loc":"proc/init_vpa_grid.html"},{"title":"set_vpa_weights – stella","text":"public  subroutine set_vpa_weights(conservative) Uses constants Arguments Type Intent Optional Attributes Name logical, intent(in) :: conservative","tags":"","loc":"proc/set_vpa_weights.html"},{"title":"integrate_mu_local – stella","text":"public  subroutine integrate_mu_local(iz, g, total) Uses species Arguments Type Intent Optional Attributes Name integer, intent(in) :: iz real, intent(in), dimension(:, :) :: g real, intent(out), dimension(:) :: total","tags":"","loc":"proc/integrate_mu_local.html"},{"title":"integrate_mu_nonlocal – stella","text":"public  subroutine integrate_mu_nonlocal(iz, g, total) Uses stella_layouts mp Arguments Type Intent Optional Attributes Name integer, intent(in) :: iz real, intent(in), dimension(vmu_lo%llim_proc:) :: g real, intent(out), dimension(:, :) :: total","tags":"","loc":"proc/integrate_mu_nonlocal.html"},{"title":"integrate_vmu_local_real – stella","text":"public  subroutine integrate_vmu_local_real(g, iz, total) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: g integer, intent(in) :: iz real, intent(out) :: total","tags":"","loc":"proc/integrate_vmu_local_real.html"},{"title":"integrate_vmu_local_complex – stella","text":"public  subroutine integrate_vmu_local_complex(g, iz, total) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: g integer, intent(in) :: iz complex, intent(out) :: total","tags":"","loc":"proc/integrate_vmu_local_complex.html"},{"title":"integrate_vmu_vmulo_complex – stella","text":"public  subroutine integrate_vmu_vmulo_complex(g, weights, total) Uses stella_layouts mp zgrid Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g real, intent(in), dimension(:) :: weights complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: total","tags":"","loc":"proc/integrate_vmu_vmulo_complex.html"},{"title":"integrate_vmu_vmulo_ivmu_only_real – stella","text":"public  subroutine integrate_vmu_vmulo_ivmu_only_real(g, ia, iz, total) Uses stella_layouts mp Arguments Type Intent Optional Attributes Name real, intent(in), dimension(vmu_lo%llim_proc:) :: g integer, intent(in) :: ia integer, intent(in) :: iz real, intent(out), dimension(:) :: total","tags":"","loc":"proc/integrate_vmu_vmulo_ivmu_only_real.html"},{"title":"integrate_species_vmu – stella","text":"public  subroutine integrate_species_vmu(g, weights, total, ia_in) Uses stella_layouts mp zgrid Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g real, intent(in), dimension(:) :: weights complex, intent(out), dimension(:, :, -nzgrid:, :) :: total integer, intent(in), optional :: ia_in","tags":"","loc":"proc/integrate_species_vmu.html"},{"title":"integrate_species_vmu_single – stella","text":"public  subroutine integrate_species_vmu_single(g, iz, weights, total, ia_in, reduce_in) Uses stella_layouts mp Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(vmu_lo%llim_proc:) :: g integer, intent(in) :: iz real, intent(in), dimension(:) :: weights complex, intent(out) :: total integer, intent(in), optional :: ia_in logical, intent(in), optional :: reduce_in","tags":"","loc":"proc/integrate_species_vmu_single.html"},{"title":"integrate_species_vmu_single_real – stella","text":"public  subroutine integrate_species_vmu_single_real(g, iz, weights, total, ia_in, reduce_in) Uses stella_layouts mp Arguments Type Intent Optional Attributes Name real, intent(in), dimension(vmu_lo%llim_proc:) :: g integer, intent(in) :: iz real, intent(in), dimension(:) :: weights real, intent(out) :: total integer, intent(in), optional :: ia_in logical, intent(in), optional :: reduce_in","tags":"","loc":"proc/integrate_species_vmu_single_real.html"},{"title":"integrate_species_vmu_block_complex – stella","text":"public  subroutine integrate_species_vmu_block_complex(g, iz, weights, pout, ia_in, reduce_in) Uses stella_layouts mp Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, vmu_lo%llim_proc:) :: g integer, intent(in) :: iz real, intent(in), dimension(:) :: weights complex, intent(out), dimension(:, :) :: pout integer, intent(in), optional :: ia_in logical, intent(in), optional :: reduce_in","tags":"","loc":"proc/integrate_species_vmu_block_complex.html"},{"title":"integrate_species_vmu_block_real – stella","text":"public  subroutine integrate_species_vmu_block_real(g, iz, weights, pout, ia_in, reduce_in) Uses stella_layouts mp Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :, vmu_lo%llim_proc:) :: g integer, intent(in) :: iz real, intent(in), dimension(:) :: weights real, intent(out), dimension(:, :) :: pout integer, intent(in), optional :: ia_in logical, intent(in), optional :: reduce_in","tags":"","loc":"proc/integrate_species_vmu_block_real.html"},{"title":"integrate_species_ffs – stella","text":"public  subroutine integrate_species_ffs(g, weights, pout, reduce_in) Uses stella_layouts mp Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, vmu_lo%llim_proc:) :: g real, intent(in), dimension(:) :: weights complex, intent(out), dimension(:, :) :: pout logical, intent(in), optional :: reduce_in","tags":"","loc":"proc/integrate_species_ffs.html"},{"title":"integrate_vmu_ffs – stella","text":"public  subroutine integrate_vmu_ffs(g, weights, ia, iz, pout, reduce_in) Uses stella_layouts mp NB: for FFS, assume that there is only one flux annulus\nthe inclusion of the Maxwellian term below is due to the fact that\ng/F is evolved for FFS Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(vmu_lo%llim_proc:) :: g real, intent(in), dimension(:) :: weights integer, intent(in) :: ia integer, intent(in) :: iz complex, intent(out), dimension(:) :: pout logical, intent(in), optional :: reduce_in","tags":"","loc":"proc/integrate_vmu_ffs.html"},{"title":"finish_vpa_grid – stella","text":"public  subroutine finish_vpa_grid() Arguments None","tags":"","loc":"proc/finish_vpa_grid.html"},{"title":"init_mu_grid – stella","text":"public  subroutine init_mu_grid() Uses zgrid species kt_grids stella_geometry run_parameters gauss_quad allocate arrays and initialize to zero\ndvpe * vpe = d(2 mu B0) * B/2B0\nfirst get equally spaced grid in mu with max value\nmu_max = vperp_max 2/(2 max(bmag))\nwant first grid point at dmu/2 to avoid mu=0 special point\ndmu/2 + (nmu-1) dmu = mu_max\nso dmu = mu_max/(nmu-1/2)\ndo simplest thing to start\nleave dmu(nmu) uninitialized. should never be used, so want\nvalgrind or similar to return error if it is maxwell_mu is the mu part of the v-space Maxwellian factor of 2. necessary to account for 2pi from\nintegration over gyro-angle and 1/pi&#94;(3/2) normalization\nof velocity space Jacobian if maxwellian_normalization, the evolved pdf is normalized by a Maxwwellian;\nin this case, the velocity integration must account for the Maxwellian. add ghost cell at mu=0 and beyond mu_max for purposes of differentiation\nnote assuming here that grid spacing for ghost cell is equal to\ngrid spacing for last non-ghost cell\nthis is mu at cell centres (including to left and right of mu grid boundary points)\nthis is mu_{j+1/2} - mu_{j-1/2} Arguments None","tags":"","loc":"proc/init_mu_grid.html"},{"title":"finish_mu_grid – stella","text":"public  subroutine finish_mu_grid() Arguments None","tags":"","loc":"proc/finish_mu_grid.html"},{"title":"calculate_velocity_integrals – stella","text":"public  subroutine calculate_velocity_integrals() Uses species zgrid Arguments None","tags":"","loc":"proc/calculate_velocity_integrals.html"},{"title":"finish_vpamu_grids – stella","text":"public  subroutine finish_vpamu_grids() Arguments None","tags":"","loc":"proc/finish_vpamu_grids.html"},{"title":"integrate_species – stella","text":"public interface integrate_species Module Procedures public  subroutine integrate_species_vmu (g, weights, total, ia_in) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g real, intent(in), dimension(:) :: weights complex, intent(out), dimension(:, :, -nzgrid:, :) :: total integer, intent(in), optional :: ia_in public  subroutine integrate_species_vmu_single (g, iz, weights, total, ia_in, reduce_in) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(vmu_lo%llim_proc:) :: g integer, intent(in) :: iz real, intent(in), dimension(:) :: weights complex, intent(out) :: total integer, intent(in), optional :: ia_in logical, intent(in), optional :: reduce_in public  subroutine integrate_species_vmu_single_real (g, iz, weights, total, ia_in, reduce_in) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(vmu_lo%llim_proc:) :: g integer, intent(in) :: iz real, intent(in), dimension(:) :: weights real, intent(out) :: total integer, intent(in), optional :: ia_in logical, intent(in), optional :: reduce_in public  subroutine integrate_species_vmu_block_complex (g, iz, weights, pout, ia_in, reduce_in) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, vmu_lo%llim_proc:) :: g integer, intent(in) :: iz real, intent(in), dimension(:) :: weights complex, intent(out), dimension(:, :) :: pout integer, intent(in), optional :: ia_in logical, intent(in), optional :: reduce_in public  subroutine integrate_species_vmu_block_real (g, iz, weights, pout, ia_in, reduce_in) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :, vmu_lo%llim_proc:) :: g integer, intent(in) :: iz real, intent(in), dimension(:) :: weights real, intent(out), dimension(:, :) :: pout integer, intent(in), optional :: ia_in logical, intent(in), optional :: reduce_in","tags":"","loc":"interface/integrate_species.html"},{"title":"integrate_vmu – stella","text":"public interface integrate_vmu Module Procedures public  subroutine integrate_vmu_local_real (g, iz, total) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: g integer, intent(in) :: iz real, intent(out) :: total public  subroutine integrate_vmu_local_complex (g, iz, total) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: g integer, intent(in) :: iz complex, intent(out) :: total public  subroutine integrate_vmu_vmulo_complex (g, weights, total) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g real, intent(in), dimension(:) :: weights complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: total public  subroutine integrate_vmu_vmulo_ivmu_only_real (g, ia, iz, total) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(vmu_lo%llim_proc:) :: g integer, intent(in) :: ia integer, intent(in) :: iz real, intent(out), dimension(:) :: total","tags":"","loc":"interface/integrate_vmu.html"},{"title":"integrate_mu – stella","text":"public interface integrate_mu Module Procedures public  subroutine integrate_mu_local (iz, g, total) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iz real, intent(in), dimension(:, :) :: g real, intent(out), dimension(:) :: total public  subroutine integrate_mu_nonlocal (iz, g, total) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iz real, intent(in), dimension(vmu_lo%llim_proc:) :: g real, intent(out), dimension(:, :) :: total","tags":"","loc":"interface/integrate_mu.html"},{"title":"systemf – stella","text":"public  subroutine systemf(command) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: command","tags":"","loc":"proc/systemf.html"},{"title":"imaxloc – stella","text":"public  function imaxloc(array) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: array Return Value integer","tags":"","loc":"proc/imaxloc.html"},{"title":"lu_decomposition_real – stella","text":"public  subroutine lu_decomposition_real(lu, idx, d) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :) :: lu integer, intent(out), dimension(:) :: idx real, intent(out) :: d","tags":"","loc":"proc/lu_decomposition_real.html"},{"title":"lu_decomposition_complex – stella","text":"public  subroutine lu_decomposition_complex(lu, idx, d) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: lu integer, intent(out), dimension(:) :: idx real, intent(out) :: d","tags":"","loc":"proc/lu_decomposition_complex.html"},{"title":"lu_back_substitution_real – stella","text":"public  subroutine lu_back_substitution_real(lu, idx, b) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx real, intent(inout), dimension(:) :: b","tags":"","loc":"proc/lu_back_substitution_real.html"},{"title":"lu_back_substitution_real_complex – stella","text":"public  subroutine lu_back_substitution_real_complex(lu, idx, b) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx complex, intent(inout), dimension(:) :: b","tags":"","loc":"proc/lu_back_substitution_real_complex.html"},{"title":"lu_back_substitution_complex – stella","text":"public  subroutine lu_back_substitution_complex(lu, idx, b) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx complex, intent(inout), dimension(:) :: b","tags":"","loc":"proc/lu_back_substitution_complex.html"},{"title":"lu_back_substitution_matrix_real – stella","text":"public  subroutine lu_back_substitution_matrix_real(lu, idx, b) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx real, intent(inout), dimension(:, :) :: b","tags":"","loc":"proc/lu_back_substitution_matrix_real.html"},{"title":"lu_back_substitution_matrix_complex – stella","text":"public  subroutine lu_back_substitution_matrix_complex(lu, idx, b) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx complex, intent(inout), dimension(:, :) :: b","tags":"","loc":"proc/lu_back_substitution_matrix_complex.html"},{"title":"lu_inverse_real – stella","text":"public  subroutine lu_inverse_real(lu, idx, inverse) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx real, intent(out), dimension(:, :) :: inverse","tags":"","loc":"proc/lu_inverse_real.html"},{"title":"lu_inverse_complex – stella","text":"public  subroutine lu_inverse_complex(lu, idx, inverse) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx complex, intent(out), dimension(:, :) :: inverse","tags":"","loc":"proc/lu_inverse_complex.html"},{"title":"lu_decomposition – stella","text":"public interface lu_decomposition Module Procedures public  subroutine lu_decomposition_real (lu, idx, d) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :) :: lu integer, intent(out), dimension(:) :: idx real, intent(out) :: d public  subroutine lu_decomposition_complex (lu, idx, d) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: lu integer, intent(out), dimension(:) :: idx real, intent(out) :: d","tags":"","loc":"interface/lu_decomposition.html"},{"title":"lu_back_substitution – stella","text":"public interface lu_back_substitution Module Procedures public  subroutine lu_back_substitution_real (lu, idx, b) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx real, intent(inout), dimension(:) :: b public  subroutine lu_back_substitution_real_complex (lu, idx, b) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx complex, intent(inout), dimension(:) :: b public  subroutine lu_back_substitution_complex (lu, idx, b) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx complex, intent(inout), dimension(:) :: b public  subroutine lu_back_substitution_matrix_real (lu, idx, b) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx real, intent(inout), dimension(:, :) :: b public  subroutine lu_back_substitution_matrix_complex (lu, idx, b) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx complex, intent(inout), dimension(:, :) :: b","tags":"","loc":"interface/lu_back_substitution.html"},{"title":"lu_inverse – stella","text":"public interface lu_inverse Module Procedures public  subroutine lu_inverse_real (lu, idx, inverse) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx real, intent(out), dimension(:, :) :: inverse public  subroutine lu_inverse_complex (lu, idx, inverse) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx complex, intent(out), dimension(:, :) :: inverse","tags":"","loc":"interface/lu_inverse.html"},{"title":"Rpos – stella","text":"private  function Rpos(r, theta, j) Uses constants Arguments Type Intent Optional Attributes Name real, intent(in) :: r real, intent(in) :: theta integer, intent(in) :: j Return Value real","tags":"","loc":"proc/rpos.html"},{"title":"Zpos – stella","text":"private  function Zpos(r, theta, j) Arguments Type Intent Optional Attributes Name real, intent(in) :: r real, intent(in) :: theta integer, intent(in) :: j Return Value real","tags":"","loc":"proc/zpos.html"},{"title":"mod2pi – stella","text":"private  function mod2pi(theta) Arguments Type Intent Optional Attributes Name real, intent(in) :: theta Return Value real","tags":"","loc":"proc/mod2pi.html"},{"title":"init_local_defaults – stella","text":"public  subroutine init_local_defaults() Arguments None","tags":"","loc":"proc/init_local_defaults.html"},{"title":"read_local_parameters – stella","text":"public  subroutine read_local_parameters(nzed, nzgrid, local_out) Uses file_utils common_types Arguments Type Intent Optional Attributes Name integer, intent(in) :: nzed integer, intent(in) :: nzgrid type( flux_surface_type ), intent(out) :: local_out Namelists Namelist millergeo_parameters Variables Name Type Default Description rhoc real None rmaj real None shift real None qinp real None shat real None kappa real None kapprim real None tri real None triprim real None rgeo real None betaprim real None betadbprim real None d2qdr2 real None d2psidr2 real None nzed_local integer None read_profile_variation logical None write_profile_variation logical None","tags":"","loc":"proc/read_local_parameters.html"},{"title":"communicate_parameters_multibox – stella","text":"public  subroutine communicate_parameters_multibox(surf, drl, drr) Uses job_manage mp common_types Arguments Type Intent Optional Attributes Name type( flux_surface_type ), intent(inout) :: surf real, intent(in), optional :: drl real, intent(in), optional :: drr","tags":"","loc":"proc/communicate_parameters_multibox.html"},{"title":"get_local_geo – stella","text":"public  subroutine get_local_geo(nzed, nzgrid, zed_in, zed_equal_arc, dpsidrho_out, dpsidrho_psi0_out, dIdrho_out, grho_out, bmag_out, bmag_psi0_out, gds2_out, gds21_out, gds22_out, gds23_out, gds24_out, gradpar_out, gbdrift0_out, gbdrift_out, cvdrift0_out, cvdrift_out, dBdrho_out, d2Bdrdth_out, dgradpardrho_out, btor_out, rmajor_out, dcvdrift0drho_out, dcvdriftdrho_out, dgbdrift0drho_out, dgbdriftdrho_out, dgds2dr_out, dgds21dr_out, dgds22dr_out, djacdrho_out) Uses splines file_utils constants Arguments Type Intent Optional Attributes Name integer, intent(in) :: nzed integer, intent(in) :: nzgrid real, intent(in), dimension(-nzgrid:) :: zed_in logical, intent(in) :: zed_equal_arc real, intent(out) :: dpsidrho_out real, intent(out) :: dpsidrho_psi0_out real, intent(out) :: dIdrho_out real, intent(out), dimension(-nzgrid:) :: grho_out real, intent(out), dimension(-nzgrid:) :: bmag_out real, intent(out), dimension(-nzgrid:) :: bmag_psi0_out real, intent(out), dimension(-nzgrid:) :: gds2_out real, intent(out), dimension(-nzgrid:) :: gds21_out real, intent(out), dimension(-nzgrid:) :: gds22_out real, intent(out), dimension(-nzgrid:) :: gds23_out real, intent(out), dimension(-nzgrid:) :: gds24_out real, intent(out), dimension(-nzgrid:) :: gradpar_out real, intent(out), dimension(-nzgrid:) :: gbdrift0_out real, intent(out), dimension(-nzgrid:) :: gbdrift_out real, intent(out), dimension(-nzgrid:) :: cvdrift0_out real, intent(out), dimension(-nzgrid:) :: cvdrift_out real, intent(out), dimension(-nzgrid:) :: dBdrho_out real, intent(out), dimension(-nzgrid:) :: d2Bdrdth_out real, intent(out), dimension(-nzgrid:) :: dgradpardrho_out real, intent(out), dimension(-nzgrid:) :: btor_out real, intent(out), dimension(-nzgrid:) :: rmajor_out real, intent(out), dimension(-nzgrid:) :: dcvdrift0drho_out real, intent(out), dimension(-nzgrid:) :: dcvdriftdrho_out real, intent(out), dimension(-nzgrid:) :: dgbdrift0drho_out real, intent(out), dimension(-nzgrid:) :: dgbdriftdrho_out real, intent(out), dimension(-nzgrid:) :: dgds2dr_out real, intent(out), dimension(-nzgrid:) :: dgds21dr_out real, intent(out), dimension(-nzgrid:) :: dgds22dr_out real, intent(out), dimension(-nzgrid:) :: djacdrho_out","tags":"","loc":"proc/get_local_geo.html"},{"title":"allocate_arrays – stella","text":"private  subroutine allocate_arrays(nr, nz) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nr integer, intent(in) :: nz","tags":"","loc":"proc/allocate_arrays~7.html"},{"title":"deallocate_arrays – stella","text":"private  subroutine deallocate_arrays() Arguments None","tags":"","loc":"proc/deallocate_arrays~4.html"},{"title":"finish_local_geo – stella","text":"public  subroutine finish_local_geo() Arguments None","tags":"","loc":"proc/finish_local_geo.html"},{"title":"get_drho – stella","text":"private  subroutine get_drho(f, df) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, -nz:) :: f real, intent(out), dimension(-nz:) :: df","tags":"","loc":"proc/get_drho.html"},{"title":"get_d2dthet2 – stella","text":"private  subroutine get_d2dthet2(f, d2f) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nz:) :: f real, intent(out), dimension(-nz:) :: d2f","tags":"","loc":"proc/get_d2dthet2.html"},{"title":"get_dthet – stella","text":"private  subroutine get_dthet(f, df) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nz:) :: f real, intent(out), dimension(-nz:) :: df","tags":"","loc":"proc/get_dthet.html"},{"title":"get_jacrho – stella","text":"private  subroutine get_jacrho() Arguments None","tags":"","loc":"proc/get_jacrho.html"},{"title":"get_gradrho – stella","text":"private  subroutine get_gradrho(dpsidrho, grho) Arguments Type Intent Optional Attributes Name real, intent(in) :: dpsidrho real, intent(out), dimension(-nz:) :: grho","tags":"","loc":"proc/get_gradrho.html"},{"title":"get_dIdrho – stella","text":"private  subroutine get_dIdrho(dpsidrho, grho, dIdrho) Uses constants Arguments Type Intent Optional Attributes Name real, intent(in) :: dpsidrho real, intent(in), dimension(-nz:) :: grho real, intent(out) :: dIdrho","tags":"","loc":"proc/get_didrho.html"},{"title":"get_djacdrho – stella","text":"private  subroutine get_djacdrho(dpsidrho, dIdrho, grho) Arguments Type Intent Optional Attributes Name real, intent(in) :: dpsidrho real, intent(in) :: dIdrho real, intent(in), dimension(-nz:) :: grho","tags":"","loc":"proc/get_djacdrho.html"},{"title":"get_d2RZdr2 – stella","text":"private  subroutine get_d2RZdr2() Arguments None","tags":"","loc":"proc/get_d2rzdr2.html"},{"title":"get_dgr2dr – stella","text":"private  subroutine get_dgr2dr(dpsidrho, grho) Arguments Type Intent Optional Attributes Name real, intent(in) :: dpsidrho real, intent(in), dimension(-nz:) :: grho","tags":"","loc":"proc/get_dgr2dr.html"},{"title":"get_graddotgrad – stella","text":"private  subroutine get_graddotgrad(dpsidrho, grho) Arguments Type Intent Optional Attributes Name real, intent(in) :: dpsidrho real, intent(in), dimension(-nz:) :: grho","tags":"","loc":"proc/get_graddotgrad.html"},{"title":"get_gds – stella","text":"private  subroutine get_gds(gds2, gds21, gds22, gds23, gds24) Arguments Type Intent Optional Attributes Name real, intent(out), dimension(-nz:) :: gds2 real, intent(out), dimension(-nz:) :: gds21 real, intent(out), dimension(-nz:) :: gds22 real, intent(out), dimension(-nz:) :: gds23 real, intent(out), dimension(-nz:) :: gds24","tags":"","loc":"proc/get_gds.html"},{"title":"get_dBdrho – stella","text":"private  subroutine get_dBdrho(bmag, dIdrho) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nz:) :: bmag real, intent(in) :: dIdrho","tags":"","loc":"proc/get_dbdrho.html"},{"title":"get_varthet – stella","text":"private  subroutine get_varthet(dpsidrho) Arguments Type Intent Optional Attributes Name real, intent(in) :: dpsidrho","tags":"","loc":"proc/get_varthet.html"},{"title":"get_dvarthdr – stella","text":"private  subroutine get_dvarthdr(dpsidrho, dIdrho) Arguments Type Intent Optional Attributes Name real, intent(in) :: dpsidrho real, intent(in) :: dIdrho","tags":"","loc":"proc/get_dvarthdr.html"},{"title":"get_d2Idr2_d2jacdr2 – stella","text":"private  subroutine get_d2Idr2_d2jacdr2(grho, dIdrho) Uses constants Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nz:) :: grho real, intent(in) :: dIdrho","tags":"","loc":"proc/get_d2idr2_d2jacdr2.html"},{"title":"get_d2varthdr2 – stella","text":"private  subroutine get_d2varthdr2(dpsidrho, dIdrho) Arguments Type Intent Optional Attributes Name real, intent(in) :: dpsidrho real, intent(in) :: dIdrho","tags":"","loc":"proc/get_d2varthdr2.html"},{"title":"get_d2Bdr2 – stella","text":"private  subroutine get_d2Bdr2(bmag, dIdrho) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nz:) :: bmag real, intent(in) :: dIdrho","tags":"","loc":"proc/get_d2bdr2.html"},{"title":"get_dcrossdr – stella","text":"private  subroutine get_dcrossdr(dpsidrho, dIdrho, grho) Arguments Type Intent Optional Attributes Name real, intent(in) :: dpsidrho real, intent(in) :: dIdrho real, intent(in), dimension(-nz:) :: grho","tags":"","loc":"proc/get_dcrossdr.html"},{"title":"theta_integrate – stella","text":"private  subroutine theta_integrate(integrand, integral) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nz2pi:) :: integrand real, intent(out) :: integral","tags":"","loc":"proc/theta_integrate.html"},{"title":"theta_integrate_indef – stella","text":"private  subroutine theta_integrate_indef(integrand, integral) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nz:) :: integrand real, intent(out), dimension(-nz:) :: integral","tags":"","loc":"proc/theta_integrate_indef.html"},{"title":"init_volume_averages – stella","text":"public  subroutine init_volume_averages() Uses kt_grids physics_flags zgrid stella_geometry Arguments None","tags":"","loc":"proc/init_volume_averages.html"},{"title":"finish_volume_averages – stella","text":"public  subroutine finish_volume_averages() Uses physics_flags stella_geometry Arguments None","tags":"","loc":"proc/finish_volume_averages.html"},{"title":"fieldline_average_real – stella","text":"private  subroutine fieldline_average_real(unavg, avg) Uses kt_grids zgrid stella_geometry Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :, -nzgrid:, :) :: unavg real, intent(out), dimension(:, :) :: avg","tags":"","loc":"proc/fieldline_average_real.html"},{"title":"fieldline_average_complex – stella","text":"private  subroutine fieldline_average_complex(unavg, avg) Uses kt_grids zgrid stella_geometry Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: unavg complex, intent(out), dimension(:, :) :: avg","tags":"","loc":"proc/fieldline_average_complex.html"},{"title":"volume_average – stella","text":"public  subroutine volume_average(unavg, avg) Uses kt_grids zgrid stella_geometry Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: unavg real, intent(out) :: avg","tags":"","loc":"proc/volume_average.html"},{"title":"init_flux_surface_average_ffs – stella","text":"private  subroutine init_flux_surface_average_ffs() Uses kt_grids zgrid stella_geometry stella_transforms calculate the Fourier coefficients in y of the Jacobian\nthis is needed in the computation of the flux surface average of phi Arguments None","tags":"","loc":"proc/init_flux_surface_average_ffs.html"},{"title":"flux_surface_average_ffs – stella","text":"public  subroutine flux_surface_average_ffs(no_fsa, fsa) Uses kt_grids zgrid stella_geometry Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, -nzgrid:) :: no_fsa complex, intent(out) :: fsa","tags":"","loc":"proc/flux_surface_average_ffs.html"},{"title":"fieldline_average – stella","text":"public interface fieldline_average Module Procedures private  subroutine fieldline_average_real (unavg, avg) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :, -nzgrid:, :) :: unavg real, intent(out), dimension(:, :) :: avg private  subroutine fieldline_average_complex (unavg, avg) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: unavg complex, intent(out), dimension(:, :) :: avg","tags":"","loc":"interface/fieldline_average.html"},{"title":"timer_local – stella","text":"public  function timer_local() Uses mpi Arguments None Return Value real","tags":"","loc":"proc/timer_local.html"},{"title":"time_message – stella","text":"public  subroutine time_message(lprint, targ, chmessage) Arguments Type Intent Optional Attributes Name logical, intent(in) :: lprint real, intent(inout) :: targ (2) character(len=*), intent(in) :: chmessage","tags":"","loc":"proc/time_message.html"},{"title":"job_fork – stella","text":"public  subroutine job_fork(n_ensembles) Uses file_utils mp Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: n_ensembles","tags":"","loc":"proc/job_fork.html"},{"title":"checkstop – stella","text":"public  subroutine checkstop(exit, list) Uses file_utils mp Arguments Type Intent Optional Attributes Name logical, intent(inout) :: exit logical, intent(in), optional :: list","tags":"","loc":"proc/checkstop.html"},{"title":"checktime – stella","text":"public  subroutine checktime(avail_time, exit) Uses file_utils mp Arguments Type Intent Optional Attributes Name real, intent(in) :: avail_time logical, intent(inout) :: exit","tags":"","loc":"proc/checktime.html"},{"title":"init_flow_shear – stella","text":"public  subroutine init_flow_shear() Uses physics_parameters zgrid job_manage mp species stella_layouts physics_flags file_utils constants fields_arrays kt_grids vpamu_grids stella_time stella_geometry run_parameters Arguments None","tags":"","loc":"proc/init_flow_shear.html"},{"title":"advance_parallel_flow_shear – stella","text":"public  subroutine advance_parallel_flow_shear(gout) Uses mp zgrid physics_flags stella_layouts fields fields_arrays kt_grids Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout","tags":"","loc":"proc/advance_parallel_flow_shear.html"},{"title":"advance_perp_flow_shear – stella","text":"public  subroutine advance_perp_flow_shear(g) Uses zgrid physics_flags stella_layouts file_utils constants fields_arrays kt_grids stella_time stella_transforms Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g","tags":"","loc":"proc/advance_perp_flow_shear.html"},{"title":"finish_flow_shear – stella","text":"public  subroutine finish_flow_shear() Uses fields_arrays Arguments None","tags":"","loc":"proc/finish_flow_shear.html"},{"title":"get_neo_from_sfincs – stella","text":"public  subroutine get_neo_from_sfincs(nradii, drho, f_neoclassical, phi_neoclassical, dfneo_dalpha, dphineo_dalpha) Uses mp zgrid Arguments Type Intent Optional Attributes Name integer, intent(in) :: nradii real, intent(in) :: drho real, intent(out), dimension(:, -nzgrid:, :, :, :, -nradii/2:) :: f_neoclassical real, intent(out), dimension(:, -nzgrid:, -nradii/2:) :: phi_neoclassical real, intent(out), dimension(:, -nzgrid:, :, :, :) :: dfneo_dalpha real, intent(out), dimension(:, -nzgrid:) :: dphineo_dalpha","tags":"","loc":"proc/get_neo_from_sfincs.html"},{"title":"ezcdf_open – stella","text":"public  subroutine ezcdf_open(ncid, filename, opt, ier) Arguments Type Intent Optional Attributes Name integer, intent(out) :: ncid character(len=*), intent(in) :: filename character(len=1), intent(in) :: opt integer, intent(out), optional :: ier","tags":"","loc":"proc/ezcdf_open.html"},{"title":"ezcdf_close – stella","text":"public  subroutine ezcdf_close(ncid, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(out), optional :: ier","tags":"","loc":"proc/ezcdf_close.html"},{"title":"cdfOpn – stella","text":"public interface cdfOpn Module Procedures public  subroutine ezcdf_open (ncid, filename, opt, ier) Arguments Type Intent Optional Attributes Name integer, intent(out) :: ncid character(len=*), intent(in) :: filename character(len=1), intent(in) :: opt integer, intent(out), optional :: ier","tags":"","loc":"interface/cdfopn.html"},{"title":"cdf_open – stella","text":"public interface cdf_open Module Procedures public  subroutine ezcdf_open (ncid, filename, opt, ier) Arguments Type Intent Optional Attributes Name integer, intent(out) :: ncid character(len=*), intent(in) :: filename character(len=1), intent(in) :: opt integer, intent(out), optional :: ier","tags":"","loc":"interface/cdf_open.html"},{"title":"cdfCls – stella","text":"public interface cdfCls Module Procedures public  subroutine ezcdf_close (ncid, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(out), optional :: ier","tags":"","loc":"interface/cdfcls.html"},{"title":"cdf_close – stella","text":"public interface cdf_close Module Procedures public  subroutine ezcdf_close (ncid, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(out), optional :: ier","tags":"","loc":"interface/cdf_close.html"},{"title":"init_bessel – stella","text":"public  subroutine init_bessel() Uses zgrid dist_fn_arrays species physics_flags stella_layouts spfunc kt_grids vpamu_grids stella_geometry Arguments None","tags":"","loc":"proc/init_bessel.html"},{"title":"init_bessel_ffs – stella","text":"private  subroutine init_bessel_ffs() Uses mp zgrid dist_fn_arrays species stella_layouts stella_geometry spfunc kt_grids vpamu_grids stella_transforms aj0_alpha will contain J_0 as a function of k_alpha and alpha\nj0_B_maxwell will contain J_0 B exp(-v&#94;2) as a function of k_alpha and alpha\nfor each value of alpha, take kperp&#94;2 calculated on domain kx = [-kx_max, kx_max] and ky = [0, ky_max]\nand use symmetry to obtain kperp&#94;2 on domain kx = [0, kx_max] and ky = [-ky_max, ky_max]\nthis makes later convolutions involving sums over all ky more straightforward\ncalculate the argument of the Bessel function, which depends on both alpha and k_alpha compute J_0 B exp(-v&#94;2), needed when integrating g over v-space in Maxwell's equations,\ndue to B in v-space Jacobian and Maxwellian factor hidden in normalisation of g\nfourier transform aj0_alpha and j0_B_maxwell.\nnote that fourier coefficients aj0_kalpha and j0_B_maxwell_kalpha have\nbeen filtered to avoid aliasing\ngiven the Fourier coefficients aj0_kalpha, calculate the minimum number of coefficients needed,\ncalled j0_ffs%max_idx, to ensure that the relative error in the total spectral energy is below a specified tolerance\ngiven the Fourier coefficients j0_B_maxwell_kalpha, calculate the minimum number of coefficients needed,\ncalled j0_B_maxwell_ffs%max_idx, to ensure that the relative error in the total spectral energy is below a specified tolerance\nkeep track of the total number of coefficients that must be retained across different phase space points\nkeep track of the total number of coefficients that must be retained across different phase space points\nallocate array to hold the reduced number of Fourier coefficients\nfill the array with the requisite coefficients fill the array with the requisite coefficients calculate the reduction factor of Fourier modes\nused to represent J0\navoid overflow by converting integers to reals before multiplying Arguments None","tags":"","loc":"proc/init_bessel_ffs.html"},{"title":"find_max_required_kalpha_index – stella","text":"private  subroutine find_max_required_kalpha_index(ft, idx, imu, iz, is) Uses vpamu_grids subroutine takes a set of Fourier coefficients (ft)\nand returns the minimum number of coeffients that must be retained (idx)\nto ensure that the relative error in the total spectral energy is\nbelow a specified tolerance (tol_floor) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: ft integer, intent(out) :: idx integer, intent(in), optional :: imu integer, intent(in), optional :: iz integer, intent(in), optional :: is","tags":"","loc":"proc/find_max_required_kalpha_index.html"},{"title":"finish_bessel – stella","text":"public  subroutine finish_bessel() Arguments None","tags":"","loc":"proc/finish_bessel.html"},{"title":"gyro_average_local – stella","text":"private  subroutine gyro_average_local(field, iky, ikx, iz, ivmu, gyro_field) gyro_average_local takes a field at a given ky, kx, z and (vpa, mu, s) value\nand returns the gyro-average of that field; Arguments Type Intent Optional Attributes Name complex, intent(in) :: field integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: ivmu complex, intent(out) :: gyro_field","tags":"","loc":"proc/gyro_average_local.html"},{"title":"gyro_average_kxky_local – stella","text":"private  subroutine gyro_average_kxky_local(field, iz, ivmu, gyro_field) Uses physics_flags if simulating a full flux surface, the alpha dependence present\nin kperp makes gyro-averaging non-local in k-space\nif simulating a flux tube, a gyro-average is local in k-space Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: field integer, intent(in) :: iz integer, intent(in) :: ivmu complex, intent(out), dimension(:, :) :: gyro_field","tags":"","loc":"proc/gyro_average_kxky_local.html"},{"title":"gyro_average_kxkyz_local – stella","text":"private  subroutine gyro_average_kxkyz_local(field, ivmu, gyro_field) Uses physics_flags zgrid if simulating a full flux surface, the alpha dependence present\nin kperp makes gyro-averaging non-local in k-space\nif simulating a flux tube, a gyro-average is local in k-space Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: field integer, intent(in) :: ivmu complex, intent(out), dimension(:, :, -nzgrid:, :) :: gyro_field","tags":"","loc":"proc/gyro_average_kxkyz_local.html"},{"title":"gyro_average_kxkyzv_local – stella","text":"private  subroutine gyro_average_kxkyzv_local(field, gyro_field) Uses stella_layouts physics_flags zgrid if simulating a full flux surface, the alpha dependence present\nin kperp makes gyro-averaging non-local in k-space\nif simulating a flux tube, a gyro-average is local in k-space Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: field complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gyro_field","tags":"","loc":"proc/gyro_average_kxkyzv_local.html"},{"title":"gyro_average_ffs_kxky_local – stella","text":"private  subroutine gyro_average_ffs_kxky_local(field, gyro_field, coefs) Uses kt_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: field complex, intent(out), dimension(:, :) :: gyro_field type( coupled_alpha_type ), intent(in), dimension(:, :) :: coefs","tags":"","loc":"proc/gyro_average_ffs_kxky_local.html"},{"title":"gyro_average_ffs_kxkyz_local – stella","text":"private  subroutine gyro_average_ffs_kxkyz_local(field, gyro_field, coefs) Uses zgrid Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: field complex, intent(out), dimension(:, :, -nzgrid:, :) :: gyro_field type( coupled_alpha_type ), intent(in), dimension(:, :, -nzgrid:) :: coefs","tags":"","loc":"proc/gyro_average_ffs_kxkyz_local.html"},{"title":"gyro_average_ffs – stella","text":"private  subroutine gyro_average_ffs(dist, gyro_dist, coefs) Uses stella_layouts common_types zgrid Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dist complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gyro_dist type( coupled_alpha_type ), intent(in), dimension(:, :, -nzgrid:, vmu_lo%llim_proc:) :: coefs","tags":"","loc":"proc/gyro_average_ffs.html"},{"title":"gyro_average_v_local – stella","text":"private  subroutine gyro_average_v_local(distfn, imu, ikxkyz, gyro_distfn) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: distfn integer, intent(in) :: imu integer, intent(in) :: ikxkyz complex, intent(out), dimension(:) :: gyro_distfn","tags":"","loc":"proc/gyro_average_v_local.html"},{"title":"gyro_average_vmu_local – stella","text":"private  subroutine gyro_average_vmu_local(distfn, ikxkyz, gyro_distfn) Uses vpamu_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: distfn integer, intent(in) :: ikxkyz complex, intent(out), dimension(:, :) :: gyro_distfn","tags":"","loc":"proc/gyro_average_vmu_local.html"},{"title":"gyro_average_vmus_nonlocal – stella","text":"private  subroutine gyro_average_vmus_nonlocal(field, iky, ikx, iz, gyro_field) Uses stella_layouts Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(vmu_lo%llim_proc:) :: field integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz complex, intent(out), dimension(vmu_lo%llim_proc:) :: gyro_field","tags":"","loc":"proc/gyro_average_vmus_nonlocal.html"},{"title":"gyro_average_j1_vmus_nonlocal – stella","text":"private  subroutine gyro_average_j1_vmus_nonlocal(field, iky, ikx, iz, gyro_field) Uses stella_layouts Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(vmu_lo%llim_proc:) :: field integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz complex, intent(out), dimension(vmu_lo%llim_proc:) :: gyro_field","tags":"","loc":"proc/gyro_average_j1_vmus_nonlocal.html"},{"title":"gyro_average_j1_local – stella","text":"private  subroutine gyro_average_j1_local(field, iky, ikx, iz, ivmu, gyro_field) Arguments Type Intent Optional Attributes Name complex, intent(in) :: field integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: ivmu complex, intent(out) :: gyro_field","tags":"","loc":"proc/gyro_average_j1_local.html"},{"title":"gyro_average_j1_kxky_local – stella","text":"private  subroutine gyro_average_j1_kxky_local(field, iz, ivmu, gyro_field) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: field integer, intent(in) :: iz integer, intent(in) :: ivmu complex, intent(out), dimension(:, :) :: gyro_field","tags":"","loc":"proc/gyro_average_j1_kxky_local.html"},{"title":"gyro_average_j1_kxkyz_local – stella","text":"private  subroutine gyro_average_j1_kxkyz_local(field, ivmu, gyro_field) Uses zgrid Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: field integer, intent(in) :: ivmu complex, intent(out), dimension(:, :, -nzgrid:, :) :: gyro_field","tags":"","loc":"proc/gyro_average_j1_kxkyz_local.html"},{"title":"gyro_average_j1_vmu_local – stella","text":"private  subroutine gyro_average_j1_vmu_local(distfn, ikxkyz, gyro_distfn) Uses vpamu_grids Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: distfn integer, intent(in) :: ikxkyz complex, intent(out), dimension(:, :) :: gyro_distfn","tags":"","loc":"proc/gyro_average_j1_vmu_local.html"},{"title":"gyro_average_j1_v_local – stella","text":"private  subroutine gyro_average_j1_v_local(distfn, imu, ikxkyz, gyro_distfn) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: distfn integer, intent(in) :: imu integer, intent(in) :: ikxkyz complex, intent(out), dimension(:) :: gyro_distfn","tags":"","loc":"proc/gyro_average_j1_v_local.html"},{"title":"gyro_average_j1_kxkyzv_local – stella","text":"private  subroutine gyro_average_j1_kxkyzv_local(field, gyro_field) Uses stella_layouts mp physics_flags zgrid if simulating a full flux surface, the alpha dependence present\nin kperp makes gyro-averaging non-local in k-space\nif simulating a flux tube, a gyro-average is local in k-space Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: field complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gyro_field","tags":"","loc":"proc/gyro_average_j1_kxkyzv_local.html"},{"title":"band_lu_solve_ffs – stella","text":"public  subroutine band_lu_solve_ffs(lu, solvec) Uses kt_grids zgrid common_types Arguments Type Intent Optional Attributes Name type( gam0_ffs_type ), intent(in), dimension(:, -nzgrid:) :: lu complex, intent(inout), dimension(:, :, -nzgrid:) :: solvec","tags":"","loc":"proc/band_lu_solve_ffs.html"},{"title":"band_lu_solve_ffs_single – stella","text":"private  subroutine band_lu_solve_ffs_single(lu, solvec) Uses kt_grids common_types Arguments Type Intent Optional Attributes Name type( gam0_ffs_type ), intent(in) :: lu complex, intent(inout), dimension(:) :: solvec","tags":"","loc":"proc/band_lu_solve_ffs_single.html"},{"title":"band_lu_factorisation_ffs – stella","text":"public  subroutine band_lu_factorisation_ffs(gam0, lu_gam0) Uses kt_grids zgrid common_types Arguments Type Intent Optional Attributes Name type( coupled_alpha_type ), intent(in), dimension(:, :, -nzgrid:) :: gam0 type( gam0_ffs_type ), intent(out), dimension(:, -nzgrid:) :: lu_gam0","tags":"","loc":"proc/band_lu_factorisation_ffs.html"},{"title":"band_lu_factorisation_single – stella","text":"private  subroutine band_lu_factorisation_single(gam0, lu_gam0) Uses kt_grids common_types Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gam0 type( gam0_ffs_type ), intent(out) :: lu_gam0","tags":"","loc":"proc/band_lu_factorisation_single.html"},{"title":"gyro_average – stella","text":"public interface gyro_average Module Procedures private  subroutine gyro_average_local (field, iky, ikx, iz, ivmu, gyro_field) gyro_average_local takes a field at a given ky, kx, z and (vpa, mu, s) value\nand returns the gyro-average of that field; Arguments Type Intent Optional Attributes Name complex, intent(in) :: field integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: ivmu complex, intent(out) :: gyro_field private  subroutine gyro_average_kxky_local (field, iz, ivmu, gyro_field) if simulating a full flux surface, the alpha dependence present\nin kperp makes gyro-averaging non-local in k-space\nif simulating a flux tube, a gyro-average is local in k-space Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: field integer, intent(in) :: iz integer, intent(in) :: ivmu complex, intent(out), dimension(:, :) :: gyro_field private  subroutine gyro_average_kxkyz_local (field, ivmu, gyro_field) if simulating a full flux surface, the alpha dependence present\nin kperp makes gyro-averaging non-local in k-space\nif simulating a flux tube, a gyro-average is local in k-space Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: field integer, intent(in) :: ivmu complex, intent(out), dimension(:, :, -nzgrid:, :) :: gyro_field private  subroutine gyro_average_kxkyzv_local (field, gyro_field) if simulating a full flux surface, the alpha dependence present\nin kperp makes gyro-averaging non-local in k-space\nif simulating a flux tube, a gyro-average is local in k-space Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: field complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gyro_field private  subroutine gyro_average_v_local (distfn, imu, ikxkyz, gyro_distfn) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: distfn integer, intent(in) :: imu integer, intent(in) :: ikxkyz complex, intent(out), dimension(:) :: gyro_distfn private  subroutine gyro_average_vmu_local (distfn, ikxkyz, gyro_distfn) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: distfn integer, intent(in) :: ikxkyz complex, intent(out), dimension(:, :) :: gyro_distfn private  subroutine gyro_average_vmus_nonlocal (field, iky, ikx, iz, gyro_field) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(vmu_lo%llim_proc:) :: field integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz complex, intent(out), dimension(vmu_lo%llim_proc:) :: gyro_field private  subroutine gyro_average_ffs_kxky_local (field, gyro_field, coefs) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: field complex, intent(out), dimension(:, :) :: gyro_field type( coupled_alpha_type ), intent(in), dimension(:, :) :: coefs private  subroutine gyro_average_ffs_kxkyz_local (field, gyro_field, coefs) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: field complex, intent(out), dimension(:, :, -nzgrid:, :) :: gyro_field type( coupled_alpha_type ), intent(in), dimension(:, :, -nzgrid:) :: coefs private  subroutine gyro_average_ffs (dist, gyro_dist, coefs) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dist complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gyro_dist type( coupled_alpha_type ), intent(in), dimension(:, :, -nzgrid:, vmu_lo%llim_proc:) :: coefs","tags":"","loc":"interface/gyro_average.html"},{"title":"gyro_average_j1 – stella","text":"public interface gyro_average_j1 Module Procedures private  subroutine gyro_average_j1_vmus_nonlocal (field, iky, ikx, iz, gyro_field) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(vmu_lo%llim_proc:) :: field integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz complex, intent(out), dimension(vmu_lo%llim_proc:) :: gyro_field private  subroutine gyro_average_j1_local (field, iky, ikx, iz, ivmu, gyro_field) Arguments Type Intent Optional Attributes Name complex, intent(in) :: field integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: ivmu complex, intent(out) :: gyro_field private  subroutine gyro_average_j1_kxky_local (field, iz, ivmu, gyro_field) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: field integer, intent(in) :: iz integer, intent(in) :: ivmu complex, intent(out), dimension(:, :) :: gyro_field private  subroutine gyro_average_j1_kxkyz_local (field, ivmu, gyro_field) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: field integer, intent(in) :: ivmu complex, intent(out), dimension(:, :, -nzgrid:, :) :: gyro_field private  subroutine gyro_average_j1_v_local (distfn, imu, ikxkyz, gyro_distfn) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: distfn integer, intent(in) :: imu integer, intent(in) :: ikxkyz complex, intent(out), dimension(:) :: gyro_distfn private  subroutine gyro_average_j1_vmu_local (distfn, ikxkyz, gyro_distfn) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: distfn integer, intent(in) :: ikxkyz complex, intent(out), dimension(:, :) :: gyro_distfn private  subroutine gyro_average_j1_kxkyzv_local (field, gyro_field) if simulating a full flux surface, the alpha dependence present\nin kperp makes gyro-averaging non-local in k-space\nif simulating a flux tube, a gyro-average is local in k-space Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: field complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gyro_field","tags":"","loc":"interface/gyro_average_j1.html"},{"title":"input_unit – stella","text":"public  function input_unit(nml) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: nml Return Value integer","tags":"","loc":"proc/input_unit.html"},{"title":"input_unit_exist – stella","text":"public  function input_unit_exist(nml, exist) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: nml logical, intent(out) :: exist Return Value integer","tags":"","loc":"proc/input_unit_exist.html"},{"title":"error_unit – stella","text":"public  function error_unit() Arguments None Return Value integer","tags":"","loc":"proc/error_unit.html"},{"title":"init_file_utils – stella","text":"public  subroutine init_file_utils(list, input, error, trin_run, name, n_ensembles) Arguments Type Intent Optional Attributes Name logical, intent(out) :: list logical, intent(in), optional :: input logical, intent(in), optional :: error logical, intent(in), optional :: trin_run character(len=*), intent(in), optional :: name integer, intent(in), optional :: n_ensembles","tags":"","loc":"proc/init_file_utils.html"},{"title":"run_type – stella","text":"private  subroutine run_type(list) Uses command_line Arguments Type Intent Optional Attributes Name logical, intent(out) :: list","tags":"","loc":"proc/run_type.html"},{"title":"init_run_name – stella","text":"private  subroutine init_run_name() Arguments None","tags":"","loc":"proc/init_run_name.html"},{"title":"init_job_name – stella","text":"public  subroutine init_job_name(jobname) Arguments Type Intent Optional Attributes Name character(len=500), intent(in) :: jobname","tags":"","loc":"proc/init_job_name.html"},{"title":"get_unused_unit – stella","text":"public  subroutine get_unused_unit(unit) Arguments Type Intent Optional Attributes Name integer, intent(out) :: unit","tags":"","loc":"proc/get_unused_unit.html"},{"title":"open_output_file – stella","text":"public  subroutine open_output_file(unit, ext, overwrite_in) Arguments Type Intent Optional Attributes Name integer, intent(out) :: unit character(len=*), intent(in) :: ext logical, intent(in), optional :: overwrite_in","tags":"","loc":"proc/open_output_file.html"},{"title":"close_output_file – stella","text":"public  subroutine close_output_file(unit) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit","tags":"","loc":"proc/close_output_file.html"},{"title":"flush_output_file – stella","text":"public  subroutine flush_output_file(unit) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit","tags":"","loc":"proc/flush_output_file.html"},{"title":"init_error_unit – stella","text":"public  subroutine init_error_unit(open_it) Arguments Type Intent Optional Attributes Name logical, intent(in) :: open_it","tags":"","loc":"proc/init_error_unit.html"},{"title":"strip_comments – stella","text":"private  subroutine strip_comments(line) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: line","tags":"","loc":"proc/strip_comments.html"},{"title":"init_input_unit – stella","text":"public  subroutine init_input_unit(open_it) Arguments Type Intent Optional Attributes Name logical, intent(in) :: open_it","tags":"","loc":"proc/init_input_unit.html"},{"title":"finish_file_utils – stella","text":"public  subroutine finish_file_utils() Arguments None","tags":"","loc":"proc/finish_file_utils.html"},{"title":"get_input_unit – stella","text":"public  subroutine get_input_unit(unit) Arguments Type Intent Optional Attributes Name integer, intent(out) :: unit","tags":"","loc":"proc/get_input_unit.html"},{"title":"get_indexed_namelist_unit – stella","text":"public  subroutine get_indexed_namelist_unit(unit, nml, index_in) Arguments Type Intent Optional Attributes Name integer, intent(out) :: unit character(len=*), intent(in) :: nml integer, intent(in) :: index_in","tags":"","loc":"proc/get_indexed_namelist_unit.html"},{"title":"cl_iargc – stella","text":"public  function cl_iargc() Arguments None Return Value integer","tags":"","loc":"proc/cl_iargc.html"},{"title":"cl_getarg – stella","text":"public  subroutine cl_getarg(k, arg, len, ierr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: k character(len=*), intent(out) :: arg integer, intent(out) :: len integer, intent(out) :: ierr","tags":"","loc":"proc/cl_getarg.html"},{"title":"time_average – stella","text":"subroutine time_average(t, it, flx, flxavg) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: t integer, intent(in) :: it real, intent(in), dimension(:, :) :: flx real, intent(out), dimension(:) :: flxavg","tags":"","loc":"proc/time_average.html"},{"title":"init_init_g – stella","text":"public  subroutine init_init_g() Uses system_fortran stella_layouts mp stella_save Arguments None","tags":"","loc":"proc/init_init_g.html"},{"title":"ginit – stella","text":"public  subroutine ginit(restarted, istep0) Uses run_parameters stella_save if maxwwellian_normalization = .true., the pdf is normalized by F0 (which is not the case otherwise)\nunless reading in g from a restart file, normalise g by F0 for a full flux surface simulation Arguments Type Intent Optional Attributes Name logical, intent(out) :: restarted integer, intent(out) :: istep0","tags":"","loc":"proc/ginit.html"},{"title":"read_parameters – stella","text":"private  subroutine read_parameters() Uses file_utils stella_save text_options Arguments None Namelists Namelist init_g_knobs Variables Name Type Default Description ginit_option character(len=20) None width0 real None phiinit real None chop_side logical None restart_file character(len=300) None restart_dir character(len=150) None read_many logical .true. left logical None scale real None tstart real None zf_init real None den0 real None upar0 real None tpar0 real None tperp0 real None imfac real None refac real None den1 real None upar1 real None tpar1 real None tperp1 real None den2 real None upar2 real None tpar2 real None tperp2 real None kxmax real None kxmin real None scale_to_phiinit logical None oddparity logical None","tags":"","loc":"proc/read_parameters~11.html"},{"title":"ginit_default – stella","text":"private  subroutine ginit_default() Uses zgrid dist_fn_arrays species stella_layouts constants kt_grids vpamu_grids ran Arguments None","tags":"","loc":"proc/ginit_default.html"},{"title":"ginit_noise – stella","text":"private  subroutine ginit_noise() Uses mp zgrid dist_fn_arrays species stella_layouts file_utils physics_flags extended_zgrid kt_grids vpamu_grids stella_geometry ran Initialise the distribution function with random noise. This is the default Arguments None","tags":"","loc":"proc/ginit_noise.html"},{"title":"ginit_kpar – stella","text":"private  subroutine ginit_kpar() Uses zgrid dist_fn_arrays stella_layouts constants kt_grids vpamu_grids Arguments None","tags":"","loc":"proc/ginit_kpar.html"},{"title":"ginit_rh – stella","text":"private  subroutine ginit_rh() Uses dist_fn_arrays species stella_layouts kt_grids vpamu_grids Arguments None","tags":"","loc":"proc/ginit_rh.html"},{"title":"ginit_remap – stella","text":"private  subroutine ginit_remap() Uses species stella_layouts vpamu_grids dist_fn_arrays Arguments None","tags":"","loc":"proc/ginit_remap.html"},{"title":"ginit_restart_many – stella","text":"private  subroutine ginit_restart_many() Uses file_utils mp dist_fn_arrays stella_save Arguments None","tags":"","loc":"proc/ginit_restart_many.html"},{"title":"normalize_by_maxwellian – stella","text":"private  subroutine normalize_by_maxwellian() Uses vpamu_grids stella_layouts dist_fn_arrays gvmu is initialised with a Maxwellian weighting for flux tube simulations,\nwith the Maxwellian evaluated at ia = 1\nwe are undoing that weighting here, so also need to use ia = 1 Arguments None","tags":"","loc":"proc/normalize_by_maxwellian.html"},{"title":"reset_init – stella","text":"public  subroutine reset_init() Arguments None","tags":"","loc":"proc/reset_init.html"},{"title":"finish_init_g – stella","text":"public  subroutine finish_init_g() Uses stella_save Arguments None","tags":"","loc":"proc/finish_init_g.html"},{"title":"init_physics_parameters – stella","text":"public  subroutine init_physics_parameters() Arguments None","tags":"","loc":"proc/init_physics_parameters.html"},{"title":"read_parameters – stella","text":"private  subroutine read_parameters() Uses file_utils mp Arguments None Namelists Namelist parameters Variables Name Type Default Description beta real None zeff real None tite real None nine real None rhostar real None vnew_ref real None g_exb real None g_exbfac real None omprimfac real None irhostar real None","tags":"","loc":"proc/read_parameters~12.html"},{"title":"finish_physics_parameters – stella","text":"public  subroutine finish_physics_parameters() Arguments None","tags":"","loc":"proc/finish_physics_parameters.html"},{"title":"physics_flags – stella","text":"Variables Type Visibility Attributes Name Initial logical, public :: full_flux_surface logical, public :: radial_variation logical, public :: include_apar logical, public :: include_bpar logical, public :: include_parallel_nonlinearity logical, public :: include_parallel_streaming logical, public :: include_pressure_variation logical, public :: include_geometric_variation logical, public :: include_mirror logical, public :: nonlinear logical, public :: prp_shear_enabled logical, public :: hammett_flow_shear logical, public :: const_alpha_geo integer, public :: adiabatic_option_switch integer, private, parameter :: adiabatic_option_default = 1 integer, private, parameter :: adiabatic_option_zero = 2 integer, public, parameter :: adiabatic_option_fieldlineavg = 3 logical, private :: initialized = .false. Subroutines public  subroutine init_physics_flags () Arguments None private  subroutine read_parameters () Arguments None public  subroutine finish_physics_flags () Arguments None","tags":"","loc":"module/physics_flags.html"},{"title":"spfunc – stella","text":"Uses constants","tags":"","loc":"module/spfunc.html"},{"title":"fft_work – stella","text":"Uses constants Variables Type Visibility Attributes Name Initial integer, public, parameter :: FFTW_R2HC = 0 integer, public, parameter :: FFTW_HC2R = 1 integer, public, parameter :: FFTW_DHT = 2 integer, public, parameter :: FFTW_REDFT00 = 3 integer, public, parameter :: FFTW_REDFT01 = 4 integer, public, parameter :: FFTW_REDFT10 = 5 integer, public, parameter :: FFTW_REDFT11 = 6 integer, public, parameter :: FFTW_RODFT00 = 7 integer, public, parameter :: FFTW_RODFT01 = 8 integer, public, parameter :: FFTW_RODFT10 = 9 integer, public, parameter :: FFTW_RODFT11 = 10 integer, public, parameter :: FFTW_FORWARD = -1 integer, public, parameter :: FFTW_BACKWARD = +1 integer, public, parameter :: FFTW_MEASURE = 0 integer, public, parameter :: FFTW_DESTROY_INPUT = 1 integer, public, parameter :: FFTW_UNALIGNED = 2 integer, public, parameter :: FFTW_CONSERVE_MEMORY = 4 integer, public, parameter :: FFTW_EXHAUSTIVE = 8 integer, public, parameter :: FFTW_PRESERVE_INPUT = 16 integer, public, parameter :: FFTW_PATIENT = 32 integer, public, parameter :: FFTW_ESTIMATE = 64 integer, public, parameter :: FFTW_WISDOM_ONLY = 2097152 integer, public, parameter :: FFTW_ESTIMATE_PATIENT = 128 integer, public, parameter :: FFTW_BELIEVE_PCOST = 256 integer, public, parameter :: FFTW_NO_DFT_R2HC = 512 integer, public, parameter :: FFTW_NO_NONTHREADED = 1024 integer, public, parameter :: FFTW_NO_BUFFERING = 2048 integer, public, parameter :: FFTW_NO_INDIRECT_OP = 4096 integer, public, parameter :: FFTW_ALLOW_LARGE_GENERIC = 8192 integer, public, parameter :: FFTW_NO_RANK_SPLITS = 16384 integer, public, parameter :: FFTW_NO_VRANK_SPLITS = 32768 integer, public, parameter :: FFTW_NO_VRECURSE = 65536 integer, public, parameter :: FFTW_NO_SIMD = 131072 integer, public, parameter :: FFTW_NO_SLOW = 262144 integer, public, parameter :: FFTW_NO_FIXED_RADIX_LARGE_N = 524288 integer, public, parameter :: FFTW_ALLOW_PRUNING = 1048576 integer, public, parameter :: FFT_BACKWARD = FFTW_BACKWARD integer, public, parameter :: FFT_FORWARD = FFTW_FORWARD Derived Types type, public :: fft_type Components Type Visibility Attributes Name Initial integer, public :: n integer, public :: is integer, public :: type integer(kind=kind_id), public :: plan real, public :: scale Subroutines public  subroutine init_ccfftw (fft, is, n, data_in, data_out) Arguments Type Intent Optional Attributes Name type( fft_type ), intent(out) :: fft integer, intent(in) :: is integer, intent(in) :: n complex, intent(inout), dimension(:) :: data_in complex, intent(inout), dimension(:) :: data_out public  subroutine init_crfftw (fft, is, n, data_in, data_out) Arguments Type Intent Optional Attributes Name type( fft_type ), intent(out) :: fft integer, intent(in) :: is integer, intent(in) :: n complex, intent(inout), dimension(:) :: data_in real, intent(inout), dimension(:) :: data_out public  subroutine init_rcfftw (fft, is, n, data_in, data_out) Arguments Type Intent Optional Attributes Name type( fft_type ), intent(out) :: fft integer, intent(in) :: is integer, intent(in) :: n real, intent(inout), dimension(:) :: data_in complex, intent(inout), dimension(:) :: data_out public  subroutine delete_fft (fft) Arguments Type Intent Optional Attributes Name type( fft_type ), intent(inout) :: fft","tags":"","loc":"module/fft_work.html"},{"title":"extended_zgrid – stella","text":"Variables Type Visibility Attributes Name Initial integer, public :: nzed_segment these arrays needed to keep track of connections between different\n2pi segments integer, public, dimension(:), allocatable :: neigen integer, public, dimension(:), allocatable :: iz_low integer, public, dimension(:), allocatable :: iz_mid integer, public, dimension(:), allocatable :: iz_up integer, public, dimension(:, :), allocatable :: nsegments integer, public, dimension(:, :, :), allocatable :: ikxmod integer, private, dimension(:), allocatable :: it_left arrays indicate which flux tube index to connect to\non the left and on the right\nas a function of current flux tube index\npre-compute to avoid conditionals in loops integer, public, dimension(:), allocatable :: it_right arrays indicate which flux tube index to connect to\non the left and on the right\nas a function of current flux tube index\npre-compute to avoid conditionals in loops complex, public, dimension(:), allocatable :: phase_shift logical, public, dimension(:), allocatable :: periodic logical, private :: extended_zgrid_initialized = .false. Subroutines public  subroutine init_extended_zgrid () phase shift due to the twist-and-shift boundary condition\nUsually set to zero for standard local simulation, but can\nhave an effect for global simulations and simulations with low\nmagnetic shear that use periodic boundary conditions everywhere Read more… Arguments None public  subroutine fill_zed_ghost_zones (it, iseg, ie, iky, g, gleft, gright) Arguments Type Intent Optional Attributes Name integer, intent(in) :: it integer, intent(in) :: iseg integer, intent(in) :: ie integer, intent(in) :: iky complex, intent(in), dimension(:, :, -nzgrid:, :) :: g complex, intent(out), dimension(:) :: gleft complex, intent(out), dimension(:) :: gright public  subroutine fill_zext_ghost_zones (iky, pdf_ext, pdf_left, pdf_right) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky complex, intent(in), dimension(:) :: pdf_ext complex, intent(out) :: pdf_left complex, intent(out) :: pdf_right public  subroutine map_to_extended_zgrid (it, ie, iky, g, gext, ulim) Arguments Type Intent Optional Attributes Name integer, intent(in) :: it integer, intent(in) :: ie integer, intent(in) :: iky complex, intent(in), dimension(:, -nzgrid:, :) :: g complex, intent(out), dimension(:) :: gext integer, intent(out) :: ulim public  subroutine map_from_extended_zgrid (it, ie, iky, gext, g) Arguments Type Intent Optional Attributes Name integer, intent(in) :: it integer, intent(in) :: ie integer, intent(in) :: iky complex, intent(in), dimension(:) :: gext complex, intent(inout), dimension(:, -nzgrid:, :) :: g public  subroutine map_to_iz_ikx_from_izext (iky, ie, iz_from_izext, ikx_from_izext) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky integer, intent(in) :: ie integer, intent(out), dimension(:) :: iz_from_izext integer, intent(out), dimension(:) :: ikx_from_izext public  subroutine finish_extended_zgrid () Arguments None","tags":"","loc":"module/extended_zgrid.html"},{"title":"mp_lu_decomposition – stella","text":"","tags":"","loc":"module/mp_lu_decomposition.html"},{"title":"stella_time – stella","text":"Variables Type Visibility Attributes Name Initial real, public :: cfl_dt_linear = -1. real, public :: cfl_dt_ExB = -1. real, public :: cfl_dt_parallel = -1. real, public :: code_dt real, public :: code_dt_min real, public :: code_dt_max real, public :: code_dt_old = 0. real, public :: code_time = 0. Subroutines public  subroutine init_tstart (tstart) Arguments Type Intent Optional Attributes Name real, intent(in) :: tstart public  subroutine init_delt (delt, delt_max, delt_min) Arguments Type Intent Optional Attributes Name real, intent(in) :: delt real, intent(in) :: delt_max real, intent(in) :: delt_min public  subroutine update_time () Arguments None public  subroutine write_dt () Arguments None public  subroutine checkcodedt (stop_stella) Arguments Type Intent Optional Attributes Name logical, intent(inout) :: stop_stella","tags":"","loc":"module/stella_time.html"},{"title":"redistribute – stella","text":"Variables Type Visibility Attributes Name Initial integer, public :: gather_count = 0 integer, public :: scatter_count = 0 real, public, save :: time_redist (2) = 0. Interfaces public        interface gather private  subroutine c_redist_22 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine r_redist_22 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine i_redist_22 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here integer, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine l_redist_22 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here logical, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine c_redist_32 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine r_redist_32 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine i_redist_32 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here integer, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine l_redist_32 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here logical, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine c_redist_42 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine r_redist_42 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine i_redist_42 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: from_here integer, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine l_redist_42 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: from_here logical, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine c_redist_23 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):) :: to_here private  subroutine c_redist_34 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):) :: to_here private  subroutine r_redist_34 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):) :: to_here private  subroutine c_redist_33 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):) :: to_here private  subroutine c_redist_35 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):, r%to_low(5):) :: to_here private  subroutine r_redist_35 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):, r%to_low(5):) :: to_here public        interface scatter private  subroutine c_redist_12 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine r_redist_12 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine i_redist_12 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%from_low(1):) :: from_here integer, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine l_redist_12 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%from_low(1):) :: from_here logical, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine c_redist_22_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here private  subroutine r_redist_22_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here private  subroutine i_redist_22_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here integer, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here private  subroutine l_redist_22_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here logical, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here private  subroutine c_redist_32_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private  subroutine r_redist_32_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private  subroutine i_redist_32_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here integer, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private  subroutine l_redist_32_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here logical, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private  subroutine c_redist_42_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: to_here private  subroutine r_redist_42_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: to_here private  subroutine i_redist_42_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here integer, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: to_here private  subroutine l_redist_42_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here logical, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: to_here private  subroutine c_redist_33_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private  subroutine c_redist_34_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private  subroutine r_redist_34_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private  subroutine c_redist_35_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):, r%to_low(5):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private  subroutine r_redist_35_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):, r%to_low(5):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here public        interface measure_gather private  subroutine measure_gather_32 (map, gin, gout) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :, :) :: gin complex, intent(out), dimension(:, :) :: gout private  subroutine measure_gather_33 (map, gin, gout) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :, :) :: gin complex, intent(out), dimension(:, :, :) :: gout private  subroutine measure_gather_22 (map, gin, gout) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout public        interface measure_scatter private  subroutine measure_scatter_23 (map, gin, gout) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :, :) :: gout private  subroutine measure_scatter_33 (map, gin, gout) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :, :) :: gin complex, intent(out), dimension(:, :, :) :: gout private  subroutine measure_scatter_22 (map, gin, gout) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout public        interface fill private  subroutine c_fill_2 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f complex, intent(in), dimension(f%from_low(1):, f%from_low(2):) :: from_here complex, intent(inout), dimension(f%to_low(1):, f%to_low(2):) :: to_here private  subroutine c_fill_3 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f complex, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):) :: from_here complex, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):) :: to_here private  subroutine c_fill_4 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f complex, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):, f%from_low(4):) :: from_here complex, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):, f%to_low(4):) :: to_here private  subroutine r_fill_2 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f real, intent(in), dimension(f%from_low(1):, f%from_low(2):) :: from_here real, intent(inout), dimension(f%to_low(1):, f%to_low(2):) :: to_here private  subroutine r_fill_3 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f real, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):) :: from_here real, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):) :: to_here private  subroutine r_fill_4 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f real, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):, f%from_low(4):) :: from_here real, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):, f%to_low(4):) :: to_here private  subroutine i_fill_2 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f integer, intent(in), dimension(f%from_low(1):, f%from_low(2):) :: from_here integer, intent(inout), dimension(f%to_low(1):, f%to_low(2):) :: to_here private  subroutine i_fill_3 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f integer, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):) :: from_here integer, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):) :: to_here private  subroutine i_fill_4 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f integer, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):, f%from_low(4):) :: from_here integer, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):, f%to_low(4):) :: to_here private  subroutine l_fill_2 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f logical, intent(in), dimension(f%from_low(1):, f%from_low(2):) :: from_here logical, intent(inout), dimension(f%to_low(1):, f%to_low(2):) :: to_here private  subroutine l_fill_3 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f logical, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):) :: from_here logical, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):) :: to_here private  subroutine l_fill_4 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f logical, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):, f%from_low(4):) :: from_here logical, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):, f%to_low(4):) :: to_here Derived Types type, private :: index_map Components Type Visibility Attributes Name Initial integer, public :: nn integer, public, dimension(:), pointer :: k => null() integer, public, dimension(:), pointer :: l => null() integer, public, dimension(:), pointer :: m => null() integer, public, dimension(:), pointer :: n => null() integer, public, dimension(:), pointer :: o => null() type, public :: redist_type Components Type Visibility Attributes Name Initial integer, private, dimension(5) :: to_low integer, private, dimension(5) :: from_low integer, private, dimension(5) :: to_high integer, private, dimension(5) :: from_high type( index_map ), private, dimension(:), pointer :: to => null() type( index_map ), private, dimension(:), pointer :: from => null() complex, private, dimension(:), pointer :: complex_buff => null() real, private, dimension(:), pointer :: real_buff => null() integer, private, dimension(:), pointer :: integer_buff => null() logical, private, dimension(:), pointer :: logical_buff => null() character(len=3), private :: redistname = \"\" type, public :: index_list_type Components Type Visibility Attributes Name Initial integer, public, dimension(:), pointer :: first => null() integer, public, dimension(:), pointer :: second => null() integer, public, dimension(:), pointer :: third => null() integer, public, dimension(:), pointer :: fourth => null() integer, public, dimension(:), pointer :: fifth => null() Subroutines public  subroutine set_redist_character_type (r, chartype) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r character(len=3), intent(in) :: chartype public  subroutine init_redist (r, char, to_low, to_high, to_list, from_low, from_high, from_list, ierr) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r character(len=1), intent(in) :: char integer, intent(in), dimension(:) :: to_low integer, intent(in), dimension(:) :: to_high type( index_list_type ), intent(in), dimension(0:nproc - 1) :: to_list integer, intent(in), dimension(:) :: from_low integer, intent(in), dimension(:) :: from_high type( index_list_type ), intent(in), dimension(0:nproc - 1) :: from_list integer, intent(out), optional :: ierr public  subroutine init_fill (f, char, to_low, to_list, from_low, from_list, ierr) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(out) :: f character(len=1), intent(in) :: char integer, intent(in), dimension(:) :: to_low type( index_list_type ), intent(in), dimension(0:nproc - 1) :: to_list integer, intent(in), dimension(:) :: from_low type( index_list_type ), intent(in), dimension(0:nproc - 1) :: from_list integer, intent(out), optional :: ierr public  subroutine delete_redist (r) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r public  subroutine delete_list (list) Arguments Type Intent Optional Attributes Name type( index_list_type ), intent(inout), dimension(0:nproc - 1) :: list private  subroutine c_redist_12 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine c_redist_22 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine c_redist_22_old_copy (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine c_redist_22_mpi_copy (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine c_redist_22_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here private  subroutine c_redist_22_inv_old_copy (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here private  subroutine c_redist_22_inv_mpi_copy (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here private  subroutine c_redist_32 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine c_redist_32_old_copy (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine c_redist_32_mpi_copy (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine c_redist_32_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private  subroutine c_redist_32_inv_old_copy (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private  subroutine c_redist_32_inv_mpi_copy (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private  subroutine c_redist_42 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine c_redist_42_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: to_here private  subroutine c_redist_23 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):) :: to_here private  subroutine c_redist_34 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):) :: to_here private  subroutine c_redist_34_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private  subroutine r_redist_34 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):) :: to_here private  subroutine r_redist_34_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private  subroutine c_redist_35 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):, r%to_low(5):) :: to_here private  subroutine r_redist_35 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):, r%to_low(5):) :: to_here private  subroutine c_redist_35_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):, r%to_low(5):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private  subroutine r_redist_35_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):, r%to_low(4):, r%to_low(5):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private  subroutine r_redist_12 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine r_redist_22 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine r_redist_22_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here private  subroutine r_redist_32 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine r_redist_32_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private  subroutine r_redist_42 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: from_here real, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine r_redist_42_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r real, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here real, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: to_here private  subroutine i_redist_12 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%from_low(1):) :: from_here integer, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine i_redist_22 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here integer, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine i_redist_22_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here integer, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here private  subroutine i_redist_32 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here integer, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine i_redist_32_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here integer, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private  subroutine i_redist_42 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: from_here integer, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine i_redist_42_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r integer, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here integer, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: to_here private  subroutine l_redist_12 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%from_low(1):) :: from_here logical, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine l_redist_22 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%from_low(1):, r%from_low(2):) :: from_here logical, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine l_redist_22_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here logical, intent(inout), dimension(r%from_low(1):, r%from_low(2):) :: to_here private  subroutine l_redist_32 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here logical, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine l_redist_32_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here logical, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private  subroutine l_redist_42 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: from_here logical, intent(inout), dimension(r%to_low(1):, r%to_low(2):) :: to_here private  subroutine l_redist_42_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r logical, intent(in), dimension(r%to_low(1):, r%to_low(2):) :: from_here logical, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):, r%from_low(4):) :: to_here private  subroutine c_redist_33 (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: from_here complex, intent(inout), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):) :: to_here private  subroutine c_redist_33_inv (r, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: r complex, intent(in), dimension(r%to_low(1):, r%to_low(2):, r%to_low(3):) :: from_here complex, intent(inout), dimension(r%from_low(1):, r%from_low(2):, r%from_low(3):) :: to_here private  subroutine c_fill_2 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f complex, intent(in), dimension(f%from_low(1):, f%from_low(2):) :: from_here complex, intent(inout), dimension(f%to_low(1):, f%to_low(2):) :: to_here private  subroutine c_fill_3 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f complex, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):) :: from_here complex, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):) :: to_here private  subroutine c_fill_4 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f complex, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):, f%from_low(4):) :: from_here complex, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):, f%to_low(4):) :: to_here private  subroutine r_fill_2 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f real, intent(in), dimension(f%from_low(1):, f%from_low(2):) :: from_here real, intent(inout), dimension(f%to_low(1):, f%to_low(2):) :: to_here private  subroutine r_fill_3 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f real, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):) :: from_here real, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):) :: to_here private  subroutine r_fill_4 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f real, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):, f%from_low(4):) :: from_here real, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):, f%to_low(4):) :: to_here private  subroutine i_fill_2 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f integer, intent(in), dimension(f%from_low(1):, f%from_low(2):) :: from_here integer, intent(inout), dimension(f%to_low(1):, f%to_low(2):) :: to_here private  subroutine i_fill_3 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f integer, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):) :: from_here integer, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):) :: to_here private  subroutine i_fill_4 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f integer, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):, f%from_low(4):) :: from_here integer, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):, f%to_low(4):) :: to_here private  subroutine l_fill_2 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f logical, intent(in), dimension(f%from_low(1):, f%from_low(2):) :: from_here logical, intent(inout), dimension(f%to_low(1):, f%to_low(2):) :: to_here private  subroutine l_fill_3 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f logical, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):) :: from_here logical, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):) :: to_here private  subroutine l_fill_4 (f, from_here, to_here) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: f logical, intent(in), dimension(f%from_low(1):, f%from_low(2):, f%from_low(3):, f%from_low(4):) :: from_here logical, intent(inout), dimension(f%to_low(1):, f%to_low(2):, f%to_low(3):, f%to_low(4):) :: to_here public  subroutine report_map_property (r) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(in) :: r private  subroutine measure_gather_32 (map, gin, gout) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :, :) :: gin complex, intent(out), dimension(:, :) :: gout private  subroutine measure_scatter_23 (map, gin, gout) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :, :) :: gout private  subroutine measure_gather_33 (map, gin, gout) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :, :) :: gin complex, intent(out), dimension(:, :, :) :: gout private  subroutine measure_scatter_33 (map, gin, gout) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :, :) :: gin complex, intent(out), dimension(:, :, :) :: gout private  subroutine measure_gather_22 (map, gin, gout) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout private  subroutine measure_scatter_22 (map, gin, gout) Arguments Type Intent Optional Attributes Name type( redist_type ), intent(inout) :: map complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout","tags":"","loc":"module/redistribute.html"},{"title":"ran – stella","text":"Functions public  function ranf (seed) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: seed Return Value real public  function get_rnd_seed_length () result(l) Arguments None Return Value integer Subroutines public  subroutine get_rnd_seed (seed) Arguments Type Intent Optional Attributes Name integer, intent(out), dimension(:) :: seed public  subroutine init_ranf (randomize, init_seed, mult) Arguments Type Intent Optional Attributes Name logical, intent(in) :: randomize integer, intent(inout), dimension(:) :: init_seed integer, intent(in), optional :: mult","tags":"","loc":"module/ran.html"},{"title":"splines – stella","text":"Interfaces public        interface geo_spline public  subroutine geo_spline_real (x, y, xint, yint) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: x real, intent(in), dimension(:) :: y real, intent(in) :: xint real, intent(out) :: yint public  subroutine geo_spline_array (x, y, xint, yint) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: x real, intent(in), dimension(:) :: y real, intent(in), dimension(:) :: xint real, intent(out), dimension(:) :: yint Derived Types type, public :: spline Components Type Visibility Attributes Name Initial integer, public :: n real, public, dimension(:), pointer :: x real, public, dimension(:), pointer :: y real, public, dimension(:), pointer :: y2 type, public :: periodic_spline Components Type Visibility Attributes Name Initial integer, public :: n real, public :: period real, public, dimension(:), pointer :: x real, public, dimension(:), pointer :: y real, public, dimension(:), pointer :: y2 Functions public  function fitp_curv2 (t, n, x, y, yp, sigma) Arguments Type Intent Optional Attributes Name real :: t integer :: n real :: x (n) real :: y (n) real :: yp (n) real :: sigma Return Value real public  function fitp_curvd (t, n, x, y, yp, sigma) Arguments Type Intent Optional Attributes Name real :: t integer :: n real :: x (n) real :: y (n) real :: yp (n) real :: sigma Return Value real public  function fitp_curvi (xl, xu, n, x, y, yp, sigma) Arguments Type Intent Optional Attributes Name real :: xl real :: xu integer :: n real :: x (n) real :: y (n) real :: yp (n) real :: sigma Return Value real public  function fitp_curvp2 (t, n, x, y, p, yp, sigma) Arguments Type Intent Optional Attributes Name real :: t integer :: n real, dimension(:) :: x real, dimension(:) :: y real :: p real, dimension(:) :: yp real :: sigma Return Value real public  function fitp_curvpd (t, n, x, y, p, yp, sigma) Arguments Type Intent Optional Attributes Name real :: t integer :: n real :: x (n) real :: y (n) real :: p real :: yp (n) real :: sigma Return Value real public  function fitp_curvpi (xl, xu, n, x, y, p, yp, sigma) Arguments Type Intent Optional Attributes Name real :: xl real :: xu integer :: n real :: x (n) real :: y (n) real :: p real :: yp (n) real :: sigma Return Value real public  function fitp_surf2 (xx, yy, m, n, x, y, z, iz, zp, sigma) Arguments Type Intent Optional Attributes Name real :: xx real :: yy integer :: m integer :: n real :: x (m) real :: y (n) real :: z (iz,n) integer :: iz real :: zp (m,n,3) real :: sigma Return Value real public  function fitp_intrvl (t, x, n) Arguments Type Intent Optional Attributes Name real :: t real :: x (n) integer :: n Return Value integer public  function fitp_intrvp (t, x, n, p, tp) Arguments Type Intent Optional Attributes Name real :: t real :: x (n) integer :: n real :: p real :: tp Return Value integer public  function dedge (a, r, n, iside) Arguments Type Intent Optional Attributes Name real :: a (n) real :: r (n) integer :: n integer :: iside Return Value real Subroutines public  subroutine fitp_curv1 (n, x, y, slp1, slpn, islpsw, yp, temp, sigma, ierr) Arguments Type Intent Optional Attributes Name integer :: n real :: x (n) real :: y (n) real :: slp1 real :: slpn integer :: islpsw real :: yp (n) real :: temp (n) real :: sigma integer :: ierr public  subroutine fitp_curvs (n, x, y, d, isw, s, eps, ys, ysp, sigma, temp, ierr) Arguments Type Intent Optional Attributes Name integer :: n real :: x (n) real :: y (n) real :: d (n) integer :: isw real :: s real :: eps real :: ys (n) real :: ysp (n) real :: sigma real :: temp (n,9) integer :: ierr public  subroutine fitp_curvp1 (n, x, y, p, yp, temp, sigma, ierr) Arguments Type Intent Optional Attributes Name integer :: n real, dimension(:) :: x real, dimension(:) :: y real :: p real, dimension(:) :: yp real, dimension(:) :: temp real :: sigma integer :: ierr public  subroutine fitp_curvps (n, x, y, p, d, isw, s, eps, ys, ysp, sigma, temp, ierr) Arguments Type Intent Optional Attributes Name integer :: n real :: x (n) real :: y (n) real :: p real :: d (n) integer :: isw real :: s real :: eps real :: ys (n) real :: ysp (n) real :: sigma real :: temp (n,11) integer :: ierr public  subroutine fitp_kurv1 (n, x, y, slp1, slpn, islpsw, xp, yp, temp, s, sigma, ierr) Arguments Type Intent Optional Attributes Name integer :: n real :: x (n) real :: y (n) real :: slp1 real :: slpn integer :: islpsw real :: xp (n) real :: yp (n) real :: temp (n) real :: s (n) real :: sigma integer :: ierr public  subroutine fitp_kurv2 (t, xs, ys, n, x, y, xp, yp, s, sigma) Arguments Type Intent Optional Attributes Name real :: t real :: xs real :: ys integer :: n real :: x (n) real :: y (n) real :: xp (n) real :: yp (n) real :: s (n) real :: sigma public  subroutine fitp_kurvd (t, xs, ys, xst, yst, xstt, ystt, n, x, y, xp, yp, s, sigma) Arguments Type Intent Optional Attributes Name real :: t real :: xs real :: ys real :: xst real :: yst real :: xstt real :: ystt integer :: n real :: x (n) real :: y (n) real :: xp (n) real :: yp (n) real :: s (n) real :: sigma public  subroutine fitp_kurvp1 (n, x, y, xp, yp, temp, s, sigma, ierr) Arguments Type Intent Optional Attributes Name integer :: n real :: x (n) real :: y (n) real :: xp (n) real :: yp (n) real :: temp (1) real :: s (n) real :: sigma integer :: ierr public  subroutine fitp_kurvp2 (t, xs, ys, n, x, y, xp, yp, s, sigma) Arguments Type Intent Optional Attributes Name real :: t real :: xs real :: ys integer :: n real :: x (n) real :: y (n) real :: xp (n) real :: yp (n) real :: s (n) real :: sigma public  subroutine fitp_kurvpd (t, xs, ys, xst, yst, xstt, ystt, n, x, y, xp, yp, s, sigma) Arguments Type Intent Optional Attributes Name real :: t real :: xs real :: ys real :: xst real :: yst real :: xstt real :: ystt integer :: n real :: x (n) real :: y (n) real :: xp (n) real :: yp (n) real :: s (n) real :: sigma public  subroutine fitp_surf1 (m, n, x, y, z, iz, zx1, zxm, zy1, zyn, zxy11, zxym1, zxy1n, zxymn, islpsw, zp, temp, sigma, ierr) Arguments Type Intent Optional Attributes Name integer :: m integer :: n real :: x (m) real :: y (n) real :: z (iz,n) integer :: iz real :: zx1 (n) real :: zxm (n) real :: zy1 (m) real :: zyn (m) real :: zxy11 real :: zxym1 real :: zxy1n real :: zxymn integer :: islpsw real :: zp (m,n,3) real :: temp (n+n+m) real :: sigma integer :: ierr public  subroutine fitp_ceez (del1, del2, sigma, c1, c2, c3, n) Arguments Type Intent Optional Attributes Name real :: del1 real :: del2 real :: sigma real :: c1 real :: c2 real :: c3 integer :: n public  subroutine fitp_curvpp (n, x, y, p, d, isw, s, eps, ys, ysp, sigma, td, tsd1, hd, hsd1, hsd2, rd, rsd1, rsd2, rnm1, rn, v, ierr) Arguments Type Intent Optional Attributes Name integer :: n real :: x (n) real :: y (n) real :: p real :: d (n) integer :: isw real :: s real :: eps real :: ys (n) real :: ysp (n) real :: sigma real :: td (n) real :: tsd1 (n) real :: hd (n) real :: hsd1 (n) real :: hsd2 (n) real :: rd (n) real :: rsd1 (n) real :: rsd2 (n) real :: rnm1 (n) real :: rn (n) real :: v (n) integer :: ierr public  subroutine fitp_curvss (n, x, y, d, isw, s, eps, ys, ysp, sigma, td, tsd1, hd, hsd1, hsd2, rd, rsd1, rsd2, v, ierr) Arguments Type Intent Optional Attributes Name integer :: n real :: x (n) real :: y (n) real :: d (n) integer :: isw real :: s real :: eps real :: ys (n) real :: ysp (n) real :: sigma real :: td (n) real :: tsd1 (n) real :: hd (n) real :: hsd1 (n) real :: hsd2 (n) real :: rd (n) real :: rsd1 (n) real :: rsd2 (n) real :: v (n) integer :: ierr public  subroutine fitp_snhcsh (sinhm, coshm, x, isw) Arguments Type Intent Optional Attributes Name real :: sinhm real :: coshm real :: x integer :: isw public  subroutine fitp_terms (diag, sdiag, sigma, del) Arguments Type Intent Optional Attributes Name real :: diag real :: sdiag real :: sigma real :: del public  subroutine geo_spline_real (x, y, xint, yint) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: x real, intent(in), dimension(:) :: y real, intent(in) :: xint real, intent(out) :: yint public  subroutine geo_spline_array (x, y, xint, yint) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: x real, intent(in), dimension(:) :: y real, intent(in), dimension(:) :: xint real, intent(out), dimension(:) :: yint public  subroutine linear_interp_periodic (x, y, xint, yint, period) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: x real, intent(in), dimension(:) :: y real, intent(in), dimension(:) :: xint real, intent(out), dimension(:) :: yint real, intent(in), optional :: period","tags":"","loc":"module/splines.html"},{"title":"sort – stella","text":"Subroutines public  subroutine sort_array_ascending (array, sort_index) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: array integer, intent(out), dimension(:) :: sort_index public  subroutine unsort_array_ascending (array, sort_index) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: array integer, intent(in), dimension(:) :: sort_index","tags":"","loc":"module/sort.html"},{"title":"stella_save – stella","text":"Uses mp Variables Type Visibility Attributes Name Initial logical, public :: read_many = .true. logical, public :: save_many = .true. character(len=300), private, save :: restart_file Interfaces public        interface stella_restore private  subroutine stella_restore_many (g, scale, istatus) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :, kxkyz_lo%llim_proc:) :: g real, intent(in) :: scale integer, intent(out) :: istatus Subroutines public  subroutine stella_save_for_restart (g, istep0, t0, delt0, istatus, exit_in, fileopt) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g integer, intent(in) :: istep0 real, intent(in) :: t0 real, intent(in) :: delt0 integer, intent(out) :: istatus logical, intent(in), optional :: exit_in character(len=20), intent(in), optional :: fileopt private  subroutine stella_restore_many (g, scale, istatus) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :, kxkyz_lo%llim_proc:) :: g real, intent(in) :: scale integer, intent(out) :: istatus public  subroutine init_save (file) Arguments Type Intent Optional Attributes Name character(len=300), intent(in) :: file public  subroutine init_dt (delt0, istatus) Arguments Type Intent Optional Attributes Name real, intent(inout) :: delt0 integer, intent(out) :: istatus public  subroutine init_tstart (tstart, istep0, istatus) Arguments Type Intent Optional Attributes Name real, intent(inout) :: tstart integer, intent(out) :: istep0 integer, intent(out) :: istatus public  subroutine finish_save () Arguments None","tags":"","loc":"module/stella_save.html"},{"title":"dist_fn – stella","text":"Variables Type Visibility Attributes Name Initial logical, private :: dist_fn_initialized = .false. logical, private :: gxyz_initialized = .false. logical, private :: kp2init = .false. logical, private :: dkp2drinit = .false. logical, private :: vp2init = .false. logical, private :: debug = .false. Interfaces public        interface checksum private  subroutine checksum_field (field, total) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: field real, intent(out) :: total private  subroutine checksum_dist (dist, total, norm) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dist real, intent(out) :: total logical, intent(in), optional :: norm Subroutines public  subroutine init_gxyz (restarted) Arguments Type Intent Optional Attributes Name logical, intent(in) :: restarted public  subroutine init_dist_fn () allocate and initialise kperp2 and dkperp2dr\nallocate and initialise vperp2\ninit_bessel sets up arrays needed for gyro-averaging;\nfor a flux tube simulation, this is j0 and j1;\nfor a flux annulus simulation, gyro-averaging is non-local in ky\nand so more effort is required Arguments None private  subroutine init_kperp2 () init_kperp2 allocates and initialises the kperp2 array Read more… Arguments None private  subroutine init_dkperp2dr () init_dkperp2dr allocates and initialises the dkperp2dr array, needed for radial variation Arguments None private  subroutine enforce_single_valued_kperp2 () Arguments None private  subroutine allocate_arrays () Arguments None private  subroutine init_vperp2 () Arguments None public  subroutine finish_dist_fn () Arguments None private  subroutine deallocate_arrays () Arguments None private  subroutine finish_kperp2 () Arguments None private  subroutine finish_vperp2 () Arguments None private  subroutine checksum_field (field, total) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: field real, intent(out) :: total private  subroutine checksum_dist (dist, total, norm) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dist real, intent(out) :: total logical, intent(in), optional :: norm","tags":"","loc":"module/dist_fn.html"},{"title":"response_matrix – stella","text":"Uses netcdf mpi Variables Type Visibility Attributes Name Initial logical, public :: response_matrix_initialized = .false. integer, private, parameter :: mat_unit = 70 character(len=100), private :: message_dgdphi character(len=100), private :: message_QN character(len=100), private :: message_lu real, private, dimension(2) :: time_dgdphi real, private, dimension(2) :: time_QN real, private, dimension(2) :: time_lu logical, private :: debug = .false. Subroutines public  subroutine init_response_matrix () Arguments None private  subroutine write_response_matrix_message () Arguments None private  subroutine setup_response_matrix_timings () Arguments None private  subroutine setup_response_matrix_file_io () Arguments None private  subroutine setup_shared_memory_window () Arguments None private  subroutine construct_response_matrix () Arguments None private  subroutine calculate_vspace_integrated_response (iky) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky private  subroutine setup_response_matrix_zloc_idx (iky, ie, nresponse) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky integer, intent(in) :: ie integer, intent(in) :: nresponse private  subroutine apply_field_solve_to_finish_response_matrix (iky) set up offset_apar and offset_bpar consistently\nso that the array slices below are consistent with\nthe size of the response matrix Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky private  subroutine lu_decompose_response_matrix (iky) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky public  subroutine read_response_matrix () Arguments None private  subroutine get_dpdf_dphi_matrix_column (iky, ie, idx, nz_ext, nresponse, phi_ext, apar_ext, bpar_ext, pdf_ext) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky integer, intent(in) :: ie integer, intent(in) :: idx integer, intent(in) :: nz_ext integer, intent(in) :: nresponse complex, intent(out), dimension(:) :: phi_ext complex, intent(out), dimension(:) :: apar_ext complex, intent(out), dimension(:) :: bpar_ext complex, intent(out), dimension(:, vmu_lo%llim_proc:) :: pdf_ext private  subroutine get_dpdf_dapar_matrix_column (iky, ie, idx, nz_ext, nresponse, phi_ext, apar_ext, bpar_ext, pdf_ext) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky integer, intent(in) :: ie integer, intent(in) :: idx integer, intent(in) :: nz_ext integer, intent(in) :: nresponse complex, intent(out), dimension(:) :: phi_ext complex, intent(out), dimension(:) :: apar_ext complex, intent(out), dimension(:) :: bpar_ext complex, intent(out), dimension(:, vmu_lo%llim_proc:) :: pdf_ext private  subroutine get_dpdf_dbpar_matrix_column (iky, ie, idx, nz_ext, nresponse, phi_ext, apar_ext, bpar_ext, pdf_ext) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky integer, intent(in) :: ie integer, intent(in) :: idx integer, intent(in) :: nz_ext integer, intent(in) :: nresponse complex, intent(out), dimension(:) :: phi_ext complex, intent(out), dimension(:) :: apar_ext complex, intent(out), dimension(:) :: bpar_ext complex, intent(out), dimension(:, vmu_lo%llim_proc:) :: pdf_ext private  subroutine integrate_over_velocity (g, phi, apar, bpar, iky, ie) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:) :: phi complex, intent(out), dimension(:) :: apar complex, intent(out), dimension(:) :: bpar integer, intent(in) :: iky integer, intent(in) :: ie private  subroutine integrate_over_velocity_phi (g, phi, iky, ie) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:) :: phi integer, intent(in) :: iky integer, intent(in) :: ie private  subroutine integrate_over_velocity_bpar (g, bpar, iky, ie) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:) :: bpar integer, intent(in) :: iky integer, intent(in) :: ie private  subroutine integrate_over_velocity_apar (g, apar, iky, ie) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:) :: apar integer, intent(in) :: iky integer, intent(in) :: ie private  subroutine get_fields_for_response_matrix (phi, apar, bpar, iky, ie, dist) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: phi complex, intent(inout), dimension(:) :: apar complex, intent(inout), dimension(:) :: bpar integer, intent(in) :: iky integer, intent(in) :: ie character(len=*), intent(in) :: dist private  subroutine get_phi_for_response_matrix (phi, iky, ie, dist) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: phi integer, intent(in) :: iky integer, intent(in) :: ie character(len=*), intent(in) :: dist private  subroutine get_phi_and_bpar_for_response_matrix (phi, bpar, iky, ie, dist) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: phi complex, intent(inout), dimension(:) :: bpar integer, intent(in) :: iky integer, intent(in) :: ie character(len=*), intent(in) :: dist private  subroutine get_apar_for_response_matrix (apar, iky, ie, dist) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: apar integer, intent(in) :: iky integer, intent(in) :: ie character(len=*), intent(in) :: dist public  subroutine finish_response_matrix () Arguments None private  subroutine parallel_LU_decomposition_global (iky) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky","tags":"","loc":"module/response_matrix.html"},{"title":"stella_geometry – stella","text":"Uses common_types Variables Type Visibility Attributes Name Initial type( flux_surface_type ), public :: geo_surf real, public :: grad_x_grad_y_end real, public :: aref real, public :: bref real, public :: dxdXcoord real, public :: dydalpha real, private :: dqdrho real, public :: dIdrho real, public :: grho_norm real, public :: drhodpsi real, public :: drhodpsi_psi0 real, private :: shat real, private :: qinp real, public :: exb_nonlin_fac real, public :: exb_nonlin_fac_p real, public :: gradpar_eqarc real, public :: zed_scalefac real, public :: twist_and_shift_geo_fac real, public :: gfac real, public, dimension(:), allocatable :: zed_eqarc real, public, dimension(:), allocatable :: gradpar real, public, dimension(:, :), allocatable :: b_dot_grad_z real, public, dimension(:, :), allocatable :: bmag real, public, dimension(:, :), allocatable :: bmag_psi0 real, public, dimension(:, :), allocatable :: dbdzed real, private, dimension(:, :), allocatable :: twist_and_shift_geo_fac_full real, public, dimension(:, :), allocatable :: cvdrift real, public, dimension(:, :), allocatable :: cvdrift0 real, public, dimension(:, :), allocatable :: gbdrift real, public, dimension(:, :), allocatable :: gbdrift0 real, public, dimension(:, :), allocatable :: dcvdriftdrho real, public, dimension(:, :), allocatable :: dcvdrift0drho real, public, dimension(:, :), allocatable :: dgbdriftdrho real, public, dimension(:, :), allocatable :: dgbdrift0drho real, public, dimension(:, :), allocatable :: gds2 real, public, dimension(:, :), allocatable :: gds21 real, public, dimension(:, :), allocatable :: gds22 real, public, dimension(:, :), allocatable :: gds23 real, public, dimension(:, :), allocatable :: gds24 real, public, dimension(:, :), allocatable :: gds25 real, public, dimension(:, :), allocatable :: gds26 real, public, dimension(:, :), allocatable :: dgds2dr real, public, dimension(:, :), allocatable :: dgds21dr real, public, dimension(:, :), allocatable :: dgds22dr real, public, dimension(:, :), allocatable :: theta_vmec real, public, dimension(:, :), allocatable :: jacob real, public, dimension(:, :), allocatable :: djacdrho real, public, dimension(:, :), allocatable :: grho real, public, dimension(:, :), allocatable :: grad_x real, public, dimension(:, :), allocatable :: dl_over_b real, public, dimension(:, :), allocatable :: d_dl_over_b_drho real, public, dimension(:, :, :), allocatable :: dVolume real, public, dimension(:, :), allocatable :: x_displacement_fac real, public, dimension(:), allocatable :: dBdrho real, public, dimension(:), allocatable :: d2Bdrdth real, public, dimension(:), allocatable :: dgradpardrho real, public, dimension(:), allocatable :: btor real, public, dimension(:), allocatable :: Rmajor real, public, dimension(:), allocatable :: alpha real, public, dimension(:, :), allocatable :: zeta integer, public :: sign_torflux integer, private :: geo_option_switch integer, private, parameter :: geo_option_local = 1 integer, private, parameter :: geo_option_inputprof = 2 integer, private, parameter :: geo_option_vmec = 3 integer, private, parameter :: geo_option_multibox = 4 logical, private :: overwrite_geometry logical, private :: overwrite_bmag logical, private :: overwrite_gradpar logical, private :: overwrite_gds2 logical, private :: overwrite_gds21 logical, private :: overwrite_gds22 logical, private :: overwrite_gds23 logical, private :: overwrite_gds24 logical, private :: overwrite_gbdrift logical, private :: overwrite_cvdrift logical, private :: overwrite_gbdrift0 logical, public :: q_as_x character(len=100), private :: geo_file logical, private :: vmec_chosen = .false. logical, private :: geoinit = .false. logical, private :: set_bmag_const Subroutines public  subroutine init_geometry (nalpha, naky) b_dot_grad_z is the alpha-dependent b . grad z,\nand gradpar is the constant-in-alpha part of it.\nfor axisymmetric systems, b_dot_grad_z is independent of alpha. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: nalpha integer, intent(in) :: naky private  subroutine allocate_arrays (nalpha, nzgrid) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nalpha integer, intent(in) :: nzgrid private  subroutine read_parameters () Arguments None private  subroutine broadcast_arrays () Arguments None public  subroutine communicate_geo_multibox (l_edge, r_edge) Arguments Type Intent Optional Attributes Name real, intent(in) :: l_edge real, intent(in) :: r_edge private  subroutine get_dzed (nz, dz, f, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nz real, intent(in), dimension(-nz:) :: dz real, intent(in), dimension(-nz:) :: f real, intent(out), dimension(-nz:) :: df private  subroutine get_gradpar_eqarc (gp, z, dz, gp_eqarc) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nzgrid:) :: gp real, intent(in), dimension(-nzgrid:) :: z real, intent(in), dimension(-nzgrid:) :: dz real, intent(out) :: gp_eqarc private  subroutine get_zed_eqarc (gp, dz, z, gp_eqarc, z_eqarc) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nzgrid:) :: gp real, intent(in), dimension(-nzgrid:) :: dz real, intent(in), dimension(-nzgrid:) :: z real, intent(in) :: gp_eqarc real, intent(out), dimension(-nzgrid:) :: z_eqarc private  subroutine integrate_zed (dz, f, intf) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nzgrid:) :: dz real, intent(in), dimension(-nzgrid:) :: f real, intent(out) :: intf public  subroutine get_x_to_rho (llim, x_in, rho_out) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(:) :: x_in real, intent(out), dimension(:) :: rho_out private  subroutine write_geometric_coefficients (nalpha) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nalpha public  subroutine finish_init_geometry () Arguments None public  subroutine finish_geometry () Arguments None","tags":"","loc":"module/stella_geometry.html"},{"title":"text_options – stella","text":"Variables Type Visibility Attributes Name Initial integer, private, parameter :: maxlen = 30 Derived Types type, public :: text_option Components Type Visibility Attributes Name Initial character(len=maxlen), public :: name integer, public :: value Subroutines public  subroutine get_option_value (selection, options, value, error_unit, selection_name, stop_on_error) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: selection type( text_option ), intent(in), dimension(:) :: options integer, intent(inout) :: value integer, intent(in), optional :: error_unit character(len=*), intent(in), optional :: selection_name logical, intent(in), optional :: stop_on_error","tags":"","loc":"module/text_options.html"},{"title":"zgrid – stella","text":"Variables Type Visibility Attributes Name Initial integer, public :: nzed integer, public :: nzgrid integer, public :: nztot integer, public :: nz2pi integer, public :: nperiod integer, public :: ntubes logical, public :: zed_equal_arc real, public :: shat_zero real, public :: grad_x_grad_y_zero real, public :: dkx_over_dky real, public, dimension(:), allocatable :: zed real, public, dimension(:), allocatable :: delzed integer, public :: boundary_option_switch integer, public, parameter :: boundary_option_zero = 1 integer, public, parameter :: boundary_option_self_periodic = 2 integer, public, parameter :: boundary_option_linked = 3 integer, public, parameter :: boundary_option_linked_stellarator = 4 logical, private :: zgridinit = .false. Subroutines public  subroutine init_zgrid () Arguments None private  subroutine read_parameters () Arguments None private  subroutine broadcast_parameters () Arguments None public  subroutine finish_zgrid () Arguments None public  subroutine get_total_arc_length (nz, gp, dz, length) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nz real, intent(in), dimension(-nz:) :: gp real, intent(in) :: dz real, intent(out) :: length public  subroutine get_arc_length_grid (nz_max, nzext_max, zboundary, gp, dz, zarc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nz_max integer, intent(in) :: nzext_max real, intent(in) :: zboundary real, intent(in), dimension(-nzext_max:) :: gp real, intent(in) :: dz real, intent(out), dimension(-nzext_max:) :: zarc private  subroutine integrate_zed (nz, dz, f, intf) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nz real, intent(in) :: dz real, intent(in), dimension(-nz:) :: f real, intent(out) :: intf","tags":"","loc":"module/zgrid.html"},{"title":"read_wout_mod – stella","text":"Uses ezcdf_GenGet stel_kinds vsvd0 ezcdf_inqvar Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: vn_version = 'version_' character(len=*), public, parameter :: vn_extension = 'input_extension' character(len=*), public, parameter :: vn_mgrid = 'mgrid_file' character(len=*), public, parameter :: vn_magen = 'wb' character(len=*), public, parameter :: vn_therm = 'wp' character(len=*), public, parameter :: vn_gam = 'gamma' character(len=*), public, parameter :: vn_maxr = 'rmax_surf' character(len=*), public, parameter :: vn_minr = 'rmin_surf' character(len=*), public, parameter :: vn_maxz = 'zmax_surf' character(len=*), public, parameter :: vn_fp = 'nfp' character(len=*), public, parameter :: vn_radnod = 'ns' character(len=*), public, parameter :: vn_polmod = 'mpol' character(len=*), public, parameter :: vn_tormod = 'ntor' character(len=*), public, parameter :: vn_maxmod = 'mnmax' character(len=*), public, parameter :: vn_maxit = 'niter' character(len=*), public, parameter :: vn_actit = 'itfsq' character(len=*), public, parameter :: vn_asym = 'lasym' character(len=*), public, parameter :: vn_recon = 'lrecon' character(len=*), public, parameter :: vn_free = 'lfreeb' character(len=*), public, parameter :: vn_error = 'ier_flag' character(len=*), public, parameter :: vn_aspect = 'aspect' character(len=*), public, parameter :: vn_rfp = 'lrfp' character(len=*), public, parameter :: vn_maxmod_nyq = 'mnmax_nyq' character(len=*), public, parameter :: vn_beta = 'betatotal' character(len=*), public, parameter :: vn_pbeta = 'betapol' character(len=*), public, parameter :: vn_tbeta = 'betator' character(len=*), public, parameter :: vn_abeta = 'betaxis' character(len=*), public, parameter :: vn_b0 = 'b0' character(len=*), public, parameter :: vn_rbt0 = 'rbtor0' character(len=*), public, parameter :: vn_rbt1 = 'rbtor' character(len=*), public, parameter :: vn_sgs = 'signgs' character(len=*), public, parameter :: vn_lar = 'IonLarmor' character(len=*), public, parameter :: vn_modB = 'volavgB' character(len=*), public, parameter :: vn_ctor = 'ctor' character(len=*), public, parameter :: vn_amin = 'Aminor_p' character(len=*), public, parameter :: vn_Rmaj = 'Rmajor_p' character(len=*), public, parameter :: vn_vol = 'volume_p' character(len=*), public, parameter :: vn_am = 'am' character(len=*), public, parameter :: vn_ai = 'ai' character(len=*), public, parameter :: vn_ac = 'ac' character(len=*), public, parameter :: vn_ah = 'hot particle fraction' character(len=*), public, parameter :: vn_atuname = 'T-perp/T-par' character(len=*), public, parameter :: vn_pmass_type = 'pmass_type' character(len=*), public, parameter :: vn_piota_type = 'piota_type' character(len=*), public, parameter :: vn_pcurr_type = 'pcurr_type' character(len=*), public, parameter :: vn_am_aux_s = 'am_aux_s' character(len=*), public, parameter :: vn_am_aux_f = 'am_aux_f' character(len=*), public, parameter :: vn_ai_aux_s = 'ai_aux_s' character(len=*), public, parameter :: vn_ai_aux_f = 'ai_aux_f' character(len=*), public, parameter :: vn_ac_aux_s = 'ac_aux_s' character(len=*), public, parameter :: vn_ac_aux_f = 'ac_aux_f' character(len=*), public, parameter :: vn_mse = 'imse' character(len=*), public, parameter :: vn_thom = 'itse' character(len=*), public, parameter :: vn_pmod = 'xm' character(len=*), public, parameter :: vn_tmod = 'xn' character(len=*), public, parameter :: vn_pmod_nyq = 'xm_nyq' character(len=*), public, parameter :: vn_tmod_nyq = 'xn_nyq' character(len=*), public, parameter :: vn_racc = 'raxis_cc' character(len=*), public, parameter :: vn_zacs = 'zaxis_cs' character(len=*), public, parameter :: vn_racs = 'raxis_cs' character(len=*), public, parameter :: vn_zacc = 'zaxis_cc' character(len=*), public, parameter :: vn_iotaf = 'iotaf' character(len=*), public, parameter :: vn_qfact = 'q-factor' character(len=*), public, parameter :: vn_chi = 'chi' character(len=*), public, parameter :: vn_chipf = 'chipf' character(len=*), public, parameter :: vn_presf = 'presf' character(len=*), public, parameter :: vn_phi = 'phi' character(len=*), public, parameter :: vn_phipf = 'phipf' character(len=*), public, parameter :: vn_jcuru = 'jcuru' character(len=*), public, parameter :: vn_jcurv = 'jcurv' character(len=*), public, parameter :: vn_iotah = 'iotas' character(len=*), public, parameter :: vn_mass = 'mass' character(len=*), public, parameter :: vn_presh = 'pres' character(len=*), public, parameter :: vn_betah = 'beta_vol' character(len=*), public, parameter :: vn_buco = 'buco' character(len=*), public, parameter :: vn_bvco = 'bvco' character(len=*), public, parameter :: vn_vp = 'vp' character(len=*), public, parameter :: vn_specw = 'specw' character(len=*), public, parameter :: vn_phip = 'phips' character(len=*), public, parameter :: vn_jdotb = 'jdotb' character(len=*), public, parameter :: vn_overr = 'over_r' character(len=*), public, parameter :: vn_bgrv = 'bdotgradv' character(len=*), public, parameter :: vn_merc = 'DMerc' character(len=*), public, parameter :: vn_mshear = 'DShear' character(len=*), public, parameter :: vn_mwell = 'DWell' character(len=*), public, parameter :: vn_mcurr = 'DCurr' character(len=*), public, parameter :: vn_mgeo = 'DGeod' character(len=*), public, parameter :: vn_equif = 'equif' character(len=*), public, parameter :: vn_fsq = 'fsqt' character(len=*), public, parameter :: vn_wdot = 'wdot' character(len=*), public, parameter :: vn_ftolv = 'ftolv' character(len=*), public, parameter :: vn_fsql = 'fsql' character(len=*), public, parameter :: vn_fsqr = 'fsqr' character(len=*), public, parameter :: vn_fsqz = 'fsqz' character(len=*), public, parameter :: vn_extcur = 'extcur' character(len=*), public, parameter :: vn_curlab = 'curlabel' character(len=*), public, parameter :: vn_rmnc = 'rmnc' character(len=*), public, parameter :: vn_zmns = 'zmns' character(len=*), public, parameter :: vn_lmns = 'lmns' character(len=*), public, parameter :: vn_gmnc = 'gmnc' character(len=*), public, parameter :: vn_bmnc = 'bmnc' character(len=*), public, parameter :: vn_bsubumnc = 'bsubumnc' character(len=*), public, parameter :: vn_bsubvmnc = 'bsubvmnc' character(len=*), public, parameter :: vn_bsubsmns = 'bsubsmns' character(len=*), public, parameter :: vn_bsupumnc = 'bsupumnc' character(len=*), public, parameter :: vn_bsupvmnc = 'bsupvmnc' character(len=*), public, parameter :: vn_rmns = 'rmns' character(len=*), public, parameter :: vn_zmnc = 'zmnc' character(len=*), public, parameter :: vn_lmnc = 'lmnc' character(len=*), public, parameter :: vn_gmns = 'gmns' character(len=*), public, parameter :: vn_bmns = 'bmns' character(len=*), public, parameter :: vn_bsubumns = 'bsubumns' character(len=*), public, parameter :: vn_bsubvmns = 'bsubvmns' character(len=*), public, parameter :: vn_bsubsmnc = 'bsubsmnc' character(len=*), public, parameter :: vn_bsupumns = 'bsupumns' character(len=*), public, parameter :: vn_bsupvmns = 'bsupvmns' character(len=*), public, parameter :: vn_rbc = 'rbc' character(len=*), public, parameter :: vn_zbs = 'zbs' character(len=*), public, parameter :: vn_rbs = 'rbs' character(len=*), public, parameter :: vn_zbc = 'zbc' character(len=*), public, parameter :: vn_potvac = 'potvac' character(len=*), public, parameter :: vn_wpar = 'wpar' character(len=*), public, parameter :: vn_pparmnc = 'pparmnc' character(len=*), public, parameter :: vn_ppermnc = 'ppermnc' character(len=*), public, parameter :: vn_hotdmnc = 'hotdmnc' character(len=*), public, parameter :: vn_pbprmnc = 'pbprmnc' character(len=*), public, parameter :: vn_ppprmnc = 'ppprmnc' character(len=*), public, parameter :: vn_sigmnc = 'sigmnc' character(len=*), public, parameter :: vn_taumnc = 'taumnc' character(len=*), public, parameter :: vn_pparmns = 'pparmns' character(len=*), public, parameter :: vn_ppermns = 'ppermns' character(len=*), public, parameter :: vn_hotdmns = 'hotdmns' character(len=*), public, parameter :: vn_pbprmns = 'pbprmns' character(len=*), public, parameter :: vn_ppprmns = 'ppprmns' character(len=*), public, parameter :: vn_sigmns = 'sigmns' character(len=*), public, parameter :: vn_taumns = 'taumns' character(len=*), public, parameter :: vn_machsq = 'machsq' character(len=*), public, parameter :: vn_protmnc = 'protmnc' character(len=*), public, parameter :: vn_protrsqmnc = 'protrsqmnc' character(len=*), public, parameter :: vn_prprmnc = 'prprmnc' character(len=*), public, parameter :: vn_protmns = 'protmns' character(len=*), public, parameter :: vn_protrsqmns = 'protrsqmns' character(len=*), public, parameter :: vn_prprmns = 'prprmns' character(len=*), public, parameter :: vn_pmap = 'pmap' character(len=*), public, parameter :: vn_omega = 'omega' character(len=*), public, parameter :: vn_tpotb = 'tpotb' character(len=*), public, parameter :: ln_version = 'VMEC Version' character(len=*), public, parameter :: ln_extension = 'Input file extension' character(len=*), public, parameter :: ln_mgrid = 'MGRID file' character(len=*), public, parameter :: ln_magen = 'Magnetic Energy' character(len=*), public, parameter :: ln_therm = 'Thermal Energy' character(len=*), public, parameter :: ln_gam = 'Gamma' character(len=*), public, parameter :: ln_maxr = 'Maximum R' character(len=*), public, parameter :: ln_minr = 'Minimum R' character(len=*), public, parameter :: ln_maxz = 'Maximum Z' character(len=*), public, parameter :: ln_fp = 'Field Periods' character(len=*), public, parameter :: ln_radnod = 'Radial nodes' character(len=*), public, parameter :: ln_polmod = 'Poloidal modes' character(len=*), public, parameter :: ln_tormod = 'Toroidal modes' character(len=*), public, parameter :: ln_maxmod = 'Fourier modes' character(len=*), public, parameter :: ln_maxmod_nyq = 'Fourier modes (Nyquist)' character(len=*), public, parameter :: ln_maxit = 'Max iterations' character(len=*), public, parameter :: ln_actit = 'Actual iterations' character(len=*), public, parameter :: ln_asym = 'Asymmetry' character(len=*), public, parameter :: ln_recon = 'Reconstruction' character(len=*), public, parameter :: ln_free = 'Free boundary' character(len=*), public, parameter :: ln_error = 'Error flag' character(len=*), public, parameter :: ln_aspect = 'Aspect ratio' character(len=*), public, parameter :: ln_beta = 'Total beta' character(len=*), public, parameter :: ln_pbeta = 'Poloidal beta' character(len=*), public, parameter :: ln_tbeta = 'Toroidal beta' character(len=*), public, parameter :: ln_abeta = 'Beta axis' character(len=*), public, parameter :: ln_b0 = 'RB-t over R axis' character(len=*), public, parameter :: ln_rbt0 = 'RB-t axis' character(len=*), public, parameter :: ln_rbt1 = 'RB-t edge' character(len=*), public, parameter :: ln_sgs = 'Sign jacobian' character(len=*), public, parameter :: ln_lar = 'Ion Larmor radius' character(len=*), public, parameter :: ln_modB = 'avg mod B' character(len=*), public, parameter :: ln_ctor = 'Toroidal current' character(len=*), public, parameter :: ln_amin = 'minor radius' character(len=*), public, parameter :: ln_Rmaj = 'major radius' character(len=*), public, parameter :: ln_vol = 'Plasma volume' character(len=*), public, parameter :: ln_mse = 'Number of MSE points' character(len=*), public, parameter :: ln_thom = 'Number of Thompson scattering points' character(len=*), public, parameter :: ln_am = 'Specification parameters for mass(s)' character(len=*), public, parameter :: ln_ac = 'Specification parameters for <J>(s)' character(len=*), public, parameter :: ln_ai = 'Specification parameters for iota(s)' character(len=*), public, parameter :: ln_pmass_type = 'Profile type specifier for mass(s)' character(len=*), public, parameter :: ln_pcurr_type = 'Profile type specifier for <J>(s)' character(len=*), public, parameter :: ln_piota_type = 'Profile type specifier for iota(s)' character(len=*), public, parameter :: ln_am_aux_s = 'Auxiliary-s parameters for mass(s)' character(len=*), public, parameter :: ln_am_aux_f = 'Auxiliary-f parameters for mass(s)' character(len=*), public, parameter :: ln_ac_aux_s = 'Auxiliary-s parameters for <J>(s)' character(len=*), public, parameter :: ln_ac_aux_f = 'Auxiliary-f parameters for <J>(s)' character(len=*), public, parameter :: ln_ai_aux_s = 'Auxiliary-s parameters for iota(s)' character(len=*), public, parameter :: ln_ai_aux_f = 'Auxiliary-f parameters for iota(s)' character(len=*), public, parameter :: ln_pmod = 'Poloidal mode numbers' character(len=*), public, parameter :: ln_tmod = 'Toroidal mode numbers' character(len=*), public, parameter :: ln_pmod_nyq = 'Poloidal mode numbers (Nyquist)' character(len=*), public, parameter :: ln_tmod_nyq = 'Toroidal mode numbers (Nyquist)' character(len=*), public, parameter :: ln_racc = 'raxis (cosnv)' character(len=*), public, parameter :: ln_racs = 'raxis (sinnv)' character(len=*), public, parameter :: ln_zacs = 'zaxis (sinnv)' character(len=*), public, parameter :: ln_zacc = 'zaxis (cosnv)' character(len=*), public, parameter :: ln_iotaf = 'iota on full mesh' character(len=*), public, parameter :: ln_qfact = 'q-factor on full mesh' character(len=*), public, parameter :: ln_presf = 'pressure on full mesh' character(len=*), public, parameter :: ln_phi = 'Toroidal flux on full mesh' character(len=*), public, parameter :: ln_phipf = 'd(phi)/ds: Toroidal flux deriv on full mesh' character(len=*), public, parameter :: ln_chi = 'Poloidal flux on full mesh' character(len=*), public, parameter :: ln_chipf = 'd(chi)/ds: Poroidal flux deriv on full mesh' character(len=*), public, parameter :: ln_jcuru = 'j dot gradu full' character(len=*), public, parameter :: ln_jcurv = 'j dot gradv full' character(len=*), public, parameter :: ln_iotah = 'iota half' character(len=*), public, parameter :: ln_mass = 'mass half' character(len=*), public, parameter :: ln_presh = 'pressure half' character(len=*), public, parameter :: ln_betah = 'beta half' character(len=*), public, parameter :: ln_buco = 'bsubu half' character(len=*), public, parameter :: ln_bvco = 'bsubv half' character(len=*), public, parameter :: ln_vp = 'volume deriv half' character(len=*), public, parameter :: ln_specw = 'Spectral width half' character(len=*), public, parameter :: ln_phip = 'tor flux deriv over 2pi half' character(len=*), public, parameter :: ln_jdotb = 'J dot B' character(len=*), public, parameter :: ln_bgrv = 'B dot grad v' character(len=*), public, parameter :: ln_merc = 'Mercier criterion' character(len=*), public, parameter :: ln_mshear = 'Shear Mercier' character(len=*), public, parameter :: ln_mwell = 'Well Mercier' character(len=*), public, parameter :: ln_mcurr = 'Current Mercier' character(len=*), public, parameter :: ln_mgeo = 'Geodesic Mercier' character(len=*), public, parameter :: ln_equif = 'Average force balance' character(len=*), public, parameter :: ln_fsq = 'Residual decay' character(len=*), public, parameter :: ln_wdot = 'Wdot decay' character(len=*), public, parameter :: ln_extcur = 'External coil currents' character(len=*), public, parameter :: ln_fsqr = 'Residual decay - radial' character(len=*), public, parameter :: ln_fsqz = 'Residual decay - vertical' character(len=*), public, parameter :: ln_fsql = 'Residual decay - hoop' character(len=*), public, parameter :: ln_ftolv = 'Residual decay - requested' character(len=*), public, parameter :: ln_curlab = 'External current names' character(len=*), public, parameter :: ln_rmnc = 'cosmn component of cylindrical R, full mesh' character(len=*), public, parameter :: ln_zmns = 'sinmn component of cylindrical Z, full mesh' character(len=*), public, parameter :: ln_lmns = 'sinmn component of lambda, half mesh' character(len=*), public, parameter :: ln_gmnc = 'cosmn component of jacobian, half mesh' character(len=*), public, parameter :: ln_bmnc = 'cosmn component of mod-B, half mesh' character(len=*), public, parameter :: ln_bsubumnc = 'cosmn covariant u-component of B, half mesh' character(len=*), public, parameter :: ln_bsubvmnc = 'cosmn covariant v-component of B, half mesh' character(len=*), public, parameter :: ln_bsubsmns = 'sinmn covariant s-component of B, full mesh' character(len=*), public, parameter :: ln_bsupumnc = 'BSUPUmnc half' character(len=*), public, parameter :: ln_bsupvmnc = 'BSUPVmnc half' character(len=*), public, parameter :: ln_rmns = 'sinmn component of cylindrical R, full mesh' character(len=*), public, parameter :: ln_zmnc = 'cosmn component of cylindrical Z, full mesh' character(len=*), public, parameter :: ln_lmnc = 'cosmn component of lambda, half mesh' character(len=*), public, parameter :: ln_gmns = 'sinmn component of jacobian, half mesh' character(len=*), public, parameter :: ln_bmns = 'sinmn component of mod-B, half mesh' character(len=*), public, parameter :: ln_bsubumns = 'sinmn covariant u-component of B, half mesh' character(len=*), public, parameter :: ln_bsubvmns = 'sinmn covariant v-component of B, half mesh' character(len=*), public, parameter :: ln_bsubsmnc = 'cosmn covariant s-component of B, full mesh' character(len=*), public, parameter :: ln_bsupumns = 'BSUPUmns half' character(len=*), public, parameter :: ln_bsupvmns = 'BSUPVmns half' character(len=*), public, parameter :: ln_rbc = 'Initial boundary R cos(mu-nv) coefficients' character(len=*), public, parameter :: ln_zbs = 'Initial boundary Z sin(mu-nv) coefficients' character(len=*), public, parameter :: ln_rbs = 'Initial boundary R sin(mu-nv) coefficients' character(len=*), public, parameter :: ln_zbc = 'Initial boundary Z cos(mu-nv) coefficients' character(len=*), public, parameter :: ln_potvac = 'Vacuum Potential on Boundary' character(len=*), public, parameter :: ln_wpar = 'Energy' character(len=*), public, parameter :: ln_pparmnc = 'cosmn compoents of hot part. para. pressure' character(len=*), public, parameter :: ln_ppermnc = 'cosmn compoents of hot part. perp. pressure' character(len=*), public, parameter :: ln_hotdmnc = 'cosmn compoents of hot part. density' character(len=*), public, parameter :: ln_pbprmnc = 'cosmn compoents of hot part. para. pres. grad.' character(len=*), public, parameter :: ln_ppprmnc = 'cosmn compoents of hot part. perp. pres. grad.' character(len=*), public, parameter :: ln_sigmnc = 'cosmn firehose stability variable' character(len=*), public, parameter :: ln_taumnc = 'cosmn mirror stability variable' character(len=*), public, parameter :: ln_pparmns = 'sinmn compoents of hot part. para. pressure' character(len=*), public, parameter :: ln_ppermns = 'sinmn compoents of hot part. perp. pressure' character(len=*), public, parameter :: ln_hotdmns = 'sinmn compoents of hot part. density' character(len=*), public, parameter :: ln_pbprmns = 'sinmn compoents of hot part. para. pres. grad.' character(len=*), public, parameter :: ln_ppprmns = 'sinmn compoents of hot part. perp. pres. grad.' character(len=*), public, parameter :: ln_sigmns = 'sinmn firehose stability variable' character(len=*), public, parameter :: ln_taumns = 'sinmn mirror stability variable' character(len=*), public, parameter :: ln_machsq = 'Mach # on axis (squared)' character(len=*), public, parameter :: ln_protmnc = 'cosmn components of pressure' character(len=*), public, parameter :: ln_protrsqmnc = 'cosmn component of rotational energy' character(len=*), public, parameter :: ln_prprmnc = 'cosmn components of radial pressure gradient' character(len=*), public, parameter :: ln_protmns = 'sinmn components of pressure' character(len=*), public, parameter :: ln_protrsqmns = 'sinmn component of rotational energy' character(len=*), public, parameter :: ln_prprmns = 'sinmn components of radial pressure gradient' character(len=*), public, parameter :: ln_pmap = '<p(s,R)>' character(len=*), public, parameter :: ln_omega = 'Toroidal Angular Freq.' character(len=*), public, parameter :: ln_tpotb = 'T_perp/T_parallel or T(flow)' integer, public, parameter :: fatal_error = 666 logical, public :: lnverror = .true. integer, public, parameter :: nlimset = 2 character(len=*), public, parameter :: vn_br0 = 'br' character(len=*), public, parameter :: vn_bp0 = 'bp' character(len=*), public, parameter :: vn_bz0 = 'bz' character(len=*), public, parameter :: vn_ir = 'ir' character(len=*), public, parameter :: vn_jz = 'jz' character(len=*), public, parameter :: vn_kp = 'kp' character(len=*), public, parameter :: vn_nfp = 'nfp' character(len=*), public, parameter :: vn_rmin = 'rmin' character(len=*), public, parameter :: vn_rmax = 'rmax' character(len=*), public, parameter :: vn_zmin = 'zmin' character(len=*), public, parameter :: vn_zmax = 'zmax' character(len=*), public, parameter :: vn_coilgrp = 'coil_group' character(len=*), public, parameter :: vn_nextcur = 'nextcur' character(len=*), public, parameter :: vn_mgmode = 'mgrid_mode' character(len=*), public, parameter :: vn_coilcur = 'raw_coil_cur' character(len=*), public, parameter :: vn_flp = 'nobser' character(len=*), public, parameter :: vn_nobd = 'nobd' character(len=*), public, parameter :: vn_nbset = 'nbsets' character(len=*), public, parameter :: vn_nbfld = 'nbfld' character(len=*), public, parameter :: ln_flp = 'flux loops' character(len=*), public, parameter :: ln_nobd = 'Connected flux loops' character(len=*), public, parameter :: ln_nbset = 'B-coil loops' character(len=*), public, parameter :: ln_next = 'External currents' character(len=*), public, parameter :: ln_nbfld = 'B-coil measurements' integer, public :: nr0b integer, public :: np0b integer, public :: nfper0 integer, public :: nz0b integer, public :: nobd integer, public :: nobser integer, public :: nextcur integer, public :: nbfldn integer, public :: nbsets integer, public :: nbcoilsn integer, public :: nbvac integer, public :: nbcoil_max integer, public :: nlim integer, public :: nlim_max integer, public :: nsets integer, public :: nrgrid integer, public :: nzgrid integer, public, DIMENSION(:), ALLOCATABLE :: needflx integer, public, DIMENSION(:), ALLOCATABLE :: nbcoils integer, public, DIMENSION(:), ALLOCATABLE :: limitr integer, public, DIMENSION(:), ALLOCATABLE :: nsetsn integer, public, DIMENSION(:,:), ALLOCATABLE :: iconnect integer, public, DIMENSION(:,:), ALLOCATABLE :: needbfld real(kind=rprec), public :: rminb real(kind=rprec), public :: zminb real(kind=rprec), public :: rmaxb real(kind=rprec), public :: zmaxb real(kind=rprec), public :: delrb real(kind=rprec), public :: delzb real(kind=rprec), public :: rx1 real(kind=rprec), public :: rx2 real(kind=rprec), public :: zy1 real(kind=rprec), public :: zy2 real(kind=rprec), public :: condif real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE, TARGET :: bvac real(kind=rprec), public, DIMENSION(:,:,:), POINTER :: brvac real(kind=rprec), public, DIMENSION(:,:,:), POINTER :: bzvac real(kind=rprec), public, DIMENSION(:,:,:), POINTER :: bpvac real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: unpsiext real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: plbfld real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: rbcoil real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: zbcoil real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: abcoil real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: bcoil real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: rbcoilsqr real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: raw_coil_current real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: xobser real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: zobser real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: xobsqr real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: dsiext real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: psiext real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: plflux real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: b_chi character(len=300), public :: mgrid_path character(len=300), public :: mgrid_path_old = \" \" character(len=30), public, DIMENSION(:), ALLOCATABLE :: curlabel character(len=15), public, DIMENSION(:), ALLOCATABLE :: dsilabel character(len=15), public, DIMENSION(:), ALLOCATABLE :: bloopnames character(len=30), public :: tokid real(kind=rprec), public, DIMENSION(:,:,:), ALLOCATABLE :: dbcoil real(kind=rprec), public, DIMENSION(:,:,:), ALLOCATABLE :: pfcspec real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: rlim real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: zlim real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: reslim real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: seplim character(len=1), public :: mgrid_mode integer, public, DIMENSION(nbsetsp) :: nbfld logical, public :: lpofr logical, public :: lmac logical, public :: lfreeb logical, public :: lrecon logical, public :: loldout logical, public :: ledge_dump logical, public :: lforbal logical, public :: lmovie logical, public :: lmove_axis logical, public :: lwouttxt logical, public :: ldiagno logical, public :: logical, public :: lgiveup real(kind=rprec), public :: fgiveup logical, public :: lbsubs integer, public :: nfp integer, public :: ns integer, public :: mpol integer, public :: ntor integer, public :: mnmax integer, public :: mnmax_nyq integer, public :: itfsq integer, public :: niter integer, public :: iasym integer, public :: ireconstruct integer, public :: ierr_vmec integer, public :: imse integer, public :: itse integer, public :: nstore_seq integer, public :: isnodes integer, public :: ipnodes integer, public :: imatch_phiedge integer, public :: isigng integer, public :: mnyq integer, public :: nnyq integer, public :: ntmax integer, public :: vmec_type real(kind=rprec), public :: wb real(kind=rprec), public :: wp real(kind=rprec), public :: gamma real(kind=rprec), public :: pfac real(kind=rprec), public :: rmax_surf real(kind=rprec), public :: rmin_surf real(kind=rprec), public :: zmax_surf real(kind=rprec), public :: aspect real(kind=rprec), public :: betatot real(kind=rprec), public :: betapol real(kind=rprec), public :: betator real(kind=rprec), public :: betaxis real(kind=rprec), public :: b0 real(kind=rprec), public :: tswgt real(kind=rprec), public :: msewgt real(kind=rprec), public :: flmwgt real(kind=rprec), public :: bcwgt real(kind=rprec), public :: phidiam real(kind=rprec), public :: version_ real(kind=rprec), public :: delphid real(kind=rprec), public :: IonLarmor real(kind=rprec), public :: VolAvgB real(kind=rprec), public :: fsql real(kind=rprec), public :: fsqr real(kind=rprec), public :: fsqz real(kind=rprec), public :: ftolv real(kind=rprec), public :: Aminor real(kind=rprec), public :: Rmajor real(kind=rprec), public :: Volume real(kind=rprec), public :: RBtor real(kind=rprec), public :: RBtor0 real(kind=rprec), public :: Itor real(kind=rprec), public :: machsq real(kind=rprec), public, ALLOCATABLE :: rzl_local (:,:,:,:) real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: rmnc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: zmns real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: lmns real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: rmns real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: zmnc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: lmnc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: bmnc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: gmnc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: bsubumnc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: bsubvmnc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: bsubsmns real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: bsupumnc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: bsupvmnc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: currvmnc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: currumnc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: bbc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: raxis real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: zaxis real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: bmns real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: gmns real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: bsubumns real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: bsubvmns real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: bsubsmnc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: bsupumns real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: bsupvmns real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: currumns real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: currvmns real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: pparmnc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: ppermnc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: hotdmnc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: pbprmnc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: ppprmnc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: sigmnc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: taumnc real(kind=rprec), public, DIMENSION(:,:), ALLOCATABLE :: real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: iotas real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: iotaf real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: presf real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: phipf real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: mass real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: pres real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: beta_vol real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: xm real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: xn real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: qfact real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: chipf real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: phi real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: chi real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: xm_nyq real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: xn_nyq real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: phip real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: buco real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: bvco real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: vp real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: overr real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: jcuru real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: jcurv real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: specw real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: jdotb real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: bdotgradv real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: fsqt real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: wdot real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: am real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: ac real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: ai real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: am_aux_s real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: am_aux_f real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: ac_aux_s real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: ac_aux_f real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: ai_aux_s real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: ai_aux_f real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: Dmerc real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: Dshear real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: Dwell real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: Dcurr real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: Dgeod real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: equif real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: extcur real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: sknots real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: ystark real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: y2stark real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: pknots real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: ythom real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: y2thom real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: anglemse real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: rmid real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: qmid real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: shear real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: presmid real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: alfa real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: curmid real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: rstark real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: qmeas real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: datastark real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: rthom real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: datathom real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: dsiobt real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: potvac real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: pmap real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: omega real(kind=rprec), public, DIMENSION(:), ALLOCATABLE :: tpotb logical, public :: lasym logical, public :: lthreed logical, public :: lwout_opened = .false. logical, public :: lrfp = .false. character(len=1), public :: mgrid_file *200 character(len=1), public :: input_extension *100 character(len=1), public :: pmass_type *20 character(len=1), public :: pcurr_type *20 character(len=1), public :: piota_type *20 integer, private, parameter :: norm_term_flag = 0 integer, private, parameter :: bad_jacobian_flag = 1 integer, private, parameter :: more_iter_flag = 2 integer, private, parameter :: jac75_flag = 4 Interfaces public        interface read_wout_file public  subroutine readw_and_open (file_or_extension, ierr, iopen) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_or_extension integer, intent(out) :: ierr integer, optional :: iopen public  subroutine readw_only (iunit, ierr, iopen) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iunit integer, intent(out) :: ierr integer, optional :: iopen Subroutines public  subroutine readw_and_open (file_or_extension, ierr, iopen) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_or_extension integer, intent(out) :: ierr integer, optional :: iopen public  subroutine readw_only (iunit, ierr, iopen) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iunit integer, intent(out) :: ierr integer, optional :: iopen private  subroutine read_wout_text (iunit, ierr) Arguments Type Intent Optional Attributes Name integer :: iunit integer :: ierr private  subroutine read_wout_nc (filename, ierr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer, intent(out) :: ierr public  subroutine write_wout_text (filename, ierr) Arguments Type Intent Optional Attributes Name character(len=*) :: filename integer, intent(out) :: ierr public  subroutine Compute_Currents (ierror) Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierror public  subroutine read_wout_deallocate (ierr) Arguments Type Intent Optional Attributes Name integer, intent(out) :: ierr","tags":"","loc":"module/read_wout_mod.html"},{"title":"vmec_to_stella_geometry_interface_mod – stella","text":"Variables Type Visibility Attributes Name Initial real, private :: theta_pest_target real, private :: zeta0 real, private, dimension(2) :: vmec_radial_weight_full real, private, dimension(2) :: vmec_radial_weight_half integer, private, dimension(2) :: vmec_radial_index_full integer, private, dimension(2) :: vmec_radial_index_half logical, private :: lasym integer, private :: nfp integer, private :: isigng integer, private :: ns integer, private :: mnmax integer, private :: mnmax_nyq integer, private :: mpol integer, private :: ntor real, private :: Aminor real, private, dimension(:), allocatable :: xm real, private, dimension(:), allocatable :: xn real, private, dimension(:), allocatable :: xm_nyq real, private, dimension(:), allocatable :: xn_nyq real, private, dimension(:, :), allocatable :: rmnc real, private, dimension(:, :), allocatable :: rmns real, private, dimension(:, :), allocatable :: lmnc real, private, dimension(:, :), allocatable :: lmns real, private, dimension(:, :), allocatable :: zmnc real, private, dimension(:, :), allocatable :: zmns real, private, dimension(:, :), allocatable :: bmnc real, private, dimension(:, :), allocatable :: bmns real, private, dimension(:, :), allocatable :: gmnc real, private, dimension(:, :), allocatable :: gmns real, private, dimension(:, :), allocatable :: bsupumnc real, private, dimension(:, :), allocatable :: bsupumns real, private, dimension(:, :), allocatable :: bsupvmnc real, private, dimension(:, :), allocatable :: bsupvmns real, private, dimension(:, :), allocatable :: bsubumnc real, private, dimension(:, :), allocatable :: bsubumns real, private, dimension(:, :), allocatable :: bsubvmnc real, private, dimension(:, :), allocatable :: bsubvmns real, private, dimension(:, :), allocatable :: bsubsmnc real, private, dimension(:, :), allocatable :: bsubsmns real, private, dimension(:), allocatable :: phi real, private, dimension(:), allocatable :: phip real, private, dimension(:), allocatable :: iotas real, private, dimension(:), allocatable :: iotaf real, private, dimension(:), allocatable :: presf Functions private  function fzero_residual (theta_vmec_try) Arguments Type Intent Optional Attributes Name real :: theta_vmec_try Return Value real Subroutines public  subroutine read_vmec_equilibrium (vmec_filename, verbose, ierr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: vmec_filename logical, intent(in) :: verbose integer, intent(out) :: ierr public  subroutine get_nominal_vmec_zeta_grid (new_zeta_min, stellarator_symmetric_BC, nzgrid, zeta_center, number_of_field_periods_stella, number_of_field_periods_device, zeta) Arguments Type Intent Optional Attributes Name real, intent(in) :: new_zeta_min logical, intent(in) :: stellarator_symmetric_BC integer, intent(in) :: nzgrid real, intent(in) :: zeta_center real, intent(inout) :: number_of_field_periods_stella real, intent(out) :: number_of_field_periods_device real, intent(out), dimension(-nzgrid:) :: zeta public  subroutine vmec_to_stella_geometry_interface (nalpha, alpha0, nzgrid, zeta_center, number_of_field_periods_to_include, desired_normalized_toroidal_flux, vmec_surface_option, verbose, normalized_toroidal_flux_used, safety_factor_q, shat, L_reference, B_reference, nfp_out, sign_toroidal_flux, alpha, zeta, bmag, gradpar_zeta, grad_alpha_grad_alpha, grad_alpha_grad_psi, grad_psi_grad_psi, gds23, gds24, gds25, gds26, gbdrift_alpha, gbdrift0_psi, cvdrift_alpha, cvdrift0_psi, theta_vmec, B_sub_zeta, B_sub_theta_vmec, x_displacement_fac, gradpar_zeta_prefac, ierr) Input parameters Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: nalpha real, intent(in) :: alpha0 integer, intent(in) :: nzgrid real, intent(in) :: zeta_center real, intent(in) :: number_of_field_periods_to_include real, intent(in) :: desired_normalized_toroidal_flux integer, intent(in) :: vmec_surface_option logical, intent(in) :: verbose Output quantities Read more… real, intent(out) :: normalized_toroidal_flux_used real, intent(out) :: safety_factor_q real, intent(out) :: shat real, intent(out) :: L_reference real, intent(out) :: B_reference real, intent(out) :: nfp_out integer, intent(out) :: sign_toroidal_flux real, intent(out), dimension(:) :: alpha real, intent(out), dimension(-nzgrid:) :: zeta real, intent(out), dimension(:, -nzgrid:) :: bmag real, intent(out), dimension(:, -nzgrid:) :: gradpar_zeta real, intent(out), dimension(:, -nzgrid:) :: grad_alpha_grad_alpha real, intent(out), dimension(:, -nzgrid:) :: grad_alpha_grad_psi real, intent(out), dimension(:, -nzgrid:) :: grad_psi_grad_psi real, intent(out), dimension(:, -nzgrid:) :: gds23 real, intent(out), dimension(:, -nzgrid:) :: gds24 real, intent(out), dimension(:, -nzgrid:) :: gds25 real, intent(out), dimension(:, -nzgrid:) :: gds26 real, intent(out), dimension(:, -nzgrid:) :: gbdrift_alpha real, intent(out), dimension(:, -nzgrid:) :: gbdrift0_psi real, intent(out), dimension(:, -nzgrid:) :: cvdrift_alpha real, intent(out), dimension(:, -nzgrid:) :: cvdrift0_psi real, intent(out), dimension(:, -nzgrid:) :: theta_vmec real, intent(out), dimension(:, -nzgrid:) :: B_sub_zeta real, intent(out), dimension(:, -nzgrid:) :: B_sub_theta_vmec real, intent(out), dimension(:, -nzgrid:) :: x_displacement_fac real, intent(in) :: gradpar_zeta_prefac integer, intent(out) :: ierr private  subroutine get_root (a0, b0, root, converged) Arguments Type Intent Optional Attributes Name real, intent(in) :: a0 real, intent(in) :: b0 real, intent(out) :: root logical, intent(out) :: converged public  subroutine desired_zmin (nalpha, nzgrid, zeta, twist_shift_factor_full, dkx_over_dky, new_zeta_min) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nalpha integer, intent(in) :: nzgrid real, intent(in), dimension(nalpha, -nzgrid:nzgrid) :: zeta real, intent(in), dimension(nalpha, -nzgrid:nzgrid) :: twist_shift_factor_full real, intent(in) :: dkx_over_dky real, intent(out) :: new_zeta_min","tags":"","loc":"module/vmec_to_stella_geometry_interface_mod.html"},{"title":"coll_dougherty – stella","text":"Variables Type Visibility Attributes Name Initial logical, private :: vpa_operator logical, private :: mu_operator logical, private :: momentum_conservation logical, private :: energy_conservation integer, private :: nresponse_vpa = 1 integer, private :: nresponse_mu = 1 real, private, dimension(:, :), allocatable :: aa_vpa real, private, dimension(:, :), allocatable :: bb_vpa real, private, dimension(:, :), allocatable :: cc_vpa real, private, dimension(:, :, :), allocatable :: aa_mu real, private, dimension(:, :, :), allocatable :: cc_mu real, private, dimension(:, :), allocatable :: bb_mu complex, private, dimension(:, :, :), allocatable :: vpadiff_response integer, private, dimension(:, :), allocatable :: vpadiff_idx complex, private, dimension(:, :, :), allocatable :: mudiff_response integer, private, dimension(:, :), allocatable :: mudiff_idx complex, private, dimension(:, :, :), allocatable :: vpadiff_zf_response integer, private, dimension(:, :), allocatable :: vpadiff_zf_idx complex, private, dimension(:, :, :), allocatable :: mudiff_zf_response integer, private, dimension(:, :), allocatable :: mudiff_zf_idx logical, private :: dougherty_initialized = .false. Subroutines public  subroutine read_parameters_dougherty () Arguments None public  subroutine init_collisions_dougherty (collisions_implicit, cfl_dt_vpadiff, cfl_dt_mudiff) Arguments Type Intent Optional Attributes Name logical, intent(in) :: collisions_implicit real, intent(out) :: cfl_dt_vpadiff real, intent(out) :: cfl_dt_mudiff private  subroutine init_vpadiff_matrix () Arguments None private  subroutine init_mudiff_matrix () Arguments None private  subroutine init_vpadiff_conserve () Arguments None private  subroutine init_mudiff_conserve () Arguments None public  subroutine finish_collisions_dougherty () Arguments None private  subroutine finish_vpadiff_matrix () Arguments None private  subroutine finish_mudiff_matrix () Arguments None private  subroutine finish_vpadiff_response () Arguments None private  subroutine finish_mudiff_response () Arguments None private  subroutine get_upar (g, fld) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: fld private  subroutine get_uperp (g, fld) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: fld private  subroutine get_temp (g, fld) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: fld private  subroutine get_temp_mu (g, fld) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: fld public  subroutine advance_collisions_dougherty_explicit (g, phi, bpar, gke_rhs, time_collisions) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(in), dimension(:, :, -nzgrid:, :) :: bpar complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gke_rhs real, intent(inout), dimension(:, :) :: time_collisions private  subroutine vpa_differential_operator (tfac, h, Dh) Arguments Type Intent Optional Attributes Name real, intent(in) :: tfac complex, intent(in), dimension(:) :: h complex, intent(out), dimension(:) :: Dh private  subroutine mu_differential_operator (tfac, iz, ia, h, Dh) Arguments Type Intent Optional Attributes Name real, intent(in) :: tfac integer, intent(in) :: iz integer, intent(in) :: ia complex, intent(in), dimension(:) :: h complex, intent(out), dimension(:) :: Dh private  subroutine conserve_momentum (iky, ikx, iz, is, ikxkyz, h, Ch) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: is integer, intent(in) :: ikxkyz complex, intent(in), dimension(:, :) :: h complex, intent(inout), dimension(:, :) :: Ch private  subroutine conserve_energy (iz, is, ikxkyz, h, Ch) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iz integer, intent(in) :: is integer, intent(in) :: ikxkyz complex, intent(in), dimension(:, :) :: h complex, intent(inout), dimension(:, :) :: Ch private  subroutine conserve_momentum_vmulo (h, gke_rhs) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: h complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gke_rhs private  subroutine conserve_energy_vmulo (h, gke_rhs) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: h complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gke_rhs public  subroutine advance_collisions_dougherty_implicit (phi, apar, bpar) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :) :: apar complex, intent(inout), dimension(:, :, -nzgrid:, :) :: bpar private  subroutine advance_vpadiff_implicit (phi, apar, bpar, g) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :) :: apar complex, intent(inout), dimension(:, :, -nzgrid:, :) :: bpar complex, intent(inout), dimension(:, :, kxkyz_lo%llim_proc:) :: g private  subroutine advance_mudiff_implicit (phi, apar, bpar, g) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :) :: apar complex, intent(inout), dimension(:, :, -nzgrid:, :) :: bpar complex, intent(inout), dimension(:, :, kxkyz_lo%llim_proc:) :: g","tags":"","loc":"module/coll_dougherty.html"},{"title":"ezcdf – stella","text":"Uses ezcdf_opncls ezcdf_GenGet","tags":"","loc":"module/ezcdf.html"},{"title":"sources – stella","text":"Variables Type Visibility Attributes Name Initial logical, private :: krook_odd logical, public :: exclude_boundary_regions logical, private :: from_zero logical, private :: conserve_momentum logical, private :: conserve_density integer, private :: ikxmax_source real, private :: nu_krook real, public :: tcorr_source real, public :: int_krook real, public :: int_proj real, public :: exp_fac logical, public :: qn_source_initialized logical, public :: include_qn_source logical, private :: debug = .false. real, public, dimension(2, 2) :: time_sources = 0. integer, public :: source_option_switch integer, public, parameter :: source_option_none = 1 integer, public, parameter :: source_option_krook = 2 integer, public, parameter :: source_option_projection = 3 Subroutines public  subroutine init_sources () Arguments None private  subroutine read_parameters () Arguments None public  subroutine init_source_timeaverage () Arguments None public  subroutine finish_sources () Arguments None public  subroutine add_krook_operator (g, gke_rhs) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:), target :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gke_rhs public  subroutine update_tcorr_krook (g) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:), target :: g private  subroutine enforce_momentum_conservation (g_work) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g_work private  subroutine enforce_density_conservation (g_work) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, -nzgrid:, :, vmu_lo%llim_proc:) :: g_work public  subroutine project_out_zero (gold, gnew) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gold complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gnew public  subroutine init_quasineutrality_source () Arguments None public  subroutine update_quasineutrality_source () Arguments None","tags":"","loc":"module/sources.html"},{"title":"species – stella","text":"Uses common_types Variables Type Visibility Attributes Name Initial integer, public, parameter :: ion_species = 1 integer, public, parameter :: electron_species = 2 integer, public, parameter :: slowing_down_species = 3 integer, public, parameter :: tracer_species = 4 integer, private :: species_option_switch integer, private, parameter :: species_option_stella = 1 integer, private, parameter :: species_option_inputprofs = 2 integer, private, parameter :: species_option_euterpe = 3 integer, private, parameter :: species_option_multibox = 4 integer, public :: nspec logical, private :: read_profile_variation logical, private :: write_profile_variation logical, private :: ecoll_zeff logical, public :: modified_adiabatic_electrons logical, public :: adiabatic_electrons type( spec_type ), public, dimension(:), allocatable :: spec integer, public :: ions integer, public :: electrons integer, public :: impurity real, public :: pfac character(len=20), private :: species_option logical, private :: initialized = .false. Functions public pure function has_electron_species (spec) Arguments Type Intent Optional Attributes Name type( spec_type ), intent(in), dimension(:) :: spec Return Value logical public pure function has_slowing_down_species (spec) Arguments Type Intent Optional Attributes Name type( spec_type ), intent(in), dimension(:) :: spec Return Value logical Subroutines public  subroutine init_species () Arguments None public  subroutine read_species_knobs () Arguments None private  subroutine read_species_stella () Arguments None private  subroutine broadcast_parameters () Arguments None public  subroutine finish_species () Arguments None public  subroutine reinit_species (ntspec, dens, temp, fprim, tprim, bess_fac) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ntspec real, intent(in), dimension(:) :: dens real, intent(in), dimension(:) :: temp real, intent(in), dimension(:) :: fprim real, intent(in), dimension(:) :: tprim real, intent(in), dimension(:) :: bess_fac public  subroutine communicate_species_multibox (dr_m, dr_p) Arguments Type Intent Optional Attributes Name real, intent(in), optional :: dr_m real, intent(in), optional :: dr_p private  subroutine dump_species_input () Arguments None","tags":"","loc":"module/species.html"},{"title":"implicit_solve – stella","text":"Variables Type Visibility Attributes Name Initial real, public, dimension(2, 3) :: time_implicit_advance = 0. Subroutines public  subroutine advance_implicit_terms (g, phi, apar, bpar) dist_choice indicates whether the non-Boltzmann part of the pdf (h) is evolved\nin parallel streaming or if the guiding centre distribution (g = ) is evolved\nif using delphi formulation for response matrix, then phi = phi&#94;n replaces\nphi&#94;{n+1} in the inhomogeneous GKE; else set phi_{n+1} to zero in inhomogeneous equation\nIf using deltaphi formulation, must account for fact that phi = phi&#94;{n+1}-phi&#94;{n*}, but\ntupwnd_p should multiply phi&#94;{n+1} Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :) :: apar complex, intent(inout), dimension(:, :, -nzgrid:, :) :: bpar public  subroutine get_gke_rhs (ivmu, iky, ie, pdf, phi, apar, aparnew, aparold, bpar, rhs) get_gke_rhs calculates the RHS of the GK equation.\nas the response matrix approach requires separate solution of the 'inhomogeneous' GKE,\nthe homogeneous GKE (to obtain the response matrix itself),\nand the full GKE, which RHS is obtained depends on the input values\nfor 'pdf', 'phi', 'apar', 'aparnew' and 'aparold' Arguments Type Intent Optional Attributes Name integer, intent(in) :: ivmu integer, intent(in) :: iky integer, intent(in) :: ie complex, intent(in), dimension(:) :: pdf complex, intent(in), dimension(:) :: phi complex, intent(in), dimension(:) :: apar complex, intent(in), dimension(:) :: aparnew complex, intent(in), dimension(:) :: aparold complex, intent(in), dimension(:) :: bpar complex, intent(out), dimension(:) :: rhs private  subroutine get_contributions_from_fields (phi, apar, aparnew, bpar, ivmu, iky, ie, scratch, rhs) get_contributions_from_fields takes as input the appropriately averaged\nelectrostatic potential phi and magnetic vector potential components apar\nand returns in rhs the sum of the source terms\ninvolving phi and apar that appear on the RHS of the GK equation when g is the pdf Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: phi complex, intent(in), dimension(:) :: apar complex, intent(in), dimension(:) :: aparnew complex, intent(in), dimension(:) :: bpar integer, intent(in) :: ivmu integer, intent(in) :: iky integer, intent(in) :: ie complex, intent(out), dimension(:) :: scratch complex, intent(out), dimension(:) :: rhs private  subroutine get_contributions_from_phi (phi, ivmu, iky, iz_from_izext, ikx_from_izext, scratch, rhs) get_contributions_from_phi takes as input the appropriately averaged\nelectrostatic potential phi and returns in rhs the sum of the source terms\ninvolving phi that appear on the RHS of the GK equation when g is the pdf Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: phi integer, intent(in) :: ivmu integer, intent(in) :: iky integer, intent(in), dimension(:) :: iz_from_izext integer, intent(in), dimension(:) :: ikx_from_izext complex, intent(out), dimension(:) :: scratch complex, intent(out), dimension(:) :: rhs private  subroutine get_contributions_from_bpar (bpar, ivmu, iky, iz_from_izext, ikx_from_izext, scratch, rhs) get_contributions_from_bpar takes as input the appropriately averaged\nelectrostatic potential bpar and returns in rhs the sum of the source terms\ninvolving bpar that appear on the RHS of the GK equation when g is the pdf Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: bpar integer, intent(in) :: ivmu integer, intent(in) :: iky integer, intent(in), dimension(:) :: iz_from_izext integer, intent(in), dimension(:) :: ikx_from_izext complex, intent(out), dimension(:) :: scratch complex, intent(out), dimension(:) :: rhs private  subroutine get_contributions_from_apar (apar, aparnew, ivmu, iky, iz_from_izext, ikx_from_izext, scratch, rhs) get_contributions_from_apar takes as input the appropriately averaged\nparallel component of the vector potential, apar, and returns in rhs the sum of the source terms\ninvolving apar that appear on the RHS of the GK equation when g is the pdf Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: apar complex, intent(in), dimension(:) :: aparnew integer, intent(in) :: ivmu integer, intent(in) :: iky integer, intent(in), dimension(:) :: iz_from_izext integer, intent(in), dimension(:) :: ikx_from_izext complex, intent(out), dimension(:) :: scratch complex, intent(inout), dimension(:) :: rhs private  subroutine add_gbar_to_g_contribution_apar (scratch2, iky, ia, iv, imu, is, nz_ext, iz_from_izext, rhs) adds the contributions to the GKE RHS that comes from switching from\ngbar&#94;{n+1} = g&#94;{n+1} + (Ze/T) (vpa/c) *F0 to g&#94;{n+1} = in the time derivative; Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: scratch2 integer, intent(in) :: iky integer, intent(in) :: ia integer, intent(in) :: iv integer, intent(in) :: imu integer, intent(in) :: is integer, intent(in) :: nz_ext integer, intent(in), dimension(:) :: iz_from_izext complex, intent(inout), dimension(:) :: rhs private  subroutine add_drifts_contribution_apar (scratch, iky, ia, ivmu, iv, is, nz_ext, iz_from_izext, rhs) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: scratch integer, intent(in) :: iky integer, intent(in) :: ia integer, intent(in) :: ivmu integer, intent(in) :: iv integer, intent(in) :: is integer, intent(in) :: nz_ext integer, intent(in), dimension(:) :: iz_from_izext complex, intent(inout), dimension(:) :: rhs private  subroutine gbar_to_g_zext (pdf, apar, facapar, iky, ivmu, ikx_from_izext, iz_from_izext) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: pdf complex, intent(in), dimension(:) :: apar real, intent(in) :: facapar integer, intent(in) :: iky integer, intent(in) :: ivmu integer, intent(in), dimension(:) :: ikx_from_izext integer, intent(in), dimension(:) :: iz_from_izext private  subroutine gyro_average_zext (iky, ivmu, ikx_from_izext, iz_from_izext, fld, gyro_fld) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky integer, intent(in) :: ivmu integer, intent(in), dimension(:) :: ikx_from_izext integer, intent(in), dimension(:) :: iz_from_izext complex, intent(in), dimension(:) :: fld complex, intent(out), dimension(:) :: gyro_fld private  subroutine gyro_average_j1_zext (iky, ivmu, ikx_from_izext, iz_from_izext, fld, gyro_fld) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky integer, intent(in) :: ivmu integer, intent(in), dimension(:) :: ikx_from_izext integer, intent(in), dimension(:) :: iz_from_izext complex, intent(in), dimension(:) :: fld complex, intent(out), dimension(:) :: gyro_fld private  subroutine get_contributions_from_pdf (pdf, apar, ivmu, iky, ie, rhs) get_contributions_from_pdf takes as an argument the evolved pdf\n(either guiding centre distribution g= or maxwellian-normlized, non-Boltzmann distribution h/F0=f/F0+(Ze*phi/T))\nand the scratch array rhs, and returns the source terms that depend on the pdf in rhs Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: pdf complex, intent(in), dimension(:) :: apar integer, intent(in) :: ivmu integer, intent(in) :: iky integer, intent(in) :: ie complex, intent(out), dimension(:) :: rhs public  subroutine sweep_g_zext (iky, ie, it, ivmu, pdf) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky integer, intent(in) :: ie integer, intent(in) :: it integer, intent(in) :: ivmu complex, intent(inout), dimension(:) :: pdf private  subroutine get_updated_pdf (iz, iv, is, sgn, iz1, iz2, wdrift_ext, pdf) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: iz integer, intent(in) :: iv integer, intent(in) :: is integer, intent(in) :: sgn integer, intent(in) :: iz1 integer, intent(in) :: iz2 complex, intent(in), dimension(:) :: wdrift_ext complex, intent(inout), dimension(:) :: pdf public  subroutine sweep_zed_zonal (iky, iv, is, sgn, g, llim) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky integer, intent(in) :: iv integer, intent(in) :: is integer, intent(in) :: sgn complex, intent(inout), dimension(llim:) :: g integer, intent(in) :: llim private  subroutine invert_parstream_response (phi, apar, bpar) use the LU-decomposed response matrix and the contributions from the\n'inhomogeneous' fields (phi, apar) to solve for (phi&#94;{n+1}, apar&#94;{n+1}) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :) :: apar complex, intent(inout), dimension(:, :, -nzgrid:, :) :: bpar","tags":"","loc":"module/implicit_solve.html"},{"title":"stella_io – stella","text":"Variables Type Visibility Attributes Name Initial real, private, parameter :: zero = epsilon(0.0) Subroutines public  subroutine init_stella_io (restart) Arguments Type Intent Optional Attributes Name logical, intent(in) :: restart Is this run a restart? private  subroutine write_grids (file_id) Ensure the netCDF file contains all the dimensions and grids,\ncreating them if necessary Arguments Type Intent Optional Attributes Name integer, intent(in) :: file_id NetCDF ID of the file public  subroutine finish_stella_io () Arguments None private  subroutine save_input (file_id) Save the input file in the NetCDF file Arguments Type Intent Optional Attributes Name integer, intent(in) :: file_id NetCDF ID of the file to write to private  subroutine define_vars () Arguments None public  subroutine write_time_nc (nout, time) Write simulation time to netCDF output file Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout Current timestep real, intent(in) :: time Current simulation time public  subroutine write_phi2_nc (nout, phi2) Write amplitude of electrostatic potential to netCDF Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout Current timestep real, intent(in) :: phi2 Amplitude of electrostatic potential public  subroutine write_apar2_nc (nout, apar2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout Current timestep real, intent(in) :: apar2 Amplitude of parallel vector potential public  subroutine write_bpar2_nc (nout, bpar2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout Current timestep real, intent(in) :: bpar2 Amplitude of parallel vector potential public  subroutine write_phi_nc (nout, phi) Write time trace of electrostatic potential to netCDF Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout Current timestep complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi Electrostatic potential public  subroutine write_apar_nc (nout, apar) Write time trace of electromagnetic field A|| to netCDF Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout Current timestep complex, intent(in), dimension(:, :, -nzgrid:, :) :: apar public  subroutine write_bpar_nc (nout, bpar) Write time trace of electromagnetic field B|| to netCDF Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout Current timestep complex, intent(in), dimension(:, :, -nzgrid:, :) :: bpar public  subroutine write_omega_nc (nout, omega) Write the complex frequency to netCDF Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout complex, intent(in), dimension(:, :) :: omega public  subroutine write_radial_fluxes_nc (nout, pflux, vflux, qflux) Write fluxes to netCDF Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout Current timestep real, intent(in), dimension(:, :) :: pflux Particle, velocity, heat flux real, intent(in), dimension(:, :) :: vflux Particle, velocity, heat flux real, intent(in), dimension(:, :) :: qflux Particle, velocity, heat flux public  subroutine write_radial_moments_nc (nout, dens_x, upar_x, temp_x) Write radial moments to netCDF Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout Current timestep real, intent(in), dimension(:, :) :: dens_x Radial moments for density, parallel velocity, temperature real, intent(in), dimension(:, :) :: upar_x Radial moments for density, parallel velocity, temperature real, intent(in), dimension(:, :) :: temp_x Radial moments for density, parallel velocity, temperature public  subroutine write_kspectra_nc (nout, field_vs_kxky, keyname, longname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout Current timestep real, intent(in), dimension(:, :) :: field_vs_kxky character(len=*), intent(in) :: keyname character(len=*), intent(in) :: longname public  subroutine write_kspectra_species_nc (nout, field_vs_kxkys, keyname, longname) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout Current timestep real, intent(in), dimension(:, :, :) :: field_vs_kxkys character(len=*), intent(in) :: keyname character(len=*), intent(in) :: longname public  subroutine write_fluxes_nc (nout, pflx, vflx, qflx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout Current timestep real, intent(in), dimension(:) :: pflx real, intent(in), dimension(:) :: vflx real, intent(in), dimension(:) :: qflx public  subroutine write_fluxes_kxkyz_nc (nout, pflx_kxkyz, vflx_kxkyz, qflx_kxkyz) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout Current timestep real, intent(in), dimension(:, :, :, :, :) :: pflx_kxkyz real, intent(in), dimension(:, :, :, :, :) :: vflx_kxkyz real, intent(in), dimension(:, :, :, :, :) :: qflx_kxkyz public  subroutine write_moments_nc (nout, density, upar, temperature, spitzer2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout complex, intent(in), dimension(:, :, :, :, :) :: density complex, intent(in), dimension(:, :, :, :, :) :: upar complex, intent(in), dimension(:, :, :, :, :) :: temperature complex, intent(in), dimension(:, :, :, :, :) :: spitzer2 public  subroutine write_gvmus_nc (nout, gvmus) Write guiding center distribution function averaged over real space Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout Current timestep real, intent(in), dimension(:, :, :) :: gvmus Guiding centre distribution function public  subroutine write_gzvs_nc (nout, gzvs) Write guiding center distribution function averaged over (kx, ky, mu) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nout Current timestep real, intent(in), dimension(:, :, :, :) :: gzvs Guiding centre distribution function private  subroutine nc_species (file_id) Write spec to output netCDF file Arguments Type Intent Optional Attributes Name integer, intent(in) :: file_id NetCDF ID of the file to write to private  subroutine nc_geo (file_id) Write various geometric quantities to output netCDF file Arguments Type Intent Optional Attributes Name integer, intent(in) :: file_id NetCDF ID of the file to write to public  subroutine get_nout (tstart, nout) Get the index of the time dimension in the netCDF file that corresponds to\na time no larger than tstart Arguments Type Intent Optional Attributes Name real, intent(in) :: tstart Simulation time to find integer, intent(out) :: nout Index of time dimension public  subroutine sync_nc () Flush netCDF file to disk Arguments None private  subroutine write_complex_rank2 (parent_id, name, values, dim_names, units, long_name, start) Arguments Type Intent Optional Attributes Name integer, intent(in) :: parent_id NetCDF ID of the parent group/file character(len=*), intent(in) :: name Name of the variable complex, intent(in), dimension(:, :) :: values Array to be written character(len=*), intent(in), dimension(:) :: dim_names Array of dimension names character(len=*), intent(in), optional :: units Units of coordinate character(len=*), intent(in), optional :: long_name Long descriptive name integer, intent(in), optional, dimension(:) :: start private  subroutine write_complex_rank4 (parent_id, name, values, dim_names, units, long_name, start) Arguments Type Intent Optional Attributes Name integer, intent(in) :: parent_id NetCDF ID of the parent group/file character(len=*), intent(in) :: name Name of the variable complex, intent(in), dimension(:, :, :, :) :: values Array to be written character(len=*), intent(in), dimension(:) :: dim_names Array of dimension names character(len=*), intent(in), optional :: units Units of coordinate character(len=*), intent(in), optional :: long_name Long descriptive name integer, intent(in), optional, dimension(:) :: start private  subroutine write_complex_rank5 (parent_id, name, values, dim_names, units, long_name, start) Arguments Type Intent Optional Attributes Name integer, intent(in) :: parent_id NetCDF ID of the parent group/file character(len=*), intent(in) :: name Name of the variable complex, intent(in), dimension(:, :, :, :, :) :: values Array to be written character(len=*), intent(in), dimension(:) :: dim_names Array of dimension names character(len=*), intent(in), optional :: units Units of coordinate character(len=*), intent(in), optional :: long_name Long descriptive name integer, intent(in), optional, dimension(:) :: start","tags":"","loc":"module/stella_io.html"},{"title":"vmec_geo – stella","text":"Variables Type Visibility Attributes Name Initial real, public :: alpha0 integer, public :: zgrid_refinement_factor real, public :: zgrid_scalefac real, public :: gradpar_zeta_prefac integer, public :: surface_option real, public :: nfield_periods real, public :: zeta_center real, public :: torflux logical, public :: verbose character(len=2000), public :: vmec_filename integer, public :: n_tolerated_test_arrays_inconsistencies Subroutines public  subroutine read_vmec_parameters () Arguments None public  subroutine init_vmec_defaults () Arguments None public  subroutine get_vmec_geo (new_zeta_min, stellarator_symmetric_BC, nzgrid, nalpha, naky, surf, grho, bmag, gradpar, b_dot_grad_z, grad_alpha_grad_alpha, grad_alpha_grad_psi, grad_psi_grad_psi, gds23, gds24, gds25, gds26, gbdrift_alpha, gbdrift0_psi, cvdrift_alpha, cvdrift0_psi, sign_torflux, theta_vmec, zed_scalefac, L_reference, B_reference, alpha, zeta, field_period_ratio, x_displacement_fac) To avoid writting twice in the output file when recomputing zeta.\nfirst read in equilibrium information from vmec file\nthis is stored as a set of global variables in read_wout_mod\nin mini_libstell.  it will be accessible\nif desired, increase number of sampled zeta grid points in VMEC data\nto increase accuracy of later integration in zeta and interpolation\nonto stella zed grid Read more… Arguments Type Intent Optional Attributes Name real, intent(in) :: new_zeta_min logical, intent(in) :: stellarator_symmetric_BC integer, intent(in) :: nzgrid integer, intent(in) :: nalpha integer, intent(in) :: naky type( flux_surface_type ), intent(out) :: surf real, intent(out), dimension(:, -nzgrid:) :: grho real, intent(out), dimension(:, -nzgrid:) :: bmag real, intent(out), dimension(-nzgrid:) :: gradpar real, intent(out), dimension(:, -nzgrid:) :: b_dot_grad_z real, intent(out), dimension(:, -nzgrid:) :: grad_alpha_grad_alpha real, intent(out), dimension(:, -nzgrid:) :: grad_alpha_grad_psi real, intent(out), dimension(:, -nzgrid:) :: grad_psi_grad_psi real, intent(out), dimension(:, -nzgrid:) :: gds23 real, intent(out), dimension(:, -nzgrid:) :: gds24 real, intent(out), dimension(:, -nzgrid:) :: gds25 real, intent(out), dimension(:, -nzgrid:) :: gds26 real, intent(out), dimension(:, -nzgrid:) :: gbdrift_alpha real, intent(out), dimension(:, -nzgrid:) :: gbdrift0_psi real, intent(out), dimension(:, -nzgrid:) :: cvdrift_alpha real, intent(out), dimension(:, -nzgrid:) :: cvdrift0_psi integer, intent(out) :: sign_torflux real, intent(out), dimension(:, -nzgrid:) :: theta_vmec real, intent(out) :: zed_scalefac real, intent(out) :: L_reference real, intent(out) :: B_reference real, intent(out), dimension(:) :: alpha real, intent(out), dimension(:, -nzgrid:) :: zeta real, intent(out) :: field_period_ratio real, intent(out), dimension(:, -nzgrid:) :: x_displacement_fac public  subroutine filter_geo_coef (naky, geocoef) Arguments Type Intent Optional Attributes Name integer, intent(in) :: naky real, intent(inout), dimension(:) :: geocoef public  subroutine get_modified_vmec_zeta_grid (new_zeta_min, stellarator_symmetric_BC, nzgrid_modified, dzeta_modified) need to extend the maximum and minimum zeta values\nby zgrid_scalefac to ensure that we have information\nabout geometric coefficients everywhere on a fixed\nequal-arc grid in zed\nfirst figure out how many extra zeta grid points are\nrequired at the nominal grid spacing to get out\nto the ends of the extended zeta domain\nfirst calculate the nominal zeta grid used for vmec\nnote that nfield_periods is the number of field periods\nsampled in stella, while nfield_periods_device\nis the number of field periods in the device\nnfield_periods may be reasonably bigger than nfield_periods_device\nas the former is sampled while keeping alpha fixed (rather than theta) Read more… Arguments Type Intent Optional Attributes Name real, intent(in) :: new_zeta_min logical, intent(in) :: stellarator_symmetric_BC integer, intent(out) :: nzgrid_modified real :: dzeta_modified","tags":"","loc":"module/vmec_geo.html"},{"title":"dist_fn_arrays – stella","text":"A container for the arrays that are used to store the distribution function among other things. Variables Type Visibility Attributes Name Initial complex, public, dimension(:, :, :, :, :), allocatable :: gnew complex, public, dimension(:, :, :, :, :), allocatable :: gold complex, public, dimension(:, :, :, :, :), allocatable :: g_scratch complex, public, dimension(:, :, :, :, :), target, allocatable :: g_symm complex, public, dimension(:, :, :, :, :), allocatable :: g0 complex, public, dimension(:, :, :, :, :), allocatable :: g1 complex, public, dimension(:, :, :, :, :), allocatable :: g2 complex, public, dimension(:, :, :, :, :), allocatable :: g3 complex, public, dimension(:, :, :, :), allocatable :: g_krook complex, public, dimension(:, :, :, :), allocatable :: g_proj complex, public, dimension(:, :, :), allocatable :: gvmu real, public, dimension(:, :, :), allocatable :: wstar real, public, dimension(:, :, :), allocatable :: wstarp real, public, dimension(:, :, :), allocatable :: wdriftx_g real, public, dimension(:, :, :), allocatable :: wdrifty_g real, public, dimension(:, :, :), allocatable :: wdriftx_phi real, public, dimension(:, :, :), allocatable :: wdrifty_phi real, public, dimension(:, :, :), allocatable :: wdriftx_bpar real, public, dimension(:, :, :), allocatable :: wdrifty_bpar real, public, dimension(:, :, :), allocatable :: wdriftpx_g real, public, dimension(:, :, :), allocatable :: wdriftpy_g real, public, dimension(:, :, :), allocatable :: wdriftpx_phi real, public, dimension(:, :, :), allocatable :: wdriftpy_phi real, public, dimension(:, :, :, :), allocatable :: kperp2 dkperp2dr will contain the radial variation of kperp2 real, public, dimension(:, :, :, :), allocatable :: dkperp2dr dkperp2dr will contain the radial variation of kperp2","tags":"","loc":"module/dist_fn_arrays.html"},{"title":"fields – stella","text":"Uses common_types mpi Variables Type Visibility Attributes Name Initial real, public, dimension(:, :, :), allocatable :: apar_denom real, public :: gamtot_h real, public :: gamtot3_h real, public :: efac real, public :: efacp type( coupled_alpha_type ), private, dimension(:, :, :), allocatable :: gam0_ffs arrays allocated/used if simulating a full flux surface type( gam0_ffs_type ), private, dimension(:, :), allocatable :: lu_gam0_ffs complex, private, dimension(:), allocatable :: adiabatic_response_factor logical, public :: fields_updated = .false. logical, private :: fields_initialized = .false. logical, private :: debug = .false. integer, private :: zm integer, public :: nfields real, public, dimension(2, 5) :: time_field_solve = 0. Interfaces public        interface get_dchidy private  subroutine get_dchidy_4d (phi, apar, bpar, dchidy) compute d /dy in (ky,kx,z,tube) space include bpar contribution Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(in), dimension(:, :, -nzgrid:, :) :: apar complex, intent(in), dimension(:, :, -nzgrid:, :) :: bpar complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dchidy private  subroutine get_dchidy_2d (iz, ivmu, phi, apar, bpar, dchidy) compute d /dy in (ky,kx) space include bpar contribution Arguments Type Intent Optional Attributes Name integer, intent(in) :: iz integer, intent(in) :: ivmu complex, intent(in), dimension(:, :) :: phi complex, intent(in), dimension(:, :) :: apar complex, intent(in), dimension(:, :) :: bpar complex, intent(out), dimension(:, :) :: dchidy public        interface advance_fields private  subroutine advance_fields_vmu_lo (g, phi, apar, bpar, dist) time the communications + field solve\nfields_kxkyz = F is the default\nfirst gather (vpa,mu) onto processor for v-space operations\nv-space operations are field solve, dg/dvpa, and collisions\ngiven gvmu with vpa and mu local, calculate the corresponding fields\nset a flag to indicate that the fields have been updated\nthis helps avoid unnecessary field solves\ntime the communications + field solve Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: phi complex, intent(out), dimension(:, :, -nzgrid:, :) :: apar complex, intent(out), dimension(:, :, -nzgrid:, :) :: bpar character(len=*), intent(in) :: dist private  subroutine advance_fields_kxkyz_lo (gvmu, phi, apar, bpar, dist) time the communications + field solve given gvmu with vpa and mu local, calculate the corresponding fields\nset a flag to indicate that the fields have been updated\nthis helps avoid unnecessary field solves\ntime the communications + field solve Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: gvmu complex, intent(out), dimension(:, :, -nzgrid:, :) :: phi complex, intent(out), dimension(:, :, -nzgrid:, :) :: apar complex, intent(out), dimension(:, :, -nzgrid:, :) :: bpar character(len=*), intent(in) :: dist Subroutines public  subroutine init_fields () Arguments None private  subroutine init_fields_fluxtube () would be tidier if the code related to radial profile variation\nwere gathered into a separate subroutine or subroutines\ninit_fields_fluxtube allocates and fills arrays needed during main time advance\nloop for the field solve for flux tube simulations Read more… Arguments None private  subroutine init_radial_field_solve () Arguments None private  subroutine init_fields_ffs () init_fields_ffs allocates and fills arrays needed during main time advance\nloop for the field solve for full_flux_surface simulations Read more… Arguments None private  subroutine init_gamma0_factor_ffs () calculate and LU factorise the matrix multiplying the electrostatic potential in quasineutrality\nthis involves the factor 1-Gamma_0(kperp(alpha)) Read more… Arguments None private  subroutine init_adiabatic_response_factor () solves Delta * phi_hom = -delta_{ky,0} * ne/Te for phi_hom\nthis is the vector describing the response of phi_hom to a unit impulse in phi_fsa\nit is the sum over ky and integral over kx of this that is needed, and this\nis stored in adiabatic_response_factor Read more… Arguments None private  subroutine allocate_arrays () Arguments None public  subroutine enforce_reality_field (fin) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: fin private  subroutine advance_fields_vmu_lo (g, phi, apar, bpar, dist) time the communications + field solve\nfields_kxkyz = F is the default\nfirst gather (vpa,mu) onto processor for v-space operations\nv-space operations are field solve, dg/dvpa, and collisions\ngiven gvmu with vpa and mu local, calculate the corresponding fields\nset a flag to indicate that the fields have been updated\nthis helps avoid unnecessary field solves\ntime the communications + field solve Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: phi complex, intent(out), dimension(:, :, -nzgrid:, :) :: apar complex, intent(out), dimension(:, :, -nzgrid:, :) :: bpar character(len=*), intent(in) :: dist private  subroutine advance_fields_kxkyz_lo (gvmu, phi, apar, bpar, dist) time the communications + field solve Read more… Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: gvmu complex, intent(out), dimension(:, :, -nzgrid:, :) :: phi complex, intent(out), dimension(:, :, -nzgrid:, :) :: apar complex, intent(out), dimension(:, :, -nzgrid:, :) :: bpar character(len=*), intent(in) :: dist public  subroutine get_fields (g, phi, apar, bpar, dist, skip_fsa) integrate g to get sum_s Z_s n_s J0 g and store in phi\nintegrate g to get - 2 beta sum_s n_s T_s J1 mu g and store in bpar Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: phi complex, intent(out), dimension(:, :, -nzgrid:, :) :: apar complex, intent(out), dimension(:, :, -nzgrid:, :) :: bpar character(len=*), intent(in) :: dist logical, intent(in), optional :: skip_fsa private  subroutine get_fields_vmulo (g, phi, apar, bpar, dist, skip_fsa) store result in phi, which will be further modified below to account for polarization term\nstore result in phi, which will be further modified below to account for polarization term\nstore result in bpar, which will be further modified below to account for polarization term\nstore result in apar, which will be further modified below to account for apar pre-factor Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: phi complex, intent(out), dimension(:, :, -nzgrid:, :) :: apar complex, intent(out), dimension(:, :, -nzgrid:, :) :: bpar character(len=*), intent(in) :: dist logical, intent(in), optional :: skip_fsa private  subroutine get_fields_ffs (g, phi, apar) get_fields_ffs accepts as input the guiding centre distribution function g\nand calculates/returns the electronstatic potential phi for full_flux_surface simulations Read more… Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: phi complex, intent(out), dimension(:, :, -nzgrid:, :) :: apar public  subroutine get_fields_by_spec (g, fld, skip_fsa) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: fld logical, intent(in), optional :: skip_fsa public  subroutine get_fields_by_spec_idx (isa, g, fld) Arguments Type Intent Optional Attributes Name integer, intent(in) :: isa complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: fld private  subroutine get_phi (phi, dist, skip_fsa) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi character(len=*), intent(in) :: dist logical, intent(in), optional :: skip_fsa private  subroutine get_phi_and_bpar (phi, bpar, dist, skip_fsa) divide sum ( Zs int J0 h d&#94;3 v) by sum(Zs&#94;2 ns / Ts)\ndo nothing for bpar because\nbpar = - 2 * beta * sum(Ts ns int (J1/bs) mu h d&#94;3 v)\nwhich is already stored in bpar when dist = 'h'. Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :) :: bpar character(len=*), intent(in) :: dist logical, intent(in), optional :: skip_fsa private  subroutine get_phi_radial (phi) Non-perturbative approach to solving quasineutrality for radially\nglobal simulations Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi private  subroutine get_apar (apar, dist) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: apar character(len=*), intent(in) :: dist public  subroutine advance_apar (g, dist, apar) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g character(len=*), intent(in) :: dist complex, intent(out), dimension(:, :, -nzgrid:, :) :: apar private  subroutine add_adiabatic_response_radial (phi) Add the adiabatic eletron contribution for globally radial simulations.\nThis actually entails solving for the whole ky = 0 slice of phi at once (not really adding!) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi private  subroutine get_phi_ffs (rhs, phi) change from rhs defined on grid with ky >=0 and kx from 0,...,kxmax,-kxmax,...,-dkx\nto rhs_swap defined on grid with ky = -kymax,...,kymax and kx >= 0\nsolve sum_s Z_s int d&#94;3v = gam0*phi\nwhere sum_s Z_s int d&#94;3v is initially passed in as rhs_swap\nand then rhs_swap is over-written with the solution to the linear system Read more… Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:) :: rhs complex, intent(out), dimension(:, :, -nzgrid:) :: phi private  subroutine add_radial_correction_int_species (g_in) Add radial variation of the Jacobian and gyroaveraing in the velocity integration of , needed for radially global simulations Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g_in public  subroutine get_radial_correction (g, phi0, dist) the following routine gets the correction in phi both from gyroaveraging and quasineutrality Read more… Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi0 character(len=*), intent(in) :: dist public  subroutine rescale_fields (target_amplitude) rescale fields, including the distribution function Arguments Type Intent Optional Attributes Name real, intent(in) :: target_amplitude private  subroutine get_dchidy_4d (phi, apar, bpar, dchidy) compute d /dy in (ky,kx,z,tube) space Read more… Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(in), dimension(:, :, -nzgrid:, :) :: apar complex, intent(in), dimension(:, :, -nzgrid:, :) :: bpar complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dchidy private  subroutine get_dchidy_2d (iz, ivmu, phi, apar, bpar, dchidy) compute d /dy in (ky,kx) space Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: iz integer, intent(in) :: ivmu complex, intent(in), dimension(:, :) :: phi complex, intent(in), dimension(:, :) :: apar complex, intent(in), dimension(:, :) :: bpar complex, intent(out), dimension(:, :) :: dchidy public  subroutine get_dchidx (iz, ivmu, phi, apar, bpar, dchidx) compute d /dx in (ky,kx) space Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: iz integer, intent(in) :: ivmu complex, intent(in), dimension(:, :) :: phi complex, intent(in), dimension(:, :) :: apar complex, intent(in), dimension(:, :) :: bpar complex, intent(out), dimension(:, :) :: dchidx public  subroutine finish_fields () arrays only allocated/used if simulating a full flux surface Arguments None","tags":"","loc":"module/fields.html"},{"title":"ezcdf_GenGet – stella","text":"Uses ezcdf_opncls ezcdf_inqvar Variables Type Visibility Attributes Name Initial integer, private, parameter :: nf_byte = 1 integer, private, parameter :: nf_int1 = nf_byte integer, private, parameter :: nf_char = 2 integer, private, parameter :: nf_short = 3 integer, private, parameter :: nf_int2 = nf_short integer, private, parameter :: nf_int = 4 integer, private, parameter :: nf_float = 5 integer, private, parameter :: nf_real = nf_float integer, private, parameter :: nf_double = 6 integer, private, parameter :: nf_ubyte = 7 integer, private, parameter :: nf_ushort = 8 integer, private, parameter :: nf_uint = 9 integer, private, parameter :: nf_int64 = 10 integer, private, parameter :: nf_uint64 = 11 integer, private, parameter :: nf_fill_byte = -127 integer, private, parameter :: nf_fill_int1 = nf_fill_byte integer, private, parameter :: nf_fill_char = 0 integer, private, parameter :: nf_fill_short = -32767 integer, private, parameter :: nf_fill_int2 = nf_fill_short integer, private, parameter :: nf_fill_int = -2147483647 real, private, parameter :: nf_fill_float = 9.9692099683868690e+36 real, private, parameter :: nf_fill_real = nf_fill_float doubleprecision, private, parameter :: nf_fill_double = 9.9692099683868690d+36 integer, private, parameter :: nf_nowrite = 0 integer, private, parameter :: nf_write = 1 integer, private, parameter :: nf_clobber = 0 integer, private, parameter :: nf_noclobber = 4 integer, private, parameter :: nf_fill = 0 integer, private, parameter :: nf_nofill = 256 integer, private, parameter :: nf_lock = 1024 integer, private, parameter :: nf_share = 2048 integer, private, parameter :: nf_64bit_offset = 512 integer, private, parameter :: nf_64bit_data = 32 integer, private, parameter :: nf_cdf5 = nf_64bit_data integer, private, parameter :: nf_sizehint_default = 0 integer, private, parameter :: nf_align_chunk = -1 integer, private, parameter :: nf_format_classic = 1 integer, private, parameter :: nf_format_64bit = 2 integer, private, parameter :: nf_format_64bit_offset = nf_format_64bit integer, private, parameter :: nf_format_64bit_data = 5 integer, private, parameter :: nf_format_cdf5 = nf_format_64bit_data integer, private, parameter :: nf_diskless = 8 integer, private, parameter :: nf_mmap = 16 integer, private, parameter :: nf_unlimited = 0 integer, private, parameter :: nf_global = 0 integer, private, parameter :: nf_max_dims = 1024 integer, private, parameter :: nf_max_attrs = 8192 integer, private, parameter :: nf_max_vars = 8192 integer, private, parameter :: nf_max_name = 256 integer, private, parameter :: nf_max_var_dims = nf_max_dims integer, private, parameter :: nf_noerr = 0 integer, private, parameter :: nf_ebadid = -33 integer, private, parameter :: nf_eexist = -35 integer, private, parameter :: nf_einval = -36 integer, private, parameter :: nf_eperm = -37 integer, private, parameter :: nf_enotindefine = -38 integer, private, parameter :: nf_eindefine = -39 integer, private, parameter :: nf_einvalcoords = -40 integer, private, parameter :: nf_emaxdims = -41 integer, private, parameter :: nf_enameinuse = -42 integer, private, parameter :: nf_enotatt = -43 integer, private, parameter :: nf_emaxatts = -44 integer, private, parameter :: nf_ebadtype = -45 integer, private, parameter :: nf_ebaddim = -46 integer, private, parameter :: nf_eunlimpos = -47 integer, private, parameter :: nf_emaxvars = -48 integer, private, parameter :: nf_enotvar = -49 integer, private, parameter :: nf_eglobal = -50 integer, private, parameter :: nf_enotnc = -51 integer, private, parameter :: nf_ests = -52 integer, private, parameter :: nf_emaxname = -53 integer, private, parameter :: nf_eunlimit = -54 integer, private, parameter :: nf_enorecvars = -55 integer, private, parameter :: nf_echar = -56 integer, private, parameter :: nf_eedge = -57 integer, private, parameter :: nf_estride = -58 integer, private, parameter :: nf_ebadname = -59 integer, private, parameter :: nf_erange = -60 integer, private, parameter :: nf_enomem = -61 integer, private, parameter :: nf_evarsize = -62 integer, private, parameter :: nf_edimsize = -63 integer, private, parameter :: nf_etrunc = -64 integer, private, parameter :: nf_fatal = 1 integer, private, parameter :: nf_verbose = 2 integer, private, parameter :: nf_string = 12 integer, private, parameter :: nf_vlen = 13 integer, private, parameter :: nf_opaque = 14 integer, private, parameter :: nf_enum = 15 integer, private, parameter :: nf_compound = 16 integer, private, parameter :: nf_fill_ubyte = 255 integer, private, parameter :: nf_fill_ushort = 65535 integer, private, parameter :: nf_format_netcdf4 = 3 integer, private, parameter :: nf_format_netcdf4_classic = 4 integer, private, parameter :: nf_netcdf4 = 4096 integer, private, parameter :: nf_classic_model = 256 integer, private, parameter :: nf_chunk_seq = 0 integer, private, parameter :: nf_chunk_sub = 1 integer, private, parameter :: nf_chunk_sizes = 2 integer, private, parameter :: nf_endian_native = 0 integer, private, parameter :: nf_endian_little = 1 integer, private, parameter :: nf_endian_big = 2 integer, private, parameter :: nf_chunked = 0 integer, private, parameter :: nf_contiguous = 1 integer, private, parameter :: nf_compact = 2 integer, private, parameter :: nf_nochecksum = 0 integer, private, parameter :: nf_fletcher32 = 1 integer, private, parameter :: nf_noshuffle = 0 integer, private, parameter :: nf_shuffle = 1 integer, private, parameter :: nf_szip_ec_option_mask = 4 integer, private, parameter :: nf_szip_nn_option_mask = 32 integer, private, parameter :: nf_mpiio = 8192 integer, private, parameter :: nf_mpiposix = 16384 integer, private, parameter :: nf_pnetcdf = 32768 integer, private, parameter :: nf_independent = 0 integer, private, parameter :: nf_collective = 1 integer, private, parameter :: nf_ehdferr = -101 integer, private, parameter :: nf_ecantread = -102 integer, private, parameter :: nf_ecantwrite = -103 integer, private, parameter :: nf_ecantcreate = -104 integer, private, parameter :: nf_efilemeta = -105 integer, private, parameter :: nf_edimmeta = -106 integer, private, parameter :: nf_eattmeta = -107 integer, private, parameter :: nf_evarmeta = -108 integer, private, parameter :: nf_enocompound = -109 integer, private, parameter :: nf_eattexists = -110 integer, private, parameter :: nf_enotnc4 = -111 integer, private, parameter :: nf_estrictnc3 = -112 integer, private, parameter :: nf_enotnc3 = -113 integer, private, parameter :: nf_enopar = -114 integer, private, parameter :: nf_eparinit = -115 integer, private, parameter :: nf_ebadgrpid = -116 integer, private, parameter :: nf_ebadtypid = -117 integer, private, parameter :: nf_etypdefined = -118 integer, private, parameter :: nf_ebadfield = -119 integer, private, parameter :: nf_ebadclass = -120 integer, private, parameter :: nf_emaptype = -121 integer, private, parameter :: nf_elatefill = -122 integer, private, parameter :: nf_elatedef = -123 integer, private, parameter :: nf_edimscale = -124 integer, private, parameter :: nf_enogrp = -125 integer, private :: ncrdwr integer, private :: nccreat integer, private :: ncexcl integer, private :: ncindef integer, private :: ncnsync integer, private :: nchsync integer, private :: ncndirty integer, private :: nchdirty integer, private :: nclink integer, private :: ncnowrit integer, private :: ncwrite integer, private :: ncclob integer, private :: ncnoclob integer, private :: ncglobal integer, private :: ncfill integer, private :: ncnofill integer, private :: maxncop integer, private :: maxncdim integer, private :: maxncatt integer, private :: maxncvar integer, private :: maxncnam integer, private :: maxvdims integer, private :: ncnoerr integer, private :: ncebadid integer, private :: ncenfile integer, private :: nceexist integer, private :: nceinval integer, private :: nceperm integer, private :: ncenotin integer, private :: nceindef integer, private :: ncecoord integer, private :: ncemaxds integer, private :: ncename integer, private :: ncenoatt integer, private :: ncemaxat integer, private :: ncebadty integer, private :: ncebadd integer, private :: ncests integer, private :: nceunlim integer, private :: ncemaxvs integer, private :: ncenotvr integer, private :: nceglob integer, private :: ncenotnc integer, private :: ncfoobar integer, private :: ncsyserr integer, private :: ncfatal integer, private :: ncverbos integer, private, parameter :: ncentool = nf_emaxname integer, private :: ncbyte integer, private :: ncchar integer, private :: ncshort integer, private :: nclong integer, private :: ncfloat integer, private :: ncdouble integer, private :: ncunlim integer, private, parameter :: filbyte = -127 integer, private, parameter :: filchar = 0 integer, private, parameter :: filshort = -32767 integer, private, parameter :: fillong = -2147483647 real, private, parameter :: filfloat = 9.9692099683868690e+36 doubleprecision, private, parameter :: fildoub = 9.9692099683868690e+36 integer, private, parameter :: r4 = SELECTED_REAL_KIND(6, 37) integer, private, parameter :: r8 = SELECTED_REAL_KIND(12, 100) character(len=*), private, parameter :: cmplx_name = '__CmPlx_Re_Im' Interfaces public        interface cdf_read public  subroutine cdfr_3i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_3l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_3d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_3c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_3f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_3c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_2i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_2l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_2d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_2c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_2f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_2c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_2c (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_1i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_1l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_1d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_1c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_1f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_1c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_1c (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(inout) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_0i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(out) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_0l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(out) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_0d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(out) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_0c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(out) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_0f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(out) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_0c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(out) :: varval integer, intent(out), optional :: ier public        interface cdfGetVar public  subroutine cdfr_3i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_3l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_3d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_3c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_3f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_3c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_2i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_2l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_2d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_2c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_2f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_2c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_2c (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_1i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_1l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_1d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_1c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_1f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_1c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_1c (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(inout) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_0i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(out) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_0l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(out) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_0d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(out) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_0c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(out) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_0f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(out) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_0c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(out) :: varval integer, intent(out), optional :: ier Subroutines public  subroutine cdfr_3i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_3l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_3d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_3c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_3f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_3c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(inout), dimension(:, :, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_2i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_2l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_2d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_2c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_2f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_2c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(inout), dimension(:, :) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_2c (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_1i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_1l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_1d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_1c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_1f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_1c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(inout), dimension(:) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_1c (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam character(len=*), intent(inout) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_0i (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(out) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_0l (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam logical, intent(out) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_0d (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r8), intent(out) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_0c16 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r8), intent(out) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_0f (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam real(kind=r4), intent(out) :: varval integer, intent(out), optional :: ier public  subroutine cdfr_0c8 (ncid, varnam, varval, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam complex(kind=r4), intent(out) :: varval integer, intent(out), optional :: ier","tags":"","loc":"module/ezcdf_genget.html"},{"title":"netcdf_utils – stella","text":"Variables Type Visibility Attributes Name Initial integer, public, parameter :: kind_nf = kind(1) integer(kind=kind_nf), public :: netcdf_real = 0 integer(kind=kind_nf), public :: netcdf_int = 0 logical, private :: test = .false. Functions public  function get_netcdf_code_precision () result(code_real) Arguments None Return Value integer Subroutines public  subroutine check_netcdf_file_precision (ncid, filename) Arguments Type Intent Optional Attributes Name integer(kind=kind_nf), intent(in), optional :: ncid character(len=*), intent(in), optional :: filename public  subroutine netcdf_error (istatus, ncid, varid, dimid, file, dim, var, att, message, abort) Arguments Type Intent Optional Attributes Name integer(kind=kind_nf), intent(in) :: istatus integer(kind=kind_nf), intent(in), optional :: ncid integer(kind=kind_nf), intent(in), optional :: varid integer(kind=kind_nf), intent(in), optional :: dimid character(len=*), intent(in), optional :: file character(len=*), intent(in), optional :: dim character(len=*), intent(in), optional :: var character(len=*), intent(in), optional :: att character(len=*), intent(in), optional :: message logical, intent(in), optional :: abort","tags":"","loc":"module/netcdf_utils.html"},{"title":"dissipation – stella","text":"Variables Type Visibility Attributes Name Initial logical, public :: collisions_initialized = .false. logical, public :: include_collisions logical, public :: collisions_implicit logical, public :: hyper_dissipation character(len=30), private :: collision_model real, public :: cfl_dt_mudiff = huge(0.0) real, public :: cfl_dt_vpadiff = huge(0.0) real, public, dimension(2, 2) :: time_collisions = 0. Subroutines public  subroutine init_dissipation () Arguments None public  subroutine read_parameters () Arguments None public  subroutine init_collisions () Arguments None public  subroutine finish_dissipation () Arguments None private  subroutine finish_collisions () Arguments None public  subroutine advance_collisions_explicit (g, phi, bpar, gke_rhs) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(in), dimension(:, :, -nzgrid:, :) :: bpar complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gke_rhs public  subroutine advance_collisions_implicit (mirror_implicit, phi, apar, bpar, g) switch the vpa integration weights to ensure correct integration by parts Arguments Type Intent Optional Attributes Name logical, intent(in) :: mirror_implicit complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :) :: apar complex, intent(inout), dimension(:, :, -nzgrid:, :) :: bpar complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g","tags":"","loc":"module/dissipation.html"},{"title":"coll_fokkerplanck – stella","text":"Variables Type Visibility Attributes Name Initial logical, private :: vpa_operator logical, private :: mu_operator logical, private :: density_conservation logical, private :: density_conservation_field logical, private :: density_conservation_tp logical, private :: exact_conservation_tp logical, private :: exact_conservation logical, private :: spitzer_problem logical, private :: no_j1l1 logical, private :: no_j1l2 logical, private :: no_j0l2 logical, public :: fieldpart logical, private :: testpart logical, private :: interspec logical, private :: intraspec logical, private :: advfield_coll integer, private :: nresponse = 1 real, private :: cfac real, private :: cfac2 real, private :: nuxfac real, private :: iiknob real, private :: ieknob real, private :: eeknob real, private :: eiknob real, private :: eiediffknob real, private :: eideflknob real, private :: deflknob logical, private :: eimassr_approx integer, private :: jmax = 1 integer, private :: lmax = 1 integer, private :: nvel_local real, private, dimension(:, :), allocatable :: aa_vpa real, private, dimension(:, :), allocatable :: bb_vpa real, private, dimension(:, :), allocatable :: cc_vpa complex, private, dimension(:, :, :), allocatable :: fp_response integer, private, dimension(:, :), allocatable :: diff_idx complex, private, dimension(:, :, :, :, :), allocatable :: aa_blcs complex, private, dimension(:, :, :, :, :), allocatable :: cc_blcs complex, private, dimension(:, :, :, :, :), allocatable :: bb_blcs complex, private, dimension(:, :, :, :, :, :), allocatable :: cdiffmat_band complex, private, dimension(:, :, :, :), allocatable :: blockmatrix complex, private, dimension(:, :, :), allocatable :: blockmatrix_sum integer, private, dimension(:, :, :, :, :), allocatable :: ipiv real, private, dimension(:, :, :, :, :), allocatable :: nus real, private, dimension(:, :, :, :, :), allocatable :: nuD real, private, dimension(:, :, :, :, :), allocatable :: nupa real, private, dimension(:, :, :, :, :), allocatable :: nux real, private, dimension(:, :, :, :), allocatable :: mw real, private, dimension(:, :, :, :), allocatable :: modmw real, private, dimension(:, :, :), allocatable :: velvpamu integer, private :: info real, private, dimension(:), allocatable :: wgts_v real, private, dimension(:), allocatable :: vel real, private, dimension(:, :, :, :, :, :, :, :), allocatable :: deltaj real, private, dimension(:, :, :, :, :, :, :, :), allocatable :: deltaj_tp complex, private, dimension(:, :, :, :), allocatable :: deltajint real, private, dimension(:, :, :, :, :), allocatable :: psijnorm real, private, dimension(:, :, :, :, :), allocatable :: legendre_vpamu real, private, dimension(:, :, :, :, :, :), allocatable :: jm real, private, dimension(:, :, :, :, :), allocatable :: jm0 real, private, dimension(:), allocatable :: mwnorm real, private, dimension(:), allocatable :: modmwnorm logical, private :: fp_initialized = .false. real, private :: i1fac real, private :: i2fac Functions private elemental function associated_laguerre (n, alpha, x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real, intent(in) :: alpha real, intent(in) :: x Return Value real private elemental function associated_legendre (l, m, x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: l integer, intent(in) :: m double precision, intent(in) :: x Return Value double precision Subroutines public  subroutine read_parameters_fp () Arguments None public  subroutine init_collisions_fp (collisions_implicit, cfl_dt_vpadiff, cfl_dt_mudiff) Arguments Type Intent Optional Attributes Name logical, intent(in) :: collisions_implicit real, intent(out) :: cfl_dt_vpadiff real, intent(out) :: cfl_dt_mudiff private  subroutine init_nusDpa () Arguments None private  subroutine finish_nusDpa () Arguments None private  subroutine init_fp_diffmatrix () Arguments None private  subroutine init_legendre () Arguments None private  subroutine init_bessel_fn () Arguments None private  subroutine init_vgrid () Arguments None private recursive subroutine gamlow (a, x, gl) Arguments Type Intent Optional Attributes Name real, intent(in) :: a real, intent(in) :: x real, intent(out) :: gl private recursive subroutine gamup (a, x, gu) Arguments Type Intent Optional Attributes Name real, intent(in) :: a real, intent(in) :: x real, intent(out) :: gu private  subroutine calc_delta0 (xa, jj, ll, isa, isb, delt0) Arguments Type Intent Optional Attributes Name real, intent(in) :: xa integer, intent(in) :: jj integer, intent(in) :: ll integer, intent(in) :: isa integer, intent(in) :: isb real, intent(out) :: delt0 private recursive subroutine calc_deltaj_vmu (jj, nn, ll, isa, isb, deltj) Arguments Type Intent Optional Attributes Name integer, intent(in) :: jj integer, intent(in) :: nn integer, intent(in) :: ll integer, intent(in) :: isa integer, intent(in) :: isb real, intent(out), dimension(nvpa, nmu, -nzgrid:nzgrid) :: deltj private  subroutine vLj_vmu (jj, ll, vLj) Arguments Type Intent Optional Attributes Name integer, intent(in) :: jj integer, intent(in) :: ll real, intent(out), dimension(nvpa, nmu, -nzgrid:nzgrid) :: vLj private recursive subroutine calc_psi_vmu (jj, nn, ll, isa, isb, psij) Arguments Type Intent Optional Attributes Name integer, intent(in) :: jj integer, intent(in) :: nn integer, intent(in) :: ll integer, intent(in) :: isa integer, intent(in) :: isb real, intent(out), dimension(-nzgrid:nzgrid) :: psij private  subroutine init_deltaj_vmu () Arguments None private  subroutine get_testpart_density (isa, isb, g, fld) Arguments Type Intent Optional Attributes Name integer, intent(in) :: isa integer, intent(in) :: isb complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: fld private  subroutine init_fp_conserve () Arguments None private  subroutine get_psi_response (ll, mm, jj, isa, response) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ll integer, intent(in) :: mm integer, intent(in) :: jj integer, intent(in) :: isa complex, intent(out), dimension(:, :, kxkyz_lo%llim_proc:) :: response private  subroutine get_psi (g, fld, isa, isb, ll, mm, jj) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: fld integer, intent(in) :: isa integer, intent(in) :: isb integer, intent(in) :: ll integer, intent(in) :: mm integer, intent(in) :: jj public  subroutine finish_collisions_fp () Arguments None private  subroutine finish_deltaj () Arguments None private  subroutine finish_fp_diffmatrix () Arguments None private  subroutine finish_fp_response () Arguments None public  subroutine advance_collisions_fp_explicit (g, phi, bpar, gke_rhs, time_collisions) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(in), dimension(:, :, -nzgrid:, :) :: bpar complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gke_rhs real, intent(inout), dimension(:, :) :: time_collisions private  subroutine vpa_differential_operator_fp (h, Dh, imu, iz, is, ia) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: h complex, intent(out), dimension(:, :) :: Dh integer, intent(in) :: imu integer, intent(in) :: iz integer, intent(in) :: is integer, intent(in) :: ia private  subroutine mu_differential_operator_fp (h, Dh, iv, iz, is, ia, iky, ikx, cfac) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: h complex, intent(out), dimension(:, :) :: Dh integer, intent(in) :: iv integer, intent(in) :: iz integer, intent(in) :: is integer, intent(in) :: ia integer, intent(in) :: iky integer, intent(in) :: ikx real, intent(in) :: cfac private  subroutine vpa_differential_operator_fp_conservative (h, Dh, imu, iz, is, ia) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: h complex, intent(out), dimension(:, :) :: Dh integer, intent(in) :: imu integer, intent(in) :: iz integer, intent(in) :: is integer, intent(in) :: ia private  subroutine mu_differential_operator_fp_conservative (h, Dh, iv, iz, is, ia, iky, ikx, cfac) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: h complex, intent(out), dimension(:, :) :: Dh integer, intent(in) :: iv integer, intent(in) :: iz integer, intent(in) :: is integer, intent(in) :: ia integer, intent(in) :: iky integer, intent(in) :: ikx real, intent(in) :: cfac public  subroutine advance_collisions_fp_implicit (phi, apar, bpar) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :) :: apar complex, intent(inout), dimension(:, :, -nzgrid:, :) :: bpar private  subroutine advance_implicit_fp (phi, apar, bpar, g) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :) :: apar complex, intent(inout), dimension(:, :, -nzgrid:, :) :: bpar complex, intent(inout), dimension(:, :, kxkyz_lo%llim_proc:) :: g","tags":"","loc":"module/coll_fokkerplanck.html"},{"title":"ezcdf_inqvar – stella","text":"Variables Type Visibility Attributes Name Initial integer, public, parameter :: fatal_error = 666 integer, private, parameter :: nf_byte = 1 integer, private, parameter :: nf_int1 = nf_byte integer, private, parameter :: nf_char = 2 integer, private, parameter :: nf_short = 3 integer, private, parameter :: nf_int2 = nf_short integer, private, parameter :: nf_int = 4 integer, private, parameter :: nf_float = 5 integer, private, parameter :: nf_real = nf_float integer, private, parameter :: nf_double = 6 integer, private, parameter :: nf_ubyte = 7 integer, private, parameter :: nf_ushort = 8 integer, private, parameter :: nf_uint = 9 integer, private, parameter :: nf_int64 = 10 integer, private, parameter :: nf_uint64 = 11 integer, private, parameter :: nf_fill_byte = -127 integer, private, parameter :: nf_fill_int1 = nf_fill_byte integer, private, parameter :: nf_fill_char = 0 integer, private, parameter :: nf_fill_short = -32767 integer, private, parameter :: nf_fill_int2 = nf_fill_short integer, private, parameter :: nf_fill_int = -2147483647 real, private, parameter :: nf_fill_float = 9.9692099683868690e+36 real, private, parameter :: nf_fill_real = nf_fill_float doubleprecision, private, parameter :: nf_fill_double = 9.9692099683868690d+36 integer, private, parameter :: nf_nowrite = 0 integer, private, parameter :: nf_write = 1 integer, private, parameter :: nf_clobber = 0 integer, private, parameter :: nf_noclobber = 4 integer, private, parameter :: nf_fill = 0 integer, private, parameter :: nf_nofill = 256 integer, private, parameter :: nf_lock = 1024 integer, private, parameter :: nf_share = 2048 integer, private, parameter :: nf_64bit_offset = 512 integer, private, parameter :: nf_64bit_data = 32 integer, private, parameter :: nf_cdf5 = nf_64bit_data integer, private, parameter :: nf_sizehint_default = 0 integer, private, parameter :: nf_align_chunk = -1 integer, private, parameter :: nf_format_classic = 1 integer, private, parameter :: nf_format_64bit = 2 integer, private, parameter :: nf_format_64bit_offset = nf_format_64bit integer, private, parameter :: nf_format_64bit_data = 5 integer, private, parameter :: nf_format_cdf5 = nf_format_64bit_data integer, private, parameter :: nf_diskless = 8 integer, private, parameter :: nf_mmap = 16 integer, private, parameter :: nf_unlimited = 0 integer, private, parameter :: nf_global = 0 integer, private, parameter :: nf_max_dims = 1024 integer, private, parameter :: nf_max_attrs = 8192 integer, private, parameter :: nf_max_vars = 8192 integer, private, parameter :: nf_max_name = 256 integer, private, parameter :: nf_max_var_dims = nf_max_dims integer, private, parameter :: nf_noerr = 0 integer, private, parameter :: nf_ebadid = -33 integer, private, parameter :: nf_eexist = -35 integer, private, parameter :: nf_einval = -36 integer, private, parameter :: nf_eperm = -37 integer, private, parameter :: nf_enotindefine = -38 integer, private, parameter :: nf_eindefine = -39 integer, private, parameter :: nf_einvalcoords = -40 integer, private, parameter :: nf_emaxdims = -41 integer, private, parameter :: nf_enameinuse = -42 integer, private, parameter :: nf_enotatt = -43 integer, private, parameter :: nf_emaxatts = -44 integer, private, parameter :: nf_ebadtype = -45 integer, private, parameter :: nf_ebaddim = -46 integer, private, parameter :: nf_eunlimpos = -47 integer, private, parameter :: nf_emaxvars = -48 integer, private, parameter :: nf_enotvar = -49 integer, private, parameter :: nf_eglobal = -50 integer, private, parameter :: nf_enotnc = -51 integer, private, parameter :: nf_ests = -52 integer, private, parameter :: nf_emaxname = -53 integer, private, parameter :: nf_eunlimit = -54 integer, private, parameter :: nf_enorecvars = -55 integer, private, parameter :: nf_echar = -56 integer, private, parameter :: nf_eedge = -57 integer, private, parameter :: nf_estride = -58 integer, private, parameter :: nf_ebadname = -59 integer, private, parameter :: nf_erange = -60 integer, private, parameter :: nf_enomem = -61 integer, private, parameter :: nf_evarsize = -62 integer, private, parameter :: nf_edimsize = -63 integer, private, parameter :: nf_etrunc = -64 integer, private, parameter :: nf_fatal = 1 integer, private, parameter :: nf_verbose = 2 integer, private, parameter :: nf_string = 12 integer, private, parameter :: nf_vlen = 13 integer, private, parameter :: nf_opaque = 14 integer, private, parameter :: nf_enum = 15 integer, private, parameter :: nf_compound = 16 integer, private, parameter :: nf_fill_ubyte = 255 integer, private, parameter :: nf_fill_ushort = 65535 integer, private, parameter :: nf_format_netcdf4 = 3 integer, private, parameter :: nf_format_netcdf4_classic = 4 integer, private, parameter :: nf_netcdf4 = 4096 integer, private, parameter :: nf_classic_model = 256 integer, private, parameter :: nf_chunk_seq = 0 integer, private, parameter :: nf_chunk_sub = 1 integer, private, parameter :: nf_chunk_sizes = 2 integer, private, parameter :: nf_endian_native = 0 integer, private, parameter :: nf_endian_little = 1 integer, private, parameter :: nf_endian_big = 2 integer, private, parameter :: nf_chunked = 0 integer, private, parameter :: nf_contiguous = 1 integer, private, parameter :: nf_compact = 2 integer, private, parameter :: nf_nochecksum = 0 integer, private, parameter :: nf_fletcher32 = 1 integer, private, parameter :: nf_noshuffle = 0 integer, private, parameter :: nf_shuffle = 1 integer, private, parameter :: nf_szip_ec_option_mask = 4 integer, private, parameter :: nf_szip_nn_option_mask = 32 integer, private, parameter :: nf_mpiio = 8192 integer, private, parameter :: nf_mpiposix = 16384 integer, private, parameter :: nf_pnetcdf = 32768 integer, private, parameter :: nf_independent = 0 integer, private, parameter :: nf_collective = 1 integer, private, parameter :: nf_ehdferr = -101 integer, private, parameter :: nf_ecantread = -102 integer, private, parameter :: nf_ecantwrite = -103 integer, private, parameter :: nf_ecantcreate = -104 integer, private, parameter :: nf_efilemeta = -105 integer, private, parameter :: nf_edimmeta = -106 integer, private, parameter :: nf_eattmeta = -107 integer, private, parameter :: nf_evarmeta = -108 integer, private, parameter :: nf_enocompound = -109 integer, private, parameter :: nf_eattexists = -110 integer, private, parameter :: nf_enotnc4 = -111 integer, private, parameter :: nf_estrictnc3 = -112 integer, private, parameter :: nf_enotnc3 = -113 integer, private, parameter :: nf_enopar = -114 integer, private, parameter :: nf_eparinit = -115 integer, private, parameter :: nf_ebadgrpid = -116 integer, private, parameter :: nf_ebadtypid = -117 integer, private, parameter :: nf_etypdefined = -118 integer, private, parameter :: nf_ebadfield = -119 integer, private, parameter :: nf_ebadclass = -120 integer, private, parameter :: nf_emaptype = -121 integer, private, parameter :: nf_elatefill = -122 integer, private, parameter :: nf_elatedef = -123 integer, private, parameter :: nf_edimscale = -124 integer, private, parameter :: nf_enogrp = -125 integer, private :: ncrdwr integer, private :: nccreat integer, private :: ncexcl integer, private :: ncindef integer, private :: ncnsync integer, private :: nchsync integer, private :: ncndirty integer, private :: nchdirty integer, private :: nclink integer, private :: ncnowrit integer, private :: ncwrite integer, private :: ncclob integer, private :: ncnoclob integer, private :: ncglobal integer, private :: ncfill integer, private :: ncnofill integer, private :: maxncop integer, private :: maxncdim integer, private :: maxncatt integer, private :: maxncvar integer, private :: maxncnam integer, private :: maxvdims integer, private :: ncnoerr integer, private :: ncebadid integer, private :: ncenfile integer, private :: nceexist integer, private :: nceinval integer, private :: nceperm integer, private :: ncenotin integer, private :: nceindef integer, private :: ncecoord integer, private :: ncemaxds integer, private :: ncename integer, private :: ncenoatt integer, private :: ncemaxat integer, private :: ncebadty integer, private :: ncebadd integer, private :: ncests integer, private :: nceunlim integer, private :: ncemaxvs integer, private :: ncenotvr integer, private :: nceglob integer, private :: ncenotnc integer, private :: ncfoobar integer, private :: ncsyserr integer, private :: ncfatal integer, private :: ncverbos integer, private, parameter :: ncentool = nf_emaxname integer, private :: ncbyte integer, private :: ncchar integer, private :: ncshort integer, private :: nclong integer, private :: ncfloat integer, private :: ncdouble integer, private :: ncunlim integer, private, parameter :: filbyte = -127 integer, private, parameter :: filchar = 0 integer, private, parameter :: filshort = -32767 integer, private, parameter :: fillong = -2147483647 real, private, parameter :: filfloat = 9.9692099683868690e+36 doubleprecision, private, parameter :: fildoub = 9.9692099683868690e+36 character(len=nf_max_name), private :: varnam_noalpha Interfaces public        interface cdfInqVarDim public  subroutine cdfInqV (ncid, varnam, varid, dimlens, ndims, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(out) :: varid integer, intent(out), dimension(:) :: dimlens integer, intent(out) :: ndims integer, intent(out) :: status public  subroutine cdfgv (ncid, varnam, varid, dimlens, sizes, xtype, status) Arguments Type Intent Optional Attributes Name integer :: ncid character(len=*) :: varnam integer :: varid integer, dimension(:) :: dimlens integer, dimension(:) :: sizes character(len=1) :: xtype integer :: status public  subroutine cdf_inquire (ncid, varnam, dimlens, xtype, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(out), dimension(:) :: dimlens character(len=*), intent(out), optional :: xtype integer, intent(out), optional :: ier Subroutines public  subroutine cdfInqVar (ncid, varnam, dimlens, eztype, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(out), dimension(:) :: dimlens character(len=*), intent(out) :: eztype integer, intent(out), optional :: ier public  subroutine cdfgv (ncid, varnam, varid, dimlens, sizes, xtype, status) Arguments Type Intent Optional Attributes Name integer :: ncid character(len=*) :: varnam integer :: varid integer, dimension(:) :: dimlens integer, dimension(:) :: sizes character(len=1) :: xtype integer :: status public  subroutine cdfInqV (ncid, varnam, varid, dimlens, ndims, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(out) :: varid integer, intent(out), dimension(:) :: dimlens integer, intent(out) :: ndims integer, intent(out) :: status public  subroutine cdf_inquire (ncid, varnam, dimlens, xtype, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid character(len=*), intent(in) :: varnam integer, intent(out), dimension(:) :: dimlens character(len=*), intent(out), optional :: xtype integer, intent(out), optional :: ier public  subroutine alpha_numeric (string) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: string","tags":"","loc":"module/ezcdf_inqvar.html"},{"title":"safe_open_mod – stella","text":"Subroutines public  subroutine safe_open (iunit, istat, filename, filestat, fileform, record_in, access_in, delim_in) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: iunit integer, intent(out) :: istat character(len=*), intent(in) :: filename character(len=*), intent(in) :: filestat character(len=*), intent(in) :: fileform integer, intent(in), optional :: record_in character(len=*), intent(in), optional :: access_in character(len=*), intent(in), optional :: delim_in","tags":"","loc":"module/safe_open_mod.html"},{"title":"convert – stella","text":"Interfaces public        interface c2r private  subroutine x1c2r (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: a real, intent(out), dimension(:, :) :: a_ri private  subroutine x2c2r (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: a real, intent(out), dimension(:, :, :) :: a_ri private  subroutine x3c2r (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, :) :: a real, intent(out), dimension(:, :, :, :) :: a_ri private  subroutine x4c2r (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, :, :) :: a real, intent(out), dimension(:, :, :, :, :) :: a_ri private  subroutine x5c2r (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, :, :, :) :: a real, intent(out), dimension(:, :, :, :, :, :) :: a_ri private  subroutine x6c2r (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, :, :, :, :) :: a real, intent(out), dimension(:, :, :, :, :, :, :) :: a_ri public        interface r2c private  subroutine x1r2c (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:) :: a real, intent(in), dimension(:, :) :: a_ri private  subroutine x2r2c (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :) :: a real, intent(in), dimension(:, :, :) :: a_ri private  subroutine x3r2c (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :, :) :: a real, intent(in), dimension(:, :, :, :) :: a_ri private  subroutine x4r2c (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :, :, :) :: a real, intent(in), dimension(:, :, :, :, :) :: a_ri private  subroutine x5r2c (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :, :, :, :) :: a real, intent(in), dimension(:, :, :, :, :, :) :: a_ri Subroutines private  subroutine x5c2r (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, :, :, :) :: a real, intent(out), dimension(:, :, :, :, :, :) :: a_ri private  subroutine x6c2r (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, :, :, :, :) :: a real, intent(out), dimension(:, :, :, :, :, :, :) :: a_ri private  subroutine x5r2c (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :, :, :, :) :: a real, intent(in), dimension(:, :, :, :, :, :) :: a_ri private  subroutine x4c2r (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, :, :) :: a real, intent(out), dimension(:, :, :, :, :) :: a_ri private  subroutine x4r2c (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :, :, :) :: a real, intent(in), dimension(:, :, :, :, :) :: a_ri private  subroutine x3c2r (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, :) :: a real, intent(out), dimension(:, :, :, :) :: a_ri private  subroutine x3r2c (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :, :) :: a real, intent(in), dimension(:, :, :, :) :: a_ri private  subroutine x2c2r (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: a real, intent(out), dimension(:, :, :) :: a_ri private  subroutine x2r2c (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :) :: a real, intent(in), dimension(:, :, :) :: a_ri private  subroutine x1c2r (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: a real, intent(out), dimension(:, :) :: a_ri private  subroutine x1r2c (a, a_ri) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:) :: a real, intent(in), dimension(:, :) :: a_ri private  subroutine Aborter (iunit, ierrmsg) Arguments Type Intent Optional Attributes Name integer :: iunit character(len=1) :: ierrmsg *(*)","tags":"","loc":"module/convert.html"},{"title":"mirror_terms – stella","text":"Variables Type Visibility Attributes Name Initial logical, public :: mirror_initialized = .false. real, public, dimension(2, 2) :: time_mirror = 0. integer, private, dimension(:, :), allocatable :: mirror_sign real, public, dimension(:, :, :, :), allocatable :: mirror real, private, dimension(:, :, :, :), allocatable :: mirror_rad_var real, private, dimension(:, :, :), allocatable :: mirror_tri_a real, private, dimension(:, :, :), allocatable :: mirror_tri_b real, private, dimension(:, :, :), allocatable :: mirror_tri_c real, private, dimension(:, :, :), allocatable :: mirror_int_fac real, private, dimension(:, :, :, :), allocatable :: mirror_interp_loc integer, private, dimension(:, :, :, :), allocatable :: mirror_interp_idx_shift complex, private, dimension(:, :, :, :), allocatable :: response_apar_denom Subroutines public  subroutine init_mirror () mirror has sign consistent with being on RHS of GKE;\nit is the factor multiplying dg/dvpa in the mirror term\nmirror_sign set to +/- 1 depending on the sign of the mirror term.\nNB: mirror_sign = -1 corresponds to positive advection velocity\nset up the tridiagonal matrix that must be inverted\nfor the implicit treatment of the mirror operator Arguments None private  subroutine init_mirror_semi_lagrange () Arguments None private  subroutine init_invert_mirror_operator () mirror_int_fac = exp(vpa&#94;2 * (mu dB/dz)/(mu dB/dz + Z e dpihnc/dz))\nis the integrating factor needed to turn the dg/dvpa part of the GKE advance\ninto an advection equation\na, b and c contain the sub-, main- and super-diagonal terms, respectively\nif running in full-flux-surface mode, solve mirror advance\nin y-space rather than ky-space due to alpha-dependence of coefficients\ncorresponds to sign of mirror term positive on RHS of equation\nmust treat boundary carefully\nassumes fully upwinded at outgoing boundary\ncorresponds to sign of mirror term negative on RHS of equation\nmust treat boundary carefully\nassumes fully upwinded at outgoing boundary\ntime_upwind = 0.0 corresponds to centered in time\ntime_upwind = 1.0 corresponds to fully implicit (upwinded)\naccount for fact that we have expanded d(gnorm)/dvpa, where gnorm = g/exp(-v&#94;s);\nthis gives rise to d(gnorm exp(-vpa&#94;2))/dvpa + 2 vpa gnorm exp(-vpa&#94;2) term\nwe solve for gnorm*exp(-vpa&#94;2) and later multiply by exp(vpa&#94;2) to get gnorm\nmultiply by mirror coefficient Arguments None private  subroutine init_mirror_response () Arguments None public  subroutine advance_mirror_explicit (g, gout) advance_mirror_explicit calculates the contribution to the RHS of the gyrokinetic equation\ndue to the mirror force term; it treats all terms explicitly in time Read more… Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout public  subroutine add_mirror_radial_variation (g, gout) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout private  subroutine get_dgdvpa_ffs (g, ikxyz) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: g integer, intent(in) :: ikxyz private  subroutine get_dgdvpa_explicit (g) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, kxkyz_lo%llim_proc:) :: g private  subroutine add_mirror_term (g, src) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: src private  subroutine add_mirror_term_ffs (g, src) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: src public  subroutine advance_mirror_implicit (collisions_implicit, g, apar) Arguments Type Intent Optional Attributes Name logical, intent(in) :: collisions_implicit complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :) :: apar private  subroutine get_mirror_rhs_g_contribution (g_in, apar, imu, ikxkyz, rhs) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: g_in complex, intent(in) :: apar integer, intent(in) :: imu integer, intent(in) :: ikxkyz complex, intent(out), dimension(:) :: rhs private  subroutine get_mirror_rhs_apar_contribution (rhs, apar, imu, ikxkyz) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:) :: rhs complex, intent(in) :: apar integer, intent(in) :: imu integer, intent(in) :: ikxkyz private  subroutine vpa_interpolation (grid, interp) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: grid complex, intent(out), dimension(:, :, kxkyz_lo%llim_proc:) :: interp private  subroutine invert_mirror_operator (imu, ilo, g) Arguments Type Intent Optional Attributes Name integer, intent(in) :: imu integer, intent(in) :: ilo complex, intent(inout), dimension(:) :: g public  subroutine finish_mirror () Arguments None private  subroutine finish_mirror_semi_lagrange () Arguments None private  subroutine finish_invert_mirror_operator () Arguments None private  subroutine finish_mirror_response () Arguments None","tags":"","loc":"module/mirror_terms.html"},{"title":"stella_diagnostics – stella","text":"Routines for calculating and writing various physical diagnostics Variables Type Visibility Attributes Name Initial integer, private :: ntg_out integer, private :: nwrite integer, public :: nsave integer, private :: navg integer, private :: nc_mult integer, private :: stdout_unit integer, private :: fluxes_unit integer, private :: omega_unit logical, private :: save_for_restart logical, private :: write_omega logical, private :: write_moments logical, private :: write_phi_vs_time logical, private :: write_apar_vs_time logical, private :: write_bpar_vs_time logical, private :: write_gvmus logical, private :: write_gzvs logical, private :: write_kspectra logical, public :: write_radial_fluxes logical, public :: write_radial_moments logical, private :: write_fluxes_kxkyz logical, private :: flux_norm real, private, dimension(:), allocatable :: pflux_avg Arrays needed for averaging in x,y,z real, private, dimension(:), allocatable :: vflux_avg Arrays needed for averaging in x,y,z real, private, dimension(:), allocatable :: qflux_avg Arrays needed for averaging in x,y,z real, private, dimension(:), allocatable :: heat_avg Arrays needed for averaging in x,y,z real, private, dimension(:, :, :), allocatable :: pflux real, private, dimension(:, :, :), allocatable :: vflux real, private, dimension(:, :, :), allocatable :: qflux real, private, dimension(:, :, :), allocatable :: exchange complex, private, dimension(:, :, :), allocatable :: omega_vs_time Needed for calculating growth rates and frequencies integer, private :: nout = 1 Current maximum index of the time dimension in the netCDF file logical, private :: diagnostics_initialized = .false. Has this module been initialised? logical, private :: debug = .false. Debugging Interfaces private        interface get_one_flux_vmulo private  subroutine get_one_flux_vmulo_int (weights, gin, fld, flxout) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: weights complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gin complex, intent(in), dimension(:, :, -nzgrid:, :) :: fld real, intent(inout), dimension(:) :: flxout private  subroutine get_one_flux_vmulo_kxkyz (weights, gin, fld, flxout) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: weights complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gin complex, intent(in), dimension(:, :, -nzgrid:, :) :: fld real, intent(inout), dimension(:, :, -nzgrid:, :, :) :: flxout Subroutines public  subroutine read_stella_diagnostics_knobs () Read-in the parameters for the stella_diagnostics module Read more… Arguments None public  subroutine init_stella_diagnostics (restart, tstart) Initialise the stella_diagnostics module Read more… Arguments Type Intent Optional Attributes Name logical, intent(in) :: restart Has this simulation been restarted? real, intent(in) :: tstart Current simulation time private  subroutine read_parameters () Read the diagnostic input parameters from the input file Read more… Arguments None private  subroutine allocate_arrays () Allocate the module-level arrays Arguments None private  subroutine open_loop_ascii_files (restart) Open the '.out' and the '.fluxes' file. Read more… Arguments Type Intent Optional Attributes Name logical, intent(in) :: restart private  subroutine close_loop_ascii_files () Close the text files opened by open_loop_ascii_files Arguments None public  subroutine diagnose_stella (istep) Calculate and write diagnostics Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: istep The current timestep private  subroutine get_fluxes (g, pflx, vflx, qflx, pflx_vs_kxkyz, vflx_vs_kxkyz, qflx_vs_kxkyz) Calculate fluxes Read more… Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g real, intent(out), dimension(:) :: pflx real, intent(out), dimension(:) :: vflx real, intent(out), dimension(:) :: qflx real, intent(out), dimension(:, :, -nzgrid:, :, :) :: pflx_vs_kxkyz real, intent(out), dimension(:, :, -nzgrid:, :, :) :: vflx_vs_kxkyz real, intent(out), dimension(:, :, -nzgrid:, :, :) :: qflx_vs_kxkyz private  subroutine get_fluxes_vmulo (g, phi, pflx, vflx, qflx, pflx_x, vflx_x, qflx_x, pflx_vs_kxkyz, vflx_vs_kxkyz, qflx_vs_kxkyz) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi real, intent(out), dimension(:) :: pflx real, intent(out), dimension(:) :: vflx real, intent(out), dimension(:) :: qflx real, intent(out), dimension(:, :) :: pflx_x real, intent(out), dimension(:, :) :: vflx_x real, intent(out), dimension(:, :) :: qflx_x real, intent(out), dimension(:, :, -nzgrid:, :, :) :: pflx_vs_kxkyz real, intent(out), dimension(:, :, -nzgrid:, :, :) :: vflx_vs_kxkyz real, intent(out), dimension(:, :, -nzgrid:, :, :) :: qflx_vs_kxkyz private  subroutine get_fluxes_ffs (dens, upar, pres, pflx, vflx, qflx, pflx_vs_kxkyz, vflx_vs_kxkyz, qflx_vs_kxkyz) Calculate the total particle, momentum and heat fluxes (pflx, vflx, qflx)\nand the contributions from a given (kx,ky,z) location (pflx_kxkyz, vflx_kxkyz, qflx_kxkyz)\ninputs are the particle density (dens), parallel flow (upar) and pressure (pres) Read more… Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: dens complex, intent(in), dimension(:, :, -nzgrid:, :) :: upar complex, intent(in), dimension(:, :, -nzgrid:, :) :: pres real, intent(out), dimension(:) :: pflx real, intent(out), dimension(:) :: vflx real, intent(out), dimension(:) :: qflx real, intent(out), dimension(:, :, -nzgrid:, :, :) :: pflx_vs_kxkyz real, intent(out), dimension(:, :, -nzgrid:, :, :) :: vflx_vs_kxkyz real, intent(out), dimension(:, :, -nzgrid:, :, :) :: qflx_vs_kxkyz private  subroutine get_one_flux_ffs (mom, dphidy, flxfac, flx, flx_vs_kxkyz) divide the input density by the magnetic field strength (due to Jacobian in flux-surfacee avg)\nand Fourier transform in y to get mom_ky = (density/B)(ky,kx,z,spec)\npflx_vs_kxkyz is the particle flux before summing over (kx,ky) and integrating over z\ncalculate the volume average of the particle flux\nnote that the factor of 1/B that appears in the Jacobian has already been taken into account\nin the numerator of the flux surface average Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: mom complex, intent(in), dimension(:, :, -nzgrid:) :: dphidy real, intent(in) :: flxfac real, intent(out), dimension(:) :: flx real, intent(out), dimension(:, :, -nzgrid:, :) :: flx_vs_kxkyz private  subroutine get_modified_fourier_coefficient (moment, moment_ky) divide the input moment by the magnetic field strength\nto account for Jacobian in flux-surface average\ntransform the B-modified input moment from y to ky space\nswap from all ky and kx >= 0 to all kx and ky >= 0 Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: moment complex, intent(out), dimension(:, :, -nzgrid:, :) :: moment_ky private  subroutine get_one_flux (iky, iz, norm, gin, fld, flxout) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky integer, intent(in) :: iz real, intent(in) :: norm complex, intent(in), dimension(:, :) :: gin complex, intent(in) :: fld real, intent(inout) :: flxout private  subroutine get_one_flux_vmulo_int (weights, gin, fld, flxout) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: weights complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gin complex, intent(in), dimension(:, :, -nzgrid:, :) :: fld real, intent(inout), dimension(:) :: flxout private  subroutine get_one_flux_vmulo_kxkyz (weights, gin, fld, flxout) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: weights complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gin complex, intent(in), dimension(:, :, -nzgrid:, :) :: fld real, intent(inout), dimension(:, :, -nzgrid:, :, :) :: flxout private  subroutine get_one_flux_radial (weights, gin, fld, flxout) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: weights complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gin complex, intent(in), dimension(:, :, -nzgrid:, :) :: fld real, intent(inout), dimension(:, :) :: flxout private  subroutine get_moments (g, dens, upar, temp, dens_x, upar_x, temp_x, spitzer2) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: dens complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: upar complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: temp real, intent(out), dimension(:, :) :: dens_x real, intent(out), dimension(:, :) :: upar_x real, intent(out), dimension(:, :) :: temp_x complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: spitzer2 private  subroutine get_moments_ffs (g, dens, upar, pres) species-dependent factor by which velocity moments must be multiplied\nto get density, pressure, etc.\nthe guiding centre distribution function, normalized by\nthe equilibrium Maxwellian, is passed in as g.\nto obtain moments such as density, flow and pressure,\nwe need to take moments of the distribution function, f,\nwhich is related to g via\nf/F0 = g + (Ze/T)*( _R - phi)\nobtain g0=f/F0 in Fourier space Read more… Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: dens complex, intent(out), dimension(:, :, -nzgrid:, :) :: upar complex, intent(out), dimension(:, :, -nzgrid:, :) :: pres private  subroutine g_to_f (g, phi, f) the Fourier components of the guiding centre distribution function\nnormalized by the equilibrium Maxwellian is passed in as g,\nalong with the Fourier components of the electrostatic potential, phi.\ng_to_f calculates the Maxwellian-normalized distribution function f,\nwhich is related to g via\nf = g + (Ze/T)*( _R - phi) Read more… Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: f private  subroutine get_gvmus (g, gv) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, kxkyz_lo%llim_proc:) :: g real, intent(out), dimension(:, :, :) :: gv private  subroutine get_gzvs (g, gz) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g real, intent(out), dimension(:, :, :, :) :: gz public  subroutine finish_stella_diagnostics (istep) Arguments Type Intent Optional Attributes Name integer, intent(in) :: istep private  subroutine write_loop_ascii_files (istep, phi2, apar2, bpar2, pflx, vflx, qflx, om, om_avg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: istep real, intent(in) :: phi2 real, intent(in) :: apar2 real, intent(in) :: bpar2 real, intent(in), dimension(:) :: pflx real, intent(in), dimension(:) :: vflx real, intent(in), dimension(:) :: qflx complex, intent(in), dimension(:, :) :: om complex, intent(in), dimension(:, :) :: om_avg private  subroutine write_final_ascii_files () Arguments None private  subroutine deallocate_arrays () Arguments None","tags":"","loc":"module/stella_diagnostics.html"},{"title":"stella_transforms – stella","text":"Uses fft_work Variables Type Visibility Attributes Name Initial type( fft_type ), private :: yf_fft type( fft_type ), private :: yb_fft type( fft_type ), private :: xf_fft type( fft_type ), private :: xb_fft type( fft_type ), private :: yfnp_fft type( fft_type ), private :: ybnp_fft type( fft_type ), private :: xfnp_fft type( fft_type ), private :: xbnp_fft type( fft_type ), private :: xsf_fft type( fft_type ), private :: xsb_fft type( fft_type ), private :: ysf_fft type( fft_type ), private :: ysb_fft type( fft_type ), private :: alpha_f_fft type( fft_type ), private :: alpha_b_fft logical, private :: transforms_initialized = .false. complex, private, dimension(:), allocatable :: fft_y_in complex, private, dimension(:), allocatable :: fft_y_out complex, private, dimension(:), allocatable :: fft_x_k real, private, dimension(:), allocatable :: fft_x_x complex, private, dimension(:), allocatable :: fft_xs_k complex, private, dimension(:), allocatable :: fft_xs_x complex, private, dimension(:), allocatable :: fft_ys_k real, private, dimension(:), allocatable :: fft_ys_y complex, private, dimension(:), allocatable :: fftnp_x_k complex, private, dimension(:), allocatable :: fftnp_x_x complex, private, dimension(:), allocatable :: fftnp_y_k real, private, dimension(:), allocatable :: fftnp_y_y real, private, dimension(:), allocatable :: fft_alpha_alpha arrays for transforming from alpha-space to k-alpha space complex, private, dimension(:), allocatable :: fft_alpha_kalpha Interfaces public        interface transform_ky2y private  subroutine transform_ky2y_5d (gky_unpad, gy) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -vmu_lo%nzgrid:, :, vmu_lo%llim_proc:) :: gky_unpad complex, intent(out), dimension(:, :, -vmu_lo%nzgrid:, :, vmu_lo%llim_proc:) :: gy private  subroutine transform_ky2y_2d (gky_unpad, gy) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gky_unpad complex, intent(out), dimension(:, :) :: gy public        interface transform_y2ky private  subroutine transform_y2ky_5d (gy, gky) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -vmu_lo%nzgrid:, :, vmu_lo%llim_proc:) :: gy complex, intent(out), dimension(:, :, -vmu_lo%nzgrid:, :, vmu_lo%llim_proc:) :: gky private  subroutine transform_y2ky_2d (gy, gky) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: gy complex, intent(out), dimension(:, :) :: gky Subroutines public  subroutine init_transforms () Arguments None private  subroutine init_y_fft () Arguments None private  subroutine init_x_fft () Arguments None private  subroutine init_x_xfirst_fft () Arguments None private  subroutine init_y_xfirst_fft () Arguments None private  subroutine init_unpadded_x_fft () Arguments None private  subroutine init_unpadded_y_fft () Arguments None private  subroutine init_alpha_fft () Arguments None private  subroutine transform_ky2y_5d (gky_unpad, gy) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -vmu_lo%nzgrid:, :, vmu_lo%llim_proc:) :: gky_unpad complex, intent(out), dimension(:, :, -vmu_lo%nzgrid:, :, vmu_lo%llim_proc:) :: gy private  subroutine transform_ky2y_2d (gky_unpad, gy) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gky_unpad complex, intent(out), dimension(:, :) :: gy private  subroutine transform_y2ky_5d (gy, gky) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -vmu_lo%nzgrid:, :, vmu_lo%llim_proc:) :: gy complex, intent(out), dimension(:, :, -vmu_lo%nzgrid:, :, vmu_lo%llim_proc:) :: gky private  subroutine transform_y2ky_2d (gy, gky) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: gy complex, intent(out), dimension(:, :) :: gky public  subroutine transform_kx2x (gkx, gx) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gkx real, intent(out), dimension(:, :) :: gx public  subroutine transform_x2kx (gx, gkx) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: gx complex, intent(out), dimension(:, :) :: gkx public  subroutine transform_kx2x_xfirst (gkx, gx) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gkx complex, intent(out), dimension(:, :) :: gx public  subroutine transform_x2kx_xfirst (gx, gkx) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gx complex, intent(out), dimension(:, :) :: gkx public  subroutine transform_ky2y_xfirst (gky, gy) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gky real, intent(out), dimension(:, :) :: gy public  subroutine transform_y2ky_xfirst (gy, gky) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: gy complex, intent(out), dimension(:, :) :: gky public  subroutine transform_kx2x_unpadded (gkx, gx) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gkx complex, intent(out), dimension(:, :) :: gx public  subroutine transform_x2kx_unpadded (gx, gkx) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gx complex, intent(out), dimension(:, :) :: gkx public  subroutine transform_ky2y_unpadded (gky, gy) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gky real, intent(out), dimension(:, :) :: gy public  subroutine transform_y2ky_unpadded (gy, gky) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :) :: gy complex, intent(out), dimension(:, :) :: gky public  subroutine transform_kalpha2alpha (gkalph, galph) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: gkalph real, intent(out), dimension(:) :: galph public  subroutine transform_alpha2kalpha (galph, gkalph) input galph array is real and contains values on the padded alpha grid\ngkalph is output array; it contains the Fourier coefficients of galph\nfor positive ky values only (reality can be used to obtain the negative ky coefs)\nthe highest 1/3 of the ky modes from the FFT have been discarded to avoid de-aliasing Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: galph complex, intent(out), dimension(:) :: gkalph public  subroutine finish_transforms () Arguments None","tags":"","loc":"module/stella_transforms.html"},{"title":"hyper – stella","text":"Variables Type Visibility Attributes Name Initial logical, private :: use_physical_ksqr logical, private :: scale_to_outboard real, private :: D_hyper real, private :: tfac real, private :: k2max Subroutines public  subroutine read_parameters_hyper () Arguments None public  subroutine init_hyper () avoid spatially dependent kperp (through the geometric coefficients)\nstill allowed to vary along zed with global magnetic shear\nuseful for full_flux_surface and radial_variation runs Read more… Arguments None public  subroutine advance_hyper_dissipation (g) avoid spatially dependent kperp\nadd in hyper-dissipation of form dg/dt = -D (k/kmax)&#94;4 g\nadd in hyper-dissipation of form dg/dt = -D (k/kmax)&#94;4 g Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g","tags":"","loc":"module/hyper.html"},{"title":"fzero_mod – stella","text":"Subroutines public  subroutine FZERO (F, B, C, R, RE, AE, IFLAG) BEGIN PROLOGUE  FZERO PURPOSE  Search for a zero of a function F(X) in a given interval\n            (B,C).  It is designed primarily for problems where F(B)\n            and F(C) have opposite signs. LIBRARY   SLATEC CATEGORY  F1B TYPE      SINGLE PRECISION (FZERO-S, DFZERO-D) KEYWORDS  BISECTION, NONLINEAR EQUATIONS, ROOTS, ZEROS AUTHOR  Shampine, L. F., (SNLA)\n           Watts, H. A., (SNLA) DESCRIPTION Read more… Arguments Type Intent Optional Attributes Name real :: F real :: B real :: C real :: R real :: RE real :: AE integer :: IFLAG","tags":"","loc":"module/fzero_mod.html"},{"title":"g_tofrom_h – stella","text":"Interfaces public        interface gbar_to_g private  subroutine gbar_to_g_kxkyz (g, apar, facapar) adjust apar part of Zs / Ts Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: apar real, intent(in) :: facapar private  subroutine gbar_to_g_1d_vpa (g, apar, imu, ikxkyz, facapar) adjust apar part of Zs / Ts Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: g complex, intent(in) :: apar integer, intent(in) :: imu integer, intent(in) :: ikxkyz real, intent(in) :: facapar private  subroutine gbar_to_g_vmu (g, apar, facapar) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: apar real, intent(in) :: facapar private  subroutine gbar_to_g_vmu_single (ivmu, g0, apar, facapar) adjust apar part of Arguments Type Intent Optional Attributes Name integer, intent(in) :: ivmu complex, intent(inout), dimension(:, :, -nzgrid:, :) :: g0 complex, intent(in), dimension(:, :, -nzgrid:, :) :: apar real, intent(in) :: facapar public        interface g_to_h private  subroutine g_to_h_kxkyz (g, phi, bpar, facphi) adjust bpar part of Zs / Ts Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(in), dimension(:, :, -nzgrid:, :) :: bpar real, intent(in) :: facphi private  subroutine g_to_h_vmu (g, phi, bpar, facphi, phi_corr) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(in), dimension(:, :, -nzgrid:, :) :: bpar real, intent(in) :: facphi complex, intent(in), optional, dimension(:, :, -nzgrid:, :) :: phi_corr private  subroutine g_to_h_vmu_single (ivmu, g0, phi, bpar, facphi, phi_corr) adjust bpar part of Zs / Ts Arguments Type Intent Optional Attributes Name integer, intent(in) :: ivmu complex, intent(inout), dimension(:, :, -nzgrid:, :) :: g0 complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(in), dimension(:, :, -nzgrid:, :) :: bpar real, intent(in) :: facphi complex, intent(in), optional, dimension(:, :, -nzgrid:, :) :: phi_corr Subroutines private  subroutine gbar_to_g_kxkyz (g, apar, facapar) adjust apar part of Zs / Ts Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: apar real, intent(in) :: facapar private  subroutine gbar_to_g_1d_vpa (g, apar, imu, ikxkyz, facapar) adjust apar part of Zs / Ts Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: g complex, intent(in) :: apar integer, intent(in) :: imu integer, intent(in) :: ikxkyz real, intent(in) :: facapar private  subroutine gbar_to_g_vmu (g, apar, facapar) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: apar real, intent(in) :: facapar private  subroutine gbar_to_g_vmu_single (ivmu, g0, apar, facapar) adjust apar part of Arguments Type Intent Optional Attributes Name integer, intent(in) :: ivmu complex, intent(inout), dimension(:, :, -nzgrid:, :) :: g0 complex, intent(in), dimension(:, :, -nzgrid:, :) :: apar real, intent(in) :: facapar private  subroutine g_to_h_vmu (g, phi, bpar, facphi, phi_corr) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(in), dimension(:, :, -nzgrid:, :) :: bpar real, intent(in) :: facphi complex, intent(in), optional, dimension(:, :, -nzgrid:, :) :: phi_corr private  subroutine g_to_h_vmu_single (ivmu, g0, phi, bpar, facphi, phi_corr) adjust bpar part of Zs / Ts Arguments Type Intent Optional Attributes Name integer, intent(in) :: ivmu complex, intent(inout), dimension(:, :, -nzgrid:, :) :: g0 complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(in), dimension(:, :, -nzgrid:, :) :: bpar real, intent(in) :: facphi complex, intent(in), optional, dimension(:, :, -nzgrid:, :) :: phi_corr private  subroutine g_to_h_kxkyz (g, phi, bpar, facphi) adjust bpar part of Zs / Ts Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, kxkyz_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(in), dimension(:, :, -nzgrid:, :) :: bpar real, intent(in) :: facphi","tags":"","loc":"module/g_tofrom_h.html"},{"title":"kt_grids – stella","text":"Variables Type Visibility Attributes Name Initial real, public, dimension(:, :), allocatable :: theta0 real, public, dimension(:, :), allocatable :: zed0 real, public, dimension(:), allocatable :: aky real, public, dimension(:), allocatable :: akx real, public, dimension(:), allocatable :: aky_all real, public, dimension(:), allocatable :: aky_all_ordered real, public, dimension(:), allocatable :: x real, public, dimension(:), allocatable :: x_d real, public, dimension(:), allocatable :: y real, public, dimension(:), allocatable :: rho real, public, dimension(:), allocatable :: rho_d real, public, dimension(:), allocatable :: rho_clamped real, public, dimension(:), allocatable :: rho_d_clamped complex, private, dimension(:, :), allocatable :: g0x real, public :: dx real, public :: dy real, public :: dkx real, public :: dky real, public :: dx_d real, public :: jtwistfac real, public :: phase_shift_angle integer, public :: naky integer, public :: nakx integer, public :: nx integer, public :: ny integer, public :: nalpha integer, public :: jtwist integer, public :: ikx_twist_shift integer, public :: ikx_max integer, public :: naky_all integer, public :: boundary_size integer, public :: copy_size integer, public :: krook_size logical, public :: reality = .false. logical, public :: centered_in_rho logical, public :: periodic_variation logical, private :: randomize_phase_shift character(len=20), private :: grid_option logical, public, dimension(:), allocatable :: zonal_mode integer, private :: gridopt_switch integer, private, parameter :: gridopt_range = 1 integer, private, parameter :: gridopt_box = 2 integer, private :: kyspacing_option_switch integer, private, parameter :: kyspacing_linear = 1 integer, private, parameter :: kyspacing_exponential = 2 real, private :: aky_min real, private :: aky_max real, private :: akx_min real, private :: akx_max real, private :: theta0_min real, private :: theta0_max real, public :: x0 real, public :: y0 logical, private :: read_kt_grids_initialized = .false. logical, private :: init_kt_grids_initialized = .false. logical, public :: box Interfaces public        interface swap_kxky private  subroutine swap_kxky_real (gin, gout) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: gin real, intent(out), dimension(:, :) :: gout private  subroutine swap_kxky_complex (gin, gout) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout public        interface swap_kxky_ordered private  subroutine swap_kxky_ordered_real (gin, gout) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: gin real, intent(out), dimension(:, :) :: gout private  subroutine swap_kxky_ordered_complex (gin, gout) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout Subroutines public  subroutine read_kt_grids_parameters () Arguments None private  subroutine read_grid_option () Arguments None private  subroutine read_kt_grids_box () Arguments None private  subroutine read_kt_grids_range () Arguments None public  subroutine init_kt_grids () determine if iky corresponds to zonal mode Arguments None private  subroutine init_kt_grids_box () set jtwist and y0 for cases where they have not been specified\nand for which it makes sense to set them automatically\nsigned version of jtwist, with sign determined by, e.g., magnetic shear Read more… Arguments None private  subroutine init_kt_grids_range () Arguments None private  subroutine broadcast_input () Arguments None private  subroutine dump_radial_grid () Arguments None private  subroutine allocate_arrays () Arguments None private  subroutine swap_kxky_complex (gin, gout) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout private  subroutine swap_kxky_real (gin, gout) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: gin real, intent(out), dimension(:, :) :: gout private  subroutine swap_kxky_ordered_real (gin, gout) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: gin real, intent(out), dimension(:, :) :: gout private  subroutine swap_kxky_ordered_complex (gin, gout) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout public  subroutine swap_kxky_back (gin, gout) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout public  subroutine swap_kxky_back_ordered (gin, gout) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gin complex, intent(out), dimension(:, :) :: gout public  subroutine communicate_ktgrids_multibox () Arguments None public  subroutine finish_kt_grids () Arguments None public  subroutine multiply_by_rho (gin) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: gin","tags":"","loc":"module/kt_grids.html"},{"title":"time_advance – stella","text":"Variables Type Visibility Attributes Name Initial logical, private :: time_advance_initialized = .false. logical, private :: wdriftinit = .false. logical, private :: wstarinit = .false. logical, private :: parnlinit = .false. logical, private :: readinit = .false. logical, private :: radialinit = .false. logical, private :: driftimpinit = .false. integer, private :: explicit_option_switch integer, private, parameter :: explicit_option_rk3 = 1 integer, private, parameter :: explicit_option_rk2 = 2 integer, private, parameter :: explicit_option_rk4 = 3 integer, private, parameter :: explicit_option_euler = 4 real, private :: xdriftknob real, private :: ydriftknob real, private :: wstarknob logical, private :: flip_flop real, private, dimension(:, :), allocatable :: par_nl_fac real, private, dimension(:, :), allocatable :: d_par_nl_fac_dr real, private, dimension(:, :), allocatable :: par_nl_curv real, private, dimension(:, :), allocatable :: d_par_nl_curv_dr real, private, dimension(:), allocatable :: par_nl_driftx real, private, dimension(:), allocatable :: par_nl_drifty real, private, dimension(:), allocatable :: d_par_nl_driftx_dr real, private, dimension(:), allocatable :: d_par_nl_drifty_dr real, public, dimension(2, 10) :: time_gke = 0. real, public, dimension(2, 2) :: time_parallel_nl = 0. logical, private :: debug = .false. Interfaces private        interface get_dgdy private  subroutine get_dgdy_2d (g, dgdy) compute dg/dy in k-space\naccepts g(ky,kx) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: g complex, intent(out), dimension(:, :) :: dgdy private  subroutine get_dgdy_3d (g, dgdy) compute dg/dy in k-space\naccepts g(ky,kx,z,tube) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: dgdy private  subroutine get_dgdy_4d (g, dgdy) compute dg/dy in k-space\naccepts g(ky,kx,z,tube,(vpa,mu,spec)) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dgdy private        interface get_dgdx private  subroutine get_dgdx_2d (g, dgdx) compute dg/dx in k-space\naccepts g(ky,kx) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: g complex, intent(out), dimension(:, :) :: dgdx private  subroutine get_dgdx_3d (g, dgdx) compute dg/dx in k-space\naccepts g(ky,kx,z,tube) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: dgdx private  subroutine get_dgdx_4d (g, dgdx) compute dg/dx in k-space\naccepts g(ky,kx,z,tube,(vpa,mu,spec)) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dgdx public        interface checksum private  subroutine checksum_field (field, total) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: field real, intent(out) :: total private  subroutine checksum_dist (dist, total, norm) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dist real, intent(out) :: total logical, intent(in), optional :: norm Subroutines public  subroutine init_time_advance () read time_advance_knobs namelist from the input file;\nsets the explicit time advance option, as well as allows for scaling of\nthe x and y components of the magnetic drifts and of the drive term\nallocate distribution function sized arrays needed, e.g., for Runge-Kutta time advance\nset up neoclassical corrections to the equilibrium Maxwellian;\nonly calculated/needed when simulating higher order terms in rhostar for intrinsic rotation\ncalculate the term multiplying dg/dvpa in the mirror term\nand set up either the semi-Lagrange machinery or the tridiagonal matrix to be inverted\nif solving implicitly\ncalculate the term multiplying dg/dz in the parallel streaming term\nand set up the tridiagonal matrix to be inverted if solving implicitly\nallocate and calculate the factors multiplying dg/dx, dg/dy, dphi/dx and dphi/dy\nin the magnetic drift terms\nallocate and calculate the factor multiplying dphi/dy in the gradient drive term Arguments None private  subroutine read_parameters () Arguments None private  subroutine init_wdrift () allocate wdriftx_phi, the factor multiplying dphi/dx in the magnetic drift term\nallocate wdrifty_phi, the factor multiplying dphi/dy in the magnetic drift term\nallocate wdriftx_bpar, the factor multiplying dbpar/dx in the magnetic drift term\nallocate wdrifty_bpar, the factor multiplying dbpar/dy in the magnetic drift term\nallocate wdriftx_g, the factor multiplying dg/dx in the magnetic drift term\nallocate wdrifty_g, the factor multiplying dg/dy in the magnetic drift term\nthis is the curvature drift piece of wdrifty with missing factor of vpa\nvpa factor is missing to avoid singularity when including\nnon-Maxwellian corrections to equilibrium\nthis is the grad-B drift piece of wdrifty\nif including neoclassical correction to equilibrium Maxwellian,\nthen add in v_E&#94;{nc} . grad y dg/dy coefficient here\nif maxwwellian_normalization = .true., evolved distribution function is normalised by a Maxwellian\notherwise, it is not; a Maxwellian weighting factor must thus be included\nassign wdrifty_bpar, neoclassical terms not supported\nif including neoclassical corrections to equilibrium,\nadd in -(Ze/m) * v_curv/vpa . grad y d /dy * dF&#94;{nc}/dvpa term\nand v_E . grad z dF&#94;{nc}/dz (here get the dphi/dy part of v_E)\nNB: the below neoclassical correction needs to be divided by an equilibrium Maxwellian\nif maxwellian_normalization = .true.\nthis is the curvature drift piece of wdriftx with missing factor of vpa\nvpa factor is missing to avoid singularity when including\nnon-Maxwellian corrections to equilibrium\nthis is the grad-B drift piece of wdriftx\nif including neoclassical correction to equilibrium Maxwellian,\nthen add in v_E&#94;{nc} . grad x dg/dx coefficient here\nif maxwellian_normalizatiion = .true., evolved distribution function is normalised by a Maxwellian\notherwise, it is not; a Maxwellian weighting factor must thus be included\nassign wdriftx_bpar, neoclassical terms not supported\nif including neoclassical corrections to equilibrium,\nadd in (Ze/m) * v_curv/vpa . grad x d /dx * dF&#94;{nc}/dvpa term\nand v_E . grad z dF&#94;{nc}/dz (here get the dphi/dx part of v_E)\nand v_E . grad alpha dF&#94;{nc}/dalpha (dphi/dx part of v_E)\nNB: the below neoclassical correction needs to be divided by an equilibrium Maxwellian\nif running with maxwellian_normalzation = .true. Arguments None private  subroutine init_wstar () Arguments None private  subroutine init_parallel_nonlinearity () Arguments None private  subroutine init_radial_variation () Arguments None private  subroutine allocate_arrays () Arguments None private  subroutine init_cfl () Arguments None private  subroutine reset_dt () Arguments None public  subroutine advance_stella (istep, stop_stella) unless running in multibox mode, no need to worry about\nmb_communicate calls as the subroutine is immediately exited\nif not in multibox mode.\nsave value of phi & apar\nfor use in diagnostics (to obtain frequency)\nreverse the order of operations every time step\nas part of alternating direction operator splitting\nthis is needed to ensure 2nd order accuracy in time Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: istep logical, intent(inout) :: stop_stella private  subroutine advance_explicit (g, restart_time_step, istep) advance_explicit takes as input the guiding centre distribution function\nin k-space and updates it to account for all of the terms in the GKE that\nare advanced explicitly in time Read more… Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g logical, intent(inout) :: restart_time_step integer, intent(in) :: istep private  subroutine advance_explicit_euler (g, restart_time_step, istep) advance_explicit_euler uses forward Euler to advance one time step Read more… Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g logical, intent(inout) :: restart_time_step integer, intent(in) :: istep private  subroutine advance_explicit_rk2 (g, restart_time_step, istep) advance_expliciit_rk2 uses strong stability-preserving RK2 to advance one time step Read more… Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g logical, intent(inout) :: restart_time_step integer, intent(in) :: istep private  subroutine advance_explicit_rk3 (g, restart_time_step, istep) strong stability-preserving RK3 Read more… Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g logical, intent(inout) :: restart_time_step integer, intent(in) :: istep private  subroutine advance_explicit_rk4 (g, restart_time_step, istep) standard RK4 Read more… Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g logical, intent(inout) :: restart_time_step integer, intent(in) :: istep private  subroutine solve_gke (pdf, rhs_ky, restart_time_step, istep) solve_gke accepts as argument pdf, the guiding centre distribution function in k-space,\nand returns rhs_ky, the right-hand side of the gyrokinetic equation in k-space;\ni.e., if dg/dt = r, then rhs_ky = r dt;\nnote that if include_apar = T, then the input pdf is actually gbar = g + (Ze/T) (vpa/c) F0 Read more… Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: pdf complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:), target :: rhs_ky logical, intent(out) :: restart_time_step integer, intent(in) :: istep private  subroutine advance_wstar_explicit (phi, gout) start timing the time advance due to the driving gradients Read more… Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout private  subroutine advance_wdrifty_explicit (g, phi, bpar, gout) advance_wdrifty_explicit subroutine calculates and adds the y-component of the\nmagnetic drift term to the RHS of the GK equation Read more… Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(in), dimension(:, :, -nzgrid:, :) :: bpar complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout private  subroutine advance_wdriftx_explicit (g, phi, bpar, gout) advance_wdriftx_explicit subroutine calculates and adds the x-component of the\nmagnetic drift term to the RHS of the GK equation Read more… Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(in), dimension(:, :, -nzgrid:, :) :: bpar complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout private  subroutine advance_ExB_nonlinearity (g, gout, restart_time_step, istep) compute phase factor needed when running with equilibrium flow shear\ncompute i ky g\nFFT to get dg/dy in (y,x) space\ncompute i kx if running with equilibrium flow shear, make adjustment to\nthe term multiplying dg/dy\nFFT to get d /dx in (y,x) space\nmultiply by the geometric factor appearing in the Poisson bracket;\ni.e., (dx/dpsi dy/dalpha) 0.5\ncompute the contribution to the Poisson bracket from dg/dy*d /dx Read more… Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout logical, intent(out) :: restart_time_step integer, intent(in) :: istep private  subroutine advance_parallel_nonlinearity (g, gout, restart_time_step) check estimated cfl_dt to see if the time step size needs to be changed Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout logical, intent(out) :: restart_time_step private  subroutine advance_radial_variation (g, gout) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout private  subroutine get_dgdy_2d (g, dgdy) compute dg/dy in k-space\naccepts g(ky,kx) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: g complex, intent(out), dimension(:, :) :: dgdy private  subroutine get_dgdy_3d (g, dgdy) compute dg/dy in k-space\naccepts g(ky,kx,z,tube) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: dgdy private  subroutine get_dgdy_4d (g, dgdy) compute dg/dy in k-space\naccepts g(ky,kx,z,tube,(vpa,mu,spec)) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dgdy private  subroutine get_dgdx_2d (g, dgdx) compute dg/dx in k-space\naccepts g(ky,kx) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: g complex, intent(out), dimension(:, :) :: dgdx private  subroutine get_dgdx_3d (g, dgdx) compute dg/dx in k-space\naccepts g(ky,kx,z,tube) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: dgdx private  subroutine get_dgdx_4d (g, dgdx) compute dg/dx in k-space\naccepts g(ky,kx,z,tube,(vpa,mu,spec)) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dgdx private  subroutine add_explicit_term (g, pre_factor, src) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g real, intent(in), dimension(-nzgrid:, vmu_lo%llim_proc:) :: pre_factor complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: src private  subroutine add_explicit_term_ffs (g, pre_factor, src) add vM . grad y d /dy or vM . grad x d /dx (or equivalents with g) or omega_* * d /dy term to RHS of GK equation Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g real, intent(in), dimension(:, -nzgrid:, vmu_lo%llim_proc:) :: pre_factor complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: src private  subroutine advance_implicit (istep, phi, apar, bpar, g) Arguments Type Intent Optional Attributes Name integer, intent(in) :: istep complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi complex, intent(inout), dimension(:, :, -nzgrid:, :) :: apar complex, intent(inout), dimension(:, :, -nzgrid:, :) :: bpar complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g private  subroutine mb_communicate (g_in) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g_in private  subroutine checksum_field (field, total) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: field real, intent(out) :: total private  subroutine checksum_dist (dist, total, norm) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dist real, intent(out) :: total logical, intent(in), optional :: norm public  subroutine finish_time_advance () Arguments None private  subroutine finish_parallel_nonlinearity () Arguments None private  subroutine finish_wdrift () Arguments None private  subroutine finish_wstar () Arguments None private  subroutine deallocate_arrays () Arguments None","tags":"","loc":"module/time_advance.html"},{"title":"finite_differences – stella","text":"Interfaces public        interface fd3pt public  subroutine fd3pt_real (prof, profgrad, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: prof real, intent(out), dimension(:) :: profgrad real, intent(in) :: dr public  subroutine fd3pt_real_array (prof, profgrad, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: prof real, intent(out), dimension(:) :: profgrad real, intent(in), dimension(:) :: dr public  subroutine fd3pt_complex_array (prof, profgrad, dr) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: prof complex, intent(out), dimension(:) :: profgrad real, intent(in), dimension(:) :: dr public        interface fd5pt public  subroutine fd5pt_real (prof, profgrad, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: prof real, intent(out), dimension(:) :: profgrad real, intent(in) :: dr public  subroutine fd5pt_array (prof, profgrad, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: prof real, intent(out), dimension(:) :: profgrad real, intent(in), dimension(:) :: dr public        interface first_order_upwind public  subroutine first_order_upwind_real (llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(out), dimension(llim:) :: df public  subroutine first_order_upwind_complex (llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(out), dimension(llim:) :: df public        interface third_order_upwind public  subroutine third_order_upwind_complex (llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(out), dimension(llim:) :: df public  subroutine third_order_upwind_real (llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(out), dimension(llim:) :: df public        interface fifth_order_upwind public  subroutine fifth_order_upwind_complex (llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(out), dimension(llim:) :: df public  subroutine fifth_order_upwind_real (llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(out), dimension(llim:) :: df public        interface tridag public  subroutine tridag_real (aa, bb, cc, sol) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: aa real, intent(in), dimension(:) :: bb real, intent(in), dimension(:) :: cc real, intent(inout), dimension(:) :: sol public  subroutine tridag_complex (llim, aa, bb, cc, sol) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: aa real, intent(in), dimension(llim:) :: bb real, intent(in), dimension(llim:) :: cc complex, intent(inout), dimension(llim:) :: sol public        interface second_order_centered public  subroutine second_order_centered_real (llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del real, intent(out), dimension(llim:) :: df public  subroutine second_order_centered_complex (llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del complex, intent(out), dimension(llim:) :: df public        interface four_point_triangle public  subroutine four_point_triangle_real (llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del real, intent(out), dimension(llim:) :: df public  subroutine four_point_triangle_complex (llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del complex, intent(out), dimension(llim:) :: df public        interface fourth_order_centered public  subroutine fourth_order_centered_real (llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del real, intent(out), dimension(llim:) :: df public  subroutine fourth_order_centered_complex (llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del complex, intent(out), dimension(llim:) :: df public        interface second_order_centered_zed public  subroutine second_order_centered_zed_real (llim, iseg, nseg, f, del, sgn, fl, fr, periodic, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim integer, intent(in) :: iseg integer, intent(in) :: nseg real, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(in), dimension(:) :: fl real, intent(in), dimension(:) :: fr logical, intent(in) :: periodic real, intent(out), dimension(llim:) :: df public  subroutine second_order_centered_zed_complex (llim, iseg, nseg, f, del, sgn, fl, fr, periodic, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim integer, intent(in) :: iseg integer, intent(in) :: nseg complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(in), dimension(:) :: fl complex, intent(in), dimension(:) :: fr logical, intent(in) :: periodic complex, intent(out), dimension(llim:) :: df public        interface d2_3pt public  subroutine d2_3pt_real (f, d2f, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: f real, intent(out), dimension(:) :: d2f real, intent(in), dimension(:) :: dr public  subroutine d2_3pt_complex (f, d2f, dr) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: f complex, intent(out), dimension(:) :: d2f real, intent(in), dimension(:) :: dr Subroutines public  subroutine first_order_upwind_real (llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(out), dimension(llim:) :: df public  subroutine first_order_upwind_complex (llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(out), dimension(llim:) :: df public  subroutine third_order_upwind_complex (llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(out), dimension(llim:) :: df public  subroutine third_order_upwind_real (llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(out), dimension(llim:) :: df public  subroutine fifth_order_upwind_complex (llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(out), dimension(llim:) :: df public  subroutine fifth_order_upwind_real (llim, f, del, sgn, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(out), dimension(llim:) :: df public  subroutine third_order_upwind_zed (llim, iseg, nseg, f, del, sgn, fl, fr, periodic, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim integer, intent(in) :: iseg integer, intent(in) :: nseg complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(in), dimension(:) :: fl complex, intent(in), dimension(:) :: fr logical, intent(in) :: periodic complex, intent(out), dimension(llim:) :: df public  subroutine first_order_upwind_zed (llim, iseg, nseg, f, del, sgn, fl, fr, periodic, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim integer, intent(in) :: iseg integer, intent(in) :: nseg complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(in), dimension(:) :: fl complex, intent(in), dimension(:) :: fr logical, intent(in) :: periodic complex, intent(out), dimension(llim:) :: df public  subroutine second_order_centered_real (llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del real, intent(out), dimension(llim:) :: df public  subroutine second_order_centered_complex (llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del complex, intent(out), dimension(llim:) :: df public  subroutine four_point_triangle_real (llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del real, intent(out), dimension(llim:) :: df public  subroutine four_point_triangle_complex (llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del complex, intent(out), dimension(llim:) :: df public  subroutine fourth_order_centered_real (llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: f real, intent(in) :: del real, intent(out), dimension(llim:) :: df public  subroutine fourth_order_centered_complex (llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del complex, intent(out), dimension(llim:) :: df public  subroutine second_order_centered_zed_real (llim, iseg, nseg, f, del, sgn, fl, fr, periodic, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim integer, intent(in) :: iseg integer, intent(in) :: nseg real, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(in), dimension(:) :: fl real, intent(in), dimension(:) :: fr logical, intent(in) :: periodic real, intent(out), dimension(llim:) :: df public  subroutine second_order_centered_zed_complex (llim, iseg, nseg, f, del, sgn, fl, fr, periodic, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim integer, intent(in) :: iseg integer, intent(in) :: nseg complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(in), dimension(:) :: fl complex, intent(in), dimension(:) :: fr logical, intent(in) :: periodic complex, intent(out), dimension(llim:) :: df public  subroutine second_order_centered_vpa (llim, f, del, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del complex, intent(out), dimension(llim:) :: df public  subroutine fd_cell_centres_zed (llim, f, del, sgn, fl, fr, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn complex, intent(in) :: fl complex, intent(in) :: fr complex, intent(out), dimension(llim:) :: df public  subroutine cell_centres_zed (llim, f, upwnd, sgn, fl, fr, fc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: upwnd integer, intent(in) :: sgn complex, intent(in) :: fl complex, intent(in) :: fr complex, intent(out), dimension(llim:) :: fc public  subroutine fd_variable_upwinding_zed (llim, iseg, nseg, f, del, sgn, upwnd, fl, fr, periodic, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim integer, intent(in) :: iseg integer, intent(in) :: nseg complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(in) :: upwnd complex, intent(in), dimension(:) :: fl complex, intent(in), dimension(:) :: fr logical, intent(in) :: periodic complex, intent(out), dimension(llim:) :: df public  subroutine fd_variable_upwinding_vpa (llim, f, del, sgn, upwnd, df) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim complex, intent(in), dimension(llim:) :: f real, intent(in) :: del integer, intent(in) :: sgn real, intent(in) :: upwnd complex, intent(out), dimension(llim:) :: df public  subroutine fd3pt_real (prof, profgrad, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: prof real, intent(out), dimension(:) :: profgrad real, intent(in) :: dr public  subroutine fd3pt_real_array (prof, profgrad, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: prof real, intent(out), dimension(:) :: profgrad real, intent(in), dimension(:) :: dr public  subroutine fd3pt_complex_array (prof, profgrad, dr) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: prof complex, intent(out), dimension(:) :: profgrad real, intent(in), dimension(:) :: dr public  subroutine fd5pt_real (prof, profgrad, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: prof real, intent(out), dimension(:) :: profgrad real, intent(in) :: dr public  subroutine fd5pt_array (prof, profgrad, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: prof real, intent(out), dimension(:) :: profgrad real, intent(in), dimension(:) :: dr public  subroutine d2_3pt_real (f, d2f, dr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: f real, intent(out), dimension(:) :: d2f real, intent(in), dimension(:) :: dr public  subroutine d2_3pt_complex (f, d2f, dr) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: f complex, intent(out), dimension(:) :: d2f real, intent(in), dimension(:) :: dr public  subroutine tridag_real (aa, bb, cc, sol) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: aa real, intent(in), dimension(:) :: bb real, intent(in), dimension(:) :: cc real, intent(inout), dimension(:) :: sol public  subroutine tridag_complex (llim, aa, bb, cc, sol) Arguments Type Intent Optional Attributes Name integer, intent(in) :: llim real, intent(in), dimension(llim:) :: aa real, intent(in), dimension(llim:) :: bb real, intent(in), dimension(llim:) :: cc complex, intent(inout), dimension(llim:) :: sol","tags":"","loc":"module/finite_differences.html"},{"title":"smooth_step – stella","text":"Functions public pure function smoothstep (x, N, minV, maxV) Arguments Type Intent Optional Attributes Name real, intent(in) :: x integer, intent(in) :: N real, intent(in), optional :: minV real, intent(in), optional :: maxV Return Value real public pure function smoothstep0 (x) Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value real public pure function smoothstep1 (x) Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value real public pure function smoothstep2 (x) Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value real public pure function smoothstepN (x, N) Arguments Type Intent Optional Attributes Name real, intent(in) :: x integer, intent(in) :: N Return Value real public pure function pascalTriangle (a, b) Arguments Type Intent Optional Attributes Name integer, intent(in) :: a integer, intent(in) :: b Return Value integer","tags":"","loc":"module/smooth_step.html"},{"title":"euterpe_interface – stella","text":"Subroutines public  subroutine read_species_euterpe (nspec, spec) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nspec type( spec_type ), intent(inout), dimension(:) :: spec public  subroutine read_euterpe_parameters (nradii_out, data_file_out) Arguments Type Intent Optional Attributes Name integer, intent(out) :: nradii_out character(len=*), intent(out) :: data_file_out","tags":"","loc":"module/euterpe_interface.html"},{"title":"mt19937 – stella","text":"Variables Type Visibility Attributes Name Initial integer, private, parameter :: default_seed = 4357 integer, private, parameter :: N = 624 integer, private, parameter :: M = 397 integer, private, parameter :: MATA = -1727483681 integer, private, parameter :: LMASK = 2147483647 integer, private, parameter :: UMASK = -LMASK-1 integer, private, parameter :: TMASKB = -1658038656 integer, private, parameter :: TMASKC = -272236544 integer, private, save :: mt (0:N-1) integer, private, save :: mti = N+1 integer, private, save :: mag01 (0:1) = (/0, MATA/) Functions public  function grnd () Arguments None Return Value real Subroutines public  subroutine sgrnd (seed) Arguments Type Intent Optional Attributes Name integer, intent(in) :: seed","tags":"","loc":"module/mt19937.html"},{"title":"stella_layouts – stella","text":"Uses common_types Variables Type Visibility Attributes Name Initial character(len=4), public :: xyzs_layout character(len=3), public :: vms_layout logical, private :: exist type( kxkyz_layout_type ), public :: kxkyz_lo type( kxyz_layout_type ), public :: kxyz_lo type( xyz_layout_type ), public :: xyz_lo type( vmu_layout_type ), public :: vmu_lo Interfaces public        interface it_idx private elemental function it_idx_kxkyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function it_idx_kxyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function it_idx_xyz (lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer public        interface iz_idx private elemental function iz_idx_kxkyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function iz_idx_kxyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function iz_idx_xyz (lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer public        interface iv_idx private elemental function iv_idx_vmu (lo, i) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer public        interface iky_idx private elemental function iky_idx_kxkyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer public        interface iy_idx private elemental function iy_idx_kxyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function iy_idx_xyz (lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer public        interface ikx_idx private elemental function ikx_idx_kxkyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function ikx_idx_kxyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private        interface ix_idx private elemental function ix_idx_xyz (lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer public        interface imu_idx private elemental function imu_idx_vmu (lo, i) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer public        interface is_idx private elemental function is_idx_kxkyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function is_idx_kxyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function is_idx_xyz (lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function is_idx_vmu (lo, i) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer public        interface proc_id private elemental function proc_id_kxkyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function proc_id_kxyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function proc_id_xyz (lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function proc_id_vmu (lo, i) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer public        interface idx private elemental function idx_kxkyz (lo, iky, ikx, iz, it, is) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value integer private elemental function idx_kxyz (lo, iy, ikx, iz, it, is) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: iy integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value integer private elemental function idx_xyz (lo, iy, ix, iz, it, is) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: iy integer, intent(in) :: ix integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value integer private elemental function idx_vmu (lo, iv, imu, is) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: iv integer, intent(in) :: imu integer, intent(in) :: is Return Value integer public        interface idx_local private elemental function idx_local_kxkyz (lo, iky, ikx, iz, it, is) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value logical private elemental function iz_local_kxkyz (lo, iz) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: iz Return Value logical private elemental function idx_local_kxyz (lo, iy, ikx, iz, it, is) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: iy integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value logical private elemental function iz_local_kxyz (lo, iz) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: iz Return Value logical private elemental function idx_local_xyz (lo, iy, ix, iz, it, is) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: iy integer, intent(in) :: ix integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value logical private elemental function iz_local_xyz (lo, iz) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: iz Return Value logical private elemental function idx_local_vmu (lo, iv, imu, is) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: iv integer, intent(in) :: imu integer, intent(in) :: is Return Value logical private elemental function iz_local_vmu (lo, iz) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: iz Return Value logical Functions private elemental function is_idx_kxkyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function ikx_idx_kxkyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function iky_idx_kxkyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function iz_idx_kxkyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function it_idx_kxkyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function proc_id_kxkyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function idx_kxkyz (lo, iky, ikx, iz, it, is) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value integer private elemental function idx_local_kxkyz (lo, iky, ikx, iz, it, is) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value logical private elemental function iz_local_kxkyz (lo, iz) Arguments Type Intent Optional Attributes Name type( kxkyz_layout_type ), intent(in) :: lo integer, intent(in) :: iz Return Value logical private elemental function is_idx_kxyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function ikx_idx_kxyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function iy_idx_kxyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function iz_idx_kxyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function it_idx_kxyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function proc_id_kxyz (lo, i) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function idx_kxyz (lo, iy, ikx, iz, it, is) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: iy integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value integer private elemental function idx_local_kxyz (lo, iy, ikx, iz, it, is) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: iy integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value logical private elemental function iz_local_kxyz (lo, iz) Arguments Type Intent Optional Attributes Name type( kxyz_layout_type ), intent(in) :: lo integer, intent(in) :: iz Return Value logical private elemental function is_idx_xyz (lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function ix_idx_xyz (lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function iy_idx_xyz (lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function iz_idx_xyz (lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function it_idx_xyz (lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function proc_id_xyz (lo, i) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function idx_xyz (lo, iy, ix, iz, it, is) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: iy integer, intent(in) :: ix integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value integer private elemental function idx_local_xyz (lo, iy, ix, iz, it, is) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: iy integer, intent(in) :: ix integer, intent(in) :: iz integer, intent(in) :: it integer, intent(in) :: is Return Value logical private elemental function iz_local_xyz (lo, iz) Arguments Type Intent Optional Attributes Name type( xyz_layout_type ), intent(in) :: lo integer, intent(in) :: iz Return Value logical private elemental function is_idx_vmu (lo, i) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function imu_idx_vmu (lo, i) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function iv_idx_vmu (lo, i) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function proc_id_vmu (lo, i) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: i Return Value integer private elemental function idx_vmu (lo, iv, imu, is) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: iv integer, intent(in) :: imu integer, intent(in) :: is Return Value integer private elemental function idx_local_vmu (lo, iv, imu, is) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: iv integer, intent(in) :: imu integer, intent(in) :: is Return Value logical private elemental function iz_local_vmu (lo, iz) Arguments Type Intent Optional Attributes Name type( vmu_layout_type ), intent(in) :: lo integer, intent(in) :: iz Return Value logical Subroutines public  subroutine init_stella_layouts () Arguments None private  subroutine read_parameters () Arguments None private  subroutine broadcast_results () Arguments None public  subroutine init_dist_fn_layouts (nzgrid, ntubes, naky, nakx, nvgrid, nmu, nspec, ny, nx, nalpha) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nzgrid integer, intent(in) :: ntubes integer, intent(in) :: naky integer, intent(in) :: nakx integer, intent(in) :: nvgrid integer, intent(in) :: nmu integer, intent(in) :: nspec integer, intent(in) :: ny integer, intent(in) :: nx integer, intent(in) :: nalpha private  subroutine init_kxkyz_layout (nzgrid, ntubes, naky, nakx, nvgrid, nmu, nspec) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nzgrid integer, intent(in) :: ntubes integer, intent(in) :: naky integer, intent(in) :: nakx integer, intent(in) :: nvgrid integer, intent(in) :: nmu integer, intent(in) :: nspec private  subroutine init_kxyz_layout (nzgrid, ntubes, naky, nakx, nvgrid, nmu, nspec, ny) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nzgrid integer, intent(in) :: ntubes integer, intent(in) :: naky integer, intent(in) :: nakx integer, intent(in) :: nvgrid integer, intent(in) :: nmu integer, intent(in) :: nspec integer, intent(in) :: ny private  subroutine init_xyz_layout (nzgrid, ntubes, naky, nakx, nvgrid, nmu, nspec, ny, nx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nzgrid integer, intent(in) :: ntubes integer, intent(in) :: naky integer, intent(in) :: nakx integer, intent(in) :: nvgrid integer, intent(in) :: nmu integer, intent(in) :: nspec integer, intent(in) :: ny integer, intent(in) :: nx private  subroutine init_vmu_layout (nzgrid, ntubes, naky, nakx, nvgrid, nmu, nspec, ny, nx, nalpha) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nzgrid integer, intent(in) :: ntubes integer, intent(in) :: naky integer, intent(in) :: nakx integer, intent(in) :: nvgrid integer, intent(in) :: nmu integer, intent(in) :: nspec integer, intent(in) :: ny integer, intent(in) :: nx integer, intent(in) :: nalpha public elemental subroutine kxkyzidx2vmuidx (iv, imu, ikxkyz, kxkyz_lo, vmu_lo, iky, ikx, iz, it, ivmu) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv integer, intent(in) :: imu integer, intent(in) :: ikxkyz type( kxkyz_layout_type ), intent(in) :: kxkyz_lo type( vmu_layout_type ), intent(in) :: vmu_lo integer, intent(out) :: iky integer, intent(out) :: ikx integer, intent(out) :: iz integer, intent(out) :: it integer, intent(out) :: ivmu public elemental subroutine kxyzidx2vmuidx (iv, imu, ikxyz, kxyz_lo, vmu_lo, iy, ikx, iz, it, ivmu) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv integer, intent(in) :: imu integer, intent(in) :: ikxyz type( kxyz_layout_type ), intent(in) :: kxyz_lo type( vmu_layout_type ), intent(in) :: vmu_lo integer, intent(out) :: iy integer, intent(out) :: ikx integer, intent(out) :: iz integer, intent(out) :: it integer, intent(out) :: ivmu public elemental subroutine xyzidx2vmuidx (iv, imu, ixyz, xyz_lo, vmu_lo, iy, ix, iz, it, ivmu) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv integer, intent(in) :: imu integer, intent(in) :: ixyz type( xyz_layout_type ), intent(in) :: xyz_lo type( vmu_layout_type ), intent(in) :: vmu_lo integer, intent(out) :: iy integer, intent(out) :: ix integer, intent(out) :: iz integer, intent(out) :: it integer, intent(out) :: ivmu public  subroutine finish_layouts () Arguments None","tags":"","loc":"module/stella_layouts.html"},{"title":"inputprofiles_interface – stella","text":"Variables Type Visibility Attributes Name Initial integer, private :: n_exp real, private, dimension(:), allocatable :: rhotor real, private, dimension(:), allocatable :: rmin real, private, dimension(:), allocatable :: rmaj_in real, private, dimension(:), allocatable :: qinp real, private, dimension(:), allocatable :: kappa real, private, dimension(:), allocatable :: delta real, private, dimension(:), allocatable :: Te real, private, dimension(:), allocatable :: ne real, private, dimension(:), allocatable :: z_eff real, private, dimension(:), allocatable :: omega0 real, private, dimension(:), allocatable :: ni real, private, dimension(:), allocatable :: Ti real, private, dimension(:), allocatable :: dr real, private, dimension(:), allocatable :: rhoc real, private, dimension(:), allocatable :: rmaj real, private, dimension(:), allocatable :: shift real, private, dimension(:), allocatable :: shat real, private, dimension(:), allocatable :: d2qdr2 real, private, dimension(:), allocatable :: tri real, private, dimension(:), allocatable :: triprim real, private, dimension(:), allocatable :: kapprim real, private, dimension(:), allocatable :: neprim real, private, dimension(:), allocatable :: Teprim real, private, dimension(:), allocatable :: niprim real, private, dimension(:), allocatable :: Tiprim real, private, dimension(:), allocatable :: nedbprim real, private, dimension(:), allocatable :: Tedbprim real, private, dimension(:), allocatable :: nidbprim real, private, dimension(:), allocatable :: Tidbprim real, private, dimension(:), allocatable :: betaprim real, private, dimension(:), allocatable :: betadbprim real, private, dimension(:), allocatable :: psitor real, private, dimension(:), allocatable :: drhotordrho real, private, dimension(:), allocatable :: dpsitordrho real, private, dimension(:), allocatable :: d2psitordrho2 real, private, dimension(:), allocatable :: pres_tot real, private, dimension(:), allocatable :: loglam real, private :: bref real, private :: omega_ref real, private :: rho_ref real, private :: bunit Subroutines public  subroutine read_inputprof_geo (surf) Arguments Type Intent Optional Attributes Name type( flux_surface_type ), intent(inout) :: surf public  subroutine read_inputprof_spec (nspec, spec) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nspec type( spec_type ), intent(inout), dimension(:) :: spec private  subroutine allocate_arrays_geo () Arguments None private  subroutine allocate_arrays_spec () Arguments None private  subroutine deallocate_arrays_geo () Arguments None private  subroutine deallocate_arrays_spec () Arguments None","tags":"","loc":"module/inputprofiles_interface.html"},{"title":"multibox – stella","text":"Uses fft_work Variables Type Visibility Attributes Name Initial complex, private, dimension(:), allocatable :: g_buffer0 complex, private, dimension(:), allocatable :: g_buffer1 complex, public, dimension(:), allocatable :: phi_buffer0 complex, public, dimension(:), allocatable :: phi_buffer1 complex, private, dimension(:), allocatable :: fsa_x real, private, dimension(:), allocatable :: copy_mask_left real, private, dimension(:), allocatable :: copy_mask_right real, private, dimension(:), allocatable :: krook_mask_left real, private, dimension(:), allocatable :: krook_mask_right real, private, dimension(:), allocatable :: krook_fac real, private, dimension(:), allocatable :: b_mat real, private, dimension(:), allocatable :: x_mb real, private, dimension(:), allocatable :: rho_mb real, private, dimension(:), allocatable :: rho_mb_clamped real, public, dimension(2, 2) :: time_multibox = 0. real, private :: dx_mb complex, private, dimension(:, :), allocatable :: fft_kxky complex, private, dimension(:, :), allocatable :: fft_xky real, private, dimension(:, :), allocatable :: fft_xy type( fft_type ), private :: yf_fft type( fft_type ), private :: yb_fft type( fft_type ), private :: xf_fft type( fft_type ), private :: xb_fft complex, private, dimension(:), allocatable :: fft_x_k complex, private, dimension(:), allocatable :: fft_x_x complex, private, dimension(:), allocatable :: fft_y_k real, private, dimension(:), allocatable :: fft_y_y logical, private :: mb_transforms_initialized = .false. logical, private :: get_phi_initialized = .false. logical, private :: use_multibox integer, private :: temp_ind = 0 integer, public :: bs_fullgrid integer, private :: mb_debug_step integer, private :: x_fft_size integer, private :: phi_bound integer, private :: phi_pow integer, private :: ikymin real, public :: xL = 0. real, public :: xR = 0. real, public :: rhoL = 0. real, public :: rhoR = 0. real, public :: kx0_L real, public :: kx0_R real, private :: nu_krook_mb real, private :: krook_exponent real, private :: krook_efold logical, private :: smooth_ZFs logical, public :: use_dirichlet_BC logical, public :: RK_step logical, public :: include_multibox_krook logical, public :: comm_at_init integer, private :: krook_option_switch integer, private, parameter :: krook_option_default = 2 integer, private, parameter :: krook_option_flat = 0 integer, private, parameter :: krook_option_linear = 1 integer, private, parameter :: krook_option_exp = 2 integer, private, parameter :: krook_option_exp_rev = 3 integer, private :: mb_zf_option_switch integer, private, parameter :: mb_zf_option_default = 0 integer, private, parameter :: mb_zf_option_skip_ky0 = 1 integer, private, parameter :: mb_zf_option_zero_ky0 = 2 integer, private, parameter :: mb_zf_option_zero_fsa = 3 integer, private :: LR_debug_switch integer, private, parameter :: LR_debug_option_default = 0 integer, private, parameter :: LR_debug_option_L = 1 integer, private, parameter :: LR_debug_option_R = 2 Subroutines public  subroutine read_multibox_parameters () Arguments None public  subroutine init_multibox () Arguments None public  subroutine communicate_multibox_parameters () Arguments None public  subroutine finish_multibox () Arguments None public  subroutine multibox_communicate (gin) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gin public  subroutine apply_radial_boundary_conditions (gin) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gin public  subroutine add_multibox_krook (g, rhs) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: rhs public  subroutine init_mb_get_phi (has_elec, adiabatic_elec, efac, efacp) Arguments Type Intent Optional Attributes Name logical, intent(in) :: has_elec logical, intent(in) :: adiabatic_elec real, intent(in) :: efac real, intent(in) :: efacp public  subroutine mb_get_phi (phi, has_elec, adiabatic_elec) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :) :: phi logical, intent(in) :: has_elec logical, intent(in) :: adiabatic_elec private  subroutine init_mb_transforms () Arguments None private  subroutine init_x_fft () Arguments None private  subroutine init_y_fft () Arguments None private  subroutine transform_kx2x (gkx, gx) transform routines start here Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gkx complex, intent(out), dimension(:, :) :: gx private  subroutine transform_x2kx (gx, gkx) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gx complex, intent(out), dimension(:, :) :: gkx private  subroutine transform_ky2y (gky, gy) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gky real, intent(out), dimension(:, :) :: gy private  subroutine finish_mb_transforms () Arguments None","tags":"","loc":"module/multibox.html"},{"title":"mp – stella","text":"Uses mpi Variables Type Visibility Attributes Name Initial integer, public, pointer :: nproc integer, private, target :: ntot_proc integer, private, target :: nshared_proc integer, private, target :: ngroup_proc integer, private, target :: ndomain_proc integer, private, target :: nsgroup_proc integer, private, target :: nscross_proc integer, public :: numnodes integer, public :: inode integer, public, pointer :: iproc integer, private, target :: aproc integer, private, target :: sproc integer, private, target :: gproc integer, private, target :: cproc integer, private, target :: sgproc integer, private, target :: scproc logical, public, pointer :: proc0 logical, private, target :: aproc0 logical, private, target :: sproc0 logical, private, target :: gproc0 logical, public, target :: sgproc0 integer, private :: mpi_comm_world_private integer, public, pointer :: mp_comm integer, private, target :: comm_all integer, private, target :: comm_shared integer, private, target :: comm_node integer, public, target :: comm_group integer, private, target :: comm_cross integer, public, target :: comm_sgroup integer, private, target :: comm_scross integer, public :: curr_focus integer, public, parameter :: mp_info = MPI_INFO_NULL integer, public :: job = 0 integer, public :: min_proc integer(kind=kind(MPI_REAL)), public :: mpireal integer(kind=kind(MPI_REAL)), public :: mpicmplx integer(kind=MPI_ADDRESS_KIND), public :: real_size integer, public, parameter :: allprocs = 0 integer, public, parameter :: sharedprocs = 1 integer, public, parameter :: subprocs = 2 integer, public, parameter :: crossdomprocs = 3 integer, public, parameter :: sharedsubprocs = 4 integer, public, parameter :: scrossdomprocs = 5 integer, public :: nbytes_real integer, private, dimension(:), allocatable :: grp0 logical, public :: trin_flag = .false. Interfaces public        interface broadcast private  subroutine broadcast_integer (i) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i private  subroutine broadcast_integer_array (i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i private  subroutine broadcast_real (x) Arguments Type Intent Optional Attributes Name real, intent(inout) :: x private  subroutine broadcast_real_array (x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: x private  subroutine broadcast_real_2array (x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :) :: x private  subroutine broadcast_real_3array (x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :) :: x private  subroutine broadcast_real_4array (x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :) :: x private  subroutine broadcast_real_5array (x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :) :: x private  subroutine broadcast_complex (z) Arguments Type Intent Optional Attributes Name complex, intent(inout) :: z private  subroutine broadcast_complex_array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: z private  subroutine broadcast_complex_2array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: z private  subroutine broadcast_complex_3array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :) :: z private  subroutine broadcast_complex_4array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :) :: z private  subroutine broadcast_logical (f) Arguments Type Intent Optional Attributes Name logical, intent(inout) :: f private  subroutine broadcast_logical_array (f) Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:) :: f private  subroutine bcastfrom_integer (i, src) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i integer, intent(in) :: src private  subroutine bcastfrom_integer_array (i, src) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i integer, intent(in) :: src private  subroutine bcastfrom_real (x, src) Arguments Type Intent Optional Attributes Name real, intent(inout) :: x integer, intent(in) :: src private  subroutine bcastfrom_real_array (x, src) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: x integer, intent(in) :: src private  subroutine bcastfrom_complex (z, src) Arguments Type Intent Optional Attributes Name complex, intent(inout) :: z integer, intent(in) :: src private  subroutine bcastfrom_complex_array (z, src) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: z integer, intent(in) :: src private  subroutine bcastfrom_complex_2array (z, src) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: z integer, intent(in) :: src private  subroutine bcastfrom_logical (f, src) Arguments Type Intent Optional Attributes Name logical, intent(inout) :: f integer, intent(in) :: src private  subroutine bcastfrom_logical_array (f, src) Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:) :: f integer, intent(in) :: src private  subroutine broadcast_character (char) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: char private  subroutine bcastfrom_character (c, src) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: c integer, intent(in) :: src public        interface sum_reduce private  subroutine sum_reduce_integer (i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i integer, intent(in) :: dest private  subroutine sum_reduce_integer_array (i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i integer, intent(in) :: dest private  subroutine sum_reduce_real (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a integer, intent(in) :: dest private  subroutine sum_reduce_real_array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a integer, intent(in) :: dest private  subroutine sum_reduce_real_2array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :) :: a integer, intent(in) :: dest private  subroutine sum_reduce_real_3array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :) :: a integer, intent(in) :: dest private  subroutine sum_reduce_real_4array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :) :: a integer, intent(in) :: dest private  subroutine sum_reduce_real_5array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :) :: a integer, intent(in) :: dest private  subroutine sum_reduce_complex (z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout) :: z integer, intent(in) :: dest private  subroutine sum_reduce_complex_array (z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: z integer, intent(in) :: dest private  subroutine sum_reduce_complex_2array (z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: z integer, intent(in) :: dest private  subroutine sum_reduce_complex_3array (z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :) :: z integer, intent(in) :: dest private  subroutine sum_reduce_complex_4array (z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :) :: z integer, intent(in) :: dest private  subroutine sum_reduce_complex_5array (z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :, :) :: z integer, intent(in) :: dest public        interface sum_allreduce private  subroutine sum_allreduce_integer (i) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i private  subroutine sum_allreduce_integer_array (i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i private  subroutine sum_allreduce_integer_2array (i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:, :) :: i private  subroutine sum_allreduce_real (a) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a private  subroutine sum_allreduce_real_array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a private  subroutine sum_allreduce_real_2array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :) :: a private  subroutine sum_allreduce_real_3array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :) :: a private  subroutine sum_allreduce_real_4array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :) :: a private  subroutine sum_allreduce_real_5array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :) :: a private  subroutine sum_allreduce_complex (z) Arguments Type Intent Optional Attributes Name complex, intent(inout) :: z private  subroutine sum_allreduce_complex_array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: z private  subroutine sum_allreduce_complex_2array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: z private  subroutine sum_allreduce_complex_3array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :) :: z private  subroutine sum_allreduce_complex_4array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :) :: z private  subroutine sum_allreduce_complex_5array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :, :) :: z public        interface max_reduce private  subroutine max_reduce_integer (i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i integer, intent(in) :: dest private  subroutine max_reduce_integer_array (i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i integer, intent(in) :: dest private  subroutine max_reduce_real (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a integer, intent(in) :: dest private  subroutine max_reduce_real_array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a integer, intent(in) :: dest public        interface max_allreduce private  subroutine max_allreduce_integer (i) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i private  subroutine max_allreduce_integer_array (i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i private  subroutine max_allreduce_real (a) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a private  subroutine max_allreduce_real_array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a public        interface min_reduce private  subroutine min_reduce_integer (i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i integer, intent(in) :: dest private  subroutine min_reduce_integer_array (i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i integer, intent(in) :: dest private  subroutine min_reduce_real (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a integer, intent(in) :: dest private  subroutine min_reduce_real_array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a integer, intent(in) :: dest public        interface min_allreduce private  subroutine min_allreduce_integer (i) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i private  subroutine min_allreduce_integer_array (i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i private  subroutine min_allreduce_real (a) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a private  subroutine min_allreduce_real_array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a public        interface send private  subroutine send_integer (i, dest, tag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine send_integer_array (i, dest, tag) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: i integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine send_real (a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine send_real_array (a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine send_real_array_2d (a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine send_complex (z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine send_complex_array (z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine nonblocking_send_complex_array (z, dest, tag, request) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag integer, intent(out) :: request private  subroutine send_logical (f, dest, tag) Arguments Type Intent Optional Attributes Name logical, intent(in) :: f integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine send_logical_array (f, dest, tag) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:) :: f integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine send_character (s, dest, tag) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s integer, intent(in) :: dest integer, intent(in), optional :: tag public        interface receive private  subroutine receive_integer (i, src, tag) Arguments Type Intent Optional Attributes Name integer, intent(out) :: i integer, intent(in) :: src integer, intent(in), optional :: tag private  subroutine receive_integer_array (i, src, tag) Arguments Type Intent Optional Attributes Name integer, intent(out), dimension(:) :: i integer, intent(in) :: src integer, intent(in), optional :: tag private  subroutine receive_real (a, src, tag) Arguments Type Intent Optional Attributes Name real, intent(out) :: a integer, intent(in) :: src integer, intent(in), optional :: tag private  subroutine receive_real_array (a, src, tag) Arguments Type Intent Optional Attributes Name real, intent(out), dimension(:) :: a integer, intent(in) :: src integer, intent(in), optional :: tag private  subroutine receive_real_array_2d (a, src, tag) Arguments Type Intent Optional Attributes Name real, intent(out), dimension(:, :) :: a integer, intent(in) :: src integer, intent(in), optional :: tag private  subroutine receive_complex (z, src, tag) Arguments Type Intent Optional Attributes Name complex, intent(out) :: z integer, intent(in) :: src integer, intent(in), optional :: tag private  subroutine receive_complex_array (z, src, tag) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:) :: z integer, intent(in) :: src integer, intent(in), optional :: tag private  subroutine receive_complex_2array (z, src, tag) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :) :: z integer, intent(in) :: src integer, intent(in), optional :: tag private  subroutine nonblocking_receive_complex_array (z, src, tag, request) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: z integer, intent(in) :: src integer, intent(in), optional :: tag integer, intent(out) :: request private  subroutine receive_logical (f, src, tag) Arguments Type Intent Optional Attributes Name logical, intent(out) :: f integer, intent(in) :: src integer, intent(in), optional :: tag private  subroutine receive_logical_array (f, src, tag) Arguments Type Intent Optional Attributes Name logical, intent(out), dimension(:) :: f integer, intent(in) :: src integer, intent(in), optional :: tag private  subroutine receive_character (s, src, tag) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: s integer, intent(in) :: src integer, intent(in), optional :: tag public        interface ssend private  subroutine ssend_integer (i, dest, tag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine ssend_integer_array (i, dest, tag) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: i integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine ssend_real (a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine ssend_real_array (a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine ssend_complex (z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine ssend_complex_array (z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine ssend_complex_2array (z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine ssend_logical (f, dest, tag) Arguments Type Intent Optional Attributes Name logical, intent(in) :: f integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine ssend_logical_array (f, dest, tag) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:) :: f integer, intent(in) :: dest integer, intent(in), optional :: tag public        interface all_to_group private  subroutine all_to_group_real (all, group, njobs) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: all real, intent(out) :: group integer, intent(in) :: njobs private  subroutine all_to_group_real_array (all, group, njobs) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: all real, intent(out), dimension(:) :: group integer, intent(in) :: njobs public        interface group_to_all private  subroutine group_to_all_real (group, all, njobs) Arguments Type Intent Optional Attributes Name real, intent(in) :: group real, intent(out), dimension(:) :: all integer, intent(in) :: njobs private  subroutine group_to_all_real_array (group, all, njobs) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: group real, intent(out), dimension(:, :) :: all integer, intent(in) :: njobs Subroutines public  subroutine init_mp (comm_in) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: comm_in public  subroutine scope (focus) Arguments Type Intent Optional Attributes Name integer, intent(in) :: focus public  subroutine init_job_topology (ncolumns, group0, ierr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncolumns integer, intent(out), dimension(0:) :: group0 integer :: ierr public  subroutine split_n_tasks (n, lo, hi) split n tasks over current communicator. Returns the low and high\nindices for a given processor. Assumes indices start at 1 Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(out) :: lo integer, intent(out) :: hi public  subroutine finish_mp () Arguments None private  subroutine broadcast_character (char) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: char private  subroutine broadcast_integer (i) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i private  subroutine broadcast_integer_array (i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i private  subroutine broadcast_real (x) Arguments Type Intent Optional Attributes Name real, intent(inout) :: x private  subroutine broadcast_real_array (x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: x private  subroutine broadcast_real_2array (x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :) :: x private  subroutine broadcast_real_3array (x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :) :: x private  subroutine broadcast_real_4array (x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :) :: x private  subroutine broadcast_real_5array (x) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :) :: x private  subroutine broadcast_complex (z) Arguments Type Intent Optional Attributes Name complex, intent(inout) :: z private  subroutine broadcast_complex_array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: z private  subroutine broadcast_complex_2array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: z private  subroutine broadcast_complex_3array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :) :: z private  subroutine broadcast_complex_4array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :) :: z private  subroutine broadcast_logical (f) Arguments Type Intent Optional Attributes Name logical, intent(inout) :: f private  subroutine broadcast_logical_array (f) Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:) :: f private  subroutine bcastfrom_logical (f, src) Arguments Type Intent Optional Attributes Name logical, intent(inout) :: f integer, intent(in) :: src private  subroutine bcastfrom_logical_array (f, src) Arguments Type Intent Optional Attributes Name logical, intent(inout), dimension(:) :: f integer, intent(in) :: src private  subroutine bcastfrom_character (c, src) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: c integer, intent(in) :: src private  subroutine bcastfrom_integer (i, src) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i integer, intent(in) :: src private  subroutine bcastfrom_integer_array (i, src) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i integer, intent(in) :: src private  subroutine bcastfrom_real (x, src) Arguments Type Intent Optional Attributes Name real, intent(inout) :: x integer, intent(in) :: src private  subroutine bcastfrom_real_array (x, src) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: x integer, intent(in) :: src private  subroutine bcastfrom_complex (z, src) Arguments Type Intent Optional Attributes Name complex, intent(inout) :: z integer, intent(in) :: src private  subroutine bcastfrom_complex_array (z, src) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: z integer, intent(in) :: src private  subroutine bcastfrom_complex_2array (z, src) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: z integer, intent(in) :: src private  subroutine sum_reduce_integer (i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i integer, intent(in) :: dest private  subroutine sum_reduce_integer_array (i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i integer, intent(in) :: dest private  subroutine sum_reduce_real (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a integer, intent(in) :: dest private  subroutine sum_reduce_real_array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a integer, intent(in) :: dest private  subroutine sum_reduce_real_2array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :) :: a integer, intent(in) :: dest private  subroutine sum_reduce_real_3array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :) :: a integer, intent(in) :: dest private  subroutine sum_reduce_real_4array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :) :: a integer, intent(in) :: dest private  subroutine sum_reduce_real_5array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :) :: a integer, intent(in) :: dest private  subroutine sum_reduce_complex (z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout) :: z integer, intent(in) :: dest private  subroutine sum_reduce_complex_array (z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: z integer, intent(in) :: dest private  subroutine sum_reduce_complex_2array (z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: z integer, intent(in) :: dest private  subroutine sum_reduce_complex_3array (z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :) :: z integer, intent(in) :: dest private  subroutine sum_reduce_complex_4array (z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :) :: z integer, intent(in) :: dest private  subroutine sum_reduce_complex_5array (z, dest) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :, :) :: z integer, intent(in) :: dest private  subroutine sum_allreduce_integer (i) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i private  subroutine sum_allreduce_integer_array (i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i private  subroutine sum_allreduce_integer_2array (i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:, :) :: i private  subroutine sum_allreduce_real (a) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a private  subroutine sum_allreduce_real_array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a private  subroutine sum_allreduce_real_2array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :) :: a private  subroutine sum_allreduce_real_3array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :) :: a private  subroutine sum_allreduce_real_4array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :) :: a private  subroutine sum_allreduce_real_5array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :) :: a private  subroutine sum_allreduce_complex (z) Arguments Type Intent Optional Attributes Name complex, intent(inout) :: z private  subroutine sum_allreduce_complex_array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: z private  subroutine sum_allreduce_complex_2array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: z private  subroutine sum_allreduce_complex_3array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :) :: z private  subroutine sum_allreduce_complex_4array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :) :: z private  subroutine sum_allreduce_complex_5array (z) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, :, :, :) :: z private  subroutine max_reduce_integer (i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i integer, intent(in) :: dest private  subroutine max_reduce_integer_array (i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i integer, intent(in) :: dest private  subroutine max_reduce_real (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a integer, intent(in) :: dest private  subroutine max_reduce_real_array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a integer, intent(in) :: dest private  subroutine max_allreduce_integer (i) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i private  subroutine max_allreduce_integer_array (i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i private  subroutine max_allreduce_real (a) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a private  subroutine max_allreduce_real_array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a private  subroutine min_reduce_integer (i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i integer, intent(in) :: dest private  subroutine min_reduce_integer_array (i, dest) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i integer, intent(in) :: dest private  subroutine min_reduce_real (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a integer, intent(in) :: dest private  subroutine min_reduce_real_array (a, dest) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a integer, intent(in) :: dest private  subroutine min_allreduce_integer (i) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i private  subroutine min_allreduce_integer_array (i) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: i private  subroutine min_allreduce_real (a) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a private  subroutine min_allreduce_real_array (a) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: a public  subroutine comm_split (color, comm_out, ierr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: color integer, intent(out) :: comm_out integer, intent(out) :: ierr public  subroutine comm_free (comm_in, ierr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: comm_in integer, intent(out) :: ierr public  subroutine barrier () Arguments None private  subroutine send_integer (i, dest, tag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine send_integer_array (i, dest, tag) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: i integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine send_real (a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine send_real_array (a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine send_real_array_2d (a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine send_complex (z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine send_complex_array (z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine nonblocking_send_complex_array (z, dest, tag, request) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag integer, intent(out) :: request private  subroutine send_logical (f, dest, tag) Arguments Type Intent Optional Attributes Name logical, intent(in) :: f integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine send_logical_array (f, dest, tag) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:) :: f integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine send_character (s, dest, tag) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine ssend_integer (i, dest, tag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine ssend_integer_array (i, dest, tag) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: i integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine ssend_real (a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine ssend_real_array (a, dest, tag) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: a integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine ssend_complex (z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine ssend_complex_array (z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine ssend_complex_2array (z, dest, tag) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: z integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine ssend_logical (f, dest, tag) Arguments Type Intent Optional Attributes Name logical, intent(in) :: f integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine ssend_logical_array (f, dest, tag) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:) :: f integer, intent(in) :: dest integer, intent(in), optional :: tag private  subroutine receive_integer (i, src, tag) Arguments Type Intent Optional Attributes Name integer, intent(out) :: i integer, intent(in) :: src integer, intent(in), optional :: tag private  subroutine receive_integer_array (i, src, tag) Arguments Type Intent Optional Attributes Name integer, intent(out), dimension(:) :: i integer, intent(in) :: src integer, intent(in), optional :: tag private  subroutine receive_real (a, src, tag) Arguments Type Intent Optional Attributes Name real, intent(out) :: a integer, intent(in) :: src integer, intent(in), optional :: tag private  subroutine receive_real_array (a, src, tag) Arguments Type Intent Optional Attributes Name real, intent(out), dimension(:) :: a integer, intent(in) :: src integer, intent(in), optional :: tag private  subroutine receive_real_array_2d (a, src, tag) Arguments Type Intent Optional Attributes Name real, intent(out), dimension(:, :) :: a integer, intent(in) :: src integer, intent(in), optional :: tag private  subroutine receive_complex (z, src, tag) Arguments Type Intent Optional Attributes Name complex, intent(out) :: z integer, intent(in) :: src integer, intent(in), optional :: tag private  subroutine receive_complex_array (z, src, tag) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:) :: z integer, intent(in) :: src integer, intent(in), optional :: tag private  subroutine receive_complex_2array (z, src, tag) Arguments Type Intent Optional Attributes Name complex, intent(out), dimension(:, :) :: z integer, intent(in) :: src integer, intent(in), optional :: tag private  subroutine nonblocking_receive_complex_array (z, src, tag, request) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:) :: z integer, intent(in) :: src integer, intent(in), optional :: tag integer, intent(out) :: request private  subroutine receive_logical (f, src, tag) Arguments Type Intent Optional Attributes Name logical, intent(out) :: f integer, intent(in) :: src integer, intent(in), optional :: tag private  subroutine receive_logical_array (f, src, tag) Arguments Type Intent Optional Attributes Name logical, intent(out), dimension(:) :: f integer, intent(in) :: src integer, intent(in), optional :: tag private  subroutine receive_character (s, src, tag) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: s integer, intent(in) :: src integer, intent(in), optional :: tag public  subroutine waitany (count, requests, requestindex, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: count integer, intent(inout), dimension(:) :: requests integer, intent(out) :: requestindex integer, intent(out), dimension(MPI_STATUS_SIZE) :: status private  subroutine all_to_group_real (all, group, njobs) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: all real, intent(out) :: group integer, intent(in) :: njobs private  subroutine all_to_group_real_array (all, group, njobs) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: all real, intent(out), dimension(:) :: group integer, intent(in) :: njobs private  subroutine group_to_all_real (group, all, njobs) Arguments Type Intent Optional Attributes Name real, intent(in) :: group real, intent(out), dimension(:) :: all integer, intent(in) :: njobs private  subroutine group_to_all_real_array (group, all, njobs) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: group real, intent(out), dimension(:, :) :: all integer, intent(in) :: njobs public  subroutine mp_abort (msg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg public  subroutine mp_gather (senddata, recvarray) Arguments Type Intent Optional Attributes Name integer, intent(in) :: senddata integer, intent(out), dimension(:) :: recvarray public  subroutine broadcast_with_comm (x, comm) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: x integer, intent(in) :: comm","tags":"","loc":"module/mp.html"},{"title":"fields_arrays – stella","text":"Uses common_types mpi Variables Type Visibility Attributes Name Initial complex, public, dimension(:, :, :, :), allocatable :: phi complex, public, dimension(:, :, :, :), allocatable :: phi_old complex, public, dimension(:, :, :, :), allocatable :: apar complex, public, dimension(:, :, :, :), allocatable :: apar_old complex, public, dimension(:, :, :, :), allocatable :: bpar complex, public, dimension(:, :, :, :), allocatable :: bpar_old complex, public, dimension(:, :, :, :), pointer :: phi_shared complex, public, dimension(:, :, :, :), allocatable :: phi_corr_QN complex, public, dimension(:, :, :, :), allocatable :: apar_corr_QN complex, public, dimension(:, :, :), allocatable :: phi_proj complex, public, dimension(:, :, :), allocatable :: phi_proj_stage complex, public, dimension(:, :, :, :, :), allocatable :: phi_corr_GA complex, public, dimension(:, :, :, :, :), allocatable :: apar_corr_GA type( response_matrix_type ), public, dimension(:), allocatable :: response_matrix integer, public :: response_window = MPI_WIN_NULL real, public, dimension(:), allocatable :: shift_state real, public, dimension(:, :, :), allocatable :: gamtot real, public, dimension(:, :, :), allocatable :: dgamtotdr real, public, dimension(:, :, :), allocatable :: gamtot13 real, public, dimension(:, :, :), allocatable :: gamtot31 real, public, dimension(:, :, :), allocatable :: gamtot33 real, public, dimension(:, :, :), allocatable :: gamtotinv11 real, public, dimension(:, :, :), allocatable :: gamtotinv13 real, public, dimension(:, :, :), allocatable :: gamtotinv31 real, public, dimension(:, :, :), allocatable :: gamtotinv33 real, public, dimension(:, :), allocatable :: gamtot3 complex, public, dimension(:, :, :), allocatable :: theta complex, public, dimension(:, :), allocatable :: c_mat complex, public, dimension(:), pointer :: phi_ext => null() type( eigen_type ), public, dimension(:, :), allocatable :: phi_solve type( eigen_type ), public :: phizf_solve logical, public :: exclude_boundary_regions_qn real, public :: tcorr_source_qn real, public :: exp_fac_qn integer, public :: qn_window = MPI_WIN_NULL integer, public :: qn_zf_window = MPI_WIN_NULL","tags":"","loc":"module/fields_arrays.html"},{"title":"gauss_quad – stella","text":"Variables Type Visibility Attributes Name Initial logical, private :: debug = .false. logical, private :: weight_roundoff_correction = .false. integer, private, parameter :: qp = selected_real_kind(33, 4931) Functions private elemental function legendre_p (n, x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision, intent(in) :: x Return Value double precision private elemental function legendre_pp (n, x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision, intent(in) :: x Return Value double precision private elemental function laguerre_l (n, x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=qp), intent(in) :: x Return Value real(kind=qp) private elemental function laguerre_lp (n, x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=qp), intent(in) :: x Return Value real(kind=qp) Subroutines public  subroutine get_legendre_grids_from_cheb (x1, x2, zero, wgt) Arguments Type Intent Optional Attributes Name real, intent(in) :: x1 real, intent(in) :: x2 real, intent(out), dimension(:) :: zero real, intent(out), dimension(:) :: wgt private  subroutine find_zero_bisect_newton (n, xold, xnew, pold, pnew, zz) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision, intent(in) :: xold double precision, intent(in) :: xnew double precision, intent(in) :: pold double precision, intent(in) :: pnew double precision, intent(out) :: zz private  subroutine check_legendre_zero (x0, x1, zero) Arguments Type Intent Optional Attributes Name real, intent(in) :: x0 real, intent(in) :: x1 real, intent(in), dimension(:) :: zero private  subroutine check_legendre_weights (norm, wgt) Arguments Type Intent Optional Attributes Name real, intent(in) :: norm real, intent(in), dimension(:) :: wgt public  subroutine get_laguerre_grids (zero, wgt) Arguments Type Intent Optional Attributes Name real, intent(out), dimension(:) :: zero real, intent(out), dimension(:) :: wgt private  subroutine find_zero (n, eps, xold, xnew, pold, pnew, zz) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n double precision, intent(in) :: eps real(kind=qp), intent(in) :: xold real(kind=qp), intent(in) :: xnew real(kind=qp), intent(in) :: pold real(kind=qp), intent(in) :: pnew real(kind=qp), intent(out) :: zz private  subroutine check_laguerre_zeros (zero) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: zero private  subroutine check_laguerre_weights (wgt, eps) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: wgt real, intent(in) :: eps","tags":"","loc":"module/gauss_quad.html"},{"title":"stel_kinds – stella","text":"Variables Type Visibility Attributes Name Initial integer, public, parameter :: rprec = SELECTED_REAL_KIND(12, 100) integer, public, parameter :: iprec = SELECTED_INT_KIND(8) integer, public, parameter :: cprec = KIND((1.0_rprec, 1.0_rprec)) integer, public, parameter :: dp = rprec","tags":"","loc":"module/stel_kinds.html"},{"title":"common_types – stella","text":"Derived Types type, public, sequence  :: kxkyz_layout_type Components Type Visibility Attributes Name Initial integer, public :: iproc integer, public :: nzgrid integer, public :: nzed integer, public :: ntubes integer, public :: naky integer, public :: nakx integer, public :: nvgrid integer, public :: nvpa integer, public :: nmu integer, public :: nspec integer, public :: llim_world integer, public :: ulim_world integer, public :: llim_proc integer, public :: ulim_proc integer, public :: ulim_alloc integer, public :: blocksize type, public, sequence  :: kxyz_layout_type Components Type Visibility Attributes Name Initial integer, public :: iproc integer, public :: nzgrid integer, public :: nzed integer, public :: ntubes integer, public :: ny integer, public :: naky integer, public :: nakx integer, public :: ikx_max integer, public :: nvgrid integer, public :: nvpa integer, public :: nmu integer, public :: nspec integer, public :: llim_world integer, public :: ulim_world integer, public :: llim_proc integer, public :: ulim_proc integer, public :: ulim_alloc integer, public :: blocksize type, public, sequence  :: xyz_layout_type Components Type Visibility Attributes Name Initial integer, public :: iproc integer, public :: nzgrid integer, public :: nzed integer, public :: ntubes integer, public :: ny integer, public :: naky integer, public :: nx integer, public :: nakx integer, public :: nvgrid integer, public :: nvpa integer, public :: nmu integer, public :: nspec integer, public :: llim_world integer, public :: ulim_world integer, public :: llim_proc integer, public :: ulim_proc integer, public :: ulim_alloc integer, public :: blocksize type, public, sequence  :: vmu_layout_type Components Type Visibility Attributes Name Initial logical, public :: xyz integer, public :: iproc integer, public :: nzgrid integer, public :: nzed integer, public :: ntubes integer, public :: nalpha integer, public :: ny integer, public :: naky integer, public :: nx integer, public :: nakx integer, public :: nvgrid integer, public :: nvpa integer, public :: nmu integer, public :: nspec integer, public :: llim_world integer, public :: ulim_world integer, public :: llim_proc integer, public :: ulim_proc integer, public :: ulim_alloc integer, public :: blocksize type, public :: flux_surface_type Components Type Visibility Attributes Name Initial real, public :: rmaj real, public :: rgeo real, public :: kappa real, public :: kapprim real, public :: tri real, public :: triprim real, public :: rhoc real, public :: dr real, public :: shift real, public :: qinp real, public :: shat real, public :: betaprim real, public :: betadbprim real, public :: d2qdr2 real, public :: d2psidr2 real, public :: dpsitordrho real, public :: d2psitordrho2 real, public :: rhotor real, public :: drhotordrho real, public :: psitor_lcfs real, public :: zed0_fac real, public :: rhoc_psi0 real, public :: qinp_psi0 real, public :: shat_psi0 type, public :: spec_type Components Type Visibility Attributes Name Initial integer, public :: nspec real, public :: z real, public :: mass real, public :: dens real, public :: temp real, public :: tprim real, public :: fprim real, public :: vnew_ref real, public :: stm real, public :: zstm real, public :: tz real, public :: smz real, public :: zt real, public :: d2ndr2 real, public :: d2Tdr2 real, public :: bess_fac real, public, dimension(10) :: vnew integer, public :: type real, public :: dens_psi0 real, public :: temp_psi0 real, public :: stm_psi0 real, public :: zstm_psi0 real, public :: tz_psi0 real, public :: smz_psi0 real, public :: zt_psi0 type, public :: eigen_type Components Type Visibility Attributes Name Initial complex, public, dimension(:, :), pointer :: zloc => null() integer, public, dimension(:), pointer :: idx => null() type, public :: response_matrix_type Components Type Visibility Attributes Name Initial type( eigen_type ), public, dimension(:), pointer :: eigen => null() type, public :: coupled_alpha_type Components Type Visibility Attributes Name Initial integer, public :: max_idx complex, public, dimension(:), pointer :: fourier => null() type, public :: gam0_ffs_type Components Type Visibility Attributes Name Initial integer, public, dimension(:), pointer :: pivot_index => null() complex, public, dimension(:, :), pointer :: matrix => null()","tags":"","loc":"module/common_types.html"},{"title":"dist_redistribute – stella","text":"Uses redistribute Variables Type Visibility Attributes Name Initial type( redist_type ), public :: kxkyz2vmu type( redist_type ), public :: kxyz2vmu type( redist_type ), public :: xyz2vmu logical, private :: redistribute_initialized = .false. Subroutines public  subroutine init_redistribute () Arguments None private  subroutine init_kxkyz_to_vmu_redistribute () Arguments None private  subroutine init_kxyz_to_vmu_redistribute () Arguments None private  subroutine init_xyz_to_vmu_redistribute () Arguments None public  subroutine finish_redistribute () Arguments None","tags":"","loc":"module/dist_redistribute.html"},{"title":"parallel_streaming – stella","text":"Variables Type Visibility Attributes Name Initial logical, public :: parallel_streaming_initialized = .false. integer, public, dimension(:), allocatable :: stream_sign real, public, dimension(:, :, :, :), allocatable :: stream real, public, dimension(:, :, :), allocatable :: stream_c real, public, dimension(:, :, :), allocatable :: stream_rad_var1 real, public, dimension(:, :, :), allocatable :: stream_rad_var2 real, private, dimension(:, :), allocatable :: stream_tri_a1 real, private, dimension(:, :), allocatable :: stream_tri_a2 real, private, dimension(:, :), allocatable :: stream_tri_b1 real, private, dimension(:, :), allocatable :: stream_tri_b2 real, private, dimension(:, :), allocatable :: stream_tri_c1 real, private, dimension(:, :), allocatable :: stream_tri_c2 real, public, dimension(:, :), allocatable :: gradpar_c real, public, dimension(2, 3) :: time_parallel_streaming = 0. Interfaces public        interface center_zed private  subroutine center_zed_segment_real (iv, f, llim) center_zed_segment_real takes as arguments the vpa index (iv)\nthe z-depenendent real function f, and the starting iz index for the array f (llim),\nand overwrites f with the cell-centered version Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv real, intent(inout), dimension(llim:) :: f integer, intent(in) :: llim private  subroutine center_zed_segment_complex (iv, f, llim, periodic) center_zed_segment_complex takes as arguments the vpa index (iv)\nthe z-depenendent conplex function f, and the starting iz index for the array f (llim),\nand overwrites f with the cell-centered version; Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv complex, intent(inout), dimension(llim:) :: f integer, intent(in) :: llim logical, intent(in) :: periodic private  subroutine center_zed_extended (iv, g) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv complex, intent(inout), dimension(:, :, -nzgrid:, :) :: g Subroutines public  subroutine init_parallel_streaming () stream_sign set to +/- 1 depending on the sign of the parallel streaming term.\nNB: stream_sign = -1 corresponds to positive advection velocity\nonly need to consider ia=1, iz=0 and is=1 because alpha, z and species dependences\ndo not lead to change in sign of the streaming pre-factor\nget gradpar centred in zed for negative vpa (affects upwinding)\nget gradpar centred in zed for positive vpa (affects upwinding) Arguments None private  subroutine init_invert_stream_operator () Arguments None public  subroutine advance_parallel_streaming_explicit (g, phi, bpar, gout) if flux tube simulation parallel streaming stays in ky,kx,z space with ky,kx,z local\nif full flux surface (flux annulus), will need to calculate in y space\nstart the timer for the parallel streaming part of the time advance Read more… Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(in), dimension(:, :, -nzgrid:, :) :: phi complex, intent(in), dimension(:, :, -nzgrid:, :) :: bpar complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout public  subroutine add_parallel_streaming_radial_variation (g, gout, rhs) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: rhs private  subroutine get_dgdz (g, ivmu, dgdz) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: g integer, intent(in) :: ivmu complex, intent(out), dimension(:, :, -nzgrid:, :) :: dgdz private  subroutine get_dgdz_centered (g, ivmu, dgdz) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: g integer, intent(in) :: ivmu complex, intent(out), dimension(:, :, -nzgrid:, :) :: dgdz private  subroutine add_stream_term (g, ivmu, src) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: g integer, intent(in) :: ivmu complex, intent(inout), dimension(:, :, -nzgrid:, :) :: src private  subroutine add_stream_term_ffs (g, ivmu, src) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: g integer, intent(in) :: ivmu complex, intent(inout), dimension(:, :, -nzgrid:, :) :: src public  subroutine stream_tridiagonal_solve (iky, ie, iv, is, g) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iky integer, intent(in) :: ie integer, intent(in) :: iv integer, intent(in) :: is complex, intent(inout), dimension(:) :: g public  subroutine get_dzed (iv, g, dgdz) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv complex, intent(in), dimension(:, :, -nzgrid:, :) :: g complex, intent(out), dimension(:, :, -nzgrid:, :) :: dgdz public  subroutine get_zed_derivative_extended_domain (iv, f, f_left, f_right, df_dz) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv complex, intent(in), dimension(:) :: f complex, intent(in) :: f_left complex, intent(in) :: f_right complex, intent(out), dimension(:) :: df_dz private  subroutine center_zed_extended (iv, g) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv complex, intent(inout), dimension(:, :, -nzgrid:, :) :: g private  subroutine center_zed_segment_real (iv, f, llim) center_zed_segment_real takes as arguments the vpa index (iv)\nthe z-depenendent real function f, and the starting iz index for the array f (llim),\nand overwrites f with the cell-centered version Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv real, intent(inout), dimension(llim:) :: f integer, intent(in) :: llim private  subroutine center_zed_segment_complex (iv, f, llim, periodic) center_zed_segment_complex takes as arguments the vpa index (iv)\nthe z-depenendent conplex function f, and the starting iz index for the array f (llim),\nand overwrites f with the cell-centered version; Arguments Type Intent Optional Attributes Name integer, intent(in) :: iv complex, intent(inout), dimension(llim:) :: f integer, intent(in) :: llim logical, intent(in) :: periodic public  subroutine finish_parallel_streaming () Arguments None private  subroutine finish_invert_stream_operator () Arguments None","tags":"","loc":"module/parallel_streaming.html"},{"title":"constants – stella","text":"Variables Type Visibility Attributes Name Initial integer, private, parameter :: kind_i1 = selected_int_kind(2) integer, private, parameter :: kind_ih = selected_int_kind(4) integer, public, parameter :: kind_is = selected_int_kind(8) integer, public, parameter :: kind_id = selected_int_kind(15) integer, public, parameter :: kind_rs = selected_real_kind(p=6) integer, public, parameter :: kind_rd = selected_real_kind(p=12) integer, private, parameter :: kind_rq = selected_real_kind(p=24) complex, public, parameter :: zi = (0.0, 1.0) double precision, public, parameter :: dpi = 3.14159265358979323846264338327950288419716939938 double precision, public, parameter :: dtwopi = 2.*dpi real, public, parameter :: pi = dpi real, public, parameter :: twopi = dtwopi","tags":"","loc":"module/constants.html"},{"title":"neoclassical_terms – stella","text":"Variables Type Visibility Attributes Name Initial logical, public :: include_neoclassical_terms integer, private :: nradii real, private :: drho integer, private :: neo_option_switch integer, private, parameter :: neo_option_sfincs = 1 real, public, dimension(:, :, :), allocatable :: dfneo_dzed real, public, dimension(:, :, :), allocatable :: dfneo_dvpa real, public, dimension(:, :, :), allocatable :: dfneo_drho real, public, dimension(:, :, :), allocatable :: dfneo_dalpha real, public, dimension(:, :), allocatable :: dphineo_dzed real, public, dimension(:, :), allocatable :: dphineo_drho real, public, dimension(:, :), allocatable :: dphineo_dalpha logical, private :: neoinit = .false. logical, private :: debug = .false. Subroutines public  subroutine init_neoclassical_terms () Arguments None private  subroutine read_parameters () Arguments None private  subroutine distribute_vmus_over_procs (local, distributed) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :, :) :: local real, intent(out), dimension(vmu_lo%llim_proc:) :: distributed private  subroutine get_dfneo_dvpa (fneo, dfneo) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, -nzgrid:, :, :, :) :: fneo real, intent(out), dimension(:, -nzgrid:, vmu_lo%llim_proc:) :: dfneo private  subroutine get_dfneo_dzed (fneo, dfneo) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, -nzgrid:, :, :, :) :: fneo real, intent(out), dimension(:, -nzgrid:, vmu_lo%llim_proc:) :: dfneo private  subroutine get_dfneo_drho (fneo, dfneo) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, -nzgrid:, :, :, :, -nradii/2:) :: fneo real, intent(out), dimension(:, -nzgrid:, vmu_lo%llim_proc:) :: dfneo private  subroutine get_dphineo_dzed (phineo, dphineo) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, -nzgrid:) :: phineo real, intent(out), dimension(:, -nzgrid:) :: dphineo private  subroutine get_dphineo_drho (phineo, dphineo) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, -nzgrid:, -nradii/2:) :: phineo real, intent(out), dimension(:, -nzgrid:) :: dphineo private  subroutine write_neoclassical (fnc, phinc) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, -nzgrid:, :, :, :, -nradii/2:) :: fnc real, intent(in), dimension(:, -nzgrid:, -nradii/2:) :: phinc public  subroutine finish_neoclassical_terms () Arguments None","tags":"","loc":"module/neoclassical_terms.html"},{"title":"run_parameters – stella","text":"This module is basically a store for the input parameters that are specified in the namelists \\a knobs and \\a parameters. In general, the names of the public variables in this module are the same as the name of the input parameter they correspond to. Variables Type Visibility Attributes Name Initial real, public :: cfl_cushion_upper real, public :: cfl_cushion_middle real, public :: cfl_cushion_lower real, public :: fphi real, public :: fapar real, public :: fbpar real, public :: delt real, public :: tend real, public :: delt_max real, public :: delt_min real, public :: vpa_upwind real, public :: time_upwind real, public :: time_upwind_plus real, public :: time_upwind_minus real, public :: zed_upwind real, public :: zed_upwind_plus real, public :: zed_upwind_minus logical, public :: stream_implicit logical, public :: mirror_implicit logical, public :: drifts_implicit logical, public :: driftkinetic_implicit logical, public :: fully_explicit logical, public :: fully_implicit logical, public :: maxwellian_inside_zed_derivative logical, public :: stream_matrix_inversion logical, public :: mirror_semi_lagrange logical, public :: mirror_linear_interp logical, public :: fields_kxkyz logical, public :: mat_gen logical, public :: mat_read logical, public :: ky_solve_real logical, public :: use_deltaphi_for_response_matrix logical, public :: maxwellian_normalization real, public :: avail_cpu_time integer, public :: nstep integer, public :: ky_solve_radial integer, public :: rng_seed integer, public :: delt_option_switch integer, public :: lu_option_switch integer, public, parameter :: delt_option_hand = 1 integer, public, parameter :: delt_option_auto = 2 integer, public, parameter :: lu_option_none = 1 integer, public, parameter :: lu_option_local = 2 integer, public, parameter :: lu_option_global = 3 logical, private :: initialized = .false. logical, private :: knexist Subroutines public  subroutine init_run_parameters () Arguments None private  subroutine read_parameters () print warning messages and override inconsistent or unsupported options for full_flux_surface = T Arguments None public  subroutine finish_run_parameters () Arguments None","tags":"","loc":"module/run_parameters.html"},{"title":"vpamu_grids – stella","text":"Variables Type Visibility Attributes Name Initial logical, public :: vpamu_initialized = .false. integer, public :: nvgrid integer, public :: nvpa integer, public :: nmu real, public :: vpa_max real, public :: vperp_max real, public, dimension(:), allocatable :: vpa real, public, dimension(:), allocatable :: wgts_vpa real, public, dimension(:), allocatable :: wgts_vpa_default real, public, dimension(:), allocatable :: wgts_mu_bare real, public, dimension(:), allocatable :: mu real, public, dimension(:), allocatable :: maxwell_fac real, public, dimension(:, :), allocatable :: maxwell_vpa real, public, dimension(:, :, :), allocatable :: int_unit real, public, dimension(:, :, :), allocatable :: int_vpa2 real, public, dimension(:, :, :), allocatable :: int_vperp2 real, public, dimension(:, :, :), allocatable :: int_vfrth real, public, dimension(:, :, :), allocatable :: wgts_mu real, public, dimension(:, :, :, :), allocatable :: maxwell_mu real, public, dimension(:, :), allocatable :: ztmax real, public :: dvpa real, public, dimension(:), allocatable :: dmu real, public, dimension(:), allocatable :: dmu_ghost real, public, dimension(:), allocatable :: dmu_cell real, public, dimension(:), allocatable :: mu_cell complex, public, dimension(:), allocatable :: rbuffer logical, public :: equally_spaced_mu_grid logical, public :: conservative_wgts_vpa real, public, dimension(:, :, :), allocatable :: vperp2 Interfaces public        interface integrate_species public  subroutine integrate_species_vmu (g, weights, total, ia_in) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g real, intent(in), dimension(:) :: weights complex, intent(out), dimension(:, :, -nzgrid:, :) :: total integer, intent(in), optional :: ia_in public  subroutine integrate_species_vmu_single (g, iz, weights, total, ia_in, reduce_in) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(vmu_lo%llim_proc:) :: g integer, intent(in) :: iz real, intent(in), dimension(:) :: weights complex, intent(out) :: total integer, intent(in), optional :: ia_in logical, intent(in), optional :: reduce_in public  subroutine integrate_species_vmu_single_real (g, iz, weights, total, ia_in, reduce_in) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(vmu_lo%llim_proc:) :: g integer, intent(in) :: iz real, intent(in), dimension(:) :: weights real, intent(out) :: total integer, intent(in), optional :: ia_in logical, intent(in), optional :: reduce_in public  subroutine integrate_species_vmu_block_complex (g, iz, weights, pout, ia_in, reduce_in) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, vmu_lo%llim_proc:) :: g integer, intent(in) :: iz real, intent(in), dimension(:) :: weights complex, intent(out), dimension(:, :) :: pout integer, intent(in), optional :: ia_in logical, intent(in), optional :: reduce_in public  subroutine integrate_species_vmu_block_real (g, iz, weights, pout, ia_in, reduce_in) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :, vmu_lo%llim_proc:) :: g integer, intent(in) :: iz real, intent(in), dimension(:) :: weights real, intent(out), dimension(:, :) :: pout integer, intent(in), optional :: ia_in logical, intent(in), optional :: reduce_in public        interface integrate_vmu public  subroutine integrate_vmu_local_real (g, iz, total) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: g integer, intent(in) :: iz real, intent(out) :: total public  subroutine integrate_vmu_local_complex (g, iz, total) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: g integer, intent(in) :: iz complex, intent(out) :: total public  subroutine integrate_vmu_vmulo_complex (g, weights, total) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g real, intent(in), dimension(:) :: weights complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: total public  subroutine integrate_vmu_vmulo_ivmu_only_real (g, ia, iz, total) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(vmu_lo%llim_proc:) :: g integer, intent(in) :: ia integer, intent(in) :: iz real, intent(out), dimension(:) :: total public        interface integrate_mu public  subroutine integrate_mu_local (iz, g, total) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iz real, intent(in), dimension(:, :) :: g real, intent(out), dimension(:) :: total public  subroutine integrate_mu_nonlocal (iz, g, total) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iz real, intent(in), dimension(vmu_lo%llim_proc:) :: g real, intent(out), dimension(:, :) :: total Subroutines public  subroutine read_vpamu_grids_parameters () Arguments None public  subroutine init_vpamu_grids () set up the vpa grid points and integration weights\nset up the mu grid points and integration weights Read more… Arguments None public  subroutine init_vpa_grid () vpa is the parallel velocity at grid points\nwgts_vpa are the integration weights assigned\nto the parallel velocity grid points\nthis is the Maxwellian in vpa\nparallel velocity grid goes from -vpa_max to vpa_max,\nwith no point at vpa = 0;\nthe lack of a point at vpa=0 avoids treating\nthe vpa=z=0 phase space location, which\nis isolated from all other phase space points\nin the absence of collisions\nequal grid spacing in vpa Read more… Arguments None public  subroutine set_vpa_weights (conservative) Arguments Type Intent Optional Attributes Name logical, intent(in) :: conservative public  subroutine integrate_mu_local (iz, g, total) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iz real, intent(in), dimension(:, :) :: g real, intent(out), dimension(:) :: total public  subroutine integrate_mu_nonlocal (iz, g, total) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iz real, intent(in), dimension(vmu_lo%llim_proc:) :: g real, intent(out), dimension(:, :) :: total public  subroutine integrate_vmu_local_real (g, iz, total) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: g integer, intent(in) :: iz real, intent(out) :: total public  subroutine integrate_vmu_local_complex (g, iz, total) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: g integer, intent(in) :: iz complex, intent(out) :: total public  subroutine integrate_vmu_vmulo_complex (g, weights, total) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g real, intent(in), dimension(:) :: weights complex, intent(out), dimension(:, :, -nzgrid:, :, :) :: total public  subroutine integrate_vmu_vmulo_ivmu_only_real (g, ia, iz, total) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(vmu_lo%llim_proc:) :: g integer, intent(in) :: ia integer, intent(in) :: iz real, intent(out), dimension(:) :: total public  subroutine integrate_species_vmu (g, weights, total, ia_in) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g real, intent(in), dimension(:) :: weights complex, intent(out), dimension(:, :, -nzgrid:, :) :: total integer, intent(in), optional :: ia_in public  subroutine integrate_species_vmu_single (g, iz, weights, total, ia_in, reduce_in) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(vmu_lo%llim_proc:) :: g integer, intent(in) :: iz real, intent(in), dimension(:) :: weights complex, intent(out) :: total integer, intent(in), optional :: ia_in logical, intent(in), optional :: reduce_in public  subroutine integrate_species_vmu_single_real (g, iz, weights, total, ia_in, reduce_in) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(vmu_lo%llim_proc:) :: g integer, intent(in) :: iz real, intent(in), dimension(:) :: weights real, intent(out) :: total integer, intent(in), optional :: ia_in logical, intent(in), optional :: reduce_in public  subroutine integrate_species_vmu_block_complex (g, iz, weights, pout, ia_in, reduce_in) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, vmu_lo%llim_proc:) :: g integer, intent(in) :: iz real, intent(in), dimension(:) :: weights complex, intent(out), dimension(:, :) :: pout integer, intent(in), optional :: ia_in logical, intent(in), optional :: reduce_in public  subroutine integrate_species_vmu_block_real (g, iz, weights, pout, ia_in, reduce_in) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :, vmu_lo%llim_proc:) :: g integer, intent(in) :: iz real, intent(in), dimension(:) :: weights real, intent(out), dimension(:, :) :: pout integer, intent(in), optional :: ia_in logical, intent(in), optional :: reduce_in public  subroutine integrate_species_ffs (g, weights, pout, reduce_in) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, vmu_lo%llim_proc:) :: g real, intent(in), dimension(:) :: weights complex, intent(out), dimension(:, :) :: pout logical, intent(in), optional :: reduce_in public  subroutine integrate_vmu_ffs (g, weights, ia, iz, pout, reduce_in) NB: for FFS, assume that there is only one flux annulus\nthe inclusion of the Maxwellian term below is due to the fact that\ng/F is evolved for FFS Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(vmu_lo%llim_proc:) :: g real, intent(in), dimension(:) :: weights integer, intent(in) :: ia integer, intent(in) :: iz complex, intent(out), dimension(:) :: pout logical, intent(in), optional :: reduce_in public  subroutine finish_vpa_grid () Arguments None public  subroutine init_mu_grid () allocate arrays and initialize to zero\ndvpe * vpe = d(2 mu B0) * B/2B0\nfirst get equally spaced grid in mu with max value\nmu_max = vperp_max 2/(2 max(bmag))\nwant first grid point at dmu/2 to avoid mu=0 special point\ndmu/2 + (nmu-1) dmu = mu_max\nso dmu = mu_max/(nmu-1/2)\ndo simplest thing to start\nleave dmu(nmu) uninitialized. should never be used, so want\nvalgrind or similar to return error if it is Read more… Arguments None public  subroutine finish_mu_grid () Arguments None public  subroutine calculate_velocity_integrals () Arguments None public  subroutine finish_vpamu_grids () Arguments None","tags":"","loc":"module/vpamu_grids.html"},{"title":"system_fortran – stella","text":"Subroutines public  subroutine systemf (command) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: command","tags":"","loc":"module/system_fortran.html"},{"title":"linear_solve – stella","text":"Interfaces public        interface lu_decomposition public  subroutine lu_decomposition_real (lu, idx, d) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :) :: lu integer, intent(out), dimension(:) :: idx real, intent(out) :: d public  subroutine lu_decomposition_complex (lu, idx, d) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: lu integer, intent(out), dimension(:) :: idx real, intent(out) :: d public        interface lu_back_substitution public  subroutine lu_back_substitution_real (lu, idx, b) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx real, intent(inout), dimension(:) :: b public  subroutine lu_back_substitution_real_complex (lu, idx, b) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx complex, intent(inout), dimension(:) :: b public  subroutine lu_back_substitution_complex (lu, idx, b) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx complex, intent(inout), dimension(:) :: b public  subroutine lu_back_substitution_matrix_real (lu, idx, b) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx real, intent(inout), dimension(:, :) :: b public  subroutine lu_back_substitution_matrix_complex (lu, idx, b) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx complex, intent(inout), dimension(:, :) :: b public        interface lu_inverse public  subroutine lu_inverse_real (lu, idx, inverse) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx real, intent(out), dimension(:, :) :: inverse public  subroutine lu_inverse_complex (lu, idx, inverse) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx complex, intent(out), dimension(:, :) :: inverse Functions public  function imaxloc (array) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: array Return Value integer Subroutines public  subroutine lu_decomposition_real (lu, idx, d) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :) :: lu integer, intent(out), dimension(:) :: idx real, intent(out) :: d public  subroutine lu_decomposition_complex (lu, idx, d) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :) :: lu integer, intent(out), dimension(:) :: idx real, intent(out) :: d public  subroutine lu_back_substitution_real (lu, idx, b) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx real, intent(inout), dimension(:) :: b public  subroutine lu_back_substitution_real_complex (lu, idx, b) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx complex, intent(inout), dimension(:) :: b public  subroutine lu_back_substitution_complex (lu, idx, b) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx complex, intent(inout), dimension(:) :: b public  subroutine lu_back_substitution_matrix_real (lu, idx, b) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx real, intent(inout), dimension(:, :) :: b public  subroutine lu_back_substitution_matrix_complex (lu, idx, b) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx complex, intent(inout), dimension(:, :) :: b public  subroutine lu_inverse_real (lu, idx, inverse) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx real, intent(out), dimension(:, :) :: inverse public  subroutine lu_inverse_complex (lu, idx, inverse) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: lu integer, intent(in), dimension(:) :: idx complex, intent(out), dimension(:, :) :: inverse","tags":"","loc":"module/linear_solve.html"},{"title":"millerlocal – stella","text":"Uses common_types Variables Type Visibility Attributes Name Initial integer, private :: nzed_local real, private :: rhoc real, private :: rmaj real, private :: shift real, private :: kappa real, private :: kapprim real, private :: tri real, private :: triprim real, private :: betaprim real, private :: betadbprim real, private :: qinp real, private :: shat real, private :: d2qdr2 real, private :: rgeo real, private :: dpsidrho real, private :: d2psidr2 real, private :: dpsidrho_psi0 real, private :: psitor_lcfs real, private :: rhotor real, private :: drhotordrho real, private :: dIdrho real, private :: dI real, private :: rhoc0 logical, private :: write_profile_variation logical, private :: read_profile_variation logical, private :: load_psi0_variables integer, private :: nz integer, private :: nz2pi real, private :: bi real, private :: dqdr real, private :: d2Idr2 real, private, dimension(:), allocatable :: grho real, private, dimension(:), allocatable :: bmag real, private, dimension(:), allocatable :: grho_psi0 real, private, dimension(:), allocatable :: bmag_psi0 real, private, dimension(:), allocatable :: gradpar real, private, dimension(:), allocatable :: gradpararc real, private, dimension(:), allocatable :: arc real, private, dimension(:), allocatable :: gds2 real, private, dimension(:), allocatable :: gds21 real, private, dimension(:), allocatable :: gds22 real, private, dimension(:), allocatable :: gds23 real, private, dimension(:), allocatable :: gds24 real, private, dimension(:), allocatable :: gbdrift0 real, private, dimension(:), allocatable :: gbdrift real, private, dimension(:), allocatable :: cvdrift0 real, private, dimension(:), allocatable :: cvdrift real, private, dimension(:), allocatable :: d2Rdth2 real, private, dimension(:), allocatable :: d2Zdth2 real, private, dimension(:), allocatable :: d2Rdrdth real, private, dimension(:), allocatable :: d2Zdrdth real, private, dimension(:), allocatable :: gpsi real, private, dimension(:), allocatable :: dBdrho real, private, dimension(:), allocatable :: d2Bdrdth real, private, dimension(:), allocatable :: dgradpardrho real, private, dimension(:), allocatable :: dgradparBdrho real, private, dimension(:), allocatable :: dBdth real, private, dimension(:), allocatable :: gradparb real, private, dimension(:), allocatable :: dcvdrift0drho real, private, dimension(:), allocatable :: dgbdrift0drho real, private, dimension(:), allocatable :: theta real, private, dimension(:), allocatable :: varthet real, private, dimension(:), allocatable :: dvarthdr real, private, dimension(:), allocatable :: gradrho_gradthet real, private, dimension(:), allocatable :: cross real, private, dimension(:), allocatable :: d2varthdr2 real, private, dimension(:), allocatable :: gradthet2 real, private, dimension(:), allocatable :: gradalph_gradthet real, private, dimension(:), allocatable :: gradrho_gradalph real, private, dimension(:), allocatable :: gradalph2 real, private, dimension(:), allocatable :: d2Bdr2 real, private, dimension(:), allocatable :: d2Rdr2 real, private, dimension(:), allocatable :: d2Zdr2 real, private, dimension(:), allocatable :: drz real, private, dimension(:), allocatable :: drzdth real, private, dimension(:), allocatable :: d2Rdr2dth real, private, dimension(:), allocatable :: d2Zdr2dth real, private, dimension(:), allocatable :: d2gpsidr2 real, private, dimension(:), allocatable :: dcrossdr real, private, dimension(:), allocatable :: dcvdriftdrho real, private, dimension(:), allocatable :: dgbdriftdrho real, private, dimension(:), allocatable :: dgds2dr real, private, dimension(:), allocatable :: dgds21dr real, private, dimension(:), allocatable :: dgds22dr real, private, dimension(:), allocatable :: dgr2dr real, private, dimension(:), allocatable :: dgpsi2dr real, private, dimension(:), allocatable :: dgrgt real, private, dimension(:), allocatable :: dgt2 real, private, dimension(:), allocatable :: dgagr real, private, dimension(:), allocatable :: dgagt real, private, dimension(:), allocatable :: dga2 real, private, dimension(:, :), allocatable :: Rr real, private, dimension(:, :), allocatable :: Zr real, private, dimension(:), allocatable :: jacrho real, private, dimension(:), allocatable :: delthet real, private, dimension(:), allocatable :: djacdrho real, private, dimension(:), allocatable :: djacrdrho real, private, dimension(:), allocatable :: d2jacdr2 real, private, dimension(:), allocatable :: dRdrho real, private, dimension(:), allocatable :: dZdrho real, private, dimension(:), allocatable :: dRdth real, private, dimension(:), allocatable :: dZdth real, private, dimension(:), allocatable :: d2R real, private, dimension(:), allocatable :: d2Z type( flux_surface_type ), public :: local logical, private :: defaults_initialized = .false. Functions private  function Rpos (r, theta, j) Arguments Type Intent Optional Attributes Name real, intent(in) :: r real, intent(in) :: theta integer, intent(in) :: j Return Value real private  function Zpos (r, theta, j) Arguments Type Intent Optional Attributes Name real, intent(in) :: r real, intent(in) :: theta integer, intent(in) :: j Return Value real private  function mod2pi (theta) Arguments Type Intent Optional Attributes Name real, intent(in) :: theta Return Value real Subroutines public  subroutine init_local_defaults () Arguments None public  subroutine read_local_parameters (nzed, nzgrid, local_out) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nzed integer, intent(in) :: nzgrid type( flux_surface_type ), intent(out) :: local_out public  subroutine communicate_parameters_multibox (surf, drl, drr) Arguments Type Intent Optional Attributes Name type( flux_surface_type ), intent(inout) :: surf real, intent(in), optional :: drl real, intent(in), optional :: drr public  subroutine get_local_geo (nzed, nzgrid, zed_in, zed_equal_arc, dpsidrho_out, dpsidrho_psi0_out, dIdrho_out, grho_out, bmag_out, bmag_psi0_out, gds2_out, gds21_out, gds22_out, gds23_out, gds24_out, gradpar_out, gbdrift0_out, gbdrift_out, cvdrift0_out, cvdrift_out, dBdrho_out, d2Bdrdth_out, dgradpardrho_out, btor_out, rmajor_out, dcvdrift0drho_out, dcvdriftdrho_out, dgbdrift0drho_out, dgbdriftdrho_out, dgds2dr_out, dgds21dr_out, dgds22dr_out, djacdrho_out) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nzed integer, intent(in) :: nzgrid real, intent(in), dimension(-nzgrid:) :: zed_in logical, intent(in) :: zed_equal_arc real, intent(out) :: dpsidrho_out real, intent(out) :: dpsidrho_psi0_out real, intent(out) :: dIdrho_out real, intent(out), dimension(-nzgrid:) :: grho_out real, intent(out), dimension(-nzgrid:) :: bmag_out real, intent(out), dimension(-nzgrid:) :: bmag_psi0_out real, intent(out), dimension(-nzgrid:) :: gds2_out real, intent(out), dimension(-nzgrid:) :: gds21_out real, intent(out), dimension(-nzgrid:) :: gds22_out real, intent(out), dimension(-nzgrid:) :: gds23_out real, intent(out), dimension(-nzgrid:) :: gds24_out real, intent(out), dimension(-nzgrid:) :: gradpar_out real, intent(out), dimension(-nzgrid:) :: gbdrift0_out real, intent(out), dimension(-nzgrid:) :: gbdrift_out real, intent(out), dimension(-nzgrid:) :: cvdrift0_out real, intent(out), dimension(-nzgrid:) :: cvdrift_out real, intent(out), dimension(-nzgrid:) :: dBdrho_out real, intent(out), dimension(-nzgrid:) :: d2Bdrdth_out real, intent(out), dimension(-nzgrid:) :: dgradpardrho_out real, intent(out), dimension(-nzgrid:) :: btor_out real, intent(out), dimension(-nzgrid:) :: rmajor_out real, intent(out), dimension(-nzgrid:) :: dcvdrift0drho_out real, intent(out), dimension(-nzgrid:) :: dcvdriftdrho_out real, intent(out), dimension(-nzgrid:) :: dgbdrift0drho_out real, intent(out), dimension(-nzgrid:) :: dgbdriftdrho_out real, intent(out), dimension(-nzgrid:) :: dgds2dr_out real, intent(out), dimension(-nzgrid:) :: dgds21dr_out real, intent(out), dimension(-nzgrid:) :: dgds22dr_out real, intent(out), dimension(-nzgrid:) :: djacdrho_out private  subroutine allocate_arrays (nr, nz) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nr integer, intent(in) :: nz private  subroutine deallocate_arrays () Arguments None public  subroutine finish_local_geo () Arguments None private  subroutine get_drho (f, df) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, -nz:) :: f real, intent(out), dimension(-nz:) :: df private  subroutine get_d2dthet2 (f, d2f) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nz:) :: f real, intent(out), dimension(-nz:) :: d2f private  subroutine get_dthet (f, df) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nz:) :: f real, intent(out), dimension(-nz:) :: df private  subroutine get_jacrho () Arguments None private  subroutine get_gradrho (dpsidrho, grho) Arguments Type Intent Optional Attributes Name real, intent(in) :: dpsidrho real, intent(out), dimension(-nz:) :: grho private  subroutine get_dIdrho (dpsidrho, grho, dIdrho) Arguments Type Intent Optional Attributes Name real, intent(in) :: dpsidrho real, intent(in), dimension(-nz:) :: grho real, intent(out) :: dIdrho private  subroutine get_djacdrho (dpsidrho, dIdrho, grho) Arguments Type Intent Optional Attributes Name real, intent(in) :: dpsidrho real, intent(in) :: dIdrho real, intent(in), dimension(-nz:) :: grho private  subroutine get_d2RZdr2 () Arguments None private  subroutine get_dgr2dr (dpsidrho, grho) Arguments Type Intent Optional Attributes Name real, intent(in) :: dpsidrho real, intent(in), dimension(-nz:) :: grho private  subroutine get_graddotgrad (dpsidrho, grho) Arguments Type Intent Optional Attributes Name real, intent(in) :: dpsidrho real, intent(in), dimension(-nz:) :: grho private  subroutine get_gds (gds2, gds21, gds22, gds23, gds24) Arguments Type Intent Optional Attributes Name real, intent(out), dimension(-nz:) :: gds2 real, intent(out), dimension(-nz:) :: gds21 real, intent(out), dimension(-nz:) :: gds22 real, intent(out), dimension(-nz:) :: gds23 real, intent(out), dimension(-nz:) :: gds24 private  subroutine get_dBdrho (bmag, dIdrho) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nz:) :: bmag real, intent(in) :: dIdrho private  subroutine get_varthet (dpsidrho) Arguments Type Intent Optional Attributes Name real, intent(in) :: dpsidrho private  subroutine get_dvarthdr (dpsidrho, dIdrho) Arguments Type Intent Optional Attributes Name real, intent(in) :: dpsidrho real, intent(in) :: dIdrho private  subroutine get_d2Idr2_d2jacdr2 (grho, dIdrho) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nz:) :: grho real, intent(in) :: dIdrho private  subroutine get_d2varthdr2 (dpsidrho, dIdrho) Arguments Type Intent Optional Attributes Name real, intent(in) :: dpsidrho real, intent(in) :: dIdrho private  subroutine get_d2Bdr2 (bmag, dIdrho) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nz:) :: bmag real, intent(in) :: dIdrho private  subroutine get_dcrossdr (dpsidrho, dIdrho, grho) Arguments Type Intent Optional Attributes Name real, intent(in) :: dpsidrho real, intent(in) :: dIdrho real, intent(in), dimension(-nz:) :: grho private  subroutine theta_integrate (integrand, integral) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nz2pi:) :: integrand real, intent(out) :: integral private  subroutine theta_integrate_indef (integrand, integral) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(-nz:) :: integrand real, intent(out), dimension(-nz:) :: integral","tags":"","loc":"module/millerlocal.html"},{"title":"volume_averages – stella","text":"Variables Type Visibility Attributes Name Initial real, public, dimension(:), allocatable :: mode_fac complex, private, dimension(:, :), allocatable :: jacobian_ky Fourier coefficients in y of the Jacobian;\nneeded for full flux surface simulations Interfaces public        interface fieldline_average private  subroutine fieldline_average_real (unavg, avg) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :, -nzgrid:, :) :: unavg real, intent(out), dimension(:, :) :: avg private  subroutine fieldline_average_complex (unavg, avg) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: unavg complex, intent(out), dimension(:, :) :: avg Subroutines public  subroutine init_volume_averages () Arguments None public  subroutine finish_volume_averages () Arguments None private  subroutine fieldline_average_real (unavg, avg) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:, :, -nzgrid:, :) :: unavg real, intent(out), dimension(:, :) :: avg private  subroutine fieldline_average_complex (unavg, avg) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: unavg complex, intent(out), dimension(:, :) :: avg public  subroutine volume_average (unavg, avg) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: unavg real, intent(out) :: avg private  subroutine init_flux_surface_average_ffs () calculate the Fourier coefficients in y of the Jacobian\nthis is needed in the computation of the flux surface average of phi Arguments None public  subroutine flux_surface_average_ffs (no_fsa, fsa) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, -nzgrid:) :: no_fsa complex, intent(out) :: fsa","tags":"","loc":"module/volume_averages.html"},{"title":"job_manage – stella","text":"Variables Type Visibility Attributes Name Initial integer, public :: njobs = 1 Functions public  function timer_local () Arguments None Return Value real Subroutines public  subroutine time_message (lprint, targ, chmessage) Arguments Type Intent Optional Attributes Name logical, intent(in) :: lprint real, intent(inout) :: targ (2) character(len=*), intent(in) :: chmessage public  subroutine job_fork (n_ensembles) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: n_ensembles public  subroutine checkstop (exit, list) Arguments Type Intent Optional Attributes Name logical, intent(inout) :: exit logical, intent(in), optional :: list public  subroutine checktime (avail_time, exit) Arguments Type Intent Optional Attributes Name real, intent(in) :: avail_time logical, intent(inout) :: exit","tags":"","loc":"module/job_manage.html"},{"title":"stel_constants – stella","text":"Uses stel_kinds Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: pi = 3.14159265358979323846264338328_dp real(kind=dp), public, parameter :: pio2 = pi/2 real(kind=dp), public, parameter :: twopi = 2*pi real(kind=dp), public, parameter :: sqrt2 = 1.41421356237309504880168872_dp real(kind=dp), public, parameter :: degree = twopi/360 real(kind=dp), public, parameter :: one = 1 real(kind=dp), public, parameter :: zero = 0 real(kind=dp), public, parameter :: mu0 = 2*twopi*1.0e-7_dp","tags":"","loc":"module/stel_constants.html"},{"title":"vsvd0 – stella","text":"Uses stel_kinds Variables Type Visibility Attributes Name Initial real(kind=rprec), public, parameter :: fturnon_axis = 3.e-9_dp real(kind=rprec), public, parameter :: fopt_axis = 3.e-2_dp*fturnon_axis integer, public, parameter :: isamecoil = -2 integer, public, parameter :: needit = -1 integer, public, parameter :: idontneed = 0 integer, public, parameter :: isymcoil = 1 integer, public, parameter :: ithom0 = 1 integer, public, parameter :: istark0 = 2 integer, public, parameter :: islope0 = 3 integer, public, parameter :: icurr0 = 4 integer, public, parameter :: idiam0 = 5 integer, public, parameter :: iflxs0 = 6 integer, public, parameter :: ibrzfld = 7 integer, public, parameter :: natur = 0 integer, public, parameter :: ideriv = 1 integer, public, parameter :: intder = 1 integer, public, parameter :: intfun = 2 integer, public, parameter :: nmse = 100 integer, public, parameter :: ntse = 100 integer, public, parameter :: nfloops = 100 integer, public, parameter :: nbsetsp = 5 integer, public, parameter :: nbcoilsp = 100 integer, public, parameter :: nbctotp = nbsetsp*nbcoilsp integer, public, parameter :: jngrn = 1001 integer, public, parameter :: jchix = 7 integer, public, parameter :: mstp = 100 integer, public, parameter :: jchix1 = jchix+1 integer, public, parameter :: nparts = 4 integer, public, parameter :: npfcoil = 40 integer, public, parameter :: nigroup = 100 integer, public, parameter :: ipedsvd = 8","tags":"","loc":"module/vsvd0.html"},{"title":"flow_shear – stella","text":"Variables Type Visibility Attributes Name Initial logical, public :: flow_shear_initialized = .false. complex, private, dimension(:, :), allocatable :: upwind_advect real, public, dimension(:, :, :), allocatable :: prl_shear real, public, dimension(:, :, :), allocatable :: prl_shear_p real, public, dimension(:), allocatable :: prp_shear real, public, dimension(:), allocatable :: shift_times integer, private :: shift_sign integer, private :: shift_start real, public :: v_edge real, public :: v_shift = 0. Subroutines public  subroutine init_flow_shear () Arguments None public  subroutine advance_parallel_flow_shear (gout) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gout public  subroutine advance_perp_flow_shear (g) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: g public  subroutine finish_flow_shear () Arguments None","tags":"","loc":"module/flow_shear.html"},{"title":"sfincs_interface – stella","text":"Subroutines public  subroutine get_neo_from_sfincs (nradii, drho, f_neoclassical, phi_neoclassical, dfneo_dalpha, dphineo_dalpha) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nradii real, intent(in) :: drho real, intent(out), dimension(:, -nzgrid:, :, :, :, -nradii/2:) :: f_neoclassical real, intent(out), dimension(:, -nzgrid:, -nradii/2:) :: phi_neoclassical real, intent(out), dimension(:, -nzgrid:, :, :, :) :: dfneo_dalpha real, intent(out), dimension(:, -nzgrid:) :: dphineo_dalpha","tags":"","loc":"module/sfincs_interface.html"},{"title":"ezcdf_opncls – stella","text":"Interfaces public        interface cdfOpn public  subroutine ezcdf_open (ncid, filename, opt, ier) Arguments Type Intent Optional Attributes Name integer, intent(out) :: ncid character(len=*), intent(in) :: filename character(len=1), intent(in) :: opt integer, intent(out), optional :: ier public        interface cdf_open public  subroutine ezcdf_open (ncid, filename, opt, ier) Arguments Type Intent Optional Attributes Name integer, intent(out) :: ncid character(len=*), intent(in) :: filename character(len=1), intent(in) :: opt integer, intent(out), optional :: ier public        interface cdfCls public  subroutine ezcdf_close (ncid, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(out), optional :: ier public        interface cdf_close public  subroutine ezcdf_close (ncid, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(out), optional :: ier Subroutines public  subroutine ezcdf_open (ncid, filename, opt, ier) Arguments Type Intent Optional Attributes Name integer, intent(out) :: ncid character(len=*), intent(in) :: filename character(len=1), intent(in) :: opt integer, intent(out), optional :: ier public  subroutine ezcdf_close (ncid, ier) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(out), optional :: ier","tags":"","loc":"module/ezcdf_opncls.html"},{"title":"gyro_averages – stella","text":"inverse fourier transform coefs%fourier for several phase space points and compare with\nunfiltered version in alpha-space Uses common_types Variables Type Visibility Attributes Name Initial real, public, dimension(:, :, :, :), allocatable :: aj0x real, public, dimension(:, :, :, :), allocatable :: aj1x real, public, dimension(:, :), allocatable :: aj0v real, public, dimension(:, :), allocatable :: aj1v type( coupled_alpha_type ), public, dimension(:, :, :, :), allocatable :: j0_ffs type( coupled_alpha_type ), public, dimension(:, :, :, :), allocatable :: j0_B_maxwell_ffs logical, private :: bessinit = .false. logical, private :: debug = .false. Interfaces public        interface gyro_average private  subroutine gyro_average_local (field, iky, ikx, iz, ivmu, gyro_field) gyro_average_local takes a field at a given ky, kx, z and (vpa, mu, s) value\nand returns the gyro-average of that field; Arguments Type Intent Optional Attributes Name complex, intent(in) :: field integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: ivmu complex, intent(out) :: gyro_field private  subroutine gyro_average_kxky_local (field, iz, ivmu, gyro_field) if simulating a full flux surface, the alpha dependence present\nin kperp makes gyro-averaging non-local in k-space\nif simulating a flux tube, a gyro-average is local in k-space Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: field integer, intent(in) :: iz integer, intent(in) :: ivmu complex, intent(out), dimension(:, :) :: gyro_field private  subroutine gyro_average_kxkyz_local (field, ivmu, gyro_field) if simulating a full flux surface, the alpha dependence present\nin kperp makes gyro-averaging non-local in k-space\nif simulating a flux tube, a gyro-average is local in k-space Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: field integer, intent(in) :: ivmu complex, intent(out), dimension(:, :, -nzgrid:, :) :: gyro_field private  subroutine gyro_average_kxkyzv_local (field, gyro_field) if simulating a full flux surface, the alpha dependence present\nin kperp makes gyro-averaging non-local in k-space\nif simulating a flux tube, a gyro-average is local in k-space Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: field complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gyro_field private  subroutine gyro_average_v_local (distfn, imu, ikxkyz, gyro_distfn) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: distfn integer, intent(in) :: imu integer, intent(in) :: ikxkyz complex, intent(out), dimension(:) :: gyro_distfn private  subroutine gyro_average_vmu_local (distfn, ikxkyz, gyro_distfn) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: distfn integer, intent(in) :: ikxkyz complex, intent(out), dimension(:, :) :: gyro_distfn private  subroutine gyro_average_vmus_nonlocal (field, iky, ikx, iz, gyro_field) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(vmu_lo%llim_proc:) :: field integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz complex, intent(out), dimension(vmu_lo%llim_proc:) :: gyro_field private  subroutine gyro_average_ffs_kxky_local (field, gyro_field, coefs) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: field complex, intent(out), dimension(:, :) :: gyro_field type( coupled_alpha_type ), intent(in), dimension(:, :) :: coefs private  subroutine gyro_average_ffs_kxkyz_local (field, gyro_field, coefs) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: field complex, intent(out), dimension(:, :, -nzgrid:, :) :: gyro_field type( coupled_alpha_type ), intent(in), dimension(:, :, -nzgrid:) :: coefs private  subroutine gyro_average_ffs (dist, gyro_dist, coefs) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dist complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gyro_dist type( coupled_alpha_type ), intent(in), dimension(:, :, -nzgrid:, vmu_lo%llim_proc:) :: coefs public        interface gyro_average_j1 private  subroutine gyro_average_j1_vmus_nonlocal (field, iky, ikx, iz, gyro_field) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(vmu_lo%llim_proc:) :: field integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz complex, intent(out), dimension(vmu_lo%llim_proc:) :: gyro_field private  subroutine gyro_average_j1_local (field, iky, ikx, iz, ivmu, gyro_field) Arguments Type Intent Optional Attributes Name complex, intent(in) :: field integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: ivmu complex, intent(out) :: gyro_field private  subroutine gyro_average_j1_kxky_local (field, iz, ivmu, gyro_field) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: field integer, intent(in) :: iz integer, intent(in) :: ivmu complex, intent(out), dimension(:, :) :: gyro_field private  subroutine gyro_average_j1_kxkyz_local (field, ivmu, gyro_field) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: field integer, intent(in) :: ivmu complex, intent(out), dimension(:, :, -nzgrid:, :) :: gyro_field private  subroutine gyro_average_j1_v_local (distfn, imu, ikxkyz, gyro_distfn) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: distfn integer, intent(in) :: imu integer, intent(in) :: ikxkyz complex, intent(out), dimension(:) :: gyro_distfn private  subroutine gyro_average_j1_vmu_local (distfn, ikxkyz, gyro_distfn) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: distfn integer, intent(in) :: ikxkyz complex, intent(out), dimension(:, :) :: gyro_distfn private  subroutine gyro_average_j1_kxkyzv_local (field, gyro_field) if simulating a full flux surface, the alpha dependence present\nin kperp makes gyro-averaging non-local in k-space\nif simulating a flux tube, a gyro-average is local in k-space Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: field complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gyro_field Subroutines public  subroutine init_bessel () Arguments None private  subroutine init_bessel_ffs () aj0_alpha will contain J_0 as a function of k_alpha and alpha\nj0_B_maxwell will contain J_0 B exp(-v&#94;2) as a function of k_alpha and alpha\nfor each value of alpha, take kperp&#94;2 calculated on domain kx = [-kx_max, kx_max] and ky = [0, ky_max]\nand use symmetry to obtain kperp&#94;2 on domain kx = [0, kx_max] and ky = [-ky_max, ky_max]\nthis makes later convolutions involving sums over all ky more straightforward\ncalculate the argument of the Bessel function, which depends on both alpha and k_alpha Read more… Arguments None private  subroutine find_max_required_kalpha_index (ft, idx, imu, iz, is) subroutine takes a set of Fourier coefficients (ft)\nand returns the minimum number of coeffients that must be retained (idx)\nto ensure that the relative error in the total spectral energy is\nbelow a specified tolerance (tol_floor) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: ft integer, intent(out) :: idx integer, intent(in), optional :: imu integer, intent(in), optional :: iz integer, intent(in), optional :: is public  subroutine finish_bessel () Arguments None private  subroutine gyro_average_local (field, iky, ikx, iz, ivmu, gyro_field) gyro_average_local takes a field at a given ky, kx, z and (vpa, mu, s) value\nand returns the gyro-average of that field; Arguments Type Intent Optional Attributes Name complex, intent(in) :: field integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: ivmu complex, intent(out) :: gyro_field private  subroutine gyro_average_kxky_local (field, iz, ivmu, gyro_field) if simulating a full flux surface, the alpha dependence present\nin kperp makes gyro-averaging non-local in k-space\nif simulating a flux tube, a gyro-average is local in k-space Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: field integer, intent(in) :: iz integer, intent(in) :: ivmu complex, intent(out), dimension(:, :) :: gyro_field private  subroutine gyro_average_kxkyz_local (field, ivmu, gyro_field) if simulating a full flux surface, the alpha dependence present\nin kperp makes gyro-averaging non-local in k-space\nif simulating a flux tube, a gyro-average is local in k-space Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: field integer, intent(in) :: ivmu complex, intent(out), dimension(:, :, -nzgrid:, :) :: gyro_field private  subroutine gyro_average_kxkyzv_local (field, gyro_field) if simulating a full flux surface, the alpha dependence present\nin kperp makes gyro-averaging non-local in k-space\nif simulating a flux tube, a gyro-average is local in k-space Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: field complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gyro_field private  subroutine gyro_average_ffs_kxky_local (field, gyro_field, coefs) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: field complex, intent(out), dimension(:, :) :: gyro_field type( coupled_alpha_type ), intent(in), dimension(:, :) :: coefs private  subroutine gyro_average_ffs_kxkyz_local (field, gyro_field, coefs) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: field complex, intent(out), dimension(:, :, -nzgrid:, :) :: gyro_field type( coupled_alpha_type ), intent(in), dimension(:, :, -nzgrid:) :: coefs private  subroutine gyro_average_ffs (dist, gyro_dist, coefs) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: dist complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gyro_dist type( coupled_alpha_type ), intent(in), dimension(:, :, -nzgrid:, vmu_lo%llim_proc:) :: coefs private  subroutine gyro_average_v_local (distfn, imu, ikxkyz, gyro_distfn) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: distfn integer, intent(in) :: imu integer, intent(in) :: ikxkyz complex, intent(out), dimension(:) :: gyro_distfn private  subroutine gyro_average_vmu_local (distfn, ikxkyz, gyro_distfn) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: distfn integer, intent(in) :: ikxkyz complex, intent(out), dimension(:, :) :: gyro_distfn private  subroutine gyro_average_vmus_nonlocal (field, iky, ikx, iz, gyro_field) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(vmu_lo%llim_proc:) :: field integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz complex, intent(out), dimension(vmu_lo%llim_proc:) :: gyro_field private  subroutine gyro_average_j1_vmus_nonlocal (field, iky, ikx, iz, gyro_field) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(vmu_lo%llim_proc:) :: field integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz complex, intent(out), dimension(vmu_lo%llim_proc:) :: gyro_field private  subroutine gyro_average_j1_local (field, iky, ikx, iz, ivmu, gyro_field) Arguments Type Intent Optional Attributes Name complex, intent(in) :: field integer, intent(in) :: iky integer, intent(in) :: ikx integer, intent(in) :: iz integer, intent(in) :: ivmu complex, intent(out) :: gyro_field private  subroutine gyro_average_j1_kxky_local (field, iz, ivmu, gyro_field) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: field integer, intent(in) :: iz integer, intent(in) :: ivmu complex, intent(out), dimension(:, :) :: gyro_field private  subroutine gyro_average_j1_kxkyz_local (field, ivmu, gyro_field) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :) :: field integer, intent(in) :: ivmu complex, intent(out), dimension(:, :, -nzgrid:, :) :: gyro_field private  subroutine gyro_average_j1_vmu_local (distfn, ikxkyz, gyro_distfn) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: distfn integer, intent(in) :: ikxkyz complex, intent(out), dimension(:, :) :: gyro_distfn private  subroutine gyro_average_j1_v_local (distfn, imu, ikxkyz, gyro_distfn) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:) :: distfn integer, intent(in) :: imu integer, intent(in) :: ikxkyz complex, intent(out), dimension(:) :: gyro_distfn private  subroutine gyro_average_j1_kxkyzv_local (field, gyro_field) if simulating a full flux surface, the alpha dependence present\nin kperp makes gyro-averaging non-local in k-space\nif simulating a flux tube, a gyro-average is local in k-space Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: field complex, intent(out), dimension(:, :, -nzgrid:, :, vmu_lo%llim_proc:) :: gyro_field public  subroutine band_lu_solve_ffs (lu, solvec) Arguments Type Intent Optional Attributes Name type( gam0_ffs_type ), intent(in), dimension(:, -nzgrid:) :: lu complex, intent(inout), dimension(:, :, -nzgrid:) :: solvec private  subroutine band_lu_solve_ffs_single (lu, solvec) Arguments Type Intent Optional Attributes Name type( gam0_ffs_type ), intent(in) :: lu complex, intent(inout), dimension(:) :: solvec public  subroutine band_lu_factorisation_ffs (gam0, lu_gam0) Arguments Type Intent Optional Attributes Name type( coupled_alpha_type ), intent(in), dimension(:, :, -nzgrid:) :: gam0 type( gam0_ffs_type ), intent(out), dimension(:, -nzgrid:) :: lu_gam0 private  subroutine band_lu_factorisation_single (gam0, lu_gam0) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:, :) :: gam0 type( gam0_ffs_type ), intent(out) :: lu_gam0","tags":"","loc":"module/gyro_averages.html"},{"title":"file_utils – stella","text":"Variables Type Visibility Attributes Name Initial character(len=500), public, pointer :: run_name character(len=500), private, target :: arun_name character(len=500), private, target :: job_name character(len=500), public :: list_name integer, public, parameter :: stdout_unit = 6 integer, public :: runtype_option_switch integer, public, parameter :: runtype_standalone = 0 integer, public, parameter :: runtype_list = 1 integer, public, parameter :: runtype_trinity = 2 integer, public, parameter :: runtype_multibox = 3 integer, private, save :: input_unit_no integer, private, save :: error_unit_no = stdout_unit integer, public, save :: num_input_lines Functions public  function input_unit (nml) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: nml Return Value integer public  function input_unit_exist (nml, exist) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: nml logical, intent(out) :: exist Return Value integer public  function error_unit () Arguments None Return Value integer Subroutines public  subroutine init_file_utils (list, input, error, trin_run, name, n_ensembles) Arguments Type Intent Optional Attributes Name logical, intent(out) :: list logical, intent(in), optional :: input logical, intent(in), optional :: error logical, intent(in), optional :: trin_run character(len=*), intent(in), optional :: name integer, intent(in), optional :: n_ensembles private  subroutine run_type (list) Arguments Type Intent Optional Attributes Name logical, intent(out) :: list private  subroutine init_run_name () Arguments None public  subroutine init_job_name (jobname) Arguments Type Intent Optional Attributes Name character(len=500), intent(in) :: jobname public  subroutine get_unused_unit (unit) Arguments Type Intent Optional Attributes Name integer, intent(out) :: unit public  subroutine open_output_file (unit, ext, overwrite_in) Arguments Type Intent Optional Attributes Name integer, intent(out) :: unit character(len=*), intent(in) :: ext logical, intent(in), optional :: overwrite_in public  subroutine close_output_file (unit) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit public  subroutine flush_output_file (unit) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit public  subroutine init_error_unit (open_it) Arguments Type Intent Optional Attributes Name logical, intent(in) :: open_it private  subroutine strip_comments (line) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: line public  subroutine init_input_unit (open_it) Arguments Type Intent Optional Attributes Name logical, intent(in) :: open_it public  subroutine finish_file_utils () Arguments None public  subroutine get_input_unit (unit) Arguments Type Intent Optional Attributes Name integer, intent(out) :: unit public  subroutine get_indexed_namelist_unit (unit, nml, index_in) Arguments Type Intent Optional Attributes Name integer, intent(out) :: unit character(len=*), intent(in) :: nml integer, intent(in) :: index_in","tags":"","loc":"module/file_utils.html"},{"title":"command_line – stella","text":"Functions public  function cl_iargc () Arguments None Return Value integer Subroutines public  subroutine cl_getarg (k, arg, len, ierr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: k character(len=*), intent(out) :: arg integer, intent(out) :: len integer, intent(out) :: ierr","tags":"","loc":"module/command_line.html"},{"title":"init_g – stella","text":"This module contains the subroutines which set the initial value of the Variables Type Visibility Attributes Name Initial integer, private :: ginitopt_switch integer, private, parameter :: ginitopt_default = 1 integer, private, parameter :: ginitopt_noise = 2 integer, private, parameter :: ginitopt_restart_many = 3 integer, private, parameter :: ginitopt_kpar = 4 integer, private, parameter :: ginitopt_nltest = 5 integer, private, parameter :: ginitopt_kxtest = 6 integer, private, parameter :: ginitopt_rh = 7 integer, private, parameter :: ginitopt_remap = 8 real, public :: width0 real, public :: phiinit real, private :: imfac real, private :: refac real, private :: zf_init real, private :: den0 real, private :: upar0 real, private :: tpar0 real, private :: tperp0 real, private :: den1 real, private :: upar1 real, private :: tpar1 real, private :: tperp1 real, private :: den2 real, private :: upar2 real, private :: tpar2 real, private :: tperp2 real, public :: tstart real, private :: scale real, private :: kxmax real, private :: kxmin logical, private :: chop_side logical, private :: left logical, public :: scale_to_phiinit logical, private :: oddparity character(len=300), public :: restart_file character(len=150), private :: restart_dir logical, private :: initialized = .false. logical, private :: exist Subroutines public  subroutine init_init_g () Arguments None public  subroutine ginit (restarted, istep0) if maxwwellian_normalization = .true., the pdf is normalized by F0 (which is not the case otherwise)\nunless reading in g from a restart file, normalise g by F0 for a full flux surface simulation Arguments Type Intent Optional Attributes Name logical, intent(out) :: restarted integer, intent(out) :: istep0 private  subroutine read_parameters () Arguments None private  subroutine ginit_default () Arguments None private  subroutine ginit_noise () Initialise the distribution function with random noise. This is the default Arguments None private  subroutine ginit_kpar () Arguments None private  subroutine ginit_rh () Arguments None private  subroutine ginit_remap () Arguments None private  subroutine ginit_restart_many () Arguments None private  subroutine normalize_by_maxwellian () gvmu is initialised with a Maxwellian weighting for flux tube simulations,\nwith the Maxwellian evaluated at ia = 1\nwe are undoing that weighting here, so also need to use ia = 1 Arguments None public  subroutine reset_init () Arguments None public  subroutine finish_init_g () Arguments None","tags":"","loc":"module/init_g.html"},{"title":"physics_parameters – stella","text":"Variables Type Visibility Attributes Name Initial real, public :: beta real, public :: zeff real, public :: tite real, public :: nine real, public :: rhostar real, private :: irhostar real, public :: vnew_ref real, public :: g_exb real, public :: g_exbfac real, public :: omprimfac logical, private :: initialized = .false. Subroutines public  subroutine init_physics_parameters () Arguments None private  subroutine read_parameters () Arguments None public  subroutine finish_physics_parameters () Arguments None","tags":"","loc":"module/physics_parameters.html"},{"title":"test_vmec_to_stella_geometry_interface – stella","text":"Uses vmec_to_stella_geometry_interface_mod Input parameters Variables Type Attributes Name Initial character(len=2000) :: vmec_filename = 'equilibria/wout_w7x_standardConfig.nc' integer, parameter :: nalpha = 5 integer, parameter :: nzgrid = 7 real :: alpha0 = 0.0 real :: gradpar_zeta_prefac = 1.0 real :: zeta_center = 0.0 real :: number_of_field_periods_to_include = 1 real :: desired_normalized_toroidal_flux = 0.6354167d+0 integer :: vmec_surface_option = 0 logical :: verbose = .true. Output arrays real :: normalized_toroidal_flux_used real :: safety_factor_q real :: shat real :: L_reference real :: B_reference real :: nfp integer :: sign_toroidal_flux real, dimension(nalpha) :: alpha real, dimension(-nzgrid:nzgrid) :: zeta real, dimension(nalpha, -nzgrid:nzgrid) :: bmag real, dimension(nalpha, -nzgrid:nzgrid) :: gradpar real, dimension(nalpha, -nzgrid:nzgrid) :: gds2 real, dimension(nalpha, -nzgrid:nzgrid) :: gds21 real, dimension(nalpha, -nzgrid:nzgrid) :: gds22 real, dimension(nalpha, -nzgrid:nzgrid) :: gds23 real, dimension(nalpha, -nzgrid:nzgrid) :: gds24 real, dimension(nalpha, -nzgrid:nzgrid) :: gds25 real, dimension(nalpha, -nzgrid:nzgrid) :: gds26 real, dimension(nalpha, -nzgrid:nzgrid) :: gbdrift real, dimension(nalpha, -nzgrid:nzgrid) :: gbdrift0 real, dimension(nalpha, -nzgrid:nzgrid) :: cvdrift real, dimension(nalpha, -nzgrid:nzgrid) :: cvdrift0 real, dimension(nalpha, -nzgrid:nzgrid) :: theta_vmec real, dimension(nalpha, -nzgrid:nzgrid) :: B_sub_zeta Variables used internally by this program real, dimension(nalpha, -nzgrid:nzgrid) :: B_sub_theta_vmec Variables used internally by this program real, dimension(nalpha, -nzgrid:nzgrid) :: displacement Variables used internally by this program integer :: j Beginning of executable statements integer :: iunit Beginning of executable statements integer :: ierr Beginning of executable statements","tags":"","loc":"program/test_vmec_to_stella_geometry_interface.html"},{"title":"stella – stella","text":"Uses stella_diagnostics job_manage git_version dist_fn_arrays dist_redistribute file_utils redistribute stella_save stella_time run_parameters time_advance Initialize stella Diagnose stella\nAdvance stella until istep=nstep\nFinish stella Variables Type Attributes Name Initial logical :: debug = .false. logical :: stop_stella = .false. logical :: mpi_initialized = .false. integer :: istep0 integer :: istep integer :: ierr integer :: istatus real, dimension(2) :: time_init = 0. real, dimension(2) :: time_diagnostics = 0. real, dimension(2) :: time_total = 0. Subroutines subroutine init_stella (istep0, VERNUM, VERDATE) Initialise stella Read more… Arguments Type Intent Optional Attributes Name integer, intent(out) :: istep0 Starting timestep: zero unless the simulation has been restarted character(len=*), intent(in) :: VERNUM stella version number character(len=10), intent(in) :: VERDATE Release date subroutine init_multibox_subcalls () call all the multibox communication subroutines to make sure all the jobs have\nthe appropriate information Arguments None subroutine check_transforms (needs_transforms) check_transforms checks the various physics flag choices\nto determine if FFTs are needed for the simulation Read more… Arguments Type Intent Optional Attributes Name logical, intent(out) :: needs_transforms subroutine write_start_message (VERNUM, VERDATE) Write the start message to screen Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: VERNUM stella version number character(len=10), intent(in) :: VERDATE Release date subroutine print_header () Arguments None subroutine parse_command_line () Parse some basic command line arguments. Currently just 'version' and 'help'. Read more… Arguments None subroutine finish_stella (last_call) Finish a simulation, call the finialisation routines of all modules Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: last_call","tags":"","loc":"program/stella.html"},{"title":"fluxes – stella","text":"Variables Type Attributes Name Initial integer :: iargc integer :: flxunit = 101 integer :: it integer :: nstep integer :: nspec integer :: target_it real :: tstart = 0.0 logical :: tstart_flag character(len=500) :: line character(len=500) :: flxfile real, dimension(:), allocatable :: time real, dimension(:, :), allocatable :: pflx real, dimension(:, :), allocatable :: vflx real, dimension(:, :), allocatable :: qflx real, dimension(:), allocatable :: pflxavg real, dimension(:), allocatable :: vflxavg real, dimension(:), allocatable :: qflxavg real, dimension(:), allocatable :: pi_over_q Subroutines subroutine time_average (t, it, flx, flxavg) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: t integer, intent(in) :: it real, intent(in), dimension(:, :) :: flx real, intent(out), dimension(:) :: flxavg","tags":"","loc":"program/fluxes.html"},{"title":"  physics_flags %ndash; stella\n","text":"Variables Name Type Default Description full_flux_surface logical None radial_variation logical None include_parallel_nonlinearity logical None include_parallel_streaming logical None include_mirror logical None include_apar logical None include_bpar logical None nonlinear logical None include_pressure_variation logical None include_geometric_variation logical None adiabatic_option character(len=30) None const_alpha_geo logical None","tags":"","loc":"namelist/physics_flags.html"},{"title":"  geo_knobs %ndash; stella\n","text":"Variables Name Type Default Description geo_option character(len=20) None geo_file character(len=100) None overwrite_bmag logical None overwrite_gradpar logical None overwrite_gds2 logical None overwrite_gds21 logical None overwrite_gds22 logical None overwrite_gds23 logical None overwrite_gds24 logical None overwrite_gbdrift logical None overwrite_cvdrift logical None overwrite_gbdrift0 logical None q_as_x logical None set_bmag_const logical None","tags":"","loc":"namelist/geo_knobs.html"},{"title":"  zgrid_parameters %ndash; stella\n","text":"Variables Name Type Default Description nzed integer None nperiod integer None ntubes integer None shat_zero real None boundary_option character(len=20) None zed_equal_arc logical None grad_x_grad_y_zero real None dkx_over_dky real None","tags":"","loc":"namelist/zgrid_parameters.html"},{"title":"  collisions_dougherty %ndash; stella\n","text":"Variables Name Type Default Description momentum_conservation logical None energy_conservation logical None vpa_operator logical None mu_operator logical None","tags":"","loc":"namelist/collisions_dougherty.html"},{"title":"  sources %ndash; stella\n","text":"Variables Name Type Default Description source_option character(len=30) None nu_krook real None tcorr_source real None ikxmax_source integer None krook_odd logical None exclude_boundary_regions logical None tcorr_source_qn real None exclude_boundary_regions_qn logical None from_zero logical None conserve_momentum logical None conserve_density logical None","tags":"","loc":"namelist/sources.html"},{"title":"  species_knobs %ndash; stella\n","text":"Variables Name Type Default Description nspec integer None species_option character(len=20) None read_profile_variation logical None write_profile_variation logical None ecoll_zeff logical None","tags":"","loc":"namelist/species_knobs.html"},{"title":"  species_parameters %ndash; stella\n","text":"Variables Name Type Default Description z real None mass real None dens real None temp real None tprim real None fprim real None d2ndr2 real None d2Tdr2 real None bess_fac real None type character(len=20) None","tags":"","loc":"namelist/species_parameters.html"},{"title":"  vmec_parameters %ndash; stella\n","text":"Variables Name Type Default Description alpha0 real None zeta_center real None nfield_periods real None torflux real None zgrid_scalefac real None zgrid_refinement_factor integer None surface_option integer None verbose logical None vmec_filename character(len=2000) None gradpar_zeta_prefac real None n_tolerated_test_arrays_inconsistencies integer None","tags":"","loc":"namelist/vmec_parameters.html"},{"title":"  dissipation %ndash; stella\n","text":"Variables Name Type Default Description include_collisions logical None collisions_implicit logical None collision_model character(len=30) None hyper_dissipation logical None","tags":"","loc":"namelist/dissipation.html"},{"title":"  collisions_fp %ndash; stella\n","text":"Variables Name Type Default Description testpart logical None fieldpart logical None lmax integer 1 jmax integer 1 nvel_local integer None interspec logical None intraspec logical None iiknob real None ieknob real None eeknob real None eiknob real None eiediffknob real None eideflknob real None deflknob real None eimassr_approx logical None advfield_coll logical None spitzer_problem logical None density_conservation logical None density_conservation_field logical None density_conservation_tp logical None exact_conservation logical None exact_conservation_tp logical None vpa_operator logical None mu_operator logical None cfac real None cfac2 real None nuxfac real None i1fac real None i2fac real None no_j1l1 logical None no_j1l2 logical None no_j0l2 logical None","tags":"","loc":"namelist/collisions_fp.html"},{"title":"  stella_diagnostics_knobs %ndash; stella\n","text":"Variables Name Type Default Description nwrite integer None navg integer None nsave integer None save_for_restart logical None write_phi_vs_time logical None write_apar_vs_time logical None write_bpar_vs_time logical None write_gvmus logical None write_gzvs logical None write_omega logical None write_kspectra logical None write_moments logical None write_radial_fluxes logical None write_radial_moments logical None write_fluxes_kxkyz logical None flux_norm logical None nc_mult integer None","tags":"","loc":"namelist/stella_diagnostics_knobs.html"},{"title":"  hyper %ndash; stella\n","text":"Variables Name Type Default Description D_hyper real None use_physical_ksqr logical None scale_to_outboard logical None","tags":"","loc":"namelist/hyper.html"},{"title":"  kt_grids_box_parameters %ndash; stella\n","text":"Variables Name Type Default Description nx integer None ny integer None jtwist integer None jtwistfac real None x0 real None y0 real None centered_in_rho logical None periodic_variation logical None randomize_phase_shift logical None phase_shift_angle real None","tags":"","loc":"namelist/kt_grids_box_parameters.html"},{"title":"  kt_grids_range_parameters %ndash; stella\n","text":"Variables Name Type Default Description naky integer None nakx integer None aky_min real None aky_max real None theta0_min real None theta0_max real None akx_min real None akx_max real None kyspacing_option character(len=20) 'default'","tags":"","loc":"namelist/kt_grids_range_parameters.html"},{"title":"  time_advance_knobs %ndash; stella\n","text":"Variables Name Type Default Description xdriftknob real None ydriftknob real None wstarknob real None explicit_option character(len=10) None flip_flop logical None","tags":"","loc":"namelist/time_advance_knobs.html"},{"title":"  euterpe_parameters %ndash; stella\n","text":"Variables Name Type Default Description nradii integer None data_file character(len=1000) None","tags":"","loc":"namelist/euterpe_parameters.html"},{"title":"  layouts_knobs %ndash; stella\n","text":"Variables Name Type Default Description xyzs_layout character(len=4) None vms_layout character(len=3) None","tags":"","loc":"namelist/layouts_knobs.html"},{"title":"  multibox_parameters %ndash; stella\n","text":"Variables Name Type Default Description boundary_size integer None krook_size integer None smooth_ZFs logical None zf_option character(len=30) None LR_debug_option character(len=30) None krook_option character(len=30) None RK_step logical None nu_krook_mb real None mb_debug_step integer None krook_exponent real None comm_at_init logical None phi_bound integer None phi_pow integer None krook_efold real None use_dirichlet_BC logical None","tags":"","loc":"namelist/multibox_parameters.html"},{"title":"  neoclassical_input %ndash; stella\n","text":"Variables Name Type Default Description include_neoclassical_terms logical None neo_option character(len=10) None nradii integer None drho real None","tags":"","loc":"namelist/neoclassical_input.html"},{"title":"  knobs %ndash; stella\n","text":"Variables Name Type Default Description fphi real None fapar real None fbpar real None delt real None nstep integer None tend real None delt_option character(len=20) None lu_option character(len=20) None avail_cpu_time real None delt_max real None delt_min real None cfl_cushion_upper real None cfl_cushion_middle real None cfl_cushion_lower real None stream_implicit logical None mirror_implicit logical None driftkinetic_implicit logical None drifts_implicit logical None use_deltaphi_for_response_matrix logical None maxwellian_normalization logical None stream_matrix_inversion logical None maxwellian_inside_zed_derivative logical None mirror_semi_lagrange logical None mirror_linear_interp logical None zed_upwind real None vpa_upwind real None time_upwind real None fields_kxkyz logical None mat_gen logical None mat_read logical None rng_seed integer None ky_solve_radial integer None ky_solve_real logical None","tags":"","loc":"namelist/knobs.html"},{"title":"  vpamu_grids_parameters %ndash; stella\n","text":"Variables Name Type Default Description nvgrid integer None nmu integer None vpa_max real None vperp_max real None equally_spaced_mu_grid logical None conservative_wgts_vpa logical None","tags":"","loc":"namelist/vpamu_grids_parameters.html"},{"title":"  millergeo_parameters %ndash; stella\n","text":"Variables Name Type Default Description rhoc real None rmaj real None shift real None qinp real None shat real None kappa real None kapprim real None tri real None triprim real None rgeo real None betaprim real None betadbprim real None d2qdr2 real None d2psidr2 real None nzed_local integer None read_profile_variation logical None write_profile_variation logical None","tags":"","loc":"namelist/millergeo_parameters.html"},{"title":"  init_g_knobs %ndash; stella\n","text":"Variables Name Type Default Description ginit_option character(len=20) None width0 real None phiinit real None chop_side logical None restart_file character(len=300) None restart_dir character(len=150) None read_many logical .true. left logical None scale real None tstart real None zf_init real None den0 real None upar0 real None tpar0 real None tperp0 real None imfac real None refac real None den1 real None upar1 real None tpar1 real None tperp1 real None den2 real None upar2 real None tpar2 real None tperp2 real None kxmax real None kxmin real None scale_to_phiinit logical None oddparity logical None","tags":"","loc":"namelist/init_g_knobs.html"},{"title":"  parameters %ndash; stella\n","text":"Variables Name Type Default Description beta real None zeff real None tite real None nine real None rhostar real None vnew_ref real None g_exb real None g_exbfac real None omprimfac real None irhostar real None","tags":"","loc":"namelist/parameters.html"},{"title":"physics_flags.f90 – stella","text":"Source Code module physics_flags implicit none public :: init_physics_flags public :: finish_physics_flags public :: full_flux_surface public :: radial_variation public :: include_apar public :: include_bpar public :: include_parallel_nonlinearity public :: include_parallel_streaming public :: include_mirror public :: prp_shear_enabled public :: hammett_flow_shear public :: include_pressure_variation public :: include_geometric_variation public :: nonlinear public :: adiabatic_option_switch public :: adiabatic_option_fieldlineavg public :: const_alpha_geo private logical :: full_flux_surface logical :: radial_variation logical :: include_apar logical :: include_bpar logical :: include_parallel_nonlinearity logical :: include_parallel_streaming logical :: include_pressure_variation logical :: include_geometric_variation logical :: include_mirror logical :: nonlinear logical :: prp_shear_enabled logical :: hammett_flow_shear logical :: const_alpha_geo integer :: adiabatic_option_switch integer , parameter :: adiabatic_option_default = 1 , & adiabatic_option_zero = 2 , & adiabatic_option_fieldlineavg = 3 logical :: initialized = . false . contains subroutine init_physics_flags implicit none if ( initialized ) return initialized = . true . call read_parameters end subroutine init_physics_flags subroutine read_parameters use file_utils , only : input_unit_exist , error_unit use mp , only : proc0 , broadcast use text_options , only : text_option , get_option_value implicit none integer :: in_file , ierr logical :: rpexist type ( text_option ), dimension ( 6 ), parameter :: adiabaticopts = & ( / text_option ( 'default' , adiabatic_option_default ), & text_option ( 'no-field-line-average-term' , adiabatic_option_default ), & text_option ( 'field-line-average-term' , adiabatic_option_fieldlineavg ), & text_option ( 'iphi00=0' , adiabatic_option_default ), & text_option ( 'iphi00=1' , adiabatic_option_default ), & text_option ( 'iphi00=2' , adiabatic_option_fieldlineavg ) / ) character ( 30 ) :: adiabatic_option namelist / physics_flags / full_flux_surface , radial_variation , & include_parallel_nonlinearity , include_parallel_streaming , & include_mirror , include_apar , include_bpar , nonlinear , & include_pressure_variation , include_geometric_variation , & adiabatic_option , const_alpha_geo if ( proc0 ) then full_flux_surface = . false . radial_variation = . false . include_apar = . false . include_bpar = . false . include_pressure_variation = . true . include_geometric_variation = . true . include_parallel_nonlinearity = . false . include_parallel_streaming = . true . include_mirror = . true . nonlinear = . false . adiabatic_option = 'default' const_alpha_geo = . false . in_file = input_unit_exist ( \"physics_flags\" , rpexist ) if ( rpexist ) read ( unit = in_file , nml = physics_flags ) ierr = error_unit () call get_option_value & ( adiabatic_option , adiabaticopts , adiabatic_option_switch , & ierr , \"adiabatic_option in physics_flags\" ) end if prp_shear_enabled = . false . hammett_flow_shear = . true . call broadcast ( full_flux_surface ) call broadcast ( radial_variation ) call broadcast ( include_apar ) call broadcast ( include_bpar ) call broadcast ( include_pressure_variation ) call broadcast ( include_geometric_variation ) call broadcast ( include_parallel_nonlinearity ) call broadcast ( include_parallel_streaming ) call broadcast ( include_mirror ) call broadcast ( nonlinear ) call broadcast ( adiabatic_option_switch ) call broadcast ( const_alpha_geo ) end subroutine read_parameters subroutine finish_physics_flags implicit none initialized = . false . end subroutine finish_physics_flags end module physics_flags","tags":"","loc":"sourcefile/physics_flags.f90.html"},{"title":"spfunc.fpp – stella","text":"Source Code # include \"define.inc\" ! ! special function wrapper routine written by Tomo Tatsuno (5/7/08) ! only has Bessel function at the moment ! ! RN 2008/07/01: Error function is added ! RN 2008/07/01: Compilers not having intrinsic those special functions !                must choose one of the following !                 1: local [USE_LOCAL_SPFUNC=on] !                 2: NAG Library [USE_NAGLIB=spfunc] ! ! Unfortunately we do not support elemental feature for ifort... ! XL-fortran does not seem to have intrinsic Bessel function ! ! To do: avoid explicit specification of kind and use kind_rs or kind_rd !        support of other compilers such as absoft, lahay etc... ! ! PGI cannot use kind_rs, kind_rd as kind specifications, but it is ok ! because we know kind_rs=4 kind_rd=8 for PGI ! module spfunc use constants , only : kind_rs , kind_rd # if SPFUNC == _SPNAG_ use constants , only : nag_kind # endif implicit none public :: j0 , j1 public :: erf_ext private # if SPFUNC == _SPNAG_ ! error handling ! ifail=0: terminate the program ! ifail=1 (-1): continues the program w/o (w) error messages integer :: ifail = - 1 # endif # if SPFUNC == _SPLOCAL_ # elif SPFUNC == _SPNAG_ # else /* if not _SPLOCAL_ and not _SPNAG_ */ # if (FCOMPILER == _GFORTRAN_ || FCOMPILER == _INTEL_ \\ || FCOMPILER == _ PATHSCALE_ ) interface j0 module procedure sj0 , dj0 end interface interface j1 module procedure sj1 , dj1 end interface interface erf_ext module procedure serf_ext , derf_ext end interface # elif FCOMPILER == _G95_ /* not _GFORTRAN_, _INTEL_, _PATHSCALE_ */ interface j0 module procedure sj0 , dj0 end interface interface j1 module procedure sj1 , dj1 end interface # elif FCOMPILER == _PGI_ /* not _GFORTRAN_, _INTEL_, _PATHSCALE_, _G95_ */ interface j0 elemental function besj0 ( x ) real ( kind = 4 ), intent ( in ) :: x real ( kind = 4 ) :: besj0 end function besj0 elemental function dbesj0 ( x ) real ( kind = 8 ), intent ( in ) :: x real ( kind = 8 ) :: dbesj0 end function dbesj0 end interface ! j1 is below interface erf_ext elemental function erf ( x ) real ( kind = 4 ), intent ( in ) :: x real ( kind = 4 ) :: erf end function erf elemental function derf ( x ) real ( kind = 8 ), intent ( in ) :: x real ( kind = 8 ) :: derf end function derf end interface # endif /* FCOMPILER */ # endif /* SPFUNC */ contains # if SPFUNC == _SPLOCAL_ !-------------------------------------------------------------------------! ! double precision Bessel functions (dbesj0.f dbesj1.f)                   ! ! http://www.kurims.kyoto-u.ac.jp/~ooura/bessel.html                      ! !-------------------------------------------------------------------------! ! Copyright(C) 1996 Takuya OOURA (email: ooura@mmm.t.u-tokyo.ac.jp).      ! ! You may use, copy, modify this code for any purpose and                 ! ! without fee. You may distribute this ORIGINAL package.                  ! !-------------------------------------------------------------------------! ! Modified by Ryusuke NUMATA 2008/06/27                                   ! !  to fit F90 format, and for j1 to give besj1/x                          ! !-------------------------------------------------------------------------! ! these routines are declared as real, but can be promoted to ! double presicion using compiler option. ! this is so because constatns used are only double precision, ! and cannot be promoted to quad-precision. ! differences from GNU gfortran besj0 and besj1 are ! |err| < 1.e-15 elemental function j0 ( x ) ! Bessel J_0(x) function in double precision use constants , only : pi real :: j0 real , intent ( in ) :: x integer :: k real :: w , t , y , theta , v real , parameter :: a ( 0 : 7 ) = ( / & & - 0.0000000000023655394 , 0.0000000004708898680 , & & - 0.0000000678167892231 , 0.0000067816840038636 , & & - 0.0004340277777716935 , 0.0156249999999992397 , & & - 0.2499999999999999638 , 0.9999999999999999997 / ) real , parameter :: b ( 0 : 64 ) = ( / & & 0.0000000000626681117 , - 0.0000000022270614428 , & & 0.0000000662981656302 , - 0.0000016268486502196 , & & 0.0000321978384111685 , - 0.0005005237733315830 , & & 0.0059060313537449816 , - 0.0505265323740109701 , & & 0.2936432097610503985 , - 1.0482565081091638637 , & & 1.9181123286040428113 , - 1.1319199475221700100 , & & - 0.1965480952704682000 , 0.0000000000457457332 , & & - 0.0000000015814772025 , 0.0000000455487446311 , & & - 0.0000010735201286233 , 0.0000202015179970014 , & & - 0.0002942392368203808 , 0.0031801987726150648 , & & - 0.0239875209742846362 , 0.1141447698973777641 , & & - 0.2766726722823530233 , 0.1088620480970941648 , & & 0.5136514645381999197 , - 0.2100594022073706033 , & & 0.0000000000331366618 , - 0.0000000011119090229 , & & 0.0000000308823040363 , - 0.0000006956602653104 , & & 0.0000123499947481762 , - 0.0001662951945396180 , & & 0.0016048663165678412 , - 0.0100785479932760966 , & & 0.0328996815223415274 , - 0.0056168761733860688 , & & - 0.2341096400274429386 , 0.2551729256776404262 , & & 0.2288438186148935667 , 0.0000000000238007203 , & & - 0.0000000007731046439 , 0.0000000206237001152 , & & - 0.0000004412291442285 , 0.0000073107766249655 , & & - 0.0000891749801028666 , 0.0007341654513841350 , & & - 0.0033303085445352071 , 0.0015425853045205717 , & & 0.0521100583113136379 , - 0.1334447768979217815 , & & - 0.1401330292364750968 , 0.2685616168804818919 , & & 0.0000000000169355950 , - 0.0000000005308092192 , & & 0.0000000135323005576 , - 0.0000002726650587978 , & & 0.0000041513240141760 , - 0.0000443353052220157 , & & 0.0002815740758993879 , - 0.0004393235121629007 , & & - 0.0067573531105799347 , 0.0369141914660130814 , & & 0.0081673361942996237 , - 0.2573381285898881860 , & & 0.0459580257102978932 / ) real , parameter :: c ( 0 : 69 ) = ( / & & - 0.00000000003009451757 , - 0.00000000014958003844 , & & 0.00000000506854544776 , 0.00000001863564222012 , & & - 0.00000060304249068078 , - 0.00000147686259937403 , & & 0.00004714331342682714 , 0.00006286305481740818 , & & - 0.00214137170594124344 , - 0.00089157336676889788 , & & 0.04508258728666024989 , - 0.00490362805828762224 , & & - 0.27312196367405374426 , 0.04193925184293450356 , & & - 0.00000000000712453560 , - 0.00000000041170814825 , & & 0.00000000138012624364 , 0.00000005704447670683 , & & - 0.00000019026363528842 , - 0.00000533925032409729 , & & 0.00001736064885538091 , 0.00030692619152608375 , & & - 0.00092598938200644367 , - 0.00917934265960017663 , & & 0.02287952522866389076 , 0.10545197546252853195 , & & - 0.16126443075752985095 , - 0.19392874768742235538 , & & 0.00000000002128344556 , - 0.00000000031053910272 , & & - 0.00000000334979293158 , 0.00000004507232895050 , & & 0.00000036437959146427 , - 0.00000446421436266678 , & & - 0.00002523429344576552 , 0.00027519882931758163 , & & 0.00097185076358599358 , - 0.00898326746345390692 , & & - 0.01665959196063987584 , 0.11456933464891967814 , & & 0.07885001422733148815 , - 0.23664819446234712621 , & & 0.00000000003035295055 , 0.00000000005486066835 , & & - 0.00000000501026824811 , - 0.00000000501246847860 , & & 0.00000058012340163034 , 0.00000016788922416169 , & & - 0.00004373270270147275 , 0.00001183898532719802 , & & 0.00189863342862291449 , - 0.00113759249561636130 , & & - 0.03846797195329871681 , 0.02389746880951420335 , & & 0.22837862066532347461 , - 0.06765394811166522844 , & & 0.00000000001279875977 , 0.00000000035925958103 , & & - 0.00000000228037105967 , - 0.00000004852770517176 , & & 0.00000028696428000189 , 0.00000440131125178642 , & & - 0.00002366617753349105 , - 0.00024412456252884129 , & & 0.00113028178539430542 , 0.00708470513919789080 , & & - 0.02526914792327618386 , - 0.08006137953480093426 , & & 0.16548380461475971846 , 0.14688405470042110229 / ) real , parameter :: d ( 0 : 51 ) = ( / & & 1.059601355592185731e-14 , - 2.71150591218550377e-13 , & & 8.6514809056201638e-12 , - 4.6264028554286627e-10 , & & 5.0815403835647104e-8 , - 1.76722552048141208e-5 , & & 0.16286750396763997378 , 2.949651820598278873e-13 , & & - 8.818215611676125741e-12 , 3.571119876162253451e-10 , & & - 2.631924120993717060e-8 , 4.709502795656698909e-6 , & & - 5.208333333333283282e-3 , 7.18344107717531977e-15 , & & - 2.51623725588410308e-13 , 8.6017784918920604e-12 , & & - 4.6256876614290359e-10 , 5.0815343220437937e-8 , & & - 1.76722551764941970e-5 , 0.16286750396763433767 , & & 2.2327570859680094777e-13 , - 8.464594853517051292e-12 , & & 3.563766464349055183e-10 , - 2.631843986737892965e-8 , & & 4.709502342288659410e-6 , - 5.2083333332278466225e-3 , & & 5.15413392842889366e-15 , - 2.27740238380640162e-13 , & & 8.4827767197609014e-12 , - 4.6224753682737618e-10 , & & 5.0814848128929134e-8 , - 1.76722547638767480e-5 , & & 0.16286750396748926663 , 1.7316195320192170887e-13 , & & - 7.971122772293919646e-12 , 3.544039469911895749e-10 , & & - 2.631443902081701081e-8 , 4.709498228695400603e-6 , & & - 5.2083333315143653610e-3 , 3.84653681453798517e-15 , & & - 2.04464520778789011e-13 , 8.3089298605177838e-12 , & & - 4.6155016158412096e-10 , 5.0813263696466650e-8 , & & - 1.76722528311426167e-5 , 0.16286750396650065930 , & & 1.3797879972460878797e-13 , - 7.448089381011684812e-12 , & & 3.512733797106959780e-10 , - 2.630500895563592722e-8 , & & 4.709483934775839193e-6 , - 5.2083333227940760113e-3 / ) w = abs ( x ) if ( w < 1 ) then t = w * w y = (((((( a ( 0 ) * t + a ( 1 )) * t + & & a ( 2 )) * t + a ( 3 )) * t + a ( 4 )) * t + & & a ( 5 )) * t + a ( 6 )) * t + a ( 7 ) else if ( w < 8.5 ) then t = w * w * 0.0625 k = int ( t ) t = t - ( k + 0.5 ) k = k * 13 y = ((((((((((( b ( k ) * t + b ( k + 1 )) * t + & & b ( k + 2 )) * t + b ( k + 3 )) * t + b ( k + 4 )) * t + & & b ( k + 5 )) * t + b ( k + 6 )) * t + b ( k + 7 )) * t + & & b ( k + 8 )) * t + b ( k + 9 )) * t + b ( k + 10 )) * t + & & b ( k + 11 )) * t + b ( k + 12 ) else if ( w < 1 2.5 ) then k = int ( w ) t = w - ( k + 0.5 ) k = 14 * ( k - 8 ) y = (((((((((((( c ( k ) * t + c ( k + 1 )) * t + & & c ( k + 2 )) * t + c ( k + 3 )) * t + c ( k + 4 )) * t + & & c ( k + 5 )) * t + c ( k + 6 )) * t + c ( k + 7 )) * t + & & c ( k + 8 )) * t + c ( k + 9 )) * t + c ( k + 10 )) * t + & & c ( k + 11 )) * t + c ( k + 12 )) * t + c ( k + 13 ) else v = 2 4. / w t = v * v k = 13 * ( int ( t )) y = (((((( d ( k ) * t + d ( k + 1 )) * t + & & d ( k + 2 )) * t + d ( k + 3 )) * t + d ( k + 4 )) * t + & & d ( k + 5 )) * t + d ( k + 6 )) * sqrt ( v ) theta = ((((( d ( k + 7 ) * t + d ( k + 8 )) * t + & & d ( k + 9 )) * t + d ( k + 10 )) * t + d ( k + 11 )) * t + & & d ( k + 12 )) * v - . 25 * pi y = y * cos ( w + theta ) end if j0 = y end function j0 elemental function j1 ( x ) ! Bessel J_1(x) function devided by x in double precision use constants , only : pi real :: j1 real , intent ( in ) :: x integer :: k real :: w , t , y , theta , v real , parameter :: a ( 0 : 7 ) = ( / & & - 0.00000000000014810349 , 0.00000000003363594618 , & & - 0.00000000565140051697 , 0.00000067816840144764 , & & - 0.00005425347222188379 , 0.00260416666666662438 , & & - 0.06249999999999999799 , 0.49999999999999999998 / ) real , parameter :: b ( 0 : 64 ) = ( / & & 0.00000000000243721316 , - 0.00000000009400554763 , & & 0.00000000306053389980 , - 0.00000008287270492518 , & & 0.00000183020515991344 , - 0.00003219783841164382 , & & 0.00043795830161515318 , - 0.00442952351530868999 , & & 0.03157908273375945955 , - 0.14682160488052520107 , & & 0.39309619054093640008 , - 0.47952808215101070280 , & & 0.14148999344027125140 , 0.00000000000182119257 , & & - 0.00000000006862117678 , 0.00000000217327908360 , & & - 0.00000005693592917820 , 0.00000120771046483277 , & & - 0.00002020151799736374 , 0.00025745933218048448 , & & - 0.00238514907946126334 , 0.01499220060892984289 , & & - 0.05707238494868888345 , 0.10375225210588234727 , & & - 0.02721551202427354117 , - 0.06420643306727498985 , & & 0.000000000001352611196 , - 0.000000000049706947875 , & & 0.000000001527944986332 , - 0.000000038602878823401 , & & 0.000000782618036237845 , - 0.000012349994748451100 , & & 0.000145508295194426686 , - 0.001203649737425854162 , & & 0.006299092495799005109 , - 0.016449840761170764763 , & & 0.002106328565019748701 , 0.058527410006860734650 , & & - 0.031896615709705053191 , 0.000000000000997982124 , & & - 0.000000000035702556073 , 0.000000001062332772617 , & & - 0.000000025779624221725 , 0.000000496382962683556 , & & - 0.000007310776625173004 , 0.000078028107569541842 , & & - 0.000550624088538081113 , 0.002081442840335570371 , & & - 0.000771292652260286633 , - 0.019541271866742634199 , & & 0.033361194224480445382 , 0.017516628654559387164 , & & 0.000000000000731050661 , - 0.000000000025404499912 , & & 0.000000000729360079088 , - 0.000000016915375004937 , & & 0.000000306748319652546 , - 0.000004151324014331739 , & & 0.000038793392054271497 , - 0.000211180556924525773 , & & 0.000274577195102593786 , 0.003378676555289966782 , & & - 0.013842821799754920148 , - 0.002041834048574905921 , & & 0.032167266073736023299 / ) real , parameter :: c ( 0 : 69 ) = ( / & & - 0.00000000001185964494 , 0.00000000039110295657 , & & 0.00000000180385519493 , - 0.00000005575391345723 , & & - 0.00000018635897017174 , 0.00000542738239401869 , & & 0.00001181490114244279 , - 0.00033000319398521070 , & & - 0.00037717832892725053 , 0.01070685852970608288 , & & 0.00356629346707622489 , - 0.13524776185998074716 , & & 0.00980725611657523952 , 0.27312196367405374425 , & & - 0.00000000003029591097 , 0.00000000009259293559 , & & 0.00000000496321971223 , - 0.00000001518137078639 , & & - 0.00000057045127595547 , 0.00000171237271302072 , & & 0.00004271400348035384 , - 0.00012152454198713258 , & & - 0.00184155714921474963 , 0.00462994691003219055 , & & 0.03671737063840232452 , - 0.06863857568599167175 , & & - 0.21090395092505707655 , 0.16126443075752985095 , & & - 0.00000000002197602080 , - 0.00000000027659100729 , & & 0.00000000374295124827 , 0.00000003684765777023 , & & - 0.00000045072801091574 , - 0.00000327941630669276 , & & 0.00003571371554516300 , 0.00017664005411843533 , & & - 0.00165119297594774104 , - 0.00485925381792986774 , & & 0.03593306985381680131 , 0.04997877588191962563 , & & - 0.22913866929783936544 , - 0.07885001422733148814 , & & 0.00000000000516292316 , - 0.00000000039445956763 , & & - 0.00000000066220021263 , 0.00000005511286218639 , & & 0.00000005012579400780 , - 0.00000522111059203425 , & & - 0.00000134311394455105 , 0.00030612891890766805 , & & - 0.00007103391195326182 , - 0.00949316714311443491 , & & 0.00455036998246516948 , 0.11540391585989614784 , & & - 0.04779493761902840455 , - 0.22837862066532347460 , & & 0.00000000002697817493 , - 0.00000000016633326949 , & & - 0.00000000433134860350 , 0.00000002508404686362 , & & 0.00000048528284780984 , - 0.00000258267851112118 , & & - 0.00003521049080466759 , 0.00016566324273339952 , & & 0.00146474737522491617 , - 0.00565140892697147306 , & & - 0.02833882055679300400 , 0.07580744376982855057 , & & 0.16012275906960187978 , - 0.16548380461475971845 / ) real , parameter :: d ( 0 : 51 ) = ( / & & - 1.272346002224188092e-14 , 3.370464692346669075e-13 , & & - 1.144940314335484869e-11 , 6.863141561083429745e-10 , & & - 9.491933932960924159e-8 , 5.301676561445687562e-5 , & & 0.1628675039676399740 , - 3.652982212914147794e-13 , & & 1.151126750560028914e-11 , - 5.165585095674343486e-10 , & & 4.657991250060549892e-8 , - 1.186794704692706504e-5 , & & 1.562499999999994026e-2 , - 8.713069680903981555e-15 , & & 3.140780373478474935e-13 , - 1.139089186076256597e-11 , & & 6.862299023338785566e-10 , - 9.491926788274594674e-8 , & & 5.301676558106268323e-5 , 0.1628675039676466220 , & & - 2.792555727162752006e-13 , 1.108650207651756807e-11 , & & - 5.156745588549830981e-10 , 4.657894859077370979e-8 , & & - 1.186794650130550256e-5 , 1.562499999987299901e-2 , & & - 6.304859171204770696e-15 , 2.857249044208791652e-13 , & & - 1.124956921556753188e-11 , 6.858482894906716661e-10 , & & - 9.491867953516898460e-8 , 5.301676509057781574e-5 , & & 0.1628675039678191167 , - 2.185193490132496053e-13 , & & 1.048820673697426074e-11 , - 5.132819367467680132e-10 , & & 4.657409437372994220e-8 , - 1.186794150862988921e-5 , & & 1.562499999779270706e-2 , - 4.740417209792009850e-15 , & & 2.578715253644144182e-13 , - 1.104148898414138857e-11 , & & 6.850134201626289183e-10 , - 9.491678234174919640e-8 , & & 5.301676277588728159e-5 , 0.1628675039690033136 , & & - 1.755122057493842290e-13 , 9.848723331445182397e-12 , & & - 5.094535425482245697e-10 , 4.656255982268609304e-8 , & & - 1.186792402114394891e-5 , 1.562499998712198636e-2 / ) w = abs ( x ) if ( w < 1 ) then t = w * w !       y = (((((((a(0) * t + a(1)) * t + & !            & a(2)) * t + a(3)) * t + a(4)) * t + & !            & a(5)) * t + a(6)) * t + a(7)) * w y = (((((( a ( 0 ) * t + a ( 1 )) * t + & & a ( 2 )) * t + a ( 3 )) * t + a ( 4 )) * t + & & a ( 5 )) * t + a ( 6 )) * t + a ( 7 ) else if ( w < 8.5 ) then t = w * w * 0.0625 k = int ( t ) t = t - ( k + 0.5 ) k = k * 13 !       y = ((((((((((((b(k) * t + b(k + 1)) * t + & !            & b(k + 2)) * t + b(k + 3)) * t + b(k + 4)) * t + & !            & b(k + 5)) * t + b(k + 6)) * t + b(k + 7)) * t + & !            & b(k + 8)) * t + b(k + 9)) * t + b(k + 10)) * t + & !            & b(k + 11)) * t + b(k + 12)) * w y = ((((((((((( b ( k ) * t + b ( k + 1 )) * t + & & b ( k + 2 )) * t + b ( k + 3 )) * t + b ( k + 4 )) * t + & & b ( k + 5 )) * t + b ( k + 6 )) * t + b ( k + 7 )) * t + & & b ( k + 8 )) * t + b ( k + 9 )) * t + b ( k + 10 )) * t + & & b ( k + 11 )) * t + b ( k + 12 ) else if ( w < 1 2.5 ) then k = int ( w ) t = w - ( k + 0.5 ) k = 14 * ( k - 8 ) !       y = ((((((((((((c(k) * t + c(k + 1)) * t + & !            & c(k + 2)) * t + c(k + 3)) * t + c(k + 4)) * t + & !            & c(k + 5)) * t + c(k + 6)) * t + c(k + 7)) * t + & !            & c(k + 8)) * t + c(k + 9)) * t + c(k + 10)) * t + & !            & c(k + 11)) * t + c(k + 12)) * t + c(k + 13) y = ((((((((((((( c ( k ) * t + c ( k + 1 )) * t + & & c ( k + 2 )) * t + c ( k + 3 )) * t + c ( k + 4 )) * t + & & c ( k + 5 )) * t + c ( k + 6 )) * t + c ( k + 7 )) * t + & & c ( k + 8 )) * t + c ( k + 9 )) * t + c ( k + 10 )) * t + & & c ( k + 11 )) * t + c ( k + 12 )) * t + c ( k + 13 )) / w else v = 2 4. / w t = v * v k = 13 * ( int ( t )) y = (((((( d ( k ) * t + d ( k + 1 )) * t + & & d ( k + 2 )) * t + d ( k + 3 )) * t + d ( k + 4 )) * t + & & d ( k + 5 )) * t + d ( k + 6 )) * sqrt ( v ) theta = ((((( d ( k + 7 ) * t + d ( k + 8 )) * t + & & d ( k + 9 )) * t + d ( k + 10 )) * t + d ( k + 11 )) * t + & & d ( k + 12 )) * v - . 25 * pi y = y * sin ( w + theta ) ! y = y / w end if !    if (x < 0) y = -y j1 = y end function j1 !-------------------------------------------------------------------------! ! double precision error functions (derf.f)                               ! ! http://www.kurims.kyoto-u.ac.jp/~ooura/gamerf.html                      ! !-------------------------------------------------------------------------! ! Copyright(C) 1996 Takuya OOURA (email: ooura@mmm.t.u-tokyo.ac.jp).      ! ! You may use, copy, modify this code for any purpose and                 ! ! without fee. You may distribute this ORIGINAL package.                  ! !-------------------------------------------------------------------------! ! Modified by Ryusuke NUMATA 2008/06/27                                   ! !  to fit F90 format                                                      ! !-------------------------------------------------------------------------! ! these routines are declared as real, but can be promoted to ! double presicion using compiler option. ! this is so because constatns used are only double precision, ! and cannot be promoted to quad-precision. ! differences from GNU gfortran besj0 and besj1 are ! |err| < 1.e-15 !!$  elemental function erf(x) !!$! A&S, p.299 7.1.28 |epsilon|<=3.e-7 !!$    implicit none !!$    real, intent(in) :: x !!$    real :: xerf !!$    real, parameter, dimension(6) :: a = (/ & !!$         0.0705230784, 0.0422820123, 0.0092705272, & !!$         0.0001520143, 0.0002765672, 0.0000430638 /) !!$ !!$    erf = 1.0 - 1.0/(1.0 + & !!$         x*(a(1) + x*(a(2) + x*(a(3) + x*(a(4) + x*(a(5) + x*(a(6))))))))**16 !!$ !!$  end function erf elemental function erf_ext ( x ) ! error function in double precision real :: erf_ext real , intent ( in ) :: x integer :: k real :: w , t , y real , parameter :: a ( 0 : 64 ) = ( / & & 0.00000000005958930743 , - 0.00000000113739022964 , & & 0.00000001466005199839 , - 0.00000016350354461960 , & & 0.00000164610044809620 , - 0.00001492559551950604 , & & 0.00012055331122299265 , - 0.00085483269811296660 , & & 0.00522397762482322257 , - 0.02686617064507733420 , & & 0.11283791670954881569 , - 0.37612638903183748117 , & & 1.12837916709551257377 , 0.00000000002372510631 , & & - 0.00000000045493253732 , 0.00000000590362766598 , & & - 0.00000006642090827576 , 0.00000067595634268133 , & & - 0.00000621188515924000 , 0.00005103883009709690 , & & - 0.00037015410692956173 , 0.00233307631218880978 , & & - 0.01254988477182192210 , 0.05657061146827041994 , & & - 0.21379664776456006580 , 0.84270079294971486929 , & & 0.00000000000949905026 , - 0.00000000018310229805 , & & 0.00000000239463074000 , - 0.00000002721444369609 , & & 0.00000028045522331686 , - 0.00000261830022482897 , & & 0.00002195455056768781 , - 0.00016358986921372656 , & & 0.00107052153564110318 , - 0.00608284718113590151 , & & 0.02986978465246258244 , - 0.13055593046562267625 , & & 0.67493323603965504676 , 0.00000000000382722073 , & & - 0.00000000007421598602 , 0.00000000097930574080 , & & - 0.00000001126008898854 , 0.00000011775134830784 , & & - 0.00000111992758382650 , 0.00000962023443095201 , & & - 0.00007404402135070773 , 0.00050689993654144881 , & & - 0.00307553051439272889 , 0.01668977892553165586 , & & - 0.08548534594781312114 , 0.56909076642393639985 , & & 0.00000000000155296588 , - 0.00000000003032205868 , & & 0.00000000040424830707 , - 0.00000000471135111493 , & & 0.00000005011915876293 , - 0.00000048722516178974 , & & 0.00000430683284629395 , - 0.00003445026145385764 , & & 0.00024879276133931664 , - 0.00162940941748079288 , & & 0.00988786373932350462 , - 0.05962426839442303805 , & & 0.49766113250947636708 / ) real , parameter :: b ( 0 : 64 ) = ( / & & - 0.00000000029734388465 , 0.00000000269776334046 , & & - 0.00000000640788827665 , - 0.00000001667820132100 , & & - 0.00000021854388148686 , 0.00000266246030457984 , & & 0.00001612722157047886 , - 0.00025616361025506629 , & & 0.00015380842432375365 , 0.00815533022524927908 , & & - 0.01402283663896319337 , - 0.19746892495383021487 , & & 0.71511720328842845913 , - 0.00000000001951073787 , & & - 0.00000000032302692214 , 0.00000000522461866919 , & & 0.00000000342940918551 , - 0.00000035772874310272 , & & 0.00000019999935792654 , 0.00002687044575042908 , & & - 0.00011843240273775776 , - 0.00080991728956032271 , & & 0.00661062970502241174 , 0.00909530922354827295 , & & - 0.20160072778491013140 , 0.51169696718727644908 , & & 0.00000000003147682272 , - 0.00000000048465972408 , & & 0.00000000063675740242 , 0.00000003377623323271 , & & - 0.00000015451139637086 , - 0.00000203340624738438 , & & 0.00001947204525295057 , 0.00002854147231653228 , & & - 0.00101565063152200272 , 0.00271187003520095655 , & & 0.02328095035422810727 , - 0.16725021123116877197 , & & 0.32490054966649436974 , 0.00000000002319363370 , & & - 0.00000000006303206648 , - 0.00000000264888267434 , & & 0.00000002050708040581 , 0.00000011371857327578 , & & - 0.00000211211337219663 , 0.00000368797328322935 , & & 0.00009823686253424796 , - 0.00065860243990455368 , & & - 0.00075285814895230877 , 0.02585434424202960464 , & & - 0.11637092784486193258 , 0.18267336775296612024 , & & - 0.00000000000367789363 , 0.00000000020876046746 , & & - 0.00000000193319027226 , - 0.00000000435953392472 , & & 0.00000018006992266137 , - 0.00000078441223763969 , & & - 0.00000675407647949153 , 0.00008428418334440096 , & & - 0.00017604388937031815 , - 0.00239729611435071610 , & & 0.02064129023876022970 , - 0.06905562880005864105 , & & 0.09084526782065478489 / ) w = abs ( x ) if ( w < 2.2 ) then t = w * w k = int ( t ) t = t - k k = k * 13 y = (((((((((((( a ( k ) * t + a ( k + 1 )) * t + & & a ( k + 2 )) * t + a ( k + 3 )) * t + a ( k + 4 )) * t + & & a ( k + 5 )) * t + a ( k + 6 )) * t + a ( k + 7 )) * t + & & a ( k + 8 )) * t + a ( k + 9 )) * t + a ( k + 10 )) * t + & & a ( k + 11 )) * t + a ( k + 12 )) * w else if ( w < 6.9 ) then k = int ( w ) t = w - k k = 13 * ( k - 2 ) y = ((((((((((( b ( k ) * t + b ( k + 1 )) * t + & & b ( k + 2 )) * t + b ( k + 3 )) * t + b ( k + 4 )) * t + & & b ( k + 5 )) * t + b ( k + 6 )) * t + b ( k + 7 )) * t + & & b ( k + 8 )) * t + b ( k + 9 )) * t + b ( k + 10 )) * t + & & b ( k + 11 )) * t + b ( k + 12 ) y = y * y y = y * y y = y * y y = 1. - y * y else y = 1. end if if ( x < 0. ) y = - y erf_ext = y end function erf_ext !-------------------------------------------------------------------------! # elif SPFUNC == _SPNAG_ /* if SPFUNC != _SPLOCAL_ */ function j0 ( x ) real :: j0 real , intent ( in ) :: x # if NAG_PREC == _NAGDBLE_ real ( kind = nag_kind ), external :: s17aef ! bessel J0 double # elif NAG_PREC == _NAGSNGL_ real ( kind = nag_kind ), external :: s17aee ! bessel J0 single # endif /* NAG_PREC */ real ( kind = nag_kind ) :: xarg xarg = x # if NAG_PREC == _NAGDBLE_ j0 = s17aef ( xarg , ifail ) # elif NAG_PREC == _NAGSNGL_ j0 = s17aee ( xarg , ifail ) # endif /* NAG_PREC */ end function j0 function j1 ( x ) real :: j1 real , intent ( in ) :: x # if NAG_PREC == _NAGDBLE_ real ( kind = nag_kind ), external :: s17aff ! bessel J1 double # elif NAG_PREC == _NAGSNGL_ real ( kind = nag_kind ), external :: s17afe ! bessel J1 single # endif /* NAG_PREC */ real ( kind = nag_kind ) :: xarg xarg = x # if NAG_PREC == _NAGDBLE_ j1 = s17aff ( xarg , ifail ) # elif NAG_PREC == _NAGSNGL_ j1 = s17afe ( xarg , ifail ) # endif /* NAG_PREC */ if ( x == 0. ) then j1 = . 5 else j1 = j1 / x end if end function j1 function erf_ext ( x ) real :: erf_ext real , intent ( in ) :: x # if NAG_PREC == _NAGDBLE_ real ( kind = nag_kind ), external :: s15aef ! error function double # elif NAG_PREC == _NAGSNGL_ real ( kind = nag_kind ), external :: s15aee ! error function single # endif /* NAG_PREC */ real ( kind = nag_kind ) :: xarg xarg = x # if NAG_PREC == _NAGDBLE_ erf_ext = s15aef ( xarg , ifail ) # elif NAG_PREC == _NAGSNGL_ erf_ext = s15aee ( xarg , ifail ) # endif /* NAG_PREC */ end function erf_ext # else /* if SPFUNC != _SPLOCAL_ && SPFUNC != _SPNAG_*/ # if (FCOMPILER == _G95_ || FCOMPILER == _GFORTRAN_ \\ || FCOMPILER == _ PATHSCALE_ || FCOMPILER == _ INTEL_ ) # if FCOMPILER == _INTEL_ function sj0 ( x ) use ifport , only : besj0 # else elemental function sj0 ( x ) # endif real ( kind = kind_rs ), intent ( in ) :: x real ( kind = kind_rs ) :: sj0 sj0 = besj0 ( x ) end function sj0 # if FCOMPILER == _INTEL_ function dj0 ( x ) use ifport , only : dbesj0 # else elemental function dj0 ( x ) # endif real ( kind = kind_rd ), intent ( in ) :: x real ( kind = kind_rd ) :: dj0 dj0 = dbesj0 ( x ) end function dj0 # if FCOMPILER == _INTEL_ function sj1 ( x ) use ifport , only : besj1 # else elemental function sj1 ( x ) # endif real ( kind = kind_rs ), intent ( in ) :: x real ( kind = kind_rs ) :: sj1 if ( x == 0.0 ) then sj1 = 0.5 else sj1 = besj1 ( x ) / x end if end function sj1 # if FCOMPILER == _INTEL_ function dj1 ( x ) use ifport , only : dbesj1 # else elemental function dj1 ( x ) # endif real ( kind = kind_rd ), intent ( in ) :: x real ( kind = kind_rd ) :: dj1 if ( x == 0.0 ) then dj1 = 0.5 else dj1 = dbesj1 ( x ) / x end if end function dj1 # if FCOMPILER == _G95_ function erf_ext ( x ) real , intent ( in ) :: x real :: erf_ext erf_ext = erf ( x ) end function erf_ext # else /* if FCOMPILER != _G95_ */ # if FCOMPILER == _INTEL_ function serf_ext ( x ) # else elemental function serf_ext ( x ) # endif /* if FCOMPILER == _INTEL_ */ real ( kind = kind_rs ), intent ( in ) :: x real ( kind = kind_rs ) :: serf_ext serf_ext = erf ( x ) end function serf_ext # if FCOMPILER == _INTEL_ function derf_ext ( x ) # else elemental function derf_ext ( x ) # endif real ( kind = kind_rd ), intent ( in ) :: x real ( kind = kind_rd ) :: derf_ext derf_ext = derf ( x ) end function derf_ext # endif /* if FCOMPILER == _G95_ */ # elif FCOMPILER == _PGI_ /* if (FCOMPILER != one of _G95_, _GFORTRAN_, _INTEL_, _PATHSCALE_) */ elemental function j1 ( x ) real , intent ( in ) :: x real :: j1 interface besj1 elemental function besj1 ( x ) real ( kind = 4 ), intent ( in ) :: x real ( kind = 4 ) :: besj1 end function besj1 elemental function dbesj1 ( x ) real ( kind = 8 ), intent ( in ) :: x real ( kind = 8 ) :: dbesj1 end function dbesj1 end interface if ( x == 0.0 ) then j1 = 0.5 else j1 = besj1 ( x ) / x end if end function j1 # endif /* if FCOMPILER */ # endif /* if SPFUNC */ end module spfunc","tags":"","loc":"sourcefile/spfunc.fpp.html"},{"title":"fft_work.f90 – stella","text":"Source Code module fft_work use constants , only : kind_id implicit none include \"fftw3.f\" public :: fft_type , delete_fft public :: init_ccfftw , init_crfftw , init_rcfftw public :: FFT_BACKWARD , FFT_FORWARD private integer , parameter :: FFT_BACKWARD = FFTW_BACKWARD integer , parameter :: FFT_FORWARD = FFTW_FORWARD type :: fft_type integer :: n , is , type integer ( kind_id ) :: plan real :: scale end type fft_type contains subroutine init_ccfftw ( fft , is , n , data_in , data_out ) use mp , only : mp_abort type ( fft_type ), intent ( out ) :: fft integer , intent ( in ) :: is , n complex , dimension (:), intent ( inout ) :: data_in , data_out integer :: j fft % n = n fft % is = is fft % scale = 1. / real ( n ) if ( is > 0 ) fft % scale = 1. fft % type = 1 j = FFTW_PATIENT call dfftw_plan_dft_1d ( fft % plan , n , data_in , data_out , is , j ) end subroutine init_ccfftw subroutine init_crfftw ( fft , is , n , data_in , data_out ) use mp , only : mp_abort type ( fft_type ), intent ( out ) :: fft integer , intent ( in ) :: is , n complex , dimension (:), intent ( in out ) :: data_in real , dimension (:), intent ( in out ) :: data_out integer :: j fft % n = n fft % is = is fft % scale = 1. / real ( n ) if ( is > 0 ) fft % scale = 1. fft % type = 1 j = FFTW_PATIENT call dfftw_plan_dft_c2r_1d ( fft % plan , n , data_in , data_out , j ) end subroutine init_crfftw subroutine init_rcfftw ( fft , is , n , data_in , data_out ) use mp , only : mp_abort type ( fft_type ), intent ( out ) :: fft integer , intent ( in ) :: is , n real , dimension (:), intent ( in out ) :: data_in complex , dimension (:), intent ( in out ) :: data_out integer :: j fft % n = n fft % is = is fft % scale = 1. / real ( n ) if ( is > 0 ) fft % scale = 1. fft % type = 1 j = FFTW_PATIENT call dfftw_plan_dft_r2c_1d ( fft % plan , n , data_in , data_out , j ) end subroutine init_rcfftw subroutine delete_fft ( fft ) type ( fft_type ), intent ( in out ) :: fft call dfftw_destroy_plan ( fft % plan ) end subroutine delete_fft end module fft_work","tags":"","loc":"sourcefile/fft_work.f90.html"},{"title":"extended_zgrid.f90 – stella","text":"Source Code module extended_zgrid implicit none public :: nsegments public :: neigen public :: ikxmod public :: iz_low , iz_mid , iz_up public :: it_right public :: periodic public :: phase_shift public :: nzed_segment public :: fill_zed_ghost_zones , fill_zext_ghost_zones public :: init_extended_zgrid , finish_extended_zgrid public :: map_to_extended_zgrid public :: map_from_extended_zgrid public :: map_to_iz_ikx_from_izext private !> these arrays needed to keep track of connections between different !> 2pi segments integer :: nzed_segment integer , dimension (:), allocatable :: neigen integer , dimension (:), allocatable :: iz_low , iz_mid , iz_up integer , dimension (:, :), allocatable :: nsegments integer , dimension (:, :, :), allocatable :: ikxmod !> arrays indicate which flux tube index to connect to !> on the left and on the right !> as a function of current flux tube index !> pre-compute to avoid conditionals in loops integer , dimension (:), allocatable :: it_left , it_right complex , dimension (:), allocatable :: phase_shift logical , dimension (:), allocatable :: periodic logical :: extended_zgrid_initialized = . false . contains subroutine init_extended_zgrid use zgrid , only : boundary_option_switch use zgrid , only : boundary_option_self_periodic use zgrid , only : boundary_option_linked use zgrid , only : boundary_option_linked_stellarator use zgrid , only : nperiod , nzgrid , nzed , ntubes use kt_grids , only : nakx , naky use kt_grids , only : jtwist , ikx_twist_shift , phase_shift_angle use kt_grids , only : aky , ikx_max use constants , only : zi implicit none integer :: iseg , iky , ie , ikx , it integer :: nseg_max , neigen_max integer , dimension (:), allocatable :: ikx_shift_end integer , dimension (:, :), allocatable :: ikx_shift if ( extended_zgrid_initialized ) return extended_zgrid_initialized = . true . if (. not . allocated ( neigen )) allocate ( neigen ( naky )) if (. not . allocated ( periodic )) allocate ( periodic ( naky )); periodic = . false . if (. not . allocated ( phase_shift )) allocate ( phase_shift ( naky )) if ( boundary_option_switch == boundary_option_self_periodic ) then periodic = . true . else where ( abs ( aky ) < epsilon ( 0.0 )) periodic = . true . end if !> phase shift due to the twist-and-shift boundary condition !> Usually set to zero for standard local simulation, but can !> have an effect for global simulations and simulations with low !> magnetic shear that use periodic boundary conditions everywhere phase_shift = exp ( zi * aky * phase_shift_angle ) if ( boundary_option_switch == boundary_option_linked . or . boundary_option_switch == boundary_option_linked_stellarator ) then !> all periodic modes (e.g., the zonal mode) have no connections do iky = 1 , naky if ( periodic ( iky )) then neigen ( iky ) = nakx else neigen ( iky ) = min (( iky - 1 ) * jtwist , nakx ) end if end do neigen_max = maxval ( neigen ) if (. not . allocated ( ikx_shift_end )) then allocate ( ikx_shift_end ( neigen_max )); ikx_shift_end = 0 allocate ( ikx_shift ( nakx , naky )); ikx_shift = 0 end if !> phi(kx-kx_shift,-nzgrid) = phi(kx,nzgrid) from twist-and-shift BC !> for positive (negative) magnetic shear, kx_shift is positive (negative), !> so start at most positive (negative) kx and !> progress to smaller (larger) kx values as connections occur !> figure out how much to shift ikx by to get to the end of the kx chain !> for positive (negative) magnetic shear, this is the left-most (right-most) theta-theta0 !> in each set of connected 2pi segments !> note that theta0 goes from 0 to theta0_max and then from theta0_min back !> to -dtheta0 do ikx = 1 , neigen_max !> first ikx_max=nakx/2+1 theta0s are 0 and all positive theta0 values !> remainder are negative theta0s !> theta_0 = kx / ky / shat !> if ky > 0, then most positive theta_0 corresponds to most positive kx !> first consider case where shift in kx is negative (corresponds to positive magnetic shear) if ( ikx_twist_shift < 0 ) then if ( ikx <= ikx_max ) then ikx_shift_end ( ikx ) = ikx_max - 2 * ikx + 1 else ikx_shift_end ( ikx ) = 3 * ikx_max - 2 * ikx end if !> then consider case where shift in kx is positive else if ( ikx_twist_shift > 0 ) then if ( ikx < ikx_max ) then if ( ikx + ikx_max <= nakx ) then ikx_shift_end ( ikx ) = ikx_max else ikx_shift_end ( ikx ) = ikx - nakx end if else ikx_shift_end ( ikx ) = 1 - ikx_max end if end if !> note that zero shift case is taken care of by initialization of ikx_shift_end end do do iky = 1 , naky !> ikx_shift is how much to shift each ikx by to connect !> to the next theta0 (from most positive to most negative for positive magnetic shear !> and vice versa for negative magnetic shear) !> first consider shift in index for case where shift is negative !> (corresponds to positive magnetic shear) if ( ikx_twist_shift < 0 ) then !> if ky > 0, then going to more negative theta0 !> corresponds to going to more negative kx do ikx = 1 , ikx_max !> if theta0 is sufficiently positive, shifting to more !> negative theta0 corresponds to decreasing ikx if ( ikx - neigen ( iky ) > 0 ) then ikx_shift ( ikx , iky ) = - neigen ( iky ) !> if a positive theta0 connects to a negative theta0 !> must do more complicated mapping of ikx else if ( ikx - neigen ( iky ) + nakx >= ikx_max + 1 ) then ikx_shift ( ikx , iky ) = nakx - neigen ( iky ) end if end do !> if theta0 is negative, then shifting to more negative !> theta0 corresponds to decreasing ikx do ikx = ikx_max + 1 , nakx !> if theta0 is sufficiently negative, it has no !> more negative theta0 with which it can connect if ( ikx - neigen ( iky ) > ikx_max ) then ikx_shift ( ikx , iky ) = - neigen ( iky ) end if !> theta0 is positive end do else if ( ikx_twist_shift > 0 ) then !> if ky > 0, then going to more positive theta0 !> corresponds to going to more positive kx do ikx = 1 , ikx_max !> if shift in kx, kx_shift, is less than kx-kx_max, !> then shift by the appropriate amount if ( ikx + neigen ( iky ) <= ikx_max ) then ikx_shift ( ikx , iky ) = neigen ( iky ) end if !> otherwise, no kx on grid to connect with end do do ikx = ikx_max + 1 , nakx !> if kx+kx_shift < 0, then simple shift by neigen if ( ikx + neigen ( iky ) <= nakx ) then ikx_shift ( ikx , iky ) = neigen ( iky ) !> if 0 < kx+kx_shift <= kx_max, then more complicated shift !> to positive set of kx values else if ( ikx - ikx_max + neigen ( iky ) <= nakx ) then ikx_shift ( ikx , iky ) = neigen ( iky ) - nakx end if !> otherwise, no kx on grid with which to connect end do end if end do if (. not . allocated ( nsegments )) allocate ( nsegments ( neigen_max , naky )) do iky = 1 , naky if ( neigen ( iky ) == 0 ) then nsegments (:, iky ) = 1 else nsegments (:, iky ) = ( nakx - 1 ) / neigen ( iky ) do ie = 1 , mod ( nakx - 1 , neigen ( iky )) + 1 nsegments ( ie , iky ) = nsegments ( ie , iky ) + 1 end do end if end do nseg_max = maxval ( nsegments ) if (. not . allocated ( iz_low )) then allocate ( iz_low ( nseg_max )); iz_low = - nzgrid allocate ( iz_mid ( nseg_max )); iz_mid = 0 allocate ( iz_up ( nseg_max )); iz_up = nzgrid end if else neigen = nakx ; neigen_max = nakx if (. not . allocated ( ikx_shift_end )) then allocate ( ikx_shift_end ( neigen_max )) allocate ( ikx_shift ( nakx , naky )) end if ikx_shift = 0 ; ikx_shift_end = 0 if (. not . allocated ( nsegments )) then allocate ( nsegments ( neigen_max , naky )) end if !> this is the number of 2pi poloidal segments in the extended theta domain, !> which is needed in initializing the reponse matrix and doing the implicit sweep nsegments = 2 * ( nperiod - 1 ) + 1 nseg_max = maxval ( nsegments ) if (. not . allocated ( iz_low )) then allocate ( iz_low ( nseg_max )) allocate ( iz_mid ( nseg_max )) allocate ( iz_up ( nseg_max )) end if !> iz_low(j) is the ig index corresponding to the inboard midplane from below (theta=-pi) within the jth segment !> iz_mid(j) is the ig index corresponding to the outboard midplane (theta=0) within the jth segment do iseg = 1 , nseg_max iz_low ( iseg ) = - nzgrid + ( iseg - 1 ) * nzed iz_mid ( iseg ) = iz_low ( iseg ) + nzed / 2 iz_up ( iseg ) = iz_low ( iseg ) + nzed end do end if if (. not . allocated ( ikxmod )) then allocate ( ikxmod ( nseg_max , neigen_max , naky )) !> initialize ikxmod to nakx !> should not be necessary but just in case one tries to access !> a value beyond nsegments(ie,iky) ikxmod = nakx end if do iky = 1 , naky !> only do the following once for each independent set of theta0s !> the assumption here is that all kx are on processor and sequential do ie = 1 , neigen ( iky ) !> remap to start at theta0 = theta0_max (theta0_min) for negative (positive) kx shift !> for this set of connected theta0s iseg = 1 ikxmod ( iseg , ie , iky ) = ie + ikx_shift_end ( ie ) if ( nsegments ( ie , iky ) > 1 ) then do iseg = 2 , nsegments ( ie , iky ) ikxmod ( iseg , ie , iky ) = ikxmod ( iseg - 1 , ie , iky ) + ikx_shift ( ikxmod ( iseg - 1 , ie , iky ), iky ) end do end if end do end do if ( allocated ( ikx_shift_end )) deallocate ( ikx_shift_end ) if ( allocated ( ikx_shift )) deallocate ( ikx_shift ) if (. not . allocated ( it_left )) allocate ( it_left ( ntubes )) if (. not . allocated ( it_right )) allocate ( it_right ( ntubes )) it_right ( ntubes ) = 1 if ( ntubes > 1 ) then do it = 1 , ntubes - 1 it_right ( it ) = it + 1 end do end if it_left ( 1 ) = ntubes if ( ntubes > 1 ) then do it = 2 , ntubes it_left ( it ) = it - 1 end do end if !> this is the number of unique zed values in all segments but the first !> the first has one extra unique zed value (all others have one grid common !> with the previous segment due to periodicity) nzed_segment = iz_up ( 1 ) - iz_low ( 1 ) end subroutine init_extended_zgrid subroutine fill_zed_ghost_zones ( it , iseg , ie , iky , g , gleft , gright ) use zgrid , only : nzgrid implicit none integer , intent ( in ) :: it , iseg , ie , iky complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: g complex , dimension (:), intent ( out ) :: gleft , gright integer :: nseg ! stream_sign > 0 --> stream speed < 0 nseg = nsegments ( ie , iky ) if ( iseg == 1 ) then if ( periodic ( iky )) then gleft = phase_shift ( iky ) * g ( iky , ikxmod ( iseg , ie , iky ), iz_up ( nseg ) - 2 : iz_up ( nseg ) - 1 , it ) else gleft = 0.0 end if else gleft = phase_shift ( iky ) * g ( iky , ikxmod ( iseg - 1 , ie , iky ), iz_up ( iseg - 1 ) - 2 : iz_up ( iseg - 1 ) - 1 , it_left ( it )) end if if ( nseg > iseg ) then ! connect to segment with larger theta-theta0 (on right) gright = g ( iky , ikxmod ( iseg + 1 , ie , iky ), iz_low ( iseg + 1 ) + 1 : iz_low ( iseg + 1 ) + 2 , it_right ( it )) / phase_shift ( iky ) else ! apply periodic BC where necessary and zero BC otherwise if ( periodic ( iky )) then gright = g ( iky , ikxmod ( iseg , ie , iky ), iz_low ( 1 ) + 1 : iz_low ( 1 ) + 2 , it ) / phase_shift ( iky ) else gright = 0.0 end if end if end subroutine fill_zed_ghost_zones subroutine fill_zext_ghost_zones ( iky , pdf_ext , pdf_left , pdf_right ) implicit none integer , intent ( in ) :: iky complex , dimension (:), intent ( in ) :: pdf_ext complex , intent ( out ) :: pdf_left , pdf_right integer :: nz_ext ! n_zext is the number of grid points in this extended zed domain nz_ext = size ( pdf_ext ) ! if periodic BCs are applied in zed, then ghost zones at ends of extended domain ! should be filled using periodicity (with any appropriate phase shift) ! otherwise, zero incoming BC is used if ( periodic ( iky )) then pdf_left = pdf_ext ( nz_ext - 1 ) * phase_shift ( iky ) pdf_right = pdf_ext ( 2 ) / phase_shift ( iky ) else pdf_left = 0.0 pdf_right = 0.0 end if end subroutine fill_zext_ghost_zones subroutine map_to_extended_zgrid ( it , ie , iky , g , gext , ulim ) use zgrid , only : nzgrid implicit none integer , intent ( in ) :: it , ie , iky complex , dimension (:, - nzgrid :, :), intent ( in ) :: g complex , dimension (:), intent ( out ) :: gext integer , intent ( out ) :: ulim integer :: iseg , ikx , itmod integer :: llim complex :: curr_shift ! avoid double-counting at boundaries between 2pi segments iseg = 1 curr_shift = 1. ikx = ikxmod ( iseg , ie , iky ) llim = 1 ; ulim = nzed_segment + 1 gext ( llim : ulim ) = g ( ikx , iz_low ( iseg ): iz_up ( iseg ), it ) * curr_shift if ( nsegments ( ie , iky ) > 1 ) then itmod = it do iseg = 2 , nsegments ( ie , iky ) curr_shift = curr_shift / phase_shift ( iky ) ikx = ikxmod ( iseg , ie , iky ) itmod = it_right ( itmod ) llim = ulim + 1 ulim = llim + nzed_segment - 1 gext ( llim : ulim ) = g ( ikx , iz_low ( iseg ) + 1 : iz_up ( iseg ), itmod ) * curr_shift end do end if end subroutine map_to_extended_zgrid subroutine map_from_extended_zgrid ( it , ie , iky , gext , g ) use zgrid , only : nzgrid implicit none integer , intent ( in ) :: it , ie , iky complex , dimension (:), intent ( in ) :: gext complex , dimension (:, - nzgrid :, :), intent ( in out ) :: g integer :: iseg , ikx , itmod integer :: llim , ulim complex :: curr_shift iseg = 1 curr_shift = 1. ikx = ikxmod ( iseg , ie , iky ) llim = 1 ; ulim = nzed_segment + 1 g ( ikx , iz_low ( iseg ): iz_up ( iseg ), it ) = gext ( llim : ulim ) if ( nsegments ( ie , iky ) > 1 ) then itmod = it do iseg = 2 , nsegments ( ie , iky ) curr_shift = curr_shift * phase_shift ( iky ) llim = ulim + 1 ulim = llim + nzed_segment - 1 ikx = ikxmod ( iseg , ie , iky ) itmod = it_right ( itmod ) g ( ikx , iz_low ( iseg ), itmod ) = gext ( llim - 1 ) * curr_shift g ( ikx , iz_low ( iseg ) + 1 : iz_up ( iseg ), itmod ) = gext ( llim : ulim ) * curr_shift end do end if end subroutine map_from_extended_zgrid subroutine map_to_iz_ikx_from_izext ( iky , ie , iz_from_izext , ikx_from_izext ) implicit none integer , intent ( in ) :: iky , ie integer , dimension (:), intent ( out ) :: iz_from_izext , ikx_from_izext integer :: iseg integer :: llim , ulim integer :: izext iseg = 1 llim = 1 ; ulim = nzed_segment + 1 ikx_from_izext ( llim : ulim ) = ikxmod ( iseg , ie , iky ) do izext = llim , ulim iz_from_izext ( izext ) = izext - llim + iz_low ( iseg ) end do if ( nsegments ( ie , iky ) > 1 ) then do iseg = 2 , nsegments ( ie , iky ) llim = ulim + 1 ulim = llim + nzed_segment - 1 ikx_from_izext ( llim : ulim ) = ikxmod ( iseg , ie , iky ) do izext = llim , ulim iz_from_izext ( izext ) = izext - llim + iz_low ( iseg ) + 1 end do end do end if end subroutine map_to_iz_ikx_from_izext subroutine finish_extended_zgrid implicit none if ( allocated ( neigen )) deallocate ( neigen ) if ( allocated ( periodic )) deallocate ( periodic ) if ( allocated ( nsegments )) deallocate ( nsegments ) if ( allocated ( iz_low )) deallocate ( iz_low , iz_mid , iz_up ) if ( allocated ( ikxmod )) deallocate ( ikxmod ) if ( allocated ( it_right )) deallocate ( it_right ) if ( allocated ( it_left )) deallocate ( it_left ) if ( allocated ( phase_shift )) deallocate ( phase_shift ) extended_zgrid_initialized = . false . end subroutine finish_extended_zgrid end module extended_zgrid","tags":"","loc":"sourcefile/extended_zgrid.f90.html"},{"title":"mp_lu_decomposition.fpp – stella","text":"Source Code module mp_lu_decomposition #ifdef ISO_C_BINDING implicit none public :: lu_decomposition_local public :: lu_inverse_local public :: lu_matrix_multiply_local interface lu_decomposition_local !    module procedure lu_decomposition_local_real module procedure lu_decomposition_local_complex end interface interface lu_inverse_local !    module procedure lu_inverse_local_real module procedure lu_inverse_local_complex end interface interface lu_matrix_multiply_local !    module procedure lu_decomposition_local_real module procedure lu_matrix_multiply_local_complex end interface contains subroutine lu_decomposition_local_complex ( mp_comm , root , win , lu , idx , d ) use mpi implicit none integer , intent ( in ) :: win , mp_comm , root complex , dimension (:, :), intent ( in out ) :: lu integer , dimension (:), intent ( out ) :: idx real , intent ( out ) :: d real , parameter :: zero = 1.0e-20 real , dimension ( size ( lu , 1 )) :: vv complex , dimension ( size ( lu , 2 )) :: dum integer :: i , j , k , n , imax , lo , hi integer :: iproc , nproc , ierr real :: dmax , tmp n = size ( lu , 1 ) call mpi_comm_size ( mp_comm , nproc , ierr ) call mpi_comm_rank ( mp_comm , iproc , ierr ) d = 1.0 !the following is a loop to avoid copying entire matrix ! with (cabs(lu)) do i = 1 , n vv ( i ) = maxval ( cabs ( lu ( i , :))) end do if ( any ( vv == 0.0 )) & write ( * , * ) 'singular matrix in lu_decomposition on process ' , iproc vv = 1.0 / vv do j = 1 , n !divide up the work using row_limits call split_n_tasks ( n - j , iproc , nproc , lo , hi , llim = j + 1 ) !pivot if needed dmax = - 1.0 do k = j , n tmp = vv ( k ) * abs ( lu ( k , j )) if ( tmp > dmax ) then dmax = tmp imax = k end if end do if ( iproc == root ) then idx ( j ) = imax if ( j /= imax ) then dum = lu ( imax , :) lu ( imax , :) = lu ( j , :) lu ( j , :) = dum vv ( imax ) = vv ( j ) d = - d end if if ( lu ( j , j ) == 0.0 ) lu ( j , j ) = zero else if ( j /= imax ) vv ( imax ) = vv ( j ) end if call mpi_win_fence ( 0 , win , ierr ) !get the lead multiplier do i = lo , hi lu ( i , j ) = lu ( i , j ) / lu ( j , j ) end do call mpi_win_fence ( 0 , win , ierr ) do k = lo , hi do i = j + 1 , n lu ( i , k ) = lu ( i , k ) - lu ( i , j ) * lu ( j , k ) end do end do call mpi_win_fence ( 0 , win , ierr ) end do end subroutine lu_decomposition_local_complex subroutine lu_inverse_local_complex ( mp_comm , win , lu , idx , inverse ) use linear_solve , only : lu_back_substitution implicit none integer , intent ( in ) :: win , mp_comm complex , dimension (:, :), intent ( in ) :: lu integer , dimension (:), intent ( in ) :: idx complex , dimension (:, :), intent ( out ) :: inverse integer :: i , n , nproc , iproc , ierr integer :: lo , hi n = size ( lu , 1 ) call mpi_comm_size ( mp_comm , nproc , ierr ) call mpi_comm_rank ( mp_comm , iproc , ierr ) call split_n_tasks ( n , iproc , nproc , lo , hi ) do i = lo , hi inverse ( i , :) = 0 inverse ( i , i ) = 1.0 end do call mpi_win_fence ( 0 , win , ierr ) do i = lo , hi call lu_back_substitution ( lu , idx , inverse (:, i )) end do call mpi_win_fence ( 0 , win , ierr ) end subroutine lu_inverse_local_complex subroutine lu_matrix_multiply_local_complex ( mp_comm , win , mat , b ) implicit none integer , intent ( in ) :: win , mp_comm complex , dimension (:, :), intent ( in ) :: mat complex , dimension (:), intent ( out ) :: b complex , dimension ( size ( b )) :: a integer :: i , n , nproc , iproc integer :: lo , hi , ierr n = size ( mat , 1 ) call mpi_comm_size ( mp_comm , nproc , ierr ) call mpi_comm_rank ( mp_comm , iproc , ierr ) call split_n_tasks ( n , iproc , nproc , lo , hi ) do i = lo , hi a ( i ) = sum ( mat ( i , :) * b (:)) end do call mpi_win_fence ( 0 , win , ierr ) do i = lo , hi b ( i ) = a ( i ) end do call mpi_win_fence ( 0 , win , ierr ) end subroutine lu_matrix_multiply_local_complex subroutine split_n_tasks ( n , iproc , nproc , lo , hi , llim , blocksize , comm ) implicit none integer , intent ( in ) :: n , iproc , nproc integer , intent ( out ) :: lo , hi integer , optional , intent ( in ) :: llim integer , optional , intent ( in ) :: blocksize logical , optional , intent ( out ) :: comm integer :: n_div , n_mod , llim_l , blocksize_l llim_l = 1 if ( present ( llim )) llim_l = llim blocksize_l = 1 if ( present ( blocksize )) blocksize_l = blocksize n_div = n / nproc n_mod = mod ( n , nproc ) if ( n_div < blocksize_l ) then lo = min ( iproc * blocksize_l + llim_l , n + llim_l ) hi = min ( lo + blocksize_l - 1 , n + llim_l - 1 ) if ( present ( comm )) then ! do we require an MPI_WIN_FENCE? comm = . not . ( blocksize_l >= n ) end if else lo = iproc * n_div + min ( iproc , n_mod ) + llim_l hi = lo + n_div - 1 if ( iproc < n_mod ) hi = hi + 1 if ( present ( comm )) then ! do we require an MPI_WIN_FENCE? comm = . not . ( n_div + min ( n_mod , 1 ) >= n ) end if end if end subroutine split_n_tasks #endif end module mp_lu_decomposition","tags":"","loc":"sourcefile/mp_lu_decomposition.fpp.html"},{"title":"parse_extension.f – stella","text":"Source Code SUBROUTINE parse_extension ( file_to_parse , file_or_extension , lnc ) IMPLICIT NONE !----------------------------------------------- !   D u m m y   A r g u m e n t s !----------------------------------------------- CHARACTER ( LEN =* ), INTENT ( in ) :: file_or_extension CHARACTER ( LEN =* ), INTENT ( inout ) :: file_to_parse LOGICAL , INTENT ( out ) :: lnc !----------------------------------------------- !   L o c a l   V a r i a b l e s !----------------------------------------------- INTEGER :: index_path , index_comp , index_nc , istat = 0 LOGICAL :: ltxt CHARACTER ( len = LEN ( file_to_parse )) :: path CHARACTER ( len = LEN ( file_to_parse )) :: temp !!Assumes file_to_parse can store it all CHARACTER ( LEN = 1 ), PARAMETER :: ch_test = '.' !----------------------------------------------- ! !     FIRST CHECK IF FILE_OR_EXTENSION IS A FILENAME (FILE_TO_PARSE EMBEDDED) !     OR AN EXTENSION ! index_path = INDEX ( file_or_extension , TRIM ( file_to_parse )) inde x _ comp = index_path IF ( index_path . gt . 0 ) THEN ! !     MUST BE <FILENAME>. OR <FILENAME>_ ! index_nc = index_path + LEN_TRIM ( file_to_parse ) index_path = INDEX ( file_or_extension ( index_nc :), ch_test ) !SPH032510         IF ((ch_test.ne.'.') .and. (ch_test.ne.'_')) index_path = 0 END IF IF ( index_path . gt . 0 ) THEN file_to_parse = file_or_extension ! !     CHECK FOR netcdf FILE EXTENSION (*.nc) ! index_nc = INDEX ( file_to_parse , \".nc\" , BACK = . TRUE .) lnc = ( index_nc . eq . ( LEN_TRIM ( file_to_parse ) - 2 )) ! !     MAY HAVE PASSED FILE NAME EXTENSION WITHOUT .nc; CHECK IF FILE_TO_PARSE EXISTS IF (. not . lnc ) THEN INQUIRE ( FILE = file_to_parse , EXIST = ltxt , iostat = istat ) IF ( istat . ne . 0 . or . . not . ltxt ) THEN file_to_parse = TRIM ( file_to_parse ) // \".nc\" lnc = . true . END IF END IF ELSE ! !     CHECK IF TEXT (.txt) OR NETCDF (.nc) FILE EXISTS ! path = file_to_parse IF ( file_or_extension ( 1 : 1 ) == '.' . or . 1 file_or_extension ( 1 : 1 ) == '_' ) THEN temp = TRIM ( path ) // file_or_extension ELSE IF ( index_comp == 0 ) THEN temp = TRIM ( path ) // '_' // file_or_extension E L SE temp = TRIM ( file_or_extension ) END IF ! !     FIRST LOOK FOR FILE WITH .nc SUFFIX IN file_or_extension ! file_to_parse = TRIM ( temp ) index_nc = INDEX ( file_to_parse , \".nc\" , BACK = . TRUE .) lnc = ( index_nc . eq . ( LEN_TRIM ( file_to_parse ) - 2 )) ! !     NEXT LOOK FOR .txt SUFFIX ! IF (. not . lnc ) THEN index_nc = INDEX ( file_to_parse , \".txt\" , BACK = . TRUE .) ltxt = ( index_nc . eq . ( LEN_TRIM ( file_to_parse ) - 3 )) ! !     CHECK IF file_or_extension WAS GIVEN WITHOUT EXPLICIT .nc OR .txt SUFFIX ! IF (. not . ltxt ) THEN file_to_parse = TRIM ( temp ) // '.nc' INQUIRE ( FILE = file_to_parse , EXIST = lnc , iostat = istat ) IF ( istat . ne . 0 . or . . not . lnc ) THEN file_to_parse = TRIM ( path ) // '.' 1 // TRIM ( file_or_extension ) // '.nc' INQUIRE ( FILE = file_to_parse , EXIST = lnc , iostat = istat ) IF ( istat . ne . 0 . or . . not . lnc ) THEN file_to_parse = TRIM ( temp ) // '.txt' INQUIRE ( FILE = file_to_parse , EXIST = ltxt , 1 iostat = istat ) IF (. not . ltxt ) THEN file_to_parse = TRIM ( path ) // '.' // 1 TRIM ( file_or_extension ) // '.txt' INQUIRE ( FILE = file_to_parse , EXIST = ltxt , 1 iostat = istat ) END IF END IF END IF END IF ! !     DEFAULT (OLD STYLE) FILE NAME WHEN NONE OF THE ABOVE EXIST ! IF (( istat . ne . 0 . or . . not . ltxt ) . and . . not . lnc ) THEN file_to_parse = TRIM ( path ) // '.' // file_or_extension END IF END IF END IF END SUBROUTINE parse_extension","tags":"","loc":"sourcefile/parse_extension.f.html"},{"title":"stella_time.f90 – stella","text":"Source Code module stella_time implicit none private real :: cfl_dt_linear = - 1. real :: cfl_dt_ExB = - 1. real :: cfl_dt_parallel = - 1. real :: code_dt , code_dt_min , code_dt_max ! added May 18, 2009 to take care of problems ! in exb_shear calculation after change in time step size real :: code_dt_old = 0. real :: code_time = 0. public :: code_dt , update_time , code_dt_old public :: code_time public :: write_dt public :: init_tstart , init_delt , checkcodedt public :: cfl_dt_linear , cfl_dt_ExB , cfl_dt_parallel public :: code_dt_min , code_dt_max contains subroutine init_tstart ( tstart ) real , intent ( in ) :: tstart code_time = tstart end subroutine init_tstart subroutine init_delt ( delt , delt_max , delt_min ) real , intent ( in ) :: delt , delt_max , delt_min code_dt = delt code_dt_min = delt_min ! Do not allow code_dt to increase beyond the input value ! Unless we specified delt_max in the input file ! For example, when restarting the simulation if ( delt_max < 0 ) then code_dt_max = code_dt else code_dt_max = delt_max end if end subroutine init_delt subroutine update_time ! MAB+CMR, 21/5/09: set code_dt_old to code_dt BEFORE any changes in timestep code_dt_old = code_dt code_time = code_time + code_dt end subroutine update_time subroutine write_dt if ( cfl_dt_linear > 0. . and . cfl_dt_linear < 1.e7 ) & write ( * , * ) 'TIME STEP:' write ( * , '(A12, ES10.2E2)' ) \"   cfl_dt:\" // repeat ( ' ' , 50 ), cfl_dt_linear write ( * , '(A12, ES10.2E2)' ) \"   code_dt:\" // repeat ( ' ' , 50 ), code_dt end subroutine write_dt subroutine checkcodedt ( stop_stella ) use mp , only : proc0 , broadcast logical , intent ( in out ) :: stop_stella if ( proc0 ) then if ( code_dt < code_dt_min ) then stop_stella = . true . end if end if if ( proc0 . and . ( code_dt < code_dt_min )) then write ( * , * ) write ( * , * ) 'EXITING STELLA BECAUSE CODE_DT<CODE_DT_MIN:' write ( * , '(A16, ES10.2E2)' ) \"   code_dt:\" // REPEAT ( ' ' , 50 ), code_dt write ( * , '(A16, ES10.2E2)' ) \"   code_dt_min:\" // REPEAT ( ' ' , 50 ), code_dt_min end if call broadcast ( stop_stella ) end subroutine checkcodedt end module stella_time","tags":"","loc":"sourcefile/stella_time.f90.html"},{"title":"redistribute.f90 – stella","text":"Source Code ! Modifications for optimised local copy in c_redist_22 and c_redist_32 ! (and their inverse routines): ! (c) The Numerical Algorithms Group (NAG) Ltd, 2012 ! on behalf of EPSRC for the HECToR project module redistribute ! ! Redistribute distributed (integer, real, complex or logical) ! (1, 2, 3, or 4) dimensional arrays into two dimensional arrays with ! first index on local processor, and vice versa. ! ! The first operation is called 'gather' and the second is called 'scatter.' ! ! One can also do a 'fill' operation.  This consists of copying ! values from a (2, 3, or 4) dimensional array of ! (integer, real, complex, or logical ) values into ! another array with the same number of dimensions. ! ! One can also do a three index to four index redistribution for complex numbers. ! implicit none private public :: index_list_type , delete_list public :: redist_type , delete_redist ! TT> public :: report_map_property , measure_gather , measure_scatter public :: gather_count , scatter_count , time_redist ! <TT public :: init_redist , gather , scatter public :: init_fill , fill public :: set_redist_character_type interface gather module procedure c_redist_22 , r_redist_22 , i_redist_22 , l_redist_22 module procedure c_redist_32 , r_redist_32 , i_redist_32 , l_redist_32 module procedure c_redist_42 , r_redist_42 , i_redist_42 , l_redist_42 module procedure c_redist_23 module procedure c_redist_34 , r_redist_34 module procedure c_redist_33 module procedure c_redist_35 , r_redist_35 end interface interface scatter module procedure c_redist_12 , r_redist_12 , i_redist_12 , l_redist_12 module procedure c_redist_22_inv , r_redist_22_inv , i_redist_22_inv , l_redist_22_inv module procedure c_redist_32_inv , r_redist_32_inv , i_redist_32_inv , l_redist_32_inv module procedure c_redist_42_inv , r_redist_42_inv , i_redist_42_inv , l_redist_42_inv module procedure c_redist_33_inv module procedure c_redist_34_inv , r_redist_34_inv module procedure c_redist_35_inv , r_redist_35_inv end interface ! TT> interface measure_gather module procedure measure_gather_32 , measure_gather_33 module procedure measure_gather_22 end interface interface measure_scatter module procedure measure_scatter_23 , measure_scatter_33 module procedure measure_scatter_22 end interface integer :: gather_count = 0 , scatter_count = 0 real , save :: time_redist ( 2 ) = 0. ! <TT interface fill module procedure c_fill_2 , c_fill_3 , c_fill_4 module procedure r_fill_2 , r_fill_3 , r_fill_4 module procedure i_fill_2 , i_fill_3 , i_fill_4 module procedure l_fill_2 , l_fill_3 , l_fill_4 end interface type :: index_map integer :: nn integer , dimension (:), pointer :: k => null () integer , dimension (:), pointer :: l => null () integer , dimension (:), pointer :: m => null () integer , dimension (:), pointer :: n => null () integer , dimension (:), pointer :: o => null () end type index_map ! TT: want to add map name, from_layout and to_layout type :: redist_type private integer , dimension ( 5 ) :: to_low , from_low , to_high , from_high type ( index_map ), dimension (:), pointer :: to => null () type ( index_map ), dimension (:), pointer :: from => null () complex , dimension (:), pointer :: complex_buff => null () real , dimension (:), pointer :: real_buff => null () integer , dimension (:), pointer :: integer_buff => null () logical , dimension (:), pointer :: logical_buff => null () character ( len = 3 ) :: redistname = \"\" end type redist_type type :: index_list_type integer , dimension (:), pointer :: first => null () integer , dimension (:), pointer :: second => null () integer , dimension (:), pointer :: third => null () integer , dimension (:), pointer :: fourth => null () integer , dimension (:), pointer :: fifth => null () end type index_list_type contains subroutine set_redist_character_type ( r , chartype ) type ( redist_type ), intent ( inout ) :: r character ( 3 ), intent ( in ) :: chartype r % redistname = chartype end subroutine set_redist_character_type subroutine init_redist ( r , char , to_low , to_high , to_list , & from_low , from_high , from_list , ierr ) use mp , only : iproc , nproc , proc0 type ( redist_type ), intent ( inout ) :: r character ( 1 ), intent ( in ) :: char type ( index_list_type ), dimension ( 0 : nproc - 1 ), intent ( in ) :: to_list , from_list integer , dimension (:), intent ( in ) :: from_low , to_high , from_high , to_low integer :: j , ip , n_to , n_from , buff_size integer , optional , intent ( out ) :: ierr allocate ( r % to ( 0 : nproc - 1 ), r % from ( 0 : nproc - 1 )) if ( present ( ierr )) ierr = 0 buff_size = 0 do ip = 0 , nproc - 1 if ( associated ( to_list ( ip )% first )) then n_to = size ( to_list ( ip )% first ) r % to ( ip )% nn = n_to allocate ( r % to ( ip )% k ( n_to )) allocate ( r % to ( ip )% l ( n_to )) r % to ( ip )% k = to_list ( ip )% first r % to ( ip )% l = to_list ( ip )% second if ( associated ( to_list ( ip )% third )) then allocate ( r % to ( ip )% m ( n_to )) r % to ( ip )% m = to_list ( ip )% third end if if ( associated ( to_list ( ip )% fourth )) then allocate ( r % to ( ip )% n ( n_to )) r % to ( ip )% n = to_list ( ip )% fourth end if if ( associated ( to_list ( ip )% fifth )) then allocate ( r % to ( ip )% o ( n_to )) r % to ( ip )% o = to_list ( ip )% fifth end if if ( ip /= iproc ) buff_size = max ( buff_size , n_to ) else r % to ( ip )% nn = 0 end if end do do j = 1 , size ( from_low ) r % from_low ( j ) = from_low ( j ) end do do j = 1 , size ( from_high ) r % from_high ( j ) = from_high ( j ) end do do j = 1 , size ( to_high ) r % to_high ( j ) = to_high ( j ) end do do j = 1 , size ( to_low ) r % to_low ( j ) = to_low ( j ) end do do ip = 0 , nproc - 1 if ( associated ( from_list ( ip )% first )) then n_from = size ( from_list ( ip )% first ) r % from ( ip )% nn = n_from allocate ( r % from ( ip )% k ( n_from )) allocate ( r % from ( ip )% l ( n_from )) r % from ( ip )% k = from_list ( ip )% first r % from ( ip )% l = from_list ( ip )% second if ( associated ( from_list ( ip )% third )) then allocate ( r % from ( ip )% m ( n_from )) r % from ( ip )% m = from_list ( ip )% third end if if ( associated ( from_list ( ip )% fourth )) then allocate ( r % from ( ip )% n ( n_from )) r % from ( ip )% n = from_list ( ip )% fourth end if if ( associated ( from_list ( ip )% fifth )) then allocate ( r % from ( ip )% o ( n_from )) r % from ( ip )% o = from_list ( ip )% fifth end if if ( ip /= iproc ) buff_size = max ( buff_size , n_from ) else r % from ( ip )% nn = 0 end if end do select case ( char ) case ( 'c' ) if ( buff_size > 0 ) allocate ( r % complex_buff ( buff_size )) case ( 'r' ) if ( buff_size > 0 ) allocate ( r % real_buff ( buff_size )) case ( 'i' ) if ( buff_size > 0 ) allocate ( r % integer_buff ( buff_size )) case ( 'l' ) if ( buff_size > 0 ) allocate ( r % logical_buff ( buff_size )) case default if ( proc0 ) then write ( * , * ) 'Type to be redistributed invalid.  Must stop.' write ( * , * ) char end if stop end select end subroutine init_redist !  subroutine init_fill (f, char, to_low, to_high, to_list, & !       from_low, from_high, from_list, ierr) subroutine init_fill ( f , char , to_low , to_list , & from_low , from_list , ierr ) use mp , only : nproc , proc0 , iproc type ( redist_type ), intent ( out ) :: f character ( 1 ), intent ( in ) :: char ! TT> caused a problem on PGI compiler !    type (index_list_type), dimension (0:) :: to_list, from_list type ( index_list_type ), dimension ( 0 : nproc - 1 ), intent ( in ) :: to_list , from_list ! <TT !    integer, dimension(:), intent (in) :: to_low, from_low, to_high, from_high integer , dimension (:), intent ( in ) :: to_low , from_low integer , optional , intent ( out ) :: ierr integer :: j , ip , n_to , n_from , buff_size if ( present ( ierr )) ierr = 0 do j = 1 , size ( to_low ) f % to_low ( j ) = to_low ( j ) end do do j = 1 , size ( from_low ) f % from_low ( j ) = from_low ( j ) end do allocate ( f % to ( 0 : nproc - 1 ), f % from ( 0 : nproc - 1 )) buff_size = 0 do ip = 0 , nproc - 1 if ( associated ( to_list ( ip )% first )) then n_to = size ( to_list ( ip )% first ) f % to ( ip )% nn = n_to allocate ( f % to ( ip )% k ( n_to )) f % to ( ip )% k = to_list ( ip )% first if ( associated ( to_list ( ip )% second )) then allocate ( f % to ( ip )% l ( n_to )) f % to ( ip )% l = to_list ( ip )% second end if if ( associated ( to_list ( ip )% third )) then allocate ( f % to ( ip )% m ( n_to )) f % to ( ip )% m = to_list ( ip )% third end if if ( associated ( to_list ( ip )% fourth )) then allocate ( f % to ( ip )% n ( n_to )) f % to ( ip )% n = to_list ( ip )% fourth end if if ( associated ( to_list ( ip )% fifth )) then allocate ( f % to ( ip )% o ( n_to )) f % to ( ip )% o = to_list ( ip )% fifth end if if ( ip /= iproc ) buff_size = max ( buff_size , n_to ) else f % to ( ip )% nn = 0 end if end do do ip = 0 , nproc - 1 if ( associated ( from_list ( ip )% first )) then n_from = size ( from_list ( ip )% first ) f % from ( ip )% nn = n_from allocate ( f % from ( ip )% k ( n_from )) f % from ( ip )% k = from_list ( ip )% first if ( associated ( from_list ( ip )% second )) then allocate ( f % from ( ip )% l ( n_from )) f % from ( ip )% l = from_list ( ip )% second end if if ( associated ( from_list ( ip )% third )) then allocate ( f % from ( ip )% m ( n_from )) f % from ( ip )% m = from_list ( ip )% third end if if ( associated ( from_list ( ip )% fourth )) then allocate ( f % from ( ip )% n ( n_from )) f % from ( ip )% n = from_list ( ip )% fourth end if if ( associated ( from_list ( ip )% fifth )) then allocate ( f % from ( ip )% o ( n_from )) f % from ( ip )% o = from_list ( ip )% fifth end if if ( ip /= iproc ) buff_size = max ( buff_size , n_from ) else f % from ( ip )% nn = 0 end if end do select case ( char ) case ( 'c' ) if ( buff_size > 0 ) allocate ( f % complex_buff ( buff_size )) case ( 'r' ) if ( buff_size > 0 ) allocate ( f % real_buff ( buff_size )) case ( 'i' ) if ( buff_size > 0 ) allocate ( f % integer_buff ( buff_size )) case ( 'l' ) if ( buff_size > 0 ) allocate ( f % logical_buff ( buff_size )) case default if ( proc0 ) then write ( * , * ) 'Type to be redistributed invalid.  Must stop.' write ( * , * ) char end if stop end select end subroutine init_fill subroutine delete_redist ( r ) use mp , only : nproc type ( redist_type ), intent ( in out ) :: r integer :: i if ( associated ( r % to )) then do i = 0 , nproc - 1 if ( associated ( r % to ( i )% k )) deallocate ( r % to ( i )% k ) if ( associated ( r % to ( i )% l )) deallocate ( r % to ( i )% l ) if ( associated ( r % to ( i )% m )) deallocate ( r % to ( i )% m ) if ( associated ( r % to ( i )% n )) deallocate ( r % to ( i )% n ) end do deallocate ( r % to ) end if if ( associated ( r % from )) then do i = 0 , nproc - 1 if ( associated ( r % from ( i )% k )) deallocate ( r % from ( i )% k ) if ( associated ( r % from ( i )% l )) deallocate ( r % from ( i )% l ) if ( associated ( r % from ( i )% m )) deallocate ( r % from ( i )% m ) if ( associated ( r % from ( i )% n )) deallocate ( r % from ( i )% n ) end do deallocate ( r % from ) end if if ( associated ( r % complex_buff )) deallocate ( r % complex_buff ) if ( associated ( r % real_buff )) deallocate ( r % real_buff ) if ( associated ( r % integer_buff )) deallocate ( r % integer_buff ) if ( associated ( r % logical_buff )) deallocate ( r % logical_buff ) end subroutine delete_redist subroutine delete_list ( list ) use mp , only : nproc ! TT> caused a problem on PGI compiler !    type (index_list_type), dimension(0:) :: list type ( index_list_type ), dimension ( 0 : nproc - 1 ), intent ( inout ) :: list ! <TT integer :: ip do ip = 0 , nproc - 1 if ( associated ( list ( ip )% first )) deallocate ( list ( ip )% first ) if ( associated ( list ( ip )% second )) deallocate ( list ( ip )% second ) if ( associated ( list ( ip )% third )) deallocate ( list ( ip )% third ) if ( associated ( list ( ip )% fourth )) deallocate ( list ( ip )% fourth ) if ( associated ( list ( ip )% fifth )) deallocate ( list ( ip )% fifth ) end do end subroutine delete_list subroutine c_redist_12 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % from_low ( 1 ):), intent ( in ) :: from_here complex , dimension ( r % to_low ( 1 ):, r % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), r % to ( iproc )% l ( i )) & = from_here ( r % from ( iproc )% k ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % complex_buff ( i ) = from_here ( r % from ( ipto )% k ( i )) end do call send ( r % complex_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % complex_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % complex_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % complex_buff ( i ) = from_here ( r % from ( ipto )% k ( i )) end do call send ( r % complex_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine c_redist_12 subroutine c_redist_22 ( r , from_here , to_here ) type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):), intent ( in ) :: from_here complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in out ) :: to_here call c_redist_22_old_copy ( r , from_here , to_here ) call c_redist_22_mpi_copy ( r , from_here , to_here ) end subroutine c_redist_22 subroutine c_redist_22_old_copy ( r , from_here , to_here ) use mp , only : iproc type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):), intent ( in ) :: from_here complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i !CMR ! In the stella standard FFT situation this routine maps !         xxf(it,ixxf) to yxf(ik,iyxf) data type !         where it is kx (or x) index, ik is ky (or y) index, !         ixxf is (y,ig,isgn,\"les\") and iyxf is (x,ig,isgn,\"les\") ! do i = 1 , r % from ( iproc )% nn ! ! redistribute from local processor to local processor ! NB r%from(iproc)%nn is #elements sent by THIS processor to THIS processor !    In this situation the data at (r%to(iproc)%k(i),r%to(iproc)%l(i)) !    should come from (r%from(iproc)%k(i), r%from(iproc)%l(i)). ! ! This do loop, in stella standard FFT situation, corresponds to: !    to_here(ik,iyxf)=from_here(it,ixxf) ! to_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) & = from_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i )) end do end subroutine c_redist_22_old_copy subroutine c_redist_22_mpi_copy ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):), intent ( in ) :: from_here complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % complex_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i )) end do call send ( r % complex_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % complex_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % complex_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % complex_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i )) end do call send ( r % complex_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine c_redist_22_mpi_copy subroutine c_redist_22_inv ( r , from_here , to_here ) type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in ) :: from_here complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):), intent ( in out ) :: to_here call c_redist_22_inv_old_copy ( r , from_here , to_here ) call c_redist_22_inv_mpi_copy ( r , from_here , to_here ) end subroutine c_redist_22_inv subroutine c_redist_22_inv_old_copy ( r , from_here , to_here ) use mp , only : iproc type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in ) :: from_here complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):), intent ( in out ) :: to_here integer :: i !CMR ! In the stella standard FFT situation this routine maps !         yxf(ik,iyxf) to xxf(it,ixxf) data type !         where it is kx (or x) index, ik is ky (or y) index, !         ixxf is (y,ig,isgn,\"les\") and iyxf is (x,ig,isgn,\"les\") ! do i = 1 , r % to ( iproc )% nn ! ! redistribute from local processor to local processor ! NB r%from(iproc)%nn is #elements sent by THIS processor to THIS processor !    In this situation the data at (r%from(iproc)%k(i),r%from(iproc)%l(i)) !    should come from (r%to(iproc)%k(i), r%to(iproc)%l(i)). ! ! This do loop, in stella standard FFT situation, corresponds to: !    to_here(it,ixxf)=from_here(ik,iyxf) ! to_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i )) & = from_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) end do end subroutine c_redist_22_inv_old_copy subroutine c_redist_22_inv_mpi_copy ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in ) :: from_here complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % complex_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % complex_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i )) & = r % complex_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i )) & = r % complex_buff ( i ) end do end if ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % complex_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % complex_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine c_redist_22_inv_mpi_copy subroutine c_redist_32 ( r , from_here , to_here ) use job_manage , only : time_message type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in ) :: from_here complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in out ) :: to_here call c_redist_32_old_copy ( r , from_here , to_here ) call c_redist_32_mpi_copy ( r , from_here , to_here ) end subroutine c_redist_32 subroutine c_redist_32_old_copy ( r , from_here , to_here ) use mp , only : iproc type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in ) :: from_here complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i !CMR ! In the stella standard FFT situation this routine maps !         g(ig, isgn, iglo) to xxf(it,ixxf) data type !         where it is kx (or x) index, ixxf is (y,ig,isgn,\"les\") !         and iglo is (\"xyles\") do i = 1 , r % from ( iproc )% nn ! ! redistribute from local processor to local processor ! NB r%from(iproc)%nn is #elements sent by THIS processor to THIS processor !    In this situation the data at (r%to(iproc)%k(i),r%to(iproc)%l(i)) !    should come from (r%from(iproc)%k(i),r%from(iproc)%l(i),r%from(iproc)%m(i)). ! ! This do loop, in stella standard FFT situation, corresponds to: !    to_here(it,ixxf)=from_here(ig,isgn,iglo) ! to_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) & = from_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i )) end do end subroutine c_redist_32_old_copy subroutine c_redist_32_mpi_copy ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in ) :: from_here complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % complex_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i )) end do call send ( r % complex_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % complex_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % complex_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % complex_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i )) end do call send ( r % complex_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine c_redist_32_mpi_copy subroutine c_redist_32_inv ( r , from_here , to_here ) use job_manage , only : time_message type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in ) :: from_here complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in out ) :: to_here call c_redist_32_inv_old_copy ( r , from_here , to_here ) call c_redist_32_inv_mpi_copy ( r , from_here , to_here ) end subroutine c_redist_32_inv subroutine c_redist_32_inv_old_copy ( r , from_here , to_here ) use mp , only : iproc type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in ) :: from_here complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in out ) :: to_here integer :: i !CMR ! In the stella standard FFT situation this routine maps !         xxf(it,ixxf) to g(ig, isgn, iglo) data type !         where it is kx (or x) index, ixxf is (y,ig,isgn,\"les\") !         and iglo is (\"xyles\") do i = 1 , r % to ( iproc )% nn ! ! redistribute from local processor to local processor ! NB r%to(iproc)%nn is #elements sent by THIS processor to THIS processor !    In this situation the data at (r%from(iproc)%k(i),r%from(iproc)%l(i),r%from(iproc)%m(i)) !    should come from (r%to(iproc)%k(i),r%to(iproc)%l(i)). ! ! This do loop, in stella standard FFT situation, corresponds to: !    to_here(ig,isgn,iglo)=from_here(it,ixxf) ! to_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i )) & = from_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) end do end subroutine c_redist_32_inv_old_copy subroutine c_redist_32_inv_mpi_copy ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in ) :: from_here complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % complex_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % complex_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i )) & = r % complex_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i )) & = r % complex_buff ( i ) end do end if ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % complex_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % complex_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine c_redist_32_inv_mpi_copy subroutine c_redist_42 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):, & r % from_low ( 4 ):), intent ( in ) :: from_here complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) & = from_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i ), & r % from ( iproc )% n ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % complex_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i ), & r % from ( ipto )% n ( i )) end do call send ( r % complex_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % complex_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % complex_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % complex_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i ), & r % from ( ipto )% n ( i )) end do call send ( r % complex_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine c_redist_42 subroutine c_redist_42_inv ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in ) :: from_here complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):, & r % from_low ( 4 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % to ( iproc )% nn to_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i ), & r % from ( iproc )% n ( i )) & = from_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % complex_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % complex_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i ), & r % from ( ipfrom )% n ( i )) & = r % complex_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i ), & r % from ( ipfrom )% n ( i )) & = r % complex_buff ( i ) end do end if ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % complex_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % complex_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine c_redist_42_inv subroutine c_redist_23 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):), intent ( in ) :: from_here complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):, & r % to_low ( 3 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i ), & r % to ( iproc )% m ( i )) & = from_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % complex_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i )) end do call send ( r % complex_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i ), & r % to ( ipfrom )% m ( i )) & = r % complex_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i ), & r % to ( ipfrom )% m ( i )) & = r % complex_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % complex_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i )) end do call send ( r % complex_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine c_redist_23 subroutine c_redist_34 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in ) :: from_here complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):, & r % to_low ( 3 ):, & r % to_low ( 4 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i ), & r % to ( iproc )% m ( i ), & r % to ( iproc )% n ( i )) & = from_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % complex_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i )) end do call send ( r % complex_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i ), & r % to ( ipfrom )% m ( i ), & r % to ( ipfrom )% n ( i )) & = r % complex_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i ), & r % to ( ipfrom )% m ( i ), & r % to ( ipfrom )% n ( i )) & = r % complex_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % complex_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i )) end do call send ( r % complex_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine c_redist_34 subroutine c_redist_34_inv ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):, & r % to_low ( 3 ):, & r % to_low ( 4 ):), intent ( in ) :: from_here complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % to ( iproc )% nn to_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i )) & = from_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i ), & r % to ( iproc )% m ( i ), & r % to ( iproc )% n ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % complex_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i ), & r % to ( ipto )% m ( i ), & r % to ( ipto )% n ( i )) end do call send ( r % complex_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i )) & = r % complex_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i )) & = r % complex_buff ( i ) end do end if ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % complex_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i ), & r % to ( ipto )% m ( i ), & r % to ( ipto )% n ( i )) end do call send ( r % complex_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine c_redist_34_inv subroutine r_redist_34 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r real , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in ) :: from_here real , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):, & r % to_low ( 3 ):, & r % to_low ( 4 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i ), & r % to ( iproc )% m ( i ), & r % to ( iproc )% n ( i )) & = from_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % real_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i )) end do call send ( r % real_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i ), & r % to ( ipfrom )% m ( i ), & r % to ( ipfrom )% n ( i )) & = r % real_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i ), & r % to ( ipfrom )% m ( i ), & r % to ( ipfrom )% n ( i )) & = r % real_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % real_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i )) end do call send ( r % real_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine r_redist_34 subroutine r_redist_34_inv ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r real , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):, & r % to_low ( 3 ):, & r % to_low ( 4 ):), intent ( in ) :: from_here real , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % to ( iproc )% nn to_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i )) & = from_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i ), & r % to ( iproc )% m ( i ), & r % to ( iproc )% n ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % real_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i ), & r % to ( ipto )% m ( i ), & r % to ( ipto )% n ( i )) end do call send ( r % real_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i )) & = r % real_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i )) & = r % real_buff ( i ) end do end if ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % real_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i ), & r % to ( ipto )% m ( i ), & r % to ( ipto )% n ( i )) end do call send ( r % real_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine r_redist_34_inv subroutine c_redist_35 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in ) :: from_here complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):, & r % to_low ( 3 ):, & r % to_low ( 4 ):, & r % to_low ( 5 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i ), & r % to ( iproc )% m ( i ), & r % to ( iproc )% n ( i ), & r % to ( iproc )% o ( i )) & = from_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % complex_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i )) end do call send ( r % complex_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i ), & r % to ( ipfrom )% m ( i ), & r % to ( ipfrom )% n ( i ), & r % to ( ipfrom )% o ( i )) & = r % complex_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i ), & r % to ( ipfrom )% m ( i ), & r % to ( ipfrom )% n ( i ), & r % to ( ipfrom )% o ( i )) & = r % complex_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % complex_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i )) end do call send ( r % complex_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine c_redist_35 subroutine r_redist_35 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r real , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in ) :: from_here real , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):, & r % to_low ( 3 ):, & r % to_low ( 4 ):, & r % to_low ( 5 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i ), & r % to ( iproc )% m ( i ), & r % to ( iproc )% n ( i ), & r % to ( iproc )% o ( i )) & = from_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % real_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i )) end do call send ( r % real_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i ), & r % to ( ipfrom )% m ( i ), & r % to ( ipfrom )% n ( i ), & r % to ( ipfrom )% o ( i )) & = r % real_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i ), & r % to ( ipfrom )% m ( i ), & r % to ( ipfrom )% n ( i ), & r % to ( ipfrom )% o ( i )) & = r % real_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % real_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i )) end do call send ( r % real_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine r_redist_35 subroutine c_redist_35_inv ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):, & r % to_low ( 3 ):, & r % to_low ( 4 ):, & r % to_low ( 5 ):), intent ( in ) :: from_here complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % to ( iproc )% nn to_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i )) & = from_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i ), & r % to ( iproc )% m ( i ), & r % to ( iproc )% n ( i ), & r % to ( iproc )% o ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % complex_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i ), & r % to ( ipto )% m ( i ), & r % to ( ipto )% n ( i ), & r % to ( ipto )% o ( i )) end do call send ( r % complex_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i )) & = r % complex_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i )) & = r % complex_buff ( i ) end do end if ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % complex_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i ), & r % to ( ipto )% m ( i ), & r % to ( ipto )% n ( i ), & r % to ( ipto )% o ( i )) end do call send ( r % complex_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine c_redist_35_inv subroutine r_redist_35_inv ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r real , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):, & r % to_low ( 3 ):, & r % to_low ( 4 ):, & r % to_low ( 5 ):), intent ( in ) :: from_here real , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % to ( iproc )% nn to_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i )) & = from_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i ), & r % to ( iproc )% m ( i ), & r % to ( iproc )% n ( i ), & r % to ( iproc )% o ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % real_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i ), & r % to ( ipto )% m ( i ), & r % to ( ipto )% n ( i ), & r % to ( ipto )% o ( i )) end do call send ( r % real_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i )) & = r % real_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i )) & = r % real_buff ( i ) end do end if ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % real_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i ), & r % to ( ipto )% m ( i ), & r % to ( ipto )% n ( i ), & r % to ( ipto )% o ( i )) end do call send ( r % real_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine r_redist_35_inv subroutine r_redist_12 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r real , dimension ( r % from_low ( 1 ):), intent ( in ) :: from_here real , dimension ( r % to_low ( 1 ):, r % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), r % to ( iproc )% l ( i )) & = from_here ( r % from ( iproc )% k ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % real_buff ( i ) = from_here ( r % from ( ipto )% k ( i )) end do call send ( r % real_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % real_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % real_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % real_buff ( i ) = from_here ( r % from ( ipto )% k ( i )) end do call send ( r % real_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine r_redist_12 subroutine r_redist_22 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r real , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):), intent ( in ) :: from_here real , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) & = from_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % real_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i )) end do call send ( r % real_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % real_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % real_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % real_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i )) end do call send ( r % real_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine r_redist_22 subroutine r_redist_22_inv ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r real , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in ) :: from_here real , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % to ( iproc )% nn to_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i )) & = from_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % real_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % real_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i )) & = r % real_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i )) & = r % real_buff ( i ) end do end if ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % real_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % real_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine r_redist_22_inv subroutine r_redist_32 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r real , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in ) :: from_here real , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) & = from_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % real_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i )) end do call send ( r % real_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % real_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % real_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % real_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i )) end do call send ( r % real_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine r_redist_32 subroutine r_redist_32_inv ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r real , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in ) :: from_here real , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % to ( iproc )% nn to_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i )) & = from_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % real_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % real_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i )) & = r % real_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i )) & = r % real_buff ( i ) end do end if ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % real_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % real_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine r_redist_32_inv subroutine r_redist_42 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r real , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):, & r % from_low ( 4 ):), intent ( in ) :: from_here real , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) & = from_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i ), & r % from ( iproc )% n ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % real_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i ), & r % from ( ipto )% n ( i )) end do call send ( r % real_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % real_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % real_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % real_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i ), & r % from ( ipto )% n ( i )) end do call send ( r % real_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine r_redist_42 subroutine r_redist_42_inv ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r real , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in ) :: from_here real , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):, & r % from_low ( 4 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % to ( iproc )% nn to_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i ), & r % from ( iproc )% n ( i )) & = from_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % real_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % real_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i ), & r % from ( ipfrom )% n ( i )) & = r % real_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % real_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i ), & r % from ( ipfrom )% n ( i )) & = r % real_buff ( i ) end do end if ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % real_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % real_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine r_redist_42_inv subroutine i_redist_12 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r integer , dimension ( r % from_low ( 1 ):), intent ( in ) :: from_here integer , dimension ( r % to_low ( 1 ):, r % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), r % to ( iproc )% l ( i )) & = from_here ( r % from ( iproc )% k ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % integer_buff ( i ) = from_here ( r % from ( ipto )% k ( i )) end do call send ( r % integer_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % integer_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % integer_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % integer_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % integer_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % integer_buff ( i ) = from_here ( r % from ( ipto )% k ( i )) end do call send ( r % integer_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine i_redist_12 subroutine i_redist_22 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r integer , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):), intent ( in ) :: from_here integer , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) & = from_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % integer_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i )) end do call send ( r % integer_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % integer_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % integer_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % integer_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % integer_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % integer_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i )) end do call send ( r % integer_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine i_redist_22 subroutine i_redist_22_inv ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r integer , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in ) :: from_here integer , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % to ( iproc )% nn to_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i )) & = from_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % integer_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % integer_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % integer_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i )) & = r % integer_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % integer_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i )) & = r % integer_buff ( i ) end do end if ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % integer_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % integer_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine i_redist_22_inv subroutine i_redist_32 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r integer , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in ) :: from_here integer , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) & = from_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % integer_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i )) end do call send ( r % integer_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % integer_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % integer_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % integer_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % integer_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % integer_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i )) end do call send ( r % integer_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine i_redist_32 subroutine i_redist_32_inv ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r integer , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in ) :: from_here integer , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % to ( iproc )% nn to_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i )) & = from_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % integer_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % integer_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % integer_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i )) & = r % integer_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % integer_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i )) & = r % integer_buff ( i ) end do end if ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % integer_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % integer_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine i_redist_32_inv subroutine i_redist_42 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r integer , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):, & r % from_low ( 4 ):), intent ( in ) :: from_here integer , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) & = from_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i ), & r % from ( iproc )% n ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % integer_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i ), & r % from ( ipto )% n ( i )) end do call send ( r % integer_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % integer_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % integer_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % integer_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % integer_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % integer_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i ), & r % from ( ipto )% n ( i )) end do call send ( r % integer_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine i_redist_42 subroutine i_redist_42_inv ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r integer , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in ) :: from_here integer , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):, & r % from_low ( 4 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % to ( iproc )% nn to_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i ), & r % from ( iproc )% n ( i )) & = from_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % integer_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % integer_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % integer_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i ), & r % from ( ipfrom )% n ( i )) & = r % integer_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % integer_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i ), & r % from ( ipfrom )% n ( i )) & = r % integer_buff ( i ) end do end if ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % integer_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % integer_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine i_redist_42_inv subroutine l_redist_12 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r logical , dimension ( r % from_low ( 1 ):), intent ( in ) :: from_here logical , dimension ( r % to_low ( 1 ):, r % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), r % to ( iproc )% l ( i )) & = from_here ( r % from ( iproc )% k ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % logical_buff ( i ) = from_here ( r % from ( ipto )% k ( i )) end do call send ( r % logical_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % logical_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % logical_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % logical_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % logical_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % logical_buff ( i ) = from_here ( r % from ( ipto )% k ( i )) end do call send ( r % logical_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine l_redist_12 subroutine l_redist_22 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r logical , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):), intent ( in ) :: from_here logical , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) & = from_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % logical_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i )) end do call send ( r % logical_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % logical_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % logical_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % logical_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % logical_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % logical_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i )) end do call send ( r % logical_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine l_redist_22 subroutine l_redist_22_inv ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r logical , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in ) :: from_here logical , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % to ( iproc )% nn to_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i )) & = from_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % logical_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % logical_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % logical_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i )) & = r % logical_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % logical_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i )) & = r % logical_buff ( i ) end do end if ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % logical_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % logical_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine l_redist_22_inv subroutine l_redist_32 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r logical , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in ) :: from_here logical , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) & = from_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % logical_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i )) end do call send ( r % logical_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % logical_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % logical_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % logical_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % logical_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % logical_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i )) end do call send ( r % logical_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine l_redist_32 subroutine l_redist_32_inv ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r logical , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in ) :: from_here logical , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % to ( iproc )% nn to_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i )) & = from_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % logical_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % logical_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % logical_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i )) & = r % logical_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % logical_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i )) & = r % logical_buff ( i ) end do end if ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % logical_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % logical_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine l_redist_32_inv subroutine l_redist_42 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r logical , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):, & r % from_low ( 4 ):), intent ( in ) :: from_here logical , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) & = from_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i ), & r % from ( iproc )% n ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % logical_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i ), & r % from ( ipto )% n ( i )) end do call send ( r % logical_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % logical_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % logical_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % logical_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i )) & = r % logical_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % logical_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i ), & r % from ( ipto )% n ( i )) end do call send ( r % logical_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine l_redist_42 subroutine l_redist_42_inv ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r logical , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):), intent ( in ) :: from_here logical , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):, & r % from_low ( 4 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % to ( iproc )% nn to_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i ), & r % from ( iproc )% n ( i )) & = from_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % logical_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % logical_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % logical_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i ), & r % from ( ipfrom )% n ( i )) & = r % logical_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % logical_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i ), & r % from ( ipfrom )% n ( i )) & = r % logical_buff ( i ) end do end if ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % logical_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i )) end do call send ( r % logical_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine l_redist_42_inv ! TT> subroutine c_redist_33 ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in ) :: from_here complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):, & r % to_low ( 3 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % from ( iproc )% nn to_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i ), & r % to ( iproc )% m ( i )) & = from_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % complex_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i )) end do call send ( r % complex_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i ), & r % to ( ipfrom )% m ( i )) & = r % complex_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % to ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % to ( ipfrom )% nn to_here ( r % to ( ipfrom )% k ( i ), & r % to ( ipfrom )% l ( i ), & r % to ( ipfrom )% m ( i )) & = r % complex_buff ( i ) end do end if ! send to idpth next processor if ( r % from ( ipto )% nn > 0 ) then do i = 1 , r % from ( ipto )% nn r % complex_buff ( i ) = from_here ( r % from ( ipto )% k ( i ), & r % from ( ipto )% l ( i ), & r % from ( ipto )% m ( i )) end do call send ( r % complex_buff ( 1 : r % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine c_redist_33 subroutine c_redist_33_inv ( r , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: r complex , dimension ( r % to_low ( 1 ):, & r % to_low ( 2 ):, & r % to_low ( 3 ):), intent ( in ) :: from_here complex , dimension ( r % from_low ( 1 ):, & r % from_low ( 2 ):, & r % from_low ( 3 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , r % to ( iproc )% nn to_here ( r % from ( iproc )% k ( i ), & r % from ( iproc )% l ( i ), & r % from ( iproc )% m ( i )) & = from_here ( r % to ( iproc )% k ( i ), & r % to ( iproc )% l ( i ), & r % to ( iproc )% m ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % complex_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i ), & r % to ( ipto )% m ( i )) end do call send ( r % complex_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i )) & = r % complex_buff ( i ) end do end if else ! receive from idpth preceding processor if ( r % from ( ipfrom )% nn > 0 ) then call receive ( r % complex_buff ( 1 : r % from ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , r % from ( ipfrom )% nn to_here ( r % from ( ipfrom )% k ( i ), & r % from ( ipfrom )% l ( i ), & r % from ( ipfrom )% m ( i )) & = r % complex_buff ( i ) end do end if ! send to idpth next processor if ( r % to ( ipto )% nn > 0 ) then do i = 1 , r % to ( ipto )% nn r % complex_buff ( i ) = from_here ( r % to ( ipto )% k ( i ), & r % to ( ipto )% l ( i ), & r % to ( ipto )% m ( i )) end do call send ( r % complex_buff ( 1 : r % to ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine c_redist_33_inv ! <TT subroutine c_fill_2 ( f , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: f complex , dimension ( f % from_low ( 1 ):, & f % from_low ( 2 ):), intent ( in ) :: from_here complex , dimension ( f % to_low ( 1 ):, & f % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , f % from ( iproc )% nn to_here ( f % to ( iproc )% k ( i ), & f % to ( iproc )% l ( i )) & = from_here ( f % from ( iproc )% k ( i ), & f % from ( iproc )% l ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % complex_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i )) end do call send ( f % complex_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % complex_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i )) & = f % complex_buff ( i ) end do end if else ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % complex_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i )) & = f % complex_buff ( i ) end do end if ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % complex_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i )) end do call send ( f % complex_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine c_fill_2 subroutine c_fill_3 ( f , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: f complex , dimension ( f % from_low ( 1 ):, & f % from_low ( 2 ):, & f % from_low ( 3 ):), intent ( in ) :: from_here complex , dimension ( f % to_low ( 1 ):, & f % to_low ( 2 ):, & f % to_low ( 3 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , f % from ( iproc )% nn to_here ( f % to ( iproc )% k ( i ), & f % to ( iproc )% l ( i ), & f % to ( iproc )% m ( i )) & = from_here ( f % from ( iproc )% k ( i ), & f % from ( iproc )% l ( i ), & f % from ( iproc )% m ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % complex_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i ), & f % from ( ipto )% m ( i )) end do call send ( f % complex_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % complex_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i ), & f % to ( ipfrom )% m ( i )) & = f % complex_buff ( i ) end do end if else ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % complex_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i ), & f % to ( ipfrom )% m ( i )) & = f % complex_buff ( i ) end do end if ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % complex_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i ), & f % from ( ipto )% m ( i )) end do call send ( f % complex_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine c_fill_3 subroutine c_fill_4 ( f , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: f complex , dimension ( f % from_low ( 1 ):, & f % from_low ( 2 ):, & f % from_low ( 3 ):, & f % from_low ( 4 ):), intent ( in ) :: from_here complex , dimension ( f % to_low ( 1 ):, & f % to_low ( 2 ):, & f % to_low ( 3 ):, & f % to_low ( 4 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , f % from ( iproc )% nn to_here ( f % to ( iproc )% k ( i ), & f % to ( iproc )% l ( i ), & f % to ( iproc )% m ( i ), & f % to ( iproc )% n ( i )) & = from_here ( f % from ( iproc )% k ( i ), & f % from ( iproc )% l ( i ), & f % from ( iproc )% m ( i ), & f % from ( iproc )% n ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % complex_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i ), & f % from ( ipto )% m ( i ), & f % from ( ipto )% n ( i )) end do call send ( f % complex_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % complex_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i ), & f % to ( ipfrom )% m ( i ), & f % to ( ipfrom )% n ( i )) & = f % complex_buff ( i ) end do end if else ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % complex_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i ), & f % to ( ipfrom )% m ( i ), & f % to ( ipfrom )% n ( i )) & = f % complex_buff ( i ) end do end if ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % complex_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i ), & f % from ( ipto )% m ( i ), & f % from ( ipto )% n ( i )) end do call send ( f % complex_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine c_fill_4 subroutine r_fill_2 ( f , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: f real , dimension ( f % from_low ( 1 ):, & f % from_low ( 2 ):), intent ( in ) :: from_here real , dimension ( f % to_low ( 1 ):, & f % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , f % from ( iproc )% nn to_here ( f % to ( iproc )% k ( i ), & f % to ( iproc )% l ( i )) & = from_here ( f % from ( iproc )% k ( i ), & f % from ( iproc )% l ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % real_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i )) end do call send ( f % real_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % real_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i )) & = f % real_buff ( i ) end do end if else ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % real_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i )) & = f % real_buff ( i ) end do end if ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % real_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i )) end do call send ( f % real_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine r_fill_2 subroutine r_fill_3 ( f , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: f real , dimension ( f % from_low ( 1 ):, & f % from_low ( 2 ):, & f % from_low ( 3 ):), intent ( in ) :: from_here real , dimension ( f % to_low ( 1 ):, & f % to_low ( 2 ):, & f % to_low ( 3 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , f % from ( iproc )% nn to_here ( f % to ( iproc )% k ( i ), & f % to ( iproc )% l ( i ), & f % to ( iproc )% m ( i )) & = from_here ( f % from ( iproc )% k ( i ), & f % from ( iproc )% l ( i ), & f % from ( iproc )% m ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % real_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i ), & f % from ( ipto )% m ( i )) end do call send ( f % real_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % real_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i ), & f % to ( ipfrom )% m ( i )) & = f % real_buff ( i ) end do end if else ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % real_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i ), & f % to ( ipfrom )% m ( i )) & = f % real_buff ( i ) end do end if ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % real_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i ), & f % from ( ipto )% m ( i )) end do call send ( f % real_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine r_fill_3 subroutine r_fill_4 ( f , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: f real , dimension ( f % from_low ( 1 ):, & f % from_low ( 2 ):, & f % from_low ( 3 ):, & f % from_low ( 4 ):), intent ( in ) :: from_here real , dimension ( f % to_low ( 1 ):, & f % to_low ( 2 ):, & f % to_low ( 3 ):, & f % to_low ( 4 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , f % from ( iproc )% nn to_here ( f % to ( iproc )% k ( i ), & f % to ( iproc )% l ( i ), & f % to ( iproc )% m ( i ), & f % to ( iproc )% n ( i )) & = from_here ( f % from ( iproc )% k ( i ), & f % from ( iproc )% l ( i ), & f % from ( iproc )% m ( i ), & f % from ( iproc )% n ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % real_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i ), & f % from ( ipto )% m ( i ), & f % from ( ipto )% n ( i )) end do call send ( f % real_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % real_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i ), & f % to ( ipfrom )% m ( i ), & f % to ( ipfrom )% n ( i )) & = f % real_buff ( i ) end do end if else ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % real_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i ), & f % to ( ipfrom )% m ( i ), & f % to ( ipfrom )% n ( i )) & = f % real_buff ( i ) end do end if ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % real_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i ), & f % from ( ipto )% m ( i ), & f % from ( ipto )% n ( i )) end do call send ( f % real_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine r_fill_4 subroutine i_fill_2 ( f , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: f integer , dimension ( f % from_low ( 1 ):, & f % from_low ( 2 ):), intent ( in ) :: from_here integer , dimension ( f % to_low ( 1 ):, & f % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , f % from ( iproc )% nn to_here ( f % to ( iproc )% k ( i ), & f % to ( iproc )% l ( i )) & = from_here ( f % from ( iproc )% k ( i ), & f % from ( iproc )% l ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % integer_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i )) end do call send ( f % integer_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % integer_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i )) & = f % integer_buff ( i ) end do end if else ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % integer_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i )) & = f % integer_buff ( i ) end do end if ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % integer_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i )) end do call send ( f % integer_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine i_fill_2 subroutine i_fill_3 ( f , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: f integer , dimension ( f % from_low ( 1 ):, & f % from_low ( 2 ):, & f % from_low ( 3 ):), intent ( in ) :: from_here integer , dimension ( f % to_low ( 1 ):, & f % to_low ( 2 ):, & f % to_low ( 3 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , f % from ( iproc )% nn to_here ( f % to ( iproc )% k ( i ), & f % to ( iproc )% l ( i ), & f % to ( iproc )% m ( i )) & = from_here ( f % from ( iproc )% k ( i ), & f % from ( iproc )% l ( i ), & f % from ( iproc )% m ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % integer_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i ), & f % from ( ipto )% m ( i )) end do call send ( f % integer_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % integer_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i ), & f % to ( ipfrom )% m ( i )) & = f % integer_buff ( i ) end do end if else ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % integer_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i ), & f % to ( ipfrom )% m ( i )) & = f % integer_buff ( i ) end do end if ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % integer_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i ), & f % from ( ipto )% m ( i )) end do call send ( f % integer_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine i_fill_3 subroutine i_fill_4 ( f , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: f integer , dimension ( f % from_low ( 1 ):, & f % from_low ( 2 ):, & f % from_low ( 3 ):, & f % from_low ( 4 ):), intent ( in ) :: from_here integer , dimension ( f % to_low ( 1 ):, & f % to_low ( 2 ):, & f % to_low ( 3 ):, & f % to_low ( 4 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , f % from ( iproc )% nn to_here ( f % to ( iproc )% k ( i ), & f % to ( iproc )% l ( i ), & f % to ( iproc )% m ( i ), & f % to ( iproc )% n ( i )) & = from_here ( f % from ( iproc )% k ( i ), & f % from ( iproc )% l ( i ), & f % from ( iproc )% m ( i ), & f % from ( iproc )% n ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % integer_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i ), & f % from ( ipto )% m ( i ), & f % from ( ipto )% n ( i )) end do call send ( f % integer_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % integer_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i ), & f % to ( ipfrom )% m ( i ), & f % to ( ipfrom )% n ( i )) & = f % integer_buff ( i ) end do end if else ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % integer_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i ), & f % to ( ipfrom )% m ( i ), & f % to ( ipfrom )% n ( i )) & = f % integer_buff ( i ) end do end if ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % integer_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i ), & f % from ( ipto )% m ( i ), & f % from ( ipto )% n ( i )) end do call send ( f % integer_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine i_fill_4 subroutine l_fill_2 ( f , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: f logical , dimension ( f % from_low ( 1 ):, & f % from_low ( 2 ):), intent ( in ) :: from_here logical , dimension ( f % to_low ( 1 ):, & f % to_low ( 2 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , f % from ( iproc )% nn to_here ( f % to ( iproc )% k ( i ), & f % to ( iproc )% l ( i )) & = from_here ( f % from ( iproc )% k ( i ), & f % from ( iproc )% l ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % logical_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i )) end do call send ( f % logical_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % logical_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i )) & = f % logical_buff ( i ) end do end if else ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % logical_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i )) & = f % logical_buff ( i ) end do end if ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % logical_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i )) end do call send ( f % logical_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine l_fill_2 subroutine l_fill_3 ( f , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: f logical , dimension ( f % from_low ( 1 ):, & f % from_low ( 2 ):, & f % from_low ( 3 ):), intent ( in ) :: from_here logical , dimension ( f % to_low ( 1 ):, & f % to_low ( 2 ):, & f % to_low ( 3 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , f % from ( iproc )% nn to_here ( f % to ( iproc )% k ( i ), & f % to ( iproc )% l ( i ), & f % to ( iproc )% m ( i )) & = from_here ( f % from ( iproc )% k ( i ), & f % from ( iproc )% l ( i ), & f % from ( iproc )% m ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % logical_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i ), & f % from ( ipto )% m ( i )) end do call send ( f % logical_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % logical_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i ), & f % to ( ipfrom )% m ( i )) & = f % logical_buff ( i ) end do end if else ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % logical_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i ), & f % to ( ipfrom )% m ( i )) & = f % logical_buff ( i ) end do end if ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % logical_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i ), & f % from ( ipto )% m ( i )) end do call send ( f % logical_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine l_fill_3 subroutine l_fill_4 ( f , from_here , to_here ) use mp , only : iproc , nproc , send , receive type ( redist_type ), intent ( in out ) :: f logical , dimension ( f % from_low ( 1 ):, & f % from_low ( 2 ):, & f % from_low ( 3 ):, & f % from_low ( 4 ):), intent ( in ) :: from_here logical , dimension ( f % to_low ( 1 ):, & f % to_low ( 2 ):, & f % to_low ( 3 ):, & f % to_low ( 4 ):), intent ( in out ) :: to_here integer :: i , idp , ipto , ipfrom , iadp ! redistribute from local processor to local processor do i = 1 , f % from ( iproc )% nn to_here ( f % to ( iproc )% k ( i ), & f % to ( iproc )% l ( i ), & f % to ( iproc )% m ( i ), & f % to ( iproc )% n ( i )) & = from_here ( f % from ( iproc )% k ( i ), & f % from ( iproc )% l ( i ), & f % from ( iproc )% m ( i ), & f % from ( iproc )% n ( i )) end do ! redistribute to idpth next processor from idpth preceding processor ! or redistribute from idpth preceding processor to idpth next processor ! to avoid deadlocks do idp = 1 , nproc - 1 ipto = mod ( iproc + idp , nproc ) ipfrom = mod ( iproc + nproc - idp , nproc ) iadp = min ( idp , nproc - idp ) ! avoid deadlock AND ensure mostly parallel resolution if ( mod ( iproc / iadp , 2 ) == 0 ) then ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % logical_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i ), & f % from ( ipto )% m ( i ), & f % from ( ipto )% n ( i )) end do call send ( f % logical_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % logical_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i ), & f % to ( ipfrom )% m ( i ), & f % to ( ipfrom )% n ( i )) & = f % logical_buff ( i ) end do end if else ! receive from idpth preceding processor if ( f % to ( ipfrom )% nn > 0 ) then call receive ( f % logical_buff ( 1 : f % to ( ipfrom )% nn ), ipfrom , idp ) do i = 1 , f % to ( ipfrom )% nn to_here ( f % to ( ipfrom )% k ( i ), & f % to ( ipfrom )% l ( i ), & f % to ( ipfrom )% m ( i ), & f % to ( ipfrom )% n ( i )) & = f % logical_buff ( i ) end do end if ! send to idpth next processor if ( f % from ( ipto )% nn > 0 ) then do i = 1 , f % from ( ipto )% nn f % logical_buff ( i ) = from_here ( f % from ( ipto )% k ( i ), & f % from ( ipto )% l ( i ), & f % from ( ipto )% m ( i ), & f % from ( ipto )% n ( i )) end do call send ( f % logical_buff ( 1 : f % from ( ipto )% nn ), ipto , idp ) end if end if end do end subroutine l_fill_4 subroutine report_map_property ( r ) use mp , only : iproc , nproc , proc0 , sum_reduce , max_reduce type ( redist_type ), intent ( in ) :: r type :: redist_prp integer :: local_max , local_total integer :: comm_max , comm_total integer :: elm_max , elm_total end type redist_prp type ( redist_prp ) :: prp integer :: ip , rank_from , rank_to integer , dimension (:), allocatable :: lbd_from , lbd_to prp % comm_max = 0 prp % comm_total = 0 prp % elm_total = 0 do ip = 0 , nproc - 1 if ( ip == iproc ) then prp % local_total = r % to ( ip )% nn else if ( r % to ( ip )% nn > 0 ) then prp % comm_total = prp % comm_total + 1 prp % elm_total = prp % elm_total + r % to ( ip )% nn end if end if end do prp % local_max = prp % local_total prp % comm_max = prp % comm_total prp % elm_max = prp % elm_total call max_reduce ( prp % local_max , 0 ) call sum_reduce ( prp % local_total , 0 ) call max_reduce ( prp % comm_max , 0 ) call sum_reduce ( prp % comm_total , 0 ) call max_reduce ( prp % elm_max , 0 ) call sum_reduce ( prp % elm_total , 0 ) if ( proc0 ) then rank_from = 1 if ( associated ( r % from ( 0 )% l )) rank_from = 2 if ( associated ( r % from ( 0 )% m )) rank_from = 3 if ( associated ( r % from ( 0 )% n )) rank_from = 4 rank_to = 1 if ( associated ( r % to ( 0 )% l )) rank_to = 2 if ( associated ( r % to ( 0 )% m )) rank_to = 3 if ( associated ( r % to ( 0 )% n )) rank_to = 4 allocate ( lbd_from ( rank_from ), lbd_to ( rank_to )) lbd_from = r % from_low ( 1 : rank_from ) lbd_to = r % to_low ( 1 : rank_to ) print '(a,i2,a,i2)' , 'From rank' , rank_from , ' to rank' , rank_to print '(a,t20,4i10)' , 'From lbound (proc0)' , r % from_low ( 1 : rank_from ) print '(a,t20,4i10)' , 'To lbound (proc0)' , r % to_low ( 1 : rank_to ) print '(a,t49,a,t64,a)' , '--- Redistribution statistics ---' , & 'max' , 'avg' print '(a,t40,i12,t55,f15.2)' , 'Number of local move elements' , & prp % local_max , real ( prp % local_total ) / real ( nproc ) print '(a,t40,i12,t60,f10.2)' , & 'Number of inter-processor communications' , & prp % comm_max , real ( prp % comm_total ) / real ( nproc ) print '(a,t40,i12,t55,f15.2)' , & 'Number of inter-processor move elements' , & prp % elm_max , real ( prp % elm_total ) / real ( nproc ) print * end if end subroutine report_map_property subroutine measure_gather_32 ( map , gin , gout ) use job_manage , only : time_message use mp , only : proc0 type ( redist_type ), intent ( in out ) :: map complex , dimension (:, :, :), intent ( in ) :: gin complex , dimension (:, :), intent ( out ) :: gout if ( proc0 ) call time_message (. false ., time_redist , ' Redistribution' ) call c_redist_32 ( map , gin , gout ) if ( proc0 ) call time_message (. false ., time_redist , ' Redistribution' ) gather_count = gather_count + 1 end subroutine measure_gather_32 subroutine measure_scatter_23 ( map , gin , gout ) use job_manage , only : time_message use mp , only : proc0 type ( redist_type ), intent ( in out ) :: map complex , dimension (:, :), intent ( in ) :: gin complex , dimension (:, :, :), intent ( out ) :: gout if ( proc0 ) call time_message (. false ., time_redist , ' Redistribution' ) call c_redist_32_inv ( map , gin , gout ) if ( proc0 ) call time_message (. false ., time_redist , ' Redistribution' ) scatter_count = scatter_count + 1 end subroutine measure_scatter_23 subroutine measure_gather_33 ( map , gin , gout ) use job_manage , only : time_message use mp , only : proc0 type ( redist_type ), intent ( in out ) :: map complex , dimension (:, :, :), intent ( in ) :: gin complex , dimension (:, :, :), intent ( out ) :: gout if ( proc0 ) call time_message (. false ., time_redist , ' Redistribution' ) call c_redist_33 ( map , gin , gout ) if ( proc0 ) call time_message (. false ., time_redist , ' Redistribution' ) gather_count = gather_count + 1 end subroutine measure_gather_33 subroutine measure_scatter_33 ( map , gin , gout ) use job_manage , only : time_message use mp , only : proc0 type ( redist_type ), intent ( in out ) :: map complex , dimension (:, :, :), intent ( in ) :: gin complex , dimension (:, :, :), intent ( out ) :: gout if ( proc0 ) call time_message (. false ., time_redist , ' Redistribution' ) call c_redist_33_inv ( map , gin , gout ) if ( proc0 ) call time_message (. false ., time_redist , ' Redistribution' ) scatter_count = scatter_count + 1 end subroutine measure_scatter_33 subroutine measure_gather_22 ( map , gin , gout ) use job_manage , only : time_message use mp , only : proc0 type ( redist_type ), intent ( in out ) :: map complex , dimension (:, :), intent ( in ) :: gin complex , dimension (:, :), intent ( out ) :: gout if ( proc0 ) call time_message (. false ., time_redist , ' Redistribution' ) call c_redist_22 ( map , gin , gout ) if ( proc0 ) call time_message (. false ., time_redist , ' Redistribution' ) gather_count = gather_count + 1 end subroutine measure_gather_22 subroutine measure_scatter_22 ( map , gin , gout ) use job_manage , only : time_message use mp , only : proc0 type ( redist_type ), intent ( in out ) :: map complex , dimension (:, :), intent ( in ) :: gin complex , dimension (:, :), intent ( out ) :: gout if ( proc0 ) call time_message (. false ., time_redist , ' Redistribution' ) call c_redist_22_inv ( map , gin , gout ) if ( proc0 ) call time_message (. false ., time_redist , ' Redistribution' ) scatter_count = scatter_count + 1 end subroutine measure_scatter_22 end module redistribute","tags":"","loc":"sourcefile/redistribute.f90.html"},{"title":"ran.fpp – stella","text":"Source Code # include \"define.inc\" module ran ! <doc> !  A wrapper module for random number generator. !  Thie module provides real function ranf !  using intrinsic random_number/random_seed or !  Mersenne Twister 19937 (see mt19937.f90). !  Note that instrinsic function appears to use !  and integer vector seed of length 2, but this !  is implementation dependent.  If there is ever !  a system that uses seed integer vector of !  different length, an error message will print. ! </doc> implicit none private public :: ranf public :: get_rnd_seed_length , get_rnd_seed , init_ranf contains !------------------------------------------------------------------- function ranf ( seed ) ! <doc> !  returns a uniform deviate in [0., 1.) !  The generator is initialized with the given seed if exists, !  otherwise uses the default seed. ! </doc> # if RANDOM == _RANMT_ use mt19937 , only : sgrnd , grnd # endif integer , intent ( in ), optional :: seed real :: ranf # if RANDOM == _RANMT_ if ( present ( seed )) call sgrnd ( seed ) ranf = grnd () # else integer :: l integer , allocatable :: seed_in (:) if ( present ( seed )) then call random_seed ( size = l ) allocate ( seed_in ( l )) seed_in (:) = seed call random_seed ( put = seed_in ) deallocate ( seed_in ) end if call random_number ( ranf ) # endif end function ranf !------------------------------------------------------------------- function get_rnd_seed_length () result ( l ) ! <doc> !  get_rnd_seed_length gets the length of the integer vector for !      the random number generator seed ! </doc> integer :: l # if RANDOM == _RANMT_ l = 1 # else call random_seed ( size = l ) # endif end function get_rnd_seed_length !------------------------------------------------------------------- subroutine get_rnd_seed ( seed ) ! <doc> !  get_rnd_seed  random number seed integer vector ! </doc> integer , dimension (:), intent ( out ) :: seed # if RANDOM == _RANMT_ !NOTE: If MT is generator, more codding needs to be done to !      extract seed, so this should be run using only randomize seed = 0 # else call random_seed ( get = seed ) # endif end subroutine get_rnd_seed !------------------------------------------------------------------- subroutine init_ranf ( randomize , init_seed , mult ) # if RANDOM == _RANMT_ use mt19937 , only : sgrnd , grnd # endif ! <doc> !  init_ranf seeds the choosen random number generator. !  if randomize=T, a random seed based on the date and time is used. !  Otherwise, it sets the seed using init_seed !  In either case, it outputs the initial seed in init_seed ! </doc> implicit none logical , intent ( in ) :: randomize integer , intent ( inout ), dimension (:) :: init_seed integer , optional , intent ( in ) :: mult integer :: lmult = 1 , clock # if RANDOM == _RANMT_ if ( present ( mult )) then lmult = mult end if if ( randomize ) then call system_clock ( COUNT = clock ) init_seed ( 1 ) = clock * lmult call sgrnd ( init_seed ( 1 )) else call sgrnd ( init_seed ( 1 ) * lmult ) end if # else integer :: i , n integer , parameter :: prim1 = 1824261409 , prim2 = 1190494759 if ( present ( mult )) then lmult = mult end if if ( randomize ) then call random_seed ( size = n ) call system_clock ( count = clock ) init_seed = clock * ( / ( prim1 ** i , i = 1 , n ) / ) + prim2 * lmult * ( / ( i - 1 , i = 1 , n ) / ) call random_seed ( put = init_seed ) else call random_seed ( put = init_seed * lmult ) end if # endif end subroutine init_ranf end module ran","tags":"","loc":"sourcefile/ran.fpp.html"},{"title":"spl.f90 – stella","text":"Source Code module splines implicit none public :: geo_spline , linear_interp_periodic type :: spline integer :: n real , dimension (:), pointer :: x , y , y2 end type spline type :: periodic_spline integer :: n real :: period real , dimension (:), pointer :: x , y , y2 end type periodic_spline interface geo_spline module procedure geo_spline_real module procedure geo_spline_array end interface contains !   subroutine new_spline (n, x, y, spl) !     implicit none !     integer, intent (in) :: n !     real, dimension (n), intent (in) :: x, y !     type (spline), intent (out) :: spl !     real, dimension (n) :: temp !     integer :: ierr !     spl%n = n !     allocate (spl%x(n),spl%y(n)) !     spl%x = x !     spl%y = y !     allocate (spl%y2(n)) !     call fitp_curv1 (n, x, y, 0.0, 0.0, 3, spl%y2, temp, 1.0, ierr) !   end subroutine new_spline !   subroutine new_periodic_spline (n, x, y, period, spl) !     implicit none !     integer, intent (in) :: n !     real, dimension (n), intent (in) :: x, y !     real, intent (in) :: period !     type (periodic_spline), intent (out) :: spl !     real, dimension (2*n) :: temp !     integer :: ierr !     spl%n = n !     spl%period = period !     allocate (spl%x(n),spl%y(n)) !     spl%x = x !     spl%y = y !     allocate (spl%y2(n)) !     call fitp_curvp1 (n,x,y,period,spl%y2,temp,1.0,ierr) !   end subroutine new_periodic_spline !   subroutine delete_spline (spl) !     implicit none !     type (spline), intent (in out) :: spl !     spl%n = 0 !     deallocate (spl%x,spl%y) !     nullify (spl%x) !     nullify (spl%y) !     deallocate (spl%y2) !     nullify (spl%y2) !   end subroutine delete_spline !   subroutine delete_periodic_spline (spl) !     implicit none !     type (periodic_spline), intent (in out) :: spl !     spl%n = 0 !     spl%period = 0.0 !     deallocate (spl%x,spl%y) !     nullify (spl%x) !     nullify (spl%y) !     deallocate (spl%y2) !     nullify (spl%y2) !   end subroutine delete_periodic_spline !   function splint (x, spl) !     implicit none !     real, intent (in) :: x !     type (spline), intent (in) :: spl !     real :: splint !     splint = fitp_curv2 (x, spl%n, spl%x, spl%y, spl%y2, 1.0) !   end function splint !   function periodic_splint (x, spl) !     implicit none !     real, intent (in) :: x !     type (periodic_spline), intent (in) :: spl !     real :: periodic_splint !     periodic_splint = fitp_curvp2 & !          (x, spl%n, spl%x, spl%y, spl%period, spl%y2, 1.0) !   end function periodic_splint !   function dsplint (x, spl) !     implicit none !     real, intent (in) :: x !     type (spline), intent (in) :: spl !     real :: dsplint !     dsplint = fitp_curvd (x, spl%n, spl%x, spl%y, spl%y2, 1.0) !   end function dsplint !   function splintint (x0, x1, spl) !     implicit none !     real, intent (in) :: x0, x1 !     type (spline), intent (in) :: spl !     real :: splintint !     splintint = fitp_curvi (x0,x1,spl%n,spl%x,spl%y,spl%y2,1.0) !   end function splintint !   function periodic_splintint (x0, x1, spl) !     implicit none !     real, intent (in) :: x0, x1 !     type (periodic_spline), intent (in) :: spl !     real :: periodic_splintint !     periodic_splintint = fitp_curvpi & !          (x0,x1,spl%n,spl%x,spl%y,spl%period,spl%y2, 1.0) !   end function periodic_splintint !   subroutine inter_d_cspl(n,r,data,m,x,dint,ddint) !     integer n !     integer m !     real r(n), data(n), x(m), dint(m), ddint(m) !     integer max !     parameter (max=1000) !     real ddata(max),temp(max) !     integer i,ierr !     if (n .gt. max) then !        write (*,*) 'error in inter_d_cspl' !        write (*,*) 'increase max' !        stop !     endif !     ierr = 0 !     call fitp_curv1(n,r,data,0.0,0.0,3,ddata,temp,1.0,ierr) !     if (ierr .ne. 0) then !        if (ierr .eq. 1) then !           write (*,*) 'FITPACK: curv1 error: n < 2' !        elseif (ierr .eq. 2) then !           write (*,*) 'FITPACK: curv1 error: x-values not increasing' !        else !           write (*,*) 'FITPACK: curv1 error' !        endif !        stop !     endif !     do i=1,m !        dint(i) = fitp_curv2 (x(i),n,r,data,ddata,1.0) !        ddint(i)= fitp_curvd (x(i),n,r,data,ddata,1.0) !     enddo !   end subroutine inter_d_cspl !   subroutine inter_cspl(n,r,data,m,x,dint) !     integer n !     integer m !     real r(n), data(n), x(m), dint(m) !     integer max !     parameter (max=1000) !     real ddata(max),temp(max) !     integer i,ierr !     if (n .gt. max) then !        write (*,*) 'error in inter_cspl' !        write (*,*) 'increase max' !        stop !     endif !     ierr = 0 !     call fitp_curv1(n,r,data,0.0,0.0,3,ddata,temp,1.0,ierr) !     if (ierr .ne. 0) then !        if (ierr .eq. 1) then !           write (*,*) 'FITPACK: curv1 error: n < 2' !        elseif (ierr .eq. 2) then !           write (*,*) 'FITPACK: curv1 error: x-values not increasing' !        else !           write (*,*) 'FITPACK: curv1 error' !        endif !        stop !     endif !     do i=1,m !        dint(i) = fitp_curv2 (x(i),n,r,data,ddata,1.0) !     enddo !   end subroutine inter_cspl !   subroutine inter_getspl (n, x, y, y2) !     integer n !     real x(n), y(n), y2(n) !     integer max !     parameter (max=1000) !     real temp(max) !     integer ierr !     if (n .gt. max) then !        write (*,*) 'error in inter_getspl' !        write (*,*) 'increase max' !        stop !     endif !     ierr = 0 !     call fitp_curv1(n,x,y,0.0,0.0,3,y2,temp,1.0,ierr) !     if (ierr .ne. 0) then !        if (ierr .eq. 1) then !           write (*,*) 'FITPACK: curv1 error: n < 2' !        elseif (ierr .eq. 2) then !           write (*,*) 'FITPACK: curv1 error: x-values not increasing' !        else !           write (*,*) 'FITPACK: curv1 error' !        endif !        stop !     endif !   end subroutine inter_getspl !   real function inter_splint (x0, n, x, y, y2) !     real x0 !     integer n !     real x(n), y(n), y2(n) !     inter_splint = fitp_curv2 (x0, n, x, y, y2, 1.0) !   end function inter_splint !   real function inter_dsplint (x0, n, x, y, y2) !     real x0 !     integer n !     real x(n), y(n), y2(n) !     inter_dsplint = fitp_curvd (x0, n, x, y, y2, 1.0) !   end function inter_dsplint !   real function inter_d2splint (x0, n, x, y, y2) !     real x0 !     integer n !     real x(n), y(n), y2(n) !     real yx(500) !     data yx(1)/1.0/ !     save yx !     integer i !     if (yx(1) .ne. 0.0) then !        do i=1,500 !           yx(i) = 0.0 !        enddo !     endif !     inter_d2splint = fitp_curv2 (x0, n, x, y2, yx, 1e5) !   end function inter_d2splint !   subroutine inter_getpspl (n, x, p, y, y2) !     integer n !     real x(n), p, y(n), y2(n) !     integer max !     parameter (max=1000) !     real temp(max) !     integer ierr !     if (n .gt. max) then !        write (*,*) 'error in inter_getpspl' !        write (*,*) 'increase max' !        stop !     endif !     ierr=0 !     call fitp_curvp1(n,x,y,p,y2,temp,1.0,ierr) !     if (ierr .ne. 0) then !        if (ierr .eq. 1) then !           write (*,*) 'FITPACK: curvp1 error: n < 2' !        elseif (ierr .eq. 2) then !           write (*,*) 'FITPACK: curvp1 error: p <= x(n)-x(1)' !        elseif (ierr .eq. 3) then !           write (*,*) 'FITPACK: curvp1 error: x-values not increasing' !        else !           write (*,*) 'FITPACK: curv1 error' !        endif !        stop !     endif !   end subroutine inter_getpspl !   real function inter_psplint (x0, n, x, p, y, y2) !     real x0 !     integer n !     real x(n), p, y(n), y2(n) !     inter_psplint = fitp_curvp2 (x0, n, x, y, p, y2, 1.0) !   end function inter_psplint !   real function inter_pdsplint (x0, n, x, p, y, y2) !     real x0 !     integer n !     real x(n), p, y(n), y2(n) !     inter_pdsplint = fitp_curvpd (x0, n, x, y, p, y2, 1.0) !   end function inter_pdsplint ! From inet!cs.utexas.edu!cline Tue Oct 31 17:10:31 CST 1989 ! Received: from mojave.cs.utexas.edu by cs.utexas.edu (5.59/1.44) !         id AA29509; Tue, 31 Oct 89 17:11:51 CST ! Posted-Date: Tue, 31 Oct 89 17:10:31 CST ! Message-Id: <8910312310.AA04442@mojave.cs.utexas.edu> ! Received: by mojave.cs.utexas.edu (14.5/1.4-Client) !         id AA04442; Tue, 31 Oct 89 17:10:34 cst ! Date: Tue, 31 Oct 89 17:10:31 CST ! X-Mailer: Mail User's Shell (6.5 4/17/89) ! From: cline@cs.utexas.edu (Alan Cline) ! To: ehg@research.att.com ! Subject: New FITPACK Subset for netlib ! ! ! This new version of FITPACK distributed by netlib is about 20% of ! the total package in terms of characters, lines of code, and num- ! ber of subprograms. However, these 25 subprograms represent about ! 95% of usages of the package.  What has been omitted are such ca- ! pabilities as: !   1. Automatic tension determination, !   2. Derivatives, arclengths, and enclosed areas for planar !      curves, !   3. Three dimensional curves, !   4. Special surface fitting using equispacing assumptions, !   5. Surface fitting in annular, wedge, polar, toroidal, lunar, !      and spherical geometries, !   6. B-splines in tension generation and usage, !   7. General surface fitting in three dimensional space. ! ! (The code previously circulated in netlib is less than 10% of the ! total  package  and is more than a decade old.  Its usage is dis- ! couraged.) ! ! Please note:  Two versions of the subroutine snhcsh are included. ! Both serve the same purpose:  obtaining approximations to certain ! hyperbolic trigonometric-like functions.  The first is less accu- ! rate (but more efficient) than the second.  Installers should se- ! lect the one with the precision they desire. ! ! Interested parties can obtain the entire package on disk or  tape ! from Pleasant  Valley Software, 8603 Altus Cove, Austin TX (USA), ! 78759 at a cost of $495 US. A 340 page manual  is  available  for ! $30  US  per  copy.  The  package  includes  examples and machine ! readable documentation. subroutine fitp_curv1 ( n , x , y , slp1 , slpn , islpsw , yp , temp , sigma , ierr ) integer n , islpsw , ierr real x ( n ), y ( n ), slp1 , slpn , yp ( n ), temp ( n ), sigma ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this subroutine determines the parameters necessary to ! compute an interpolatory spline under tension through ! a sequence of functional values. the slopes at the two ! ends of the curve may be specified or omitted.  for actual ! computation of points on the curve it is necessary to call ! the function curv2. ! ! on input-- ! !   n is the number of values to be interpolated (n.ge.2). ! !   x is an array of the n increasing abscissae of the !   functional values. ! !   y is an array of the n ordinates of the values, (i. e. !   y(k) is the functional value corresponding to x(k) ). ! !   slp1 and slpn contain the desired values for the first !   derivative of the curve at x(1) and x(n), respectively. !   the user may omit values for either or both of these !   parameters and signal this with islpsw. ! !   islpsw contains a switch indicating which slope data !   should be used and which should be estimated by this !   subroutine, !          = 0 if slp1 and slpn are to be used, !          = 1 if slp1 is to be used but not slpn, !          = 2 if slpn is to be used but not slp1, !          = 3 if both slp1 and slpn are to be estimated !              internally. ! !   yp is an array of length at least n. ! !   temp is an array of length at least n which is used for !   scratch storage. ! ! and ! !   sigma contains the tension factor. this value indicates !   the curviness desired. if abs(sigma) is nearly zero !   (e.g. .001) the resulting curve is approximately a !   cubic spline. if abs(sigma) is large (e.g. 50.) the !   resulting curve is nearly a polygonal line. if sigma !   equals zero a cubic spline results.  a standard value !   for sigma is approximately 1. in absolute value. ! ! on output-- ! !   yp contains the values of the second derivative of the !   curve at the given nodes. ! !   ierr contains an error flag, !        = 0 for normal return, !        = 1 if n is less than 2, !        = 2 if x-values are not strictly increasing. ! ! and ! !   n, x, y, slp1, slpn, islpsw and sigma are unaltered. ! ! this subroutine references package modules ceez, terms, ! and snhcsh. ! !----------------------------------------------------------- integer i , ibak , nm1 , np1 real sdiag1 , diag1 , delxnm , dx1 , diag , sdiag2 , dx2 , diag2 real delxn , slpp1 , delx1 , sigmap , c3 , c2 , c1 , slppn , delx2 nm1 = n - 1 np1 = n + 1 ierr = 0 if ( n <= 1 ) go to 8 if ( x ( n ) <= x ( 1 )) go to 9 ! ! denormalize tension factor ! sigmap = abs ( sigma ) * real ( n - 1 ) / ( x ( n ) - x ( 1 )) ! ! approximate end slopes ! if ( islpsw >= 2 ) go to 1 slpp1 = slp1 go to 2 1 delx1 = x ( 2 ) - x ( 1 ) delx2 = delx1 + delx1 if ( n > 2 ) delx2 = x ( 3 ) - x ( 1 ) if ( delx1 <= 0. . or . delx2 <= delx1 ) go to 9 call fitp_ceez ( delx1 , delx2 , sigmap , c1 , c2 , c3 , n ) slpp1 = c1 * y ( 1 ) + c2 * y ( 2 ) if ( n > 2 ) slpp1 = slpp1 + c3 * y ( 3 ) 2 if ( islpsw == 1 . or . islpsw == 3 ) go to 3 slppn = slpn go to 4 3 delxn = x ( n ) - x ( nm1 ) delxnm = delxn + delxn if ( n > 2 ) delxnm = x ( n ) - x ( n - 2 ) if ( delxn <= 0. . or . delxnm <= delxn ) go to 9 call fitp_ceez ( - delxn , - delxnm , sigmap , c1 , c2 , c3 , n ) slppn = c1 * y ( n ) + c2 * y ( nm1 ) if ( n > 2 ) slppn = slppn + c3 * y ( n - 2 ) ! ! set up right hand side and tridiagonal system for yp and ! perform forward elimination ! 4 delx1 = x ( 2 ) - x ( 1 ) if ( delx1 <= 0. ) go to 9 dx1 = ( y ( 2 ) - y ( 1 )) / delx1 call fitp_terms ( diag1 , sdiag1 , sigmap , delx1 ) yp ( 1 ) = ( dx1 - slpp1 ) / diag1 temp ( 1 ) = sdiag1 / diag1 if ( n == 2 ) go to 6 do i = 2 , nm1 delx2 = x ( i + 1 ) - x ( i ) if ( delx2 <= 0. ) go to 9 dx2 = ( y ( i + 1 ) - y ( i )) / delx2 call fitp_terms ( diag2 , sdiag2 , sigmap , delx2 ) diag = diag1 + diag2 - sdiag1 * temp ( i - 1 ) yp ( i ) = ( dx2 - dx1 - sdiag1 * yp ( i - 1 )) / diag temp ( i ) = sdiag2 / diag dx1 = dx2 diag1 = diag2 sdiag1 = sdiag2 end do 6 diag = diag1 - sdiag1 * temp ( nm1 ) yp ( n ) = ( slppn - dx1 - sdiag1 * yp ( nm1 )) / diag ! ! perform back substitution ! do i = 2 , n ibak = np1 - i yp ( ibak ) = yp ( ibak ) - temp ( ibak ) * yp ( ibak + 1 ) end do return ! ! too few points ! 8 ierr = 1 return ! ! x-values not strictly increasing ! 9 ierr = 2 return end subroutine fitp_curv1 subroutine fitp_curvs ( n , x , y , d , isw , s , eps , ys , ysp , sigma , temp , ierr ) integer n , isw , ierr real x ( n ), y ( n ), d ( n ), s , eps , ys ( n ), ysp ( n ), sigma , temp ( n , 9 ) ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this subroutine determines the parameters necessary to ! compute a smoothing spline under tension. for a given ! increasing sequence of abscissae (x(i)), i = 1,..., n and ! associated ordinates (y(i)), i = 1,..., n, the function ! determined minimizes the summation from i = 1 to n-1 of ! the square of the second derivative of f plus sigma ! squared times the difference of the first derivative of f ! and (f(x(i+1))-f(x(i)))/(x(i+1)-x(i)) squared, over all ! functions f with two continuous derivatives such that the ! summation of the square of (f(x(i))-y(i))/d(i) is less ! than or equal to a given constant s, where (d(i)), i = 1, ! ..., n are a given set of observation weights. the ! function determined is a spline under tension with third ! derivative discontinuities at (x(i)), i = 2,..., n-1. for ! actual computation of points on the curve it is necessary ! to call the function curv2. the determination of the curve ! is performed by subroutine curvss, the subroutine curvs ! only decomposes the workspace for curvss. ! ! on input-- ! !   n is the number of values to be smoothed (n.ge.2). ! !   x is an array of the n increasing abscissae of the !   values to be smoothed. ! !   y is an array of the n ordinates of the values to be !   smoothed, (i. e. y(k) is the functional value !   corresponding to x(k) ). ! !   d is a parameter containing the observation weights. !   this may either be an array of length n or a scalar !   (interpreted as a constant). the value of d !   corresponding to the observation (x(k),y(k)) should !   be an approximation to the standard deviation of error. ! !   isw contains a switch indicating whether the parameter !   d is to be considered a vector or a scalar, !          = 0 if d is an array of length n, !          = 1 if d is a scalar. ! !   s contains the value controlling the smoothing. this !   must be non-negative. for s equal to zero, the !   subroutine does interpolation, larger values lead to !   smoother funtions. if parameter d contains standard !   deviation estimates, a reasonable value for s is !   float(n). ! !   eps contains a tolerance on the relative precision to !   which s is to be interpreted. this must be greater than !   or equal to zero and less than or equal to one. a !   reasonable value for eps is sqrt(2./float(n)). ! !   ys is an array of length at least n. ! !   ysp is an array of length at least n. ! !   sigma contains the tension factor. this value indicates !   the degree to which the first derivative part of the !   smoothing functional is emphasized. if sigma is nearly !   zero (e. g. .001) the resulting curve is approximately a !   cubic spline. if sigma is large (e. g. 50.) the !   resulting curve is nearly a polygonal line. if sigma !   equals zero a cubic spline results. a standard value for !   sigma is approximately 1. ! ! and ! !   temp is an array of length at least 9*n which is used !   for scratch storage. ! ! on output-- ! !   ys contains the smoothed ordinate values. ! !   ysp contains the values of the second derivative of the !   smoothed curve at the given nodes. ! !   ierr contains an error flag, !        = 0 for normal return, !        = 1 if n is less than 2, !        = 2 if s is negative, !        = 3 if eps is negative or greater than one, !        = 4 if x-values are not strictly increasing, !        = 5 if a d-value is non-positive. ! ! and ! !   n, x, y, d, isw, s, eps, and sigma are unaltered. ! ! this subroutine references package modules curvss, terms, ! and snhcsh. ! !----------------------------------------------------------- ! ! decompose temp into nine arrays and call curvss ! call fitp_curvss ( n , x , y , d , isw , s , eps , ys , ysp , sigma , temp ( 1 , 1 ), & temp ( 1 , 2 ), temp ( 1 , 3 ), temp ( 1 , 4 ), temp ( 1 , 5 ), & temp ( 1 , 6 ), temp ( 1 , 7 ), temp ( 1 , 8 ), temp ( 1 , 9 ), & ierr ) end subroutine fitp_curvs real function fitp_curv2 ( t , n , x , y , yp , sigma ) integer n real t , x ( n ), y ( n ), yp ( n ), sigma ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this function interpolates a curve at a given point ! using a spline under tension. the subroutine curv1 should ! be called earlier to determine certain necessary ! parameters. ! ! on input-- ! !   t contains a real value to be mapped onto the interpo- !   lating curve. ! !   n contains the number of points which were specified to !   determine the curve. ! !   x and y are arrays containing the abscissae and !   ordinates, respectively, of the specified points. ! !   yp is an array of second derivative values of the curve !   at the nodes. ! ! and ! !   sigma contains the tension factor (its sign is ignored). ! ! the parameters n, x, y, yp, and sigma should be input ! unaltered from the output of curv1. ! ! on output-- ! !   curv2 contains the interpolated value. ! ! none of the input parameters are altered. ! ! this function references package modules intrvl and ! snhcsh. ! !----------------------------------------------------------- integer i , im1 real ss , sigdel , dummy , s1 , s2 , sum , sigmap real del1 , del2 , dels ! ! determine interval ! im1 = fitp_intrvl ( t , x , n ) i = im1 + 1 ! ! denormalize tension factor ! sigmap = abs ( sigma ) * real ( n - 1 ) / ( x ( n ) - x ( 1 )) ! ! set up and perform interpolation ! del1 = t - x ( im1 ) del2 = x ( i ) - t dels = x ( i ) - x ( im1 ) sum = ( y ( i ) * del1 + y ( im1 ) * del2 ) / dels if ( sigmap /= 0. ) go to 1 fitp_curv2 = sum - del1 * del2 * ( yp ( i ) * ( del1 + dels ) + yp ( im1 ) * ( del2 + dels )) / ( 6. * dels ) return 1 sigdel = sigmap * dels call fitp_snhcsh ( ss , dummy , sigdel , - 1 ) call fitp_snhcsh ( s1 , dummy , sigmap * del1 , - 1 ) call fitp_snhcsh ( s2 , dummy , sigmap * del2 , - 1 ) fitp_curv2 = sum + ( yp ( i ) * del1 * ( s1 - ss ) + yp ( im1 ) * del2 * ( s2 - ss )) / ( sigdel * sigmap * ( 1. + ss )) return end function fitp_curv2 real function fitp_curvd ( t , n , x , y , yp , sigma ) integer n real t , x ( n ), y ( n ), yp ( n ), sigma ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this function differentiates a curve at a given point ! using a spline under tension. the subroutine curv1 should ! be called earlier to determine certain necessary ! parameters. ! ! on input-- ! !   t contains a real value at which the derivative is to be !   determined. ! !   n contains the number of points which were specified to !   determine the curve. ! !   x and y are arrays containing the abscissae and !   ordinates, respectively, of the specified points. ! !   yp is an array of second derivative values of the curve !   at the nodes. ! ! and ! !   sigma contains the tension factor (its sign is ignored). ! ! the parameters n, x, y, yp, and sigma should be input ! unaltered from the output of curv1. ! ! on output-- ! !   curvd contains the derivative value. ! ! none of the input parameters are altered. ! ! this function references package modules intrvl and ! snhcsh. ! !----------------------------------------------------------- integer i , im1 real ss , sigdel , dummy , c1 , c2 , sum , sigmap real del1 , del2 , dels ! ! determine interval ! im1 = fitp_intrvl ( t , x , n ) i = im1 + 1 ! ! denormalize tension factor ! sigmap = abs ( sigma ) * real ( n - 1 ) / ( x ( n ) - x ( 1 )) ! ! set up and perform differentiation ! del1 = t - x ( im1 ) del2 = x ( i ) - t dels = x ( i ) - x ( im1 ) sum = ( y ( i ) - y ( im1 )) / dels if ( sigmap /= 0. ) go to 1 fitp_curvd = sum + ( yp ( i ) * ( 2. * del1 * del1 - del2 * ( del1 + dels )) - & yp ( im1 ) * ( 2. * del2 * del2 - del1 * ( del2 + dels ))) & / ( 6. * dels ) return 1 sigdel = sigmap * dels call fitp_snhcsh ( ss , dummy , sigdel , - 1 ) call fitp_snhcsh ( dummy , c1 , sigmap * del1 , 1 ) call fitp_snhcsh ( dummy , c2 , sigmap * del2 , 1 ) fitp_curvd = sum + ( yp ( i ) * ( c1 - ss ) - yp ( im1 ) * ( c2 - ss )) / ( sigdel * sigmap * ( 1. + ss )) return end function fitp_curvd real function fitp_curvi ( xl , xu , n , x , y , yp , sigma ) integer n real xl , xu , x ( n ), y ( n ), yp ( n ), sigma ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this function integrates a curve specified by a spline ! under tension between two given limits. the subroutine ! curv1 should be called earlier to determine necessary ! parameters. ! ! on input-- ! !   xl and xu contain the upper and lower limits of inte- !   gration, respectively. (sl need not be less than or !   equal to xu, curvi (xl,xu,...) .eq. -curvi (xu,xl,...) ). ! !   n contains the number of points which were specified to !   determine the curve. ! !   x and y are arrays containing the abscissae and !   ordinates, respectively, of the specified points. ! !   yp is an array from subroutine curv1 containing !   the values of the second derivatives at the nodes. ! ! and ! !   sigma contains the tension factor (its sign is ignored). ! ! the parameters n, x, y, yp, and sigma should be input ! unaltered from the output of curv1. ! ! on output-- ! !   curvi contains the integral value. ! ! none of the input parameters are altered. ! ! this function references package modules intrvl and ! snhcsh. ! !----------------------------------------------------------- integer i , ilp1 , ilm1 , il , ium1 , iu real delu1 , delu2 , c2 , ss , cs , cu2 , cl1 , cl2 , cu1 real dell1 , dell2 , deli , c1 , ssign , sigmap real xxl , xxu , t1 , t2 , dummy , dels , sum , del1 , del2 ! ! denormalize tension factor ! sigmap = abs ( sigma ) * real ( n - 1 ) / ( x ( n ) - x ( 1 )) ! ! determine actual upper and lower bounds ! xxl = xl xxu = xu ssign = 1. if ( xl < xu ) go to 1 xxl = xu xxu = xl ssign = - 1. if ( xl > xu ) go to 1 ! ! return zero if xl .eq. xu ! fitp_curvi = 0. return ! ! search for proper intervals ! 1 ilm1 = fitp_intrvl ( xxl , x , n ) il = ilm1 + 1 ium1 = fitp_intrvl ( xxu , x , n ) iu = ium1 + 1 if ( il == iu ) go to 8 ! ! integrate from xxl to x(il) ! sum = 0. if ( xxl == x ( il )) go to 3 del1 = xxl - x ( ilm1 ) del2 = x ( il ) - xxl dels = x ( il ) - x ( ilm1 ) t1 = ( del1 + dels ) * del2 / ( 2. * dels ) t2 = del2 * del2 / ( 2. * dels ) sum = t1 * y ( il ) + t2 * y ( ilm1 ) if ( sigma == 0. ) go to 2 call fitp_snhcsh ( dummy , c1 , sigmap * del1 , 2 ) call fitp_snhcsh ( dummy , c2 , sigmap * del2 , 2 ) call fitp_snhcsh ( ss , cs , sigmap * dels , 3 ) sum = sum + (( dels * dels * ( cs - ss / 2. ) - del1 * del1 * ( c1 - ss / 2. )) & * yp ( il ) + del2 * del2 * ( c2 - ss / 2. ) * yp ( ilm1 )) / & ( sigmap * sigmap * dels * ( 1. + ss )) go to 3 2 sum = sum - t1 * t1 * dels * yp ( il ) / 6. & - t2 * ( del1 * ( del2 + dels ) + dels * dels ) * yp ( ilm1 ) / 1 2. ! ! integrate over interior intervals ! 3 if ( iu - il == 1 ) go to 6 ilp1 = il + 1 do i = ilp1 , ium1 dels = x ( i ) - x ( i - 1 ) sum = sum + ( y ( i ) + y ( i - 1 )) * dels / 2. if ( sigma == 0. ) go to 4 call fitp_snhcsh ( ss , cs , sigmap * dels , 3 ) sum = sum + ( yp ( i ) + yp ( i - 1 )) * dels * ( cs - ss / 2. ) / ( sigmap * sigmap * ( 1. + ss )) go to 5 4 sum = sum - ( yp ( i ) + yp ( i - 1 )) * dels * dels * dels / 2 4. 5 continue end do ! ! integrate from x(iu-1) to xxu ! 6 if ( xxu == x ( ium1 )) go to 10 del1 = xxu - x ( ium1 ) del2 = x ( iu ) - xxu dels = x ( iu ) - x ( ium1 ) t1 = del1 * del1 / ( 2. * dels ) t2 = ( del2 + dels ) * del1 / ( 2. * dels ) sum = sum + t1 * y ( iu ) + t2 * y ( ium1 ) if ( sigma == 0. ) go to 7 call fitp_snhcsh ( dummy , c1 , sigmap * del1 , 2 ) call fitp_snhcsh ( dummy , c2 , sigmap * del2 , 2 ) call fitp_snhcsh ( ss , cs , sigmap * dels , 3 ) sum = sum + ( yp ( iu ) * del1 * del1 * ( c1 - ss / 2. ) + yp ( ium1 ) * & ( dels * dels * ( cs - ss / 2. ) - del2 * del2 * ( c2 - ss / 2. ))) & / ( sigmap * sigmap * dels * ( 1. + ss )) go to 10 7 sum = sum - t1 * ( del2 * ( del1 + dels ) + dels * dels ) * yp ( iu ) / 1 2. - t2 * t2 * dels * yp ( ium1 ) / 6. go to 10 ! ! integrate from xxl to xxu ! 8 delu1 = xxu - x ( ium1 ) delu2 = x ( iu ) - xxu dell1 = xxl - x ( ium1 ) dell2 = x ( iu ) - xxl dels = x ( iu ) - x ( ium1 ) deli = xxu - xxl t1 = ( delu1 + dell1 ) * deli / ( 2. * dels ) t2 = ( delu2 + dell2 ) * deli / ( 2. * dels ) sum = t1 * y ( iu ) + t2 * y ( ium1 ) if ( sigma == 0. ) go to 9 call fitp_snhcsh ( dummy , cu1 , sigmap * delu1 , 2 ) call fitp_snhcsh ( dummy , cu2 , sigmap * delu2 , 2 ) call fitp_snhcsh ( dummy , cl1 , sigmap * dell1 , 2 ) call fitp_snhcsh ( dummy , cl2 , sigmap * dell2 , 2 ) call fitp_snhcsh ( ss , dummy , sigmap * dels , - 1 ) sum = sum + ( yp ( iu ) * ( delu1 * delu1 * ( cu1 - ss / 2. ) & - dell1 * dell1 * ( cl1 - ss / 2. )) & + yp ( ium1 ) * ( dell2 * dell2 * ( cl2 - ss / 2. ) & - delu2 * delu2 * ( cu2 - ss / 2. ))) / & ( sigmap * sigmap * dels * ( 1. + ss )) go to 10 9 sum = sum - t1 * ( delu2 * ( dels + delu1 ) + dell2 * ( dels + dell1 )) * & yp ( iu ) / 1 2. & - t2 * ( dell1 * ( dels + dell2 ) + delu1 * ( dels + delu2 )) * & yp ( ium1 ) / 1 2. ! ! correct sign and return ! 10 fitp_curvi = ssign * sum return end function fitp_curvi subroutine fitp_curvp1 ( n , x , y , p , yp , temp , sigma , ierr ) integer n , ierr real , dimension (:) :: x , y , yp , temp real :: p , sigma !!    real x(n),y(n),p,yp(n),temp(2*n),sigma !      real x(n),y(n),p,yp(n),temp(1),sigma ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this subroutine determines the parameters necessary to ! compute a periodic interpolatory spline under tension ! through a sequence of functional values. for actual ends ! of the curve may be specified or omitted.  for actual ! computation of points on the curve it is necessary to call ! the function curvp2. ! ! on input-- ! !   n is the number of values to be interpolated (n.ge.2). ! !   x is an array of the n increasing abscissae of the !   functional values. ! !   y is an array of the n ordinates of the values, (i. e. !   y(k) is the functional value corresponding to x(k) ). ! !   p is the period (p .gt. x(n)-x(1)). ! !   yp is an array of length at least n. ! !   temp is an array of length at least 2*n which is used !   for scratch storage. ! ! and ! !   sigma contains the tension factor.  this value indicates !   the curviness desired. if abs(sigma) is nearly zero !   (e.g. .001) the resulting curve is approximately a !   cubic spline. if abs(sigma) is large (e.g. 50.) the !   resulting curve is nearly a polygonal line. if sigma !   equals zero a cubic spline results.  a standard value !   for sigma is approximately 1. in absolute value. ! ! on output-- ! !   yp contains the values of the second derivative of the !   curve at the given nodes. ! !   ierr contains an error flag, !        = 0 for normal return, !        = 1 if n is less than 2, !        = 2 if p is less than or equal to x(n)-x(1), !        = 3 if x-values are not strictly increasing. ! ! and ! !  n, x, y, and sigma are unaltered. ! ! this subroutine references package modules terms and ! snhcsh. ! !----------------------------------------------------------- integer i , npibak , npi , ibak , nm1 , np1 real diag , diag2 , sdiag2 , ypn , dx2 , sigmap , delx1 real sdiag1 , delx2 , dx1 , diag1 nm1 = n - 1 np1 = n + 1 ierr = 0 if ( n <= 1 ) go to 6 if ( p <= x ( n ) - x ( 1 ) . or . p <= 0. ) go to 7 ! ! denormalize tension factor ! sigmap = abs ( sigma ) * real ( n ) / p ! ! set up right hand side and tridiagonal system for yp and ! perform forward elimination ! delx1 = p - ( x ( n ) - x ( 1 )) dx1 = ( y ( 1 ) - y ( n )) / delx1 call fitp_terms ( diag1 , sdiag1 , sigmap , delx1 ) delx2 = x ( 2 ) - x ( 1 ) if ( delx2 <= 0. ) go to 8 dx2 = ( y ( 2 ) - y ( 1 )) / delx2 call fitp_terms ( diag2 , sdiag2 , sigmap , delx2 ) diag = diag1 + diag2 yp ( 1 ) = ( dx2 - dx1 ) / diag temp ( np1 ) = - sdiag1 / diag temp ( 1 ) = sdiag2 / diag dx1 = dx2 diag1 = diag2 sdiag1 = sdiag2 if ( n == 2 ) go to 2 do i = 2 , nm1 npi = n + i delx2 = x ( i + 1 ) - x ( i ) if ( delx2 <= 0. ) go to 8 dx2 = ( y ( i + 1 ) - y ( i )) / delx2 call fitp_terms ( diag2 , sdiag2 , sigmap , delx2 ) diag = diag1 + diag2 - sdiag1 * temp ( i - 1 ) yp ( i ) = ( dx2 - dx1 - sdiag1 * yp ( i - 1 )) / diag temp ( npi ) = - temp ( npi - 1 ) * sdiag1 / diag temp ( i ) = sdiag2 / diag dx1 = dx2 diag1 = diag2 sdiag1 = sdiag2 end do 2 delx2 = p - ( x ( n ) - x ( 1 )) dx2 = ( y ( 1 ) - y ( n )) / delx2 call fitp_terms ( diag2 , sdiag2 , sigmap , delx2 ) yp ( n ) = dx2 - dx1 temp ( nm1 ) = temp ( 2 * n - 1 ) - temp ( nm1 ) if ( n == 2 ) go to 4 ! ! perform first step of back substitution ! do i = 3 , n ibak = np1 - i npibak = n + ibak yp ( ibak ) = yp ( ibak ) - temp ( ibak ) * yp ( ibak + 1 ) temp ( ibak ) = temp ( npibak ) - temp ( ibak ) * temp ( ibak + 1 ) end do 4 yp ( n ) = ( yp ( n ) - sdiag2 * yp ( 1 ) - sdiag1 * yp ( nm1 )) / & ( diag1 + diag2 + sdiag2 * temp ( 1 ) + sdiag1 * temp ( nm1 )) ! ! perform second step of back substitution ! ypn = yp ( n ) do i = 1 , nm1 yp ( i ) = yp ( i ) + temp ( i ) * ypn end do return ! ! too few points ! 6 ierr = 1 return ! ! period too small ! 7 ierr = 2 return ! ! x-values not strictly increasing ! 8 ierr = 3 return end subroutine fitp_curvp1 subroutine fitp_curvps ( n , x , y , p , d , isw , s , eps , ys , ysp , sigma , temp , ierr ) integer n , isw , ierr real x ( n ), y ( n ), p , d ( n ), s , eps , ys ( n ), ysp ( n ), sigma , temp ( n , 11 ) ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this subroutine determines the parameters necessary to ! compute a periodic smoothing spline under tension. for a ! given increasing sequence of abscissae (x(i)), i = 1,...,n ! and associated ordinates (y(i)), i = 1,...,n, letting p be ! the period, x(n+1) = x(1)+p, and y(n+1) = y(1), the ! function determined minimizes the summation from i = 1 to ! n of the square of the second derivative of f plus sigma ! squared times the difference of the first derivative of f ! and (f(x(i+1))-f(x(i)))/(x(i+1)-x(i)) squared, over all ! functions f with period p and two continuous derivatives ! such that the summation of the square of ! (f(x(i))-y(i))/d(i) is less than or equal to a given ! constant s, where (d(i)), i = 1,...,n are a given set of ! observation weights. the function determined is a periodic ! spline under tension with third derivative discontinuities ! at (x(i)) i = 1,...,n (and all periodic translations of ! these values). for actual computation of points on the ! curve it is necessary to call the function curvp2. the ! determination of the curve is performed by subroutine ! curvpp, the subroutin curvps only decomposes the workspace ! for curvpp. ! ! on input-- ! !   n is the number of values to be smoothed (n.ge.2). ! !   x is an array of the n increasing abscissae of the !   values to be smoothed. ! !   y is an array of the n ordinates of the values to be !   smoothed, (i. e. y(k) is the functional value !   corresponding to x(k) ). ! !   p is the period (p .gt. x(n)-x(1)). ! !   d is a parameter containing the observation weights. !   this may either be an array of length n or a scalar !   (interpreted as a constant). the value of d !   corresponding to the observation (x(k),y(k)) should !   be an approximation to the standard deviation of error. ! !   isw contains a switch indicating whether the parameter !   d is to be considered a vector or a scalar, !          = 0 if d is an array of length n, !          = 1 if d is a scalar. ! !   s contains the value controlling the smoothing. this !   must be non-negative. for s equal to zero, the !   subroutine does interpolation, larger values lead to !   smoother funtions. if parameter d contains standard !   deviation estimates, a reasonable value for s is !   float(n). ! !   eps contains a tolerance on the relative precision to !   which s is to be interpreted. this must be greater than !   or equal to zero and less than or equal to one. a !   reasonable value for eps is sqrt(2./float(n)). ! !   ys is an array of length at least n. ! !   ysp is an array of length at least n. ! !   sigma contains the tension factor. this value indicates !   the degree to which the first derivative part of the !   smoothing functional is emphasized. if sigma is nearly !   zero (e. g. .001) the resulting curve is approximately a !   cubic spline. if sigma is large (e. g. 50.) the !   resulting curve is nearly a polygonal line. if sigma !   equals zero a cubic spline results. a standard value for !   sigma is approximately 1. ! ! and ! !   temp is an array of length at least 11*n which is used !   for scratch storage. ! ! on output-- ! !   ys contains the smoothed ordinate values. ! !   ysp contains the values of the second derivative of the !   smoothed curve at the given nodes. ! !   ierr contains an error flag, !        = 0 for normal return, !        = 1 if n is less than 2, !        = 2 if s is negative, !        = 3 if eps is negative or greater than one, !        = 4 if x-values are not strictly increasing, !        = 5 if a d-value is non-positive, !        = 6 if p is less than or equal to x(n)-x(1). ! ! and ! !   n, x, y, p, d, isw, s, eps, and sigma are unaltered. ! ! this subroutine references package modules curvpp, terms, ! and snhcsh. ! !----------------------------------------------------------- ! ! decompose temp into eleven arrays and call curvpp ! call fitp_curvpp ( n , x , y , p , d , isw , s , eps , ys , ysp , sigma , & temp ( 1 , 1 ), temp ( 1 , 2 ), temp ( 1 , 3 ), temp ( 1 , 4 ), & temp ( 1 , 5 ), temp ( 1 , 6 ), temp ( 1 , 7 ), temp ( 1 , 8 ), & temp ( 1 , 9 ), temp ( 1 , 10 ), temp ( 1 , 11 ), ierr ) return end subroutine fitp_curvps real function fitp_curvp2 ( t , n , x , y , p , yp , sigma ) integer n real , dimension (:) :: x , y , yp real :: t , p , sigma !    real t,x(n),y(n),p,yp(n),sigma ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this function interpolates a curve at a given point using ! a periodic spline under tension. the subroutine curvp1 ! should be called earlier to determine certain necessary ! parameters. ! ! on input-- ! !   t contains a real value to be mapped onto the interpo- !   lating curve. ! !   n contains the number of points which were specified to !   determine the curve. ! !   x and y are arrays containing the abscissae and !   ordinates, respectively, of the specified points. ! !   p contains the period. ! !   yp is an array of second derivative values of the curve !   at the nodes. ! ! and ! !   sigma contains the tension factor (its sign is ignored). ! ! the parameters n, x, y, p, yp, and sigma should be input ! unaltered from the output of curvp1. ! ! on output-- ! !   curvp2 contains the interpolated value. ! ! none of the input parameters are altered. ! ! this function references package modules intrvp and ! snhcsh. ! !----------------------------------------------------------- integer i , im1 real ss , sigdel , sum , s2 , s1 , dummy real tp , sigmap , dels , del2 , del1 ! ! determine interval ! im1 = fitp_intrvp ( t , x , n , p , tp ) i = im1 + 1 ! ! denormalize tension factor ! sigmap = abs ( sigma ) * real ( n ) / p ! ! set up and perform interpolation ! del1 = tp - x ( im1 ) if ( im1 == n ) go to 1 del2 = x ( i ) - tp dels = x ( i ) - x ( im1 ) go to 2 1 i = 1 del2 = x ( 1 ) + p - tp dels = p - ( x ( n ) - x ( 1 )) 2 sum = ( y ( i ) * del1 + y ( im1 ) * del2 ) / dels if ( sigmap /= 0. ) go to 3 fitp_curvp2 = sum - del1 * del2 * ( yp ( i ) * ( del1 + dels ) + yp ( im1 ) * ( del2 + dels )) / ( 6. * dels ) return 3 sigdel = sigmap * dels call fitp_snhcsh ( ss , dummy , sigdel , - 1 ) call fitp_snhcsh ( s1 , dummy , sigmap * del1 , - 1 ) call fitp_snhcsh ( s2 , dummy , sigmap * del2 , - 1 ) fitp_curvp2 = sum + ( yp ( i ) * del1 * ( s1 - ss ) + yp ( im1 ) * del2 * ( s2 - ss )) / ( sigdel * sigmap * ( 1. + ss )) end function fitp_curvp2 real function fitp_curvpd ( t , n , x , y , p , yp , sigma ) integer n real t , x ( n ), y ( n ), p , yp ( n ), sigma ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this function is the derivative of curvp2 ! interpolates a curve at a given point using ! a periodic spline under tension. the subroutine curvp1 ! should be called earlier to determine certain necessary ! parameters. ! ! on input-- ! !   t contains a real value to be mapped onto the interpo- !   lating curve. ! !   n contains the number of points which were specified to !   determine the curve. ! !   x and y are arrays containing the abscissae and !   ordinates, respectively, of the specified points. ! !   p contains the period. ! !   yp is an array of second derivative values of the curve !   at the nodes. ! ! and ! !   sigma contains the tension factor (its sign is ignored). ! ! the parameters n, x, y, p, yp, and sigma should be input ! unaltered from the output of curvp1. ! ! on output-- ! !   curvpd contains the interpolated derivative ! ! none of the input parameters are altered. ! ! this function references package modules intrvp and ! snhcsh. ! !----------------------------------------------------------- integer i , im1 real ss , sigdel , sum , c2 , c1 , dummy real tp , sigmap , dels , del2 , del1 ! ! determine interval ! im1 = fitp_intrvp ( t , x , n , p , tp ) i = im1 + 1 ! ! denormalize tension factor ! sigmap = abs ( sigma ) * real ( n ) / p ! ! set up and perform interpolation ! del1 = tp - x ( im1 ) if ( im1 == n ) go to 1 del2 = x ( i ) - tp dels = x ( i ) - x ( im1 ) go to 2 1 i = 1 del2 = x ( 1 ) + p - tp dels = p - ( x ( n ) - x ( 1 )) 2 sum = ( y ( i ) - y ( im1 )) / dels if ( sigmap /= 0. ) go to 3 fitp_curvpd = sum + ( yp ( i ) * ( 2. * del1 * del1 - del2 * ( del1 + dels )) - & yp ( im1 ) * ( 2. * del2 * del2 - del1 * ( del2 + dels ))) & / ( 6. * dels ) return 3 sigdel = sigmap * dels call fitp_snhcsh ( ss , dummy , sigdel , - 1 ) call fitp_snhcsh ( dummy , c1 , sigmap * del1 , - 1 ) call fitp_snhcsh ( dummy , c2 , sigmap * del2 , - 1 ) fitp_curvpd = sum + ( yp ( i ) * ( c1 - ss ) - yp ( im1 ) * ( c2 - ss )) / ( sigdel * sigmap * ( 1. + ss )) return end function fitp_curvpd real function fitp_curvpi ( xl , xu , n , x , y , p , yp , sigma ) integer n real xl , xu , x ( n ), y ( n ), p , yp ( n ), sigma ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this function integrates a curve specified by a periodic ! spline under tension between two given limits. the ! subroutine curvp1 should be called earlier to determine ! necessary parameters. ! ! on input-- ! !   xl and xu contain the upper and lower limits of inte- !   gration, respectively. (sl need not be less than or !   equal to xu, curvpi (xl,xu,...) .eq. -curvpi (xu,xl,...) ). ! !   n contains the number of points which were specified to !   determine the curve. ! !   x and y are arrays containing the abscissae and !   ordinates, respectively, of the specified points. ! !   p contains the period. ! !   yp is an array from subroutine curvp1 containing !   the values of the second derivatives at the nodes. ! ! and ! !   sigma contains the tension factor (its sign is ignored). ! ! the parameters n, x, y, p, yp, and sigma should be input ! unaltered from the output of curvp1. ! ! on output-- ! ! !   curvpi contains the integral value. ! ! none of the input parameters are altered. ! ! this function references package modules intrvp and ! snhcsh. ! !-------------------------------------------------------------- integer np1 , im1 , ii , iup1 , ilp1 , ideltp real s7 , s6 , s3 , c2 , c1 , s5 , s4 , cl1 , cu2 , cu1 , si , so real cl2 , delu2 , delu1 , s8 , deli , dell2 , dell1 , dummy integer ium1 , il , isave , isign , lper , ilm1 , iu , i real xxu , xsave , x1pp , sigmap , xxl , xil , del1 , s2 , cs real t2 , t1 , del2 , s1 , xiu , ss , dels integer uper logical bdy ! ! denormalize tension factor ! sigmap = abs ( sigma ) * real ( n ) / p ! ! determine actual upper and lower bounds ! x1pp = x ( 1 ) + p isign = 1 ilm1 = fitp_intrvp ( xl , x , n , p , xxl ) lper = int (( xl - x ( 1 )) / p ) if ( xl < x ( 1 )) lper = lper - 1 ium1 = fitp_intrvp ( xu , x , n , p , xxu ) uper = int (( xu - x ( 1 )) / p ) if ( xu < x ( 1 )) uper = uper - 1 ideltp = uper - lper bdy = real ( ideltp ) * ( xxu - xxl ) < 0. if (( ideltp == 0 . and . xxu < xxl ) . or . ideltp < 0 ) isign = - 1 if ( bdy ) ideltp = ideltp - isign if ( xxu >= xxl ) go to 1 xsave = xxl xxl = xxu xxu = xsave isave = ilm1 ilm1 = ium1 ium1 = isave 1 il = ilm1 + 1 if ( ilm1 == n ) il = 1 xil = x ( il ) if ( ilm1 == n ) xil = x1pp iu = ium1 + 1 if ( ium1 == n ) iu = 1 xiu = x ( iu ) if ( ium1 == n ) xiu = x1pp s1 = 0. if ( ilm1 == 1 . or . ( ideltp == 0 . and . . not . bdy )) go to 4 ! ! integrate from x(1) to x(ilm1), store in s1 ! do i = 2 , ilm1 dels = x ( i ) - x ( i - 1 ) s1 = s1 + ( y ( i ) + y ( i - 1 )) * dels / 2. if ( sigma == 0. ) go to 2 call fitp_snhcsh ( ss , cs , sigmap * dels , 3 ) s1 = s1 + ( yp ( i ) + yp ( i - 1 )) * dels * ( cs - ss / 2. ) / ( sigmap * sigmap * ( 1. + ss )) cycle 2 s1 = s1 - ( yp ( i ) + yp ( i - 1 )) * dels * dels * dels / 2 4. end do 4 s2 = 0. if ( x ( ilm1 ) >= xxl . or . ( ideltp == 0 . and . . not . bdy )) go to 6 ! ! integrate from x(ilm1) to xxl, store in s2 ! del1 = xxl - x ( ilm1 ) del2 = xil - xxl dels = xil - x ( ilm1 ) t1 = del1 * del1 / ( 2. * dels ) t2 = ( del2 + dels ) * del1 / ( 2. * dels ) s2 = t1 * y ( il ) + t2 * y ( ilm1 ) if ( sigma == 0. ) go to 5 call fitp_snhcsh ( dummy , c1 , sigmap * del1 , 2 ) call fitp_snhcsh ( dummy , c2 , sigmap * del2 , 2 ) call fitp_snhcsh ( ss , cs , sigmap * dels , 3 ) s2 = s2 + ( yp ( il ) * del1 * del1 * ( c1 - ss / 2. ) + yp ( ilm1 ) * & ( dels * dels * ( cs - ss / 2. ) - del2 * del2 * ( c2 - ss / 2. ))) & / ( sigmap * sigmap * dels * ( 1. + ss )) go to 6 5 s2 = s2 - t1 * ( del2 * ( del1 + dels ) & + dels * dels ) * yp ( il ) / 1 2. & - t2 * t2 * dels * yp ( ilm1 ) / 6. 6 s3 = 0. if ( xxl >= xil . or . ( ideltp == 0 . and . bdy ) . or . ilm1 == ium1 ) go to 8 ! ! integrate from xxl to xil, store in s3 ! del1 = xxl - x ( ilm1 ) del2 = xil - xxl dels = xil - x ( ilm1 ) t1 = ( del1 + dels ) * del2 / ( 2. * dels ) t2 = del2 * del2 / ( 2. * dels ) s3 = t1 * y ( il ) + t2 * y ( ilm1 ) if ( sigma == 0. ) go to 7 call fitp_snhcsh ( dummy , c1 , sigmap * del1 , 2 ) call fitp_snhcsh ( dummy , c2 , sigmap * del2 , 2 ) call fitp_snhcsh ( ss , cs , sigmap * dels , 3 ) s3 = s3 + (( dels * dels * ( cs - ss / 2. ) - del1 * del1 * ( c1 - ss / 2. )) & * yp ( il ) + del2 * del2 * ( c2 - ss / 2. ) * yp ( ilm1 )) / & ( sigmap * sigmap * dels * ( 1. + ss )) go to 8 7 s3 = s3 - t1 * t1 * dels * yp ( il ) / 6. & - t2 * ( del1 * ( del2 + dels ) + dels * dels ) * & yp ( ilm1 ) / 1 2. 8 s4 = 0. if ( ilm1 >= ium1 - 1 . or . ( ideltp == 0 . and . bdy )) go to 11 ! ! integrate from xil to x(ium1), store in s4 ! ilp1 = il + 1 do i = ilp1 , ium1 dels = x ( i ) - x ( i - 1 ) s4 = s4 + ( y ( i ) + y ( i - 1 )) * dels / 2. if ( sigma == 0. ) go to 9 call fitp_snhcsh ( ss , cs , sigmap * dels , 3 ) s4 = s4 + ( yp ( i ) + yp ( i - 1 )) * dels * ( cs - ss / 2. ) / ( sigmap * sigmap * ( 1. + ss )) cycle 9 s4 = s4 - ( yp ( i ) + yp ( i - 1 )) * dels * dels * dels / 2 4. end do 11 s5 = 0. if ( x ( ium1 ) >= xxu . or . ( ideltp == 0 . and . bdy ) . or . ilm1 == ium1 ) go to 13 ! ! integrate from x(ium1) to xxu, store in s5 ! del1 = xxu - x ( ium1 ) del2 = xiu - xxu dels = xiu - x ( ium1 ) t1 = del1 * del1 / ( 2. * dels ) t2 = ( del2 + dels ) * del1 / ( 2. * dels ) s5 = t1 * y ( iu ) + t2 * y ( ium1 ) if ( sigma == 0. ) go to 12 call fitp_snhcsh ( dummy , c1 , sigmap * del1 , 2 ) call fitp_snhcsh ( dummy , c2 , sigmap * del2 , 2 ) call fitp_snhcsh ( ss , cs , sigmap * dels , 3 ) s5 = s5 + ( yp ( iu ) * del1 * del1 * ( c1 - ss / 2. ) + yp ( ium1 ) * & ( dels * dels * ( cs - ss / 2. ) - del2 * del2 * ( c2 - ss / 2. ))) & / ( sigmap * sigmap * dels * ( 1. + ss )) go to 13 12 s5 = s5 - t1 * ( del2 * ( del1 + dels ) + dels * dels ) * yp ( iu ) / 1 2. - t2 * t2 * dels * yp ( ium1 ) / 6. 13 s6 = 0. if ( xxu >= xiu . or . ( ideltp == 0 . and . . not . bdy )) go to 15 ! ! integrate from xxu to xiu, store in s6 ! del1 = xxu - x ( ium1 ) del2 = xiu - xxu dels = xiu - x ( ium1 ) t1 = ( del1 + dels ) * del2 / ( 2. * dels ) t2 = del2 * del2 / ( 2. * dels ) s6 = t1 * y ( iu ) + t2 * y ( ium1 ) if ( sigma == 0. ) go to 14 call fitp_snhcsh ( dummy , c1 , sigmap * del1 , 2 ) call fitp_snhcsh ( dummy , c2 , sigmap * del2 , 2 ) call fitp_snhcsh ( ss , cs , sigmap * dels , 3 ) s6 = s6 + (( dels * dels * ( cs - ss / 2. ) - del1 * del1 * ( c1 - ss / 2. )) & * yp ( iu ) + del2 * del2 * ( c2 - ss / 2. ) * yp ( ium1 )) / & ( sigmap * sigmap * dels * ( 1. + ss )) go to 15 14 s6 = s6 - t1 * t1 * dels * yp ( iu ) / 6. - t2 * ( del1 * ( del2 + dels ) + dels * dels ) * yp ( ium1 ) / 1 2. 15 s7 = 0. if ( iu == 1 . or . ( ideltp == 0 . and . . not . bdy )) go to 18 ! ! integrate from xiu to x1pp, store in s7 ! np1 = n + 1 iup1 = iu + 1 do ii = iup1 , np1 im1 = ii - 1 i = ii if ( i == np1 ) i = 1 dels = x ( i ) - x ( im1 ) if ( dels <= 0. ) dels = dels + p s7 = s7 + ( y ( i ) + y ( im1 )) * dels / 2. if ( sigma == 0. ) go to 16 call fitp_snhcsh ( ss , cs , sigmap * dels , 3 ) s7 = s7 + ( yp ( i ) + yp ( im1 )) * dels * ( cs - ss / 2. ) / ( sigmap * sigmap * ( 1. + ss )) cycle 16 s7 = s7 - ( yp ( i ) + yp ( im1 )) * dels * dels * dels / 2 4. end do 18 s8 = 0. if ( ilm1 < ium1 . or . ( ideltp == 0 . and . bdy )) go to 20 ! ! integrate from xxl to xxu, store in s8 ! delu1 = xxu - x ( ium1 ) delu2 = xiu - xxu dell1 = xxl - x ( ium1 ) dell2 = xiu - xxl dels = xiu - x ( ium1 ) deli = xxu - xxl t1 = ( delu1 + dell1 ) * deli / ( 2. * dels ) t2 = ( delu2 + dell2 ) * deli / ( 2. * dels ) s8 = t1 * y ( iu ) + t2 * y ( ium1 ) if ( sigma == 0. ) go to 19 call fitp_snhcsh ( dummy , cu1 , sigmap * delu1 , 2 ) call fitp_snhcsh ( dummy , cu2 , sigmap * delu2 , 2 ) call fitp_snhcsh ( dummy , cl1 , sigmap * dell1 , 2 ) call fitp_snhcsh ( dummy , cl2 , sigmap * dell2 , 2 ) call fitp_snhcsh ( ss , dummy , sigmap * dels , - 1 ) s8 = s8 + ( yp ( iu ) * ( delu1 * delu1 * ( cu1 - ss / 2. ) & - dell1 * dell1 * ( cl1 - ss / 2. )) & + yp ( ium1 ) * ( dell2 * dell2 * ( cl2 - ss / 2. ) & - delu2 * delu2 * ( cu2 - ss / 2. ))) / & ( sigmap * sigmap * dels * ( 1. + ss )) go to 20 19 s8 = s8 - t1 * ( delu2 * ( dels + delu1 ) & + dell2 * ( dels + dell1 )) * yp ( iu ) / 1 2. & - t2 * ( dell1 * ( dels + dell2 ) & + delu1 * ( dels + delu2 )) * yp ( ium1 ) / 1 2. 20 so = s1 + s2 + s6 + s7 si = s3 + s4 + s5 + s8 if ( bdy ) go to 21 fitp_curvpi = real ( ideltp ) * ( so + si ) + real ( isign ) * si return 21 fitp_curvpi = real ( ideltp ) * ( so + si ) + real ( isign ) * so return end function fitp_curvpi subroutine fitp_kurv1 ( n , x , y , slp1 , slpn , islpsw , xp , yp , temp , s , sigma , ierr ) integer n , islpsw , ierr real x ( n ), y ( n ), slp1 , slpn , xp ( n ), yp ( n ), temp ( n ), s ( n ), sigma ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this subroutine determines the parameters necessary to ! compute a spline under tension forming a curve in the ! plane and passing through a sequence of pairs (x(1),y(1)), ! ...,(x(n),y(n)). for actual computation of points on the ! curve it is necessary to call the subroutine kurv2. ! ! on input-- ! !   n is the number of points to be interpolated (n.ge.2). ! !   x is an array containing the n x-coordinates of the !   points. ! !   y is an array containing the n y-coordinates of the !   points. (adjacent x-y pairs must be distinct, i. e. !   either x(i) .ne. x(i+1) or y(i) .ne. y(i+1), for !   i = 1,...,n-1.) ! !   slp1 and slpn contain the desired values for the angles !   (in radians) of the slope at (x(1),y(1)) and (x(n),y(n)) !   respectively. the angles are measured counter-clock- !   wise from the x-axis and the positive sense of the curve !   is assumed to be that moving from point 1 to point n. !   the user may omit values for either or both of these !   parameters and signal this with islpsw. ! !   islpsw contains a switch indicating which slope data !   should be used and which should be estimated by this !   subroutine, !          = 0 if slp1 and slpn are to be used, !          = 1 if slp1 is to be used but not slpn, !          = 2 if slpn is to be used but not slp1, !          = 3 if both slp1 and slpn are to be estimated !              internally. ! !   xp and yp are arrays of length at least n. ! !   temp is an array of length at least n which is used !   for scratch storage. ! !   s is an array of length at least n. ! ! and ! !   sigma contains the tension factor. this value indicates !   the curviness desired. if abs(sigma) is nearly zero !   (e.g. .001) the resulting curve is approximately a cubic !   spline. if abs(sigma) is large (e. g. 50.) the resulting !   curve is nearly a polygonal line. if sigma equals zero a !   cubic spline results. a standard value for sigma is !   approximately 1. in absolute value. ! ! on output-- ! !   xp and yp contain information about the curvature of the !   curve at the given nodes. ! !   s contains the polygonal arclengths of the curve. ! !   ierr contains an error flag, !        = 0 for normal return, !        = 1 if n is less than 2, !        = 2 if adjacent coordinate pairs coincide. ! ! and ! !   n, x, y, slp1, slpn, islpsw, and sigma are unaltered. ! ! this subroutine references package modules ceez, terms, ! and snhcsh. ! !----------------------------------------------------------- integer ibak , im1 , nm1 , np1 , i real dx1 , dy1 , diag1 , delsnm , slppnx , slppny , delsn real diag , diagin , sdiag1 , sdiag2 , dx2 , dy2 , diag2 real sigmap , slpp1x , slpp1y , dels1 , sx , sy , delt real c3 , dels2 , c1 , c2 nm1 = n - 1 np1 = n + 1 ierr = 0 if ( n <= 1 ) go to 11 ! ! determine polygonal arclengths ! s ( 1 ) = 0. do i = 2 , n im1 = i - 1 s ( i ) = s ( im1 ) + sqrt (( x ( i ) - x ( im1 )) ** 2 + ( y ( i ) - y ( im1 )) ** 2 ) end do ! ! denormalize tension factor ! sigmap = abs ( sigma ) * real ( n - 1 ) / s ( n ) ! ! approximate end slopes ! if ( islpsw >= 2 ) go to 2 slpp1x = cos ( slp1 ) slpp1y = sin ( slp1 ) go to 4 2 dels1 = s ( 2 ) - s ( 1 ) dels2 = dels1 + dels1 if ( n > 2 ) dels2 = s ( 3 ) - s ( 1 ) if ( dels1 == 0. . or . dels2 == 0. ) go to 12 call fitp_ceez ( dels1 , dels2 , sigmap , c1 , c2 , c3 , n ) sx = c1 * x ( 1 ) + c2 * x ( 2 ) sy = c1 * y ( 1 ) + c2 * y ( 2 ) if ( n == 2 ) go to 3 sx = sx + c3 * x ( 3 ) sy = sy + c3 * y ( 3 ) 3 delt = sqrt ( sx * sx + sy * sy ) slpp1x = sx / delt slpp1y = sy / delt 4 if ( islpsw == 1 . or . islpsw == 3 ) go to 5 slppnx = cos ( slpn ) slppny = sin ( slpn ) go to 7 5 delsn = s ( n ) - s ( nm1 ) delsnm = delsn + delsn if ( n > 2 ) delsnm = s ( n ) - s ( n - 2 ) if ( delsn == 0. . or . delsnm == 0. ) go to 12 call fitp_ceez ( - delsn , - delsnm , sigmap , c1 , c2 , c3 , n ) sx = c1 * x ( n ) + c2 * x ( nm1 ) sy = c1 * y ( n ) + c2 * y ( nm1 ) if ( n == 2 ) go to 6 sx = sx + c3 * x ( n - 2 ) sy = sy + c3 * y ( n - 2 ) 6 delt = sqrt ( sx * sx + sy * sy ) slppnx = sx / delt slppny = sy / delt ! ! set up right hand sides and tridiagonal system for xp and ! yp and perform forward elimination ! 7 dx1 = ( x ( 2 ) - x ( 1 )) / s ( 2 ) dy1 = ( y ( 2 ) - y ( 1 )) / s ( 2 ) call fitp_terms ( diag1 , sdiag1 , sigmap , s ( 2 )) xp ( 1 ) = ( dx1 - slpp1x ) / diag1 yp ( 1 ) = ( dy1 - slpp1y ) / diag1 temp ( 1 ) = sdiag1 / diag1 if ( n == 2 ) go to 9 do i = 2 , nm1 dels2 = s ( i + 1 ) - s ( i ) if ( dels2 == 0. ) go to 12 dx2 = ( x ( i + 1 ) - x ( i )) / dels2 dy2 = ( y ( i + 1 ) - y ( i )) / dels2 call fitp_terms ( diag2 , sdiag2 , sigmap , dels2 ) diag = diag1 + diag2 - sdiag1 * temp ( i - 1 ) diagin = 1. / diag xp ( i ) = ( dx2 - dx1 - sdiag1 * xp ( i - 1 )) * diagin yp ( i ) = ( dy2 - dy1 - sdiag1 * yp ( i - 1 )) * diagin temp ( i ) = sdiag2 * diagin dx1 = dx2 dy1 = dy2 diag1 = diag2 sdiag1 = sdiag2 end do 9 diag = diag1 - sdiag1 * temp ( nm1 ) xp ( n ) = ( slppnx - dx1 - sdiag1 * xp ( nm1 )) / diag yp ( n ) = ( slppny - dy1 - sdiag1 * yp ( nm1 )) / diag ! ! perform back substitution ! do i = 2 , n ibak = np1 - i xp ( ibak ) = xp ( ibak ) - temp ( ibak ) * xp ( ibak + 1 ) yp ( ibak ) = yp ( ibak ) - temp ( ibak ) * yp ( ibak + 1 ) end do return ! ! too few points ! 11 ierr = 1 return ! ! coincident adjacent points ! 12 ierr = 2 return end subroutine fitp_kurv1 subroutine fitp_kurv2 ( t , xs , ys , n , x , y , xp , yp , s , sigma ) integer n real t , xs , ys , x ( n ), y ( n ), xp ( n ), yp ( n ), s ( n ), sigma ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this subroutine performs the mapping of points in the ! interval (0.,1.) onto a curve in the plane. the subroutine ! kurv1 should be called earlier to determine certain ! necessary parameters. the resulting curve has a parametric ! representation both of whose components are splines under ! tension and functions of the polygonal arclength ! parameter. ! ! on input-- ! !   t contains a real value to be mapped to a point on the !   curve. the interval (0.,1.) is mapped onto the entire !   curve, with 0. mapping to (x(1),y(1)) and 1. mapping !   to (x(n),y(n)). values outside this interval result in !   extrapolation. ! !   n contains the number of points which were specified !   to determine the curve. ! !   x and y are arrays containing the x- and y-coordinates !   of the specified points. ! !   xp and yp are the arrays output from kurv1 containing !   curvature information. ! !   s is an array containing the polygonal arclengths of !   the curve. ! ! and ! !   sigma contains the tension factor (its sign is ignored). ! ! the parameters n, x, y, xp, yp, s, and sigma should be ! input unaltered from the output of kurv1. ! ! on output-- ! !   xs and ys contain the x- and y-coordinates of the image !   point on the curve. ! ! none of the input parameters are altered. ! ! this subroutine references package modules intrvl and ! snhcsh. ! !----------------------------------------------------------- integer i , im1 real c2 , sigdel , d , c1 , s1 , s2 , ss , dummy real sigmap , tn , del1 , sumx , sumy , del2 , dels ! ! determine interval ! tn = s ( n ) * t im1 = fitp_intrvl ( tn , s , n ) i = im1 + 1 ! ! denormalize tension factor ! sigmap = abs ( sigma ) * real ( n - 1 ) / s ( n ) ! ! set up and perform interpolation ! del1 = tn - s ( im1 ) del2 = s ( i ) - tn dels = s ( i ) - s ( im1 ) sumx = ( x ( i ) * del1 + x ( im1 ) * del2 ) / dels sumy = ( y ( i ) * del1 + y ( im1 ) * del2 ) / dels if ( sigmap /= 0. ) go to 1 d = del1 * del2 / ( 6. * dels ) c1 = ( del1 + dels ) * d c2 = ( del2 + dels ) * d xs = sumx - xp ( i ) * c1 - xp ( im1 ) * c2 ys = sumy - yp ( i ) * c1 - yp ( im1 ) * c2 return 1 sigdel = sigmap * dels call fitp_snhcsh ( ss , dummy , sigdel , - 1 ) call fitp_snhcsh ( s1 , dummy , sigmap * del1 , - 1 ) call fitp_snhcsh ( s2 , dummy , sigmap * del2 , - 1 ) d = sigdel * sigmap * ( 1. + ss ) c1 = del1 * ( s1 - ss ) / d c2 = del2 * ( s2 - ss ) / d xs = sumx + xp ( i ) * c1 + xp ( im1 ) * c2 ys = sumy + yp ( i ) * c1 + yp ( im1 ) * c2 return end subroutine fitp_kurv2 subroutine fitp_kurvd ( t , xs , ys , xst , yst , xstt , ystt , n , x , y , xp , yp , s , sigma ) integer n real t , xs , ys , xst , yst , xstt , ystt , x ( n ), y ( n ), xp ( n ), yp ( n ), s ( n ), sigma ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this subroutine performs the mapping of points in the ! interval (0.,1.) onto a curve in the plane. it also ! returns the first and second derivatives of the component ! functions. the subroutine kurv1 should be called earlier ! to determine certain necessary parameters. the resulting ! curve has a parametric representation both of whose ! components are splines under tension and functions of the ! polygonal arclength parameter. ! ! on input-- ! !   t contains a real value to be mapped to a point on the !   curve. the interval (0.,1.) is mapped onto the entire !   curve, with 0. mapping to (x(1),y(1)) and 1. mapping !   to (x(n),y(n)). values outside this interval result in !   extrapolation. ! !   n contains the number of points which were specified !   to determine the curve. ! !   x and y are arrays containing the x- and y-coordinates !   of the specified points. ! !   xp and yp are the arrays output from kurv1 containing !   curvature information. ! !   s is an array containing the polygonal arclengths of !   the curve. ! ! and ! !   sigma contains the tension factor (its sign is ignored). ! ! the parameters n, x, y, xp, yp, s, and sigma should be ! input unaltered from the output of kurv1. ! ! on output-- ! !   xs and ys contain the x- and y-coordinates of the image !   point on the curve. xst and yst contain the first !   derivatives of the x- and y-components of the mapping !   with respect to t. xstt and ystt contain the second !   derivatives of the x- and y-components of the mapping !   with respect to t. ! ! none of the input parameters are altered. ! ! this subroutine references package modules intrvl and ! snhcsh. ! !----------------------------------------------------------- integer im1 , i real ctt1 , ctt2 , sigdel , c2 , ct1 , ct2 , co1 , s2 , co2 , ss real dummy , s1 , c1 , sigmap , del1 , del2 , tn , dels , sumyt real dels6 , d , sumx , sumy , sumxt ! ! determine interval ! tn = s ( n ) * t im1 = fitp_intrvl ( tn , s , n ) i = im1 + 1 ! ! denormalize tension factor ! sigmap = abs ( sigma ) * real ( n - 1 ) / s ( n ) ! ! set up and perform interpolation ! del1 = tn - s ( im1 ) del2 = s ( i ) - tn dels = s ( i ) - s ( im1 ) sumx = ( x ( i ) * del1 + x ( im1 ) * del2 ) / dels sumy = ( y ( i ) * del1 + y ( im1 ) * del2 ) / dels sumxt = s ( n ) * ( x ( i ) - x ( im1 )) / dels sumyt = s ( n ) * ( y ( i ) - y ( im1 )) / dels if ( sigmap /= 0. ) go to 1 dels6 = 6. * dels d = del1 * del2 / dels6 c1 = - ( del1 + dels ) * d c2 = - ( del2 + dels ) * d dels6 = dels6 / s ( n ) ct1 = ( 2. * del1 * del1 - del2 * ( del1 + dels )) / dels6 ct2 = - ( 2. * del2 * del2 - del1 * ( del2 + dels )) / dels6 dels = dels / ( s ( n ) * s ( n )) ctt1 = del1 / dels ctt2 = del2 / dels go to 2 1 sigdel = sigmap * dels call fitp_snhcsh ( ss , dummy , sigdel , - 1 ) call fitp_snhcsh ( s1 , co1 , sigmap * del1 , 0 ) call fitp_snhcsh ( s2 , co2 , sigmap * del2 , 0 ) d = sigdel * sigmap * ( 1. + ss ) c1 = del1 * ( s1 - ss ) / d c2 = del2 * ( s2 - ss ) / d ct1 = ( co1 - ss ) * s ( n ) / d ct2 = - ( co2 - ss ) * s ( n ) / d ctt1 = del1 * ( 1. + s1 ) * s ( n ) * s ( n ) / ( dels * ( 1. + ss )) ctt2 = del2 * ( 1. + s2 ) * s ( n ) * s ( n ) / ( dels * ( 1. + ss )) 2 xs = sumx + c1 * xp ( i ) + c2 * xp ( im1 ) ys = sumy + c1 * yp ( i ) + c2 * yp ( im1 ) xst = sumxt + ct1 * xp ( i ) + ct2 * xp ( im1 ) yst = sumyt + ct1 * yp ( i ) + ct2 * yp ( im1 ) xstt = ctt1 * xp ( i ) + ctt2 * xp ( im1 ) ystt = ctt1 * yp ( i ) + ctt2 * yp ( im1 ) return end subroutine fitp_kurvd subroutine fitp_kurvp1 ( n , x , y , xp , yp , temp , s , sigma , ierr ) integer n , ierr real x ( n ), y ( n ), xp ( n ), yp ( n ), temp ( 1 ), s ( n ), sigma ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this subroutine determines the parameters necessary to ! compute a spline under tension forming a closed curve in ! the plane and passing through a sequence of pairs ! (x(1),y(1)),...,(x(n),y(n)). for actual computation of ! points on the curve it is necessary to call the subroutine ! kurvp2. ! ! on input-- ! !   n is the number of points to be interpolated (n.ge.2). ! !   x is an array containing the n x-coordinates of the !   points. ! !   y is an array containing the n y-coordinates of the !   points. (adjacent x-y pairs must be distinct, i. e. !   either x(i) .ne. x(i+1) or y(i) .ne. y(i+1), for !   i = 1,...,n-1 and either x(1) .ne. x(n) or y(1) .ne. y(n).) ! !   xp and yp are arrays of length at least n. ! !   temp is an array of length at least 2*n which is used !   for scratch storage. ! !   s is an array of length at least n. ! ! and ! !   sigma contains the tension factor. this value indicates !   the curviness desired. if abs(sigma) is nearly zero !   (e.g. .001) the resulting curve is approximately a cubic !   spline. if abs(sigma) is large (e. g. 50.) the resulting !   curve is nearly a polygonal line. if sigma equals zero a !   cubic spline results. a standard value for sigma is !   approximately 1. in absolute value. ! ! on output-- ! !   xp and yp contain information about the curvature of the !   curve at the given nodes. ! !   s contains the polygonal arclengths of the curve. ! !   ierr contains an error flag, !        = 0 for normal return, !        = 1 if n is less than 2, !        = 2 if adjacent coordinate pairs coincide. ! ! and ! !   n, x, y, and sigma are unaltered, ! ! this subroutine references package modules terms and ! snhcsh. ! !----------------------------------------------------------- integer npibak , npi , ibak , im1 , i , nm1 , np1 real sdiag2 , diag , diag2 , dx2 , dy2 , diagin , xpn , ypn real sigmap , dels1 , sdiag1 , dels2 , diag1 , dx1 , dy1 nm1 = n - 1 np1 = n + 1 ierr = 0 if ( n <= 1 ) go to 7 ! ! determine polygonal arclengths ! s ( 1 ) = sqrt (( x ( n ) - x ( 1 )) ** 2 + ( y ( n ) - y ( 1 )) ** 2 ) do i = 2 , n im1 = i - 1 s ( i ) = s ( im1 ) + sqrt (( x ( i ) - x ( im1 )) ** 2 + ( y ( i ) - y ( im1 )) ** 2 ) end do ! ! denormalize tension factor ! sigmap = abs ( sigma ) * real ( n ) / s ( n ) ! ! set up right hand sides of tridiagonal (with corner ! elements) linear system for xp and yp ! dels1 = s ( 1 ) if ( dels1 == 0. ) go to 8 dx1 = ( x ( 1 ) - x ( n )) / dels1 dy1 = ( y ( 1 ) - y ( n )) / dels1 call fitp_terms ( diag1 , sdiag1 , sigmap , dels1 ) dels2 = s ( 2 ) - s ( 1 ) if ( dels2 == 0. ) go to 8 dx2 = ( x ( 2 ) - x ( 1 )) / dels2 dy2 = ( y ( 2 ) - y ( 1 )) / dels2 call fitp_terms ( diag2 , sdiag2 , sigmap , dels2 ) diag = diag1 + diag2 diagin = 1. / diag xp ( 1 ) = ( dx2 - dx1 ) * diagin yp ( 1 ) = ( dy2 - dy1 ) * diagin temp ( np1 ) = - sdiag1 * diagin temp ( 1 ) = sdiag2 * diagin dx1 = dx2 dy1 = dy2 diag1 = diag2 sdiag1 = sdiag2 if ( n == 2 ) go to 3 do i = 2 , nm1 npi = n + i dels2 = s ( i + 1 ) - s ( i ) if ( dels2 == 0. ) go to 8 dx2 = ( x ( i + 1 ) - x ( i )) / dels2 dy2 = ( y ( i + 1 ) - y ( i )) / dels2 call fitp_terms ( diag2 , sdiag2 , sigmap , dels2 ) diag = diag1 + diag2 - sdiag1 * temp ( i - 1 ) diagin = 1. / diag xp ( i ) = ( dx2 - dx1 - sdiag1 * xp ( i - 1 )) * diagin yp ( i ) = ( dy2 - dy1 - sdiag1 * yp ( i - 1 )) * diagin temp ( npi ) = - temp ( npi - 1 ) * sdiag1 * diagin temp ( i ) = sdiag2 * diagin dx1 = dx2 dy1 = dy2 diag1 = diag2 sdiag1 = sdiag2 end do 3 dels2 = s ( 1 ) dx2 = ( x ( 1 ) - x ( n )) / dels2 dy2 = ( y ( 1 ) - y ( n )) / dels2 call fitp_terms ( diag2 , sdiag2 , sigmap , dels2 ) xp ( n ) = dx2 - dx1 yp ( n ) = dy2 - dy1 temp ( nm1 ) = temp ( 2 * n - 1 ) - temp ( nm1 ) if ( n == 2 ) go to 5 ! ! perform first step of back substitution ! do i = 3 , n ibak = np1 - i npibak = n + ibak xp ( ibak ) = xp ( ibak ) - temp ( ibak ) * xp ( ibak + 1 ) yp ( ibak ) = yp ( ibak ) - temp ( ibak ) * yp ( ibak + 1 ) temp ( ibak ) = temp ( npibak ) - temp ( ibak ) * temp ( ibak + 1 ) end do 5 xp ( n ) = ( xp ( n ) - sdiag2 * xp ( 1 ) - sdiag1 * xp ( nm1 )) / & ( diag1 + diag2 + sdiag2 * temp ( 1 ) + sdiag1 * temp ( nm1 )) yp ( n ) = ( yp ( n ) - sdiag2 * yp ( 1 ) - sdiag1 * yp ( nm1 )) / & ( diag1 + diag2 + sdiag2 * temp ( 1 ) + sdiag1 * temp ( nm1 )) ! ! perform second step of back substitution ! xpn = xp ( n ) ypn = yp ( n ) do i = 1 , nm1 xp ( i ) = xp ( i ) + temp ( i ) * xpn yp ( i ) = yp ( i ) + temp ( i ) * ypn end do return ! ! too few points ! 7 ierr = 1 return ! ! coincident adjacent points ! 8 ierr = 2 return end subroutine fitp_kurvp1 subroutine fitp_kurvp2 ( t , xs , ys , n , x , y , xp , yp , s , sigma ) integer n real t , xs , ys , x ( n ), y ( n ), xp ( n ), yp ( n ), s ( n ), sigma ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this subroutine performs the mapping of points in the ! interval (0.,1.) onto a closed curve in the plane. the ! subroutine kurvp1 should be called earlier to determine ! certain necessary parameters. the resulting curve has a ! parametric representation both of whose components are ! periodic splines under tension and functions of the poly- ! gonal arclength parameter. ! ! on input-- ! !   t contains a value to be mapped onto the curve. the !   interval (0.,1.) is mapped onto the entire closed curve !   with both 0. and 1. mapping to (x(1),y(1)). the mapping !   is periodic with period one thus any interval of the !   form (tt,tt+1.) maps onto the entire curve. ! !   n contains the number of points which were specified !   to determine the curve. ! !   x and y are arrays containing the x- and y-coordinates !   of the specified points. ! !   xp and yp are the arrays output from kurvp1 containing !   curvature information. ! !   s is an array containing the polygonal arclengths of !   the curve. ! ! and ! !   sigma contains the tension factor (its sign is ignored). ! ! the parameters n, x, y, xp, yp, s and sigma should ! be input unaltered from the output of kurvp1. ! ! on output-- ! !   xs and ys contain the x- and y-coordinates of the image !   point on the curve. ! ! none of the input parameters are altered. ! ! this subroutine references package modules intrvl and ! snhcsh. ! !----------------------------------------------------------- integer i , im1 real sigdel , ss , c1 , c2 , dummy , ci , cim1 , s1 , s2 , d real sigmap , si , tn , sumx , sumy , dels , del1 , del2 ! ! determine interval ! tn = t - real ( int ( t )) if ( tn < 0. ) tn = tn + 1. tn = s ( n ) * tn + s ( 1 ) im1 = n if ( tn < s ( n )) im1 = fitp_intrvl ( tn , s , n ) i = im1 + 1 if ( i > n ) i = 1 ! ! denormalize tension factor ! sigmap = abs ( sigma ) * real ( n ) / s ( n ) ! ! set up and perform interpolation ! si = s ( i ) if ( im1 == n ) si = s ( n ) + s ( 1 ) del1 = tn - s ( im1 ) del2 = si - tn dels = si - s ( im1 ) sumx = ( x ( i ) * del1 + x ( im1 ) * del2 ) / dels sumy = ( y ( i ) * del1 + y ( im1 ) * del2 ) / dels if ( sigmap /= 0. ) go to 1 d = del1 * del2 / ( 6. * dels ) c1 = ( del1 + dels ) * d c2 = ( del2 + dels ) * d xs = sumx - xp ( i ) * c1 - xp ( im1 ) * c2 ys = sumy - yp ( i ) * c1 - yp ( im1 ) * c2 return 1 sigdel = sigmap * dels call fitp_snhcsh ( ss , dummy , sigdel , - 1 ) call fitp_snhcsh ( s1 , dummy , sigmap * del1 , - 1 ) call fitp_snhcsh ( s2 , dummy , sigmap * del2 , - 1 ) d = sigdel * sigmap * ( 1. + ss ) ci = del1 * ( s1 - ss ) / d cim1 = del2 * ( s2 - ss ) / d xs = sumx + xp ( i ) * ci + xp ( im1 ) * cim1 ys = sumy + yp ( i ) * ci + yp ( im1 ) * cim1 return end subroutine fitp_kurvp2 subroutine fitp_kurvpd ( t , xs , ys , xst , yst , xstt , ystt , n , x , y , xp , yp , s , sigma ) integer n real t , xs , ys , xst , yst , xstt , ystt , x ( n ), y ( n ), xp ( n ), yp ( n ), s ( n ), sigma ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this subroutine performs the mapping of points in the ! interval (0.,1.) onto a closed curve in the plane. it also ! returns the first and second derivatives of the component ! functions. the subroutine kurvp1 should be called earlier ! to determine certain necessary parameters. the resulting ! curve has a parametric representation both of whose ! components are periodic splines under tension and ! functions of the polygonal arclength parameter. ! ! on input-- ! !   t contains a value to be mapped onto the curve. the !   interval (0.,1.) is mapped onto the entire closed curve !   with both 0. and 1. mapping to (x(1),y(1)). the mapping !   is periodic with period one thus any interval of the !   form (tt,tt+1.) maps onto the entire curve. ! !   n contains the number of points which were specified !   to determine the curve. ! !   x and y are arrays containing the x- and y-coordinates !   of the specified points. ! !   xp and yp are the arrays output from kurvp1 containing !   curvature information. ! !   s is an array containing the polygonal arclengths of !   the curve. ! ! and ! !   sigma contains the tension factor (its sign is ignored). ! ! the parameters n, x, y, xp, yp, s and sigma should ! be input unaltered from the output of kurvp1. ! ! on output-- ! !   xs and ys contain the x- and y-coordinates of the image !   point on the curve. xst and yst contain the first !   derivatives of the x- and y-components of the mapping !   with respect to t. xstt and ystt contain the second !   derivatives of the x- and y-components of the mapping !   with respect to t. ! ! none of the input parameters are altered. ! ! this subroutine references package modules intrvl and ! snhcsh. ! !----------------------------------------------------------- integer im1 , i real ct2 , ctt1 , ctt2 , c1 , c2 , ct1 , sigdel , co1 , s2 , co2 , ss real dummy , s1 , si , del1 , del2 , sigmap , tn real sumyt , dels6 , d , sumxt , dels , sumx , sumy ! ! determine interval ! tn = t - real ( int ( t )) if ( tn < 0. ) tn = tn + 1. tn = s ( n ) * tn + s ( 1 ) im1 = n if ( tn < s ( n )) im1 = fitp_intrvl ( tn , s , n ) i = im1 + 1 if ( i > n ) i = 1 ! ! denormalize tension factor ! sigmap = abs ( sigma ) * real ( n ) / s ( n ) ! ! set up and perform interpolation ! si = s ( i ) if ( im1 == n ) si = s ( n ) + s ( 1 ) del1 = tn - s ( im1 ) del2 = si - tn dels = si - s ( im1 ) sumx = ( x ( i ) * del1 + x ( im1 ) * del2 ) / dels sumy = ( y ( i ) * del1 + y ( im1 ) * del2 ) / dels sumxt = s ( n ) * ( x ( i ) - x ( im1 )) / dels sumyt = s ( n ) * ( y ( i ) - y ( im1 )) / dels if ( sigmap /= 0. ) go to 1 dels6 = 6. * dels d = del1 * del2 / dels6 c1 = - ( del1 + dels ) * d c2 = - ( del2 + dels ) * d dels6 = dels6 / s ( n ) ct1 = ( 2. * del1 * del1 - del2 * ( del1 + dels )) / dels6 ct2 = - ( 2. * del2 * del2 - del1 * ( del2 + dels )) / dels6 dels = dels / ( s ( n ) * s ( n )) ctt1 = del1 / dels ctt2 = del2 / dels go to 2 1 sigdel = sigmap * dels call fitp_snhcsh ( ss , dummy , sigdel , - 1 ) call fitp_snhcsh ( s1 , co1 , sigmap * del1 , 0 ) call fitp_snhcsh ( s2 , co2 , sigmap * del2 , 0 ) d = sigdel * sigmap * ( 1. + ss ) c1 = del1 * ( s1 - ss ) / d c2 = del2 * ( s2 - ss ) / d ct1 = ( co1 - ss ) * s ( n ) / d ct2 = - ( co2 - ss ) * s ( n ) / d ctt1 = del1 * ( 1. + s1 ) * s ( n ) * s ( n ) / ( dels * ( 1. + ss )) ctt2 = del2 * ( 1. + s2 ) * s ( n ) * s ( n ) / ( dels * ( 1. + ss )) 2 xs = sumx + c1 * xp ( i ) + c2 * xp ( im1 ) ys = sumy + c1 * yp ( i ) + c2 * yp ( im1 ) xst = sumxt + ct1 * xp ( i ) + ct2 * xp ( im1 ) yst = sumyt + ct1 * yp ( i ) + ct2 * yp ( im1 ) xstt = ctt1 * xp ( i ) + ctt2 * xp ( im1 ) ystt = ctt1 * yp ( i ) + ctt2 * yp ( im1 ) return end subroutine fitp_kurvpd subroutine fitp_surf1 ( m , n , x , y , z , iz , zx1 , zxm , zy1 , zyn , zxy11 , & zxym1 , zxy1n , zxymn , islpsw , zp , temp , sigma , ierr ) integer m , n , iz , islpsw , ierr real x ( m ), y ( n ), z ( iz , n ), zx1 ( n ), zxm ( n ), zy1 ( m ), zyn ( m ), & zxy11 , zxym1 , zxy1n , zxymn , zp ( m , n , 3 ), temp ( n + n + m ), sigma ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this subroutine determines the parameters necessary to ! compute an interpolatory surface passing through a rect- ! angular grid of functional values. the surface determined ! can be represented as the tensor product of splines under ! tension. the x- and y-partial derivatives around the ! boundary and the x-y-partial derivatives at the four ! corners may be specified or omitted. for actual mapping ! of points onto the surface it is necessary to call the ! function surf2. ! ! on input-- ! !   m is the number of grid lines in the x-direction, i. e. !   lines parallel to the y-axis (m .ge. 2). ! !   n is the number of grid lines in the y-direction, i. e. !   lines parallel to the x-axis (n .ge. 2). ! !   x is an array of the m x-coordinates of the grid lines !   in the x-direction. these should be strictly increasing. ! !   y is an array of the n y-coordinates of the grid lines !   in the y-direction. these should be strictly increasing. ! !   z is an array of the m * n functional values at the grid !   points, i. e. z(i,j) contains the functional value at !   (x(i),y(j)) for i = 1,...,m and j = 1,...,n. ! !   iz is the row dimension of the matrix z used in the !   calling program (iz .ge. m). ! !   zx1 and zxm are arrays of the m x-partial derivatives !   of the function along the x(1) and x(m) grid lines, !   respectively. thus zx1(j) and zxm(j) contain the x-part- !   ial derivatives at the points (x(1),y(j)) and !   (x(m),y(j)), respectively, for j = 1,...,n. either of !   these parameters will be ignored (and approximations !   supplied internally) if islpsw so indicates. ! !   zy1 and zyn are arrays of the n y-partial derivatives !   of the function along the y(1) and y(n) grid lines, !   respectively. thus zy1(i) and zyn(i) contain the y-part- !   ial derivatives at the points (x(i),y(1)) and !   (x(i),y(n)), respectively, for i = 1,...,m. either of !   these parameters will be ignored (and estimations !   supplied internally) if islpsw so indicates. ! !   zxy11, zxym1, zxy1n, and zxymn are the x-y-partial !   derivatives of the function at the four corners, !   (x(1),y(1)), (x(m),y(1)), (x(1),y(n)), and (x(m),y(n)), !   respectively. any of the parameters will be ignored (and !   estimations supplied internally) if islpsw so indicates. ! !   islpsw contains a switch indicating which boundary !   derivative information is user-supplied and which !   should be estimated by this subroutine. to determine !   islpsw, let !        i1 = 0 if zx1 is user-supplied (and = 1 otherwise), !        i2 = 0 if zxm is user-supplied (and = 1 otherwise), !        i3 = 0 if zy1 is user-supplied (and = 1 otherwise), !        i4 = 0 if zyn is user-supplied (and = 1 otherwise), !        i5 = 0 if zxy11 is user-supplied !                                       (and = 1 otherwise), !        i6 = 0 if zxym1 is user-supplied !                                       (and = 1 otherwise), !        i7 = 0 if zxy1n is user-supplied !                                       (and = 1 otherwise), !        i8 = 0 if zxymn is user-supplied !                                       (and = 1 otherwise), !   then islpsw = i1 + 2*i2 + 4*i3 + 8*i4 + 16*i5 + 32*i6 !                   + 64*i7 + 128*i8 !   thus islpsw = 0 indicates all derivative information is !   user-supplied and islpsw = 255 indicates no derivative !   information is user-supplied. any value between these !   limits is valid. ! !   zp is an array of at least 3*m*n locations. ! !   temp is an array of at least n+n+m locations which is !   used for scratch storage. ! ! and ! !   sigma contains the tension factor. this value indicates !   the curviness desired. if abs(sigma) is nearly zero !   (e. g. .001) the resulting surface is approximately the !   tensor product of cubic splines. if abs(sigma) is large !   (e. g. 50.) the resulting surface is approximately !   bi-linear. if sigma equals zero tensor products of !   cubic splines result. a standard value for sigma is !   approximately 1. in absolute value. ! ! on output-- ! !   zp contains the values of the xx-, yy-, and xxyy-partial !   derivatives of the surface at the given nodes. ! !   ierr contains an error flag, !        = 0 for normal return, !        = 1 if n is less than 2 or m is less than 2, !        = 2 if the x-values or y-values are not strictly !            increasing. ! ! and ! !   m, n, x, y, z, iz, zx1, zxm, zy1, zyn, zxy11, zxym1, !   zxy1n, zxymn, islpsw, and sigma are unaltered. ! ! this subroutine references package modules ceez, terms, ! and snhcsh. ! !----------------------------------------------------------- integer jbak , jbakp1 , jm1 , jp1 , im1 , ibakp1 integer npibak , ip1 , ibak , nm1 , np1 , mm1 , mp1 , npm , j integer npmpj , i , npi real diagi , sdiag1 , del2 , zxymns , delxmm , del1 real diag1 , deli , diag2 , diagin , sdiag2 , t real delxm , sigmay , dely1 , c1 , dely2 , c2 real delx1 , delx2 , zxy1ns , c3 , delyn , sigmax , delynm mm1 = m - 1 mp1 = m + 1 nm1 = n - 1 np1 = n + 1 npm = n + m ierr = 0 if ( n <= 1 . or . m <= 1 ) go to 46 if ( y ( n ) <= y ( 1 )) go to 47 ! ! denormalize tension factor in y-direction ! sigmay = abs ( sigma ) * real ( n - 1 ) / ( y ( n ) - y ( 1 )) ! ! obtain y-partial derivatives along y = y(1) ! if (( islpsw / 8 ) * 2 /= ( islpsw / 4 )) go to 2 do i = 1 , m zp ( i , 1 , 1 ) = zy1 ( i ) end do go to 5 2 dely1 = y ( 2 ) - y ( 1 ) dely2 = dely1 + dely1 if ( n > 2 ) dely2 = y ( 3 ) - y ( 1 ) if ( dely1 <= 0. . or . dely2 <= dely1 ) go to 47 call fitp_ceez ( dely1 , dely2 , sigmay , c1 , c2 , c3 , n ) do i = 1 , m zp ( i , 1 , 1 ) = c1 * z ( i , 1 ) + c2 * z ( i , 2 ) end do if ( n == 2 ) go to 5 do i = 1 , m zp ( i , 1 , 1 ) = zp ( i , 1 , 1 ) + c3 * z ( i , 3 ) end do ! ! obtain y-partial derivatives along y = y(n) ! 5 if (( islpsw / 16 ) * 2 /= ( islpsw / 8 )) go to 7 do i = 1 , m npi = n + i temp ( npi ) = zyn ( i ) end do go to 10 7 delyn = y ( n ) - y ( nm1 ) delynm = delyn + delyn if ( n > 2 ) delynm = y ( n ) - y ( n - 2 ) if ( delyn <= 0. . or . delynm <= delyn ) go to 47 call fitp_ceez ( - delyn , - delynm , sigmay , c1 , c2 , c3 , n ) do i = 1 , m npi = n + i temp ( npi ) = c1 * z ( i , n ) + c2 * z ( i , nm1 ) end do if ( n == 2 ) go to 10 do i = 1 , m npi = n + i temp ( npi ) = temp ( npi ) + c3 * z ( i , n - 2 ) end do 10 if ( x ( m ) <= x ( 1 )) go to 47 ! ! denormalize tension factor in x-direction ! sigmax = abs ( sigma ) * real ( m - 1 ) / ( x ( m ) - x ( 1 )) ! ! obtain x-partial derivatives along x = x(1) ! if (( islpsw / 2 ) * 2 /= islpsw ) go to 12 do j = 1 , n zp ( 1 , j , 2 ) = zx1 ( j ) end do if (( islpsw / 32 ) * 2 == ( islpsw / 16 ) . and . ( islpsw / 128 ) * 2 == ( islpsw / 64 )) go to 15 12 delx1 = x ( 2 ) - x ( 1 ) delx2 = delx1 + delx1 if ( m > 2 ) delx2 = x ( 3 ) - x ( 1 ) if ( delx1 <= 0. . or . delx2 <= delx1 ) go to 47 call fitp_ceez ( delx1 , delx2 , sigmax , c1 , c2 , c3 , m ) if (( islpsw / 2 ) * 2 == islpsw ) go to 15 do j = 1 , n zp ( 1 , j , 2 ) = c1 * z ( 1 , j ) + c2 * z ( 2 , j ) end do if ( m == 2 ) go to 15 do j = 1 , n zp ( 1 , j , 2 ) = zp ( 1 , j , 2 ) + c3 * z ( 3 , j ) end do ! ! obtain x-y-partial derivative at (x(1),y(1)) ! 15 if (( islpsw / 32 ) * 2 /= ( islpsw / 16 )) go to 16 zp ( 1 , 1 , 3 ) = zxy11 go to 17 16 zp ( 1 , 1 , 3 ) = c1 * zp ( 1 , 1 , 1 ) + c2 * zp ( 2 , 1 , 1 ) if ( m > 2 ) zp ( 1 , 1 , 3 ) = zp ( 1 , 1 , 3 ) + c3 * zp ( 3 , 1 , 1 ) ! ! obtain x-y-partial derivative at (x(1),y(n)) ! 17 if (( islpsw / 128 ) * 2 /= ( islpsw / 64 )) go to 18 zxy1ns = zxy1n go to 19 18 zxy1ns = c1 * temp ( n + 1 ) + c2 * temp ( n + 2 ) if ( m > 2 ) zxy1ns = zxy1ns + c3 * temp ( n + 3 ) ! ! obtain x-partial derivative along x = x(m) ! 19 if (( islpsw / 4 ) * 2 /= ( islpsw / 2 )) go to 21 do j = 1 , n npmpj = npm + j temp ( npmpj ) = zxm ( j ) end do if (( islpsw / 64 ) * 2 == ( islpsw / 32 ) . and . ( islpsw / 256 ) * 2 == ( islpsw / 128 )) go to 24 21 delxm = x ( m ) - x ( mm1 ) delxmm = delxm + delxm if ( m > 2 ) delxmm = x ( m ) - x ( m - 2 ) if ( delxm <= 0. . or . delxmm <= delxm ) go to 47 call fitp_ceez ( - delxm , - delxmm , sigmax , c1 , c2 , c3 , m ) if (( islpsw / 4 ) * 2 == ( islpsw / 2 )) go to 24 do j = 1 , n npmpj = npm + j temp ( npmpj ) = c1 * z ( m , j ) + c2 * z ( mm1 , j ) end do if ( m == 2 ) go to 24 do j = 1 , n npmpj = npm + j temp ( npmpj ) = temp ( npmpj ) + c3 * z ( m - 2 , j ) end do ! ! obtain x-y-partial derivative at (x(m),y(1)) ! 24 if (( islpsw / 64 ) * 2 /= ( islpsw / 32 )) go to 25 zp ( m , 1 , 3 ) = zxym1 go to 26 25 zp ( m , 1 , 3 ) = c1 * zp ( m , 1 , 1 ) + c2 * zp ( mm1 , 1 , 1 ) if ( m > 2 ) zp ( m , 1 , 3 ) = zp ( m , 1 , 3 ) + c3 * zp ( m - 2 , 1 , 1 ) ! ! obtain x-y-partial derivative at (x(m),y(n)) ! 26 if (( islpsw / 256 ) * 2 /= ( islpsw / 128 )) go to 27 zxymns = zxymn go to 28 27 zxymns = c1 * temp ( npm ) + c2 * temp ( npm - 1 ) if ( m > 2 ) zxymns = zxymns + c3 * temp ( npm - 2 ) ! ! set up right hand sides and tridiagonal system for y-grid ! perform forward elimination ! 28 del1 = y ( 2 ) - y ( 1 ) if ( del1 <= 0. ) go to 47 deli = 1. / del1 do i = 1 , m zp ( i , 2 , 1 ) = deli * ( z ( i , 2 ) - z ( i , 1 )) end do zp ( 1 , 2 , 3 ) = deli * ( zp ( 1 , 2 , 2 ) - zp ( 1 , 1 , 2 )) zp ( m , 2 , 3 ) = deli * ( temp ( npm + 2 ) - temp ( npm + 1 )) call fitp_terms ( diag1 , sdiag1 , sigmay , del1 ) diagi = 1. / diag1 do i = 1 , m zp ( i , 1 , 1 ) = diagi * ( zp ( i , 2 , 1 ) - zp ( i , 1 , 1 )) end do zp ( 1 , 1 , 3 ) = diagi * ( zp ( 1 , 2 , 3 ) - zp ( 1 , 1 , 3 )) zp ( m , 1 , 3 ) = diagi * ( zp ( m , 2 , 3 ) - zp ( m , 1 , 3 )) temp ( 1 ) = diagi * sdiag1 if ( n == 2 ) go to 34 do j = 2 , nm1 jm1 = j - 1 jp1 = j + 1 npmpj = npm + j del2 = y ( jp1 ) - y ( j ) if ( del2 <= 0. ) go to 47 deli = 1. / del2 do i = 1 , m zp ( i , jp1 , 1 ) = deli * ( z ( i , jp1 ) - z ( i , j )) end do zp ( 1 , jp1 , 3 ) = deli * ( zp ( 1 , jp1 , 2 ) - zp ( 1 , j , 2 )) zp ( m , jp1 , 3 ) = deli * ( temp ( npmpj + 1 ) - temp ( npmpj )) call fitp_terms ( diag2 , sdiag2 , sigmay , del2 ) diagin = 1. / ( diag1 + diag2 - sdiag1 * temp ( jm1 )) do i = 1 , m zp ( i , j , 1 ) = diagin * ( zp ( i , jp1 , 1 ) - zp ( i , j , 1 ) - sdiag1 * zp ( i , jm1 , 1 )) end do zp ( 1 , j , 3 ) = diagin * ( zp ( 1 , jp1 , 3 ) - zp ( 1 , j , 3 ) - sdiag1 * zp ( 1 , jm1 , 3 )) zp ( m , j , 3 ) = diagin * ( zp ( m , jp1 , 3 ) - zp ( m , j , 3 ) - sdiag1 * zp ( m , jm1 , 3 )) temp ( j ) = diagin * sdiag2 diag1 = diag2 sdiag1 = sdiag2 end do 34 diagin = 1. / ( diag1 - sdiag1 * temp ( nm1 )) do i = 1 , m npi = n + i zp ( i , n , 1 ) = diagin * ( temp ( npi ) - zp ( i , n , 1 ) - sdiag1 * zp ( i , nm1 , 1 )) end do zp ( 1 , n , 3 ) = diagin * ( zxy1ns - zp ( 1 , n , 3 ) - sdiag1 * zp ( 1 , nm1 , 3 )) temp ( n ) = diagin * ( zxymns - zp ( m , n , 3 ) - sdiag1 * zp ( m , nm1 , 3 )) ! ! perform back substitution ! do j = 2 , n jbak = np1 - j jbakp1 = jbak + 1 t = temp ( jbak ) do i = 1 , m zp ( i , jbak , 1 ) = zp ( i , jbak , 1 ) - t * zp ( i , jbakp1 , 1 ) end do zp ( 1 , jbak , 3 ) = zp ( 1 , jbak , 3 ) - t * zp ( 1 , jbakp1 , 3 ) temp ( jbak ) = zp ( m , jbak , 3 ) - t * temp ( jbakp1 ) end do ! ! set up right hand sides and tridiagonal system for x-grid ! perform forward elimination ! del1 = x ( 2 ) - x ( 1 ) if ( del1 <= 0. ) go to 47 deli = 1. / del1 do j = 1 , n zp ( 2 , j , 2 ) = deli * ( z ( 2 , j ) - z ( 1 , j )) zp ( 2 , j , 3 ) = deli * ( zp ( 2 , j , 1 ) - zp ( 1 , j , 1 )) end do call fitp_terms ( diag1 , sdiag1 , sigmax , del1 ) diagi = 1. / diag1 do j = 1 , n zp ( 1 , j , 2 ) = diagi * ( zp ( 2 , j , 2 ) - zp ( 1 , j , 2 )) zp ( 1 , j , 3 ) = diagi * ( zp ( 2 , j , 3 ) - zp ( 1 , j , 3 )) end do temp ( n + 1 ) = diagi * sdiag1 if ( m == 2 ) go to 43 do i = 2 , mm1 im1 = i - 1 ip1 = i + 1 npi = n + i del2 = x ( ip1 ) - x ( i ) if ( del2 <= 0. ) go to 47 deli = 1. / del2 do j = 1 , n zp ( ip1 , j , 2 ) = deli * ( z ( ip1 , j ) - z ( i , j )) zp ( ip1 , j , 3 ) = deli * ( zp ( ip1 , j , 1 ) - zp ( i , j , 1 )) end do call fitp_terms ( diag2 , sdiag2 , sigmax , del2 ) diagin = 1. / ( diag1 + diag2 - sdiag1 * temp ( npi - 1 )) do j = 1 , n zp ( i , j , 2 ) = diagin * ( zp ( ip1 , j , 2 ) - zp ( i , j , 2 ) - sdiag1 * zp ( im1 , j , 2 )) zp ( i , j , 3 ) = diagin * ( zp ( ip1 , j , 3 ) - zp ( i , j , 3 ) - sdiag1 * zp ( im1 , j , 3 )) end do temp ( npi ) = diagin * sdiag2 diag1 = diag2 sdiag1 = sdiag2 end do 43 diagin = 1. / ( diag1 - sdiag1 * temp ( npm - 1 )) do j = 1 , n npmpj = npm + j zp ( m , j , 2 ) = diagin * ( temp ( npmpj ) - zp ( m , j , 2 ) - sdiag1 * zp ( mm1 , j , 2 )) zp ( m , j , 3 ) = diagin * ( temp ( j ) - zp ( m , j , 3 ) - sdiag1 * zp ( mm1 , j , 3 )) end do ! ! perform back substitution ! do i = 2 , m ibak = mp1 - i ibakp1 = ibak + 1 npibak = n + ibak t = temp ( npibak ) do j = 1 , n zp ( ibak , j , 2 ) = zp ( ibak , j , 2 ) - t * zp ( ibakp1 , j , 2 ) zp ( ibak , j , 3 ) = zp ( ibak , j , 3 ) - t * zp ( ibakp1 , j , 3 ) end do end do return ! ! too few points ! 46 ierr = 1 return ! ! points not strictly increasing ! 47 ierr = 2 return end subroutine fitp_surf1 real function fitp_surf2 ( xx , yy , m , n , x , y , z , iz , zp , sigma ) integer m , n , iz real xx , yy , x ( m ), y ( n ), z ( iz , n ), zp ( m , n , 3 ), sigma ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this function interpolates a surface at a given coordinate ! pair using a bi-spline under tension. the subroutine surf1 ! should be called earlier to determine certain necessary ! parameters. ! ! on input-- ! !   xx and yy contain the x- and y-coordinates of the point !   to be mapped onto the interpolating surface. ! !   m and n contain the number of grid lines in the x- and !   y-directions, respectively, of the rectangular grid !   which specified the surface. ! !   x and y are arrays containing the x- and y-grid values, !   respectively, each in increasing order. ! !   z is a matrix containing the m * n functional values !   corresponding to the grid values (i. e. z(i,j) is the !   surface value at the point (x(i),y(j)) for i = 1,...,m !   and j = 1,...,n). ! !   iz contains the row dimension of the array z as declared !   in the calling program. ! !   zp is an array of 3*m*n locations stored with the !   various surface derivative information determined by !   surf1. ! ! and ! !   sigma contains the tension factor (its sign is ignored). ! ! the parameters m, n, x, y, z, iz, zp, and sigma should be ! input unaltered from the output of surf1. ! ! on output-- ! !   surf2 contains the interpolated surface value. ! ! none of the input parameters are altered. ! ! this function references package modules intrvl and ! snhcsh. ! !----------------------------------------------------------- integer im1 , i , j , jm1 real hermz , hermnz , zxxi , dummy , zxxim1 , zim1 , zi real sigmax , fp2 , del1 , fp1 , f1 , f2 , del2 real sinhms , sinhm2 , sinhm1 , dels , sigmay , sigmap ! ! inline one dimensional cubic spline interpolation ! hermz ( f1 , f2 , fp1 , fp2 ) = ( f2 * del1 + f1 * del2 ) / dels - del1 * & del2 * ( fp2 * ( del1 + dels ) + & fp1 * ( del2 + dels )) / ( 6. * dels ) ! ! inline one dimensional spline under tension interpolation ! hermnz ( f1 , f2 , fp1 , fp2 , sigmap ) = ( f2 * del1 + f1 * del2 ) / dels & + ( fp2 * del1 * ( sinhm1 - sinhms ) & + fp1 * del2 * ( sinhm2 - sinhms ) & ) / ( sigmap * sigmap * dels * ( 1. + sinhms )) ! ! denormalize tension factor in x and y direction ! sigmax = abs ( sigma ) * real ( m - 1 ) / ( x ( m ) - x ( 1 )) sigmay = abs ( sigma ) * real ( n - 1 ) / ( y ( n ) - y ( 1 )) ! ! determine y interval ! jm1 = fitp_intrvl ( yy , y , n ) j = jm1 + 1 ! ! determine x interval ! im1 = fitp_intrvl ( xx , x , m ) i = im1 + 1 del1 = yy - y ( jm1 ) del2 = y ( j ) - yy dels = y ( j ) - y ( jm1 ) if ( sigmay /= 0. ) go to 1 ! ! perform four interpolations in y-direction ! zim1 = hermz ( z ( i - 1 , j - 1 ), z ( i - 1 , j ), zp ( i - 1 , j - 1 , 1 ), zp ( i - 1 , j , 1 )) zi = hermz ( z ( i , j - 1 ), z ( i , j ), zp ( i , j - 1 , 1 ), zp ( i , j , 1 )) zxxim1 = hermz ( zp ( i - 1 , j - 1 , 2 ), zp ( i - 1 , j , 2 ), zp ( i - 1 , j - 1 , 3 ), zp ( i - 1 , j , 3 )) zxxi = hermz ( zp ( i , j - 1 , 2 ), zp ( i , j , 2 ), zp ( i , j - 1 , 3 ), zp ( i , j , 3 )) go to 2 1 call fitp_snhcsh ( sinhm1 , dummy , sigmay * del1 , - 1 ) call fitp_snhcsh ( sinhm2 , dummy , sigmay * del2 , - 1 ) call fitp_snhcsh ( sinhms , dummy , sigmay * dels , - 1 ) zim1 = hermnz ( z ( i - 1 , j - 1 ), z ( i - 1 , j ), zp ( i - 1 , j - 1 , 1 ), zp ( i - 1 , j , 1 ), sigmay ) zi = hermnz ( z ( i , j - 1 ), z ( i , j ), zp ( i , j - 1 , 1 ), zp ( i , j , 1 ), sigmay ) zxxim1 = hermnz ( zp ( i - 1 , j - 1 , 2 ), zp ( i - 1 , j , 2 ), zp ( i - 1 , j - 1 , 3 ), zp ( i - 1 , j , 3 ), sigmay ) zxxi = hermnz ( zp ( i , j - 1 , 2 ), zp ( i , j , 2 ), zp ( i , j - 1 , 3 ), zp ( i , j , 3 ), sigmay ) ! ! perform final interpolation in x-direction ! 2 del1 = xx - x ( im1 ) del2 = x ( i ) - xx dels = x ( i ) - x ( im1 ) if ( sigmax /= 0. ) go to 3 fitp_surf2 = hermz ( zim1 , zi , zxxim1 , zxxi ) return 3 call fitp_snhcsh ( sinhm1 , dummy , sigmax * del1 , - 1 ) call fitp_snhcsh ( sinhm2 , dummy , sigmax * del2 , - 1 ) call fitp_snhcsh ( sinhms , dummy , sigmax * dels , - 1 ) fitp_surf2 = hermnz ( zim1 , zi , zxxim1 , zxxi , sigmax ) return end function fitp_surf2 subroutine fitp_ceez ( del1 , del2 , sigma , c1 , c2 , c3 , n ) real del1 , del2 , sigma , c1 , c2 , c3 ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this subroutine determines the coefficients c1, c2, and c3 ! used to determine endpoint slopes. specifically, if ! function values y1, y2, and y3 are given at points x1, x2, ! and x3, respectively, the quantity c1*y1 + c2*y2 + c3*y3 ! is the value of the derivative at x1 of a spline under ! tension (with tension factor sigma) passing through the ! three points and having third derivative equal to zero at ! x1. optionally, only two values, c1 and c2 are determined. ! ! on input-- ! !   del1 is x2-x1 (.gt. 0.). ! !   del2 is x3-x1 (.gt. 0.). if n .eq. 2, this parameter is !   ignored. ! !   sigma is the tension factor. ! ! and ! !   n is a switch indicating the number of coefficients to !   be returned. if n .eq. 2 only two coefficients are !   returned. otherwise all three are returned. ! ! on output-- ! !   c1, c2, and c3 contain the coefficients. ! ! none of the input parameters are altered. ! ! this subroutine references package module snhcsh. ! !----------------------------------------------------------- integer n real delm , delp , sinhmp , denom , sinhmm , del , dummy , coshm2 , coshm1 if ( n == 2 ) go to 2 if ( sigma /= 0. ) go to 1 del = del2 - del1 ! ! tension .eq. 0. ! c1 = - ( del1 + del2 ) / ( del1 * del2 ) c2 = del2 / ( del1 * del ) c3 = - del1 / ( del2 * del ) return ! ! tension .ne. 0. ! 1 call fitp_snhcsh ( dummy , coshm1 , sigma * del1 , 1 ) call fitp_snhcsh ( dummy , coshm2 , sigma * del2 , 1 ) delp = sigma * ( del2 + del1 ) / 2. delm = sigma * ( del2 - del1 ) / 2. call fitp_snhcsh ( sinhmp , dummy , delp , - 1 ) call fitp_snhcsh ( sinhmm , dummy , delm , - 1 ) denom = coshm1 * ( del2 - del1 ) - 2. * del1 * delp * delm * ( 1. + sinhmp ) * ( 1. + sinhmm ) c1 = 2. * delp * delm * ( 1. + sinhmp ) * ( 1. + sinhmm ) / denom c2 = - coshm2 / denom c3 = coshm1 / denom return ! ! two coefficients ! 2 c1 = - 1. / del1 c2 = - c1 return end subroutine fitp_ceez subroutine fitp_curvpp ( n , x , y , p , d , isw , s , eps , ys , ysp , sigma , & td , tsd1 , hd , hsd1 , hsd2 , rd , rsd1 , rsd2 , rnm1 , rn , v , ierr ) integer n , isw , ierr real x ( n ), y ( n ), p , d ( n ), s , eps , ys ( n ), ysp ( n ), sigma , td ( n ), & tsd1 ( n ), hd ( n ), hsd1 ( n ), hsd2 ( n ), rd ( n ), rsd1 ( n ), & rsd2 ( n ), rnm1 ( n ), rn ( n ), v ( n ) ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this subroutine determines the parameters necessary to ! compute a periodic smoothing spline under tension. for a ! given increasing sequence of abscissae (x(i)), i = 1,...,n ! and associated ordinates (y(i)), i = 1,...,n, letting p be ! the period, x(n+1) = x(1)+p, and y(n+1) = y(1), the ! function determined minimizes the summation from i = 1 to ! n of the square of the second derivative of f plus sigma ! squared times the difference of the first derivative of f ! and (f(x(i+1))-f(x(i)))/(x(i+1)-x(i)) squared, over all ! functions f with period p and two continuous derivatives ! such that the summation of the square of ! (f(x(i))-y(i))/d(i) is less than or equal to a given ! constant s, where (d(i)), i = 1,...,n are a given set of ! observation weights. the function determined is a periodic ! spline under tension with third derivative discontinuities ! at (x(i)) i = 1,...,n (and all periodic translations of ! these values). for actual computation of points on the ! curve it is necessary to call the function curvp2. ! ! on input-- ! !   n is the number of values to be smoothed (n.ge.2). ! !   x is an array of the n increasing abscissae of the !   values to be smoothed. ! !   y is an array of the n ordinates of the values to be !   smoothed, (i. e. y(k) is the functional value !   corresponding to x(k) ). ! !   p is the period (p .gt. x(n)-x(1)). ! !   d is a parameter containing the observation weights. !   this may either be an array of length n or a scalar !   (interpreted as a constant). the value of d !   corresponding to the observation (x(k),y(k)) should !   be an approximation to the standard deviation of error. ! !   isw contains a switch indicating whether the parameter !   d is to be considered a vector or a scalar, !          = 0 if d is an array of length n, !          = 1 if d is a scalar. ! !   s contains the value controlling the smoothing. this !   must be non-negative. for s equal to zero, the !   subroutine does interpolation, larger values lead to !   smoother funtions. if parameter d contains standard !   deviation estimates, a reasonable value for s is !   float(n). ! !   eps contains a tolerance on the relative precision to !   which s is to be interpreted. this must be greater than !   or equal to zero and less than equal or equal to one. a !   reasonable value for eps is sqrt(2./float(n)). ! !   ys is an array of length at least n. ! !   ysp is an array of length at least n. ! !   sigma contains the tension factor. this value indicates !   the degree to which the first derivative part of the !   smoothing functional is emphasized. if sigma is nearly !   zero (e. g. .001) the resulting curve is approximately a !   cubic spline. if sigma is large (e. g. 50.) the !   resulting curve is nearly a polygonal line. if sigma !   equals zero a cubic spline results. a standard value for !   sigma is approximately 1. ! ! and ! !   td, tsd1, hd, hsd1, hsd2, rd, rsd1, rsd2, rnm1, rn, and !   v are arrays of length at least n which are used for !   scratch storage. ! ! on output-- ! !   ys contains the smoothed ordinate values. ! !   ysp contains the values of the second derivative of the !   smoothed curve at the given nodes. ! !   ierr contains an error flag, !        = 0 for normal return, !        = 1 if n is less than 2, !        = 2 if s is negative, !        = 3 if eps is negative or greater than one, !        = 4 if x-values are not strictly increasing, !        = 5 if a d-value is non-positive, !        = 6 if p is less than or equal to x(n)-x(1). ! ! and ! !   n, x, y, d, isw, s, eps, and sigma are unaltered. ! ! this subroutine references package modules terms and ! snhcsh. ! !----------------------------------------------------------- real f , g , rnm1sm integer ibak real rnm1t , rnt , rdn , wi , h , step , tui , rnsm real wim1 , wim2 , hsd1p , hdim1 , hdi , sum , hsd11 real sl , con , sum2 , sumn , rsd2i , sumnm1 , yspnm1 , yspn , rsd1i integer ip1 , i real dim1 , di , delyi , delxi , delyi1 real sigmap , q , delxi1 integer nm3 , nm2 , nm1 real disq , sumy , sumd , beta , hsd1ip , alpha integer im1 real su , alphap , betap , betapp if ( n < 2 ) go to 25 if ( s < 0. ) go to 26 if ( eps < 0. . or . eps > 1. ) go to 27 if ( p <= x ( n ) - x ( 1 )) go to 30 ierr = 0 q = 0. rsd1 ( 1 ) = 0. rsd2 ( 1 ) = 0. rsd2 ( 2 ) = 0. rsd1 ( n - 1 ) = 0. rsd2 ( n - 1 ) = 0. rsd2 ( n ) = 0. ! ! denormalize tension factor ! sigmap = abs ( sigma ) * real ( n ) / p ! ! form t matrix and second differences of y into ys ! nm1 = n - 1 nm2 = n - 2 nm3 = n - 3 delxi1 = x ( 1 ) + p - x ( n ) delyi1 = ( y ( 1 ) - y ( n )) / delxi1 call fitp_terms ( dim1 , tsd1 ( 1 ), sigmap , delxi1 ) hsd1 ( 1 ) = 1. / delxi1 do i = 1 , n ip1 = i + 1 if ( i == n ) ip1 = 1 delxi = x ( ip1 ) - x ( i ) if ( i == n ) delxi = x ( 1 ) + p - x ( n ) if ( delxi <= 0. ) go to 28 delyi = ( y ( ip1 ) - y ( i )) / delxi ys ( i ) = delyi - delyi1 call fitp_terms ( di , tsd1 ( ip1 ), sigmap , delxi ) td ( i ) = di + dim1 hd ( i ) = - ( 1. / delxi + 1. / delxi1 ) hsd1 ( ip1 ) = 1. / delxi delxi1 = delxi delyi1 = delyi dim1 = di end do hsd11 = hsd1 ( 1 ) if ( n >= 3 ) go to 2 tsd1 ( 2 ) = tsd1 ( 1 ) + tsd1 ( 2 ) tsd1 ( 1 ) = 0. hsd1 ( 2 ) = hsd1 ( 1 ) + hsd1 ( 2 ) hsd1 ( 1 ) = 0. ! ! calculate lower and upper tolerances ! 2 sl = s * ( 1. - eps ) su = s * ( 1. + eps ) if ( d ( 1 ) <= 0. ) go to 29 if ( isw == 1 ) go to 5 ! ! form h matrix - d array ! betapp = hsd1 ( n ) * d ( n ) * d ( n ) betap = hsd1 ( 1 ) * d ( 1 ) * d ( 1 ) alphap = hd ( n ) * d ( n ) * d ( n ) im1 = n sumd = 0. sumy = 0. do i = 1 , n disq = d ( i ) * d ( i ) sumd = sumd + 1. / disq sumy = sumy + y ( i ) / disq ip1 = i + 1 if ( i == n ) ip1 = 1 alpha = hd ( i ) * disq if ( d ( ip1 ) <= 0. ) go to 29 hsd1ip = hsd1 ( ip1 ) if ( i == n ) hsd1ip = hsd11 beta = hsd1ip * d ( ip1 ) * d ( ip1 ) hd ( i ) = ( hsd1 ( i ) * d ( im1 )) ** 2 + alpha * hd ( i ) + beta * hsd1ip hsd2 ( i ) = hsd1 ( i ) * betapp hsd1 ( i ) = hsd1 ( i ) * ( alpha + alphap ) im1 = i alphap = alpha betapp = betap betap = beta end do if ( n == 3 ) hsd1 ( 3 ) = hsd1 ( 3 ) + hsd2 ( 2 ) ! ! test for straight line fit ! con = sumy / sumd sum = 0. do i = 1 , n sum = sum + (( y ( i ) - con ) / d ( i )) ** 2 end do if ( sum <= su ) go to 23 go to 8 ! ! form h matrix - d constant ! 5 sl = d ( 1 ) * d ( 1 ) * sl su = d ( 1 ) * d ( 1 ) * su hsd1p = hsd1 ( n ) hdim1 = hd ( n ) sumy = 0. do i = 1 , n sumy = sumy + y ( i ) hsd1ip = hsd11 if ( i < n ) hsd1ip = hsd1 ( i + 1 ) hdi = hd ( i ) hd ( i ) = hsd1 ( i ) * hsd1 ( i ) + hdi * hdi + hsd1ip * hsd1ip hsd2 ( i ) = hsd1 ( i ) * hsd1p hsd1p = hsd1 ( i ) hsd1 ( i ) = hsd1p * ( hdi + hdim1 ) hdim1 = hdi end do if ( n == 3 ) hsd1 ( 3 ) = hsd1 ( 3 ) + hsd2 ( 2 ) ! ! test for straight line fit ! con = sumy / real ( n ) sum = 0. do i = 1 , n sum = sum + ( y ( i ) - con ) ** 2 end do if ( sum <= su ) go to 23 ! ! top of iteration ! cholesky factorization of q*t+h into r ! ! ! i = 1 ! 8 rd ( 1 ) = 1. / ( q * td ( 1 ) + hd ( 1 )) rnm1 ( 1 ) = hsd2 ( 1 ) yspnm1 = ys ( nm1 ) rn ( 1 ) = q * tsd1 ( 1 ) + hsd1 ( 1 ) yspn = ys ( n ) ysp ( 1 ) = ys ( 1 ) rsd1i = q * tsd1 ( 2 ) + hsd1 ( 2 ) rsd1 ( 2 ) = rsd1i * rd ( 1 ) sumnm1 = 0. sum2 = 0. sumn = 0. if ( n == 3 ) go to 11 if ( n == 2 ) go to 12 ! ! i = 2 ! rd ( 2 ) = 1. / ( q * td ( 2 ) + hd ( 2 ) - rsd1i * rsd1 ( 2 )) rnm1 ( 2 ) = - rnm1 ( 1 ) * rsd1 ( 2 ) rn ( 2 ) = hsd2 ( 2 ) - rn ( 1 ) * rsd1 ( 2 ) ysp ( 2 ) = ys ( 2 ) - rsd1 ( 2 ) * ysp ( 1 ) if ( n == 4 ) go to 10 do i = 3 , nm2 rsd2i = hsd2 ( i ) rsd1i = q * tsd1 ( i ) + hsd1 ( i ) - rsd2i * rsd1 ( i - 1 ) rsd2 ( i ) = rsd2i * rd ( i - 2 ) rsd1 ( i ) = rsd1i * rd ( i - 1 ) rd ( i ) = 1. / ( q * td ( i ) + hd ( i ) - rsd1i * rsd1 ( i ) - rsd2i * rsd2 ( i )) rnm1 ( i ) = - rnm1 ( i - 2 ) * rsd2 ( i ) - rnm1 ( i - 1 ) * rsd1 ( i ) rnm1t = rnm1 ( i - 2 ) * rd ( i - 2 ) sumnm1 = sumnm1 + rnm1t * rnm1 ( i - 2 ) rnm1 ( i - 2 ) = rnm1t sum2 = sum2 + rnm1t * rn ( i - 2 ) yspnm1 = yspnm1 - rnm1t * ysp ( i - 2 ) rn ( i ) = - rn ( i - 2 ) * rsd2 ( i ) - rn ( i - 1 ) * rsd1 ( i ) rnt = rn ( i - 2 ) * rd ( i - 2 ) sumn = sumn + rnt * rn ( i - 2 ) rn ( i - 2 ) = rnt yspn = yspn - rnt * ysp ( i - 2 ) ysp ( i ) = ys ( i ) - rsd1 ( i ) * ysp ( i - 1 ) - rsd2 ( i ) * ysp ( i - 2 ) end do ! ! i = n-3 ! 10 rnm1 ( nm3 ) = hsd2 ( nm1 ) + rnm1 ( nm3 ) rnm1 ( nm2 ) = rnm1 ( nm2 ) - hsd2 ( nm1 ) * rsd1 ( nm2 ) rnm1t = rnm1 ( nm3 ) * rd ( nm3 ) sumnm1 = sumnm1 + rnm1t * rnm1 ( nm3 ) rnm1 ( nm3 ) = rnm1t sum2 = sum2 + rnm1t * rn ( nm3 ) yspnm1 = yspnm1 - rnm1t * ysp ( nm3 ) rnt = rn ( nm3 ) * rd ( nm3 ) sumn = sumn + rnt * rn ( nm3 ) rn ( nm3 ) = rnt yspn = yspn - rnt * ysp ( nm3 ) ! ! i = n-2 ! 11 rnm1 ( nm2 ) = q * tsd1 ( nm1 ) + hsd1 ( nm1 ) + rnm1 ( nm2 ) rnm1t = rnm1 ( nm2 ) * rd ( nm2 ) sumnm1 = sumnm1 + rnm1t * rnm1 ( nm2 ) rnm1 ( nm2 ) = rnm1t rn ( nm2 ) = hsd2 ( n ) + rn ( nm2 ) sum2 = sum2 + rnm1t * rn ( nm2 ) yspnm1 = yspnm1 - rnm1t * ysp ( nm2 ) rnt = rn ( nm2 ) * rd ( nm2 ) sumn = sumn + rnt * rn ( nm2 ) rn ( nm2 ) = rnt yspn = yspn - rnt * ysp ( nm2 ) ! ! i = n-1 ! 12 rd ( nm1 ) = 1. / ( q * td ( nm1 ) + hd ( nm1 ) - sumnm1 ) ysp ( nm1 ) = yspnm1 rn ( nm1 ) = q * tsd1 ( n ) + hsd1 ( n ) - sum2 rnt = rn ( nm1 ) * rd ( nm1 ) sumn = sumn + rnt * rn ( nm1 ) rn ( nm1 ) = rnt yspn = yspn - rnt * ysp ( nm1 ) ! ! i = n ! rdn = q * td ( n ) + hd ( n ) - sumn rd ( n ) = 0. if ( rdn > 0. ) rd ( n ) = 1. / rdn ysp ( n ) = yspn ! ! back solve of r(transpose)* r * ysp = ys ! ysp ( n ) = rd ( n ) * ysp ( n ) ysp ( nm1 ) = rd ( nm1 ) * ysp ( nm1 ) - rn ( nm1 ) * ysp ( n ) if ( n == 2 ) go to 14 yspn = ysp ( n ) yspnm1 = ysp ( nm1 ) do ibak = 1 , nm2 i = nm1 - ibak ysp ( i ) = rd ( i ) * ysp ( i ) - rsd1 ( i + 1 ) * ysp ( i + 1 ) - rsd2 ( i + 2 ) * ysp ( i + 2 ) - rnm1 ( i ) * yspnm1 - rn ( i ) * yspn end do 14 sum = 0. delyi1 = ( ysp ( 1 ) - ysp ( n )) / ( x ( 1 ) + p - x ( n )) if ( isw == 1 ) go to 16 ! ! calculation of residual norm !  - d array ! do i = 1 , nm1 delyi = ( ysp ( i + 1 ) - ysp ( i )) / ( x ( i + 1 ) - x ( i )) v ( i ) = ( delyi - delyi1 ) * d ( i ) * d ( i ) sum = sum + v ( i ) * ( delyi - delyi1 ) delyi1 = delyi end do delyi = ( ysp ( 1 ) - ysp ( n )) / ( x ( 1 ) + p - x ( n )) v ( n ) = ( delyi - delyi1 ) * d ( n ) * d ( n ) go to 18 ! ! calculation of residual norm !  - d constant ! 16 do i = 1 , nm1 delyi = ( ysp ( i + 1 ) - ysp ( i )) / ( x ( i + 1 ) - x ( i )) v ( i ) = delyi - delyi1 sum = sum + v ( i ) * ( delyi - delyi1 ) delyi1 = delyi end do delyi = ( ysp ( 1 ) - ysp ( n )) / ( x ( 1 ) + p - x ( n )) v ( n ) = delyi - delyi1 18 sum = sum + v ( n ) * ( delyi - delyi1 ) ! ! test for convergence ! if ( sum <= su . and . sum >= sl . and . q > 0. ) go to 21 ! ! calculation of newton correction ! f = 0. g = 0. rnm1sm = 0. rnsm = 0. im1 = n if ( n == 2 ) go to 20 wim2 = 0. wim1 = 0. do i = 1 , nm2 tui = tsd1 ( i ) * ysp ( im1 ) + td ( i ) * ysp ( i ) + tsd1 ( i + 1 ) * ysp ( i + 1 ) wi = tui - rsd1 ( i ) * wim1 - rsd2 ( i ) * wim2 rnm1sm = rnm1sm - rnm1 ( i ) * wi rnsm = rnsm - rn ( i ) * wi f = f + tui * ysp ( i ) g = g + wi * wi * rd ( i ) im1 = i wim2 = wim1 wim1 = wi end do 20 tui = tsd1 ( nm1 ) * ysp ( im1 ) + td ( nm1 ) * ysp ( nm1 ) + tsd1 ( n ) * ysp ( n ) wi = tui + rnm1sm f = f + tui * ysp ( nm1 ) g = g + wi * wi * rd ( nm1 ) tui = tsd1 ( n ) * ysp ( nm1 ) + td ( n ) * ysp ( n ) + tsd1 ( 1 ) * ysp ( 1 ) wi = tui + rnsm - rn ( nm1 ) * wi f = f + tui * ysp ( n ) g = g + wi * wi * rd ( n ) h = f - q * g if ( h <= 0. . and . q > 0. ) go to 21 ! ! update q - newton step ! step = ( sum - sqrt ( sum * sl )) / h if ( sl /= 0. ) step = step * sqrt ( sum / sl ) q = q + step go to 8 ! ! store smoothed y-values and second derivatives ! 21 do i = 1 , n ys ( i ) = y ( i ) - v ( i ) ysp ( i ) = q * ysp ( i ) end do return ! ! store constant ys and zero ysp ! 23 do i = 1 , n ys ( i ) = con ysp ( i ) = 0. end do return ! ! n less than 2 ! 25 ierr = 1 return ! ! s negative ! 26 ierr = 2 return ! ! eps negative or greater than 1 ! 27 ierr = 3 return ! ! x-values not strictly increasing ! 28 ierr = 4 return ! ! weight non-positive ! 29 ierr = 5 return ! ! incorrect period ! 30 ierr = 6 return end subroutine fitp_curvpp subroutine fitp_curvss ( n , x , y , d , isw , s , eps , ys , ysp , sigma , td , & tsd1 , hd , hsd1 , hsd2 , rd , rsd1 , rsd2 , v , ierr ) integer n , isw , ierr real x ( n ), y ( n ), d ( n ), s , eps , ys ( n ), ysp ( n ), sigma , td ( n ), & tsd1 ( n ), hd ( n ), hsd1 ( n ), hsd2 ( n ), rd ( n ), rsd1 ( n ), rsd2 ( n ), v ( n ) ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this subroutine determines the parameters necessary to ! compute a smoothing spline under tension. for a given ! increasing sequence of abscissae (x(i)), i = 1,..., n and ! associated ordinates (y(i)), i = 1,..., n, the function ! determined minimizes the summation from i = 1 to n-1 of ! the square of the second derivative of f plus sigma ! squared times the difference of the first derivative of f ! and (f(x(i+1))-f(x(i)))/(x(i+1)-x(i)) squared, over all ! functions f with two continuous derivatives such that the ! summation of the square of (f(x(i))-y(i))/d(i) is less ! than or equal to a given constant s, where (d(i)), i = 1, ! ..., n are a given set of observation weights. the ! function determined is a spline under tension with third ! derivative discontinuities at (x(i)), i = 2,..., n-1. for ! actual computation of points on the curve it is necessary ! to call the function curv2. ! ! on input-- ! !   n is the number of values to be smoothed (n.ge.2). ! !   x is an array of the n increasing abscissae of the !   values to be smoothed. ! !   y is an array of the n ordinates of the values to be !   smoothed, (i. e. y(k) is the functional value !   corresponding to x(k) ). ! !   d is a parameter containing the observation weights. !   this may either be an array of length n or a scalar !   (interpreted as a constant). the value of d !   corresponding to the observation (x(k),y(k)) should !   be an approximation to the standard deviation of error. ! !   isw contains a switch indicating whether the parameter !   d is to be considered a vector or a scalar, !          = 0 if d is an array of length n, !          = 1 if d is a scalar. ! !   s contains the value controlling the smoothing. this !   must be non-negative. for s equal to zero, the !   subroutine does interpolation, larger values lead to !   smoother funtions. if parameter d contains standard !   deviation estimates, a reasonable value for s is !   float(n). ! !   eps contains a tolerance on the relative precision to !   which s is to be interpreted. this must be greater than !   or equal to zero and less than equal or equal to one. a !   reasonable value for eps is sqrt(2./float(n)). ! !   ys is an array of length at least n. ! !   ysp is an array of length at least n. ! !   sigma contains the tension factor. this value indicates !   the degree to which the first derivative part of the !   smoothing functional is emphasized. if sigma is nearly !   zero (e. g. .001) the resulting curve is approximately a !   cubic spline. if sigma is large (e. g. 50.) the !   resulting curve is nearly a polygonal line. if sigma !   equals zero a cubic spline results. a standard value for !   sigma is approximately 1. ! ! and ! !   td, tsd1, hd, hsd1, hsd2, rd, rsd1, rsd2, and v are !   arrays of length at least n which are used for scratch !   storage. ! ! on output-- ! !   ys contains the smoothed ordinate values. ! !   ysp contains the values of the second derivative of the !   smoothed curve at the given nodes. ! !   ierr contains an error flag, !        = 0 for normal return, !        = 1 if n is less than 2, !        = 2 if s is negative, !        = 3 if eps is negative or greater than one, !        = 4 if x-values are not strictly increasing, !        = 5 if a d-value is non-positive. ! ! and ! !   n, x, y, d, isw, s, eps, and sigma are unaltered. ! ! this subroutine references package modules terms and ! snhcsh. ! !----------------------------------------------------------- integer ibak real rsd1i , rsd2i , sum , hdi , beta , alpha , hdim1 , hsd1p real wi , tui , step , h , g , f , wim1 , wim2 , alphap integer nm1 , nm3 real delyi1 , delxi1 , rdim1 , p , sigmap , yspim2 real dim1 , su , sl , betap , betapp , delxi integer i real di , delyi if ( n < 2 ) go to 16 if ( s < 0. ) go to 17 if ( eps < 0. . or . eps > 1. ) go to 18 ierr = 0 p = 0. v ( 1 ) = 0. v ( n ) = 0. ysp ( 1 ) = 0. ysp ( n ) = 0. if ( n == 2 ) go to 14 rsd1 ( 1 ) = 0. rd ( 1 ) = 0. rsd2 ( n ) = 0. rdim1 = 0. yspim2 = 0. ! ! denormalize tension factor ! sigmap = abs ( sigma ) * real ( n - 1 ) / ( x ( n ) - x ( 1 )) ! ! form t matrix and second differences of y into ys ! nm1 = n - 1 nm3 = n - 3 delxi1 = 1. delyi1 = 0. dim1 = 0. do i = 1 , nm1 delxi = x ( i + 1 ) - x ( i ) if ( delxi <= 0. ) go to 19 delyi = ( y ( i + 1 ) - y ( i )) / delxi ys ( i ) = delyi - delyi1 call fitp_terms ( di , tsd1 ( i + 1 ), sigmap , delxi ) td ( i ) = di + dim1 hd ( i ) = - ( 1. / delxi + 1. / delxi1 ) hsd1 ( i + 1 ) = 1. / delxi delxi1 = delxi delyi1 = delyi dim1 = di end do ! ! calculate lower and upper tolerances ! sl = s * ( 1. - eps ) su = s * ( 1. + eps ) if ( isw == 1 ) go to 3 ! ! form h matrix - d array ! if ( d ( 1 ) <= 0. . or . d ( 2 ) <= 0. ) go to 20 betapp = 0. betap = 0. alphap = 0. do i = 2 , nm1 alpha = hd ( i ) * d ( i ) * d ( i ) if ( d ( i + 1 ) <= 0. ) go to 20 beta = hsd1 ( i + 1 ) * d ( i + 1 ) * d ( i + 1 ) hd ( i ) = ( hsd1 ( i ) * d ( i - 1 )) ** 2 + alpha * hd ( i ) + beta * hsd1 ( i + 1 ) hsd2 ( i ) = hsd1 ( i ) * betapp hsd1 ( i ) = hsd1 ( i ) * ( alpha + alphap ) alphap = alpha betapp = betap betap = beta end do go to 5 ! ! form h matrix - d constant ! 3 if ( d ( 1 ) <= 0. ) go to 20 sl = d ( 1 ) * d ( 1 ) * sl su = d ( 1 ) * d ( 1 ) * su hsd1p = 0. hdim1 = 0. do i = 2 , nm1 hdi = hd ( i ) hd ( i ) = hsd1 ( i ) * hsd1 ( i ) + hdi * hdi + hsd1 ( i + 1 ) * hsd1 ( i + 1 ) hsd2 ( i ) = hsd1 ( i ) * hsd1p hsd1p = hsd1 ( i ) hsd1 ( i ) = hsd1p * ( hdi + hdim1 ) hdim1 = hdi end do ! ! top of iteration ! cholesky factorization of p*t+h into r ! 5 do i = 2 , nm1 rsd2i = hsd2 ( i ) rsd1i = p * tsd1 ( i ) + hsd1 ( i ) - rsd2i * rsd1 ( i - 1 ) rsd2 ( i ) = rsd2i * rdim1 rdim1 = rd ( i - 1 ) rsd1 ( i ) = rsd1i * rdim1 rd ( i ) = 1. / ( p * td ( i ) + hd ( i ) - rsd1i * rsd1 ( i ) - rsd2i * rsd2 ( i )) ysp ( i ) = ys ( i ) - rsd1 ( i ) * ysp ( i - 1 ) - rsd2 ( i ) * yspim2 yspim2 = ysp ( i - 1 ) end do ! ! back solve of r(transpose)* r * ysp = ys ! ysp ( nm1 ) = rd ( nm1 ) * ysp ( nm1 ) if ( n == 3 ) go to 8 do ibak = 1 , nm3 i = nm1 - ibak ysp ( i ) = rd ( i ) * ysp ( i ) - rsd1 ( i + 1 ) * ysp ( i + 1 ) - rsd2 ( i + 2 ) * ysp ( i + 2 ) end do 8 sum = 0. delyi1 = 0. if ( isw == 1 ) go to 10 ! ! calculation of residual norm !  - d array ! do i = 1 , nm1 delyi = ( ysp ( i + 1 ) - ysp ( i )) / ( x ( i + 1 ) - x ( i )) v ( i ) = ( delyi - delyi1 ) * d ( i ) * d ( i ) sum = sum + v ( i ) * ( delyi - delyi1 ) delyi1 = delyi end do v ( n ) = - delyi1 * d ( n ) * d ( n ) go to 12 ! ! calculation of residual norm !  - d constant ! 10 do i = 1 , nm1 delyi = ( ysp ( i + 1 ) - ysp ( i )) / ( x ( i + 1 ) - x ( i )) v ( i ) = delyi - delyi1 sum = sum + v ( i ) * ( delyi - delyi1 ) delyi1 = delyi end do v ( n ) = - delyi1 12 sum = sum - v ( n ) * delyi1 ! ! test for convergence ! if ( sum <= su ) go to 14 ! ! calculation of newton correction ! f = 0. g = 0. wim2 = 0. wim1 = 0. do i = 2 , nm1 tui = tsd1 ( i ) * ysp ( i - 1 ) + td ( i ) * ysp ( i ) + tsd1 ( i + 1 ) * ysp ( i + 1 ) wi = tui - rsd1 ( i ) * wim1 - rsd2 ( i ) * wim2 f = f + tui * ysp ( i ) g = g + wi * wi * rd ( i ) wim2 = wim1 wim1 = wi end do h = f - p * g if ( h <= 0. ) go to 14 ! ! update p - newton step ! step = ( sum - sqrt ( sum * sl )) / h if ( sl /= 0. ) step = step * sqrt ( sum / sl ) p = p + step go to 5 ! ! store smoothed y-values and second derivatives ! 14 do i = 1 , n ys ( i ) = y ( i ) - v ( i ) ysp ( i ) = p * ysp ( i ) end do return ! ! n less than 2 ! 16 ierr = 1 return ! ! s negative ! 17 ierr = 2 return ! ! eps negative or greater than 1 ! 18 ierr = 3 return ! ! x-values not strictly increasing ! 19 ierr = 4 return ! ! weight non-positive ! 20 ierr = 5 return end subroutine fitp_curvss integer function fitp_intrvl ( t , x , n ) integer n real t , x ( n ) ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this function determines the index of the interval ! (determined by a given increasing sequence) in which ! a given value lies. ! ! on input-- ! !   t is the given value. ! !   x is a vector of strictly increasing values. ! ! and ! !   n is the length of x (n .ge. 2). ! ! on output-- ! !   intrvl returns an integer i such that ! !          i =  1       if         e   t .lt. x(2)  , !          i =  n-1     if x(n-1) .le. t            , !          otherwise       x(i)  .le. t .le. x(i+1), ! ! none of the input parameters are altered. ! !----------------------------------------------------------- integer il , ih , i real tt save i data i / 1 / tt = t ! ! check for illegal i ! if ( i >= n ) i = n / 2 ! ! check old interval and extremes ! if ( tt < x ( i )) then if ( tt <= x ( 2 )) then i = 1 fitp_intrvl = 1 return else il = 2 ih = i end if else if ( tt <= x ( i + 1 )) then fitp_intrvl = i return else if ( tt >= x ( n - 1 )) then i = n - 1 fitp_intrvl = n - 1 return else il = i + 1 ih = n - 1 end if ! ! binary search loop ! 1 i = ( il + ih ) / 2 if ( tt < x ( i )) then ih = i else if ( tt > x ( i + 1 )) then il = i + 1 else fitp_intrvl = i return end if go to 1 end function fitp_intrvl integer function fitp_intrvp ( t , x , n , p , tp ) integer n real t , x ( n ), p , tp ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this function determines the index of the interval ! (determined by a given increasing sequence) in which a ! given value lies, after translating the value to within ! the correct period.  it also returns this translated value. ! ! on input-- ! !   t is the given value. ! !   x is a vector of strictly increasing values. ! !   n is the length of x (n .ge. 2). ! ! and ! !   p contains the period. ! ! on output-- ! !   tp contains a translated value of t (i. e. x(1) .le. tp, !   tp .lt. x(1)+p, and tp = t + k*p for some integer k). ! !   intrvl returns an integer i such that ! !          i = 1       if             tp .lt. x(2)  , !          i = n       if   x(n) .le. tp            , !          otherwise       x(i)  .le. tp .lt. x(i+1), ! ! none of the input parameters are altered. ! !----------------------------------------------------------- integer il , ih , i , nper real tt save i data i / 1 / nper = int (( t - x ( 1 )) / p ) tp = t - real ( nper ) * p if ( tp < x ( 1 )) tp = tp + p tt = tp ! ! check for illegal i ! if ( i >= n ) i = n / 2 ! ! check old interval and extremes ! if ( tt < x ( i )) then if ( tt <= x ( 2 )) then i = 1 fitp_intrvp = 1 return else il = 2 ih = i end if else if ( tt <= x ( i + 1 )) then fitp_intrvp = i return else if ( tt >= x ( n )) then i = n fitp_intrvp = n return else il = i + 1 ih = n end if ! ! binary search loop ! 1 i = ( il + ih ) / 2 if ( tt < x ( i )) then ih = i else if ( tt > x ( i + 1 )) then il = i + 1 else fitp_intrvp = i return end if go to 1 end function fitp_intrvp subroutine fitp_snhcsh ( sinhm , coshm , x , isw ) integer isw real sinhm , coshm , x ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this subroutine returns approximations to !       sinhm(x) = sinh(x)/x-1 !       coshm(x) = cosh(x)-1 ! and !       coshmm(x) = (cosh(x)-1-x*x/2)/(x*x) ! with relative error less than 1.0e-6 ! ! on input-- ! !   x contains the value of the independent variable. ! !   isw indicates the function desired !           = -1 if only sinhm is desired, !           =  0 if both sinhm and coshm are desired, !           =  1 if only coshm is desired, !           =  2 if only coshmm is desired, !           =  3 if both sinhm and coshmm are desired. ! ! on output-- ! !   sinhm contains the value of sinhm(x) if isw .le. 0 or !   isw .eq. 3 (sinhm is unaltered if isw .eq.1 or isw .eq. !   2). ! !   coshm contains the value of coshm(x) if isw .eq. 0 or !   isw .eq. 1 and contains the value of coshmm(x) if isw !   .ge. 2 (coshm is unaltered if isw .eq. -1). ! ! and ! !   x and isw are unaltered. ! !----------------------------------------------------------- real sp10 , sp11 , sp12 , sp13 real sp20 , sp21 , sp22 , sp23 , sp24 real sp31 , sp32 , sp33 real sq30 , sq31 , sq32 real sp41 , sp42 , sp43 real sq40 , sq41 , sq42 real cp0 , cp1 , cp2 , cp3 , cp4 real ax , xs , expx data sp13 / . 302939 0e-5 / , sp12 / . 197513 5e-3 / , sp11 / . 833426 1e-2 / , sp10 / . 166666 5e0 / data sp24 / . 369346 7e-7 / , sp23 / . 245997 4e-5 / , sp22 / . 201810 7e-3 / , sp21 / . 831507 2e-2 / , sp20 / . 166703 5e0 / data sp33 / . 666655 8e-5 / , sp32 / . 664630 7e-3 / , sp31 / . 400147 7e-1 / , sq32 / . 203793 0e-3 / , sq31 /- . 637273 9e-1 / , sq30 / . 601749 7e1 / data sp43 / . 231181 6e-4 / , sp42 / . 272970 2e-3 / , sp41 / . 986875 7e-1 / , sq42 / . 177663 7e-3 / , sq41 /- . 754977 9e-1 / , sq40 / . 911003 4e1 / data cp4 / . 298262 8e-6 / , cp3 / . 247267 3e-4 / , cp2 / . 138896 7e-2 / , cp1 / . 416666 5e-1 / , cp0 / . 500000 0e0 / ax = abs ( x ) if ( isw >= 0 ) go to 5 ! ! sinhm approximation ! if ( ax > 4.45 ) go to 2 xs = ax * ax if ( ax > 2.3 ) go to 1 ! ! sinhm approximation on (0.,2.3) ! sinhm = xs * ((( sp13 * xs + sp12 ) * xs + sp11 ) * xs + sp10 ) return ! ! sinhm approximation on (2.3,4.45) ! 1 sinhm = xs * (((( sp24 * xs + sp23 ) * xs + sp22 ) * xs + sp21 ) * xs + sp20 ) return 2 if ( ax > 7.65 ) go to 3 ! ! sinhm approximation on (4.45,7.65) ! xs = ax * ax sinhm = xs * ((( sp33 * xs + sp32 ) * xs + sp31 ) * xs + 1. ) / (( sq32 * xs + sq31 ) * xs + sq30 ) return 3 if ( ax > 1 0.1 ) go to 4 ! ! sinhm approximation on (7.65,10.1) ! xs = ax * ax sinhm = xs * ((( sp43 * xs + sp42 ) * xs + sp41 ) * xs + 1. ) / (( sq42 * xs + sq41 ) * xs + sq40 ) return ! ! sinhm approximation above 10.1 ! 4 sinhm = exp ( ax ) / ( ax + ax ) - 1. return ! ! coshm and (possibly) sinhm approximation ! 5 if ( isw >= 2 ) go to 7 if ( ax > 2.3 ) go to 6 xs = ax * ax coshm = xs * (((( cp4 * xs + cp3 ) * xs + cp2 ) * xs + cp1 ) * xs + cp0 ) if ( isw == 0 ) sinhm = xs * ((( sp13 * xs + sp12 ) * xs + sp11 ) * xs + sp10 ) return 6 expx = exp ( ax ) coshm = ( expx + 1. / expx ) / 2. - 1. if ( isw == 0 ) sinhm = ( expx - 1. / expx ) / ( ax + ax ) - 1. return ! ! coshmm and (possibly) sinhm approximation ! 7 xs = ax * ax if ( ax > 2.3 ) go to 8 coshm = xs * ((( cp4 * xs + cp3 ) * xs + cp2 ) * xs + cp1 ) if ( isw == 3 ) sinhm = xs * ((( sp13 * xs + sp12 ) * xs + sp11 ) * xs + sp10 ) return 8 expx = exp ( ax ) coshm = (( expx + 1. / expx - xs ) / 2. - 1. ) / xs if ( isw == 3 ) sinhm = ( expx - 1. / expx ) / ( ax + ax ) - 1. return end subroutine fitp_snhcsh subroutine fitp_terms ( diag , sdiag , sigma , del ) ! real diag , sdiag , sigma , del ! !                                 coded by alan kaylor cline !                           from fitpack -- january 26, 1987 !                        a curve and surface fitting package !                      a product of pleasant valley software !                  8603 altus cove, austin, texas 78759, usa ! ! this subroutine computes the diagonal and superdiagonal ! terms of the tridiagonal linear system associated with ! spline under tension interpolation. ! ! on input-- ! !   sigma contains the tension factor. ! ! and ! !   del contains the step size. ! ! on output-- ! !                sigma*del*cosh(sigma*del) - sinh(sigma*del) !   diag = del*--------------------------------------------. !                     (sigma*del)**2 * sinh(sigma*del) ! !                   sinh(sigma*del) - sigma*del !   sdiag = del*----------------------------------. !                (sigma*del)**2 * sinh(sigma*del) ! ! and ! !   sigma and del are unaltered. ! ! this subroutine references package module snhcsh. ! !----------------------------------------------------------- real coshm , denom , sigdel , sinhm if ( sigma /= 0. ) go to 1 diag = del / 3. sdiag = del / 6. return 1 sigdel = sigma * del call fitp_snhcsh ( sinhm , coshm , sigdel , 0 ) denom = sigma * sigdel * ( 1. + sinhm ) diag = ( coshm - sinhm ) / denom sdiag = sinhm / denom return end subroutine fitp_terms real function dedge ( a , r , n , iside ) integer n , iside real a ( n ), r ( n ) ! ! Not quite right for non-uniform r mesh ! if ( iside == 1 ) then dedge = - ( 3. * a ( 1 ) - 4. * a ( 2 ) + a ( 3 )) / ( r ( 3 ) - r ( 1 )) else dedge = ( 3. * a ( iside ) - 4. * a ( iside - 1 ) + a ( iside - 2 )) / ( r ( iside ) - r ( iside - 2 )) end if return end function dedge subroutine geo_spline_real ( x , y , xint , yint ) implicit none real , dimension (:), intent ( in ) :: x , y real , intent ( in ) :: xint real , intent ( out ) :: yint integer :: n , ierr real :: dum1 , dum2 , sigma real , dimension (:), allocatable :: ypp , dum3 n = size ( x ) allocate ( ypp ( n ), dum3 ( n )) sigma = 1.0 call fitp_curv1 ( n , x , y , dum1 , dum2 , 3 , ypp , dum3 , sigma , ierr ) yint = fitp_curv2 ( xint , n , x , y , ypp , sigma ) deallocate ( ypp , dum3 ) end subroutine geo_spline_real subroutine geo_spline_array ( x , y , xint , yint ) implicit none real , dimension (:), intent ( in ) :: x , y , xint real , dimension (:), intent ( out ) :: yint integer :: n , ierr , ix real :: dum1 , dum2 , sigma real , dimension (:), allocatable :: ypp , dum3 n = size ( x ) allocate ( ypp ( n ), dum3 ( n )) sigma = 1.0 call fitp_curv1 ( n , x , y , dum1 , dum2 , 3 , ypp , dum3 , sigma , ierr ) do ix = 1 , size ( xint ) yint ( ix ) = fitp_curv2 ( xint ( ix ), n , x , y , ypp , sigma ) end do deallocate ( ypp , dum3 ) end subroutine geo_spline_array ! assumes that y is periodic in x ! if x has m entries, then assumes that y(m+1)=y(1) subroutine linear_interp_periodic ( x , y , xint , yint , period ) use constants , only : pi implicit none real , dimension (:), intent ( in ) :: x , y , xint real , intent ( in ), optional :: period real , dimension (:), intent ( out ) :: yint integer :: i , j , m , n logical :: not_finished real , dimension (:), allocatable :: xp , yp m = size ( x ) + 1 n = size ( xint ) allocate ( xp ( m ), yp ( m )) xp (: m - 1 ) = x if ( present ( period )) then xp ( m ) = x ( 1 ) + period else xp ( m ) = x ( 1 ) + 2. * pi end if yp (: m - 1 ) = y yp ( m ) = y ( 1 ) j = 1 do i = 1 , n not_finished = . true . do while ( not_finished ) if ( abs ( xint ( i ) - xp ( j )) < 10 0. * epsilon ( 0. )) then yint ( i ) = yp ( j ) not_finished = . false . else if ( xint ( i ) > xp ( j )) then j = j + 1 else yint ( i ) = ( yp ( j - 1 ) * ( xp ( j ) - xint ( i )) + yp ( j ) * ( xint ( i ) - xp ( j - 1 ))) / ( xp ( j ) - xp ( j - 1 )) not_finished = . false . end if end do end do deallocate ( xp , yp ) end subroutine linear_interp_periodic end module splines","tags":"","loc":"sourcefile/spl.f90.html"},{"title":"sort.f90 – stella","text":"Source Code module sort implicit none public :: sort_array_ascending public :: unsort_array_ascending contains subroutine sort_array_ascending ( array , sort_index ) implicit none real , dimension (:), intent ( in out ) :: array integer , dimension (:), intent ( out ) :: sort_index integer :: i , j , n real , dimension (:), allocatable :: tmp n = size ( array ) sort_index = 1 do i = 1 , n - 1 do j = i + 1 , n if ( array ( i ) > array ( j )) then sort_index ( i ) = sort_index ( i ) + 1 else sort_index ( j ) = sort_index ( j ) + 1 end if end do end do allocate ( tmp ( n )) tmp = array do i = 1 , n array ( sort_index ( i )) = tmp ( i ) end do deallocate ( tmp ) end subroutine sort_array_ascending subroutine unsort_array_ascending ( array , sort_index ) implicit none real , dimension (:), intent ( in out ) :: array integer , dimension (:), intent ( in ) :: sort_index integer :: i , n real , dimension (:), allocatable :: tmp n = size ( array ) allocate ( tmp ( n )) tmp = array do i = 1 , n array ( i ) = tmp ( sort_index ( i )) end do deallocate ( tmp ) end subroutine unsort_array_ascending end module sort","tags":"","loc":"sourcefile/sort.f90.html"},{"title":"stella_save.fpp – stella","text":"Source Code # include \"define.inc\" module stella_save use mp , only : mp_comm , mp_info # ifdef NETCDF !  use netcdf, only: NF90_FLOAT, NF90_DOUBLE # ifdef NETCDF_PARALLEL ! If using netcdf version 4.1.2 or older delete NF90_MPIIO use netcdf , only : NF90_HDF5 , NF90_MPIIO use netcdf , only : nf90_var_par_access , NF90_COLLECTIVE use netcdf , only : nf90_put_att , NF90_GLOBAL , nf90_get_att # endif use netcdf , only : NF90_NOWRITE , NF90_CLOBBER , NF90_NOERR use netcdf , only : nf90_create , nf90_open , nf90_sync , nf90_close use netcdf , only : nf90_def_dim , nf90_def_var , nf90_enddef use netcdf , only : nf90_put_var , nf90_get_var , nf90_strerror use netcdf , only : nf90_inq_dimid , nf90_inquire_dimension use netcdf , only : nf90_inq_varid , nf90_inquire_variable use netcdf , only : nf90_int use netcdf_utils , only : get_netcdf_code_precision use netcdf_utils , only : check_netcdf_file_precision use netcdf_utils , only : netcdf_error use netcdf_utils , only : netcdf_real , kind_nf # endif implicit none public :: stella_restore , stella_save_for_restart public :: read_many , save_many public :: init_save , init_dt , init_tstart , finish_save !# ifdef NETCDF !  public :: netcdf_real, kind_nf, get_netcdf_code_precision, netcdf_error !# endif interface stella_restore module procedure stella_restore_many end interface logical :: read_many = . true ., save_many = . true . ! Read and write single or multiple restart files private character ( 300 ), save :: restart_file # ifdef NETCDF real , allocatable , dimension (:, :, :) :: tmpr , tmpi real , allocatable , dimension (:, :, :, :) :: ktmpr , ktmpi real , allocatable , dimension (:, :, :, :) :: ptmpr , ptmpi real , allocatable , dimension (:, :, :) :: pptmpr , pptmpi integer ( kind_nf ) :: ncid , zedid , vpaid , gloid , gvmuloid , kyid , kxid , muid , tubeid integer ( kind_nf ) :: krookr_id , krooki_id , projr_id , proji_id integer ( kind_nf ) :: phiprojr_id , phiproji_id !  integer (kind_nf) :: bparr_id, bpari_id integer ( kind_nf ) :: t0id , gr_id , gi_id , delt0id , istep0id integer ( kind_nf ) :: intkrook_id , intproj_id ; integer ( kind_nf ) :: shift_id logical :: initialized = . false . # endif contains !!----------------------------------------------------------------------!! !!----------------------------------------------------------------------!! !!--Save----------------------------------------------------------------!! !!----------------------------------------------------------------------!! !!----------------------------------------------------------------------!! subroutine stella_save_for_restart & ( g , istep0 , t0 , delt0 , istatus , exit_in , fileopt ) # ifdef NETCDF use fields_arrays , only : shift_state , phi_proj use dist_fn_arrays , only : g_krook , g_proj use kt_grids , only : naky , nakx # else use mp , only : proc0 # endif use mp , only : iproc , barrier # ifdef NETCDF_PARALLEL use zgrid , only : nztot # endif use zgrid , only : nzgrid , ntubes ! Must include kxkyz_layout_type here to avoid obscure bomb while compiling ! stella_diagnostics.f90 (which uses this module) with the Compaq F90 compiler: use stella_layouts , only : kxkyz_lo , vmu_lo use common_types , only : kxkyz_layout_type use file_utils , only : error_unit use vpamu_grids , only : nvpa , nmu use sources , only : source_option_krook , source_option_projection use sources , only : source_option_switch , int_krook , int_proj use sources , only : include_qn_source implicit none complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( in ) :: g real , intent ( in ) :: t0 , delt0 integer , intent ( in ) :: istep0 integer , intent ( out ) :: istatus logical , intent ( in ), optional :: exit_in character ( 20 ), INTENT ( in ), optional :: fileopt # ifdef NETCDF character ( 306 ) :: file_proc character ( 10 ) :: suffix integer :: i , n_elements , nvmulo_elements , ierr integer :: total_elements , total_vmulo_elements logical :: has_vmulo # ifdef NETCDF_PARALLEL integer , dimension ( 3 ) :: start_pos , counts # endif logical :: exit !*********-----------------------_********************** istatus = 0 if ( present ( exit_in )) then exit = exit_in else exit = . false . end if !    if (proc0) then !      write (*,*) \"Starting save_for_restart in \", restart_file !      write (*,*) \"List restart files\" !      call system(\"echo 'start' >> filelist.txt; ls nc/* >> filelist.txt;  \") !    end if n_elements = kxkyz_lo % ulim_proc - kxkyz_lo % llim_proc + 1 total_elements = kxkyz_lo % ulim_world + 1 nvmulo_elements = vmu_lo % ulim_proc - vmu_lo % llim_proc + 1 total_vmulo_elements = vmu_lo % ulim_world + 1 if ( n_elements <= 0 ) return has_vmulo = nvmulo_elements > 0 . or . . not . save_many if (. not . initialized ) then initialized = . true . file_proc = trim ( restart_file ) !CMR, 5/4/2011: Add optional piece of filename IF ( PRESENT ( fileopt )) THEN file_proc = trim ( file_proc ) // trim ( fileopt ) END IF !CMRend !</HL>  The NETCDF_PARALLEL directives include code for parallel !       netcdf using HDF5 to write the output to a single restart file !       The read_many flag allows the old style multiple file output # ifdef NETCDF_PARALLEL if ( save_many ) then # endif WRITE ( suffix , '(a1,i0)' ) '.' , iproc # ifdef NETCDF_PARALLEL else WRITE ( suffix , * ) '' end if # endif file_proc = trim ( trim ( file_proc ) // adjustl ( suffix )) # ifdef NETCDF_PARALLEL if ( save_many ) then # endif istatus = nf90_create ( file_proc , NF90_CLOBBER , ncid ) # ifdef NETCDF_PARALLEL else call barrier if ( iproc == 0 ) then open ( unit = tmpunit , file = file_proc ) close ( unit = tmpunit , status = 'delete' ) end if call barrier ! If using netcdf version 4.1.2 or older replace NF90_MPIIO with NF90_CLOBBER istatus = nf90_create ( file_proc , IOR ( NF90_HDF5 , NF90_MPIIO ), ncid , comm = mp_comm , info = mp_info ) end if # endif if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_create error: \" , nf90_strerror ( istatus ) goto 1 end if # ifdef NETCDF_PARALLEL if (. not . save_many ) then istatus = nf90_put_att ( ncid , NF90_GLOBAL , 'xyzs_layout' , xyzs_layout ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_put_attr error: \" , nf90_strerror ( istatus ) goto 1 end if istatus = nf90_put_att ( ncid , NF90_GLOBAL , 'vms_layout' , vms_layout ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_put_attr error: \" , nf90_strerror ( istatus ) goto 1 end if end if # endif if ( n_elements > 0 ) then istatus = nf90_def_dim ( ncid , \"tube\" , ntubes , tubeid ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_dim zed error: \" , nf90_strerror ( istatus ) goto 1 end if istatus = nf90_def_dim ( ncid , \"zed\" , 2 * nzgrid + 1 , zedid ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_dim zed error: \" , nf90_strerror ( istatus ) goto 1 end if istatus = nf90_def_dim ( ncid , \"vpa\" , nvpa , vpaid ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_dim vpa error: \" , nf90_strerror ( istatus ) goto 1 end if istatus = nf90_def_dim ( ncid , \"mu\" , nmu , muid ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_dim mu error: \" , nf90_strerror ( istatus ) goto 1 end if # ifdef NETCDF_PARALLEL if ( save_many ) then # endif istatus = nf90_def_dim ( ncid , \"glo\" , n_elements , gloid ) # ifdef NETCDF_PARALLEL else istatus = nf90_def_dim ( ncid , \"glo\" , total_elements , gloid ) end if # endif if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_dim glo error: \" , nf90_strerror ( istatus ) goto 1 end if # ifdef NETCDF_PARALLEL if ( save_many ) then # endif if ( nvmulo_elements > 0 ) then istatus = nf90_def_dim ( ncid , \"gvmulo\" , nvmulo_elements , gvmuloid ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_dim gvmulo error: \" , nf90_strerror ( istatus ) goto 1 end if end if # ifdef NETCDF_PARALLEL else istatus = nf90_def_dim ( ncid , \"gvmulo\" , total_vmulo_elements , gvmuloid ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_dim gvmulo error: \" , nf90_strerror ( istatus ) goto 1 end if end if # endif istatus = nf90_def_dim ( ncid , \"aky\" , naky , kyid ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_dim aky error: \" , nf90_strerror ( istatus ) goto 1 end if istatus = nf90_def_dim ( ncid , \"akx\" , nakx , kxid ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_dim akx error: \" , nf90_strerror ( istatus ) goto 1 end if end if if ( netcdf_real == 0 ) netcdf_real = get_netcdf_code_precision () istatus = nf90_def_var ( ncid , \"t0\" , netcdf_real , t0id ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_var t0 error: \" , nf90_strerror ( istatus ) goto 1 end if istatus = nf90_def_var ( ncid , \"istep0\" , nf90_int , istep0id ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_var istep0 error: \" , nf90_strerror ( istatus ) goto 1 end if istatus = nf90_def_var ( ncid , \"delt0\" , netcdf_real , delt0id ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_var delt0 error: \" , nf90_strerror ( istatus ) goto 1 end if if ( n_elements > 0 ) then istatus = nf90_def_var ( ncid , \"gr\" , netcdf_real , & ( / vpaid , muid , gloid / ), gr_id ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_var g error: \" , nf90_strerror ( istatus ) goto 1 end if istatus = nf90_def_var ( ncid , \"gi\" , netcdf_real , & ( / vpaid , muid , gloid / ), gi_id ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_var g error: \" , nf90_strerror ( istatus ) goto 1 end if if ( source_option_switch == source_option_krook . and . has_vmulo ) then istatus = nf90_def_var ( ncid , \"intkrook\" , netcdf_real , intkrook_id ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_var intkrook error: \" , nf90_strerror ( istatus ) goto 1 end if istatus = nf90_def_var ( ncid , \"krookr\" , netcdf_real , & ( / kxid , zedid , tubeid , gvmuloid / ), krookr_id ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_var apar error: \" , nf90_strerror ( istatus ) goto 1 end if istatus = nf90_def_var ( ncid , \"krooki\" , netcdf_real , & ( / kxid , zedid , tubeid , gvmuloid / ), krooki_id ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_var krooki error: \" , nf90_strerror ( istatus ) goto 1 end if end if if ( include_qn_source . and . iproc == 0 ) then istatus = nf90_def_var ( ncid , \"phiprojr\" , netcdf_real , & ( / kxid , zedid , tubeid / ), phiprojr_id ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_var phiprojr error: \" , nf90_strerror ( istatus ) goto 1 end if istatus = nf90_def_var ( ncid , \"phiproji\" , netcdf_real , & ( / kxid , zedid , tubeid / ), phiproji_id ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_var phiproji error: \" , nf90_strerror ( istatus ) goto 1 end if end if if ( source_option_switch == source_option_projection . and . has_vmulo ) then istatus = nf90_def_var ( ncid , \"intproj\" , netcdf_real , intproj_id ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_var intproj error: \" , nf90_strerror ( istatus ) goto 1 end if istatus = nf90_def_var ( ncid , \"projr\" , netcdf_real , & ( / kxid , zedid , tubeid , gvmuloid / ), projr_id ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_var projr error: \" , nf90_strerror ( istatus ) goto 1 end if istatus = nf90_def_var ( ncid , \"proji\" , netcdf_real , & ( / kxid , zedid , tubeid , gvmuloid / ), proji_id ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_var proji error: \" , nf90_strerror ( istatus ) goto 1 end if end if ! we need shift_state variable defined in netcdf file even if no exb ! shear present in simulation) -- MAB + CMR istatus = nf90_def_var ( ncid , \"shiftstate\" , netcdf_real , & ( / kyid / ), shift_id ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_def_var shiftstate error: \" , nf90_strerror ( istatus ) goto 1 end if !           if (fbpar > epsilon(0.)) then !              istatus = nf90_def_var (ncid, \"bpar_r\", netcdf_real, & !                   (/ zedid, kxid, kyid /), bparr_id) !              if (istatus /= NF90_NOERR) then !                 ierr = error_unit() !                 write(ierr,*) \"nf90_def_var bparr error: \", nf90_strerror(istatus) !                 goto 1 !              end if !              istatus = nf90_def_var (ncid, \"bpar_i\", netcdf_real, & !                   (/ zedid, kxid, kyid /), bpari_id) !              if (istatus /= NF90_NOERR) then !                 ierr = error_unit() !                 write(ierr,*) \"nf90_def_var bpari error: \", nf90_strerror(istatus) !                 goto 1 !              end if !           end if end if !    if (proc0) then !      write (*,*) \"Finished definitions\" !      write (*,*) \"List restart files\" !      call system(\"echo 'defs' >> filelist.txt; ls nc/* >> filelist.txt;  \") !    end if istatus = nf90_enddef ( ncid ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_enddef error: \" , nf90_strerror ( istatus ) goto 1 end if end if !!!-----------------------!!! !!!-----------------------!!! !!!-----------------------!!! # ifdef NETCDF_PARALLEL if ( save_many . or . iproc == 0 ) then # endif istatus = nf90_put_var ( ncid , delt0id , delt0 ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_put_var delt0 error: \" , nf90_strerror ( istatus ) goto 1 end if istatus = nf90_put_var ( ncid , t0id , t0 ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_put_var t0 error: \" , nf90_strerror ( istatus ) goto 1 end if istatus = nf90_put_var ( ncid , istep0id , istep0 ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_put_var istep0 error: \" , nf90_strerror ( istatus ) goto 1 end if # ifdef NETCDF_PARALLEL end if # endif 1 continue if ( istatus /= NF90_NOERR ) then i = nf90_close ( ncid ) return end if if ( n_elements > 0 ) then if (. not . allocated ( tmpr )) & allocate ( tmpr ( nvpa , nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) tmpr = real ( g ) # ifdef NETCDF_PARALLEL if ( save_many ) then # endif istatus = nf90_put_var ( ncid , gr_id , tmpr ) #ifdef NETCDF_PARALLEL else istatus = nf90_var_par_access ( ncid , gr_id , NF90_COLLECTIVE ) istatus = nf90_var_par_access ( ncid , gi_id , NF90_COLLECTIVE ) start_pos = ( / 1 , 1 , kxkyz_lo % llim_proc + 1 / ) counts = ( / nvpa , nmu , n_elements / ) istatus = nf90_put_var ( ncid , gr_id , tmpr , start = start_pos , count = counts ) end if # endif if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , gr_id ) tmpr = aimag ( g ) # ifdef NETCDF_PARALLEL if ( save_many ) then # endif istatus = nf90_put_var ( ncid , gi_id , tmpr ) #ifdef NETCDF_PARALLEL else istatus = nf90_put_var ( ncid , gi_id , tmpr , start = start_pos , count = counts ) end if # endif if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , gi_id ) if ( source_option_switch == source_option_krook . and . has_vmulo ) then if (. not . allocated ( ktmpr )) & allocate ( ktmpr ( nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) if (. not . allocated ( ktmpi )) & allocate ( ktmpi ( nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) # ifdef NETCDF_PARALLEL if ( save_many . or . iproc == 0 ) then # endif istatus = nf90_put_var ( ncid , intkrook_id , int_krook ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_put_var int_krook error: \" , nf90_strerror ( istatus ) goto 1 end if # ifdef NETCDF_PARALLEL end if # endif ktmpr = real ( g_krook ) ktmpi = aimag ( g_krook ) # ifdef NETCDF_PARALLEL if ( save_many ) then # endif istatus = nf90_put_var ( ncid , krookr_id , ktmpr ) #ifdef NETCDF_PARALLEL else istatus = nf90_var_par_access ( ncid , krookr_id , NF90_COLLECTIVE ) istatus = nf90_var_par_access ( ncid , krooki_id , NF90_COLLECTIVE ) start_pos = ( / 1 , 1 , 1 , vmu_lo % llim_proc + 1 / ) counts = ( / nakx , nztot , ntubes , nvmulo_elements / ) istatus = nf90_put_var ( ncid , krookr_id , ktmpr , start = start_pos , count = counts ) end if # endif if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , krookr_id ) # ifdef NETCDF_PARALLEL if ( save_many ) then # endif istatus = nf90_put_var ( ncid , krooki_id , ktmpi ) #ifdef NETCDF_PARALLEL else istatus = nf90_put_var ( ncid , krooki_id , ktmpi , start = start_pos , count = counts ) end if # endif if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , krooki_id ) end if if ( source_option_switch == source_option_projection . and . has_vmulo ) then if (. not . allocated ( ptmpr )) & allocate ( ptmpr ( nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) if (. not . allocated ( ptmpi )) & allocate ( ptmpi ( nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) # ifdef NETCDF_PARALLEL if ( save_many . or . iproc == 0 ) then # endif istatus = nf90_put_var ( ncid , intproj_id , int_proj ) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_put_var int_proj error: \" , nf90_strerror ( istatus ) goto 1 end if # ifdef NETCDF_PARALLEL end if # endif ptmpr = real ( g_proj ) ptmpi = aimag ( g_proj ) # ifdef NETCDF_PARALLEL if ( save_many ) then # endif istatus = nf90_put_var ( ncid , projr_id , ptmpr ) #ifdef NETCDF_PARALLEL else istatus = nf90_var_par_access ( ncid , projr_id , NF90_COLLECTIVE ) istatus = nf90_var_par_access ( ncid , proji_id , NF90_COLLECTIVE ) start_pos = ( / 1 , 1 , 1 , vmu_lo % llim_proc + 1 / ) counts = ( / nakx , nztot , ntubes , nvmulo_elements / ) istatus = nf90_put_var ( ncid , projr_id , ptmpr , start = start_pos , count = counts ) end if # endif if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , projr_id ) # ifdef NETCDF_PARALLEL if ( save_many ) then # endif istatus = nf90_put_var ( ncid , proji_id , ptmpi ) #ifdef NETCDF_PARALLEL else istatus = nf90_put_var ( ncid , proji_id , ptmpi , start = start_pos , count = counts ) end if # endif if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , proji_id ) end if istatus = nf90_put_var ( ncid , shift_id , shift_state ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , shift_id ) if ( include_qn_source . and . iproc == 0 ) then if (. not . allocated ( pptmpr )) & allocate ( pptmpr ( nakx , - nzgrid : nzgrid , ntubes )) if (. not . allocated ( pptmpi )) & allocate ( pptmpi ( nakx , - nzgrid : nzgrid , ntubes )) pptmpr = real ( phi_proj ) pptmpi = aimag ( phi_proj ) # ifdef NETCDF_PARALLEL if ( save_many ) then # endif istatus = nf90_put_var ( ncid , phiprojr_id , pptmpr ) #ifdef NETCDF_PARALLEL else istatus = nf90_var_par_access ( ncid , phiprojr_id , NF90_COLLECTIVE ) istatus = nf90_var_par_access ( ncid , phiproji_id , NF90_COLLECTIVE ) start_pos = ( / 1 , 1 , 1 / ) counts = ( / nakx , nztot , ntubes / ) istatus = nf90_put_var ( ncid , phiprojr_id , ktmpr , start = start_pos , count = counts ) end if # endif if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , phiprojr_id ) # ifdef NETCDF_PARALLEL if ( save_many ) then # endif istatus = nf90_put_var ( ncid , phiproji_id , pptmpi ) #ifdef NETCDF_PARALLEL else istatus = nf90_put_var ( ncid , phiproji_id , pptmpi , start = start_pos , count = counts ) end if # endif if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , phiproji_id ) end if end if if ( exit ) then i = nf90_close ( ncid ) if ( i /= NF90_NOERR ) & call netcdf_error ( istatus , message = 'nf90_close error' ) else i = nf90_sync ( ncid ) if ( i /= NF90_NOERR ) & call netcdf_error ( istatus , message = 'nf90_sync error' ) end if # else if ( proc0 ) write ( error_unit (), * ) & 'WARNING: stella_save_for_restart is called without netcdf library' # endif if ( allocated ( tmpr )) deallocate ( tmpr ) if ( allocated ( tmpi )) deallocate ( tmpi ) if ( allocated ( ptmpr )) deallocate ( ptmpr ) if ( allocated ( ptmpi )) deallocate ( ptmpi ) if ( allocated ( ktmpr )) deallocate ( ktmpr ) if ( allocated ( ktmpi )) deallocate ( ktmpi ) if ( allocated ( pptmpr )) deallocate ( pptmpr ) if ( allocated ( pptmpi )) deallocate ( pptmpi ) end subroutine stella_save_for_restart !!----------------------------------------------------------------------!! !!----------------------------------------------------------------------!! !!---Restart------------------------------------------------------------!! !!----------------------------------------------------------------------!! !!----------------------------------------------------------------------!! subroutine stella_restore_many ( g , scale , istatus ) # ifdef NETCDF use fields_arrays , only : shift_state , phi_proj use dist_fn_arrays , only : g_krook , g_proj use kt_grids , only : naky , nakx # endif # ifdef NETCDF_PARALLEL use zgrid , only : nztot # endif use mp , only : iproc , broadcast use zgrid , only : nzgrid , ntubes use vpamu_grids , only : nvpa , nmu use stella_layouts , only : kxkyz_lo , vmu_lo use file_utils , only : error_unit use sources , only : source_option_krook , source_option_projection use sources , only : source_option_switch , int_krook , int_proj use sources , only : include_qn_source implicit none complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( out ) :: g real , intent ( in ) :: scale integer , intent ( out ) :: istatus # ifdef NETCDF # ifdef NETCDF_PARALLEL integer , dimension ( 3 ) :: counts , start_pos # endif character ( 306 ) :: file_proc character ( 10 ) :: suffix integer :: i , n_elements , nvmulo_elements , ierr logical :: has_vmulo n_elements = kxkyz_lo % ulim_proc - kxkyz_lo % llim_proc + 1 nvmulo_elements = vmu_lo % ulim_proc - vmu_lo % llim_proc + 1 if ( n_elements <= 0 ) return has_vmulo = nvmulo_elements > 0 . or . . not . read_many if (. not . initialized ) then !       initialized = .true. file_proc = trim ( restart_file ) # ifdef NETCDF_PARALLEL if ( read_many ) then # endif write ( suffix , '(a1,i0)' ) '.' , iproc file_proc = trim ( trim ( file_proc ) // adjustl ( suffix )) istatus = nf90_open ( file_proc , NF90_NOWRITE , ncid ) # ifdef NETCDF_PARALLEL else ! If using netcdf version 4.1.2 deleted NF90_MPIIO and the associated IOR istatus = nf90_open ( file_proc , IOR ( NF90_NOWRITE , NF90_MPIIO ), ncid , comm = mp_comm , info = mp_info ) end if # endif if ( istatus /= NF90_NOERR ) then call netcdf_error ( istatus , file = file_proc , abort = . true .) end if ! check precision if ( netcdf_real == 0 ) netcdf_real = get_netcdf_code_precision () call check_netcdf_file_precision ( ncid ) istatus = nf90_inq_dimid ( ncid , \"tube\" , tubeid ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , dim = 'tube' ) istatus = nf90_inq_dimid ( ncid , \"zed\" , zedid ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , dim = 'zed' ) istatus = nf90_inq_dimid ( ncid , \"aky\" , kyid ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , dim = 'aky' ) istatus = nf90_inq_dimid ( ncid , \"akx\" , kxid ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , dim = 'akx' ) istatus = nf90_inq_dimid ( ncid , \"glo\" , gloid ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , dim = 'glo' ) if ( has_vmulo ) then istatus = nf90_inq_dimid ( ncid , \"gvmulo\" , gvmuloid ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , dim = 'gvmulo' ) end if istatus = nf90_inquire_dimension ( ncid , tubeid , len = i ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , dimid = tubeid ) if ( i /= ntubes ) write ( * , * ) 'Restart error: ntubes=? ' , i , ' : ' , ntubes , ' : ' , iproc istatus = nf90_inquire_dimension ( ncid , zedid , len = i ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , dimid = zedid ) if ( i /= 2 * nzgrid + 1 ) write ( * , * ) 'Restart error: nzgrid=? ' , i , ' : ' , nzgrid , ' : ' , iproc istatus = nf90_inquire_dimension ( ncid , kyid , len = i ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , dimid = kyid ) if ( i /= naky ) write ( * , * ) 'Restart error: naky=? ' , i , ' : ' , naky , ' : ' , iproc istatus = nf90_inquire_dimension ( ncid , kxid , len = i ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , dimid = kxid ) if ( i /= nakx ) write ( * , * ) 'Restart error: nakx=? ' , i , ' : ' , nakx , ' : ' , iproc istatus = nf90_inquire_dimension ( ncid , gloid , len = i ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , dimid = gloid ) #ifdef NETCDF_PARALLEL if ( read_many ) then #endif if ( i /= n_elements ) write ( * , * ) 'Restart error: glo=? ' , i , ' : ' , iproc #ifdef NETCDF_PARALLEL else if ( i /= kxkyz_lo % ulim_world + 1 ) write ( * , * ) 'Restart error: glo=? ' , i , ' : ' , iproc end if #endif if ( has_vmulo ) then istatus = nf90_inquire_dimension ( ncid , gvmuloid , len = i ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , dimid = gvmuloid ) #ifdef NETCDF_PARALLEL if ( read_many ) then #endif if ( i /= nvmulo_elements ) write ( * , * ) 'Restart error: gvmulo=? ' , i , ' : ' , iproc #ifdef NETCDF_PARALLEL else if ( i /= vmu_lo % ulim_world + 1 ) write ( * , * ) 'Restart error: gvmulo=? ' , i , ' : ' , iproc end if #endif end if if ( source_option_switch == source_option_krook . and . has_vmulo ) then istatus = nf90_inq_varid ( ncid , \"intkrook\" , intkrook_id ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , var = 'intkrook' ) istatus = nf90_inq_varid ( ncid , \"krookr\" , krookr_id ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , var = 'krookr' ) istatus = nf90_inq_varid ( ncid , \"krooki\" , krooki_id ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , var = 'krooki' ) end if if ( source_option_switch == source_option_projection . and . has_vmulo ) then istatus = nf90_inq_varid ( ncid , \"intproj\" , intproj_id ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , var = 'intproj' ) istatus = nf90_inq_varid ( ncid , \"projr\" , projr_id ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , var = 'projr' ) istatus = nf90_inq_varid ( ncid , \"proji\" , proji_id ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , var = 'proji' ) end if if ( include_qn_source . and . iproc == 0 ) then istatus = nf90_inq_varid ( ncid , \"phiprojr\" , phiprojr_id ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , var = 'phiprojr' ) istatus = nf90_inq_varid ( ncid , \"phiproji\" , phiproji_id ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , var = 'phiproji' ) end if istatus = nf90_inq_varid ( ncid , \"shiftstate\" , shift_id ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , var = 'shiftstate' ) !        if (fbpar > epsilon(0.)) then !           istatus = nf90_inq_varid (ncid, \"bpar_r\", bparr_id) !           if (istatus /= NF90_NOERR) call netcdf_error (istatus, var='bpar_r') !           istatus = nf90_inq_varid (ncid, \"bpar_i\", bpari_id) !           if (istatus /= NF90_NOERR) call netcdf_error (istatus, var='bpar_i') !        end if !       if (allocated(kx_shift)) then   ! MR begin !          istatus = nf90_inq_varid (ncid, \"kx_shift\", kx_shift_id) !          if (istatus /= NF90_NOERR) call netcdf_error (istatus, var='kx_shift') !       endif   ! MR end istatus = nf90_inq_varid ( ncid , \"gr\" , gr_id ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , var = 'gr' ) istatus = nf90_inq_varid ( ncid , \"gi\" , gi_id ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , var = 'gi' ) end if if (. not . allocated ( tmpr )) & allocate ( tmpr ( nvpa , nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) if (. not . allocated ( tmpi )) & allocate ( tmpi ( nvpa , nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) tmpr = 0. ; tmpi = 0. # ifdef NETCDF_PARALLEL if ( read_many ) then # endif istatus = nf90_get_var ( ncid , gr_id , tmpr ) #ifdef NETCDF_PARALLEL else start_pos = ( / 1 , 1 , kxkyz_lo % llim_proc + 1 / ) counts = ( / nvpa , nmu , n_elements / ) istatus = nf90_get_var ( ncid , gr_id , tmpr , start = start_pos , count = counts ) end if # endif if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , gr_id ) # ifdef NETCDF_PARALLEL if ( read_many ) then # endif istatus = nf90_get_var ( ncid , gi_id , tmpi ) #ifdef NETCDF_PARALLEL else istatus = nf90_get_var ( ncid , gi_id , tmpi , start = start_pos , count = counts ) end if # endif if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , gi_id ) g = cmplx ( tmpr , tmpi ) if ( source_option_switch == source_option_krook . and . has_vmulo ) then if (. not . allocated ( ktmpr )) & allocate ( ktmpr ( nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) if (. not . allocated ( ktmpi )) & allocate ( ktmpi ( nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) istatus = nf90_get_var ( ncid , intkrook_id , int_krook ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , intkrook_id ) ktmpr = 0. ; ktmpi = 0. # ifdef NETCDF_PARALLEL if ( read_many ) then # endif istatus = nf90_get_var ( ncid , krookr_id , ktmpr ) #ifdef NETCDF_PARALLEL else start_pos = ( / 1 , 1 , 1 , vmu_lo % llim_proc + 1 / ) counts = ( / nakx , nztot , ntubes , nvmulo_elements / ) istatus = nf90_get_var ( ncid , krookr_id , ktmpr , start = start_pos , count = counts ) end if # endif if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , krookr_id ) # ifdef NETCDF_PARALLEL if ( read_many ) then # endif istatus = nf90_get_var ( ncid , krooki_id , ktmpi ) #ifdef NETCDF_PARALLEL else istatus = nf90_get_var ( ncid , krooki_id , ktmpi , start = start_pos , count = counts ) end if # endif if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , krooki_id ) g_krook = cmplx ( ktmpr , ktmpi ) end if if ( source_option_switch == source_option_projection . and . has_vmulo ) then if (. not . allocated ( ptmpr )) & allocate ( ptmpr ( nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) if (. not . allocated ( ptmpi )) & allocate ( ptmpi ( nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) istatus = nf90_get_var ( ncid , intproj_id , int_proj ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , intproj_id ) ptmpr = 0. ; ptmpi = 0. # ifdef NETCDF_PARALLEL if ( read_many ) then # endif istatus = nf90_get_var ( ncid , projr_id , ptmpr ) #ifdef NETCDF_PARALLEL else start_pos = ( / 1 , 1 , 1 , vmu_lo % llim_proc + 1 / ) counts = ( / nakx , nztot , ntubes , nvmulo_elements / ) istatus = nf90_get_var ( ncid , projr_id , ptmpr , start = start_pos , count = counts ) end if # endif if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , projr_id ) # ifdef NETCDF_PARALLEL if ( read_many ) then # endif istatus = nf90_get_var ( ncid , proji_id , ptmpi ) #ifdef NETCDF_PARALLEL else istatus = nf90_get_var ( ncid , proji_id , ptmpi , start = start_pos , count = counts ) end if # endif if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , proji_id ) g_proj = cmplx ( ptmpr , ptmpi ) end if if ( include_qn_source . and . iproc == 0 ) then if (. not . allocated ( pptmpr )) allocate ( pptmpr ( nakx , - nzgrid : nzgrid , ntubes )) if (. not . allocated ( pptmpi )) allocate ( pptmpi ( nakx , - nzgrid : nzgrid , ntubes )) pptmpr = 0. ; pptmpi = 0. # ifdef NETCDF_PARALLEL if ( read_many ) then # endif istatus = nf90_get_var ( ncid , phiprojr_id , pptmpr ) #ifdef NETCDF_PARALLEL else start_pos = ( / 1 , 1 , 1 / ) counts = ( / nakx , nztot , ntubes / ) istatus = nf90_get_var ( ncid , phiprojr_id , pptmpr , start = start_pos , count = counts ) end if # endif if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , phiprojr_id ) # ifdef NETCDF_PARALLEL if ( read_many ) then # endif istatus = nf90_get_var ( ncid , phiproji_id , pptmpi ) #ifdef NETCDF_PARALLEL else istatus = nf90_get_var ( ncid , phiproji_id , pptmpi , start = start_pos , count = counts ) end if # endif if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , phiproji_id ) phi_proj = cmplx ( pptmpr , pptmpi ) end if if (. not . allocated ( shift_state )) allocate ( shift_state ( naky )) istatus = nf90_get_var ( ncid , shift_id , shift_state ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , ncid , shift_id ) if ( scale > 0. ) then g = g * scale if ( source_option_switch == source_option_krook ) g_krook = g_krook * scale if ( source_option_switch == source_option_projection ) g_proj = g_proj * scale end if ! RN 2008/05/23: this was commented out. why? HJL 2013/05/15 Because it stops future writing to the file !    istatus = nf90_close (ncid) if ( istatus /= NF90_NOERR ) then ierr = error_unit () write ( ierr , * ) \"nf90_close error: \" , nf90_strerror ( istatus ), ' ' , iproc end if # else write ( error_unit (), * ) & 'ERROR: stella_restore_many is called without netcdf' # endif if ( allocated ( tmpr )) deallocate ( tmpr ) if ( allocated ( tmpi )) deallocate ( tmpi ) if ( allocated ( ptmpr )) deallocate ( ptmpr ) if ( allocated ( ptmpi )) deallocate ( ptmpi ) if ( allocated ( ktmpr )) deallocate ( ktmpr ) if ( allocated ( ktmpi )) deallocate ( ktmpi ) if ( allocated ( pptmpr )) deallocate ( pptmpr ) if ( allocated ( pptmpi )) deallocate ( pptmpi ) if ( include_qn_source ) call broadcast ( phi_proj ) end subroutine stella_restore_many subroutine init_save ( file ) character ( 300 ), intent ( in ) :: file restart_file = file end subroutine init_save subroutine init_dt ( delt0 , istatus ) # ifdef NETCDF use mp , only : proc0 , broadcast use file_utils , only : error_unit # endif implicit none real , intent ( in out ) :: delt0 integer , intent ( out ) :: istatus # ifdef NETCDF character ( 306 ) :: file_proc if ( proc0 ) then if (. not . initialized ) then # ifdef NETCDF_PARALLEL if ( read_many ) then # endif file_proc = trim ( trim ( restart_file ) // '.0' ) # ifdef NETCDF_PARALLEL else file_proc = trim ( trim ( restart_file )) end if # endif istatus = nf90_open ( file_proc , NF90_NOWRITE , ncid ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , file = file_proc ) istatus = nf90_inq_varid ( ncid , \"delt0\" , delt0id ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , var = 'delt0' ) end if istatus = nf90_get_var ( ncid , delt0id , delt0 ) if ( istatus /= NF90_NOERR ) then call netcdf_error ( istatus , ncid , delt0id , message = ' in init_dt' ) delt0 = - 1. end if if (. not . initialized ) istatus = nf90_close ( ncid ) end if call broadcast ( istatus ) call broadcast ( delt0 ) # endif end subroutine init_dt subroutine init_tstart ( tstart , istep0 , istatus ) # ifdef NETCDF use mp , only : proc0 , broadcast use file_utils , only : error_unit # endif implicit none real , intent ( in out ) :: tstart integer , intent ( out ) :: istep0 integer , intent ( out ) :: istatus # ifdef NETCDF character ( 306 ) :: file_proc if ( proc0 ) then # ifdef NETCDF_PARALLEL if ( read_many ) then # endif file_proc = trim ( trim ( restart_file ) // '.0' ) # ifdef NETCDF_PARALLEL else file_proc = trim ( trim ( restart_file )) end if # endif if (. not . initialized ) then istatus = nf90_open ( file_proc , NF90_NOWRITE , ncid ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , file = file_proc ) end if istatus = nf90_inq_varid ( ncid , \"t0\" , t0id ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , var = 't0' ) istatus = nf90_get_var ( ncid , t0id , tstart ) if ( istatus /= NF90_NOERR ) then call netcdf_error ( istatus , ncid , t0id , message = ' in init_tstart' ) tstart = - 1. end if istatus = nf90_inq_varid ( ncid , \"istep0\" , istep0id ) if ( istatus /= NF90_NOERR ) call netcdf_error ( istatus , var = 'istep0' ) istatus = nf90_get_var ( ncid , istep0id , istep0 ) if ( istatus /= NF90_NOERR ) then call netcdf_error ( istatus , ncid , istep0id , message = ' in init_tstart' ) istep0 = - 1 end if if (. not . initialized ) istatus = nf90_close ( ncid ) end if call broadcast ( istatus ) call broadcast ( istep0 ) call broadcast ( tstart ) # endif end subroutine init_tstart subroutine finish_save if ( allocated ( tmpr )) deallocate ( tmpr ) if ( allocated ( tmpi )) deallocate ( tmpi ) end subroutine finish_save end module stella_save","tags":"","loc":"sourcefile/stella_save.fpp.html"},{"title":"dist_fn.f90 – stella","text":"Source Code module dist_fn implicit none public :: init_gxyz public :: init_dist_fn , finish_dist_fn public :: checksum private interface checksum module procedure checksum_field module procedure checksum_dist end interface logical :: dist_fn_initialized = . false . logical :: gxyz_initialized = . false . logical :: kp2init = . false . logical :: dkp2drinit = . false . logical :: vp2init = . false . logical :: debug = . false . contains subroutine init_gxyz ( restarted ) use dist_fn_arrays , only : gvmu , gold , gnew use redistribute , only : gather , scatter use dist_redistribute , only : kxkyz2vmu use physics_flags , only : radial_variation use stella_layouts , only : vmu_lo , iv_idx , imu_idx , is_idx use stella_transforms , only : transform_kx2x_xfirst , transform_x2kx_xfirst use kt_grids , only : nalpha , nakx , naky , multiply_by_rho use vpamu_grids , only : mu , vpa , vperp2 use zgrid , only : nzgrid , ntubes use species , only : spec , pfac use stella_geometry , only : dBdrho , gfac implicit none real :: corr integer :: ivmu , is , imu , iv , it , iz , ia real , dimension (:, :), allocatable :: energy complex , dimension (:, :), allocatable :: g0k logical , intent ( in ) :: restarted if ( gxyz_initialized ) return gxyz_initialized = . false . ! get version of g that has ky,kx,z local call gather ( kxkyz2vmu , gvmu , gnew ) ia = 1 !calculate radial corrections to F0 for use in Krook operator, as well as g1 from initialization if ( radial_variation ) then !init_g uses maxwellians, so account for variation in temperature, density, and B allocate ( energy ( nalpha , - nzgrid : nzgrid )) allocate ( g0k ( naky , nakx )) do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) iv = iv_idx ( vmu_lo , ivmu ) energy = ( vpa ( iv ) ** 2 + vperp2 (:, :, imu )) * ( spec ( is )% temp_psi0 / spec ( is )% temp ) do it = 1 , ntubes do iz = - nzgrid , nzgrid corr = - ( pfac * ( spec ( is )% fprim + spec ( is )% tprim * ( energy ( ia , iz ) - 1.5 )) & + 2 * gfac * mu ( imu ) * dBdrho ( iz )) if (. not . restarted ) then g0k = corr * gnew (:, :, iz , it , ivmu ) call multiply_by_rho ( g0k ) gnew (:, :, iz , it , ivmu ) = gnew (:, :, iz , it , ivmu ) + g0k end if end do end do end do deallocate ( energy , g0k ) if (. not . restarted ) call scatter ( kxkyz2vmu , gnew , gvmu ) end if gold = gnew end subroutine init_gxyz subroutine init_dist_fn use mp , only : proc0 use physics_flags , only : radial_variation use stella_layouts , only : init_dist_fn_layouts use gyro_averages , only : init_bessel implicit none if ( dist_fn_initialized ) return dist_fn_initialized = . true . debug = debug . and . proc0 if ( debug ) write ( * , * ) 'dist_fn::init_dist_fn::allocate_arrays' call allocate_arrays !> allocate and initialise kperp2 and dkperp2dr if ( debug ) write ( * , * ) 'dist_fn::init_dist_fn::init_kperp2' call init_kperp2 if ( radial_variation ) call init_dkperp2dr !> allocate and initialise vperp2 if ( debug ) write ( * , * ) 'dist_fn::init_dist_fn::init_vperp2' call init_vperp2 !> init_bessel sets up arrays needed for gyro-averaging; !> for a flux tube simulation, this is j0 and j1; !> for a flux annulus simulation, gyro-averaging is non-local in ky !> and so more effort is required if ( debug ) write ( * , * ) 'dist_fn::init_dist_fn::init_bessel' call init_bessel end subroutine init_dist_fn !> init_kperp2 allocates and initialises the kperp2 array subroutine init_kperp2 use dist_fn_arrays , only : kperp2 use stella_geometry , only : gds2 , gds21 , gds22 use stella_geometry , only : geo_surf , q_as_x use zgrid , only : nzgrid use kt_grids , only : naky , nakx , theta0 use kt_grids , only : akx , aky use kt_grids , only : zonal_mode use kt_grids , only : nalpha implicit none integer :: iky , ikx if ( kp2init ) return kp2init = . true . !> allocate the kperp2 array to contain |k_perp|&#94;2 allocate ( kperp2 ( naky , nakx , nalpha , - nzgrid : nzgrid )) do iky = 1 , naky if ( zonal_mode ( iky )) then do ikx = 1 , nakx if ( q_as_x ) then kperp2 ( iky , ikx , :, :) = akx ( ikx ) * akx ( ikx ) * gds22 else kperp2 ( iky , ikx , :, :) = akx ( ikx ) * akx ( ikx ) * gds22 / ( geo_surf % shat ** 2 ) end if end do else do ikx = 1 , nakx kperp2 ( iky , ikx , :, :) = aky ( iky ) * aky ( iky ) & * ( gds2 + 2.0 * theta0 ( iky , ikx ) * gds21 & + theta0 ( iky , ikx ) * theta0 ( iky , ikx ) * gds22 ) end do end if end do ! NB: should really avoid this by using higher resolution when reading in VMEC geometry and then ! NB: course-graining if necessary to map onto lower-resolution stella grid ! ensure kperp2 is positive everywhere (only might go negative if using full-flux-surface due to interpolation) where ( kperp2 < 0.0 ) kperp2 = 0.0 end where call enforce_single_valued_kperp2 end subroutine init_kperp2 !> init_dkperp2dr allocates and initialises the dkperp2dr array, needed for radial variation subroutine init_dkperp2dr use dist_fn_arrays , only : kperp2 , dkperp2dr use stella_geometry , only : dgds2dr , dgds21dr , dgds22dr use stella_geometry , only : geo_surf , q_as_x use zgrid , only : nzgrid use kt_grids , only : naky , nakx , theta0 use kt_grids , only : akx , aky use kt_grids , only : zonal_mode use kt_grids , only : nalpha implicit none integer :: iky , ikx if ( dkp2drinit ) return dkp2drinit = . true . allocate ( dkperp2dr ( naky , nakx , nalpha , - nzgrid : nzgrid )) do iky = 1 , naky if ( zonal_mode ( iky )) then do ikx = 1 , nakx if ( q_as_x ) then where ( kperp2 ( iky , ikx , :, :) > epsilon ( 0.0 )) dkperp2dr ( iky , ikx , :, :) = akx ( ikx ) * akx ( ikx ) * dgds22dr / kperp2 ( iky , ikx , :, :) elsewhere dkperp2dr ( iky , ikx , :, :) = 0.0 end where else where ( kperp2 ( iky , ikx , :, :) > epsilon ( 0.0 )) dkperp2dr ( iky , ikx , :, :) = akx ( ikx ) * akx ( ikx ) * dgds22dr / ( geo_surf % shat ** 2 * kperp2 ( iky , ikx , :, :)) elsewhere dkperp2dr ( iky , ikx , :, :) = 0.0 end where end if end do else do ikx = 1 , nakx dkperp2dr ( iky , ikx , :, :) = aky ( iky ) * aky ( iky ) & * ( dgds2dr + 2.0 * theta0 ( iky , ikx ) * dgds21dr & + theta0 ( iky , ikx ) * theta0 ( iky , ikx ) * dgds22dr ) dkperp2dr ( iky , ikx , :, :) = dkperp2dr ( iky , ikx , :, :) / kperp2 ( iky , ikx , :, :) if ( any ( kperp2 ( iky , ikx , :, :) < epsilon ( 0. ))) dkperp2dr ( iky , ikx , :, :) = 0. end do end if end do end subroutine init_dkperp2dr subroutine enforce_single_valued_kperp2 use dist_fn_arrays , only : kperp2 use kt_grids , only : naky , nalpha use zgrid , only : nzgrid use extended_zgrid , only : neigen , nsegments , ikxmod implicit none integer :: iky , ie , iseg real , dimension (:), allocatable :: tmp allocate ( tmp ( nalpha )); tmp = 0.0 do iky = 1 , naky do ie = 1 , neigen ( iky ) if ( nsegments ( ie , iky ) > 1 ) then do iseg = 2 , nsegments ( ie , iky ) tmp = 0.5 * ( kperp2 ( iky , ikxmod ( iseg - 1 , ie , iky ), :, nzgrid ) + kperp2 ( iky , ikxmod ( iseg , ie , iky ), :, - nzgrid )) kperp2 ( iky , ikxmod ( iseg , ie , iky ), :, - nzgrid ) = tmp kperp2 ( iky , ikxmod ( iseg - 1 , ie , iky ), :, nzgrid ) = tmp end do end if end do end do deallocate ( tmp ) end subroutine enforce_single_valued_kperp2 subroutine allocate_arrays use stella_layouts , only : kxkyz_lo , vmu_lo use zgrid , only : nzgrid , ntubes use kt_grids , only : naky , nakx use vpamu_grids , only : nvpa , nmu use dist_fn_arrays , only : gnew , gold , g_scratch use dist_fn_arrays , only : gvmu implicit none if (. not . allocated ( gnew )) & allocate ( gnew ( naky , nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) gnew = 0. if (. not . allocated ( gold )) & allocate ( gold ( naky , nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) gold = 0. if (. not . allocated ( g_scratch )) & allocate ( g_scratch ( naky , nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) g_scratch = 0. if (. not . allocated ( gvmu )) & allocate ( gvmu ( nvpa , nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) gvmu = 0. end subroutine allocate_arrays subroutine init_vperp2 use stella_geometry , only : bmag use zgrid , only : nzgrid use vpamu_grids , only : vperp2 use vpamu_grids , only : nmu , mu use kt_grids , only : nalpha implicit none integer :: imu if ( vp2init ) return vp2init = . true . if (. not . allocated ( vperp2 )) allocate ( vperp2 ( nalpha , - nzgrid : nzgrid , nmu )); vperp2 = 0. do imu = 1 , nmu vperp2 (:, :, imu ) = 2.0 * mu ( imu ) * bmag end do end subroutine init_vperp2 subroutine finish_dist_fn use gyro_averages , only : finish_bessel implicit none call finish_bessel call finish_kperp2 call finish_vperp2 call deallocate_arrays dist_fn_initialized = . false . gxyz_initialized = . false . end subroutine finish_dist_fn subroutine deallocate_arrays use dist_fn_arrays , only : gnew , gold , g_scratch , gvmu implicit none if ( allocated ( gnew )) deallocate ( gnew ) if ( allocated ( gold )) deallocate ( gold ) if ( allocated ( g_scratch )) deallocate ( g_scratch ) if ( allocated ( gvmu )) deallocate ( gvmu ) end subroutine deallocate_arrays subroutine finish_kperp2 use dist_fn_arrays , only : kperp2 , dkperp2dr implicit none if ( allocated ( kperp2 )) deallocate ( kperp2 ) if ( allocated ( dkperp2dr )) deallocate ( dkperp2dr ) kp2init = . false . dkp2drinit = . false . end subroutine finish_kperp2 subroutine finish_vperp2 use vpamu_grids , only : vperp2 implicit none if ( allocated ( vperp2 )) deallocate ( vperp2 ) vp2init = . false . end subroutine finish_vperp2 subroutine checksum_field ( field , total ) use zgrid , only : nzgrid , ntubes use kt_grids , only : naky use extended_zgrid , only : neigen , nsegments , ikxmod use extended_zgrid , only : iz_low , iz_up implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: field real , intent ( out ) :: total integer :: it , iky , ie , iseg integer :: ikx total = 0. do iky = 1 , naky do it = 1 , ntubes do ie = 1 , neigen ( iky ) iseg = 1 ikx = ikxmod ( iseg , ie , iky ) total = total + sum ( cabs ( field ( iky , ikx , iz_low ( iseg ): iz_up ( iseg ), it ))) if ( nsegments ( ie , iky ) > 1 ) then do iseg = 2 , nsegments ( ie , iky ) ikx = ikxmod ( iseg , ie , iky ) total = total + sum ( cabs ( field ( iky , ikx , iz_low ( iseg ) + 1 : iz_up ( iseg ), it ))) end do end if end do end do end do end subroutine checksum_field subroutine checksum_dist ( dist , total , norm ) use mp , only : sum_allreduce use zgrid , only : nzgrid , ntubes use stella_layouts , only : vmu_lo , iv_idx , imu_idx , is_idx use kt_grids , only : naky , nakx use vpamu_grids , only : maxwell_vpa , maxwell_mu implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: dist real , intent ( out ) :: total logical , intent ( in ), optional :: norm integer :: ivmu , iv , imu , is integer :: iky , ikx , it real :: subtotal complex , dimension (:, :, :, :), allocatable :: dist_single total = 0. allocate ( dist_single ( naky , nakx , - nzgrid : nzgrid , ntubes )) do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc dist_single = dist (:, :, :, :, ivmu ) if ( present ( norm )) then if ( norm ) then iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) do it = 1 , ntubes do ikx = 1 , nakx do iky = 1 , naky dist_single ( iky , ikx , :, it ) = dist_single ( iky , ikx , :, it ) * maxwell_vpa ( iv , is ) * maxwell_mu ( 1 , :, imu , is ) end do end do end do else end if end if call checksum ( dist_single , subtotal ) total = total + subtotal end do deallocate ( dist_single ) call sum_allreduce ( total ) end subroutine checksum_dist end module dist_fn","tags":"","loc":"sourcefile/dist_fn.f90.html"},{"title":"response_matrix.fpp – stella","text":"Source Code module response_matrix use netcdf use mpi #ifdef ISO_C_BINDING use , intrinsic :: iso_c_binding , only : c_intptr_t #endif implicit none public :: init_response_matrix , finish_response_matrix public :: read_response_matrix public :: response_matrix_initialized private logical :: response_matrix_initialized = . false . integer , parameter :: mat_unit = 70 #ifdef ISO_C_BINDING integer ( c_intptr_t ) :: cur_pos #endif character ( 100 ) :: message_dgdphi , message_QN , message_lu real , dimension ( 2 ) :: time_dgdphi real , dimension ( 2 ) :: time_QN real , dimension ( 2 ) :: time_lu logical :: debug = . false . contains subroutine init_response_matrix use fields_arrays , only : response_matrix use kt_grids , only : naky use mp , only : proc0 use run_parameters , only : mat_gen #ifdef ISO_C_BINDING use fields_arrays , only : response_window #endif implicit none #ifdef ISO_C_BINDING integer :: ierr #endif debug = ( debug . and . proc0 ) if ( debug ) call write_response_matrix_message call setup_response_matrix_timings call setup_response_matrix_file_io if ( response_matrix_initialized ) return response_matrix_initialized = . true . if (. not . allocated ( response_matrix )) allocate ( response_matrix ( naky )) #ifdef ISO_C_BINDING call setup_shared_memory_window #endif call construct_response_matrix #ifdef ISO_C_BINDING call mpi_win_fence ( 0 , response_window , ierr ) #endif if ( proc0 . and . mat_gen ) then close ( unit = mat_unit ) end if if ( debug ) then write ( * , '(A)' ) \"    ############################################################\" write ( * , '(A)' ) \" \" end if end subroutine init_response_matrix subroutine write_response_matrix_message write ( * , * ) \" \" write ( * , '(A)' ) \"    ############################################################\" write ( * , '(A)' ) \"                         RESPONSE MATRIX\" write ( * , '(A)' ) \"    ############################################################\" end subroutine write_response_matrix_message subroutine setup_response_matrix_timings implicit none message_dgdphi = '     calculate dgdphi: ' message_QN = '     calculate QN:     ' message_lu = '     calculate LU:     ' time_dgdphi = 0.0 time_QN = 0.0 time_lu = 0.0 end subroutine setup_response_matrix_timings subroutine setup_response_matrix_file_io use mp , only : proc0 , job use run_parameters , only : mat_gen use system_fortran , only : systemf use kt_grids , only : naky implicit none character ( len = 15 ) :: job_str character ( len = 100 ) :: file_name ! All matrices handled by processor i_proc and job are stored ! on a single file named: response_mat_job.iproc if ( proc0 . and . mat_gen ) then call systemf ( 'mkdir -p mat' ) write ( job_str , '(I1.1)' ) job file_name = './mat/response_mat_' // trim ( job_str ) open ( unit = mat_unit , status = 'replace' , file = file_name , & position = 'rewind' , action = 'write' , form = 'unformatted' ) write ( unit = mat_unit ) naky end if end subroutine setup_response_matrix_file_io subroutine setup_shared_memory_window use mpi use , intrinsic :: iso_c_binding , only : c_intptr_t use mp , only : sgproc0 , real_size use mp , only : create_shared_memory_window use fields_arrays , only : response_window use fields , only : nfields use kt_grids , only : naky use extended_zgrid , only : neigen , nsegments , nzed_segment use extended_zgrid , only : periodic implicit none integer ( kind = MPI_ADDRESS_KIND ) :: win_size integer :: iky , ie integer :: nresponse ! Create a single shared memory window for all the response matrices and ! permutation arrays. ! Creating a window for each matrix/array would lead to performance ! degradation on some clusters if ( response_window == MPI_WIN_NULL ) then win_size = 0 if ( sgproc0 ) then do iky = 1 , naky do ie = 1 , neigen ( iky ) if ( periodic ( iky )) then nresponse = ( nsegments ( ie , iky ) * nzed_segment ) * nfields else nresponse = ( nsegments ( ie , iky ) * nzed_segment + 1 ) * nfields end if win_size = win_size & + int ( nresponse , MPI_ADDRESS_KIND ) * 4_MPI_ADDRESS_KIND & + int ( nresponse ** 2 , MPI_ADDRESS_KIND ) * 2 * real_size end do end do end if call create_shared_memory_window ( win_size , response_window , cur_pos ) end if end subroutine setup_shared_memory_window subroutine construct_response_matrix use mp , only : proc0 use job_manage , only : time_message use run_parameters , only : mat_gen use fields_arrays , only : response_matrix use kt_grids , only : naky use extended_zgrid , only : neigen #ifdef ISO_C_BINDING use fields_arrays , only : response_window #endif implicit none integer :: iky , ie #ifdef ISO_C_BINDING integer :: ierr #endif ! for a given ky and set of connected kx values ! give a unit impulse to phi at each zed location ! in the extended domain and solve for h(zed_extended,(vpa,mu,s)) do iky = 1 , naky if ( proc0 . and . mat_gen ) then write ( unit = mat_unit ) iky , neigen ( iky ) end if ! the response matrix for each ky has neigen(ky) ! independent sets of connected kx values if (. not . associated ( response_matrix ( iky )% eigen )) & allocate ( response_matrix ( iky )% eigen ( neigen ( iky ))) if ( debug ) call time_message (. false ., time_dgdphi , message_dgdphi ) call calculate_vspace_integrated_response ( iky ) !DSO - This ends parallelization over velocity space. !      At this point every processor has int dv dgdphi for a given ky !      and so the quasineutrality solve and LU decomposition can be !      parallelized locally if need be. !      This is preferable to parallelization over ky as the LU !      decomposition (and perhaps QN) will be dominated by the !      ky with the most connections if ( debug ) then call time_message (. true ., time_dgdphi , message_dgdphi ) call time_message (. false ., time_QN , message_QN ) end if #ifdef ISO_C_BINDING call mpi_win_fence ( 0 , response_window , ierr ) #endif call apply_field_solve_to_finish_response_matrix ( iky ) #ifdef ISO_C_BINDING call mpi_win_fence ( 0 , response_window , ierr ) #endif if ( debug ) then call time_message (. true ., time_QN , message_QN ) call time_message (. false ., time_lu , message_lu ) end if call lu_decompose_response_matrix ( iky ) if ( proc0 . and . debug ) then call time_message (. true ., time_lu , message_lu ) end if time_dgdphi = 0 time_QN = 0 time_lu = 0 do ie = 1 , neigen ( iky ) if ( proc0 . and . mat_gen ) then write ( unit = mat_unit ) response_matrix ( iky )% eigen ( ie )% idx write ( unit = mat_unit ) response_matrix ( iky )% eigen ( ie )% zloc end if end do end do end subroutine construct_response_matrix subroutine calculate_vspace_integrated_response ( iky ) use mp , only : proc0 use run_parameters , only : mat_gen use physics_flags , only : include_apar , include_bpar use extended_zgrid , only : neigen , ikxmod use extended_zgrid , only : nsegments , nzed_segment use extended_zgrid , only : periodic use extended_zgrid , only : iz_low , iz_up use stella_layouts , only : vmu_lo use fields , only : nfields implicit none integer , intent ( in ) :: iky integer :: ie , idx , ikx , iseg integer :: iz , izl_offset , izup integer :: nz_ext , nresponse , nresponse_per_field complex , dimension (:, :), allocatable :: gext complex , dimension (:), allocatable :: phi_ext , apar_ext , bpar_ext ! loop over the sets of connected kx values do ie = 1 , neigen ( iky ) ! number of zeds x number of segments on extended zed domain nz_ext = nsegments ( ie , iky ) * nzed_segment + 1 ! treat zonal mode specially to avoid double counting ! as it is periodic if ( periodic ( iky )) then nresponse_per_field = nz_ext - 1 else nresponse_per_field = nz_ext end if nresponse = nresponse_per_field * nfields if ( proc0 . and . mat_gen ) then write ( unit = mat_unit ) ie , nresponse end if call setup_response_matrix_zloc_idx ( iky , ie , nresponse ) allocate ( gext ( nz_ext , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) allocate ( phi_ext ( nz_ext )) allocate ( apar_ext ( nz_ext )) allocate ( bpar_ext ( nz_ext )) ! idx is the index in the extended zed domain ! that we are giving a unit impulse idx = 0 ! loop over segments, starting with 1 ! first segment is special because it has ! one more unique zed value than all others ! since domain is [z0-pi:z0+pi], including both endpoints ! i.e., one endpoint is shared with the previous segment iseg = 1 ! ikxmod gives the kx corresponding to iseg,ie,iky ikx = ikxmod ( iseg , ie , iky ) izl_offset = 0 ! avoid double-counting of periodic points for zonal mode (and other periodic modes) if ( periodic ( iky )) then izup = iz_up ( iseg ) - 1 else izup = iz_up ( iseg ) end if ! no need to obtain response to impulses at negative kx values do iz = iz_low ( iseg ), izup idx = idx + 1 call get_dpdf_dphi_matrix_column ( iky , ie , idx , nz_ext , nresponse_per_field , phi_ext , apar_ext , bpar_ext , gext ) if ( include_apar ) call get_dpdf_dapar_matrix_column ( iky , ie , idx , nz_ext , nresponse_per_field , phi_ext , apar_ext , bpar_ext , gext ) if ( include_bpar ) call get_dpdf_dbpar_matrix_column ( iky , ie , idx , nz_ext , nresponse_per_field , phi_ext , apar_ext , bpar_ext , gext ) end do ! once we have used one segment, remaining segments ! have one fewer unique zed point izl_offset = 1 if ( nsegments ( ie , iky ) > 1 ) then do iseg = 2 , nsegments ( ie , iky ) ikx = ikxmod ( iseg , ie , iky ) do iz = iz_low ( iseg ) + izl_offset , iz_up ( iseg ) idx = idx + 1 call get_dpdf_dphi_matrix_column ( iky , ie , idx , nz_ext , nresponse_per_field , phi_ext , apar_ext , bpar_ext , gext ) if ( include_apar ) call get_dpdf_dapar_matrix_column ( iky , ie , idx , nz_ext , nresponse_per_field , phi_ext , apar_ext , bpar_ext , gext ) if ( include_bpar ) call get_dpdf_dbpar_matrix_column ( iky , ie , idx , nz_ext , nresponse_per_field , phi_ext , apar_ext , bpar_ext , gext ) end do if ( izl_offset == 0 ) izl_offset = 1 end do end if deallocate ( gext , phi_ext , apar_ext , bpar_ext ) end do end subroutine calculate_vspace_integrated_response subroutine setup_response_matrix_zloc_idx ( iky , ie , nresponse ) #ifdef ISO_C_BINDING use , intrinsic :: iso_c_binding , only : c_ptr , c_f_pointer use mp , only : nbytes_real #endif use fields_arrays , only : response_matrix implicit none integer , intent ( in ) :: iky , ie , nresponse #ifdef ISO_C_BINDING type ( c_ptr ) :: cptr !exploit MPIs shared memory framework to reduce memory consumption of !response matrices if (. not . associated ( response_matrix ( iky )% eigen ( ie )% zloc )) then cptr = transfer ( cur_pos , cptr ) call c_f_pointer ( cptr , response_matrix ( iky )% eigen ( ie )% zloc , ( / nresponse , nresponse / )) cur_pos = cur_pos + nresponse ** 2 * 2 * nbytes_real end if if (. not . associated ( response_matrix ( iky )% eigen ( ie )% idx )) then cptr = transfer ( cur_pos , cptr ) call c_f_pointer ( cptr , response_matrix ( iky )% eigen ( ie )% idx , ( / nresponse / )) cur_pos = cur_pos + nresponse * 4 end if #else ! for each ky and set of connected kx values, ! must have a response matrix that is N x N ! with N = number of zeds per 2pi segment x number of 2pi segments if (. not . associated ( response_matrix ( iky )% eigen ( ie )% zloc )) & allocate ( response_matrix ( iky )% eigen ( ie )% zloc ( nresponse , nresponse )) ! response_matrix%idx is needed to keep track of permutations ! to the response matrix made during LU decomposition ! it will be input to LU back substitution during linear solve if (. not . associated ( response_matrix ( iky )% eigen ( ie )% idx )) & allocate ( response_matrix ( iky )% eigen ( ie )% idx ( nresponse )) #endif end subroutine setup_response_matrix_zloc_idx subroutine apply_field_solve_to_finish_response_matrix ( iky ) #ifdef ISO_C_BINDING use mp , only : sgproc0 #endif use physics_flags , only : include_apar , include_bpar use extended_zgrid , only : neigen use extended_zgrid , only : nsegments , nzed_segment use extended_zgrid , only : periodic use fields_arrays , only : response_matrix implicit none integer , intent ( in ) :: iky integer :: ie , idx , offset_apar , offset_bpar integer :: nz_ext , nresponse character ( 5 ) :: dist complex , dimension (:), allocatable :: phi_ext , apar_ext , bpar_ext ! solve quasineutrality ! for local stella, this is a diagonal process, but global stella ! may require something more sophisticated dist = 'g' ! loop over the sets of connected kx values do ie = 1 , neigen ( iky ) #ifdef ISO_C_BINDING if ( sgproc0 ) then #endif ! number of zeds x number of segments nz_ext = nsegments ( ie , iky ) * nzed_segment + 1 ! treat zonal mode specially to avoid double counting ! as it is periodic if ( periodic ( iky )) then nresponse = nz_ext - 1 else nresponse = nz_ext end if allocate ( phi_ext ( nz_ext )) allocate ( apar_ext ( nz_ext )) allocate ( bpar_ext ( nz_ext )) !> set up offset_apar and offset_bpar consistently !> so that the array slices below are consistent with !> the size of the response matrix if ( include_apar ) then offset_apar = nresponse else offset_apar = 0 end if if ( include_bpar ) then offset_bpar = offset_apar + nresponse else offset_bpar = 0 end if ! obtain the response matrix entries due to unit impulses in phi; ! this accounts for terms appearing both in quasineutrality and parallel ampere do idx = 1 , nresponse phi_ext ( nz_ext ) = 0.0 phi_ext (: nresponse ) = response_matrix ( iky )% eigen ( ie )% zloc (: nresponse , idx ) if ( include_apar ) then apar_ext ( nz_ext ) = 0.0 apar_ext (: nresponse ) = response_matrix ( iky )% eigen ( ie )% zloc ( offset_apar + 1 : nresponse + offset_apar , idx ) end if if ( include_bpar ) then bpar_ext ( nz_ext ) = 0.0 bpar_ext (: nresponse ) = response_matrix ( iky )% eigen ( ie )% zloc ( offset_bpar + 1 : nresponse + offset_bpar , idx ) end if call get_fields_for_response_matrix ( phi_ext , apar_ext , bpar_ext , iky , ie , dist ) ! next need to create column in response matrix from phi_ext and apar_ext ! negative sign because matrix to be inverted in streaming equation ! is identity matrix - response matrix ! add in contribution from identity matrix phi_ext ( idx ) = phi_ext ( idx ) - 1.0 response_matrix ( iky )% eigen ( ie )% zloc (: nresponse , idx ) = - phi_ext (: nresponse ) if ( include_apar ) response_matrix ( iky )% eigen ( ie )% zloc ( offset_apar + 1 : nresponse + offset_apar , idx ) = - apar_ext (: nresponse ) if ( include_bpar ) response_matrix ( iky )% eigen ( ie )% zloc ( offset_bpar + 1 : nresponse + offset_bpar , idx ) = - bpar_ext (: nresponse ) end do if ( include_apar ) then ! obtain the response matrix entries due to unit impulses in apar; ! this accounts for terms appearing both in quasineutrality and parallel ampere do idx = 1 , nresponse phi_ext ( nz_ext ) = 0.0 phi_ext (: nresponse ) = response_matrix ( iky )% eigen ( ie )% zloc (: nresponse , idx + offset_apar ) apar_ext ( nz_ext ) = 0.0 apar_ext (: nresponse ) = response_matrix ( iky )% eigen ( ie )% zloc ( offset_apar + 1 : nresponse + offset_apar , idx + offset_apar ) if ( include_bpar ) then bpar_ext ( nz_ext ) = 0.0 bpar_ext (: nresponse ) = response_matrix ( iky )% eigen ( ie )% zloc ( offset_bpar + 1 : nresponse + offset_bpar , idx + offset_apar ) end if call get_fields_for_response_matrix ( phi_ext , apar_ext , bpar_ext , iky , ie , dist ) ! next need to create column in response matrix from phi_ext and apar_ext ! negative sign because matrix to be inverted in streaming equation ! is identity matrix - response matrix ! add in contribution from identity matrix for diagonal entries apar_ext ( idx ) = apar_ext ( idx ) - 1.0 response_matrix ( iky )% eigen ( ie )% zloc (: nresponse , offset_apar + idx ) = - phi_ext (: nresponse ) response_matrix ( iky )% eigen ( ie )% zloc ( offset_apar + 1 : nresponse + offset_apar , offset_apar + idx ) = - apar_ext (: nresponse ) if ( include_bpar ) response_matrix ( iky )% eigen ( ie )% zloc ( offset_bpar + 1 : nresponse + offset_bpar , offset_apar + idx ) = - bpar_ext (: nresponse ) end do end if if ( include_bpar ) then ! obtain the response matrix entries due to unit impulses in bpar; ! this accounts for terms appearing both in quasineutrality and parallel ampere do idx = 1 , nresponse phi_ext ( nz_ext ) = 0.0 phi_ext (: nresponse ) = response_matrix ( iky )% eigen ( ie )% zloc (: nresponse , idx + offset_bpar ) if ( include_apar ) then apar_ext ( nz_ext ) = 0.0 apar_ext (: nresponse ) = response_matrix ( iky )% eigen ( ie )% zloc ( offset_apar + 1 : nresponse + offset_apar , idx + offset_bpar ) end if bpar_ext ( nz_ext ) = 0.0 bpar_ext (: nresponse ) = response_matrix ( iky )% eigen ( ie )% zloc ( offset_bpar + 1 : nresponse + offset_bpar , idx + offset_bpar ) call get_fields_for_response_matrix ( phi_ext , apar_ext , bpar_ext , iky , ie , dist ) ! next need to create column in response matrix from phi_ext and apar_ext ! negative sign because matrix to be inverted in streaming equation ! is identity matrix - response matrix ! add in contribution from identity matrix for diagonal entries bpar_ext ( idx ) = bpar_ext ( idx ) - 1.0 response_matrix ( iky )% eigen ( ie )% zloc (: nresponse , offset_bpar + idx ) = - phi_ext (: nresponse ) if ( include_apar ) response_matrix ( iky )% eigen ( ie )% zloc ( offset_apar + 1 : nresponse + offset_apar , offset_bpar + idx ) = - apar_ext (: nresponse ) response_matrix ( iky )% eigen ( ie )% zloc ( offset_bpar + 1 : nresponse + offset_bpar , offset_bpar + idx ) = - bpar_ext (: nresponse ) end do end if deallocate ( phi_ext , apar_ext , bpar_ext ) #ifdef ISO_C_BINDING end if #endif end do end subroutine apply_field_solve_to_finish_response_matrix subroutine lu_decompose_response_matrix ( iky ) #ifdef ISO_C_BINDING use mp , only : sgproc0 #endif use mp , only : mp_abort use fields_arrays , only : response_matrix use run_parameters , only : lu_option_switch use run_parameters , only : lu_option_none , lu_option_local , lu_option_global use extended_zgrid , only : neigen use linear_solve , only : lu_decomposition implicit none integer , intent ( in ) :: iky integer :: ie real :: dum ! now we have the full response matrix. Finally, perform its LU decomposition select case ( lu_option_switch ) case ( lu_option_global ) call parallel_LU_decomposition_global ( iky ) case ( lu_option_local ) #ifdef ISO_C_BINDING call parallel_LU_decomposition_local ( iky ) #else call mp_abort ( 'stella must be built with HAS_ISO_BINDING in order to use local parallel LU decomposition.' ) #endif case default do ie = 1 , neigen ( iky ) #ifdef ISO_C_BINDING if ( sgproc0 ) then #endif ! now that we have the reponse matrix for this ky and set of connected kx values !get the LU decomposition so we are ready to solve the linear system call lu_decomposition ( response_matrix ( iky )% eigen ( ie )% zloc , & response_matrix ( iky )% eigen ( ie )% idx , dum ) #ifdef ISO_C_BINDING end if #endif end do end select end subroutine lu_decompose_response_matrix subroutine read_response_matrix use fields_arrays , only : response_matrix use common_types , only : response_matrix_type use kt_grids , only : naky use extended_zgrid , only : neigen use extended_zgrid , only : nsegments use extended_zgrid , only : nzed_segment use extended_zgrid , only : periodic use mp , only : proc0 , job , broadcast , mp_abort use fields , only : nfields implicit none integer :: iky , ie , nz_ext integer :: iky_dump , neigen_dump , naky_dump , nresponse_dump integer :: nresponse , nresponse_per_field character ( len = 15 ) :: job_str character ( len = 100 ) :: file_name integer :: ie_dump , istat logical , parameter :: debug = . false . !   All matrices handled for the job i_job are read !   from a single file named: responst_mat.ijob by that !   jobs root process if ( proc0 ) then write ( job_str , '(I1.1)' ) job file_name = './mat/response_mat.' // trim ( job_str ) open ( unit = mat_unit , status = 'old' , file = file_name , & action = 'read' , form = 'unformatted' , iostat = istat ) if ( istat /= 0 ) then print * , 'Error opening response_matrix by root processor for job ' , job_str end if read ( unit = mat_unit ) naky_dump if ( naky /= naky_dump ) call mp_abort ( 'mismatch in naky and naky_dump' ) end if if (. not . allocated ( response_matrix )) allocate ( response_matrix ( naky )) do iky = 1 , naky if ( proc0 ) then read ( unit = mat_unit ) iky_dump , neigen_dump if ( iky_dump /= iky . or . neigen_dump /= neigen ( iky )) & call mp_abort ( 'mismatch in iky_dump/neigen_dump' ) end if if (. not . associated ( response_matrix ( iky )% eigen )) & allocate ( response_matrix ( iky )% eigen ( neigen ( iky ))) ! loop over the sets of connected kx values do ie = 1 , neigen ( iky ) ! number of zeds x number of segments nz_ext = nsegments ( ie , iky ) * nzed_segment + 1 ! treat zonal mode specially to avoid double counting ! as it is periodic if ( periodic ( iky )) then nresponse_per_field = nz_ext - 1 else nresponse_per_field = nz_ext end if nresponse = nresponse_per_field * nfields if ( proc0 ) then read ( unit = mat_unit ) ie_dump , nresponse_dump if ( ie_dump /= ie . or . nresponse /= nresponse_dump ) & call mp_abort ( 'mismatch in ie/nresponse_dump' ) end if ! for each ky and set of connected kx values, ! must have a response matrix that is N x N ! with N = number of zeds per 2pi segment x number of 2pi segments if (. not . associated ( response_matrix ( iky )% eigen ( ie )% zloc )) & allocate ( response_matrix ( iky )% eigen ( ie )% zloc ( nresponse , nresponse )) ! response_matrix%idx is needed to keep track of permutations ! to the response matrix made during LU decomposition ! it will be input to LU back substitution during linear solve if (. not . associated ( response_matrix ( iky )% eigen ( ie )% idx )) & allocate ( response_matrix ( iky )% eigen ( ie )% idx ( nresponse )) if ( proc0 ) then read ( unit = mat_unit ) response_matrix ( iky )% eigen ( ie )% idx read ( unit = mat_unit ) response_matrix ( iky )% eigen ( ie )% zloc end if call broadcast ( response_matrix ( iky )% eigen ( ie )% idx ) call broadcast ( response_matrix ( iky )% eigen ( ie )% zloc ) end do end do if ( proc0 ) close ( mat_unit ) if ( debug ) then print * , 'File' , file_name , ' successfully read by root proc for job: ' , job_str end if end subroutine read_response_matrix subroutine get_dpdf_dphi_matrix_column ( iky , ie , idx , nz_ext , nresponse , phi_ext , apar_ext , bpar_ext , pdf_ext ) use stella_layouts , only : vmu_lo use run_parameters , only : time_upwind_plus use physics_flags , only : include_apar , include_bpar use implicit_solve , only : get_gke_rhs , sweep_g_zext use fields_arrays , only : response_matrix use extended_zgrid , only : periodic #ifdef ISO_C_BINDING use mp , only : sgproc0 #endif implicit none integer , intent ( in ) :: iky , ie , idx , nz_ext , nresponse complex , dimension (:), intent ( out ) :: phi_ext , apar_ext , bpar_ext complex , dimension (:, vmu_lo % llim_proc :), intent ( out ) :: pdf_ext complex , dimension (:), allocatable :: dum integer :: ivmu , it integer :: offset_apar , offset_bpar ! provide a unit impulse to phi&#94;{n+1} (or Delta phi&#94;{n+1}) at the location ! in the extended zed domain corresponding to index 'idx' ! note that it is sufficient to give a unit real impulse (as opposed to ! separately giving real and imaginary impulse) for the following reason: ! split homogeneous GKE, L[f] = R[phi], into L[f1] = R[phir] and L[f2] = i*R[phii], ! with f = f1 + f2; then phi = df1/dphir * phir + df2/dphii * phii. ! however, we see that if phir = phii = 1, L[f1] = R[1] = L[-i*f2], ! and thus f2 = i * f1.  This gives phi = df1/dphir * (phir + i * phii) = df1/dphir * phi phi_ext = 0.0 ! how phi&#94;{n+1} enters the GKE depends on whether we are solving for the ! non-Boltzmann pdf, h, or the guiding centre pdf, 'g' phi_ext ( idx ) = time_upwind_plus if ( periodic ( iky ) . and . idx == 1 ) phi_ext ( nz_ext ) = phi_ext ( 1 ) ! dum is a scratch array that takes the place of the pdf and phi ! at the previous time level, ! which is set to zero for the response matrix approach allocate ( dum ( nz_ext )); dum = 0.0 ! set the flux tube index to one ! need to check, but think this is okay as the homogeneous equation solved here for the ! response matrix construction is the same for all flux tubes in the flux tube train it = 1 do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc ! calculate the RHS of the GK equation (using dum=0 as the pdf at the previous time level, ! and phi_ext as the potential) and store it in pdf_ext call get_gke_rhs ( ivmu , iky , ie , dum , phi_ext , dum , dum , dum , dum , pdf_ext (:, ivmu )) ! given the RHS of the GK equation (pdf_ext), solve for the pdf at the ! new time level by sweeping in zed on the extended domain; ! the rhs is input as 'pdf_ext' and over-written with the updated solution for the pdf call sweep_g_zext ( iky , ie , it , ivmu , pdf_ext (:, ivmu )) end do deallocate ( dum ) ! we now have the pdf on the extended zed domain at this ky and set of connected kx values ! corresponding to a unit impulse in phi at this location ! now integrate over velocities to get a square response matrix ! (this ends the parallelization over velocity space, so every core should have a ! copy of phi_ext) call integrate_over_velocity ( pdf_ext , phi_ext , apar_ext , bpar_ext , iky , ie ) #ifdef ISO_C_BINDING if ( sgproc0 ) then #endif response_matrix ( iky )% eigen ( ie )% zloc (: nresponse , idx ) = phi_ext (: nresponse ) offset_apar = 0 if ( include_apar ) then offset_apar = nresponse response_matrix ( iky )% eigen ( ie )% zloc ( offset_apar + 1 : nresponse + offset_apar , idx ) = apar_ext (: nresponse ) end if if ( include_bpar ) then offset_bpar = offset_apar + nresponse response_matrix ( iky )% eigen ( ie )% zloc ( offset_bpar + 1 : nresponse + offset_bpar , idx ) = bpar_ext (: nresponse ) end if #ifdef ISO_C_BINDING end if #endif end subroutine get_dpdf_dphi_matrix_column subroutine get_dpdf_dapar_matrix_column ( iky , ie , idx , nz_ext , nresponse , phi_ext , apar_ext , bpar_ext , pdf_ext ) use stella_layouts , only : vmu_lo use run_parameters , only : time_upwind_plus use physics_flags , only : include_apar , include_bpar use implicit_solve , only : get_gke_rhs , sweep_g_zext use fields_arrays , only : response_matrix use extended_zgrid , only : periodic #ifdef ISO_C_BINDING use mp , only : sgproc0 #endif implicit none integer , intent ( in ) :: iky , ie , idx , nz_ext , nresponse complex , dimension (:), intent ( out ) :: phi_ext , apar_ext , bpar_ext complex , dimension (:, vmu_lo % llim_proc :), intent ( out ) :: pdf_ext complex , dimension (:), allocatable :: dum integer :: ivmu , it integer :: offset_apar , offset_bpar ! provide a unit impulse to apar&#94;{n+1} (or Delta apar&#94;{n+1}) at the location ! in the extended zed domain corresponding to index 'idx' ! note that it is sufficient to give a unit real impulse (as opposed to ! separately giving real and imaginary impulse) for the following reason: ! split homogeneous GKE, L[f] = R[apar], into L[f1] = R[aparr] and L[f2] = i*R[apari], ! with f = f1 + f2; then apar = df1/daparr * aparr + df2/dapari * apari. ! however, we see that if aparr = apari = 1, L[f1] = R[1] = L[-i*f2], ! and thus f2 = i * f1.  This gives apar = df1/daparr * (aparr + i * apari) = df1/daparr * apar apar_ext = 0.0 apar_ext ( idx ) = 1.0 if ( periodic ( iky ) . and . idx == 1 ) apar_ext ( nz_ext ) = apar_ext ( 1 ) ! dum is a scratch array that takes the place of the pdf and phi ! at the previous time level, ! which is set to zero for the response matrix approach allocate ( dum ( nz_ext )); dum = 0.0 ! set the flux tube index to one ! need to check, but think this is okay as the homogeneous equation solved here for the ! response matrix construction is the same for all flux tubes in the flux tube train it = 1 do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc ! calculate the RHS of the GK equation (using dum=0 as the pdf at the previous time level, ! and phi_ext as the potential) and store it in pdf_ext call get_gke_rhs ( ivmu , iky , ie , dum , dum , apar_ext * time_upwind_plus , apar_ext , dum , dum , pdf_ext (:, ivmu )) ! given the RHS of the GK equation (pdf_ext), solve for the pdf at the ! new time level by sweeping in zed on the extended domain; ! the rhs is input as 'pdf_ext' and over-written with the updated solution for the pdf call sweep_g_zext ( iky , ie , it , ivmu , pdf_ext (:, ivmu )) end do deallocate ( dum ) ! we now have the pdf on the extended zed domain at this ky and set of connected kx values ! corresponding to a unit impulse in phi at this location ! now integrate over velocities to get a square response matrix ! (this ends the parallelization over velocity space, so every core should have a ! copy of phi_ext) call integrate_over_velocity ( pdf_ext , phi_ext , apar_ext , bpar_ext , iky , ie ) #ifdef ISO_C_BINDING if ( sgproc0 ) then #endif if ( include_apar ) then offset_apar = nresponse else offset_apar = 0 end if response_matrix ( iky )% eigen ( ie )% zloc (: nresponse , idx + nresponse ) = phi_ext (: nresponse ) if ( include_apar ) then response_matrix ( iky )% eigen ( ie )% zloc ( offset_apar + 1 : nresponse + offset_apar , idx + offset_apar ) = apar_ext (: nresponse ) end if if ( include_bpar ) then offset_bpar = offset_apar + nresponse response_matrix ( iky )% eigen ( ie )% zloc ( offset_bpar + 1 : nresponse + offset_bpar , idx + offset_apar ) = bpar_ext (: nresponse ) end if #ifdef ISO_C_BINDING end if #endif end subroutine get_dpdf_dapar_matrix_column ! modelled on get_dpdf_dphi_matrix_column above subroutine get_dpdf_dbpar_matrix_column ( iky , ie , idx , nz_ext , nresponse , phi_ext , apar_ext , bpar_ext , pdf_ext ) use stella_layouts , only : vmu_lo use run_parameters , only : time_upwind_plus use physics_flags , only : include_apar , include_bpar use implicit_solve , only : get_gke_rhs , sweep_g_zext use fields_arrays , only : response_matrix use extended_zgrid , only : periodic #ifdef ISO_C_BINDING use mp , only : sgproc0 #endif implicit none integer , intent ( in ) :: iky , ie , idx , nz_ext , nresponse complex , dimension (:), intent ( out ) :: phi_ext , apar_ext , bpar_ext complex , dimension (:, vmu_lo % llim_proc :), intent ( out ) :: pdf_ext complex , dimension (:), allocatable :: dum integer :: ivmu , it integer :: offset_apar , offset_bpar ! provide a unit impulse to phi&#94;{n+1} (or Delta phi&#94;{n+1}) at the location ! in the extended zed domain corresponding to index 'idx' ! note that it is sufficient to give a unit real impulse (as opposed to ! separately giving real and imaginary impulse) for the following reason: ! split homogeneous GKE, L[f] = R[phi], into L[f1] = R[phir] and L[f2] = i*R[phii], ! with f = f1 + f2; then phi = df1/dphir * phir + df2/dphii * phii. ! however, we see that if phir = phii = 1, L[f1] = R[1] = L[-i*f2], ! and thus f2 = i * f1.  This gives phi = df1/dphir * (phir + i * phii) = df1/dphir * phi bpar_ext = 0.0 ! how phi&#94;{n+1} enters the GKE depends on whether we are solving for the ! non-Boltzmann pdf, h, or the guiding centre pdf, 'g' bpar_ext ( idx ) = time_upwind_plus if ( periodic ( iky ) . and . idx == 1 ) bpar_ext ( nz_ext ) = bpar_ext ( 1 ) ! dum is a scratch array that takes the place of the pdf and phi ! at the previous time level, ! which is set to zero for the response matrix approach allocate ( dum ( nz_ext )); dum = 0.0 ! set the flux tube index to one ! need to check, but think this is okay as the homogeneous equation solved here for the ! response matrix construction is the same for all flux tubes in the flux tube train it = 1 do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc ! calculate the RHS of the GK equation (using dum=0 as the pdf at the previous time level, ! and phi_ext as the potential) and store it in pdf_ext call get_gke_rhs ( ivmu , iky , ie , dum , dum , dum , dum , dum , bpar_ext , pdf_ext (:, ivmu )) ! given the RHS of the GK equation (pdf_ext), solve for the pdf at the ! new time level by sweeping in zed on the extended domain; ! the rhs is input as 'pdf_ext' and over-written with the updated solution for the pdf call sweep_g_zext ( iky , ie , it , ivmu , pdf_ext (:, ivmu )) end do deallocate ( dum ) ! we now have the pdf on the extended zed domain at this ky and set of connected kx values ! corresponding to a unit impulse in phi at this location ! now integrate over velocities to get a square response matrix ! (this ends the parallelization over velocity space, so every core should have a ! copy of phi_ext) call integrate_over_velocity ( pdf_ext , phi_ext , apar_ext , bpar_ext , iky , ie ) #ifdef ISO_C_BINDING if ( sgproc0 ) then #endif offset_apar = 0 if ( include_apar ) offset_apar = nresponse if ( include_bpar ) offset_bpar = offset_apar + nresponse response_matrix ( iky )% eigen ( ie )% zloc (: nresponse , idx + offset_bpar ) = phi_ext (: nresponse ) if ( include_apar ) then response_matrix ( iky )% eigen ( ie )% zloc ( offset_apar + 1 : nresponse + offset_apar , idx + offset_bpar ) = apar_ext (: nresponse ) end if if ( include_bpar ) then response_matrix ( iky )% eigen ( ie )% zloc ( offset_bpar + 1 : nresponse + offset_bpar , idx + offset_bpar ) = bpar_ext (: nresponse ) end if #ifdef ISO_C_BINDING end if #endif end subroutine get_dpdf_dbpar_matrix_column subroutine integrate_over_velocity ( g , phi , apar , bpar , iky , ie ) use stella_layouts , only : vmu_lo use physics_flags , only : include_apar , include_bpar implicit none complex , dimension (:, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:), intent ( out ) :: phi , apar , bpar integer , intent ( in ) :: iky , ie call integrate_over_velocity_phi ( g , phi , iky , ie ) if ( include_apar ) call integrate_over_velocity_apar ( g , apar , iky , ie ) if ( include_bpar ) call integrate_over_velocity_bpar ( g , bpar , iky , ie ) end subroutine integrate_over_velocity subroutine integrate_over_velocity_phi ( g , phi , iky , ie ) use stella_layouts , only : vmu_lo use species , only : nspec , spec use extended_zgrid , only : iz_low , iz_up use extended_zgrid , only : ikxmod use extended_zgrid , only : nsegments use vpamu_grids , only : integrate_species use gyro_averages , only : gyro_average use mp , only : sum_allreduce implicit none complex , dimension (:, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:), intent ( out ) :: phi integer , intent ( in ) :: iky , ie integer :: idx , iseg , ikx , iz , ia integer :: izl_offset real , dimension ( nspec ) :: wgt complex , dimension (:), allocatable :: g0 ia = 1 allocate ( g0 ( vmu_lo % llim_proc : vmu_lo % ulim_alloc )) wgt = spec % z * spec % dens_psi0 phi = 0. idx = 0 ; izl_offset = 0 iseg = 1 ikx = ikxmod ( iseg , ie , iky ) do iz = iz_low ( iseg ), iz_up ( iseg ) idx = idx + 1 call gyro_average ( g ( idx , :), iky , ikx , iz , g0 ) call integrate_species ( g0 , iz , wgt , phi ( idx ), reduce_in = . false .) end do izl_offset = 1 if ( nsegments ( ie , iky ) > 1 ) then do iseg = 2 , nsegments ( ie , iky ) ikx = ikxmod ( iseg , ie , iky ) do iz = iz_low ( iseg ) + izl_offset , iz_up ( iseg ) idx = idx + 1 call gyro_average ( g ( idx , :), iky , ikx , iz , g0 ) call integrate_species ( g0 , iz , wgt , phi ( idx ), reduce_in = . false .) end do if ( izl_offset == 0 ) izl_offset = 1 end do end if call sum_allreduce ( phi ) end subroutine integrate_over_velocity_phi subroutine integrate_over_velocity_bpar ( g , bpar , iky , ie ) use stella_layouts , only : vmu_lo , imu_idx use species , only : nspec , spec use physics_parameters , only : beta use extended_zgrid , only : iz_low , iz_up use extended_zgrid , only : ikxmod use extended_zgrid , only : nsegments use vpamu_grids , only : integrate_species , mu use gyro_averages , only : gyro_average_j1 use mp , only : sum_allreduce implicit none complex , dimension (:, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:), intent ( out ) :: bpar integer , intent ( in ) :: iky , ie integer :: idx , iseg , ikx , iz , ia , imu , ivmu integer :: izl_offset real , dimension ( nspec ) :: wgt complex , dimension (:), allocatable :: g0 ia = 1 allocate ( g0 ( vmu_lo % llim_proc : vmu_lo % ulim_alloc )) wgt = - 2.0 * beta * spec % temp_psi0 * spec % dens_psi0 bpar = 0. idx = 0 ; izl_offset = 0 iseg = 1 ikx = ikxmod ( iseg , ie , iky ) do iz = iz_low ( iseg ), iz_up ( iseg ) idx = idx + 1 call gyro_average_j1 ( g ( idx , :), iky , ikx , iz , g0 ) do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc imu = imu_idx ( vmu_lo , ivmu ) g0 ( ivmu ) = g0 ( ivmu ) * mu ( imu ) end do call integrate_species ( g0 , iz , wgt , bpar ( idx ), reduce_in = . false .) end do izl_offset = 1 if ( nsegments ( ie , iky ) > 1 ) then do iseg = 2 , nsegments ( ie , iky ) ikx = ikxmod ( iseg , ie , iky ) do iz = iz_low ( iseg ) + izl_offset , iz_up ( iseg ) idx = idx + 1 call gyro_average_j1 ( g ( idx , :), iky , ikx , iz , g0 ) do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc imu = imu_idx ( vmu_lo , ivmu ) g0 ( ivmu ) = g0 ( ivmu ) * mu ( imu ) end do call integrate_species ( g0 , iz , wgt , bpar ( idx ), reduce_in = . false .) end do if ( izl_offset == 0 ) izl_offset = 1 end do end if call sum_allreduce ( bpar ) end subroutine integrate_over_velocity_bpar subroutine integrate_over_velocity_apar ( g , apar , iky , ie ) use stella_layouts , only : vmu_lo , iv_idx use physics_parameters , only : beta use species , only : nspec , spec use extended_zgrid , only : iz_low , iz_up use extended_zgrid , only : ikxmod use extended_zgrid , only : nsegments use vpamu_grids , only : integrate_species use vpamu_grids , only : vpa use gyro_averages , only : gyro_average use mp , only : sum_allreduce implicit none complex , dimension (:, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:), intent ( out ) :: apar integer , intent ( in ) :: iky , ie integer :: idx , iseg , ikx , iz , ia integer :: ivmu , iv integer :: izl_offset real , dimension ( nspec ) :: wgt complex , dimension (:), allocatable :: g0 ia = 1 allocate ( g0 ( vmu_lo % llim_proc : vmu_lo % ulim_alloc )) wgt = spec % z * spec % dens_psi0 * spec % stm_psi0 * beta apar = 0. idx = 0 ; izl_offset = 0 iseg = 1 ikx = ikxmod ( iseg , ie , iky ) do iz = iz_low ( iseg ), iz_up ( iseg ) idx = idx + 1 call gyro_average ( g ( idx , :), iky , ikx , iz , g0 ) do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) g0 ( ivmu ) = g0 ( ivmu ) * vpa ( iv ) end do call integrate_species ( g0 , iz , wgt , apar ( idx ), reduce_in = . false .) end do izl_offset = 1 if ( nsegments ( ie , iky ) > 1 ) then do iseg = 2 , nsegments ( ie , iky ) ikx = ikxmod ( iseg , ie , iky ) do iz = iz_low ( iseg ) + izl_offset , iz_up ( iseg ) idx = idx + 1 call gyro_average ( g ( idx , :), iky , ikx , iz , g0 ) do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) g0 ( ivmu ) = g0 ( ivmu ) * vpa ( iv ) end do call integrate_species ( g0 , iz , wgt , apar ( idx ), reduce_in = . false .) end do if ( izl_offset == 0 ) izl_offset = 1 end do end if call sum_allreduce ( apar ) end subroutine integrate_over_velocity_apar subroutine get_fields_for_response_matrix ( phi , apar , bpar , iky , ie , dist ) use physics_flags , only : include_apar , include_bpar implicit none complex , dimension (:), intent ( in out ) :: phi , apar , bpar integer , intent ( in ) :: iky , ie character ( * ), intent ( in ) :: dist if ( include_bpar ) then call get_phi_and_bpar_for_response_matrix ( phi , bpar , iky , ie , dist ) else call get_phi_for_response_matrix ( phi , iky , ie , dist ) end if if ( include_apar ) call get_apar_for_response_matrix ( apar , iky , ie , dist ) end subroutine get_fields_for_response_matrix subroutine get_phi_for_response_matrix ( phi , iky , ie , dist ) use zgrid , only : nzgrid use species , only : spec use species , only : has_electron_species use stella_geometry , only : dl_over_b use extended_zgrid , only : iz_low , iz_up use extended_zgrid , only : ikxmod use extended_zgrid , only : nsegments use kt_grids , only : zonal_mode , akx use fields_arrays , only : gamtot , gamtot3 use fields , only : gamtot_h , gamtot3_h use physics_flags , only : adiabatic_option_switch use physics_flags , only : adiabatic_option_fieldlineavg implicit none complex , dimension (:), intent ( inout ) :: phi integer , intent ( in ) :: iky , ie character ( * ), intent ( in ) :: dist integer :: idx , iseg , ikx , iz , ia integer :: izl_offset complex :: tmp real , dimension (:), allocatable :: gamma_fac ia = 1 allocate ( gamma_fac ( - nzgrid : nzgrid )) idx = 0 ; izl_offset = 0 iseg = 1 ikx = ikxmod ( iseg , ie , iky ) if ( dist == 'h' ) then gamma_fac = gamtot_h else gamma_fac = gamtot ( iky , ikx , :) end if if ( zonal_mode ( iky ) . and . abs ( akx ( ikx )) < epsilon ( 0. )) then phi (:) = 0.0 return end if do iz = iz_low ( iseg ), iz_up ( iseg ) idx = idx + 1 phi ( idx ) = phi ( idx ) / gamma_fac ( iz ) end do izl_offset = 1 if ( nsegments ( ie , iky ) > 1 ) then do iseg = 2 , nsegments ( ie , iky ) ikx = ikxmod ( iseg , ie , iky ) if ( dist == 'h' ) then gamma_fac = gamtot_h else gamma_fac = gamtot ( iky , ikx , :) end if do iz = iz_low ( iseg ) + izl_offset , iz_up ( iseg ) idx = idx + 1 phi ( idx ) = phi ( idx ) / gamma_fac ( iz ) end do if ( izl_offset == 0 ) izl_offset = 1 end do end if if (. not . has_electron_species ( spec ) . and . & adiabatic_option_switch == adiabatic_option_fieldlineavg ) then if ( zonal_mode ( iky )) then ! no connections for ky = 0 iseg = 1 tmp = sum ( dl_over_b ( ia , :) * phi ) if ( dist == 'h' ) then phi = phi + tmp * gamtot3_h else phi = phi + tmp * gamtot3 ( ikxmod ( 1 , ie , iky ), :) end if end if end if deallocate ( gamma_fac ) end subroutine get_phi_for_response_matrix subroutine get_phi_and_bpar_for_response_matrix ( phi , bpar , iky , ie , dist ) use zgrid , only : nzgrid use species , only : spec use species , only : has_electron_species use extended_zgrid , only : iz_low , iz_up use extended_zgrid , only : ikxmod use extended_zgrid , only : nsegments use kt_grids , only : zonal_mode , akx use fields_arrays , only : gamtotinv11 , gamtotinv13 , gamtotinv31 , gamtotinv33 use fields , only : gamtot_h use physics_flags , only : adiabatic_option_switch use physics_flags , only : adiabatic_option_fieldlineavg use mp , only : mp_abort implicit none complex , dimension (:), intent ( inout ) :: phi , bpar integer , intent ( in ) :: iky , ie character ( * ), intent ( in ) :: dist integer :: idx , iseg , ikx , iz , ia integer :: izl_offset complex :: antot1 , antot3 real , dimension (:), allocatable :: gammainv11 , gammainv13 , gammainv31 , gammainv33 ia = 1 allocate ( gammainv11 ( - nzgrid : nzgrid )) allocate ( gammainv13 ( - nzgrid : nzgrid )) allocate ( gammainv31 ( - nzgrid : nzgrid )) allocate ( gammainv33 ( - nzgrid : nzgrid )) idx = 0 ; izl_offset = 0 iseg = 1 ikx = ikxmod ( iseg , ie , iky ) if ( dist == 'h' ) then gammainv11 = 1.0 / gamtot_h gammainv13 = 0.0 gammainv31 = 0.0 gammainv33 = 1.0 else gammainv11 = gamtotinv11 ( iky , ikx , :) gammainv13 = gamtotinv13 ( iky , ikx , :) gammainv31 = gamtotinv31 ( iky , ikx , :) gammainv33 = gamtotinv33 ( iky , ikx , :) end if if ( zonal_mode ( iky ) . and . abs ( akx ( ikx )) < epsilon ( 0. )) then phi (:) = 0.0 bpar (:) = 0.0 return end if do iz = iz_low ( iseg ), iz_up ( iseg ) idx = idx + 1 antot1 = phi ( idx ) antot3 = bpar ( idx ) phi ( idx ) = antot1 * gammainv11 ( iz ) + antot3 * gammainv13 ( iz ) bpar ( idx ) = antot1 * gammainv31 ( iz ) + antot3 * gammainv33 ( iz ) end do izl_offset = 1 if ( nsegments ( ie , iky ) > 1 ) then do iseg = 2 , nsegments ( ie , iky ) ikx = ikxmod ( iseg , ie , iky ) if ( dist == 'h' ) then gammainv11 = 1.0 / gamtot_h gammainv13 = 0.0 gammainv31 = 0.0 gammainv33 = 1.0 else gammainv11 = gamtotinv11 ( iky , ikx , :) gammainv13 = gamtotinv13 ( iky , ikx , :) gammainv31 = gamtotinv31 ( iky , ikx , :) gammainv33 = gamtotinv33 ( iky , ikx , :) end if do iz = iz_low ( iseg ) + izl_offset , iz_up ( iseg ) idx = idx + 1 antot1 = phi ( idx ) antot3 = bpar ( idx ) phi ( idx ) = antot1 * gammainv11 ( iz ) + antot3 * gammainv13 ( iz ) bpar ( idx ) = antot1 * gammainv31 ( iz ) + antot3 * gammainv33 ( iz ) end do if ( izl_offset == 0 ) izl_offset = 1 end do end if if (. not . has_electron_species ( spec ) . and . & adiabatic_option_switch == adiabatic_option_fieldlineavg ) then call mp_abort ( 'adiabatic electrons not yet supported for include_bpar = T. aborting.' ) end if deallocate ( gammainv11 , gammainv13 , gammainv31 , gammainv33 ) end subroutine get_phi_and_bpar_for_response_matrix subroutine get_apar_for_response_matrix ( apar , iky , ie , dist ) use zgrid , only : nzgrid use extended_zgrid , only : iz_low , iz_up use extended_zgrid , only : ikxmod use extended_zgrid , only : nsegments use kt_grids , only : zonal_mode , akx use fields , only : apar_denom use dist_fn_arrays , only : kperp2 implicit none complex , dimension (:), intent ( in out ) :: apar integer , intent ( in ) :: iky , ie character ( * ), intent ( in ) :: dist integer :: idx , iseg , ikx , iz , ia integer :: izl_offset real , dimension (:), allocatable :: denominator ia = 1 allocate ( denominator ( - nzgrid : nzgrid )) idx = 0 ; izl_offset = 0 iseg = 1 ikx = ikxmod ( iseg , ie , iky ) if ( dist == 'g' ) then denominator = kperp2 ( iky , ikx , ia , :) else if ( dist == 'gbar' ) then denominator = apar_denom ( iky , ikx , :) end if if ( zonal_mode ( iky ) . and . abs ( akx ( ikx )) < epsilon ( 0. )) then apar (:) = 0.0 return end if do iz = iz_low ( iseg ), iz_up ( iseg ) idx = idx + 1 apar ( idx ) = apar ( idx ) / denominator ( iz ) end do izl_offset = 1 if ( nsegments ( ie , iky ) > 1 ) then do iseg = 2 , nsegments ( ie , iky ) ikx = ikxmod ( iseg , ie , iky ) if ( dist == 'g' ) then denominator = kperp2 ( iky , ikx , ia , :) elseif ( dist == 'gbar' ) then denominator = apar_denom ( iky , ikx , :) end if do iz = iz_low ( iseg ) + izl_offset , iz_up ( iseg ) idx = idx + 1 apar ( idx ) = apar ( idx ) / denominator ( iz ) end do if ( izl_offset == 0 ) izl_offset = 1 end do end if deallocate ( denominator ) end subroutine get_apar_for_response_matrix subroutine finish_response_matrix use fields_arrays , only : response_matrix #if !defined ISO_C_BINDING implicit none #else use fields_arrays , only : response_window use mpi implicit none integer :: ierr if ( response_window /= MPI_WIN_NULL ) call mpi_win_free ( response_window , ierr ) #endif if ( allocated ( response_matrix )) deallocate ( response_matrix ) response_matrix_initialized = . false . end subroutine finish_response_matrix !----------------------------------------------------------! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! ! !!!!!!!!!!!!!!PARALLEL LU DECOMPOSITIONS!!!!!!!!!!!!!!!! ! ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! !----------------------------------------------------------! #ifdef ISO_C_BINDING !this subroutine parallelizes the LU decomposition on a single !node using MPIs shared memory interface !It also splits up jtwist the independent matrices across nodes !Ideal speed up: cores_per_node*min(jtwist,ncores) subroutine parallel_LU_decomposition_local ( iky ) use , intrinsic :: iso_c_binding , only : c_ptr , c_f_pointer use fields_arrays , only : response_matrix use mp , only : barrier , broadcast , sum_allreduce use mp , only : mp_comm , scope , allprocs , sharedprocs , curr_focus use mp , only : scrossdomprocs , sgproc0 , mp_abort , real_size use mp , only : job , iproc , proc0 , nproc , numnodes , inode use mp_lu_decomposition , only : lu_decomposition_local use job_manage , only : njobs use extended_zgrid , only : neigen use mpi implicit none integer , intent ( in ) :: iky integer , dimension (:, :), allocatable :: eig_limits integer , dimension (:), allocatable :: job_list logical , dimension (:, :), allocatable :: node_jobs complex , dimension (:, :), pointer :: lu type ( c_ptr ) :: bptr logical :: needs_send = . false . integer :: prior_focus , nodes_on_job integer :: ijob , j , ie , n , ediv , emod integer :: jroot , neig , ierr , win , nroot integer ( kind = MPI_ADDRESS_KIND ) :: win_size integer :: disp_unit = 1 real :: dmax prior_focus = curr_focus call scope ( sharedprocs ) allocate ( node_jobs ( 0 :( numnodes - 1 ), 0 :( njobs - 1 ))); node_jobs = . false . allocate ( job_list ( 0 :( nproc - 1 ))); job_list = 0 allocate ( eig_limits ( 0 : numnodes , 0 :( njobs - 1 ))); eig_limits = 0 job_list ( iproc ) = job call sum_allreduce ( job_list ) if ( proc0 ) then do j = 0 , nproc - 1 node_jobs ( inode , job_list ( j )) = . true . !create a map of which nodes have which jobs end do end if !make sure all processors have this map call scope ( allprocs ) call mpi_allreduce & ( MPI_IN_PLACE , node_jobs , size ( node_jobs ), MPI_LOGICAL , MPI_LOR , mp_comm , ierr ) call scope ( sharedprocs ) do ijob = 0 , njobs - 1 jroot = - 1 do j = 0 , nproc - 1 if ( job_list ( j ) == ijob ) then jroot = j !the first processor on this job will be the root process exit end if end do if ( jroot == - 1 ) cycle !no processors on this node are on this job if ( iproc == jroot ) neig = neigen ( iky ) ! broadcast number of matrices call broadcast ( neig , jroot ) ! split up neig across nodes that have the current job nodes_on_job = count ( node_jobs (:, ijob )) ediv = neig / nodes_on_job emod = mod ( neig , nodes_on_job ) eig_limits ( 0 , ijob ) = 1 do j = 1 , numnodes if ( node_jobs ( j - 1 , ijob )) then eig_limits ( j , ijob ) = eig_limits ( j - 1 , ijob ) + ediv if ( emod > 0 ) then eig_limits ( j , ijob ) = eig_limits ( j , ijob ) + 1 emod = emod - 1 end if else eig_limits ( j , ijob ) = eig_limits ( j - 1 , ijob ) end if end do do ie = eig_limits ( inode , ijob ), eig_limits ( inode + 1 , ijob ) - 1 win_size = 0 if ( iproc == jroot ) then needs_send = . true . n = size ( response_matrix ( iky )% eigen ( ie )% idx ) win_size = int ( n * n , MPI_ADDRESS_KIND ) * 2 * real_size !complex size end if !broadcast size of matrix call broadcast ( n , jroot ) !allocate the window call mpi_win_allocate_shared ( win_size , disp_unit , MPI_INFO_NULL , mp_comm , bptr , win , ierr ) if ( iproc /= jroot ) then !make sure all the procs have the right memory address call mpi_win_shared_query ( win , jroot , win_size , disp_unit , bptr , ierr ) end if ! bind this c_ptr to our fortran matrix call c_f_pointer ( bptr , lu , ( / n , n / )) !load the matrix if ( iproc == jroot ) lu = response_matrix ( iky )% eigen ( ie )% zloc !syncronize the processors call mpi_win_fence ( 0 , win , ierr ) ! All the processors have the matrix. ! Now perform LU decomposition call lu_decomposition_local ( mp_comm , jroot , win , lu , & response_matrix ( iky )% eigen ( ie )% idx , dmax ) !copy the decomposed matrix over if ( iproc == jroot ) response_matrix ( iky )% eigen ( ie )% zloc = lu call mpi_win_free ( win , ierr ) end do end do call scope ( scrossdomprocs ) !copy all the matrices across all nodes if ( sgproc0 ) then do ie = 1 , neigen ( iky ) nroot = 0 if ( needs_send . and . & ( ie >= eig_limits ( inode , job ) . and . ie < eig_limits ( inode + 1 , job ))) nroot = iproc !first let processors know who is sending the data call sum_allreduce ( nroot ) !now send the data call broadcast ( response_matrix ( iky )% eigen ( ie )% zloc , nroot ) call broadcast ( response_matrix ( iky )% eigen ( ie )% idx , nroot ) end do end if call scope ( prior_focus ) deallocate ( node_jobs , job_list , eig_limits ) end subroutine parallel_LU_decomposition_local #endif /* ISO_C_BINDING */ !this subroutine parallelizes the LU decomposition across !all cores. Ideal speed up: ncores subroutine parallel_LU_decomposition_global ( iky ) use fields_arrays , only : response_matrix use mp , only : barrier , broadcast , sum_allreduce use mp , only : mp_comm , scope , allprocs , sharedprocs , curr_focus use mp , only : job , iproc , proc0 , nproc , mpicmplx #ifdef ISO_C_BINDING use mp , only : sgproc0 , scrossdomprocs #endif use job_manage , only : njobs use extended_zgrid , only : neigen use mpi use linear_solve , only : imaxloc implicit none integer , intent ( in ) :: iky integer , dimension (:), allocatable :: job_roots , eig_roots integer , dimension (:), allocatable :: row_limits , eig_limits integer , dimension ( MPI_STATUS_SIZE ) :: status real , parameter :: zero = 1.0e-20 integer , dimension (:), allocatable :: idx complex , dimension (:, :), allocatable :: lu real , dimension (:), allocatable :: vv complex , dimension (:), allocatable :: dum integer :: sproc logical :: sproc0 integer :: eig_comm , ceig_comm !c for 'cross' integer :: ieig_core , ceig_core , eig_cores integer :: ncomm integer :: prior_focus integer :: ie , ie_hi , r_lo , r_hi integer :: ijob , i , j , k , n , n_send , rsize integer :: imax , neig , ierr integer :: istage , nstage integer :: rdiv , rmod integer :: ediv , emod real :: dmax , tmp prior_focus = curr_focus sproc = iproc sproc0 = proc0 call scope ( allprocs ) allocate ( job_roots ( 0 : njobs - 1 )); job_roots = 0 if ( sproc0 ) job_roots ( job ) = iproc call sum_allreduce ( job_roots ) do ijob = 0 , njobs - 1 if ( job == ijob . and . sproc0 ) then neig = neigen ( iky ) end if ! broadcast number of matrices for this job call broadcast ( neig , job_roots ( ijob )) !set up communicator for cores working on a single matrix call mpi_comm_split ( mp_comm , mod ( iproc , neig ), iproc , eig_comm , ierr ) call mpi_comm_size ( eig_comm , eig_cores , ierr ) call mpi_comm_rank ( eig_comm , ieig_core , ierr ) !set up a communicator that crosses the previous one call mpi_comm_split ( mp_comm , ieig_core , iproc , ceig_comm , ierr ) call mpi_comm_rank ( ceig_comm , ceig_core , ierr ) call mpi_bcast ( ceig_core , 1 , MPI_INT , 0 , eig_comm , ierr ) ncomm = min ( neig , nproc ) !number of communicators allocate ( eig_roots ( 0 : ncomm - 1 )); eig_roots = 0 allocate ( eig_limits ( 0 : ncomm )) allocate ( row_limits ( 0 : eig_cores )) if ( ieig_core == 0 ) eig_roots ( ceig_core ) = iproc call sum_allreduce ( eig_roots ) ! split up neigen across cores ediv = neig / ncomm emod = mod ( neig , ncomm ) !how many stages will the LU decomposition take? nstage = ediv if ( emod > 0 ) nstage = nstage + 1 !determine which parts of neigen this communicator processes eig_limits ( 0 ) = 1 do j = 1 , ncomm eig_limits ( j ) = eig_limits ( j - 1 ) + ediv if ( j <= emod ) then eig_limits ( j ) = eig_limits ( j ) + 1 end if end do do istage = 0 , nstage - 1 !transfer the data from job root to root of subcommunicator do j = 0 , ncomm - 1 ie = eig_limits ( j ) + istage ie_hi = eig_limits ( j + 1 ) - 1 if ( ie > ie_hi ) cycle if ( iproc == job_roots ( ijob ) . and . iproc == eig_roots ( j )) then !no need for data transfer n = size ( response_matrix ( iky )% eigen ( ie )% idx ) allocate ( lu ( n , n )) lu = response_matrix ( iky )% eigen ( ie )% zloc else if ( iproc == job_roots ( ijob )) then !send data to subroots !send size of matrix n_send = size ( response_matrix ( iky )% eigen ( ie )% idx ) call mpi_send ( n_send , 1 , MPI_INT , eig_roots ( j ), j , mp_comm , ierr ) !send matrix call mpi_send ( response_matrix ( iky )% eigen ( ie )% zloc , & n_send * n_send , mpicmplx , eig_roots ( j ), nproc + j , mp_comm , ierr ) else if ( iproc == eig_roots ( j )) then !subroot gets the data !receive size of matrix call mpi_recv ( n , 1 , MPI_INT , job_roots ( ijob ), j , mp_comm , status , ierr ) allocate ( lu ( n , n )) !receive matrix call mpi_recv ( lu , n * n , mpicmplx , job_roots ( ijob ), nproc + j , mp_comm , status , ierr ) end if end do if ( istage >= ( eig_limits ( ceig_core + 1 ) - eig_limits ( ceig_core ))) cycle !nothing for this communicator to do !broadcast matrix and its size across the communicator call mpi_bcast ( n , 1 , MPI_INT , 0 , eig_comm , ierr ) if (. not . allocated ( lu )) allocate ( lu ( n , n )) if (. not . allocated ( vv )) allocate ( vv ( n )) call mpi_bcast ( lu , n * n , mpicmplx , 0 , eig_comm , ierr ) allocate ( dum ( n )) allocate ( idx ( n )) ! All the processors have the matrix. ! Now perform LU decomposition vv = maxval ( cabs ( lu ), dim = 2 ) if ( any ( vv == 0.0 )) & write ( * , * ) 'singular matrix in lu_decomposition on job ' , job , ', process ' , iproc vv = 1.0 / vv do j = 1 , n !divide up the work using row_limits rdiv = ( n - j ) / eig_cores rmod = mod ( n - j , eig_cores ) row_limits ( 0 ) = j + 1 if ( rdiv == 0 ) then row_limits ( rmod + 1 :) = - 1 do k = 1 , rmod row_limits ( k ) = row_limits ( k - 1 ) + 1 end do else do k = 1 , eig_cores row_limits ( k ) = row_limits ( k - 1 ) + rdiv if ( k <= rmod ) row_limits ( k ) = row_limits ( k ) + 1 end do end if !pivot if needed dmax = - 1.0 do k = j , n tmp = vv ( k ) * abs ( lu ( k , j )) if ( tmp > dmax ) then dmax = tmp imax = k end if end do !         imax = (j-1) + imaxloc(vv(j:n)*cabs(lu(j:n,j))) if ( j /= imax ) then dum = lu ( imax , :) lu ( imax , :) = lu ( j , :) lu ( j , :) = dum vv ( imax ) = vv ( j ) end if if ( ieig_core == 0 ) idx ( j ) = imax !get the lead multiplier if ( lu ( j , j ) == 0.0 ) lu ( j , j ) = zero do i = j + 1 , n lu ( i , j ) = lu ( i , j ) / lu ( j , j ) end do r_lo = row_limits ( ieig_core ) r_hi = row_limits ( ieig_core + 1 ) - 1 do k = r_lo , r_hi do i = j + 1 , n lu ( i , k ) = lu ( i , k ) - lu ( i , j ) * lu ( j , k ) end do end do do i = 0 , eig_cores - 1 r_lo = row_limits ( i ) r_hi = row_limits ( i + 1 ) - 1 rsize = ( r_hi - r_lo + 1 ) * ( n - j ) if ( r_lo > r_hi ) cycle !call mpi_bcast(lu(j+1:n,r_lo:r_hi),rsize,mpicmplx,i,eig_comm,ierr) do k = r_lo , r_hi call mpi_bcast ( lu ( j + 1 : n , k ), n - j , mpicmplx , i , eig_comm , ierr ) end do end do end do !LU decomposition ends here !copy the decomposed matrix over do j = 0 , ncomm - 1 ie = eig_limits ( j ) + istage ie_hi = eig_limits ( j + 1 ) - 1 if ( ie > ie_hi ) cycle if ( iproc == job_roots ( ijob ) . and . iproc == eig_roots ( j )) then !no need for data transfer response_matrix ( iky )% eigen ( ie )% zloc = lu response_matrix ( iky )% eigen ( ie )% idx = idx else if ( iproc == eig_roots ( j )) then !subroot sends the data !send indices call mpi_send ( idx , n , MPI_INT , job_roots ( ijob ), j , mp_comm , ierr ) !send matrix call mpi_send ( lu , n * n , mpicmplx , job_roots ( ijob ), nproc + j , mp_comm , ierr ) else if ( iproc == job_roots ( ijob )) then !receive data from subroot !receive indices call mpi_recv ( response_matrix ( iky )% eigen ( ie )% idx , & n , MPI_INT , eig_roots ( j ), j , mp_comm , status , ierr ) !receive matrix call mpi_recv ( response_matrix ( iky )% eigen ( ie )% zloc , & n * n , mpicmplx , eig_roots ( j ), nproc + j , mp_comm , status , ierr ) end if end do deallocate ( vv , lu , idx , dum ) end do deallocate ( eig_roots , eig_limits , row_limits ) end do #ifdef ISO_C_BINDING if ( sgproc0 ) then call scope ( scrossdomprocs ) !copy all the matrices across all nodes do ie = 1 , neigen ( iky ) call broadcast ( response_matrix ( iky )% eigen ( ie )% zloc ) call broadcast ( response_matrix ( iky )% eigen ( ie )% idx ) end do end if call scope ( prior_focus ) #else call scope ( prior_focus ) !copy all the matrices across all nodes do ie = 1 , neigen ( iky ) call broadcast ( response_matrix ( iky )% eigen ( ie )% zloc ) call broadcast ( response_matrix ( iky )% eigen ( ie )% idx ) end do #endif deallocate ( job_roots ) end subroutine parallel_LU_decomposition_global end module response_matrix","tags":"","loc":"sourcefile/response_matrix.fpp.html"},{"title":"stella_geometry.f90 – stella","text":"Source Code module stella_geometry use common_types , only : flux_surface_type implicit none public :: init_geometry , finish_init_geometry , finish_geometry public :: communicate_geo_multibox public :: grho , grho_norm , grad_x public :: bmag , dbdzed , btor , bmag_psi0 public :: gradpar , gradpar_eqarc , b_dot_grad_z , zed_eqarc public :: cvdrift , cvdrift0 public :: gbdrift , gbdrift0 public :: dcvdriftdrho , dcvdrift0drho public :: dgbdriftdrho , dgbdrift0drho public :: gds2 , gds21 , gds22 , gds23 , gds24 , gds25 , gds26 public :: dgds2dr , dgds21dr , dgds22dr public :: exb_nonlin_fac , exb_nonlin_fac_p public :: jacob , djacdrho public :: drhodpsi , drhodpsi_psi0 public :: dl_over_b , d_dl_over_b_drho public :: dBdrho , d2Bdrdth , dgradpardrho , dIdrho public :: geo_surf public :: Rmajor public :: alpha public :: theta_vmec public :: zeta public :: zed_scalefac public :: dxdXcoord , dydalpha public :: sign_torflux public :: aref , bref public :: twist_and_shift_geo_fac public :: q_as_x , get_x_to_rho , gfac public :: dVolume public :: grad_x_grad_y_end public :: x_displacement_fac private type ( flux_surface_type ) :: geo_surf real :: grad_x_grad_y_end real :: aref , bref real :: dxdXcoord , dydalpha real :: dqdrho real :: dIdrho real :: grho_norm real :: drhodpsi , drhodpsi_psi0 , shat , qinp real :: exb_nonlin_fac , exb_nonlin_fac_p real :: gradpar_eqarc real :: zed_scalefac real :: twist_and_shift_geo_fac , gfac real , dimension (:), allocatable :: zed_eqarc real , dimension (:), allocatable :: gradpar real , dimension (:, :), allocatable :: b_dot_grad_z real , dimension (:, :), allocatable :: bmag , bmag_psi0 , dbdzed real , dimension (:, :), allocatable :: twist_and_shift_geo_fac_full real , dimension (:, :), allocatable :: cvdrift , cvdrift0 real , dimension (:, :), allocatable :: gbdrift , gbdrift0 real , dimension (:, :), allocatable :: dcvdriftdrho , dcvdrift0drho real , dimension (:, :), allocatable :: dgbdriftdrho , dgbdrift0drho real , dimension (:, :), allocatable :: gds2 , gds21 , gds22 , gds23 , gds24 , gds25 , gds26 real , dimension (:, :), allocatable :: dgds2dr , dgds21dr real , dimension (:, :), allocatable :: dgds22dr real , dimension (:, :), allocatable :: theta_vmec real , dimension (:, :), allocatable :: jacob , djacdrho , grho , grad_x real , dimension (:, :), allocatable :: dl_over_b , d_dl_over_b_drho real , dimension (:, :, :), allocatable :: dVolume real , dimension (:, :), allocatable :: x_displacement_fac real , dimension (:), allocatable :: dBdrho , d2Bdrdth , dgradpardrho real , dimension (:), allocatable :: btor , Rmajor real , dimension (:), allocatable :: alpha real , dimension (:, :), allocatable :: zeta integer :: sign_torflux integer :: geo_option_switch integer , parameter :: geo_option_local = 1 integer , parameter :: geo_option_inputprof = 2 integer , parameter :: geo_option_vmec = 3 integer , parameter :: geo_option_multibox = 4 logical :: overwrite_geometry logical :: overwrite_bmag , overwrite_gradpar logical :: overwrite_gds2 , overwrite_gds21 , overwrite_gds22 logical :: overwrite_gds23 , overwrite_gds24 logical :: overwrite_gbdrift , overwrite_cvdrift , overwrite_gbdrift0 logical :: q_as_x character ( 100 ) :: geo_file logical :: vmec_chosen = . false . logical :: geoinit = . false . logical :: set_bmag_const contains subroutine init_geometry ( nalpha , naky ) use constants , only : pi use mp , only : proc0 use millerlocal , only : read_local_parameters , get_local_geo use millerlocal , only : communicate_parameters_multibox use vmec_geo , only : read_vmec_parameters , get_vmec_geo use vmec_to_stella_geometry_interface_mod , only : desired_zmin use inputprofiles_interface , only : read_inputprof_geo use zgrid , only : nzed , nzgrid use zgrid , only : zed , delzed use zgrid , only : shat_zero , zed_equal_arc use zgrid , only : grad_x_grad_y_zero use zgrid , only : boundary_option_switch , boundary_option_self_periodic use zgrid , only : boundary_option_linked , boundary_option_linked_stellarator use zgrid , only : dkx_over_dky use file_utils , only : get_unused_unit use physics_flags , only : include_geometric_variation , const_alpha_geo implicit none logical , parameter :: debug = . false . integer , intent ( in ) :: nalpha , naky logical :: stellarator_symmetric_BC real :: dpsidrho , dpsidrho_psi0 real :: new_zeta_min integer :: iy , ia , iz integer :: dxdXcoord_sign , dydalpha_sign real :: field_period_ratio , bmag_z0 real , dimension (:, :), allocatable :: grad_alpha_grad_alpha real , dimension (:, :), allocatable :: grad_alpha_grad_psi real , dimension (:, :), allocatable :: grad_psi_grad_psi real , dimension (:, :), allocatable :: gbdrift_alpha , cvdrift_alpha real , dimension (:, :), allocatable :: gbdrift0_psi , cvdrift0_psi if ( geoinit ) return geoinit = . true . ! B = grad alpha x grad psi ! for tokamak calculations, alpha = zeta - q * theta ! and psi = psi_poloidal ! for stellarator calculations, alpha = theta - iota * zeta ! and psi = -psi_toroidal ! default is no re-scaling of zed zed_scalefac = 1.0 if ( proc0 ) then call read_parameters select case ( geo_option_switch ) case ( geo_option_local ) ! read in Miller local parameters call read_local_parameters ( nzed , nzgrid , geo_surf ) ! allocate geometry arrays call allocate_arrays ( nalpha , nzgrid ) ! use Miller local parameters to get ! geometric coefficients needed by stella call get_local_geo ( nzed , nzgrid , zed , zed_equal_arc , & dpsidrho , dpsidrho_psi0 , dIdrho , grho ( 1 , :), & bmag ( 1 , :), bmag_psi0 ( 1 , :), & gds2 ( 1 , :), gds21 ( 1 , :), gds22 ( 1 , :), & gds23 ( 1 , :), gds24 ( 1 , :), gradpar , & gbdrift0 ( 1 , :), gbdrift ( 1 , :), cvdrift0 ( 1 , :), cvdrift ( 1 , :), & dBdrho , d2Bdrdth , dgradpardrho , btor , rmajor , & dcvdrift0drho ( 1 , :), dcvdriftdrho ( 1 , :), & dgbdrift0drho ( 1 , :), dgbdriftdrho ( 1 , :), & dgds2dr ( 1 , :), dgds21dr ( 1 , :), & dgds22dr ( 1 , :), djacdrho ( 1 , :)) !> b_dot_grad_z is the alpha-dependent b . grad z, !> and gradpar is the constant-in-alpha part of it. !> for axisymmetric systems, b_dot_grad_z is independent of alpha. b_dot_grad_z ( 1 , :) = gradpar ! note that psi here is the enclosed poloidal flux divided by 2pi drhodpsi = 1. / dpsidrho drhodpsi_psi0 = 1. / dpsidrho_psi0 ! dxdXcoord = a*Bref*dx/dpsi = sign(dx/dpsi) * a*q/r dxdXcoord_sign = 1 sign_torflux = - 1 if ( q_as_x ) then dxdXcoord = dxdXcoord_sign * dpsidrho else dxdXcoord = dxdXcoord_sign * geo_surf % qinp_psi0 / geo_surf % rhoc_psi0 end if ! dydalpha = (dy/dalpha) / a = sign(dydalpha) * (dpsi/dr) / (a*Bref) dydalpha_sign = 1 dydalpha = dydalpha_sign * dpsidrho !> | grad x |  = dx/drho * | grad rho | = dx/dpsi * dpsi/drho * | grad rho | !> = q/rho * dpsidrho * grho grad_x = grho * dxdXcoord * dpsidrho_psi0 ! abs(twist_and_shift_geo_fac) is dkx/dky * jtwist ! minus its sign gives the direction of the shift in kx ! to be used for twist-and-shift BC if ( q_as_x ) then twist_and_shift_geo_fac = 2.0 * pi else twist_and_shift_geo_fac = 2.0 * pi * geo_surf % shat_psi0 end if ! aref and bref should not be needed, so set to 1 aref = 1.0 ; bref = 1.0 zeta ( 1 , :) = zed * geo_surf % qinp case ( geo_option_multibox ) ! read in Miller local parameters call read_local_parameters ( nzed , nzgrid , geo_surf ) ! allocate geometry arrays call allocate_arrays ( nalpha , nzgrid ) call communicate_parameters_multibox ( surf = geo_surf ) ! use Miller local parameters to get ! geometric coefficients needed by stella call get_local_geo ( nzed , nzgrid , zed , zed_equal_arc , & dpsidrho , dpsidrho_psi0 , dIdrho , grho ( 1 , :), & bmag ( 1 , :), bmag_psi0 ( 1 , :), & gds2 ( 1 , :), gds21 ( 1 , :), gds22 ( 1 , :), & gds23 ( 1 , :), gds24 ( 1 , :), gradpar , & gbdrift0 ( 1 , :), gbdrift ( 1 , :), cvdrift0 ( 1 , :), cvdrift ( 1 , :), & dBdrho , d2Bdrdth , dgradpardrho , btor , rmajor , & dcvdrift0drho ( 1 , :), dcvdriftdrho ( 1 , :), & dgbdrift0drho ( 1 , :), dgbdriftdrho ( 1 , :), & dgds2dr ( 1 , :), dgds21dr ( 1 , :), & dgds22dr ( 1 , :), djacdrho ( 1 , :)) !> b_dot_grad_z is the alpha-dependent b . grad z, !> and gradpar is the constant-in-alpha part of it. !> for axisymmetric systems, b_dot_grad_z is independent of alpha. b_dot_grad_z ( 1 , :) = gradpar ! note that psi here is the enclosed poloidal flux divided by 2pi drhodpsi = 1. / dpsidrho drhodpsi_psi0 = 1. / dpsidrho_psi0 ! dxdXcoord = a*Bref*dx/dpsi = sign(dx/dpsi) * a*q/r dxdXcoord_sign = 1 sign_torflux = - 1 if ( q_as_x ) then dxdXcoord = dxdXcoord_sign / drhodpsi_psi0 else dxdXcoord = dxdXcoord_sign * geo_surf % qinp_psi0 / geo_surf % rhoc_psi0 end if ! dydalpha = (dy/dalpha) / a = sign(dydalpha) * (dpsi/dr) / (a*Bref) dydalpha_sign = 1 dydalpha = dydalpha_sign / drhodpsi_psi0 !> | grad x |  = dx/drho * | grad rho | = dx/dpsi * dpsi/drho * | grad rho | !> = q/rho * dpsidrho * grho grad_x = grho * dxdXcoord * dpsidrho_psi0 ! abs(twist_and_shift_geo_fac) is dkx/dky * jtwist ! minus its sign gives the direction of the shift in kx ! to be used for twist-and-shift BC if ( q_as_x ) then twist_and_shift_geo_fac = 2.0 * pi else twist_and_shift_geo_fac = 2.0 * pi * geo_surf % shat_psi0 end if ! aref and bref should not be needed, so set to 1 aref = 1.0 ; bref = 1.0 zeta ( 1 , :) = zed * geo_surf % qinp case ( geo_option_inputprof ) ! first read in some local parameters ! only thing needed really is rhoc call read_local_parameters ( nzed , nzgrid , geo_surf ) ! allocate geometry arrays call allocate_arrays ( nalpha , nzgrid ) ! now overwrite local parameters ! with those from input.profiles file ! use rhoc from input as surface call read_inputprof_geo ( geo_surf ) call get_local_geo ( nzed , nzgrid , zed , zed_equal_arc , & dpsidrho , dpsidrho_psi0 , dIdrho , grho ( 1 , :), & bmag ( 1 , :), bmag_psi0 ( 1 , :), & gds2 ( 1 , :), gds21 ( 1 , :), gds22 ( 1 , :), & gds23 ( 1 , :), gds24 ( 1 , :), gradpar , & gbdrift0 ( 1 , :), gbdrift ( 1 , :), cvdrift0 ( 1 , :), cvdrift ( 1 , :), & dBdrho , d2Bdrdth , dgradpardrho , btor , rmajor , & dcvdrift0drho ( 1 , :), dcvdriftdrho ( 1 , :), & dgbdrift0drho ( 1 , :), dgbdriftdrho ( 1 , :), & dgds2dr ( 1 , :), dgds21dr ( 1 , :), & dgds22dr ( 1 , :), djacdrho ( 1 , :)) !> b_dot_grad_z is the alpha-dependent b . grad z, !> and gradpar is the constant-in-alpha part of it. !> for axisymmetric systems, b_dot_grad_z is independent of alpha. b_dot_grad_z ( 1 , :) = gradpar ! psi here is enclosed poloidal flux divided by 2pi drhodpsi = 1. / dpsidrho drhodpsi_psi0 = 1. / dpsidrho_psi0 ! dxdXcoord = a*Bref*dx/dpsi = sign(dx/dpsi) * a*q/r dxdXcoord_sign = 1 dxdXcoord = dxdXcoord_sign * geo_surf % qinp / geo_surf % rhoc sign_torflux = - 1 ! dydalpha = (dy/dalpha) / a = sign(dydalpha) * (dpsi/dr) / (a*Bref) dydalpha_sign = 1 dydalpha = dydalpha_sign * dpsidrho !> | grad x |  = dx/drho * | grad rho | = dx/dpsi * dpsi/drho * | grad rho | !> = q/rho * dpsidrho * grho grad_x = grho * dxdXcoord * dpsidrho_psi0 ! abs(twist_and_shift_geo_fac) is dkx/dky * jtwist ! minus its sign gives the direction of the shift in kx ! to be used for twist-and-shift BC twist_and_shift_geo_fac = 2.0 * pi * geo_surf % shat ! aref and bref should not be needed so set to 1 aref = 1.0 ; bref = 1.0 zeta ( 1 , :) = zed * geo_surf % qinp case ( geo_option_vmec ) vmec_chosen = . true . !> read in input parameters for vmec !> nalpha may be specified via input file if ( debug ) write ( * , * ) 'init_geometry::read_vmec_parameters' call read_vmec_parameters !> allocate geometry arrays if ( debug ) write ( * , * ) 'init_geometry::allocate_arrays' call allocate_arrays ( nalpha , nzgrid ) if ( debug ) write ( * , * ) 'init_geometry::allocate_temporary_arrays' call allocate_temporary_arrays ( nalpha , nzgrid ) !> get geometry coefficients from vmec if ( debug ) write ( * , * ) 'init_geometry::get_vmec_geo' !> abs(twist_and_shift_geo_fac) is dkx/dky * jtwist !> minus its sign gives the direction of the shift in kx !> to be used for twist-and-shift BC allocate ( twist_and_shift_geo_fac_full ( nalpha , - nzgrid : nzgrid )) twist_and_shift_geo_fac_full = 0 !> The code will start computing for the initial zgrid stellarator_symmetric_BC = . false . call get_vmec_geo ( new_zeta_min , stellarator_symmetric_BC , & nzgrid , nalpha , naky , geo_surf , grho , bmag , gradpar , & b_dot_grad_z , grad_alpha_grad_alpha , & grad_alpha_grad_psi , grad_psi_grad_psi , & gds23 , gds24 , gds25 , gds26 , gbdrift_alpha , gbdrift0_psi , & cvdrift_alpha , cvdrift0_psi , sign_torflux , & theta_vmec , zed_scalefac , aref , bref , alpha , zeta , & field_period_ratio , x_displacement_fac ) write ( * , '(A)' ) \"############################################################\" write ( * , '(A)' ) \"                     BOUNDARY CONDITIONS\" write ( * , '(A)' ) \"############################################################\" write ( * , * ) if (( boundary_option_switch == boundary_option_linked_stellarator ) . and . ( dkx_over_dky > 0 )) then ! If stellarator_symmetric_BC and dkx_over_dky>0 the code will compute the new ! zeta to work with stellarator_symmetric_BC = . true . ! twist_and_shift_geo_fac_full for the whole zgrid twist_and_shift_geo_fac_full = - 2. * ( geo_surf % rhotor * geo_surf % rhotor ) * ( grad_alpha_grad_psi ) / ( grad_psi_grad_psi ) ! New min(zeta) to construct the new_number_of_periods_stella call desired_zmin ( nalpha , nzgrid , zeta , twist_and_shift_geo_fac_full , dkx_over_dky , new_zeta_min ) ! Final grid of zeta using new_zeta_min call get_vmec_geo ( new_zeta_min , stellarator_symmetric_BC , & nzgrid , nalpha , naky , geo_surf , grho , bmag , gradpar , & b_dot_grad_z , grad_alpha_grad_alpha , & grad_alpha_grad_psi , grad_psi_grad_psi , & gds23 , gds24 , gds25 , gds26 , gbdrift_alpha , gbdrift0_psi , & cvdrift_alpha , cvdrift0_psi , sign_torflux , & theta_vmec , zed_scalefac , aref , bref , alpha , zeta , & field_period_ratio , x_displacement_fac ) ! Restart the variable twist_and_shift_geo_fac_full twist_and_shift_geo_fac_full = 0 end if !> Define <dxdXcoord> = (ρref/a)(dx̃/dψ̃) and use dx/dψ = 1/(a*ρ0*Bref) !> dxdXcoord = (ρref/a)(dx̃/dψ̃) = (ρref/a)(d(x/ρref)/d(ψ/(a&#94;2 Bref)) = a Bref (dx/dψ) = 1/ρ0 dxdXcoord = 1 / geo_surf % rhotor !> Define <dydalpha> = (ρref/a)(dỹ/dα̃) and use dy/dα = a*ρ0 !> dydalpha = (ρref/a)(dỹ/dα̃) = (ρref/a)(d(y/ρref)/dα) = (1/a) (dy/dα) = ρ0 dydalpha = geo_surf % rhotor !> Define <drhodpsi> = dρ0/dψ̃ and use ρ0 = sqrt(psi_t/psi_{t,LCFS}) and ψ = sgn(psi_t)*psi_t !> Use dρ0/dpsi_t = d(sqrt(psi_t/psi_{t,LCFS}))/dpsi_t = sgn(psi_t)/(a&#94;2 ρ0 Bref) with Bref = 2 |psi_{t,LCFS}| / a&#94;2 !> drhodpsi = dρ0/dψ̃ = dρ0/d(ψ/(a&#94;2 Bref)) = a&#94;2 Bref sgn(psi_t) dρ0/dpsi_t = 1/ρ0 drhodpsi = 1 / geo_surf % rhotor drhodpsi_psi0 = drhodpsi bmag_psi0 = bmag grad_x_grad_y_end = grad_alpha_grad_psi ( 1 , nzgrid ) * ( aref * aref * bref ) select case ( boundary_option_switch ) case ( boundary_option_linked_stellarator ) !to be used for stellarator symmetric twist-and-shift BC !twist_and_shift_geo_fac = -nabla x. nabla y /|nabla x|&#94;2 write ( * , * ) 'Stellarator symmetric twist and shift BC selected' twist_and_shift_geo_fac_full = - 2. * ( geo_surf % rhotor * geo_surf % rhotor ) * ( grad_alpha_grad_psi ) / ( grad_psi_grad_psi ) if ( abs ( grad_x_grad_y_end ) <= grad_x_grad_y_zero ) & write ( * , * ) 'Using periodic boundary conditions as grad_x_grad_y_end < grad_x_grad_y_zero' write ( * , * ) case default ! to be used for std twist-and-shift BC ! twist_and_shift_geo_fac = ! -2.*pi*geo_surf%shat*geo_surf%qinp*drhodpsi*dydalpha/(dxdpsi*geo_surf%rhotor) write ( * , * ) 'Standard twist and shift BC selected' twist_and_shift_geo_fac_full = - 2. * pi * geo_surf % shat * drhodpsi * dydalpha / ( geo_surf % qinp * dxdXcoord * geo_surf % rhotor ) & * field_period_ratio if ( abs ( geo_surf % shat ) <= shat_zero ) & write ( * , * ) 'Using periodic boundary conditions as shat < shat_zero' write ( * , * ) end select twist_and_shift_geo_fac = twist_and_shift_geo_fac_full ( 1 , nzgrid ) deallocate ( twist_and_shift_geo_fac_full ) !> grad_x = | grad x | grad_x = sqrt ( abs ( grad_psi_grad_psi * dxdXcoord ** 2 )) !> gds2 = |grad y|&#94;2 = |grad alpha|&#94;2 * (dy/dalpha)&#94;2 !> note that rhotor = sqrt(psi/psi_LCFS) gds2 = grad_alpha_grad_alpha * dydalpha ** 2 !> Define <gds21> = hat{s} ∇x . ∇y !> Use (dx/dψ)*(dy/dα) = 1/(a ρ0 Bref) * (a ρ0) = 1/Bref !> Use ∇x . ∇y = (dx/dψ)(dy/dα) ∇ψ . ∇α = (1/Bref) ∇ψ . ∇α = <grad_alpha_grad_psi> gds21 = grad_alpha_grad_psi * geo_surf % shat !> gds22 = shat&#94;2 * |grad x|&#94;2 = shat&#94;2 * |grad psi_t|&#94;2 * (dx/dpsi_t)&#94;2 gds22 = ( geo_surf % shat * grad_x ) ** 2 !gds22 = geo_surf%shat**2 * grad_psi_grad_psi * dxdXcoord**2 !> gbdrift_alpha and cvdrift_alpha contain !> the grad-B and curvature drifts projected onto !> the grad alpha direction !> need the projections on grad y gbdrift = gbdrift_alpha * dydalpha cvdrift = cvdrift_alpha * dydalpha !> gbdrift0_psi and cvdrift0_psi contain !> the grad-B and curvature drifts projected onto !> the grad psi direction !> need the projections on grad x gbdrift0 = gbdrift0_psi * dxdXcoord cvdrift0 = cvdrift0_psi * dxdXcoord call deallocate_temporary_arrays !> can test FFS implementation by setting all geometric coefficients !> to their values at a given alpha; i.e., make the system axisymmetric if ( const_alpha_geo ) call set_ffs_geo_coefs_constant ( nalpha ) end select if ( overwrite_geometry ) call overwrite_selected_geometric_coefficients ( nalpha ) ! exb_nonlin_fac is equivalent to kxfac/2 in gs2 if ( q_as_x ) then dqdrho = geo_surf % shat * geo_surf % qinp / geo_surf % rhoc exb_nonlin_fac = - 0.5 * sign_torflux * dxdXcoord * dydalpha * drhodpsi * dqdrho !the following will get multiplied by exb_nonlin_fac in advance_exb_nonlinearity exb_nonlin_fac_p = geo_surf % d2qdr2 / dqdrho - geo_surf % d2psidr2 * drhodpsi else exb_nonlin_fac = - 0.5 * sign_torflux * dxdXcoord * dydalpha exb_nonlin_fac_p = 0.0 end if end if if (. not . proc0 ) call allocate_arrays ( nalpha , nzgrid ) if ( debug . and . proc0 ) write ( * , * ) 'init_geometry::broadcast_arrays' call broadcast_arrays gfac = 1.0 if (. not . include_geometric_variation ) gfac = 0.0 ! should reduce to 2*pi*shat in axisymmetric case ! but not in non-axisymmetric case !    twist_and_shift_geo_fac = geo_surf%shat*(gds21(1,-nzgrid)/gds22(1,-nzgrid)-gds21(1,nzgrid)/gds22(1,nzgrid)) ! FLAG DSO - the followiing assumes a linear relation from q to rho, but this will !            not be correct if d2qdrho != 0 dqdrho = geo_surf % shat * geo_surf % qinp / geo_surf % rhoc ! this old definition of jacob should have been fine, as it was only ever used in both the numerator ! and denominator of averages -- and do any constant factors cancelled out !jacob = 1.0/abs(drhodpsi*spread(gradpar,1,nalpha)*bmag) !> jacob is the Jacobian from Cartesian coordinates to (y,x,z) coordinates !> is ((grad y x grad x) . grad z)&#94;(-1) = Lref*(dalpha/dy)*(dpsi/dx)/(Lref*Bref)*(B/Bref . grad z)&#94;(-1) !> Lref*(dalpha/dy) = 1/dydalpha; (dpsi/dx)/(Lref*Bref) = 1 / dxdXcoord ; (B/Bref . grad z) = gradpar*bmag jacob = - sign_torflux / ( dydalpha * dxdXcoord * b_dot_grad_z * bmag ) !    jacob = 1.0/(dydalpha*dxdXcoord*spread(gradpar,1,nalpha)*bmag) ! this is dl/B dl_over_b = spread ( delzed , 1 , nalpha ) * jacob ! the next line is to avoid double counting the end points for ky = 0 modes (which leads to destabilization ! of the zonal modes for certain input parameters) ! FLAG DSO - while this is correct for ky = 0 modes and sufficient for output, if dl_over_b is applied to ! non-zero ky modes, a more sophisticated approach will be required that takes into account the sign of ! v_parallel dl_over_b (:, nzgrid ) = 0. ! this is the correction to flux-surface-averaging for adiabatic electrons d_dl_over_b_drho = spread ( delzed , 1 , nalpha ) * djacdrho d_dl_over_b_drho (:, nzgrid ) = 0 d_dl_over_b_drho = d_dl_over_b_drho - dl_over_b & * spread ( sum ( d_dl_over_b_drho , dim = 2 ) / sum ( dl_over_b , dim = 2 ), 2 , 2 * nzgrid + 1 ) d_dl_over_b_drho = gfac * d_dl_over_b_drho / spread ( sum ( dl_over_b , dim = 2 ), 2 , 2 * nzgrid + 1 ) ! normalize dl/B by int dl/B dl_over_b = dl_over_b / spread ( sum ( dl_over_b , dim = 2 ), 2 , 2 * nzgrid + 1 ) ! this is what we use to normalize the fluxes grho_norm = sum ( dl_over_b ( 1 , :) * grho ( 1 , :)) ! would probably be better to compute this in the various ! geometry subroutine (Miller, vmec, etc.), as there ! B is likely calculated on a finer z-grid do iy = 1 , nalpha call get_dzed ( nzgrid , delzed , bmag ( iy , :), dbdzed ( iy , :)) end do select case ( boundary_option_switch ) case ( boundary_option_linked ) ! if magnetic shear almost zero, override parallel ! boundary condition so that it is periodic if using the standard ! twist and shift bc, in which kx_shift is proportional to shat if ( abs ( geo_surf % shat ) <= shat_zero ) & boundary_option_switch = boundary_option_self_periodic case ( boundary_option_linked_stellarator ) ! if magnetic nabla x. nabla y is almost zero, override parallel ! boundary condition so that it is periodic if using the stellarator ! symmetric twist and shift bc, in which kx_shift is proportional to nabla ! x. nabla y if ( abs ( grad_x_grad_y_end ) <= grad_x_grad_y_zero ) & boundary_option_switch = boundary_option_self_periodic case default ! low shear is fine for periodic/zero parallel BCs, so do nothing end select ! theta_eqarc is parallel coordinate such that ! b . grad theta_eqarc = constant ! and theta_eqarc = theta at +/- pi ! b . grad theta_eqarc = b . grad theta dtheta_eqarc/dtheta ! --> dtheta_eqarc/dtheta = b . grad theta_eqarc / b . grad theta ! --> 2*pi = b . grad theta_eqarc * int_0&#94;{2pi} dtheta 1/(b.grad theta) ! this gives b . grad theta_eqarc, from which we get ! theta_eqarc = theta_min + int_{0}&#94;{theta} dtheta' b . grad theta_eqarc / b . grad theta' call get_gradpar_eqarc ( gradpar , zed , delzed , gradpar_eqarc ) call get_zed_eqarc ( gradpar , delzed , zed , gradpar_eqarc , zed_eqarc ) if ( proc0 ) call write_geometric_coefficients ( nalpha ) ! AVB: temporary, set bmag = constant in z for Spitzer problem if ( set_bmag_const ) then bmag_z0 = bmag ( 1 , 0 ) print * , '' print * , '! SETTING BMAG = CONSTANT IN Z' print * , '' do ia = 1 , nalpha do iz = - nzgrid , nzgrid bmag ( ia , iz ) = bmag_z0 end do end do end if contains subroutine allocate_temporary_arrays ( nalpha , nzgrid ) implicit none integer , intent ( in ) :: nalpha , nzgrid allocate ( grad_alpha_grad_alpha ( nalpha , - nzgrid : nzgrid )) allocate ( grad_alpha_grad_psi ( nalpha , - nzgrid : nzgrid )) allocate ( grad_psi_grad_psi ( nalpha , - nzgrid : nzgrid )) allocate ( gbdrift_alpha ( nalpha , - nzgrid : nzgrid )) allocate ( cvdrift_alpha ( nalpha , - nzgrid : nzgrid )) allocate ( gbdrift0_psi ( nalpha , - nzgrid : nzgrid )) allocate ( cvdrift0_psi ( nalpha , - nzgrid : nzgrid )) end subroutine allocate_temporary_arrays subroutine deallocate_temporary_arrays implicit none deallocate ( grad_alpha_grad_alpha ) deallocate ( grad_alpha_grad_psi ) deallocate ( grad_psi_grad_psi ) deallocate ( gbdrift_alpha ) deallocate ( cvdrift_alpha ) deallocate ( gbdrift0_psi ) deallocate ( cvdrift0_psi ) end subroutine deallocate_temporary_arrays subroutine overwrite_selected_geometric_coefficients ( nalpha ) use file_utils , only : get_unused_unit use zgrid , only : nzgrid implicit none integer , intent ( in ) :: nalpha integer :: geofile_unit character ( 100 ) :: dum_char real :: dum_real integer :: ia , iz real :: bmag_file , gradpar_file real :: gds2_file , gds21_file , gds22_file , gds23_file , gds24_file real :: gbdrift_file , cvdrift_file , gbdrift0_file call get_unused_unit ( geofile_unit ) open ( geofile_unit , file = trim ( geo_file ), status = 'old' , action = 'read' ) read ( geofile_unit , fmt =* ) dum_char read ( geofile_unit , fmt =* ) dum_char read ( geofile_unit , fmt =* ) dum_char ! overwrite bmag, gradpar, gds2, gds21, gds22, gds23, gds24, gbdrift, cvdrift, gbdrift0, and cvdrift0 ! with values from file do ia = 1 , nalpha do iz = - nzgrid , nzgrid read ( geofile_unit , fmt = '(13e12.4)' ) dum_real , dum_real , dum_real , bmag_file , gradpar_file , & gds2_file , gds21_file , gds22_file , gds23_file , & gds24_file , gbdrift_file , cvdrift_file , gbdrift0_file if ( overwrite_bmag ) bmag ( ia , iz ) = bmag_file if ( overwrite_gradpar ) gradpar ( iz ) = gradpar_file if ( overwrite_gradpar ) b_dot_grad_z ( 1 , iz ) = gradpar_file ! assuming we are only reading in for a single alpha. Usually, gradpar is the average of all b_dot_grad_z values. if ( overwrite_gds2 ) gds2 ( ia , iz ) = gds2_file if ( overwrite_gds21 ) gds21 ( ia , iz ) = gds21_file if ( overwrite_gds22 ) gds22 ( ia , iz ) = gds22_file if ( overwrite_gds23 ) gds23 ( ia , iz ) = gds23_file if ( overwrite_gds24 ) gds24 ( ia , iz ) = gds24_file if ( overwrite_gbdrift ) gbdrift ( ia , iz ) = gbdrift_file if ( overwrite_cvdrift ) cvdrift ( ia , iz ) = cvdrift_file if ( overwrite_gbdrift0 ) gbdrift0 ( ia , iz ) = gbdrift0_file end do end do cvdrift0 = gbdrift0 close ( geofile_unit ) end subroutine overwrite_selected_geometric_coefficients subroutine set_ffs_geo_coefs_constant ( nalpha ) implicit none integer , intent ( in ) :: nalpha call set_coef_constant ( gbdrift0 , nalpha ) call set_coef_constant ( cvdrift0 , nalpha ) call set_coef_constant ( gbdrift , nalpha ) call set_coef_constant ( cvdrift , nalpha ) call set_coef_constant ( grad_x , nalpha ) call set_coef_constant ( grho , nalpha ) call set_coef_constant ( bmag , nalpha ) call set_coef_constant ( bmag_psi0 , nalpha ) call set_coef_constant ( gds2 , nalpha ) call set_coef_constant ( gds21 , nalpha ) call set_coef_constant ( gds22 , nalpha ) call set_coef_constant ( gds23 , nalpha ) call set_coef_constant ( gds24 , nalpha ) call set_coef_constant ( gds25 , nalpha ) call set_coef_constant ( gds26 , nalpha ) call set_coef_constant ( theta_vmec , nalpha ) call set_coef_constant ( x_displacement_fac , nalpha ) call set_coef_constant ( zeta , nalpha ) call set_coef_constant ( b_dot_grad_z , nalpha ) ! following coefficients calculated later using above coefficients !      call set_coef_constant (dbdzed, nalpha) !      call set_coef_constant (jacob, nalpha) !      call set_coef_constant (dl_over_b, nalpha) end subroutine set_ffs_geo_coefs_constant subroutine set_coef_constant ( coef , nalpha ) implicit none real , dimension (:, - nzgrid :), intent ( in out ) :: coef integer , intent ( in ) :: nalpha coef = spread ( coef ( 1 , :), 1 , nalpha ) end subroutine set_coef_constant end subroutine init_geometry subroutine allocate_arrays ( nalpha , nzgrid ) implicit none integer , intent ( in ) :: nalpha , nzgrid if (. not . allocated ( bmag )) allocate ( bmag ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( bmag_psi0 )) allocate ( bmag_psi0 ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( gds2 )) allocate ( gds2 ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( gds21 )) allocate ( gds21 ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( gds22 )) allocate ( gds22 ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( gds23 )) allocate ( gds23 ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( gds24 )) allocate ( gds24 ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( gds25 )) allocate ( gds25 ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( gds26 )) allocate ( gds26 ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( dgds2dr )) allocate ( dgds2dr ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( dgds21dr )) allocate ( dgds21dr ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( dgds22dr )) allocate ( dgds22dr ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( gbdrift )) allocate ( gbdrift ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( gbdrift0 )) allocate ( gbdrift0 ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( cvdrift )) allocate ( cvdrift ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( cvdrift0 )) allocate ( cvdrift0 ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( dgbdriftdrho )) allocate ( dgbdriftdrho ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( dcvdriftdrho )) allocate ( dcvdriftdrho ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( dgbdrift0drho )) allocate ( dgbdrift0drho ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( dcvdrift0drho )) allocate ( dcvdrift0drho ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( dbdzed )) allocate ( dbdzed ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( theta_vmec )) allocate ( theta_vmec ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( jacob )) allocate ( jacob ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( djacdrho )) allocate ( djacdrho ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( grho )) allocate ( grho ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( grad_x )) allocate ( grad_x ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( dl_over_b )) allocate ( dl_over_b ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( d_dl_over_b_drho )) allocate ( d_dl_over_b_drho ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( b_dot_grad_z )) allocate ( b_dot_grad_z ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( gradpar )) allocate ( gradpar ( - nzgrid : nzgrid )) if (. not . allocated ( zed_eqarc )) allocate ( zed_eqarc ( - nzgrid : nzgrid )) if (. not . allocated ( btor )) allocate ( btor ( - nzgrid : nzgrid )) if (. not . allocated ( rmajor )) allocate ( rmajor ( - nzgrid : nzgrid )) if (. not . allocated ( dBdrho )) allocate ( dBdrho ( - nzgrid : nzgrid )) if (. not . allocated ( d2Bdrdth )) allocate ( d2Bdrdth ( - nzgrid : nzgrid )) if (. not . allocated ( dgradpardrho )) allocate ( dgradpardrho ( - nzgrid : nzgrid )) if (. not . allocated ( alpha )) allocate ( alpha ( nalpha )); alpha = 0. if (. not . allocated ( zeta )) allocate ( zeta ( nalpha , - nzgrid : nzgrid )); zeta = 0. if (. not . allocated ( x_displacement_fac )) allocate ( x_displacement_fac ( nalpha , - nzgrid : nzgrid )); x_displacement_fac = 0. end subroutine allocate_arrays subroutine read_parameters use text_options use file_utils , only : error_unit , input_unit_exist use file_utils , only : runtype_option_Switch , runtype_multibox use mp , only : job use physics_flags , only : radial_variation implicit none integer :: in_file , ierr logical :: exist character ( 20 ) :: geo_option type ( text_option ), dimension ( 5 ), parameter :: geoopts = ( / & text_option ( 'default' , geo_option_local ), & text_option ( 'miller' , geo_option_local ), & text_option ( 'local' , geo_option_local ), & text_option ( 'input.profiles' , geo_option_inputprof ), & text_option ( 'vmec' , geo_option_vmec ) / ) namelist / geo_knobs / geo_option , geo_file , overwrite_bmag , overwrite_gradpar , & overwrite_gds2 , overwrite_gds21 , overwrite_gds22 , overwrite_gds23 , overwrite_gds24 , & overwrite_gbdrift , overwrite_cvdrift , overwrite_gbdrift0 , q_as_x , set_bmag_const geo_option = 'local' overwrite_bmag = . false . overwrite_gradpar = . false . overwrite_gds2 = . false . overwrite_gds21 = . false . overwrite_gds22 = . false . overwrite_gds23 = . false . overwrite_gds24 = . false . overwrite_gbdrift = . false . overwrite_cvdrift = . false . overwrite_gbdrift0 = . false . set_bmag_const = . false . q_as_x = radial_variation !true by default in radial variation runs geo_file = 'input.geometry' in_file = input_unit_exist ( \"geo_knobs\" , exist ) if ( exist ) read ( unit = in_file , nml = geo_knobs ) ierr = error_unit () call get_option_value & ( geo_option , geoopts , geo_option_switch , & ierr , \"geo_option in geo_knobs\" ) if ( radial_variation . and . runtype_option_switch == runtype_multibox . and . job /= 1 ) then geo_option_switch = geo_option_multibox end if overwrite_geometry = overwrite_bmag . or . overwrite_gradpar & . or . overwrite_gds2 . or . overwrite_gds21 . or . overwrite_gds22 & . or . overwrite_gds23 . or . overwrite_gds24 & . or . overwrite_cvdrift . or . overwrite_gbdrift . or . overwrite_gbdrift0 end subroutine read_parameters subroutine broadcast_arrays use mp , only : broadcast implicit none call broadcast ( qinp ) call broadcast ( shat ) call broadcast ( drhodpsi ) call broadcast ( drhodpsi_psi0 ) call broadcast ( exb_nonlin_fac ) call broadcast ( exb_nonlin_fac_p ) call broadcast ( dIdrho ) call broadcast ( grho ) call broadcast ( grad_x ) call broadcast ( bmag ) call broadcast ( bmag_psi0 ) call broadcast ( btor ) call broadcast ( rmajor ) call broadcast ( gradpar ) call broadcast ( b_dot_grad_z ) call broadcast ( gds2 ) call broadcast ( gds21 ) call broadcast ( gds22 ) call broadcast ( gds23 ) call broadcast ( gds24 ) call broadcast ( gds25 ) call broadcast ( gds26 ) call broadcast ( dgds2dr ) call broadcast ( dgds21dr ) call broadcast ( dgds22dr ) call broadcast ( gbdrift0 ) call broadcast ( gbdrift ) call broadcast ( cvdrift0 ) call broadcast ( cvdrift ) call broadcast ( dgbdrift0drho ) call broadcast ( dgbdriftdrho ) call broadcast ( dcvdrift0drho ) call broadcast ( dcvdriftdrho ) call broadcast ( dBdrho ) call broadcast ( d2Bdrdth ) call broadcast ( dgradpardrho ) call broadcast ( djacdrho ) call broadcast ( geo_surf % rmaj ) call broadcast ( geo_surf % rgeo ) call broadcast ( geo_surf % kappa ) call broadcast ( geo_surf % kapprim ) call broadcast ( geo_surf % tri ) call broadcast ( geo_surf % triprim ) call broadcast ( geo_surf % rhoc ) call broadcast ( geo_surf % rhoc_psi0 ) call broadcast ( geo_surf % dr ) call broadcast ( geo_surf % shift ) call broadcast ( geo_surf % qinp ) call broadcast ( geo_surf % qinp_psi0 ) call broadcast ( geo_surf % shat ) call broadcast ( geo_surf % shat_psi0 ) call broadcast ( geo_surf % betaprim ) call broadcast ( geo_surf % betadbprim ) call broadcast ( geo_surf % d2qdr2 ) call broadcast ( geo_surf % d2psidr2 ) call broadcast ( geo_surf % dpsitordrho ) call broadcast ( geo_surf % rhotor ) call broadcast ( geo_surf % psitor_lcfs ) call broadcast ( geo_surf % drhotordrho ) call broadcast ( zed_scalefac ) call broadcast ( q_as_x ) call broadcast ( set_bmag_const ) call broadcast ( alpha ) call broadcast ( zeta ) call broadcast ( dxdXcoord ) call broadcast ( dydalpha ) call broadcast ( sign_torflux ) call broadcast ( twist_and_shift_geo_fac ) call broadcast ( grad_x_grad_y_end ) call broadcast ( vmec_chosen ) call broadcast ( aref ) call broadcast ( bref ) end subroutine broadcast_arrays subroutine communicate_geo_multibox ( l_edge , r_edge ) use millerlocal , only : communicate_parameters_multibox use mp , only : proc0 implicit none real , intent ( in ) :: l_edge , r_edge if ( proc0 ) then call communicate_parameters_multibox ( geo_surf , gfac * l_edge , gfac * r_edge ) end if end subroutine communicate_geo_multibox ! given function f(z:-pi->pi), calculate z derivative ! second order accurate, with equal grid spacing assumed ! assumes periodic in z -- may need to change this in future subroutine get_dzed ( nz , dz , f , df ) implicit none integer , intent ( in ) :: nz real , dimension ( - nz :), intent ( in ) :: dz , f real , dimension ( - nz :), intent ( out ) :: df df ( - nz + 1 : nz - 1 ) = ( f ( - nz + 2 :) - f (: nz - 2 )) / ( dz (: nz - 2 ) + dz ( - nz + 1 : nz - 1 )) ! FLAG -- THIS MAY NEED TO BE CHANGED ! use periodicity at boundary df ( - nz ) = ( f ( - nz + 1 ) - f ( nz - 1 )) / ( dz ( - nz ) + dz ( nz - 1 )) df ( nz ) = df ( - nz ) end subroutine get_dzed subroutine get_gradpar_eqarc ( gp , z , dz , gp_eqarc ) use constants , only : pi use zgrid , only : nzgrid implicit none real , dimension ( - nzgrid :), intent ( in ) :: gp , z , dz real , intent ( out ) :: gp_eqarc ! first get int dz b . grad z call integrate_zed ( dz , 1. / gp , gp_eqarc ) ! then take (zmax-zmin)/int (dz b . gradz) ! to get b . grad z' gp_eqarc = ( z ( nzgrid ) - z ( - nzgrid )) / gp_eqarc end subroutine get_gradpar_eqarc subroutine get_zed_eqarc ( gp , dz , z , gp_eqarc , z_eqarc ) use zgrid , only : nzgrid implicit none real , dimension ( - nzgrid :), intent ( in ) :: gp , dz , z real , intent ( in ) :: gp_eqarc real , dimension ( - nzgrid :), intent ( out ) :: z_eqarc integer :: iz z_eqarc ( - nzgrid ) = z ( - nzgrid ) do iz = - nzgrid + 1 , nzgrid call integrate_zed ( dz (: iz ), 1. / gp (: iz ), z_eqarc ( iz )) end do z_eqarc ( - nzgrid + 1 :) = z ( - nzgrid ) + z_eqarc ( - nzgrid + 1 :) * gp_eqarc end subroutine get_zed_eqarc ! trapezoidal rule to integrate in zed subroutine integrate_zed ( dz , f , intf ) use zgrid , only : nzgrid implicit none real , dimension ( - nzgrid :), intent ( in ) :: dz real , dimension ( - nzgrid :), intent ( in ) :: f real , intent ( out ) :: intf integer :: iz , iz_max iz_max = - nzgrid + size ( dz ) - 1 intf = 0. do iz = - nzgrid + 1 , iz_max intf = intf + dz ( iz ) * ( f ( iz - 1 ) + f ( iz )) end do intf = 0.5 * intf end subroutine integrate_zed subroutine get_x_to_rho ( llim , x_in , rho_out ) use physics_parameters , only : rhostar implicit none integer , intent ( in ) :: llim real , dimension (:), intent ( in ) :: x_in real , dimension (:), intent ( out ) :: rho_out integer :: ix , ulim real :: a , b , c ulim = size ( x_in ) + llim - 1 if ( q_as_x ) then a = 0.5 * geo_surf % d2qdr2 / dqdrho b = 1.0 c = - rhostar / ( dqdrho * dxdXcoord ) else a = 0.5 * geo_surf % d2psidr2 * drhodpsi b = 1.0 c = - rhostar * drhodpsi / dxdXcoord end if do ix = llim , ulim if ( abs ( 4.0 * a * c * x_in ( ix )) < 1.e-6 ) then rho_out ( ix ) = - ( c * x_in ( ix )) / b - a * ( c * x_in ( ix )) ** 2 / b ** 3 else rho_out ( ix ) = ( - b + sqrt ( b ** 2 - 4. * a * c * x_in ( ix ))) / ( 2. * a ) end if end do end subroutine get_x_to_rho subroutine write_geometric_coefficients ( nalpha ) use file_utils , only : open_output_file , close_output_file use zgrid , only : nzgrid , zed implicit none integer , intent ( in ) :: nalpha integer :: geometry_unit integer :: ia , iz call open_output_file ( geometry_unit , '.geometry' ) write ( geometry_unit , '(a1,11a14)' ) '#' , 'rhoc' , 'qinp' , 'shat' , 'rhotor' , 'aref' , 'bref' , 'dxdXcoord' , 'dydalpha' , & 'exb_nonlin' , 'exb_nonlin_p' write ( geometry_unit , '(a1,11e14.4)' ) '#' , geo_surf % rhoc , geo_surf % qinp , geo_surf % shat , geo_surf % rhotor , aref , bref , & dxdXcoord , dydalpha , exb_nonlin_fac , exb_nonlin_fac_p * exb_nonlin_fac write ( geometry_unit , * ) write ( geometry_unit , '(15a12)' ) '# alpha' , 'zed' , 'zeta' , 'bmag' , 'bdot_grad_z' , 'gds2' , 'gds21' , 'gds22' , & 'gds23' , 'gds24' , 'gbdrift' , 'cvdrift' , 'gbdrift0' , 'bmag_psi0' , 'btor' do ia = 1 , nalpha do iz = - nzgrid , nzgrid !          write (geometry_unit,'(15e12.4)') alpha(ia), zed(iz), zeta(ia,iz), bmag(ia,iz), gradpar(iz), & write ( geometry_unit , '(15e12.4)' ) alpha ( ia ), zed ( iz ), zeta ( ia , iz ), bmag ( ia , iz ), b_dot_grad_z ( ia , iz ), & gds2 ( ia , iz ), gds21 ( ia , iz ), gds22 ( ia , iz ), gds23 ( ia , iz ), & gds24 ( ia , iz ), gbdrift ( ia , iz ), cvdrift ( ia , iz ), gbdrift0 ( ia , iz ), & bmag_psi0 ( ia , iz ), btor ( iz ) end do write ( geometry_unit , * ) end do call close_output_file ( geometry_unit ) end subroutine write_geometric_coefficients subroutine finish_init_geometry use mp , only : proc0 use millerlocal , only : finish_local_geo implicit none if ( proc0 ) then select case ( geo_option_switch ) case ( geo_option_local ) call finish_local_geo case ( geo_option_multibox ) call finish_local_geo case ( geo_option_inputprof ) call finish_local_geo case ( geo_option_vmec ) end select end if end subroutine finish_init_geometry subroutine finish_geometry implicit none if ( allocated ( zed_eqarc )) deallocate ( zed_eqarc ) if ( allocated ( grho )) deallocate ( grho ) if ( allocated ( grad_x )) deallocate ( grad_x ) if ( allocated ( bmag )) deallocate ( bmag ) if ( allocated ( bmag_psi0 )) deallocate ( bmag_psi0 ) if ( allocated ( btor )) deallocate ( btor ) if ( allocated ( rmajor )) deallocate ( rmajor ) if ( allocated ( dbdzed )) deallocate ( dbdzed ) if ( allocated ( jacob )) deallocate ( jacob ) if ( allocated ( djacdrho )) deallocate ( djacdrho ) if ( allocated ( gradpar )) deallocate ( gradpar ) if ( allocated ( b_dot_grad_z )) deallocate ( b_dot_grad_z ) if ( allocated ( dl_over_b )) deallocate ( dl_over_b ) if ( allocated ( d_dl_over_b_drho )) deallocate ( d_dl_over_b_drho ) if ( allocated ( gds2 )) deallocate ( gds2 ) if ( allocated ( gds21 )) deallocate ( gds21 ) if ( allocated ( gds22 )) deallocate ( gds22 ) if ( allocated ( gds23 )) deallocate ( gds23 ) if ( allocated ( gds24 )) deallocate ( gds24 ) if ( allocated ( gds25 )) deallocate ( gds25 ) if ( allocated ( gds26 )) deallocate ( gds26 ) if ( allocated ( dgds2dr )) deallocate ( dgds2dr ) if ( allocated ( dgds21dr )) deallocate ( dgds21dr ) if ( allocated ( dgds22dr )) deallocate ( dgds22dr ) if ( allocated ( gbdrift )) deallocate ( gbdrift ) if ( allocated ( gbdrift0 )) deallocate ( gbdrift0 ) if ( allocated ( cvdrift )) deallocate ( cvdrift ) if ( allocated ( cvdrift0 )) deallocate ( cvdrift0 ) if ( allocated ( dgbdriftdrho )) deallocate ( dgbdriftdrho ) if ( allocated ( dcvdriftdrho )) deallocate ( dcvdriftdrho ) if ( allocated ( dgbdrift0drho )) deallocate ( dgbdrift0drho ) if ( allocated ( dcvdrift0drho )) deallocate ( dcvdrift0drho ) if ( allocated ( dBdrho )) deallocate ( dBdrho ) if ( allocated ( d2Bdrdth )) deallocate ( d2Bdrdth ) if ( allocated ( dgradpardrho )) deallocate ( dgradpardrho ) if ( allocated ( theta_vmec )) deallocate ( theta_vmec ) if ( allocated ( alpha )) deallocate ( alpha ) if ( allocated ( zeta )) deallocate ( zeta ) if ( allocated ( x_displacement_fac )) deallocate ( x_displacement_fac ) geoinit = . false . end subroutine finish_geometry end module stella_geometry","tags":"","loc":"sourcefile/stella_geometry.f90.html"},{"title":"text_options.f90 – stella","text":"Source Code module text_options implicit none private public :: text_option public :: get_option_value integer , parameter :: maxlen = 30 type :: text_option character ( maxlen ) :: name integer :: value end type text_option contains subroutine get_option_value ( selection , options , value , & error_unit , selection_name , stop_on_error ) use mp , only : mp_abort implicit none character ( * ), intent ( in ) :: selection type ( text_option ), dimension (:), intent ( in ) :: options integer , intent ( in out ) :: value integer , intent ( in ), optional :: error_unit character ( * ), intent ( in ), optional :: selection_name logical , intent ( in ), optional :: stop_on_error integer :: i , l , n_partial_matches , v_partial_match integer :: err logical :: local_stop local_stop = . false . if ( present ( stop_on_error )) local_stop = stop_on_error do i = 1 , size ( options ) if ( trim ( selection ) == trim ( options ( i )% name )) then value = options ( i )% value return end if end do ! look for partial matches l = len_trim ( selection ) n_partial_matches = 0 do i = 1 , size ( options ) if ( l < len_trim ( options ( i )% name )) then if ( trim ( selection ) == options ( i )% name ( 1 : l )) then n_partial_matches = n_partial_matches + 1 v_partial_match = options ( i )% value end if end if end do if ( n_partial_matches == 1 ) then value = v_partial_match return end if if ( present ( error_unit )) then err = error_unit else err = 6 end if if ( n_partial_matches == 0 ) then if ( present ( selection_name )) then write ( unit = err , fmt = \"('Invalid selection for ', a, ': ', a)\" ) & trim ( selection_name ), trim ( selection ) else write ( unit = err , fmt = \"('Invalid selection: ',a)\" ) trim ( selection ) end if write ( unit = err , fmt = \"('Valid selections are:')\" ) do i = 1 , size ( options ) write ( unit = err , fmt = \"(3x,a)\" ) trim ( options ( i )% name ) end do else if ( present ( selection_name )) then write ( unit = err , fmt = \"('Ambiguous selection for ', a, ': ', a)\" ) & trim ( selection_name ), trim ( selection ) else write ( unit = err , fmt = \"('Ambiguous selection: ',a)\" ) trim ( selection ) end if write ( unit = err , fmt = \"('Matching selections are:')\" ) do i = 1 , size ( options ) if ( l < len_trim ( options ( i )% name )) then if ( trim ( selection ) == options ( i )% name ( 1 : l )) then write ( unit = err , fmt = \"(3x,a)\" ) trim ( options ( i )% name ) end if end if end do end if if ( local_stop ) then call mp_abort ( 'STOP error in get_option_value' ) end if write ( unit = err , fmt = \"('Continuing with default selection...')\" ) end subroutine get_option_value end module text_options","tags":"","loc":"sourcefile/text_options.f90.html"},{"title":"zgrid.f90 – stella","text":"Source Code module zgrid implicit none public :: init_zgrid , finish_zgrid public :: nzed , nzgrid , nperiod , ntubes public :: nztot , nz2pi public :: zed public :: delzed public :: zed_equal_arc public :: get_total_arc_length public :: get_arc_length_grid public :: shat_zero public :: grad_x_grad_y_zero public :: dkx_over_dky public :: boundary_option_switch public :: boundary_option_zero public :: boundary_option_self_periodic public :: boundary_option_linked public :: boundary_option_linked_stellarator private integer :: nzed , nzgrid , nztot , nz2pi integer :: nperiod , ntubes logical :: zed_equal_arc real :: shat_zero , grad_x_grad_y_zero , dkx_over_dky real , dimension (:), allocatable :: zed , delzed integer :: boundary_option_switch integer , parameter :: boundary_option_zero = 1 , & boundary_option_self_periodic = 2 , & boundary_option_linked = 3 , & boundary_option_linked_stellarator = 4 logical :: zgridinit = . false . contains subroutine init_zgrid use mp , only : proc0 use constants , only : pi implicit none integer :: i if ( zgridinit ) return zgridinit = . true . if ( proc0 ) then call read_parameters end if call broadcast_parameters if (. not . allocated ( zed )) allocate ( zed ( - nzgrid : nzgrid )) if (. not . allocated ( delzed )) allocate ( delzed ( - nzgrid : nzgrid )) zed = ( / ( i * pi / real ( nzed / 2 ), i =- nzgrid , nzgrid ) / ) delzed (: nzgrid - 1 ) = zed ( - nzgrid + 1 :) - zed (: nzgrid - 1 ) delzed ( nzgrid ) = delzed ( - nzgrid ) nztot = 2 * nzgrid + 1 ! number of zed in a 2*pi segment, including points at +/- pi nz2pi = 2 * ( nzed / 2 ) + 1 end subroutine init_zgrid subroutine read_parameters use file_utils , only : input_unit_exist , error_unit use text_options , only : text_option , get_option_value use physics_flags , only : full_flux_surface implicit none integer :: in_file , ierr logical :: exist type ( text_option ), dimension ( 7 ), parameter :: boundaryopts = & ( / text_option ( 'default' , boundary_option_zero ), & text_option ( 'zero' , boundary_option_zero ), & text_option ( 'unconnected' , boundary_option_zero ), & text_option ( 'self-periodic' , boundary_option_self_periodic ), & text_option ( 'periodic' , boundary_option_self_periodic ), & text_option ( 'linked' , boundary_option_linked ), & text_option ( 'stellarator' , boundary_option_linked_stellarator ) / ) character ( 20 ) :: boundary_option namelist / zgrid_parameters / nzed , nperiod , ntubes , & shat_zero , boundary_option , zed_equal_arc , & grad_x_grad_y_zero , dkx_over_dky nzed = 24 nperiod = 1 ntubes = 1 boundary_option = 'default' ! if zed_equal_arc = T, then zed is chosen to be arc length ! if zed_equal_arc = F, then zed is poloidal (axisymmetric) ! or zeta (toroidal) angle zed_equal_arc = . false . ! set minimum shat value below which we assume ! periodic BC shat_zero = 1.e-5 ! set the minimum nabla x . nabla value at the end of the FT which we assume ! periodic BC instead of the stellarator symmetric ones grad_x_grad_y_zero = 1.e-5 ! set the ratio between dkx and dky, assuming jtwist = 1. ! if it is < 0, the code will just use the nfield_periods in the input file dkx_over_dky = - 1 in_file = input_unit_exist ( \"zgrid_parameters\" , exist ) if ( exist ) read ( unit = in_file , nml = zgrid_parameters ) ierr = error_unit () call get_option_value & ( boundary_option , boundaryopts , boundary_option_switch , & ierr , \"boundary_option in dist_fn_knobs\" ) ! note that boundary_option may be changed to self-periodic later ! if magnetic shear or nabla x \\cdot nabla y is smaller than shat_zero or grad_x_grad_y_zero ! cannot do this here as these quantities have yet to be input nzgrid = nzed / 2 + ( nperiod - 1 ) * nzed ! force use of equal arc grid to ensure gradpar alpha-independent ! necessary to obtain efficient numerical solution of parallel streaming if ( full_flux_surface ) zed_equal_arc = . true . end subroutine read_parameters subroutine broadcast_parameters use mp , only : broadcast implicit none call broadcast ( nzed ) call broadcast ( nzgrid ) call broadcast ( nperiod ) call broadcast ( ntubes ) call broadcast ( zed_equal_arc ) call broadcast ( shat_zero ) call broadcast ( boundary_option_switch ) call broadcast ( grad_x_grad_y_zero ) call broadcast ( dkx_over_dky ) end subroutine broadcast_parameters subroutine finish_zgrid implicit none if ( allocated ( zed )) deallocate ( zed ) if ( allocated ( delzed )) deallocate ( delzed ) zgridinit = . false . end subroutine finish_zgrid subroutine get_total_arc_length ( nz , gp , dz , length ) implicit none integer , intent ( in ) :: nz real , dimension ( - nz :), intent ( in ) :: gp real , intent ( in ) :: dz real , intent ( out ) :: length call integrate_zed ( nz , dz , 1. / gp , length ) end subroutine get_total_arc_length subroutine get_arc_length_grid ( nz_max , nzext_max , zboundary , gp , dz , zarc ) implicit none integer , intent ( in ) :: nz_max , nzext_max real , intent ( in ) :: zboundary real , dimension ( - nzext_max :), intent ( in ) :: gp real , intent ( in ) :: dz real , dimension ( - nzext_max :), intent ( out ) :: zarc integer :: iz zarc ( - nz_max ) = zboundary if ( nz_max /= nzext_max ) then do iz = - nzext_max , - nz_max - 1 call integrate_zed ( nzext_max , dz , 1. / gp ( iz : - nz_max ), zarc ( iz )) zarc ( iz ) = zarc ( - nz_max ) - zarc ( iz ) end do end if ! this seems very inefficient -- could just add incremental change at each zed, ! rather than recomputing from the boundary each time do iz = - nz_max + 1 , nzext_max call integrate_zed ( nz_max , dz , 1. / gp ( - nz_max : iz ), zarc ( iz )) zarc ( iz ) = zarc ( - nz_max ) + zarc ( iz ) end do end subroutine get_arc_length_grid ! trapezoidal rule to integrate in zed subroutine integrate_zed ( nz , dz , f , intf ) implicit none integer , intent ( in ) :: nz real , intent ( in ) :: dz real , dimension ( - nz :), intent ( in ) :: f real , intent ( out ) :: intf integer :: iz , iz_max iz_max = - nz + size ( f ) - 1 intf = 0. do iz = - nz + 1 , iz_max intf = intf + dz * ( f ( iz - 1 ) + f ( iz )) end do intf = 0.5 * intf end subroutine integrate_zed end module zgrid","tags":"","loc":"sourcefile/zgrid.f90.html"},{"title":"read_wout_mod.F – stella","text":"Source Code MODULE read_wout_mod ! !     USE READ_WOUT_MOD to include variables dynamically allocated !     in this module !     Call DEALLOCATE_READ_WOUT to free this memory when it is no longer needed ! !     Reads in output from VMEC equilibrium code(s), contained in wout file ! !     Contained subroutines: ! !     read_wout_file      wrapper alias called to read/open wout file !     read_wout_text      called by read_wout_file to read text file wout !     read_wout_nc        called by read_wout_file to read netcdf file wout ! !     Post-processing routines ! !     mse_pitch           user-callable function to compute mse pitch angle !                         for the computed equilibrium ! USE stel_kinds USE vsvd0 , ONLY : nigroup , nparts , npfcoil , nbcoilsp , nfloops , 1 nbctotp , nbsetsp USE ezcdf_inqvar USE ezcdf_GenGet IMPLICIT NONE #if defined(NETCDF) C----------------------------------------------- C   L O C A L   P A R A M E T E R S C----------------------------------------------- ! Variables naturally occuring here CHARACTER ( LEN =* ), PARAMETER :: 1 vn_version = 'version_' , 2 vn_extension = 'input_extension' , vn_mgrid = 'mgrid_file' , 3 vn_magen = 'wb' , vn_therm = 'wp' , vn_gam = 'gamma' , 4 vn_maxr = 'rmax_surf' , vn_minr = 'rmin_surf' , 5 vn_maxz = 'zmax_surf' , vn_fp = 'nfp' , 6 vn_radnod = 'ns' , vn_polmod = 'mpol' , vn_tormod = 'ntor' , 7 vn_maxmod = 'mnmax' , vn_maxit = 'niter' , vn_actit = 'itfsq' , 8 vn_asym = 'lasym' , vn_recon = 'lrecon' , vn_free = 'lfreeb' , 9 vn_error = 'ier_flag' , vn_aspect = 'aspect' , vn_rfp = 'lrfp' , A vn_maxmod_nyq = 'mnmax_nyq' , B vn_beta = 'betatotal' , vn_pbeta = 'betapol' , C vn_tbeta = 'betator' , vn_abeta = 'betaxis' , D vn_b0 = 'b0' , vn_rbt0 = 'rbtor0' , vn_rbt1 = 'rbtor' , E vn_sgs = 'signgs' , vn_lar = 'IonLarmor' , vn_modB = 'volavgB' , F vn_ctor = 'ctor' , vn_amin = 'Aminor_p' , vn_Rmaj = 'Rmajor_p' , G vn_vol = 'volume_p' , vn_am = 'am' , vn_ai = 'ai' , vn_ac = 'ac' , G vn_ah = 'hot particle fraction' , vn_atuname = 'T-perp/T-par' , H vn_pmass_type = 'pmass_type' , vn_piota_type = 'piota_type' , I vn_pcurr_type = 'pcurr_type' , J vn_am_aux_s = 'am_aux_s' , vn_am_aux_f = 'am_aux_f' , K vn_ai_aux_s = 'ai_aux_s' , vn_ai_aux_f = 'ai_aux_f' , L vn_ac_aux_s = 'ac_aux_s' , vn_ac_aux_f = 'ac_aux_f' , M vn_mse = 'imse' , vn_thom = 'itse' , N vn_pmod = 'xm' , vn_tmod = 'xn' , vn_pmod_nyq = 'xm_nyq' , O vn_tmod_nyq = 'xn_nyq' , P vn_racc = 'raxis_cc' , vn_zacs = 'zaxis_cs' , Q vn_racs = 'raxis_cs' , vn_zacc = 'zaxis_cc' , vn_iotaf = 'iotaf' , Q vn_qfact = 'q-factor' , vn_chi = 'chi' , vn_chipf = 'chipf' , R vn_presf = 'presf' , vn_phi = 'phi' , vn_phipf = 'phipf' , S vn_jcuru = 'jcuru' , vn_jcurv = 'jcurv' , vn_iotah = 'iotas' , T vn_mass = 'mass' , vn_presh = 'pres' , vn_betah = 'beta_vol' , U vn_buco = 'buco' , vn_bvco = 'bvco' , vn_vp = 'vp' , V vn_specw = 'specw' , vn_phip = 'phips' , vn_jdotb = 'jdotb' , W vn_overr = 'over_r' , X vn_bgrv = 'bdotgradv' , vn_merc = 'DMerc' , vn_mshear = 'DShear' , Y vn_mwell = 'DWell' , vn_mcurr = 'DCurr' , vn_mgeo = 'DGeod' , Z vn_equif = 'equif' , vn_fsq = 'fsqt' , vn_wdot = 'wdot' , 1 vn_ftolv = 'ftolv' , vn_fsql = 'fsql' , vn_fsqr = 'fsqr' , 2 vn_fsqz = 'fsqz' , 3 vn_extcur = 'extcur' , vn_curlab = 'curlabel' , vn_rmnc = 'rmnc' , 4 vn_zmns = 'zmns' , vn_lmns = 'lmns' , vn_gmnc = 'gmnc' , 5 vn_bmnc = 'bmnc' , vn_bsubumnc = 'bsubumnc' , 6 vn_bsubvmnc = 'bsubvmnc' , vn_bsubsmns = 'bsubsmns' , 7 vn_bsupumnc = 'bsupumnc' , vn_bsupvmnc = 'bsupvmnc' , 8 vn_rmns = 'rmns' , vn_zmnc = 'zmnc' , 9 vn_lmnc = 'lmnc' , vn_gmns = 'gmns' , vn_bmns = 'bmns' , A vn_bsubumns = 'bsubumns' , vn_bsubvmns = 'bsubvmns' , B vn_bsubsmnc = 'bsubsmnc' , vn_bsupumns = 'bsupumns' , C vn_bsupvmns = 'bsupvmns' , D vn_rbc = 'rbc' , vn_zbs = 'zbs' , vn_rbs = 'rbs' , vn_zbc = 'zbc' , E vn_potvac = 'potvac' , !    FOR ANIMEC F vn_wpar = 'wpar' , vn_pparmnc = 'pparmnc' , vn_ppermnc = 'ppermnc' , G vn_hotdmnc = 'hotdmnc' , vn_pbprmnc = 'pbprmnc' , H vn_ppprmnc = 'ppprmnc' , vn_sigmnc = 'sigmnc' , I vn_taumnc = 'taumnc' , J vn_pparmns = 'pparmns' , vn_ppermns = 'ppermns' , K vn_hotdmns = 'hotdmns' , vn_pbprmns = 'pbprmns' , L vn_ppprmns = 'ppprmns' , vn_sigmns = 'sigmns' , M vn_taumns = 'taumns' , !    FOR FLOW N vn_machsq = 'machsq' , O vn_protmnc = 'protmnc' , vn_protrsqmnc = 'protrsqmnc' , P vn_prprmnc = 'prprmnc' , Q vn_protmns = 'protmns' , vn_protrsqmns = 'protrsqmns' , R vn_prprmns = 'prprmns' , S vn_pmap = 'pmap' , vn_omega = 'omega' , vn_tpotb = 'tpotb' ! Long names (ln_...) CHARACTER ( LEN =* ), PARAMETER :: 1 ln_version = 'VMEC Version' , 2 ln_extension = 'Input file extension' , 3 ln_mgrid = 'MGRID file' , 4 ln_magen = 'Magnetic Energy' , ln_therm = 'Thermal Energy' , 5 ln_gam = 'Gamma' , ln_maxr = 'Maximum R' , ln_minr = 'Minimum R' , 6 ln_maxz = 'Maximum Z' , ln_fp = 'Field Periods' , 7 ln_radnod = 'Radial nodes' , ln_polmod = 'Poloidal modes' , 8 ln_tormod = 'Toroidal modes' , ln_maxmod = 'Fourier modes' , 8 ln_maxmod_nyq = 'Fourier modes (Nyquist)' , 9 ln_maxit = 'Max iterations' , ln_actit = 'Actual iterations' , 1 ln_asym = 'Asymmetry' , ln_recon = 'Reconstruction' , 1 ln_free = 'Free boundary' , 2 ln_error = 'Error flag' , ln_aspect = 'Aspect ratio' , 3 ln_beta = 'Total beta' , ln_pbeta = 'Poloidal beta' , 4 ln_tbeta = 'Toroidal beta' , ln_abeta = 'Beta axis' , 5 ln_b0 = 'RB-t over R axis' , ln_rbt0 = 'RB-t axis' , 6 ln_rbt1 = 'RB-t edge' , ln_sgs = 'Sign jacobian' , 7 ln_lar = 'Ion Larmor radius' , ln_modB = 'avg mod B' , 8 ln_ctor = 'Toroidal current' , ln_amin = 'minor radius' , 9 ln_Rmaj = 'major radius' , ln_vol = 'Plasma volume' , 1 ln_mse = 'Number of MSE points' , 1 ln_thom = 'Number of Thompson scattering points' , 1 ln_am = 'Specification parameters for mass(s)' , 1 ln_ac = 'Specification parameters for <J>(s)' , 1 ln_ai = 'Specification parameters for iota(s)' , 1 ln_pmass_type = 'Profile type specifier for mass(s)' , 1 ln_pcurr_type = 'Profile type specifier for <J>(s)' , 1 ln_piota_type = 'Profile type specifier for iota(s)' , 1 ln_am_aux_s = 'Auxiliary-s parameters for mass(s)' , 1 ln_am_aux_f = 'Auxiliary-f parameters for mass(s)' , 1 ln_ac_aux_s = 'Auxiliary-s parameters for <J>(s)' , 1 ln_ac_aux_f = 'Auxiliary-f parameters for <J>(s)' , 1 ln_ai_aux_s = 'Auxiliary-s parameters for iota(s)' , 1 ln_ai_aux_f = 'Auxiliary-f parameters for iota(s)' , 4 ln_pmod = 'Poloidal mode numbers' , 5 ln_tmod = 'Toroidal mode numbers' , 4 ln_pmod_nyq = 'Poloidal mode numbers (Nyquist)' , 5 ln_tmod_nyq = 'Toroidal mode numbers (Nyquist)' , 5 ln_racc = 'raxis (cosnv)' , ln_racs = 'raxis (sinnv)' , 6 ln_zacs = 'zaxis (sinnv)' , ln_zacc = 'zaxis (cosnv)' , 7 ln_iotaf = 'iota on full mesh' , 7 ln_qfact = 'q-factor on full mesh' , 8 ln_presf = 'pressure on full mesh' , 8 ln_phi = 'Toroidal flux on full mesh' , 9 ln_phipf = 'd(phi)/ds: Toroidal flux deriv on full mesh' , 9 ln_chi = 'Poloidal flux on full mesh' , 9 ln_chipf = 'd(chi)/ds: Poroidal flux deriv on full mesh' , 9 ln_jcuru = 'j dot gradu full' , 1 ln_jcurv = 'j dot gradv full' , ln_iotah = 'iota half' , 2 ln_mass = 'mass half' , ln_presh = 'pressure half' , 3 ln_betah = 'beta half' , ln_buco = 'bsubu half' , 4 ln_bvco = 'bsubv half' , ln_vp = 'volume deriv half' , 5 ln_specw = 'Spectral width half' , 6 ln_phip = 'tor flux deriv over 2pi half' , 7 ln_jdotb = 'J dot B' , ln_bgrv = 'B dot grad v' , 8 ln_merc = 'Mercier criterion' , ln_mshear = 'Shear Mercier' , 9 ln_mwell = 'Well Mercier' , ln_mcurr = 'Current Mercier' , 1 ln_mgeo = 'Geodesic Mercier' , ln_equif = 'Average force balance' , 1 ln_fsq = 'Residual decay' , 2 ln_wdot = 'Wdot decay' , ln_extcur = 'External coil currents' , 2 ln_fsqr = 'Residual decay - radial' , 2 ln_fsqz = 'Residual decay - vertical' , 2 ln_fsql = 'Residual decay - hoop' , 2 ln_ftolv = 'Residual decay - requested' , 3 ln_curlab = 'External current names' , 3 ln_rmnc = 'cosmn component of cylindrical R, full mesh' , 4 ln_zmns = 'sinmn component of cylindrical Z, full mesh' , 4 ln_lmns = 'sinmn component of lambda, half mesh' , 5 ln_gmnc = 'cosmn component of jacobian, half mesh' , 6 ln_bmnc = 'cosmn component of mod-B, half mesh' , 6 ln_bsubumnc = 'cosmn covariant u-component of B, half mesh' , 6 ln_bsubvmnc = 'cosmn covariant v-component of B, half mesh' , 7 ln_bsubsmns = 'sinmn covariant s-component of B, full mesh' , 7 ln_bsupumnc = 'BSUPUmnc half' , 8 ln_bsupvmnc = 'BSUPVmnc half' , 3 ln_rmns = 'sinmn component of cylindrical R, full mesh' , 4 ln_zmnc = 'cosmn component of cylindrical Z, full mesh' , 4 ln_lmnc = 'cosmn component of lambda, half mesh' , 5 ln_gmns = 'sinmn component of jacobian, half mesh' , 6 ln_bmns = 'sinmn component of mod-B, half mesh' , 6 ln_bsubumns = 'sinmn covariant u-component of B, half mesh' , 6 ln_bsubvmns = 'sinmn covariant v-component of B, half mesh' , 7 ln_bsubsmnc = 'cosmn covariant s-component of B, full mesh' , 4 ln_bsupumns = 'BSUPUmns half' , ln_bsupvmns = 'BSUPVmns half' , 6 ln_rbc = 'Initial boundary R cos(mu-nv) coefficients' , 7 ln_zbs = 'Initial boundary Z sin(mu-nv) coefficients' , 8 ln_rbs = 'Initial boundary R sin(mu-nv) coefficients' , 9 ln_zbc = 'Initial boundary Z cos(mu-nv) coefficients' , 1 ln_potvac = 'Vacuum Potential on Boundary' , !    FOR ANIMEC F ln_wpar = 'Energy' , G ln_pparmnc = 'cosmn compoents of hot part. para. pressure' , H ln_ppermnc = 'cosmn compoents of hot part. perp. pressure' , I ln_hotdmnc = 'cosmn compoents of hot part. density' , J ln_pbprmnc = 'cosmn compoents of hot part. para. pres. grad.' , K ln_ppprmnc = 'cosmn compoents of hot part. perp. pres. grad.' , L ln_sigmnc = 'cosmn firehose stability variable' , M ln_taumnc = 'cosmn mirror stability variable' , N ln_pparmns = 'sinmn compoents of hot part. para. pressure' , O ln_ppermns = 'sinmn compoents of hot part. perp. pressure' , P ln_hotdmns = 'sinmn compoents of hot part. density' , Q ln_pbprmns = 'sinmn compoents of hot part. para. pres. grad.' , R ln_ppprmns = 'sinmn compoents of hot part. perp. pres. grad.' , S ln_sigmns = 'sinmn firehose stability variable' , T ln_taumns = 'sinmn mirror stability variable' , !    FOR FLOW U ln_machsq = 'Mach # on axis (squared)' , V ln_protmnc = 'cosmn components of pressure' , W ln_protrsqmnc = 'cosmn component of rotational energy' , X ln_prprmnc = 'cosmn components of radial pressure gradient' , Y ln_protmns = 'sinmn components of pressure' , Z ln_protrsqmns = 'sinmn component of rotational energy' , 1 ln_prprmns = 'sinmn components of radial pressure gradient' , 2 ln_pmap = '<p(s,R)>' , ln_omega = 'Toroidal Angular Freq.' , 3 ln_tpotb = 'T_perp/T_parallel or T(flow)' #endif !----------------------------------------------- !   L o c a l   V a r i a b l e s !----------------------------------------------- ! Variable names (vn_...) : put eventually into library, used by read_wout too... INTEGER , PARAMETER :: fatal_error = 666 ! Variables with types previously defined in mgrid_mod LOGICAL :: lnverror = . true . INTEGER , PARAMETER :: nlimset = 2 !number of different limiters CHARACTER ( LEN =* ), PARAMETER :: 1 vn_br0 = 'br' , vn_bp0 = 'bp' , vn_bz0 = 'bz' , 3 vn_ir = 'ir' , vn_jz = 'jz' , 4 vn_kp = 'kp' , vn_nfp = 'nfp' , 5 vn_rmin = 'rmin' , vn_rmax = 'rmax' , vn_zmin = 'zmin' , 6 vn_zmax = 'zmax' , vn_coilgrp = 'coil_group' CHARACTER ( LEN =* ), PARAMETER :: 1 vn_nextcur = 'nextcur' , vn_mgmode = 'mgrid_mode' , 2 vn_coilcur = 'raw_coil_cur' , 3 vn_flp = 'nobser' , vn_nobd = 'nobd' , vn_nbset = 'nbsets' , 4 vn_nbfld = 'nbfld' , 2 ln_flp = 'flux loops' , ln_nobd = 'Connected flux loops' , 3 ln_nbset = 'B-coil loops' , ln_next = 'External currents' , 4 ln_nbfld = 'B-coil measurements' INTEGER :: nr0b , np0b , nfper0 , nz0b INTEGER :: nobd , nobser , nextcur , nbfldn , nbsets , nbcoilsn INTEGER :: nbvac , nbcoil_max , nlim , nlim_max , nsets , 1 nrgrid , nzgrid INTEGER , DIMENSION (:), ALLOCATABLE :: needflx , nbcoils INTEGER , DIMENSION (:), ALLOCATABLE :: limitr , nsetsn INTEGER , DIMENSION (:,:), ALLOCATABLE :: iconnect , needbfld REAL ( rprec ) :: rminb , zminb , rmaxb , zmaxb , delrb , delzb REAL ( rprec ) :: rx1 , rx2 , zy1 , zy2 , condif REAL ( rprec ), DIMENSION (:,:), ALLOCATABLE , TARGET :: bvac REAL ( rprec ), DIMENSION (:,:,:), POINTER :: brvac , bzvac , bpvac REAL ( rprec ), DIMENSION (:,:), ALLOCATABLE :: unpsiext , 1 plbfld , rbcoil , zbcoil , abcoil , bcoil , rbcoilsqr REAL ( rprec ), DIMENSION (:), ALLOCATABLE :: raw_coil_current REAL ( rprec ), DIMENSION (:), ALLOCATABLE :: xobser , zobser , 1 xobsqr , dsiext , psiext , plflux , b_chi CHARACTER ( LEN = 300 ) :: mgrid_path CHARACTER ( LEN = 300 ) :: mgrid_path_old = \" \" CHARACTER ( LEN = 30 ), DIMENSION (:), ALLOCATABLE :: curlabel CHARACTER ( LEN = 15 ), DIMENSION (:), ALLOCATABLE :: 1 dsilabel , bloopnames CHARACTER ( LEN = 30 ) :: tokid REAL ( rprec ), DIMENSION (:,:,:), ALLOCATABLE :: dbcoil , pfcspec REAL ( rprec ), DIMENSION (:,:), ALLOCATABLE :: 1 rlim , zlim , reslim , seplim CHARACTER ( LEN = 1 ) :: mgrid_mode ! Variables previously declared in vmec_input.f90 INTEGER , DIMENSION ( nbsetsp ) :: nbfld LOGICAL :: lpofr , lmac , lfreeb , lrecon , loldout , ledge_dump , 1 lforbal , lmovie , lmove_axis , 2 lwouttxt , ldiagno , ! J.Geiger: for txt- and diagno-output 3 lmoreiter , ! J.Geiger: if force residuals are not fulfilled add more iterations. 4 lfull3d1out , ! J.Geiger: to force full 3D1-output 5 l_v3fit = . false ., 6 lspectrum_dump , loptim !!Obsolete LOGICAL :: lgiveup ! inserted M.Drevlak REAL ( rprec ) :: fgiveup ! inserted M.Drevlak, giveup-factor for ftolv LOGICAL :: lbsubs ! J Hanson See jxbforce coding ! Variables that naturally occur here INTEGER :: nfp , ns , mpol , ntor , mnmax , mnmax_nyq , itfsq , niter , 1 iasym , ireconstruct , ierr_vmec , imse , itse , nstore_seq , 2 isnodes , ipnodes , imatch_phiedge , isigng , mnyq , nnyq , ntmax , 3 vmec_type REAL ( rprec ) :: wb , wp , gamma , pfac , rmax_surf , rmin_surf , 1 zmax_surf , aspect , betatot , betapol , betator , betaxis , b0 , 2 tswgt , msewgt , flmwgt , bcwgt , phidiam , version_ , 3 delphid , IonLarmor , VolAvgB , 3 fsql , fsqr , fsqz , ftolv , 4 Aminor , Rmajor , Volume , RBtor , RBtor0 , Itor , 5 machsq !SAL REAL ( rprec ), ALLOCATABLE :: rzl_local (:,:,:,:) REAL ( rprec ), DIMENSION (:,:), ALLOCATABLE :: 1 rmnc , zmns , lmns , rmns , zmnc , lmnc , bmnc , gmnc , bsubumnc , 2 bsubvmnc , bsubsmns , bsupumnc , bsupvmnc , currvmnc , 3 currumnc , bbc , raxis , zaxis REAL ( rprec ), DIMENSION (:,:), ALLOCATABLE :: 1 bmns , gmns , bsubumns , bsubvmns , bsubsmnc , 2 bsupumns , bsupvmns , currumns , currvmns REAL ( rprec ), DIMENSION (:,:), ALLOCATABLE :: 1 pparmnc , ppermnc , hotdmnc , pbprmnc , ppprmnc , sigmnc , taumnc , ! SAL - ANIMEC 2 pparmns , ppermns , hotdmns , pbprmns , ppprmns , sigmns , taumns , ! SAL - ANIMEC 3 protmnc , protrsqmnc , prprmnc , ! SAL - FLOW 4 protmns , protrsqmns , prprmns ! SAL - FLOW REAL ( rprec ), DIMENSION (:), ALLOCATABLE :: 1 iotas , iotaf , presf , phipf , mass , pres , beta_vol , xm , xn , 1 qfact , chipf , phi , chi , 2 xm_nyq , xn_nyq , phip , buco , bvco , vp , overr , jcuru , jcurv , 3 specw , jdotb , bdotgradv , fsqt , wdot , am , ac , ai , 3 am_aux_s , am_aux_f , ac_aux_s , ac_aux_f , ai_aux_s , ai_aux_f , 3 Dmerc , Dshear , Dwell , Dcurr , Dgeod , equif , extcur , 4 sknots , ystark , y2stark , pknots , ythom , y2thom , 5 anglemse , rmid , qmid , shear , presmid , alfa , curmid , rstark , 6 qmeas , datastark , rthom , datathom , dsiobt , potvac REAL ( rprec ), DIMENSION (:), ALLOCATABLE :: 1 pmap , omega , tpotb ! SAL -FLOW LOGICAL :: lasym , lthreed , lwout_opened = . false ., lrfp = . false . CHARACTER :: mgrid_file * 200 , input_extension * 100 CHARACTER :: pmass_type * 20 , pcurr_type * 20 , piota_type * 20 INTEGER , PARAMETER :: norm_term_flag = 0 , 1 bad_jacobian_flag = 1 , more_iter_flag = 2 , jac75_flag = 4 !     OVERLOAD SUBROUTINE READ_WOUT_FILE TO ACCEPT BOTH UNIT NO. (OPENED EXTERNALLY) !     OR FILENAME (HANDLE OPEN/CLOSE HERE) INTERFACE read_wout_file MODULE PROCEDURE readw_and_open , readw_only END INTERFACE #if defined(NETCDF) PRIVATE :: read_wout_text , read_wout_nc #else PRIVATE :: read_wout_text #endif PRIVATE :: norm_term_flag , bad_jacobian_flag , 1 more_iter_flag , jac75_flag CONTAINS SUBROUTINE readw_and_open ( file_or_extension , ierr , iopen ) USE safe_open_mod IMPLICIT NONE C----------------------------------------------- C   D u m m y   A r g u m e n t s C----------------------------------------------- INTEGER , INTENT ( out ) :: ierr INTEGER , OPTIONAL :: iopen CHARACTER ( LEN =* ), INTENT ( in ) :: file_or_extension C----------------------------------------------- C   L o c a l   V a r i a b l e s C----------------------------------------------- INTEGER , PARAMETER :: iunit_init = 10 INTEGER :: iunit LOGICAL :: isnc CHARACTER ( len = LEN_TRIM ( file_or_extension ) + 10 ) :: filename C----------------------------------------------- ! !     THIS SUBROUTINE READS THE WOUT FILE CREATED BY THE VMEC CODE !     AND STORES THE DATA IN THE READ_WOUT MODULE ! !     FIRST, CHECK IF THIS IS A FULLY-QUALIFIED PATH NAME !     MAKE SURE wout IS NOT EMBEDDED IN THE NAME (PERVERSE USER...) ! filename = 'wout' CALL parse_extension ( filename , file_or_extension , isnc ) CALL flush ( 6 ) !SPH  IF (.not.isnc) STOP 'ISNC ERR IN READ_WOUT_MOD' IF ( isnc ) THEN #if defined(NETCDF) CALL read_wout_nc ( filename , ierr ) IF ( ierr . eq . fatal_error ) THEN RETURN END IF #else PRINT * , \"NETCDF wout file can not be opened on this platform\" ierr = - 100 #endif ELSE iunit = iunit_init CALL safe_open ( iunit , ierr , filename , 'old' , 'formatted' ) IF ( ierr . eq . 0 ) CALL read_wout_text ( iunit , ierr ) IF ( ierr . eq . fatal_error ) THEN RETURN END IF CLOSE ( unit = iunit ) END IF IF ( PRESENT ( iopen )) iopen = ierr lwout_opened = ( ierr . eq . 0 ) ! WHEN READING A NETCDF FILE, A BAD RUN MAY PREVENT XN FROM BEING ! READ, SUBSEQUENTLY WE MUST CHECK TO SEE IF XN HAS BEEN ALLOCATED ! BEFORE DOING ANYTHING WITH IT OTHERWISE WE DEFAULT LTHREED TO ! FALSE.  - SAL 09/07/11 IF ( ALLOCATED ( XN )) THEN lthreed = ANY ( NINT ( xn ) . ne . 0 ) ELSE lthreed = . FALSE . END IF END SUBROUTINE readw_and_open SUBROUTINE readw_only ( iunit , ierr , iopen ) IMPLICIT NONE C----------------------------------------------- C   D u m m y   A r g u m e n t s C----------------------------------------------- INTEGER , INTENT ( in ) :: iunit INTEGER , INTENT ( out ) :: ierr INTEGER , OPTIONAL :: iopen C----------------------------------------------- C   L o c a l   V a r i a b l e s C----------------------------------------------- INTEGER :: istat CHARACTER ( LEN = 256 ) :: vmec_version LOGICAL :: exfile C----------------------------------------------- ! !     User opened the file externally and has a unit number, iunit ! ierr = 0 INQUIRE ( unit = iunit , exist = exfile , name = vmec_version , iostat = istat ) IF ( istat . ne . 0 . or . . not . exfile ) THEN PRINT * , ' In READ_WOUT_FILE, Unit = ' , iunit , 1 ' File = ' , TRIM ( vmec_version ), ' DOES NOT EXIST' IF ( PRESENT ( iopen )) iopen = - 1 ierr = - 1 RETURN ELSE IF ( PRESENT ( iopen )) iopen = 0 END IF CALL read_wout_text ( iunit , ierr ) IF ( ierr . eq . fatal_error ) THEN RETURN END IF lwout_opened = ( ierr . eq . 0 ) lthreed = ANY ( NINT ( xn ) . ne . 0 ) END SUBROUTINE readw_only SUBROUTINE read_wout_text ( iunit , ierr ) USE stel_constants , ONLY : mu0 IMPLICIT NONE C----------------------------------------------- C   D u m m y   A r g u m e n t s C----------------------------------------------- INTEGER :: iunit , ierr C----------------------------------------------- C   L o c a l   P a r a m e t e r s C----------------------------------------------- REAL ( rprec ), PARAMETER :: eps_w = 1.e-4_dp C----------------------------------------------- C   L o c a l   V a r i a b l e s C----------------------------------------------- INTEGER :: istat ( 15 ), i , j , k , js , m , n , n1 , mn , nparts_in , 1 i_animec , i_flow CHARACTER ( LEN = 256 ) :: vmec_version LOGICAL :: lcurr C----------------------------------------------- ! !     THIS SUBROUTINE READS THE TEXT FILE WOUT CREATED BY THE VMEC CODE !     AND STORES THE INFORMATION IN THE read_WOUT MODULE ! !     CALL read_wout_file - GENERIC INTERFACE - CAN BE CALLED WITH EITHER UNIT NO. OR FILENAME ! !     RMNC, ZMNS: FULL-GRID !     LMNS      : HALF-GRID ! istat = 0 ierr = 0 nextcur = 0 READ ( iunit , '(a)' , iostat = istat ( 2 ), err = 1000 ) vmec_version i = INDEX ( vmec_version , '=' ) !!!! ADDED BY SAL i_animec = INDEX ( vmec_version , '_ANIMEC' ) i_flow = INDEX ( vmec_version , '_FLOW' ) vmec_type = 0 IF ( i_animec > 0 ) THEN vmec_type = 1 ! ANIMEC vmec_version = vmec_version ( 1 : i_animec - 1 ) END IF IF ( i_flow > 0 ) THEN vmec_type = 2 ! FLOW vmec_version = vmec_version ( 1 : i_flow - 1 ) END IF !!!! END SAL Addition IF ( i . ge . 0 ) THEN READ ( vmec_version ( i + 1 : len_trim ( vmec_version )), * ) version_ ELSE version_ = - 1.0 END IF ierr_vmec = norm_term_flag IF ( version_ . le . ( 5.10 + eps_w )) THEN READ ( iunit , * , iostat = istat ( 2 ), err = 1000 ) wb , wp , gamma , 1 pfac , nfp , ns , 1 mpol , ntor , mnmax , itfsq , niter , iasym , ireconstruct ELSE IF ( version_ . lt . 6.54 ) THEN READ ( iunit , * , iostat = istat ( 2 ), err = 1000 ) wb , wp , gamma , 1 pfac , rmax_surf , rmin_surf ELSE READ ( iunit , * , iostat = istat ( 2 ), err = 1000 ) wb , wp , gamma , 1 pfac , rmax_surf , rmin_surf , zmax_surf END IF IF ( vmec_type == 2 ) THEN !SAL READ ( iunit , * , iostat = istat ( 2 ), err = 1000 ) machsq END IF IF ( version_ . le . ( 8.0 + eps_w )) THEN READ ( iunit , * , iostat = istat ( 2 ), err = 1000 ) nfp , ns , mpol , 1 ntor , mnmax , itfsq , niter , iasym , ireconstruct , ierr_vmec mnmax_nyq = mnmax ELSE READ ( iunit , * , iostat = istat ( 2 ), err = 1000 ) nfp , ns , mpol , 1 ntor , mnmax , mnmax_nyq , itfsq , niter , iasym , ireconstruct , 2 ierr_vmec END IF END IF lasym = ( iasym . gt . 0 ) IF ( version_ . gt . ( 6.20 + eps_w )) THEN READ ( iunit , * , iostat = istat ( 1 ), err = 1000 ) imse , itse , nbsets , 1 nobd , nextcur , nstore_seq ELSE READ ( iunit , * , iostat = istat ( 1 ), err = 1000 ) imse , itse , nbsets , 1 nobd , nextcur nstore_seq = 100 END IF IF ( ierr_vmec . ne . norm_term_flag . and . ierr_vmec . ne . more_iter_flag ) 1 GOTO 1000 IF ( nextcur . gt . nigroup ) istat ( 15 ) = - 1 IF ( ALLOCATED ( xm )) CALL read_wout_deallocate ( ierr ) IF ( ierr . ne . 0 ) THEN ierr = fatal_error RETURN END IF ALLOCATE ( xm ( mnmax ), xn ( mnmax ), xm_nyq ( mnmax_nyq ), 1 xn_nyq ( mnmax_nyq ), rmnc ( mnmax , ns ), zmns ( mnmax , ns ), 2 lmns ( mnmax , ns ), bmnc ( mnmax_nyq , ns ), gmnc ( mnmax_nyq , ns ), 3 bsubumnc ( mnmax_nyq , ns ), bsubvmnc ( mnmax_nyq , ns ), 4 bsubsmns ( mnmax_nyq , ns ), bsupumnc ( mnmax_nyq , ns ), 5 bsupvmnc ( mnmax_nyq , ns ), currvmnc ( mnmax_nyq , ns ), 5 iotas ( ns ), mass ( ns ), pres ( ns ), beta_vol ( ns ), phip ( ns ), 6 buco ( ns ), bvco ( ns ), phi ( ns ), iotaf ( ns ), presf ( ns ), phipf ( ns ), 5 vp ( ns ), overr ( ns ), jcuru ( ns ), jcurv ( ns ), specw ( ns ), Dmerc ( ns ), 6 Dshear ( ns ), Dwell ( ns ), Dcurr ( ns ), Dgeod ( ns ), equif ( ns ), 7 extcur ( nextcur ), curlabel ( nextcur ), raxis ( 0 : ntor , 2 ), 8 zaxis ( 0 : ntor , 2 ), jdotb ( ns ), bdotgradv ( ns ), 8 am ( 0 : 20 ), ac ( 0 : 20 ), ai ( 0 : 20 ), 9 fsqt ( nstore_seq ), wdot ( nstore_seq ), stat = istat ( 6 )) IF ( lasym ) 1 ALLOCATE ( rmns ( mnmax , ns ), zmnc ( mnmax , ns ), lmnc ( mnmax , ns ), 2 bmns ( mnmax_nyq , ns ), gmns ( mnmax_nyq , ns ), 3 bsubumns ( mnmax_nyq , ns ), 3 bsubvmns ( mnmax_nyq , ns ), bsubsmnc ( mnmax_nyq , ns ), 4 bsupumns ( mnmax_nyq , ns ), bsupvmns ( mnmax_nyq , ns ), 5 stat = istat ( 6 )) IF ( vmec_type == 1 ) THEN ! SAL ALLOCATE ( pparmnc ( mnmax_nyq , ns ), ppermnc ( mnmax_nyq , ns ), 1 hotdmnc ( mnmax_nyq , ns ), pbprmnc ( mnmax_nyq , ns ), 2 ppprmnc ( mnmax_nyq , ns ), sigmnc ( mnmax_nyq , ns ), 3 taumnc ( mnmax_nyq , ns ), stat = istat ( 6 )) IF ( lasym ) 1 ALLOCATE ( pparmns ( mnmax_nyq , ns ), ppermns ( mnmax_nyq , ns ), 2 hotdmns ( mnmax_nyq , ns ), pbprmns ( mnmax_nyq , ns ), 3 ppprmns ( mnmax_nyq , ns ), sigmns ( mnmax_nyq , ns ), 4 taumns ( mnmax_nyq , ns ), stat = istat ( 6 )) ELSE IF ( vmec_type == 2 ) THEN ALLOCATE ( pmap ( ns ), omega ( ns ), tpotb ( ns ), stat = istat ( 6 )) ALLOCATE ( protmnc ( mnmax_nyq , ns ), protrsqmnc ( mnmax_nyq , ns ), 1 prprmnc ( mnmax_nyq , ns ), stat = istat ( 6 )) IF ( lasym ) 1 ALLOCATE ( protmns ( mnmax_nyq , ns ), protrsqmns ( mnmax_nyq , ns ), 2 prprmns ( mnmax_nyq , ns ), stat = istat ( 6 )) END IF fsqt = 0 ; wdot = 0 ; raxis = 0 ; zaxis = 0 IF ( nbsets . gt . 0 ) READ ( iunit , * , iostat = istat ( 4 ), err = 1000 ) 1 ( nbfld ( i ), i = 1 , nbsets ) READ ( iunit , '(a)' , iostat = istat ( 5 ), err = 1000 ) mgrid_file DO js = 1 , ns DO mn = 1 , mnmax IF ( js . eq . 1 ) THEN READ ( iunit , * , iostat = istat ( 7 ), err = 1000 ) m , n xm ( mn ) = REAL ( m , rprec ) xn ( mn ) = REAL ( n , rprec ) END IF IF ( version_ . le . ( 6.20 + eps_w )) THEN READ ( iunit , 730 , iostat = istat ( 8 ), err = 1000 ) 1 rmnc ( mn , js ), zmns ( mn , js ), lmns ( mn , js ), 2 bmnc ( mn , js ), gmnc ( mn , js ), bsubumnc ( mn , js ), 3 bsubvmnc ( mn , js ), bsubsmns ( mn , js ), 4 bsupumnc ( mn , js ), bsupvmnc ( mn , js ), 5 currvmnc ( mn , js ) ELSE IF ( version_ . le . ( 8.0 + eps_w )) THEN READ ( iunit , * , iostat = istat ( 8 ), err = 1000 ) 1 rmnc ( mn , js ), zmns ( mn , js ), lmns ( mn , js ), 2 bmnc ( mn , js ), gmnc ( mn , js ), bsubumnc ( mn , js ), 3 bsubvmnc ( mn , js ), bsubsmns ( mn , js ), 4 bsupumnc ( mn , js ), bsupvmnc ( mn , js ), 5 currvmnc ( mn , js ) ELSE READ ( iunit , * , iostat = istat ( 8 ), err = 1000 ) 1 rmnc ( mn , js ), zmns ( mn , js ), lmns ( mn , js ) END IF IF ( lasym ) THEN IF ( version_ . le . ( 8.0 + eps_w )) THEN READ ( iunit , * , iostat = istat ( 8 ), err = 1000 ) 1 rmns ( mn , js ), zmnc ( mn , js ), lmnc ( mn , js ), 2 bmns ( mn , js ), gmns ( mn , js ), bsubumns ( mn , js ), 3 bsubvmns ( mn , js ), bsubsmnc ( mn , js ), 4 bsupumns ( mn , js ), bsupvmns ( mn , js ) ELSE READ ( iunit , * , iostat = istat ( 8 ), err = 1000 ) 1 rmns ( mn , js ), zmnc ( mn , js ), lmnc ( mn , js ) END IF END IF IF ( js . eq . 1 . and . m . eq . 0 ) THEN n1 = ABS ( n / nfp ) IF ( n1 . le . ntor ) THEN raxis ( n1 , 1 ) = rmnc ( mn , 1 ) zaxis ( n1 , 1 ) = zmns ( mn , 1 ) IF ( lasym ) THEN raxis ( n1 , 2 ) = rmns ( mn , 1 ) zaxis ( n1 , 2 ) = zmnc ( mn , 1 ) END IF END IF END IF END DO IF ( version_ . le . ( 8.0 + eps_w )) CYCLE DO mn = 1 , mnmax_nyq IF ( js . eq . 1 ) THEN READ ( iunit , * , iostat = istat ( 7 ), err = 1000 ) m , n xm_nyq ( mn ) = REAL ( m , rprec ) xn_nyq ( mn ) = REAL ( n , rprec ) END IF IF ( vmec_type == 1 ) THEN !SAL (ELSE statement below is orriginal) READ ( iunit , * , iostat = istat ( 8 ), err = 1000 ) 1 bmnc ( mn , js ), gmnc ( mn , js ), bsubumnc ( mn , js ), 2 bsubvmnc ( mn , js ), bsubsmns ( mn , js ), 3 bsupumnc ( mn , js ), bsupvmnc ( mn , js ), 3 pparmnc ( mn , js ), ppermnc ( mn , js ), hotdmnc ( mn , js ), 4 pbprmnc ( mn , js ), ppprmnc ( mn , js ), sigmnc ( mn , js ), 5 taumnc ( mn , js ) IF ( lasym ) THEN READ ( iunit , * , iostat = istat ( 8 ), err = 1000 ) 1 bmns ( mn , js ), gmns ( mn , js ), bsubumns ( mn , js ), 2 bsubvmns ( mn , js ), bsubsmnc ( mn , js ), 3 bsupumns ( mn , js ), bsupvmns ( mn , js ), 3 pparmns ( mn , js ), ppermns ( mn , js ), hotdmns ( mn , js ), 4 pbprmns ( mn , js ), ppprmns ( mn , js ), sigmns ( mn , js ), 5 taumns ( mn , js ) END IF ELSE IF ( vmec_type == 2 ) THEN READ ( iunit , * , iostat = istat ( 8 ), err = 1000 ) 1 bmnc ( mn , js ), gmnc ( mn , js ), bsubumnc ( mn , js ), 2 bsubvmnc ( mn , js ), bsubsmns ( mn , js ), 3 bsupumnc ( mn , js ), bsupvmnc ( mn , js ), 4 protmnc ( mn , js ), protrsqmnc ( mn , js ), prprmnc ( mn , js ) IF ( lasym ) THEN READ ( iunit , * , iostat = istat ( 8 ), err = 1000 ) 1 bmns ( mn , js ), gmns ( mn , js ), bsubumns ( mn , js ), 2 bsubvmns ( mn , js ), bsubsmnc ( mn , js ), 3 bsupumns ( mn , js ), bsupvmns ( mn , js ), 4 protmns ( mn , js ), protrsqmns ( mn , js ), prprmns ( mn , js ) END IF ELSE READ ( iunit , * , iostat = istat ( 8 ), err = 1000 ) 1 bmnc ( mn , js ), gmnc ( mn , js ), bsubumnc ( mn , js ), 2 bsubvmnc ( mn , js ), bsubsmns ( mn , js ), 3 bsupumnc ( mn , js ), bsupvmnc ( mn , js ) IF ( lasym ) THEN READ ( iunit , * , iostat = istat ( 8 ), err = 1000 ) 2 bmns ( mn , js ), gmns ( mn , js ), bsubumns ( mn , js ), 3 bsubvmns ( mn , js ), bsubsmnc ( mn , js ), 4 bsupumns ( mn , js ), bsupvmns ( mn , js ) END IF END IF END DO END DO !     Compute current coefficients on full mesh IF ( version_ . gt . ( 8.0 + eps_w )) CALL Compute_Currents ( ierr ) mnyq = INT ( MAXVAL ( xm_nyq )); nnyq = INT ( MAXVAL ( ABS ( xn_nyq ))) / nfp ! !     Read FULL AND HALF-MESH QUANTITIES ! !     NOTE: In version_ <= 6.00, mass, press were written out in INTERNAL (VMEC) units !     and are therefore multiplied here by 1/mu0 to transform to pascals. Same is true !     for ALL the currents (jcuru, jcurv, jdotb). Also, in version_ = 6.10 and !     above, PHI is the true (physical) toroidal flux (has the sign of jacobian correctly !     built into it) ! iotas ( 1 ) = 0 ; mass ( 1 ) = 0 ; pres ( 1 ) = 0 ; phip ( 1 ) = 0 ; buco ( 1 ) = 0 ; bvco ( 1 ) = 0 ; vp ( 1 ) = 0 ; overr ( 1 ) = 0 ; specw ( 1 ) = 1 beta_vol ( 1 ) = 0 IF ( version_ . le . ( 6.05 + eps_w )) THEN READ ( iunit , 730 , iostat = istat ( 9 ), err = 1000 ) 1 ( iotas ( js ), mass ( js ), pres ( js ), 2 phip ( js ), buco ( js ), bvco ( js ), phi ( js ), vp ( js ), overr ( js ), 3 jcuru ( js ), jcurv ( js ), specw ( js ), js = 2 , ns ) READ ( iunit , 730 , iostat = istat ( 10 ), err = 1000 ) 1 aspect , betatot , betapol , betator , betaxis , b0 ELSE IF ( version_ . le . ( 6.20 + eps_w )) THEN READ ( iunit , 730 , iostat = istat ( 9 ), err = 1000 ) 1 ( iotas ( js ), mass ( js ), pres ( js ), beta_vol ( js ), 2 phip ( js ), buco ( js ), bvco ( js ), phi ( js ), vp ( js ), overr ( js ), 3 jcuru ( js ), jcurv ( js ), specw ( js ), js = 2 , ns ) READ ( iunit , 730 , iostat = istat ( 10 ), err = 1000 ) 1 aspect , betatot , betapol , betator , betaxis , b0 ELSE IF ( version_ . le . ( 6.95 + eps_w )) THEN READ ( iunit , * , iostat = istat ( 9 ), err = 1000 ) 1 ( iotas ( js ), mass ( js ), pres ( js ), beta_vol ( js ), 2 phip ( js ), buco ( js ), bvco ( js ), phi ( js ), vp ( js ), overr ( js ), 3 jcuru ( js ), jcurv ( js ), specw ( js ), js = 2 , ns ) READ ( iunit , * , iostat = istat ( 10 ), err = 1000 ) 1 aspect , betatot , betapol , betator , betaxis , b0 ELSE READ ( iunit , * , iostat = istat ( 9 ), err = 1000 ) 1 ( iotaf ( js ), presf ( js ), phipf ( js ), phi ( js ), 2 jcuru ( js ), jcurv ( js ), js = 1 , ns ) IF ( vmec_type == 2 ) THEN READ ( iunit , * , iostat = istat ( 9 ), err = 1000 ) 1 ( iotas ( js ), mass ( js ), 1 pmap ( js ), omega ( js ), tpotb ( js ), pres ( js ), 2 beta_vol ( js ), phip ( js ), buco ( js ), bvco ( js ), vp ( js ), 3 overr ( js ), specw ( js ), js = 2 , ns ) ELSE READ ( iunit , * , iostat = istat ( 9 ), err = 1000 ) 1 ( iotas ( js ), mass ( js ), pres ( js ), 2 beta_vol ( js ), phip ( js ), buco ( js ), bvco ( js ), vp ( js ), 3 overr ( js ), specw ( js ), js = 2 , ns ) END IF READ ( iunit , * , iostat = istat ( 10 ), err = 1000 ) 1 aspect , betatot , betapol , betator , betaxis , b0 END IF IF ( version_ . gt . ( 6.10 + eps_w )) THEN READ ( iunit , * , iostat = istat ( 10 ), err = 1000 ) isigng READ ( iunit , * , iostat = istat ( 10 ), err = 1000 ) input_extension READ ( iunit , * , iostat = istat ( 10 ), err = 1000 ) IonLarmor , 1 VolAvgB , RBtor0 , RBtor , Itor , Aminor , Rmajor , Volume END IF !----------------------------------------------- !     MERCIER CRITERION !----------------------------------------------- IF ( version_ . gt .( 5.10 + eps_w ) . and . version_ . lt .( 6.20 - eps_w )) THEN READ ( iunit , 730 , iostat = istat ( 11 ), err = 1000 ) 1 ( Dmerc ( js ), Dshear ( js ), Dwell ( js ), Dcurr ( js ), 2 Dgeod ( js ), equif ( js ), js = 2 , ns - 1 ) ELSE IF ( version_ . ge . ( 6.20 - eps_w )) THEN READ ( iunit , * , iostat = istat ( 11 ), err = 1000 ) 1 ( Dmerc ( js ), Dshear ( js ), Dwell ( js ), Dcurr ( js ), 2 Dgeod ( js ), equif ( js ), js = 2 , ns - 1 ) END IF IF ( nextcur . gt . 0 ) THEN IF ( version_ . le . ( 6.20 + eps_w )) THEN READ ( iunit , 730 , iostat = istat ( 12 ), err = 1000 ) 1 ( extcur ( i ), i = 1 , nextcur ) ELSE READ ( iunit , * , iostat = istat ( 12 ), err = 1000 ) 1 ( extcur ( i ), i = 1 , nextcur ) END IF !SAL 11/30/11 - To make DIAGNO v2 work with old files. IF (( version_ . ge . ( 6.90 - eps_w )) . and . 1 ( version_ . le . ( 6.90 + eps_w ))) THEN lcurr = . true . ELSE READ ( iunit , * , iostat = istat ( 13 )) lcurr END IF !READ (iunit, *, iostat=istat(13)) lcurr IF ( lcurr ) READ ( iunit , * , iostat = istat ( 13 ), err = 1000 ) 1 ( curlabel ( i ), i = 1 , nextcur ) END IF IF ( version_ . le . ( 6.20 + eps_w )) THEN READ ( iunit , 730 , iostat = istat ( 14 )) 1 ( fsqt ( i ), wdot ( i ), i = 1 , nstore_seq ) ELSE READ ( iunit , * , iostat = istat ( 14 )) 1 ( fsqt ( i ), wdot ( i ), i = 1 , nstore_seq ) END IF IF (( version_ . ge . 6.20 - eps_w ) . and . ( version_ . lt . ( 6.50 - eps_w )) 1 . and . ( istat ( 14 ). eq . 0 )) THEN READ ( iunit , 730 , iostat = istat ( 14 ), err = 1000 ) 1 ( jdotb ( js ), bdotgradv ( js ), js = 1 , ns ) ELSE IF ( version_ . ge . ( 6.50 - eps_w )) THEN READ ( iunit , * , iostat = istat ( 14 ), err = 1000 ) 1 ( jdotb ( js ), bdotgradv ( js ), js = 1 , ns ) ELSE istat ( 14 ) = 0 END IF ! !     CONVERT FROM INTERNAL UNITS TO PHYSICAL UNITS IF NEEDED ! IF ( version_ . le . ( 6.05 + eps_w )) THEN mass = mass / mu0 pres = pres / mu0 jcuru = jcuru / mu0 jcurv = jcurv / mu0 jdotb = jdotb / mu0 phi = - phi END IF !----------------------------------------------- !     DATA AND MSE FITS !----------------------------------------------- IF ( ireconstruct . gt . 0 ) THEN n1 = MAXVAL ( nbfld (: nbsets )) ALLOCATE ( sknots ( isnodes ), ystark ( isnodes ), y2stark ( isnodes ), 1 pknots ( ipnodes ), ythom ( ipnodes ), y2thom ( ipnodes ), 2 anglemse ( 2 * ns ), rmid ( 2 * ns ), qmid ( 2 * ns ), shear ( 2 * ns ), 3 presmid ( 2 * ns ), alfa ( 2 * ns ), curmid ( 2 * ns ), rstark ( imse ), 4 datastark ( imse ), rthom ( itse ), datathom ( itse ), 5 dsiext ( nobd ), plflux ( nobd ), dsiobt ( nobd ), bcoil ( n1 , nbsets ), 6 plbfld ( n1 , nbsets ), bbc ( n1 , nbsets )) IF ( imse . ge . 2 . or . itse . gt . 0 ) THEN READ ( iunit , * ) tswgt , msewgt READ ( iunit , * ) isnodes , ( sknots ( i ), ystark ( i ), y2stark ( i ), 1 i = 1 , isnodes ) READ ( iunit , * ) ipnodes , ( pknots ( i ), ythom ( i ), 1 y2thom ( i ), i = 1 , ipnodes ) READ ( iunit , * )( anglemse ( i ), rmid ( i ), qmid ( i ), shear ( i ), 1 presmid ( i ), alfa ( i ), curmid ( i ), i = 1 , 2 * ns - 1 ) READ ( iunit , * )( rstark ( i ), datastark ( i ), qmeas ( i ), i = 1 , imse ) READ ( iunit , * )( rthom ( i ), datathom ( i ), i = 1 , itse ) END IF IF ( nobd . gt . 0 ) THEN READ ( iunit , * ) ( dsiext ( i ), plflux ( i ), dsiobt ( i ), i = 1 , nobd ) READ ( iunit , * ) flmwgt END IF nbfldn = SUM ( nbfld (: nbsets )) IF ( nbfldn . gt . 0 ) THEN DO n = 1 , nbsets READ ( iunit , * ) ( bcoil ( i , n ), plbfld ( i , n ), bbc ( i , n ), 1 i = 1 , nbfld ( n )) END DO READ ( iunit , * ) bcwgt END IF READ ( iunit , * ) phidiam , delphid ! !     READ Limiter & Prout plotting specs ! READ ( iunit , * ) nsets , nparts_in , nlim ALLOCATE ( nsetsn ( nsets )) READ ( iunit , * ) ( nsetsn ( i ), i = 1 , nsets ) n1 = MAXVAL ( nsetsn (: nsets )) ALLOCATE ( pfcspec ( nparts_in , n1 , nsets ), limitr ( nlim )) READ ( iunit , * ) ((( pfcspec ( i , j , k ), i = 1 , nparts_in ), 1 j = 1 , nsetsn ( k )), k = 1 , nsets ) READ ( iunit , * ) ( limitr ( i ), i = 1 , nlim ) m = MAXVAL ( limitr (: nlim )) ALLOCATE ( rlim ( m , nlim ), zlim ( m , nlim )) READ ( iunit , * ) (( rlim ( i , j ), zlim ( i , j ), i = 1 , limitr ( j )), 1 j = 1 , nlim ) READ ( iunit , * ) nrgrid , nzgrid READ ( iunit , * ) tokid READ ( iunit , * ) rx1 , rx2 , zy1 , zy2 , condif READ ( iunit , * ) imatch_phiedge END IF 1000 CONTINUE READ ( iunit , iostat = ierr ) mgrid_mode IF ( ierr . ne . 0 ) THEN ierr = 0 ; mgrid_mode = 'N' END IF IF ( istat ( 2 ) . ne . 0 ) ierr_vmec = 1 DO m = 1 , 15 IF ( istat ( m ) . gt . 0 ) THEN PRINT * , ' Error No. ' , m , ' in READ_WOUT, iostat = ' , istat ( m ) ierr = m EXIT END IF END DO 720 FORMAT ( 8 i10 ) 730 FORMAT ( 5e20 . 13 ) 740 FORMAT ( a ) 790 FORMAT ( i5 , / ,( 1 p , 3e12 . 4 )) END SUBROUTINE read_wout_text #if defined(NETCDF) SUBROUTINE read_wout_nc ( filename , ierr ) USE ezcdf USE stel_constants , ONLY : mu0 IMPLICIT NONE C----------------------------------------------- C   D u m m y   A r g u m e n t s C----------------------------------------------- INTEGER , INTENT ( out ) :: ierr CHARACTER ( LEN =* ), INTENT ( in ) :: filename C----------------------------------------------- C   L o c a l   V a r i a b l e s C----------------------------------------------- INTEGER :: nwout , ierror , i_animec , i_flow INTEGER , DIMENSION ( 3 ) :: dimlens REAL ( rprec ) :: ohs REAL ( rprec ), DIMENSION (:), ALLOCATABLE :: raxis_cc , raxis_cs , 1 zaxis_cs , zaxis_cc C----------------------------------------------- ! Open cdf File CALL cdf_open ( nwout , filename , 'r' , ierr ) IF ( ierr . ne . 0 ) THEN PRINT * , ' Error opening wout .nc file' RETURN END IF ! Be sure all arrays are deallocated CALL read_wout_deallocate ( ierr ) IF ( ierr . ne . 0 ) THEN ierr = fatal_error PRINT * , ' Error deallocating wout .nc file' RETURN END IF ! ANIMEC/FLOW -SAL i_animec = 0 i_flow = 0 vmec_type = 0 CALL cdf_inquire ( nwout , vn_pparmnc , dimlens , ier = ierror ) IF ( ierror . eq . 0 ) vmec_type = 1 CALL cdf_inquire ( nwout , vn_omega , dimlens , ier = ierror ) IF ( ierror . eq . 0 ) vmec_type = 2 ! Read in scalar variables CALL cdf_read ( nwout , vn_error , ierr_vmec ) ! Next 2 lines commented out by MJL 20150717. They were being triggered by a W7X file. !      IF (ierr_vmec.ne.norm_term_flag .and. ierr_vmec.ne.more_iter_flag) !     1   GOTO 1000 CALL cdf_read ( nwout , vn_version , version_ ) CALL cdf_read ( nwout , vn_extension , input_extension ) CALL cdf_read ( nwout , vn_mgrid , mgrid_file ) CALL cdf_read ( nwout , vn_magen , wb ) CALL cdf_read ( nwout , vn_therm , wp ) CALL cdf_read ( nwout , vn_gam , gamma ) CALL cdf_read ( nwout , vn_maxr , rmax_surf ) CALL cdf_read ( nwout , vn_minr , rmin_surf ) CALL cdf_read ( nwout , vn_maxz , zmax_surf ) CALL cdf_read ( nwout , vn_fp , nfp ) CALL cdf_read ( nwout , vn_radnod , ns ) CALL cdf_read ( nwout , vn_polmod , mpol ) CALL cdf_read ( nwout , vn_tormod , ntor ) CALL cdf_read ( nwout , vn_maxmod , mnmax ) mnmax_nyq = - 1 CALL cdf_read ( nwout , vn_maxmod_nyq , mnmax_nyq ) CALL cdf_read ( nwout , vn_maxit , niter ) CALL cdf_read ( nwout , vn_actit , itfsq ) CALL cdf_read ( nwout , vn_asym , lasym ) IF ( lasym ) iasym = 1 CALL cdf_read ( nwout , vn_recon , lrecon ) IF ( lrecon ) ireconstruct = 1 CALL cdf_read ( nwout , vn_free , lfreeb ) CALL cdf_read ( nwout , vn_rfp , lrfp ) CALL cdf_read ( nwout , vn_aspect , aspect ) CALL cdf_read ( nwout , vn_beta , betatot ) CALL cdf_read ( nwout , vn_pbeta , betapol ) CALL cdf_read ( nwout , vn_tbeta , betator ) CALL cdf_read ( nwout , vn_abeta , betaxis ) CALL cdf_read ( nwout , vn_b0 , b0 ) CALL cdf_read ( nwout , vn_rbt0 , rbtor0 ) CALL cdf_read ( nwout , vn_rbt1 , rbtor ) CALL cdf_read ( nwout , vn_sgs , isigng ) CALL cdf_read ( nwout , vn_lar , IonLarmor ) CALL cdf_read ( nwout , vn_modB , volAvgB ) CALL cdf_read ( nwout , vn_ctor , Itor ) CALL cdf_read ( nwout , vn_amin , Aminor ) CALL cdf_read ( nwout , vn_rmaj , Rmajor ) CALL cdf_read ( nwout , vn_vol , volume ) CALL cdf_read ( nwout , vn_ftolv , ftolv ) CALL cdf_read ( nwout , vn_fsqr , fsqr ) CALL cdf_read ( nwout , vn_fsqz , fsqz ) CALL cdf_read ( nwout , vn_fsql , fsql ) CALL cdf_read ( nwout , vn_pcurr_type , pcurr_type ) CALL cdf_read ( nwout , vn_piota_type , piota_type ) CALL cdf_read ( nwout , vn_pmass_type , pmass_type ) imse = - 1 IF ( lrecon ) THEN CALL cdf_read ( nwout , vn_mse , imse ) CALL cdf_read ( nwout , vn_thom , itse ) END IF CALL cdf_read ( nwout , vn_nextcur , nextcur ) mgrid_mode = 'N' CALL cdf_inquire ( nwout , vn_mgmode , dimlens , ier = ierror ) IF ( ierror . eq . 0 ) CALL cdf_read ( nwout , vn_mgmode , mgrid_mode ) IF ( lfreeb ) THEN CALL cdf_read ( nwout , vn_flp , nobser ) CALL cdf_read ( nwout , vn_nobd , nobd ) CALL cdf_read ( nwout , vn_nbset , nbsets ) END IF ! ANIMEC/FLOW -SAL CALL cdf_inquire ( nwout , vn_machsq , dimlens , ier = ierror ) IF ( ierror . eq . 0 ) CALL cdf_read ( nwout , vn_machsq , machsq ) CALL cdf_inquire ( nwout , vn_wpar , dimlens , ier = ierror ) IF ( ierror . eq . 0 ) CALL cdf_read ( nwout , vn_wpar , wp ) ! This overwrites wp with wpar ! Inquire existence, dimensions of arrays for allocation ! 1D Arrays IF ( lfreeb . and . nbsets . gt . 0 ) THEN CALL cdf_read ( nwout , vn_nbfld , nbfld ) END IF CALL cdf_inquire ( nwout , vn_pmod , dimlens ) ALLOCATE ( xm ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_tmod , dimlens ) ALLOCATE ( xn ( dimlens ( 1 )), stat = ierror ) IF ( mnmax_nyq . gt . 0 ) THEN CALL cdf_inquire ( nwout , vn_pmod_nyq , dimlens ) ALLOCATE ( xm_nyq ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_tmod_nyq , dimlens ) ALLOCATE ( xn_nyq ( dimlens ( 1 )), stat = ierror ) END IF CALL cdf_inquire ( nwout , vn_racc , dimlens ) ALLOCATE ( raxis_cc ( 0 : dimlens ( 1 ) - 1 ), stat = ierror ) CALL cdf_inquire ( nwout , vn_zacs , dimlens ) ALLOCATE ( zaxis_cs ( 0 : dimlens ( 1 ) - 1 ), stat = ierror ) IF ( lasym ) THEN CALL cdf_inquire ( nwout , vn_racs , dimlens ) ALLOCATE ( raxis_cs ( 0 : dimlens ( 1 ) - 1 ), stat = ierror ) CALL cdf_inquire ( nwout , vn_zacc , dimlens ) ALLOCATE ( zaxis_cc ( 0 : dimlens ( 1 ) - 1 ), stat = ierror ) END IF !  Profile coefficients, dimensioned from 0 CALL cdf_inquire ( nwout , vn_am , dimlens ) ALLOCATE ( am ( 0 : dimlens ( 1 ) - 1 ), stat = ierror ) CALL cdf_inquire ( nwout , vn_ac , dimlens ) ALLOCATE ( ac ( 0 : dimlens ( 1 ) - 1 ), stat = ierror ) CALL cdf_inquire ( nwout , vn_ai , dimlens ) ALLOCATE ( ai ( 0 : dimlens ( 1 ) - 1 ), stat = ierror ) CALL cdf_inquire ( nwout , vn_ac_aux_s , dimlens ) ALLOCATE ( ac_aux_s ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_ac_aux_f , dimlens ) ALLOCATE ( ac_aux_f ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_ai_aux_s , dimlens ) ALLOCATE ( ai_aux_s ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_ai_aux_f , dimlens ) ALLOCATE ( ai_aux_f ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_am_aux_s , dimlens ) ALLOCATE ( am_aux_s ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_am_aux_f , dimlens ) ALLOCATE ( am_aux_f ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_iotaf , dimlens ) ALLOCATE ( iotaf ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_qfact , dimlens ) ALLOCATE ( qfact ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_presf , dimlens ) ALLOCATE ( presf ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_phi , dimlens ) ALLOCATE ( phi ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_chi , dimlens ) ALLOCATE ( chi ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_phipf , dimlens ) ALLOCATE ( phipf ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_chipf , dimlens ) ALLOCATE ( chipf ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_jcuru , dimlens ) ALLOCATE ( jcuru ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_jcurv , dimlens ) ALLOCATE ( jcurv ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_iotah , dimlens ) ALLOCATE ( iotas ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_mass , dimlens ) ALLOCATE ( mass ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_presh , dimlens ) ALLOCATE ( pres ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_betah , dimlens ) ALLOCATE ( beta_vol ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_buco , dimlens ) ALLOCATE ( buco ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_bvco , dimlens ) ALLOCATE ( bvco ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_vp , dimlens ) ALLOCATE ( vp ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_specw , dimlens ) ALLOCATE ( specw ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_phip , dimlens ) ALLOCATE ( phip ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_overr , dimlens ) ALLOCATE ( overr ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_jdotb , dimlens ) ALLOCATE ( jdotb ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_bgrv , dimlens ) ALLOCATE ( bdotgradv ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_merc , dimlens ) ALLOCATE ( Dmerc ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_mshear , dimlens ) ALLOCATE ( Dshear ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_mwell , dimlens ) ALLOCATE ( Dwell ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_mcurr , dimlens ) ALLOCATE ( Dcurr ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_mgeo , dimlens ) ALLOCATE ( Dgeod ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_equif , dimlens ) ALLOCATE ( equif ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_fsq , dimlens ) ALLOCATE ( fsqt ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_wdot , dimlens ) ALLOCATE ( wdot ( dimlens ( 1 )), stat = ierror ) IF ( nextcur . gt . 0 ) THEN CALL cdf_inquire ( nwout , vn_extcur , dimlens ) ALLOCATE ( extcur ( dimlens ( 1 )), stat = ierror ) !NOTE: curlabel is an array of CHARACTER(30) strings - defined in mgrid_mod !      so dimlens(1) == 30 (check this) and dimlens(2) is the number of strings in the array CALL cdf_inquire ( nwout , vn_curlab , dimlens ) ALLOCATE ( curlabel ( dimlens ( 2 )), stat = ierror ) ENDIF ! ANIMEC/FLOW -SAL CALL cdf_inquire ( nwout , vn_pmap , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( pmap ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_omega , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( omega ( dimlens ( 1 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_tpotb , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( tpotb ( dimlens ( 1 )), stat = ierror ) ! 2D Arrays CALL cdf_inquire ( nwout , vn_rmnc , dimlens ) ALLOCATE ( rmnc ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_zmns , dimlens ) ALLOCATE ( zmns ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_lmns , dimlens ) ALLOCATE ( lmns ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_gmnc , dimlens ) ALLOCATE ( gmnc ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_bmnc , dimlens ) ALLOCATE ( bmnc ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_bsubumnc , dimlens ) ALLOCATE ( bsubumnc ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_bsubvmnc , dimlens ) ALLOCATE ( bsubvmnc ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_bsubsmns , dimlens ) ALLOCATE ( bsubsmns ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) !     ELIMINATE THESE EVENTUALLY: DON'T NEED THEM CALL cdf_inquire ( nwout , vn_bsupumnc , dimlens ) ALLOCATE ( bsupumnc ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_bsupvmnc , dimlens ) ALLOCATE ( bsupvmnc ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) ! ANIMEC/FLOW -SAL CALL cdf_inquire ( nwout , vn_pparmnc , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( pparmnc ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) CALL cdf_inquire ( nwout , vn_ppermnc , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( ppermnc ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) CALL cdf_inquire ( nwout , vn_hotdmnc , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( hotdmnc ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) CALL cdf_inquire ( nwout , vn_pbprmnc , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( pbprmnc ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) CALL cdf_inquire ( nwout , vn_ppprmnc , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( ppprmnc ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) CALL cdf_inquire ( nwout , vn_sigmnc , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( sigmnc ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) CALL cdf_inquire ( nwout , vn_taumnc , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( taumnc ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) CALL cdf_inquire ( nwout , vn_protmnc , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( protmnc ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) CALL cdf_inquire ( nwout , vn_protrsqmnc , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( protrsqmnc ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) CALL cdf_inquire ( nwout , vn_prprmnc , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( prprmnc ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) IF (. NOT . lasym ) GO TO 800 CALL cdf_inquire ( nwout , vn_rmns , dimlens ) ALLOCATE ( rmns ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_zmnc , dimlens ) ALLOCATE ( zmnc ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_lmnc , dimlens ) ALLOCATE ( lmnc ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_gmns , dimlens ) ALLOCATE ( gmns ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_bmns , dimlens ) ALLOCATE ( bmns ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_bsubumns , dimlens ) ALLOCATE ( bsubumns ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_bsubvmns , dimlens ) ALLOCATE ( bsubvmns ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_bsubsmnc , dimlens ) ALLOCATE ( bsubsmnc ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) !     ELIMINATE THESE EVENTUALLY: DO NOT NEED THEM CALL cdf_inquire ( nwout , vn_bsupumns , dimlens ) ALLOCATE ( bsupumns ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) CALL cdf_inquire ( nwout , vn_bsupvmns , dimlens ) ALLOCATE ( bsupvmns ( dimlens ( 1 ), dimlens ( 2 )), stat = ierror ) ! ANIMEC/FLOW -SAL CALL cdf_inquire ( nwout , vn_pparmns , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( pparmns ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) CALL cdf_inquire ( nwout , vn_ppermns , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( ppermns ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) CALL cdf_inquire ( nwout , vn_hotdmns , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( hotdmns ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) CALL cdf_inquire ( nwout , vn_pbprmns , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( pbprmns ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) CALL cdf_inquire ( nwout , vn_ppprmns , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( ppprmns ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) CALL cdf_inquire ( nwout , vn_sigmns , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( sigmns ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) CALL cdf_inquire ( nwout , vn_taumns , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( taumns ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) CALL cdf_inquire ( nwout , vn_protmns , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( protmns ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) CALL cdf_inquire ( nwout , vn_protrsqmns , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( protrsqmns ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) CALL cdf_inquire ( nwout , vn_prprmns , dimlens , ier = ierror ) IF ( ierror == 0 ) ALLOCATE ( prprmns ( dimlens ( 1 ), dimlens ( 2 )), 1 stat = ierror ) 800 CONTINUE ! Read Arrays CALL cdf_read ( nwout , vn_pmod , xm ) CALL cdf_read ( nwout , vn_tmod , xn ) IF ( mnmax_nyq . le . 0 ) THEN mnmax_nyq = mnmax ALLOCATE ( xm_nyq ( mnmax_nyq ), xn_nyq ( mnmax_nyq ), stat = ierror ) xm_nyq = xm ; xn_nyq = xn ELSE CALL cdf_read ( nwout , vn_pmod_nyq , xm_nyq ) CALL cdf_read ( nwout , vn_tmod_nyq , xn_nyq ) END IF mnyq = INT ( MAXVAL ( xm_nyq )); nnyq = INT ( MAXVAL ( ABS ( xn_nyq ))) / nfp CALL cdf_read ( nwout , vn_racc , raxis_cc ) CALL cdf_read ( nwout , vn_zacs , zaxis_cs ) IF ( SIZE ( raxis_cc ) . ne . ntor + 1 ) THEN PRINT * , 'WRONG SIZE(raxis_cc) in READ_WOUT_NC' ierr = fatal_error RETURN END IF ALLOCATE ( raxis ( 0 : ntor , 2 ), zaxis ( 0 : ntor , 2 ), stat = ierror ) raxis (:, 1 ) = raxis_cc ( 0 : ntor ); zaxis (:, 1 ) = zaxis_cs ( 0 : ntor ) raxis (:, 2 ) = 0 ; zaxis (:, 2 ) = 0 DEALLOCATE ( raxis_cc , zaxis_cs , stat = ierror ) CALL cdf_read ( nwout , vn_rmnc , rmnc ) CALL cdf_read ( nwout , vn_zmns , zmns ) CALL cdf_read ( nwout , vn_lmns , lmns ) CALL cdf_read ( nwout , vn_gmnc , gmnc ) !Half mesh CALL cdf_read ( nwout , vn_bmnc , bmnc ) !Half mesh CALL cdf_read ( nwout , vn_bsubumnc , bsubumnc ) !Half mesh CALL cdf_read ( nwout , vn_bsubvmnc , bsubvmnc ) !Half mesh CALL cdf_read ( nwout , vn_bsubsmns , bsubsmns ) !Full mesh !     ELIMINATE THESE EVENTUALLY: DON'T NEED THEM (can express in terms of lambdas) CALL cdf_read ( nwout , vn_bsupumnc , bsupumnc ) CALL cdf_read ( nwout , vn_bsupvmnc , bsupvmnc ) IF ( lasym ) THEN CALL cdf_read ( nwout , vn_racs , raxis_cs ) CALL cdf_read ( nwout , vn_zacc , zaxis_cc ) raxis (:, 2 ) = raxis_cs ; zaxis (:, 2 ) = zaxis_cc DEALLOCATE ( raxis_cs , zaxis_cc , stat = ierror ) CALL cdf_read ( nwout , vn_rmns , rmns ) CALL cdf_read ( nwout , vn_zmnc , zmnc ) CALL cdf_read ( nwout , vn_lmnc , lmnc ) CALL cdf_read ( nwout , vn_gmns , gmns ) CALL cdf_read ( nwout , vn_bmns , bmns ) CALL cdf_read ( nwout , vn_bsubumns , bsubumns ) CALL cdf_read ( nwout , vn_bsubvmns , bsubvmns ) CALL cdf_read ( nwout , vn_bsubsmnc , bsubsmnc ) !     ELIMINATE THESE EVENTUALLY: DON'T NEED THEM CALL cdf_read ( nwout , vn_bsupumns , bsupumns ) CALL cdf_read ( nwout , vn_bsupvmns , bsupvmns ) END IF ! ANIMEC/FLOW -SAL IF ( vmec_type == 1 ) THEN CALL cdf_read ( nwout , vn_pparmnc , pparmnc ) CALL cdf_read ( nwout , vn_ppermnc , ppermnc ) CALL cdf_read ( nwout , vn_hotdmnc , hotdmnc ) CALL cdf_read ( nwout , vn_pbprmnc , pbprmnc ) CALL cdf_read ( nwout , vn_ppprmnc , ppprmnc ) CALL cdf_read ( nwout , vn_sigmnc , sigmnc ) CALL cdf_read ( nwout , vn_taumnc , taumnc ) IF ( lasym ) THEN CALL cdf_read ( nwout , vn_pparmns , pparmns ) CALL cdf_read ( nwout , vn_ppermns , ppermns ) CALL cdf_read ( nwout , vn_hotdmns , hotdmns ) CALL cdf_read ( nwout , vn_pbprmns , pbprmns ) CALL cdf_read ( nwout , vn_ppprmns , ppprmns ) CALL cdf_read ( nwout , vn_sigmns , sigmns ) CALL cdf_read ( nwout , vn_taumns , taumns ) END IF ELSE IF ( vmec_type == 2 ) THEN CALL cdf_read ( nwout , vn_protmnc , protmnc ) CALL cdf_read ( nwout , vn_prprmnc , prprmnc ) CALL cdf_read ( nwout , vn_protrsqmnc , protrsqmnc ) IF ( lasym ) THEN CALL cdf_read ( nwout , vn_protmns , protmns ) CALL cdf_read ( nwout , vn_prprmns , prprmns ) CALL cdf_read ( nwout , vn_protrsqmns , protrsqmns ) END IF END IF CALL cdf_read ( nwout , vn_am , am ) CALL cdf_read ( nwout , vn_ac , ac ) CALL cdf_read ( nwout , vn_ai , ai ) CALL cdf_read ( nwout , vn_am_aux_s , am_aux_s ) CALL cdf_read ( nwout , vn_am_aux_f , am_aux_f ) CALL cdf_read ( nwout , vn_ac_aux_s , ac_aux_s ) CALL cdf_read ( nwout , vn_ac_aux_f , ac_aux_f ) CALL cdf_read ( nwout , vn_ai_aux_s , ai_aux_s ) CALL cdf_read ( nwout , vn_ai_aux_f , ai_aux_f ) CALL cdf_read ( nwout , vn_iotaf , iotaf ) CALL cdf_read ( nwout , vn_qfact , qfact ) CALL cdf_read ( nwout , vn_presf , presf ) CALL cdf_read ( nwout , vn_phi , phi ) CALL cdf_read ( nwout , vn_phipf , phipf ) CALL cdf_read ( nwout , vn_chi , chi ) CALL cdf_read ( nwout , vn_chipf , chipf ) CALL cdf_read ( nwout , vn_jcuru , jcuru ) CALL cdf_read ( nwout , vn_jcurv , jcurv ) IF ( vmec_type == 2 ) THEN CALL cdf_read ( nwout , vn_pmap , pmap ) CALL cdf_read ( nwout , vn_omega , omega ) CALL cdf_read ( nwout , vn_tpotb , tpotb ) END IF !     HALF-MESH quantities !     NOTE: jdotb is in units_of_A (1/mu0 incorporated in jxbforce...) !     prior to version 6.00, this was output in internal VMEC units... CALL cdf_read ( nwout , vn_iotah , iotas ) CALL cdf_read ( nwout , vn_mass , mass ) CALL cdf_read ( nwout , vn_presh , pres ) CALL cdf_read ( nwout , vn_betah , beta_vol ) CALL cdf_read ( nwout , vn_buco , buco ) CALL cdf_read ( nwout , vn_bvco , bvco ) CALL cdf_read ( nwout , vn_vp , vp ) CALL cdf_read ( nwout , vn_specw , specw ) CALL cdf_read ( nwout , vn_phip , phip ) CALL cdf_read ( nwout , vn_jdotb , jdotb ) CALL cdf_read ( nwout , vn_bgrv , bdotgradv ) !     MERCIER_CRITERION CALL cdf_read ( nwout , vn_merc , Dmerc ) CALL cdf_read ( nwout , vn_mshear , Dshear ) CALL cdf_read ( nwout , vn_mwell , Dwell ) CALL cdf_read ( nwout , vn_mcurr , Dcurr ) CALL cdf_read ( nwout , vn_mgeo , Dgeod ) CALL cdf_read ( nwout , vn_equif , equif ) CALL cdf_read ( nwout , vn_fsq , fsqt ) CALL cdf_read ( nwout , vn_wdot , wdot ) IF ( nextcur . gt . 0 ) THEN CALL cdf_read ( nwout , vn_extcur , extcur ) CALL cdf_read ( nwout , vn_curlab , curlabel ) ENDIF 1000 CONTINUE CALL cdf_close ( nwout , ierr ) IF (. not . ALLOCATED ( bsubumnc )) RETURN !Moved this here because ns may not be set. SAL -09/07/11 ! !     COMPUTE CONTRAVARIANT CURRENT COMPONENTS IN AMPS !     ON THE FULL RADIAL MESH, WHERE JACOBIAN = SQRT(G) ! !     CURRU = SQRT(G) * J dot grad(u) !     CURRV = SQRT(G) * J dot grad(v) ! ohs = ( ns - 1 ) IF ( ierror . eq . 0 ) CALL Compute_Currents ( ierror ) IF ( ierr . ne . 0 ) PRINT * , \"in read_wout_nc ierr=\" , ierr IF ( ierror . ne . 0 ) PRINT * , \"in read_wout_nc ierror=\" , ierror END SUBROUTINE read_wout_nc #endif SUBROUTINE write_wout_text ( filename , ierr ) USE vsvd0 , ONLY : nparts USE safe_open_mod USE stel_constants , ONLY : mu0 IMPLICIT NONE !------------------------------------------------ !   D u m m y   A r g u m e n t s !------------------------------------------------ CHARACTER ( len =* ) :: filename INTEGER , INTENT ( out ) :: ierr !------------------------------------------------ !   L o c a l   P a r a m e t e r s !------------------------------------------------ REAL ( rprec ), PARAMETER :: eps_w = 1.e-4_dp !------------------------------------------------ !   L o c a l   V a r i a b l e s !------------------------------------------------ INTEGER :: iounit , js , mn , i , j , k , n , iasymm LOGICAL :: lcurr !------------------------------------------------ ! !     THIS SUBROUTINE WRITES A TEXT FILE WOUT CREATED BY STORED THE INFORMATION !     IN THE read_WOUT MODULE. This routine can only be called if the wout has !     already been read in. iounit = 0 ierr = 0 CALL safe_open ( iounit , ierr , & & 'wout_' // TRIM ( filename ) // '.txt' , & & 'replace' , 'formatted' ) IF ( ierr . ne . 0 ) then PRINT * , 'Error opening text wout file in ' // & & 'write_wout_text of read_wout_mod.' ierr = fatal_error RETURN END IF !  Write version info WRITE ( iounit , '(a15,f5.2)' ) 'VMEC VERSION = ' , version_ !  Check version numbers since values change. IF ( lasym ) THEN iasymm = 1 ELSE iasym = 0 END IF IF ( version_ . le . ( 5.10 + eps_w )) THEN WRITE ( iounit , * ) wb , wp , gamma , pfac , nfp , ns , mpol , ntor , & & mnmax , itfsq , niter , iasymm , ireconstruct ELSE IF ( version_ . lt . 6.54 ) THEN WRITE ( iounit , * ) wb , wp , gamma , pfac , rmax_surf , rmin_surf ELSE WRITE ( iounit , * ) wb , wp , gamma , pfac , rmax_surf , rmin_surf , & & zmax_surf END IF IF ( version_ . le . ( 8.0 + eps_w )) THEN WRITE ( iounit , * ) nfp , ns , mpol , ntor , mnmax , itfsq , niter , & & iasym , ireconstruct , ierr_vmec ELSE WRITE ( iounit , * ) nfp , ns , mpol , ntor , mnmax , mnmax_nyq , & & itfsq , niter , iasym , ireconstruct , & & ierr_vmec END IF END IF IF ( version_ . gt . ( 6.20 + eps_w )) THEN WRITE ( iounit , * ) imse , itse , nbsets , nobd , nextcur , nstore_seq ELSE WRITE ( iounit , * ) imse , itse , nbsets , nobd , nextcur END IF IF ( ierr_vmec . ne . norm_term_flag . and . & & ierr_vmec . ne . more_iter_flag ) THEN GOTO 1000 END IF IF ( nbsets . gt . 0 ) THEN WRITE ( iounit , * ) nbfld ( 1 : nbsets ) END IF WRITE ( iounit , * ) TRIM ( mgrid_file ) DO js = 1 , ns DO mn = 1 , mnmax IF ( js . eq . 1 ) THEN WRITE ( iounit , * ) NINT ( xm ( mn )), NINT ( xn ( mn ) / nfp ) END IF IF ( version_ . le . ( 6.20 + eps_w )) THEN WRITE ( iounit , 730 ) rmnc ( mn , js ), zmns ( mn , js ), & & lmns ( mn , js ), bmnc ( mn , js ), & & gmnc ( mn , js ), bsubumnc ( mn , js ), & & bsubvmnc ( mn , js ), bsubsmns ( mn , js ), & & bsupumnc ( mn , js ), bsupvmnc ( mn , js ), & & currvmnc ( mn , js ) ELSE IF ( version_ . le . ( 8.0 + eps_w )) THEN WRITE ( iounit , * ) rmnc ( mn , js ), zmns ( mn , js ), lmns ( mn , js ), & & bmnc ( mn , js ), gmnc ( mn , js ), & & bsubumnc ( mn , js ), bsubvmnc ( mn , js ), & & bsubsmns ( mn , js ), bsupumnc ( mn , js ), & & bsupvmnc ( mn , js ), currvmnc ( mn , js ) ELSE WRITE ( iounit , * ) rmnc ( mn , js ), zmns ( mn , js ), lmns ( mn , js ) END IF !  Write asymmetric components. IF ( lasym ) THEN IF ( version_ . le . ( 8.0 + eps_w )) THEN WRITE ( iounit , * ) rmns ( mn , js ), zmnc ( mn , js ), & & lmnc ( mn , js ), bmns ( mn , js ), & & gmns ( mn , js ), bsubumns ( mn , js ), & & bsubvmns ( mn , js ), bsubsmnc ( mn , js ), & & bsupumns ( mn , js ), bsubvmns ( mn , js ) ELSE WRITE ( iounit , * ) rmns ( mn , js ), zmnc ( mn , js ), & & lmnc ( mn , js ) END IF END IF END DO IF ( version_ . le . ( 8.0 + eps_w )) THEN CYCLE END IF DO mn = 1 , mnmax_nyq IF ( js . eq . 1 ) THEN WRITE ( iounit , * ) NINT ( xm_nyq ( mn )), & & NINT ( xn_nyq ( mn ) / nfp ) END IF WRITE ( iounit , * ) bmnc ( mn , js ), gmnc ( mn , js ), & & bsubumnc ( mn , js ), bsubvmnc ( mn , js ), & & bsubsmns ( mn , js ), bsupumnc ( mn , js ), & & bsupvmnc ( mn , js ) IF ( lasym ) THEN WRITE ( iounit , * ) bmns ( mn , js ), gmns ( mn , js ), & & bsubumns ( mn , js ), bsubvmns ( mn , js ), & & bsubsmnc ( mn , js ), bsupumns ( mn , js ), & & bsupvmns ( mn , js ) END IF END DO END DO ! !     Write FULL AND HALF-MESH QUANTITIES ! !     NOTE: In version_ <= 6.00, mass, press were written out in INTERNAL (VMEC) units !     and are therefore multiplied here by 1/mu0 to transform to pascals. Same is true !     for ALL the currents (jcuru, jcurv, jdotb). Also, in version_ = 6.10 and !     above, PHI is the true (physical) toroidal flux (has the sign of jacobian correctly !     built into it) ! IF ( version_ . le . ( 6.05 + eps_w )) THEN WRITE ( iounit , 730 ) ( iotas ( js ), mass ( js ) * mu0 , pres ( js ) * mu0 , & & phip ( js ), buco ( js ), bvco ( js ), - phi ( js ), & & vp ( js ), overr ( js ), jcuru ( js ) * mu0 , & & jcurv ( js ) * mu0 , specw ( js ), js = 2 , ns ) WRITE ( iounit , 730 ) aspect , betatot , betapol , betaxis , b0 ELSE IF ( version_ . le . ( 6.20 + eps_w )) THEN WRITE ( iounit , 730 ) ( iotas ( js ), mass ( js ), pres ( js ), & & beta_vol ( js ), phip ( js ), buco ( js ), & & bvco ( js ), phi ( js ), vp ( js ), overr ( js ), & & jcuru ( js ), jcurv ( js ), specw ( js ), & & js = 2 , ns ) WRITE ( iounit , 730 ) aspect , betatot , betapol , betaxis , b0 ELSE IF ( version_ . le . ( 6.95 + eps_w )) THEN WRITE ( iounit , * ) ( iotas ( js ), mass ( js ), pres ( js ), & & beta_vol ( js ), phip ( js ), buco ( js ), & & bvco ( js ), phi ( js ), vp ( js ), overr ( js ), & & jcuru ( js ), jcurv ( js ), specw ( js ), & & js = 2 , ns ) WRITE ( iounit , * ) aspect , betatot , betapol , betaxis , b0 ELSE WRITE ( iounit , * ) ( iotaf ( js ), presf ( js ), phipf ( js ), phi ( js ), & & jcuru ( js ), jcurv ( js ), js = 1 , ns ) WRITE ( iounit , * ) ( iotas ( js ), mass ( js ), pres ( js ), & & beta_vol ( js ), phip ( js ), buco ( js ), & & bvco ( js ), vp ( js ), overr ( js ), specw ( js ), & & js = 2 , ns ) WRITE ( iounit , * ) aspect , betatot , betapol , betaxis , b0 END IF IF ( version_ . gt . ( 6.10 + eps_w )) THEN WRITE ( iounit , * ) isigng WRITE ( iounit , * ) TRIM ( input_extension ) WRITE ( iounit , * ) IonLarmor , VolAvgB , RBtor0 , RBtor , Itor , & & Aminor , Rmajor , Volume END IF !----------------------------------------------- !     MERCIER CRITERION !----------------------------------------------- IF ( version_ . gt . ( 5.10 + eps_w ) . and . & & version_ . lt . ( 6.20 - eps_w )) THEN WRITE ( iounit , 730 ) ( Dmerc ( js ), Dshear ( js ), Dwell ( js ), & & Dcurr ( js ), Dgeod ( js ), equif ( js ), & & js = 2 , ns - 1 ) ELSE IF ( version_ . ge . ( 6.20 - eps_w )) THEN WRITE ( iounit , * ) ( Dmerc ( js ), Dshear ( js ), Dwell ( js ), & & Dcurr ( js ), Dgeod ( js ), equif ( js ), & & js = 2 , ns - 1 ) END IF IF ( nextcur . gt . 0 ) THEN IF ( version_ . le . ( 6.20 + eps_w )) THEN WRITE ( iounit , 730 ) ( extcur ( js ), js = 1 , nextcur ) ELSE WRITE ( iounit , * ) ( extcur ( js ), js = 1 , nextcur ) END IF lcurr = LEN_TRIM ( curlabel ( 1 )) . gt . 0 WRITE ( iounit , * ) lcurr IF ( lcurr ) THEN WRITE ( iounit , * ) ( TRIM ( curlabel ( js )), js = 1 , nextcur ) END IF END IF IF ( version_ . le . ( 6.20 + eps_w )) THEN WRITE ( iounit , 730 ) ( fsqt ( js ), wdot ( js ), js = 1 , nstore_seq ) ELSE WRITE ( iounit , * ) ( fsqt ( js ), wdot ( js ), js = 1 , nstore_seq ) END IF IF ( version_ . ge . ( 6.20 - eps_w ) . and . & & version_ . lt . ( 6.50 - eps_w )) THEN WRITE ( iounit , 730 ) ( jdotb ( js ), bdotgradv ( js ), js = 1 , ns ) ELSE IF ( version_ . ge . ( 6.50 - eps_w )) THEN WRITE ( iounit , * ) ( jdotb ( js ), bdotgradv ( js ), js = 1 , ns ) END IF !----------------------------------------------- !     DATA AND MSE FITS !----------------------------------------------- IF ( ireconstruct . gt . 0 ) THEN IF ( imse . ge . 2 . or . itse . gt . 0 ) THEN WRITE ( iounit , * ) tswgt , msewgt WRITE ( iounit , * ) isnodes , ( sknots ( js ), ystark ( js ), & & y2stark ( js ), js = 1 , isnodes ) WRITE ( iounit , * ) ipnodes , ( pknots ( js ), ythom ( js ), & & y2thom ( js ), js = 1 , ipnodes ) WRITE ( iounit , * ) ( anglemse ( js ), rmid ( js ), qmid ( js ), & & shear ( js ), presmid ( js ), alfa ( js ), & & curmid ( js ), js = 1 , 2 * ns - 1 ) WRITE ( iounit , * ) ( rstark ( js ), datastark ( js ), qmeas ( js ), & & js = 1 , imse ) WRITE ( iounit , * ) ( rthom ( js ), datathom ( i ), js = 1 , itse ) END IF IF ( nobd . gt . 0 ) THEN WRITE ( iounit , * ) ( dsiext ( js ), plflux ( js ), dsiobt ( js ), & & js = 1 , nobd ) WRITE ( iounit , * ) flmwgt END IF IF ( nbfldn . gt . 0 ) THEN DO n = 1 , nbsets READ ( iounit , * ) ( bcoil ( i , n ), plbfld ( i , n ), bbc ( i , n ), & & i = 1 , nbfld ( n )) END DO WRITE ( iounit , * ) bcwgt END IF WRITE ( iounit , * ) phidiam , delphid ! !     READ Limiter & Prout plotting specs ! WRITE ( iounit , * ) nsets , nparts , nlim WRITE ( iounit , * ) ( nsetsn ( js ), js = 1 , nsets ) WRITE ( iounit , * ) ((( pfcspec ( i , j , k ), i = 1 , nparts ), & & j = 1 , nsetsn ( k )), k = 1 , nsets ) WRITE ( iounit , * ) ( limitr ( i ), i = 1 , nlim ) WRITE ( iounit , * ) (( rlim ( i , j ), zlim ( i , j ), i = 1 , limitr ( j )), & & j = 1 , nlim ) WRITE ( iounit , * ) nrgrid , nzgrid WRITE ( iounit , * ) tokid WRITE ( iounit , * ) rx1 , rx2 , zy1 , zy2 , condif WRITE ( iounit , * ) imatch_phiedge END IF 1000 CONTINUE WRITE ( iounit , * ) mgrid_mode 730 FORMAT ( 5e20 . 13 ) CLOSE ( iounit , iostat = ierr ) IF ( ierr . ne . 0 ) then PRINT * , 'Error closing text wout file in ' // & & 'write_wout_text of read_wout_mod.' ierr = fatal_error RETURN END IF END SUBROUTINE SUBROUTINE Compute_Currents ( ierror ) USE stel_constants , ONLY : mu0 IMPLICIT NONE INTEGER , INTENT ( out ) :: ierror !----------------------------------------------- !   L o c a l   V a r i a b l e s !----------------------------------------------- INTEGER :: js REAL ( rprec ) :: ohs , hs , shalf ( ns ), sfull ( ns ) REAL ( rprec ), DIMENSION ( mnmax_nyq ) :: bu1 , bu0 , bv1 , bv0 , t1 , t2 , & t3 !----------------------------------------------- ! !     Computes current harmonics for currXmn == sqrt(g)*JsupX, X = u,v !     [Corrected above \"JsubX\" to \"JsupX\", JDH 2010-08-16] !     NOTE: bsub(s,u,v)mn are on HALF radial grid !          (in earlier versions, bsubsmn was on FULL radial grid) ! ohs = ( ns - 1 ) hs = 1._dp / ohs DO js = 2 , ns shalf ( js ) = SQRT ( hs * ( js - 1.5_dp )) sfull ( js ) = SQRT ( hs * ( js - 1 )) END DO ALLOCATE ( currumnc ( mnmax_nyq , ns ), currvmnc ( mnmax_nyq , ns ), & & stat = ierror ) IF ( ierror . ne . 0 ) RETURN DO js = 2 , ns - 1 WHERE ( MOD ( INT ( xm_nyq ), 2 ) . EQ . 1 ) t1 = 0.5_dp * ( shalf ( js + 1 ) * bsubsmns (:, js + 1 ) + & & shalf ( js ) * bsubsmns (:, js )) / sfull ( js ) bu0 = bsubumnc (:, js ) / shalf ( js ) bu1 = bsubumnc (:, js + 1 ) / shalf ( js + 1 ) t2 = ohs * ( bu1 - bu0 ) * sfull ( js ) + 0.25_dp * ( bu0 + bu1 ) / sfull ( js ) bv0 = bsubvmnc (:, js ) / shalf ( js ) bv1 = bsubvmnc (:, js + 1 ) / shalf ( js + 1 ) t3 = ohs * ( bv1 - bv0 ) * sfull ( js ) + 0.25_dp * ( bv0 + bv1 ) / sfull ( js ) ELSEWHERE t1 = 0.5_dp * ( bsubsmns (:, js + 1 ) + bsubsmns (:, js )) t2 = ohs * ( bsubumnc (:, js + 1 ) - bsubumnc (:, js )) t3 = ohs * ( bsubvmnc (:, js + 1 ) - bsubvmnc (:, js )) ENDWHERE currumnc (:, js ) = - xn_nyq (:) * t1 - t3 currvmnc (:, js ) = - xm_nyq (:) * t1 + t2 END DO WHERE ( xm_nyq . LE . 1 ) currvmnc (:, 1 ) = 2 * currvmnc (:, 2 ) - currvmnc (:, 3 ) currumnc (:, 1 ) = 2 * currumnc (:, 2 ) - currumnc (:, 3 ) ELSEWHERE currvmnc (:, 1 ) = 0 currumnc (:, 1 ) = 0 ENDWHERE currumnc (:, ns ) = 2 * currumnc (:, ns - 1 ) - currumnc (:, ns - 2 ) currvmnc (:, ns ) = 2 * currvmnc (:, ns - 1 ) - currvmnc (:, ns - 2 ) currumnc = currumnc / mu0 ; currvmnc = currvmnc / mu0 IF (. NOT . lasym ) RETURN ALLOCATE ( currumns ( mnmax_nyq , ns ), currvmns ( mnmax_nyq , ns ), & & stat = ierror ) DO js = 2 , ns - 1 WHERE ( MOD ( INT ( xm_nyq ), 2 ) . EQ . 1 ) t1 = 0.5_dp * ( shalf ( js + 1 ) * bsubsmnc (:, js + 1 ) & & + shalf ( js ) * bsubsmnc (:, js )) / sfull ( js ) bu0 = bsubumns (:, js ) / shalf ( js + 1 ) bu1 = bsubumns (:, js + 1 ) / shalf ( js + 1 ) t2 = ohs * ( bu1 - bu0 ) * sfull ( js ) + 0.25_dp * ( bu0 + bu1 ) / sfull ( js ) bv0 = bsubvmns (:, js ) / shalf ( js ) bv1 = bsubvmns (:, js + 1 ) / shalf ( js + 1 ) t3 = ohs * ( bv1 - bv0 ) * sfull ( js ) + 0.25_dp * ( bv0 + bv1 ) / sfull ( js ) ELSEWHERE t1 = 0.5_dp * ( bsubsmnc (:, js + 1 ) + bsubsmnc (:, js )) t2 = ohs * ( bsubumns (:, js + 1 ) - bsubumns (:, js )) t3 = ohs * ( bsubvmns (:, js + 1 ) - bsubvmns (:, js )) END WHERE currumns (:, js ) = xn_nyq (:) * t1 - t3 currvmns (:, js ) = xm_nyq (:) * t1 + t2 END DO WHERE ( xm_nyq . LE . 1 ) currvmns (:, 1 ) = 2 * currvmns (:, 2 ) - currvmns (:, 3 ) currumns (:, 1 ) = 2 * currumns (:, 2 ) - currumns (:, 3 ) ELSEWHERE currvmns (:, 1 ) = 0 currumns (:, 1 ) = 0 END WHERE currumns (:, ns ) = 2 * currumns (:, ns - 1 ) - currumns (:, ns - 2 ) currvmns (:, ns ) = 2 * currvmns (:, ns - 1 ) - currvmns (:, ns - 2 ) currumns = currumns / mu0 ; currvmns = currvmns / mu0 END SUBROUTINE Compute_Currents SUBROUTINE read_wout_deallocate ( ierr ) IMPLICIT NONE C----------------------------------------------- C   D u m m y   A r g u m e n t s C----------------------------------------------- INTEGER , INTENT ( out ) :: ierr !----------------------------------------------- !   L o c a l   V a r i a b l e s !----------------------------------------------- INTEGER :: istat ( 10 ) !----------------------------------------------- istat = 0 lwout_opened = . false . IF ( ALLOCATED ( extcur )) DEALLOCATE ( extcur , 1 stat = istat ( 1 )) IF ( ALLOCATED ( curlabel )) DEALLOCATE ( curlabel , 1 stat = istat ( 1 )) IF ( ALLOCATED ( overr )) DEALLOCATE ( overr , stat = istat ( 2 )) IF ( ALLOCATED ( xm )) DEALLOCATE ( xm , xn , xm_nyq , xn_nyq , 1 rmnc , zmns , lmns , bmnc , gmnc , bsubumnc , iotaf , presf , phipf , 2 bsubvmnc , bsubsmns , bsupumnc , bsupvmnc , currvmnc , iotas , mass , 3 pres , beta_vol , phip , buco , bvco , phi , vp , jcuru , am , ac , ai , 4 jcurv , specw , Dmerc , Dshear , Dwell , Dcurr , Dgeod , equif , jdotb , 5 bdotgradv , raxis , zaxis , fsqt , wdot , stat = istat ( 3 )) IF ( ALLOCATED ( chipf )) DEALLOCATE ( chipf , chi ) IF ( ALLOCATED ( am_aux_s )) DEALLOCATE ( am_aux_s , am_aux_f , ac_aux_s , 1 ac_aux_f , ai_aux_s , ai_aux_f , stat = istat ( 6 )) IF ( ireconstruct . gt . 0 . and . ALLOCATED ( sknots )) DEALLOCATE ( 1 ystark , y2stark , pknots , anglemse , rmid , qmid , shear , 2 presmid , alfa , curmid , rstark , datastark , rthom , datathom , 3 ythom , y2thom , plflux , dsiobt , bcoil , plbfld , bbc , sknots , 4 pfcspec , limitr , rlim , zlim , nsetsn , stat = istat ( 4 )) IF ( ALLOCATED ( rmns )) DEALLOCATE ( rmns , zmnc , lmnc , 1 bmns , gmns , bsubumns , bsubvmns , bsubsmnc , 2 bsupumns , bsupvmns , stat = istat ( 5 )) IF ( ALLOCATED ( currumnc )) DEALLOCATE ( currumnc ) IF ( ALLOCATED ( currumns )) DEALLOCATE ( currumns , currvmns ) IF ( ALLOCATED ( rzl_local )) DEALLOCATE ( rzl_local ) ! FLOW/ANIMEC additions IF ( ALLOCATED ( pmap )) DEALLOCATE ( pmap , omega , tpotb ) IF ( ALLOCATED ( pparmnc )) DEALLOCATE ( pparmnc , ppermnc , hotdmnc , 1 pbprmnc , ppprmnc , sigmnc , taumnc ) IF ( ALLOCATED ( pparmns )) DEALLOCATE ( pparmns , ppermns , hotdmns , 1 pbprmns , ppprmns , sigmns , taumns ) IF ( ALLOCATED ( protmnc )) DEALLOCATE ( protmnc , protrsqmnc , prprmnc ) IF ( ALLOCATED ( protmns )) DEALLOCATE ( protmns , protrsqmns , prprmns ) IF ( ANY ( istat . ne . 0 )) THEN PRINT * , istat PRINT * , 'Deallocation error in read_wout_deallocate' ierr = fatal_error RETURN END IF END SUBROUTINE read_wout_deallocate END MODULE read_wout_mod","tags":"","loc":"sourcefile/read_wout_mod.f.html"},{"title":"vmec_to_stella_geometry_interface.f90 – stella","text":"Source Code ! vmec_to_stella_geometry_interface.f90 ! Initial code written by Matt Landreman, University of Maryland in August 2017. ! Skip down ~25 lines for detailed description of the input and output parameters. ! Modified 2018-2019 by Michael Barnes module vmec_to_stella_geometry_interface_mod implicit none private public :: vmec_to_stella_geometry_interface public :: get_nominal_vmec_zeta_grid public :: read_vmec_equilibrium public :: desired_zmin real :: theta_pest_target , zeta0 real , dimension ( 2 ) :: vmec_radial_weight_full , vmec_radial_weight_half integer , dimension ( 2 ) :: vmec_radial_index_full , vmec_radial_index_half logical :: lasym integer :: nfp , isigng integer :: ns , mnmax , mnmax_nyq integer :: mpol , ntor real :: Aminor real , dimension (:), allocatable :: xm , xn real , dimension (:), allocatable :: xm_nyq , xn_nyq real , dimension (:, :), allocatable :: rmnc , rmns real , dimension (:, :), allocatable :: lmnc , lmns real , dimension (:, :), allocatable :: zmnc , zmns real , dimension (:, :), allocatable :: bmnc , bmns real , dimension (:, :), allocatable :: gmnc , gmns real , dimension (:, :), allocatable :: bsupumnc , bsupumns real , dimension (:, :), allocatable :: bsupvmnc , bsupvmns real , dimension (:, :), allocatable :: bsubumnc , bsubumns real , dimension (:, :), allocatable :: bsubvmnc , bsubvmns real , dimension (:, :), allocatable :: bsubsmnc , bsubsmns real , dimension (:), allocatable :: phi , phip , iotas , iotaf , presf contains subroutine read_vmec_equilibrium ( vmec_filename , verbose , ierr ) use read_wout_mod , only : read_wout_file , read_wout_deallocate use read_wout_mod , only : nfp_vmec => nfp use read_wout_mod , only : lasym_vmec => lasym use read_wout_mod , only : isigng_vmec => isigng use read_wout_mod , only : Aminor_vmec => Aminor use read_wout_mod , only : ns_vmec => ns use read_wout_mod , only : mnmax_nyq_vmec => mnmax_nyq use read_wout_mod , only : mnmax_vmec => mnmax use read_wout_mod , only : mpol_vmec => mpol use read_wout_mod , only : ntor_vmec => ntor use read_wout_mod , only : xm_vmec => xm use read_wout_mod , only : xn_vmec => xn use read_wout_mod , only : xm_nyq_vmec => xm_nyq use read_wout_mod , only : xn_nyq_vmec => xn_nyq use read_wout_mod , only : phi_vmec => phi use read_wout_mod , only : phip_vmec => phip use read_wout_mod , only : lmnc_vmec => lmnc use read_wout_mod , only : lmns_vmec => lmns use read_wout_mod , only : rmnc_vmec => rmnc use read_wout_mod , only : rmns_vmec => rmns use read_wout_mod , only : zmnc_vmec => zmnc use read_wout_mod , only : zmns_vmec => zmns use read_wout_mod , only : bmnc_vmec => bmnc use read_wout_mod , only : bmns_vmec => bmns use read_wout_mod , only : gmnc_vmec => gmnc use read_wout_mod , only : gmns_vmec => gmns use read_wout_mod , only : bsupumnc_vmec => bsupumnc use read_wout_mod , only : bsupvmnc_vmec => bsupvmnc use read_wout_mod , only : bsupumns_vmec => bsupumns use read_wout_mod , only : bsupvmns_vmec => bsupvmns use read_wout_mod , only : bsubumnc_vmec => bsubumnc use read_wout_mod , only : bsubvmnc_vmec => bsubvmnc use read_wout_mod , only : bsubumns_vmec => bsubumns use read_wout_mod , only : bsubvmns_vmec => bsubvmns use read_wout_mod , only : bsubsmnc_vmec => bsubsmnc use read_wout_mod , only : bsubsmns_vmec => bsubsmns use read_wout_mod , only : iotas_vmec => iotas use read_wout_mod , only : iotaf_vmec => iotaf use read_wout_mod , only : presf_vmec => presf implicit none ! vmec_filename is the vmec wout_* file that will be read. logical , intent ( in ) :: verbose character ( * ), intent ( in ) :: vmec_filename integer , intent ( out ) :: ierr integer :: iopen !********************************************************************* ! Read in everything from the vmec wout file using libstell. !********************************************************************* if ( verbose ) then write ( * , '(A)' ) \"############################################################\" write ( * , '(A)' ) \"                       MAGNETIC FIELD\" write ( * , '(A)' ) \"############################################################\" write ( * , * ) \"About to read VMEC wout file: '\" , trim ( vmec_filename ), \"'.\" end if call read_wout_file ( vmec_filename , ierr , iopen ) if ( iopen /= 0 ) then print * , 'error opening wout file' ierr = iopen return end if if ( ierr /= 0 ) then print * , 'error reading wout file' return end if if ( verbose ) then write ( * , * ) \"Successfully read VMEC data from '\" , trim ( vmec_filename ), \"'.\" end if nfp = nfp_vmec lasym = lasym_vmec isigng = isigng_vmec aminor = aminor_vmec ns = ns_vmec mnmax = mnmax_vmec mnmax_nyq = mnmax_nyq_vmec mpol = mpol_vmec ntor = ntor_vmec if ( verbose ) then write ( * , * ) \" \" write ( * , * ) \"  Characteristics of the magnetic field:\" write ( * , '(A51, I1)' ) \"      Number of field periods of the machine (nfp):\" // REPEAT ( ' ' , 50 ), nfp write ( * , '(A51, L1)' ) \"      Stellarator-asymmetric? (lasym):\" // REPEAT ( ' ' , 50 ), lasym end if if (. not . allocated ( rmnc )) then allocate ( xm ( mnmax )); xm = xm_vmec allocate ( xn ( mnmax )); xn = xn_vmec allocate ( xm_nyq ( mnmax_nyq )); xm_nyq = xm_nyq_vmec allocate ( xn_nyq ( mnmax_nyq )); xn_nyq = xn_nyq_vmec allocate ( rmnc ( mnmax , ns )); rmnc = rmnc_vmec allocate ( lmns ( mnmax , ns )); lmns = lmns_vmec allocate ( zmns ( mnmax , ns )); zmns = zmns_vmec allocate ( bmnc ( mnmax_nyq , ns )); bmnc = bmnc_vmec allocate ( gmnc ( mnmax_nyq , ns )); gmnc = gmnc_vmec allocate ( bsupumnc ( mnmax_nyq , ns )); bsupumnc = bsupumnc_vmec allocate ( bsupvmnc ( mnmax_nyq , ns )); bsupvmnc = bsupvmnc_vmec allocate ( bsubumnc ( mnmax_nyq , ns )); bsubumnc = bsubumnc_vmec allocate ( bsubvmnc ( mnmax_nyq , ns )); bsubvmnc = bsubvmnc_vmec allocate ( bsubsmns ( mnmax_nyq , ns )); bsubsmns = bsubsmns_vmec allocate ( phi ( ns )); phi = phi_vmec allocate ( phip ( ns )); phip = phip_vmec allocate ( iotas ( ns )); iotas = iotas_vmec allocate ( iotaf ( ns )); iotaf = iotaf_vmec allocate ( presf ( ns )); presf = presf_vmec if ( lasym ) then allocate ( rmns ( mnmax , ns )); rmns = rmns_vmec allocate ( lmnc ( mnmax , ns )); lmnc = lmnc_vmec allocate ( zmnc ( mnmax , ns )); zmnc = zmnc_vmec allocate ( bmns ( mnmax_nyq , ns )); bmns = bmns_vmec allocate ( gmns ( mnmax_nyq , ns )); gmns = gmns_vmec allocate ( bsupumns ( mnmax_nyq , ns )); bsupumns = bsupumns_vmec allocate ( bsupvmns ( mnmax_nyq , ns )); bsupvmns = bsupvmns_vmec allocate ( bsubumns ( mnmax_nyq , ns )); bsubumns = bsubumns_vmec allocate ( bsubvmns ( mnmax_nyq , ns )); bsubvmns = bsubvmns_vmec allocate ( bsubsmnc ( mnmax_nyq , ns )); bsubsmnc = bsubsmnc_vmec end if end if ! deallocate all arrays opened externally in read_wout_mod call read_wout_deallocate ( ierr ) if ( ierr /= 0 ) then print * , \"Warning: error returned when deallocating wout arrays. \" , ierr end if ierr = 0 end subroutine read_vmec_equilibrium subroutine get_nominal_vmec_zeta_grid ( new_zeta_min , stellarator_symmetric_BC , nzgrid , zeta_center , & number_of_field_periods_stella , number_of_field_periods_device , zeta ) implicit none ! stellarator_symmetric_BC = true if twist_shift_option = stellarator logical , intent ( in ) :: stellarator_symmetric_BC ! new_zeta_min is the new minimum value of the parallel coordinate if dkx_over_dky != -1 selected real , intent ( in ) :: new_zeta_min ! 2*nzgrid+1 is the number of zeta grid points for the nominal zeta grid integer , intent ( in ) :: nzgrid ! The zeta domain is centered at zeta_center. Setting zeta_center = 2*pi*N/nfp for any integer N should ! yield identical results to setting zeta_center = 0, where nfp is the number of field periods (as in VMEC). real , intent ( in ) :: zeta_center ! number_of_field_periods_device is the number of field periods sampled by stella real , intent ( in out ) :: number_of_field_periods_stella ! number_of_field_periods_stella_new is the new number of field periods that the code should compute if ! dkx_over_dky != -1 real :: number_of_field_periods_stella_new ! number_of_field_periods_device is the number of field periods for the device real , intent ( out ) :: number_of_field_periods_device ! On exit, zeta holds the nominal grid points in the toroidal angle zeta real , dimension ( - nzgrid :), intent ( out ) :: zeta real , parameter :: pi = 3.1415926535897932d+0 integer :: j number_of_field_periods_device = nfp if ( number_of_field_periods_stella < 0.0 ) & number_of_field_periods_stella = number_of_field_periods_device if ( stellarator_symmetric_BC ) then number_of_field_periods_stella_new = ( new_zeta_min - zeta_center ) * nfp / ( pi ) write ( * , * ) 'Number of field periods sampled by stella has changed from' , number_of_field_periods_stella , & 'to' , number_of_field_periods_stella_new write ( * , * ) number_of_field_periods_stella = number_of_field_periods_stella_new end if zeta = [( zeta_center + ( pi * j * number_of_field_periods_stella ) / ( nfp * nzgrid ), j =- nzgrid , nzgrid )] end subroutine get_nominal_vmec_zeta_grid subroutine vmec_to_stella_geometry_interface ( nalpha , alpha0 , nzgrid , & zeta_center , number_of_field_periods_to_include , & desired_normalized_toroidal_flux , vmec_surface_option , verbose , & normalized_toroidal_flux_used , safety_factor_q , shat , L_reference , B_reference , nfp_out , & sign_toroidal_flux , & alpha , zeta , bmag , gradpar_zeta , grad_alpha_grad_alpha , & grad_alpha_grad_psi , grad_psi_grad_psi , gds23 , gds24 , gds25 , gds26 , & gbdrift_alpha , gbdrift0_psi , cvdrift_alpha , cvdrift0_psi , & theta_vmec , B_sub_zeta , B_sub_theta_vmec , x_displacement_fac , gradpar_zeta_prefac , & ierr ) use fzero_mod , only : fzero implicit none !********************************************************************* ! Input parameters !********************************************************************* ! nalpha is the number of grid points in the alpha coordinate: integer , intent ( in ) :: nalpha ! alpha0 is the first alpha value to include in the alpha grid real , intent ( in ) :: alpha0 ! The zeta grid has nzgrid*2+1 points, including the \"repeated\" point at index -nzgrid and +nzgrid. integer , intent ( in ) :: nzgrid ! The zeta domain is centered at zeta_center. Setting zeta_center = 2*pi*N/nfp for any integer N should ! yield identical results to setting zeta_center = 0, where nfp is the number of field periods (as in VMEC). real , intent ( in ) :: zeta_center ! gradpar_zeta_prefac only rescales b dot grad zeta real , intent ( in ) :: gradpar_zeta_prefac ! If number_of_field_periods_to_include is > 0, then this parameter does what you think: ! the extent of the toroidal in zeta will be 2*pi*number_of_field_periods_to_include/nfp. ! If number_of_field_periods_to_include is <= 0, the entire 2*pi toroidal domain will be included. real , intent ( in ) :: number_of_field_periods_to_include ! The parameter desired_normalized_toroidal_flux determines which flux surface from the VMEC file will be used ! for the computation. This parameter should lie in the interval [0,1]. real , intent ( in ) :: desired_normalized_toroidal_flux ! If vmec_surface_option = 0, the magnetic surface specified by desired_normalized_toroidal_flux will be used, ! by interpolating between the surfaces available in the vmec file. ! If vmec_surface_option = 1, the magnetic surface on vmec's HALF radial mesh will be used that is closest to desired_normalized_toroidal_flux. ! If vmec_surface_option = 2, the magnetic surface on vmec's FULL radial mesh will be used that is closest to desired_normalized_toroidal_flux. ! Other values of vmec_surface_option will cause the program to abort with an error. integer , intent ( in ) :: vmec_surface_option ! If verbose is .true. in the vmec_parameters namelist, lots of diagnostic information is printed. logical , intent ( in ) :: verbose !********************************************************************* ! Output quantities !********************************************************************* ! On exit, normalized_toroidal_flux_used holds the flux surface that was actually used for the geometry, ! as measured by psi_toroidal / psi_{toroidal,edge} real , intent ( out ) :: normalized_toroidal_flux_used ! Safety factor q = 1/iota real , intent ( out ) :: safety_factor_q ! Magnetic shear shat = (x/q) * (d q / d x) where x = Aminor_p * sqrt(psi_toroidal / psi_{toroidal,edge}) ! and Aminor_p is the minor radius calculated by VMEC. real , intent ( out ) :: shat ! L_reference is the reference length used for stella normalization, in meters. real , intent ( out ) :: L_reference ! B_reference is the reference magnetic field strength used for stella normalization, in Tesla. real , intent ( out ) :: B_reference ! nfp is the number of field periods given by VMEC real , intent ( out ) :: nfp_out integer , intent ( out ) :: sign_toroidal_flux ! On exit, alpha holds the grid points in alpha = theta_p - iota * zeta, where theta_p is the PEST toroidal angle real , dimension (:), intent ( out ) :: alpha ! On exit, zeta holds the grid points in the toroidal angle zeta real , dimension ( - nzgrid :), intent ( out ) :: zeta real , dimension (:, - nzgrid :), intent ( out ) :: theta_vmec real , dimension (:, - nzgrid :), intent ( out ) :: bmag ! gradpar_zeta = b . grad zeta, with zeta the physical toroidal angle ! taken to increase in the counter-clockwise direction real , dimension (:, - nzgrid :), intent ( out ) :: gradpar_zeta ! grad alpha . grad alpha in units of 1/L_ref&#94;2, with alpha = theta_pest - iota * zeta real , dimension (:, - nzgrid :), intent ( out ) :: grad_alpha_grad_alpha ! grad alpha . grad psi_t in units of B_ref, with alpha = theta_pest - iota * zeta real , dimension (:, - nzgrid :), intent ( out ) :: grad_alpha_grad_psi ! grad psi_t . grad psi_t in units of (a*B_ref)&#94;2, with alpha = theta_pest - iota * zeta real , dimension (:, - nzgrid :), intent ( out ) :: grad_psi_grad_psi ! 2 * bhat/B x (grad B / B) . grad alpha * B_ref * L_ref&#94;2 real , dimension (:, - nzgrid :), intent ( out ) :: gbdrift_alpha ! 2 * bhat/B x (bhat . grad bhat) . grad alpha * B_ref * L_ref&#94;2 real , dimension (:, - nzgrid :), intent ( out ) :: cvdrift_alpha real , dimension (:, - nzgrid :), intent ( out ) :: gds23 , gds24 , gds25 , gds26 !    real, dimension (:,-nzgrid:), intent (out) :: gbdrift, gbdrift0, cvdrift, cvdrift0 real , dimension (:, - nzgrid :), intent ( out ) :: gbdrift0_psi , cvdrift0_psi real , dimension (:, - nzgrid :), intent ( out ) :: B_sub_theta_vmec , B_sub_zeta real , dimension (:, - nzgrid :), intent ( out ) :: x_displacement_fac integer , intent ( out ) :: ierr integer :: ierr2 !********************************************************************* ! Variables used internally by this subroutine !********************************************************************* real , parameter :: pi = 3.1415926535897932d+0 real , parameter :: zero = 0.0d+0 real , parameter :: one = 1.0d+0 real , parameter :: mu_0 = 4 * pi * ( 1.0d-7 ) integer :: j , index , izeta , ialpha , isurf , m , n , imn , imn_nyq real :: angle , sin_angle , cos_angle , temp , edge_toroidal_flux_over_2pi !    integer :: fzero_flag real :: number_of_field_periods_to_include_final real :: dphi , iota , min_dr2 , ds , d_pressure_d_s , d_iota_d_s , scale_factor real :: theta_vmec_min , theta_vmec_max , sqrt_s real , dimension (:), allocatable :: dr2 , normalized_toroidal_flux_full_grid , normalized_toroidal_flux_half_grid real , dimension (:), allocatable :: d_pressure_d_s_on_half_grid , d_iota_d_s_on_half_grid !    real :: root_solve_absolute_tolerance, root_solve_relative_tolerance logical :: non_Nyquist_mode_available , found_imn real , dimension (:, :), allocatable :: R , Z real , dimension (:, :), allocatable :: B , sqrt_g , B_dot_grad_theta_pest_over_B_dot_grad_zeta , temp2D real , dimension (:, :), allocatable :: d_B_d_theta_vmec , d_B_d_zeta , d_B_d_s real , dimension (:, :), allocatable :: d_R_d_theta_vmec , d_R_d_zeta , d_R_d_s real , dimension (:, :), allocatable :: d_Z_d_theta_vmec , d_Z_d_zeta , d_Z_d_s real , dimension (:, :), allocatable :: d_X_d_theta_vmec , d_X_d_zeta , d_X_d_s real , dimension (:, :), allocatable :: d_Y_d_theta_vmec , d_Y_d_zeta , d_Y_d_s real , dimension (:, :), allocatable :: d_Lambda_d_theta_vmec , d_Lambda_d_zeta , d_Lambda_d_s !real, dimension(:,:), allocatable :: B_sub_s, B_sub_theta_vmec, B_sub_zeta real , dimension (:, :), allocatable :: B_sub_s real , dimension (:, :), allocatable :: B_sup_theta_vmec , B_sup_zeta real , dimension (:), allocatable :: d_B_d_s_mnc , d_B_d_s_mns real , dimension (:), allocatable :: d_R_d_s_mnc , d_R_d_s_mns real , dimension (:), allocatable :: d_Z_d_s_mnc , d_Z_d_s_mns real , dimension (:), allocatable :: d_Lambda_d_s_mnc , d_Lambda_d_s_mns real , dimension (:, :), allocatable :: grad_s_X , grad_s_Y , grad_s_Z real , dimension (:, :), allocatable :: grad_theta_vmec_X , grad_theta_vmec_Y , grad_theta_vmec_Z real , dimension (:, :), allocatable :: grad_theta_pest_X , grad_theta_pest_Y , grad_theta_pest_Z real , dimension (:, :), allocatable :: grad_zeta_X , grad_zeta_Y , grad_zeta_Z real , dimension (:, :), allocatable :: grad_psi_X , grad_psi_Y , grad_psi_Z real , dimension (:, :), allocatable :: grad_alpha_X , grad_alpha_Y , grad_alpha_Z real , dimension (:, :), allocatable :: B_cross_grad_B_dot_grad_alpha , B_cross_grad_B_dot_grad_alpha_alternate real , dimension (:, :), allocatable :: B_cross_grad_s_dot_grad_alpha , B_cross_grad_s_dot_grad_alpha_alternate real , dimension (:, :), allocatable :: grad_B_X , grad_B_Y , grad_B_Z real , dimension (:, :), allocatable :: B_X , B_Y , B_Z real , dimension (:, :), allocatable :: gradzeta_grady , gradzeta_gradx real , dimension (:, :), allocatable :: gradtheta_grady , gradtheta_gradx logical :: theta_converged !********************************************************************* ! VMEC variables of interest: ! ns = number of flux surfaces used by VMEC ! nfp = number of field periods, e.g. 5 for W7-X, 4 for HSX ! iotas = rotational transform (1/q) on the half grid. ! iotaf = rotational transform on the full grid. ! presf = pressure on the full grid. ! ! All VMEC quantities (B, pressure, etc) are in SI units. ! ! In VMEC, quantities on the half grid have the same number of array elements (ns) as quantities on the full grid, ! but the first array element is 0. ! !********************************************************************* !********************************************************************* ! Beginning of executable statements. !********************************************************************* !    if (verbose) print *,\"Entering subroutine vmec_to_stella_geometry_interface.\" !********************************************************************* ! Do some validation. !********************************************************************* ierr = 0 if ( nalpha < 1 ) then print * , \"Error! nalpha must be >= 1. Instead it is\" , nalpha ierr = 100 return end if if ( nzgrid < 1 ) then print * , \"Error! nzgrid must be >= 1. Instead it is\" , nzgrid ierr = 101 return end if if ( desired_normalized_toroidal_flux <= 0 ) then print * , \"Error! desired_normalized_toroidal_flux must be >0. Instead it is\" , desired_normalized_toroidal_flux ierr = 102 return end if if ( desired_normalized_toroidal_flux > 1 ) then print * , \"Error! desired_normalized_toroidal_flux must be <= 1. Instead it is\" , desired_normalized_toroidal_flux ierr = 103 return end if nfp_out = nfp ! There is a bug in libstell read_wout_file for ASCII-format wout files, in which the xm_nyq and xn_nyq arrays are sometimes ! not populated. The next few lines here provide a workaround: if ( maxval ( abs ( xm_nyq )) < 1 . and . maxval ( abs ( xn_nyq )) < 1 ) then if ( mnmax_nyq == mnmax ) then if ( verbose ) print * , \"xm_nyq and xn_nyq arrays are not populated in the wout file. Using xm and xn instead.\" xm_nyq = xm xn_nyq = xn else print * , \"Error! xm_nyq and xn_nyq arrays are not populated in the wout file, and mnmax_nyq != mnmax.\" ierr = 104 return end if end if edge_toroidal_flux_over_2pi = phi ( ns ) / ( 2 * pi ) * isigng ! isigns is called signgs in the wout*.nc file. Why is this signgs here? ! this gives the sign of the edge toroidal flux sign_toroidal_flux = int ( sign ( 1.1 , edge_toroidal_flux_over_2pi )) if ( verbose ) write ( * , '(A43, I2)' ) \"      Sign of the toroidal flux from VMEC:\" // repeat ( ' ' , 50 ), sign_toroidal_flux ! Set reference length and magnetic field for stella's normalization, ! using the choices made by Pavlos Xanthopoulos in GIST: L_reference = Aminor ! Note that 'Aminor' in read_wout_mod is called 'Aminor_p' in the wout*.nc file. !    B_reference = 2 * edge_toroidal_flux_over_2pi / (L_reference * L_reference) B_reference = 2 * abs ( edge_toroidal_flux_over_2pi ) / ( L_reference * L_reference ) if ( verbose ) then write ( * , * ) \"  \" write ( * , * ) \"  Reference values for the stella normalization:\" write ( * , '(A42, F15.12, A7)' ) \"      Reference length (minor radius a):\" // repeat ( ' ' , 50 ), L_reference , \" meters\" write ( * , '(A42, F15.12, A6)' ) \"      Reference magnetic field strength:\" // repeat ( ' ' , 50 ), B_reference , \" Tesla\" end if ! -------------------------------------------------------------------------------- ! Do some sanity checking to ensure the VMEC arrays have some expected properties. ! -------------------------------------------------------------------------------- ! 'phi' is vmec's array of the toroidal flux (not divided by 2pi!) on vmec's radial grid. if ( abs ( phi ( 1 )) > 1 d - 14 ) then print * , \"Error! VMEC phi array does not begin with 0.\" print * , \"phi:\" , phi ierr = 105 return end if dphi = phi ( 2 ) - phi ( 1 ) do j = 3 , ns if ( abs ( phi ( j ) - phi ( j - 1 ) - dphi ) > 1 d - 11 ) then print * , \"Error! VMEC phi array is not uniformly spaced.\" print * , \"phi:\" , phi ierr = 106 return end if end do ! The variable called 'phips' in the wout file is called just 'phip' in read_wout_mod.F. ! phips is on the half-mesh, so skip first point. do j = 2 , ns if ( abs ( phip ( j ) + phi ( ns ) / ( 2 * pi )) > 1 d - 11 ) then print * , \"Error! VMEC phips array is not constant and equal to -phi(ns)/(2*pi).\" print * , \"phip(s):\" , phip ierr = 107 return end if end do ! The first mode in the m and n arrays should be m=n=0: if ( xm ( 1 ) /= 0 ) then print * , \"First element of xm in the wout file should be 0.\" ierr = 108 return end if if ( xn ( 1 ) /= 0 ) then print * , \"First element of xn in the wout file should be 0.\" ierr = 109 return end if if ( xm_nyq ( 1 ) /= 0 ) then print * , \"First element of xm_nyq in the wout file should be 0.\" ierr = 110 return end if if ( xn_nyq ( 1 ) /= 0 ) then print * , \"First element of xn_nyq in the wout file should be 0.\" ierr = 111 return end if ! Lambda should be on the half mesh, so its value at radial index 1 should be 0 for all (m,n) if ( maxval ( abs ( lmns (:, 1 ))) > 0 ) then print * , \"Error! Expected lmns to be on the half mesh, but its value at radial index 1 is nonzero.\" print * , \"Here comes lmns(:,1):\" , lmns (:, 1 ) ierr = 112 return end if if ( lasym ) then if ( maxval ( abs ( lmnc (:, 1 ))) > 0 ) then print * , \"Error! Expected lmnc to be on the half mesh, but its value at radial index 1 is nonzero.\" print * , \"Here comes lmnc(:,1):\" , lmnc (:, 1 ) ierr = 113 return end if end if ! -------------------------------------------------------------------------------- ! End of sanity checks. ! -------------------------------------------------------------------------------- allocate ( normalized_toroidal_flux_full_grid ( ns )) normalized_toroidal_flux_full_grid = [( real ( j - 1 ) / ( ns - 1 ), j = 1 , ns )] ! Build an array of the half grid points: allocate ( normalized_toroidal_flux_half_grid ( ns - 1 )) do j = 1 , ns - 1 normalized_toroidal_flux_half_grid ( j ) = ( normalized_toroidal_flux_full_grid ( j ) + normalized_toroidal_flux_full_grid ( j + 1 )) * ( 0.5d+0 ) end do !********************************************************************* ! Determine which flux surface to use, based on ! desired_normalized_toroidal_flux and vmec_surface_option. !********************************************************************* ! Possible values of vmec_surface_option: ! 0 = Use the exact radius requested. ! 1 = Use the nearest value of the VMEC half grid. ! 2 = Use the nearest value of the VMEC full grid. select case ( vmec_surface_option ) case ( 0 ) ! Use exact radius requested. normalized_toroidal_flux_used = desired_normalized_toroidal_flux case ( 1 ) ! Use nearest value of the VMEC half grid ! Compute differences allocate ( dr2 ( ns - 1 )) dr2 = ( normalized_toroidal_flux_half_grid - desired_normalized_toroidal_flux ) ** 2 index = 1 min_dr2 = dr2 ( 1 ) ! Find the index of minimum error: do j = 2 , ns - 1 if ( dr2 ( j ) < min_dr2 ) then index = j min_dr2 = dr2 ( j ) end if end do normalized_toroidal_flux_used = normalized_toroidal_flux_half_grid ( index ) deallocate ( dr2 ) case ( 2 ) ! Use nearest value of the VMEC full grid ! Compute differences allocate ( dr2 ( ns )) dr2 = ( normalized_toroidal_flux_full_grid - desired_normalized_toroidal_flux ) ** 2 index = 1 min_dr2 = dr2 ( 1 ) ! Find the index of minimum error: do j = 2 , ns if ( dr2 ( j ) < min_dr2 ) then index = j min_dr2 = dr2 ( j ) end if end do normalized_toroidal_flux_used = normalized_toroidal_flux_full_grid ( index ) deallocate ( dr2 ) case default print * , \"Error! vmec_surface_option must be 0, 1, or 2. It is instead \" , vmec_surface_option ierr = 114 return end select ! -------------------------------------------------------------------------------- ! Done choosing the actual radius to use. ! -------------------------------------------------------------------------------- ! In general, we get quantities for stella by linear interpolation, taking a weighted average of the quantity from ! 2 surfaces in the VMEC file. Sometimes the weights are 0 and 1, i.e. no interpolation is needed. ! For any VMEC quantity Q on the full grid, the value used in stella will be !  Q_stella = Q(vmec_radial_index_full(1))*vmec_radial_weight_full(1) + Q(vmec_radial_index_full(2))*vmec_radial_weight_full(2) ! For any VMEC quantity Q on the half grid, the value used in stella will be !  Q_stella = Q(vmec_radial_index_half(1))*vmec_radial_weight_half(1) + Q(vmec_radial_index_half(2))*vmec_radial_weight_half(2) ! Handle quantities for the full grid if ( normalized_toroidal_flux_used > 1 ) then print * , \"Error! normalized_toroidal_flux_used cannot be >1\" ierr = 115 return elseif ( normalized_toroidal_flux_used < 0 ) then print * , \"Error! normalized_toroidal_flux_used cannot be <0\" ierr = 116 return elseif ( normalized_toroidal_flux_used == 1 ) then vmec_radial_index_full ( 1 ) = ns - 1 vmec_radial_index_full ( 2 ) = ns vmec_radial_weight_full ( 1 ) = zero else ! normalized_toroidal_flux_used is >= 0 and <1 ! This is the most common case. vmec_radial_index_full ( 1 ) = floor ( normalized_toroidal_flux_used * ( ns - 1 )) + 1 vmec_radial_index_full ( 2 ) = vmec_radial_index_full ( 1 ) + 1 vmec_radial_weight_full ( 1 ) = vmec_radial_index_full ( 1 ) - normalized_toroidal_flux_used * ( ns - one ) end if vmec_radial_weight_full ( 2 ) = one - vmec_radial_weight_full ( 1 ) ! Handle quantities for the half grid if ( normalized_toroidal_flux_used < normalized_toroidal_flux_half_grid ( 1 )) then print * , \"Warning: extrapolating beyond the end of VMEC's half grid.\" print * , \"(Extrapolating towards the magnetic axis.) Results are likely to be inaccurate.\" ! We start at element 2 since element 1 is always 0 for quantities on the half grid. vmec_radial_index_half ( 1 ) = 2 vmec_radial_index_half ( 2 ) = 3 vmec_radial_weight_half ( 1 ) = ( normalized_toroidal_flux_half_grid ( 2 ) - normalized_toroidal_flux_used ) / ( normalized_toroidal_flux_half_grid ( 2 ) - normalized_toroidal_flux_half_grid ( 1 )) elseif ( normalized_toroidal_flux_used > normalized_toroidal_flux_half_grid ( ns - 1 )) then print * , \"Warning: extrapolating beyond the end of VMEC's half grid.\" print * , \"(Extrapolating towards the last closed flux surface.) Results may be inaccurate.\" vmec_radial_index_half ( 1 ) = ns - 1 vmec_radial_index_half ( 2 ) = ns vmec_radial_weight_half ( 1 ) = ( normalized_toroidal_flux_half_grid ( ns - 1 ) - normalized_toroidal_flux_used ) & / ( normalized_toroidal_flux_half_grid ( ns - 1 ) - normalized_toroidal_flux_half_grid ( ns - 2 )) elseif ( normalized_toroidal_flux_used == normalized_toroidal_flux_half_grid ( ns - 1 )) then ! We are exactly at the last point of the half grid vmec_radial_index_half ( 1 ) = ns - 1 vmec_radial_index_half ( 2 ) = ns vmec_radial_weight_half ( 1 ) = zero else ! normalized_toroidal_flux_used is inside the half grid. ! This is the most common case. vmec_radial_index_half ( 1 ) = floor ( normalized_toroidal_flux_used * ( ns - 1 ) + 0.5d+0 ) + 1 if ( vmec_radial_index_half ( 1 ) < 2 ) then ! This can occur sometimes due to roundoff error. vmec_radial_index_half ( 1 ) = 2 end if vmec_radial_index_half ( 2 ) = vmec_radial_index_half ( 1 ) + 1 vmec_radial_weight_half ( 1 ) = vmec_radial_index_half ( 1 ) - normalized_toroidal_flux_used * ( ns - one ) - ( 0.5d+0 ) end if vmec_radial_weight_half ( 2 ) = one - vmec_radial_weight_half ( 1 ) !     if (verbose) then !        if (abs(vmec_radial_weight_half(1)) < 1e-14) then !           print \"(a,i4,a,i4,a)\",\"   Using radial index \",vmec_radial_index_half(2),\" of \",ns,\" from vmec's half mesh.\" !        elseif (abs(vmec_radial_weight_half(2)) < 1e-14) then !           print \"(a,i4,a,i4,a)\",\"   Using radial index \",vmec_radial_index_half(1),\" of \",ns,\" from vmec's half mesh.\" !        else !           print \"(a,i4,a,i4,a,i4,a)\", \"   Interpolating using radial indices \",vmec_radial_index_half(1),\" and \",vmec_radial_index_half(2),& !                \" of \",ns,\" from vmec's half mesh.\" !           print \"(a,f17.14,a,f17.14)\", \"   Weights for half mesh = \",vmec_radial_weight_half(1),\" and \",vmec_radial_weight_half(2) !           print \"(a,i4,a,i4,a,i4,a)\", \"   Interpolating using radial indices \",vmec_radial_index_full(1),\" and \",vmec_radial_index_full(2),& !                \" of \",ns,\" from vmec's full mesh.\" !           print \"(a,f17.14,a,f17.14)\", \"   Weights for full mesh = \",vmec_radial_weight_full(1),\" and \",vmec_radial_weight_full(2) !        end if !     end if !********************************************************************* ! Evaluate several radial-profile functions at the flux surface ! we ended up choosing. !********************************************************************* if ( verbose ) write ( * , * ) \" \" if ( verbose ) write ( * , * ) \"  Radial-profile functions at the chosen flux surface:\" iota = iotas ( vmec_radial_index_half ( 1 )) * vmec_radial_weight_half ( 1 ) & + iotas ( vmec_radial_index_half ( 2 )) * vmec_radial_weight_half ( 2 ) if ( verbose ) write ( * , '(A21, F15.12)' ) \"      iota:\" // repeat ( ' ' , 50 ), iota safety_factor_q = 1 / iota allocate ( d_iota_d_s_on_half_grid ( ns )) d_iota_d_s_on_half_grid = 0 ds = normalized_toroidal_flux_full_grid ( 2 ) - normalized_toroidal_flux_full_grid ( 1 ) if ( verbose ) write ( * , '(A21, ES20.12E3)' ) \"      ds:\" // repeat ( ' ' , 50 ), ds d_iota_d_s_on_half_grid ( 2 : ns ) = ( iotaf ( 2 : ns ) - iotaf ( 1 : ns - 1 )) / ds d_iota_d_s = & d_iota_d_s_on_half_grid ( vmec_radial_index_half ( 1 )) * vmec_radial_weight_half ( 1 ) & + d_iota_d_s_on_half_grid ( vmec_radial_index_half ( 2 )) * vmec_radial_weight_half ( 2 ) deallocate ( d_iota_d_s_on_half_grid ) if ( verbose ) write ( * , '(A21, ES20.12E3)' ) \"      diota/ds:\" // repeat ( ' ' , 50 ), d_iota_d_s ! shat = (r/q)(dq/dr) where r = a sqrt(s). !      = - (r/iota) (d iota / d r) = -2 (s/iota) (d iota / d s) shat = ( - 2 * normalized_toroidal_flux_used / iota ) * d_iota_d_s allocate ( d_pressure_d_s_on_half_grid ( ns )) d_pressure_d_s_on_half_grid = 0 ds = normalized_toroidal_flux_full_grid ( 2 ) - normalized_toroidal_flux_full_grid ( 1 ) d_pressure_d_s_on_half_grid ( 2 : ns ) = ( presf ( 2 : ns ) - presf ( 1 : ns - 1 )) / ds d_pressure_d_s = & d_pressure_d_s_on_half_grid ( vmec_radial_index_half ( 1 )) * vmec_radial_weight_half ( 1 ) & + d_pressure_d_s_on_half_grid ( vmec_radial_index_half ( 2 )) * vmec_radial_weight_half ( 2 ) deallocate ( d_pressure_d_s_on_half_grid ) if ( verbose ) write ( * , '(A21, ES20.12E3)' ) \"      dpressure/ds:\" // repeat ( ' ' , 50 ), d_pressure_d_s if ( verbose ) write ( * , * ) \" \" !********************************************************************* ! Set up the coordinate grids. !********************************************************************* alpha = [( alpha0 + (( j - 1 ) * 2 * pi ) / nalpha , j = 1 , nalpha )] !!$    if (number_of_field_periods_to_include > nfp) then !!$       print *,\"Error! number_of_field_periods_to_include > nfp\" !!$       print *,\"  number_of_field_periods_to_include =\",number_of_field_periods_to_include !!$       print *,\"  nfp =\",nfp !!$       stop !!$    end if number_of_field_periods_to_include_final = number_of_field_periods_to_include if ( number_of_field_periods_to_include <= 0 ) then number_of_field_periods_to_include_final = nfp if ( verbose ) print * , \"   Since number_of_field_periods_to_include was <= 0, it is being reset to nfp =\" , nfp end if zeta = [( zeta_center + ( pi * j * number_of_field_periods_to_include_final ) / ( nfp * nzgrid ), j =- nzgrid , nzgrid )] !********************************************************************* ! We know theta_pest = alpha + iota * zeta, but we need to determine ! theta_vmec = theta_pest - Lambda. !********************************************************************* if ( verbose ) print * , \"Beginning root solves to determine theta_vmec.\" do izeta = - nzgrid , nzgrid zeta0 = zeta ( izeta ) do ialpha = 1 , nalpha theta_pest_target = alpha ( ialpha ) + iota * zeta0 ! Guess that theta_vmec will be within 0.3 radians of theta_pest: theta_vmec_min = theta_pest_target - 0.3 theta_vmec_max = theta_pest_target + 0.3 call get_root ( theta_vmec_min , theta_vmec_max , theta_vmec ( ialpha , izeta ), theta_converged ) ! In the 4th argument, we are telling the root-finder (fzero) to use theta_pest as the initial guess for theta_vmec. !          call fzero(fzero_residual, theta_vmec_min, theta_vmec_max, theta_pest_target, & !               root_solve_relative_tolerance, root_solve_absolute_tolerance, fzero_flag) ! Note: fzero returns its answer in theta_vmec_min. !          theta_vmec(ialpha,izeta) = theta_vmec_min !          if (fzero_flag == 4) then !             stop \"ERROR: fzero returned error 4: no sign change in residual\" !          else if (fzero_flag > 2) then !             print *,\"WARNING: fzero returned an error code:\",fzero_flag !          end if if (. not . theta_converged ) then write ( * , * ) \"ERROR: could not find root needed to compute theta_vmec. aborting\" ierr = 117 return end if end do end do !    if (verbose) then !       do izeta = -nzgrid, nzgrid !          do ialpha = 1, nalpha !             write (*,*) 'theta_vmec', alpha(ialpha), zeta(izeta), theta_vmec(ialpha,izeta) !          end do !          write (*,*) !       end do !    end if !********************************************************************* ! Initialize geometry arrays !********************************************************************* bmag = 0 gradpar_zeta = 0 grad_alpha_grad_alpha = 0.0 grad_alpha_grad_psi = 0.0 grad_psi_grad_psi = 0.0 gds23 = 0.0 gds24 = 0.0 gds25 = 0.0 gds26 = 0.0 gbdrift_alpha = 0 gbdrift0_psi = 0 cvdrift_alpha = 0 cvdrift0_psi = 0 B_sub_theta_vmec = 0 B_sub_zeta = 0 allocate ( B ( nalpha , - nzgrid : nzgrid )) allocate ( temp2D ( nalpha , - nzgrid : nzgrid )) allocate ( sqrt_g ( nalpha , - nzgrid : nzgrid )) allocate ( R ( nalpha , - nzgrid : nzgrid )) allocate ( Z ( nalpha , - nzgrid : nzgrid )) allocate ( d_B_d_theta_vmec ( nalpha , - nzgrid : nzgrid )) allocate ( d_B_d_zeta ( nalpha , - nzgrid : nzgrid )) allocate ( d_B_d_s ( nalpha , - nzgrid : nzgrid )) allocate ( d_R_d_theta_vmec ( nalpha , - nzgrid : nzgrid )) allocate ( d_R_d_zeta ( nalpha , - nzgrid : nzgrid )) allocate ( d_R_d_s ( nalpha , - nzgrid : nzgrid )) allocate ( d_Z_d_theta_vmec ( nalpha , - nzgrid : nzgrid )) allocate ( d_Z_d_zeta ( nalpha , - nzgrid : nzgrid )) allocate ( d_Z_d_s ( nalpha , - nzgrid : nzgrid )) allocate ( d_Lambda_d_theta_vmec ( nalpha , - nzgrid : nzgrid )) allocate ( d_Lambda_d_zeta ( nalpha , - nzgrid : nzgrid )) allocate ( d_Lambda_d_s ( nalpha , - nzgrid : nzgrid )) allocate ( B_sub_s ( nalpha , - nzgrid : nzgrid )) !allocate(B_sub_theta_vmec(nalpha,-nzgrid:nzgrid)) !allocate(B_sub_zeta(nalpha,-nzgrid:nzgrid)) allocate ( B_sup_theta_vmec ( nalpha , - nzgrid : nzgrid )) allocate ( B_sup_zeta ( nalpha , - nzgrid : nzgrid )) allocate ( d_B_d_s_mnc ( ns )) allocate ( d_B_d_s_mns ( ns )) allocate ( d_R_d_s_mnc ( ns )) allocate ( d_R_d_s_mns ( ns )) allocate ( d_Z_d_s_mnc ( ns )) allocate ( d_Z_d_s_mns ( ns )) allocate ( d_Lambda_d_s_mnc ( ns )) allocate ( d_Lambda_d_s_mns ( ns )) allocate ( d_X_d_s ( nalpha , - nzgrid : nzgrid )) allocate ( d_X_d_theta_vmec ( nalpha , - nzgrid : nzgrid )) allocate ( d_X_d_zeta ( nalpha , - nzgrid : nzgrid )) allocate ( d_Y_d_s ( nalpha , - nzgrid : nzgrid )) allocate ( d_Y_d_theta_vmec ( nalpha , - nzgrid : nzgrid )) allocate ( d_Y_d_zeta ( nalpha , - nzgrid : nzgrid )) allocate ( grad_s_X ( nalpha , - nzgrid : nzgrid )) allocate ( grad_s_Y ( nalpha , - nzgrid : nzgrid )) allocate ( grad_s_Z ( nalpha , - nzgrid : nzgrid )) allocate ( grad_theta_vmec_X ( nalpha , - nzgrid : nzgrid )) allocate ( grad_theta_vmec_Y ( nalpha , - nzgrid : nzgrid )) allocate ( grad_theta_vmec_Z ( nalpha , - nzgrid : nzgrid )) allocate ( grad_theta_pest_X ( nalpha , - nzgrid : nzgrid )) allocate ( grad_theta_pest_Y ( nalpha , - nzgrid : nzgrid )) allocate ( grad_theta_pest_Z ( nalpha , - nzgrid : nzgrid )) allocate ( grad_zeta_X ( nalpha , - nzgrid : nzgrid )) allocate ( grad_zeta_Y ( nalpha , - nzgrid : nzgrid )) allocate ( grad_zeta_Z ( nalpha , - nzgrid : nzgrid )) allocate ( grad_psi_X ( nalpha , - nzgrid : nzgrid )) allocate ( grad_psi_Y ( nalpha , - nzgrid : nzgrid )) allocate ( grad_psi_Z ( nalpha , - nzgrid : nzgrid )) allocate ( grad_alpha_X ( nalpha , - nzgrid : nzgrid )) allocate ( grad_alpha_Y ( nalpha , - nzgrid : nzgrid )) allocate ( grad_alpha_Z ( nalpha , - nzgrid : nzgrid )) allocate ( B_X ( nalpha , - nzgrid : nzgrid )) allocate ( B_Y ( nalpha , - nzgrid : nzgrid )) allocate ( B_Z ( nalpha , - nzgrid : nzgrid )) allocate ( grad_B_X ( nalpha , - nzgrid : nzgrid )) allocate ( grad_B_Y ( nalpha , - nzgrid : nzgrid )) allocate ( grad_B_Z ( nalpha , - nzgrid : nzgrid )) allocate ( B_cross_grad_B_dot_grad_alpha ( nalpha , - nzgrid : nzgrid )) allocate ( B_cross_grad_B_dot_grad_alpha_alternate ( nalpha , - nzgrid : nzgrid )) allocate ( B_cross_grad_s_dot_grad_alpha ( nalpha , - nzgrid : nzgrid )) allocate ( B_cross_grad_s_dot_grad_alpha_alternate ( nalpha , - nzgrid : nzgrid )) allocate ( gradzeta_grady ( nalpha , - nzgrid : nzgrid )) allocate ( gradzeta_gradx ( nalpha , - nzgrid : nzgrid )) allocate ( gradtheta_grady ( nalpha , - nzgrid : nzgrid )) allocate ( gradtheta_gradx ( nalpha , - nzgrid : nzgrid )) B = 0 sqrt_g = 0 R = 0.0 Z = 0.0 d_B_d_theta_vmec = 0 d_B_d_zeta = 0 d_B_d_s = 0 d_R_d_theta_vmec = 0 d_R_d_zeta = 0 d_R_d_s = 0 d_Z_d_theta_vmec = 0 d_Z_d_zeta = 0 d_Z_d_s = 0 d_Lambda_d_theta_vmec = 0 d_Lambda_d_zeta = 0 d_Lambda_d_s = 0 B_sub_s = 0 B_sub_theta_vmec = 0 B_sub_zeta = 0 B_sup_theta_vmec = 0 B_sup_zeta = 0 !********************************************************************* ! Now that we know the grid points in theta_vmec, we can evaluate ! all the geometric quantities on the grid points. !********************************************************************* do imn_nyq = 1 , mnmax_nyq ! All the quantities we need except R, Z, and Lambda use the _nyq mode numbers. m = int ( xm_nyq ( imn_nyq )) n = int ( xn_nyq ( imn_nyq ) / nfp ) if ( abs ( m ) >= mpol . or . abs ( n ) > ntor ) then non_Nyquist_mode_available = . false . else non_Nyquist_mode_available = . true . ! Find the imn in the non-Nyquist arrays that corresponds to the same m and n. found_imn = . false . do imn = 1 , mnmax if ( xm ( imn ) == m . and . xn ( imn ) == n * nfp ) then found_imn = . true . exit end if end do if (( xm ( imn ) /= m ) . or . ( xn ( imn ) /= n * nfp )) then print * , \"Something went wrong!\" ierr = 118 return end if if (. not . found_imn ) then print * , \"Error! imn could not be found matching the given imn_nyq.\" ierr = 119 return end if end if ! All quantities are multiplied by a variable scale_factor which can in principle depend on m and n. ! For now we just set scale_factor = 1. In the future, scale_factor could be used to lower the ! symmetry-breaking Fourier components, or filter out certain Fourier components in some way. scale_factor = 1 ! ----------------------------------------------------- ! First, consider just the stellarator-symmetric terms: ! ----------------------------------------------------- ! Evaluate the radial derivatives we will need: ! B and Lambda are on the half mesh, so their radial derivatives are on the full mesh. ! R and Z are on the full mesh, so their radial derivatives are on the half mesh. d_B_d_s_mnc ( 2 : ns - 1 ) = ( bmnc ( imn_nyq , 3 : ns ) - bmnc ( imn_nyq , 2 : ns - 1 )) / ds ! Simplistic extrapolation at the endpoints: d_B_d_s_mnc ( 1 ) = d_B_d_s_mnc ( 2 ) d_B_d_s_mnc ( ns ) = d_B_d_s_mnc ( ns - 1 ) if ( non_Nyquist_mode_available ) then ! R is on the full mesh: d_R_d_s_mnc ( 2 : ns ) = ( rmnc ( imn , 2 : ns ) - rmnc ( imn , 1 : ns - 1 )) / ds d_R_d_s_mnc ( 1 ) = 0 ! Z is on the full mesh: d_Z_d_s_mns ( 2 : ns ) = ( zmns ( imn , 2 : ns ) - zmns ( imn , 1 : ns - 1 )) / ds d_Z_d_s_mns ( 1 ) = 0 ! Lambda is on the half mesh: d_Lambda_d_s_mns ( 2 : ns - 1 ) = ( lmns ( imn , 3 : ns ) - lmns ( imn , 2 : ns - 1 )) / ds ! Simplistic extrapolation at the endpoints: d_Lambda_d_s_mns ( 1 ) = d_Lambda_d_s_mns ( 2 ) d_Lambda_d_s_mns ( ns ) = d_Lambda_d_s_mns ( ns - 1 ) else d_R_d_s_mnc = 0 d_Z_d_s_mns = 0 d_Lambda_d_s_mns = 0 end if ! End of evaluating radial derivatives. do ialpha = 1 , nalpha do izeta = - nzgrid , nzgrid angle = m * theta_vmec ( ialpha , izeta ) - n * nfp * zeta ( izeta ) cos_angle = cos ( angle ) sin_angle = sin ( angle ) do isurf = 1 , 2 ! Handle |B|: temp = bmnc ( imn_nyq , vmec_radial_index_half ( isurf )) * vmec_radial_weight_half ( isurf ) temp = temp * scale_factor B ( ialpha , izeta ) = B ( ialpha , izeta ) + temp * cos_angle d_B_d_theta_vmec ( ialpha , izeta ) = d_B_d_theta_vmec ( ialpha , izeta ) - m * temp * sin_angle d_B_d_zeta ( ialpha , izeta ) = d_B_d_zeta ( ialpha , izeta ) + n * nfp * temp * sin_angle ! Handle Jacobian: temp = gmnc ( imn_nyq , vmec_radial_index_half ( isurf )) * vmec_radial_weight_half ( isurf ) temp = temp * scale_factor sqrt_g ( ialpha , izeta ) = sqrt_g ( ialpha , izeta ) + temp * cos_angle ! Handle B sup theta: temp = bsupumnc ( imn_nyq , vmec_radial_index_half ( isurf )) * vmec_radial_weight_half ( isurf ) temp = temp * scale_factor B_sup_theta_vmec ( ialpha , izeta ) = B_sup_theta_vmec ( ialpha , izeta ) + temp * cos_angle ! Handle B sup zeta: temp = bsupvmnc ( imn_nyq , vmec_radial_index_half ( isurf )) * vmec_radial_weight_half ( isurf ) temp = temp * scale_factor B_sup_zeta ( ialpha , izeta ) = B_sup_zeta ( ialpha , izeta ) + temp * cos_angle ! Handle B sub theta: temp = bsubumnc ( imn_nyq , vmec_radial_index_half ( isurf )) * vmec_radial_weight_half ( isurf ) temp = temp * scale_factor B_sub_theta_vmec ( ialpha , izeta ) = B_sub_theta_vmec ( ialpha , izeta ) + temp * cos_angle ! Handle B sub zeta: temp = bsubvmnc ( imn_nyq , vmec_radial_index_half ( isurf )) * vmec_radial_weight_half ( isurf ) temp = temp * scale_factor B_sub_zeta ( ialpha , izeta ) = B_sub_zeta ( ialpha , izeta ) + temp * cos_angle ! Handle B sub psi. ! Unlike the other components of B, this one is on the full mesh. temp = bsubsmns ( imn_nyq , vmec_radial_index_full ( isurf )) * vmec_radial_weight_full ( isurf ) temp = temp * scale_factor B_sub_s ( ialpha , izeta ) = B_sub_s ( ialpha , izeta ) + temp * sin_angle ! Handle d B / d s ! Since bmnc is on the half mesh, its radial derivative is on the full mesh. temp = d_B_d_s_mnc ( vmec_radial_index_full ( isurf )) * vmec_radial_weight_full ( isurf ) temp = temp * scale_factor d_B_d_s ( ialpha , izeta ) = d_B_d_s ( ialpha , izeta ) + temp * cos_angle ! Handle arrays that use xm and xn instead of xm_nyq and xn_nyq. if ( non_Nyquist_mode_available ) then ! Handle R, which is on the full mesh temp = rmnc ( imn , vmec_radial_index_full ( isurf )) * vmec_radial_weight_full ( isurf ) temp = temp * scale_factor R ( ialpha , izeta ) = R ( ialpha , izeta ) + temp * cos_angle d_R_d_theta_vmec ( ialpha , izeta ) = d_R_d_theta_vmec ( ialpha , izeta ) - temp * m * sin_angle d_R_d_zeta ( ialpha , izeta ) = d_R_d_zeta ( ialpha , izeta ) + temp * n * nfp * sin_angle ! Handle Z, which is on the full mesh temp = zmns ( imn , vmec_radial_index_full ( isurf )) * vmec_radial_weight_full ( isurf ) temp = temp * scale_factor Z ( ialpha , izeta ) = Z ( ialpha , izeta ) + temp * sin_angle !Z(ialpha,izeta) = Z(ialpha,izeta) + temp * sin_angle  ! We don't actually need Z itself, only derivatives of Z. d_Z_d_theta_vmec ( ialpha , izeta ) = d_Z_d_theta_vmec ( ialpha , izeta ) + temp * m * cos_angle d_Z_d_zeta ( ialpha , izeta ) = d_Z_d_zeta ( ialpha , izeta ) - temp * n * nfp * cos_angle ! Handle Lambda: temp = lmns ( imn , vmec_radial_index_half ( isurf )) * vmec_radial_weight_half ( isurf ) temp = temp * scale_factor ! We don't need Lambda itself, just its derivatives. d_Lambda_d_theta_vmec ( ialpha , izeta ) = d_Lambda_d_theta_vmec ( ialpha , izeta ) + m * temp * cos_angle d_Lambda_d_zeta ( ialpha , izeta ) = d_Lambda_d_zeta ( ialpha , izeta ) - n * nfp * temp * cos_angle ! Handle d R / d s ! Since R is on the full mesh, its radial derivative is on the half mesh. temp = d_R_d_s_mnc ( vmec_radial_index_half ( isurf )) * vmec_radial_weight_half ( isurf ) temp = temp * scale_factor d_R_d_s ( ialpha , izeta ) = d_R_d_s ( ialpha , izeta ) + temp * cos_angle ! Handle d Z / d s ! Since Z is on the full mesh, its radial derivative is on the half mesh. temp = d_Z_d_s_mns ( vmec_radial_index_half ( isurf )) * vmec_radial_weight_half ( isurf ) temp = temp * scale_factor d_Z_d_s ( ialpha , izeta ) = d_Z_d_s ( ialpha , izeta ) + temp * sin_angle ! Handle d Lambda / d s ! Since Lambda is on the half mesh, its radial derivative is on the full mesh. temp = d_Lambda_d_s_mns ( vmec_radial_index_full ( isurf )) * vmec_radial_weight_full ( isurf ) temp = temp * scale_factor d_Lambda_d_s ( ialpha , izeta ) = d_Lambda_d_s ( ialpha , izeta ) + temp * sin_angle end if end do end do end do ! ----------------------------------------------------- ! Now consider the stellarator-asymmetric terms. ! ----------------------------------------------------- if ( lasym ) then ! Evaluate the radial derivatives we will need: ! B and Lambda are on the half mesh, so their radial derivatives are on the full mesh. ! R and Z are on the full mesh, so their radial derivatives are on the half mesh. d_B_d_s_mns ( 2 : ns - 1 ) = ( bmns ( imn_nyq , 3 : ns ) - bmns ( imn_nyq , 2 : ns - 1 )) / ds ! Simplistic extrapolation at the endpoints: d_B_d_s_mns ( 1 ) = d_B_d_s_mns ( 2 ) d_B_d_s_mns ( ns ) = d_B_d_s_mns ( ns - 1 ) if ( non_Nyquist_mode_available ) then ! R is on the full mesh: d_R_d_s_mns ( 2 : ns ) = ( rmns ( imn , 2 : ns ) - rmns ( imn , 1 : ns - 1 )) / ds d_R_d_s_mns ( 1 ) = 0 ! Z is on the full mesh: d_Z_d_s_mnc ( 2 : ns ) = ( zmnc ( imn , 2 : ns ) - zmnc ( imn , 1 : ns - 1 )) / ds d_Z_d_s_mnc ( 1 ) = 0 ! Lambda is on the half mesh: d_Lambda_d_s_mnc ( 2 : ns - 1 ) = ( lmnc ( imn_nyq , 3 : ns ) - lmnc ( imn_nyq , 2 : ns - 1 )) / ds ! Simplistic extrapolation at the endpoints: d_Lambda_d_s_mnc ( 1 ) = d_Lambda_d_s_mnc ( 2 ) d_Lambda_d_s_mnc ( ns ) = d_Lambda_d_s_mnc ( ns - 1 ) else d_R_d_s_mns = 0 d_Z_d_s_mnc = 0 d_Lambda_d_s_mnc = 0 end if ! End of evaluating radial derivatives. do ialpha = 1 , nalpha do izeta = - nzgrid , nzgrid angle = m * theta_vmec ( ialpha , izeta ) - n * nfp * zeta ( izeta ) cos_angle = cos ( angle ) sin_angle = sin ( angle ) do isurf = 1 , 2 ! Handle |B|: temp = bmns ( imn_nyq , vmec_radial_index_half ( 1 )) * vmec_radial_weight_half ( 1 ) temp = temp * scale_factor B ( ialpha , izeta ) = B ( ialpha , izeta ) + temp * sin_angle d_B_d_theta_vmec ( ialpha , izeta ) = d_B_d_theta_vmec ( ialpha , izeta ) + m * temp * cos_angle d_B_d_zeta ( ialpha , izeta ) = d_B_d_zeta ( ialpha , izeta ) - n * nfp * temp * cos_angle ! Handle Jacobian: temp = gmns ( imn_nyq , vmec_radial_index_half ( isurf )) * vmec_radial_weight_half ( isurf ) temp = temp * scale_factor sqrt_g ( ialpha , izeta ) = sqrt_g ( ialpha , izeta ) + temp * sin_angle ! Handle B sup theta: temp = bsupumns ( imn_nyq , vmec_radial_index_half ( isurf )) * vmec_radial_weight_half ( isurf ) temp = temp * scale_factor B_sup_theta_vmec ( ialpha , izeta ) = B_sup_theta_vmec ( ialpha , izeta ) + temp * sin_angle ! Handle B sup zeta: temp = bsupvmns ( imn_nyq , vmec_radial_index_half ( isurf )) * vmec_radial_weight_half ( isurf ) temp = temp * scale_factor B_sup_zeta ( ialpha , izeta ) = B_sup_zeta ( ialpha , izeta ) + temp * sin_angle ! Handle B sub theta: temp = bsubumns ( imn_nyq , vmec_radial_index_half ( isurf )) * vmec_radial_weight_half ( isurf ) temp = temp * scale_factor B_sub_theta_vmec ( ialpha , izeta ) = B_sub_theta_vmec ( ialpha , izeta ) + temp * sin_angle ! Handle B sub zeta: temp = bsubvmns ( imn_nyq , vmec_radial_index_half ( isurf )) * vmec_radial_weight_half ( isurf ) temp = temp * scale_factor B_sub_zeta ( ialpha , izeta ) = B_sub_zeta ( ialpha , izeta ) + temp * sin_angle ! Handle B sub psi. ! Unlike the other components of B, this one is on the full mesh. temp = bsubsmnc ( imn_nyq , vmec_radial_index_full ( isurf )) * vmec_radial_weight_full ( isurf ) temp = temp * scale_factor B_sub_s ( ialpha , izeta ) = B_sub_s ( ialpha , izeta ) + temp * cos_angle ! Handle d B / d s. ! Since bmns is on the half mesh, its radial derivative is on the full mesh. temp = d_B_d_s_mns ( vmec_radial_index_full ( isurf )) * vmec_radial_weight_full ( isurf ) temp = temp * scale_factor d_B_d_s ( ialpha , izeta ) = d_B_d_s ( ialpha , izeta ) + temp * sin_angle ! Handle arrays that use xm and xn instead of xm_nyq and xn_nyq. if ( non_Nyquist_mode_available ) then ! Handle R, which is on the full mesh temp = rmns ( imn , vmec_radial_index_full ( isurf )) * vmec_radial_weight_full ( isurf ) temp = temp * scale_factor R ( ialpha , izeta ) = R ( ialpha , izeta ) + temp * sin_angle d_R_d_theta_vmec ( ialpha , izeta ) = d_R_d_theta_vmec ( ialpha , izeta ) + temp * m * cos_angle d_R_d_zeta ( ialpha , izeta ) = d_R_d_zeta ( ialpha , izeta ) - temp * n * nfp * cos_angle ! Handle Z, which is on the full mesh temp = zmnc ( imn , vmec_radial_index_full ( isurf )) * vmec_radial_weight_full ( isurf ) temp = temp * scale_factor Z ( ialpha , izeta ) = Z ( ialpha , izeta ) + temp * cos_angle ! We don't actually need Z itself, only derivatives of Z. d_Z_d_theta_vmec ( ialpha , izeta ) = d_Z_d_theta_vmec ( ialpha , izeta ) - temp * m * sin_angle d_Z_d_zeta ( ialpha , izeta ) = d_Z_d_zeta ( ialpha , izeta ) + temp * n * nfp * sin_angle ! Handle Lambda, which is on the half mesh temp = lmnc ( imn , vmec_radial_index_half ( isurf )) * vmec_radial_weight_half ( isurf ) temp = temp * scale_factor ! We don't actually need Lambda itself, only derivatives of Lambda. d_Lambda_d_theta_vmec ( ialpha , izeta ) = d_Lambda_d_theta_vmec ( ialpha , izeta ) - temp * m * sin_angle d_Lambda_d_zeta ( ialpha , izeta ) = d_Lambda_d_zeta ( ialpha , izeta ) + temp * n * nfp * sin_angle ! Handle d R / d s. ! Since R is on the full mesh, its radial derivative is on the half mesh. temp = d_R_d_s_mns ( vmec_radial_index_half ( isurf )) * vmec_radial_weight_half ( isurf ) temp = temp * scale_factor d_R_d_s ( ialpha , izeta ) = d_R_d_s ( ialpha , izeta ) + temp * sin_angle ! Handle d Z / d s. ! Since Z is on the full mesh, its radial derivative is on the half mesh. temp = d_Z_d_s_mnc ( vmec_radial_index_half ( isurf )) * vmec_radial_weight_half ( isurf ) temp = temp * scale_factor d_Z_d_s ( ialpha , izeta ) = d_Z_d_s ( ialpha , izeta ) + temp * cos_angle ! Handle d Lambda / d s. ! Since Lambda is on the half mesh, its radial derivative is on the full mesh. temp = d_Lambda_d_s_mnc ( vmec_radial_index_full ( isurf )) * vmec_radial_weight_full ( isurf ) temp = temp * scale_factor d_Lambda_d_s ( ialpha , izeta ) = d_Lambda_d_s ( ialpha , izeta ) + temp * cos_angle end if end do end do end do end if end do !********************************************************************* ! Sanity check: If the conversion to theta_pest has been done ! correctly, we should find that ! (B dot grad theta_pest) / (B dot grad zeta) = iota. ! Let's verify this: !********************************************************************* allocate ( B_dot_grad_theta_pest_over_B_dot_grad_zeta ( nalpha , - nzgrid : nzgrid )) ! Compute (B dot grad theta_pest) / (B dot grad zeta): B_dot_grad_theta_pest_over_B_dot_grad_zeta = ( B_sup_theta_vmec * ( 1 + d_Lambda_d_theta_vmec ) + B_sup_zeta * d_Lambda_d_zeta ) / B_sup_zeta temp2D = iota call test_arrays ( B_dot_grad_theta_pest_over_B_dot_grad_zeta , temp2D , . false ., 0.01 , 'iota' , ierr2 ) if ( ierr2 /= 0 ) then print * , \"test_arrays returned error for iota\" ierr = ierr + 1 end if deallocate ( B_dot_grad_theta_pest_over_B_dot_grad_zeta ) !********************************************************************* ! Using R(theta,zeta) and Z(theta,zeta), compute the Cartesian ! components of the gradient basis vectors using the dual relations: !********************************************************************* do izeta = - nzgrid , nzgrid cos_angle = cos ( zeta ( izeta )) sin_angle = sin ( zeta ( izeta )) ! X = R * cos(zeta) d_X_d_theta_vmec (:, izeta ) = d_R_d_theta_vmec (:, izeta ) * cos_angle d_X_d_zeta (:, izeta ) = d_R_d_zeta (:, izeta ) * cos_angle - R (:, izeta ) * sin_angle d_X_d_s (:, izeta ) = d_R_d_s (:, izeta ) * cos_angle ! Y = R * sin(zeta) d_Y_d_theta_vmec (:, izeta ) = d_R_d_theta_vmec (:, izeta ) * sin_angle d_Y_d_zeta (:, izeta ) = d_R_d_zeta (:, izeta ) * sin_angle + R (:, izeta ) * cos_angle d_Y_d_s (:, izeta ) = d_R_d_s (:, izeta ) * sin_angle !!$       ! Y = -R * sin(zeta) !!$       d_Y_d_theta_vmec(:,izeta) = -d_R_d_theta_vmec(:,izeta) * sin_angle !!$       d_Y_d_zeta(:,izeta) = -(d_R_d_zeta(:,izeta) * sin_angle + R(:,izeta) * cos_angle) !!$       d_Y_d_s(:,izeta) = -d_R_d_s(:,izeta) * sin_angle end do ! Use the dual relations to get the Cartesian components of grad s, grad theta_vmec, and grad zeta: grad_s_X = ( d_Y_d_theta_vmec * d_Z_d_zeta - d_Z_d_theta_vmec * d_Y_d_zeta ) / sqrt_g grad_s_Y = ( d_Z_d_theta_vmec * d_X_d_zeta - d_X_d_theta_vmec * d_Z_d_zeta ) / sqrt_g grad_s_Z = ( d_X_d_theta_vmec * d_Y_d_zeta - d_Y_d_theta_vmec * d_X_d_zeta ) / sqrt_g grad_theta_vmec_X = ( d_Y_d_zeta * d_Z_d_s - d_Z_d_zeta * d_Y_d_s ) / sqrt_g grad_theta_vmec_Y = ( d_Z_d_zeta * d_X_d_s - d_X_d_zeta * d_Z_d_s ) / sqrt_g grad_theta_vmec_Z = ( d_X_d_zeta * d_Y_d_s - d_Y_d_zeta * d_X_d_s ) / sqrt_g grad_zeta_X = ( d_Y_d_s * d_Z_d_theta_vmec - d_Z_d_s * d_Y_d_theta_vmec ) / sqrt_g grad_zeta_Y = ( d_Z_d_s * d_X_d_theta_vmec - d_X_d_s * d_Z_d_theta_vmec ) / sqrt_g grad_zeta_Z = ( d_X_d_s * d_Y_d_theta_vmec - d_Y_d_s * d_X_d_theta_vmec ) / sqrt_g ! End of the dual relations. ! next get grad_theta_pest = grad (theta_vmec + Lambda) grad_theta_pest_X = ( 1.0 + d_Lambda_d_theta_vmec ) * grad_theta_vmec_X & + d_Lambda_d_zeta * grad_zeta_X + d_Lambda_d_s * grad_s_X grad_theta_pest_Y = ( 1.0 + d_Lambda_d_theta_vmec ) * grad_theta_vmec_Y & + d_Lambda_d_zeta * grad_zeta_Y + d_Lambda_d_s * grad_s_Y grad_theta_pest_Z = ( 1.0 + d_Lambda_d_theta_vmec ) * grad_theta_vmec_Z & + d_Lambda_d_zeta * grad_zeta_Z + d_Lambda_d_s * grad_s_Z ! Sanity check: grad_zeta_X should be -sin(zeta) / R: do izeta = - nzgrid , nzgrid temp2D (:, izeta ) = - sin ( zeta ( izeta )) / R (:, izeta ) end do call test_arrays ( grad_zeta_X , temp2D , . false ., 1.0e-2 , 'grad_zeta_X' , ierr2 ) if ( ierr2 /= 0 ) then print * , \"test_arrays returned error for grad_zeta_X\" ierr = ierr + 1 end if grad_zeta_X = temp2D ! We might as well use the exact value, which is in temp2D. ! Sanity check: grad_zeta_Y should be cos(zeta) / R: do izeta = - nzgrid , nzgrid temp2D (:, izeta ) = cos ( zeta ( izeta )) / R (:, izeta ) end do call test_arrays ( grad_zeta_Y , temp2D , . false ., 1.0e-2 , 'grad_zeta_Y' , ierr2 ) if ( ierr2 /= 0 ) then print * , \"test_arrays returned error for grad_zeta_Y\" ierr = ierr + 1 end if grad_zeta_Y = temp2D ! We might as well use the exact value, which is in temp2D. ! grad_zeta_Z should be 0: call test_arrays ( grad_zeta_Z , temp2D , . true ., 1.0e-14 , 'grad_zeta_Z' , ierr2 ) if ( ierr2 /= 0 ) then print * , \"test_arrays returned error for grad_zeta_Z\" ierr = ierr + 1 end if grad_zeta_Z = 0 !********************************************************************* ! Compute the Cartesian components of other quantities we need: !********************************************************************* ! In VMEC <s> = psi/psi_LCFS and in stella <psi> = sgn(psi_t)*psi_t ! nabla psi = (dpsi/ds) * nabla s = d(psi_LCFS*s)/ds * nabla s !           = psi_LCFS * nabla s = sgn(psi_t) * psi_{t,LCFS} * nabla s grad_psi_X = grad_s_X * sign_toroidal_flux * edge_toroidal_flux_over_2pi grad_psi_Y = grad_s_Y * sign_toroidal_flux * edge_toroidal_flux_over_2pi grad_psi_Z = grad_s_Z * sign_toroidal_flux * edge_toroidal_flux_over_2pi ! Form grad alpha = grad (theta_vmec + Lambda - iota * zeta) do izeta = - nzgrid , nzgrid grad_alpha_X (:, izeta ) = ( d_Lambda_d_s (:, izeta ) - zeta ( izeta ) * d_iota_d_s ) * grad_s_X (:, izeta ) grad_alpha_Y (:, izeta ) = ( d_Lambda_d_s (:, izeta ) - zeta ( izeta ) * d_iota_d_s ) * grad_s_Y (:, izeta ) grad_alpha_Z (:, izeta ) = ( d_Lambda_d_s (:, izeta ) - zeta ( izeta ) * d_iota_d_s ) * grad_s_Z (:, izeta ) end do grad_alpha_X = grad_alpha_X + ( 1 + d_Lambda_d_theta_vmec ) * grad_theta_vmec_X + ( - iota + d_Lambda_d_zeta ) * grad_zeta_X grad_alpha_Y = grad_alpha_Y + ( 1 + d_Lambda_d_theta_vmec ) * grad_theta_vmec_Y + ( - iota + d_Lambda_d_zeta ) * grad_zeta_Y grad_alpha_Z = grad_alpha_Z + ( 1 + d_Lambda_d_theta_vmec ) * grad_theta_vmec_Z + ( - iota + d_Lambda_d_zeta ) * grad_zeta_Z grad_B_X = d_B_d_s * grad_s_X + d_B_d_theta_vmec * grad_theta_vmec_X + d_B_d_zeta * grad_zeta_X grad_B_Y = d_B_d_s * grad_s_Y + d_B_d_theta_vmec * grad_theta_vmec_Y + d_B_d_zeta * grad_zeta_Y grad_B_Z = d_B_d_s * grad_s_Z + d_B_d_theta_vmec * grad_theta_vmec_Z + d_B_d_zeta * grad_zeta_Z !temp2D = edge_toroidal_flux_over_2pi * ((1 + d_Lambda_d_theta_vmec) * d_R_d_zeta + (iota - d_Lambda_d_zeta) * d_R_d_theta_vmec) / sqrt_g !!$    do izeta = -nzgrid,nzgrid !!$       !B_X(:,izeta) = temp2D(:,izeta) * cos(zeta(izeta)) !!$       !B_Y(:,izeta) = temp2D(:,izeta) * sin(zeta(izeta)) !!$       sin_angle = sin(zeta(izeta)) !!$       cos_angle = cos(zeta(izeta)) !!$       B_X(:,izeta) = edge_toroidal_flux_over_2pi * ((1 + d_Lambda_d_theta_vmec(:,izeta)) * (d_R_d_zeta(:,izeta)*cos_angle - R(:,izeta)*sin_angle) & !!$            + (iota - d_Lambda_d_zeta(:,izeta)) * d_R_d_theta_vmec(:,izeta)*cos_angle) / sqrt_g(:,izeta) !!$       B_Y(:,izeta) = edge_toroidal_flux_over_2pi * ((1 + d_Lambda_d_theta_vmec(:,izeta)) * (d_R_d_zeta(:,izeta)*sin_angle + R(:,izeta)*cos_angle) & !!$            + (iota - d_Lambda_d_zeta(:,izeta)) * d_R_d_theta_vmec(:,izeta)*sin_angle) / sqrt_g(:,izeta) !!$    end do B_X = edge_toroidal_flux_over_2pi * (( 1 + d_Lambda_d_theta_vmec ) * d_X_d_zeta + ( iota - d_Lambda_d_zeta ) * d_X_d_theta_vmec ) / sqrt_g B_Y = edge_toroidal_flux_over_2pi * (( 1 + d_Lambda_d_theta_vmec ) * d_Y_d_zeta + ( iota - d_Lambda_d_zeta ) * d_Y_d_theta_vmec ) / sqrt_g B_Z = edge_toroidal_flux_over_2pi * (( 1 + d_Lambda_d_theta_vmec ) * d_Z_d_zeta + ( iota - d_Lambda_d_zeta ) * d_Z_d_theta_vmec ) / sqrt_g sqrt_s = sqrt ( normalized_toroidal_flux_used ) !********************************************************************* ! Sanity tests: Verify that the Jacobian equals the appropriate ! cross product of the basis vectors. !********************************************************************* temp2D = 0 & + d_X_d_s * d_Y_d_theta_vmec * d_Z_d_zeta & + d_Y_d_s * d_Z_d_theta_vmec * d_X_d_zeta & + d_Z_d_s * d_X_d_theta_vmec * d_Y_d_zeta & - d_Z_d_s * d_Y_d_theta_vmec * d_X_d_zeta & - d_X_d_s * d_Z_d_theta_vmec * d_Y_d_zeta & - d_Y_d_s * d_X_d_theta_vmec * d_Z_d_zeta call test_arrays ( sqrt_g , temp2D , . false ., 3.0e-3 , 'sqrt_g' , ierr2 ) if ( ierr2 /= 0 ) then print * , \"test_arrays returned error for sqrt g\" ierr = ierr + 1 end if temp2D = 0 & + grad_s_X * grad_theta_vmec_Y * grad_zeta_Z & + grad_s_Y * grad_theta_vmec_Z * grad_zeta_X & + grad_s_Z * grad_theta_vmec_X * grad_zeta_Y & - grad_s_Z * grad_theta_vmec_Y * grad_zeta_X & - grad_s_X * grad_theta_vmec_Z * grad_zeta_Y & - grad_s_Y * grad_theta_vmec_X * grad_zeta_Z call test_arrays ( 1 / sqrt_g , temp2D , . false ., 1.0e-2 , '1/sqrt_g' , ierr2 ) if ( ierr2 /= 0 ) then print * , \"test_arrays returned error for 1/sqrt g\" ierr = ierr + 1 end if !********************************************************************* ! Sanity tests: Verify that ! \\vec{B} dot (each of the covariant and contravariant basis vectors) ! matches the corresponding term from VMEC. !********************************************************************* call test_arrays ( B_X * d_X_d_theta_vmec + B_Y * d_Y_d_theta_vmec + B_Z * d_Z_d_theta_vmec , B_sub_theta_vmec , . false ., 1.0e-2 , 'B_sub_theta_vmec' , ierr2 ) if ( ierr2 /= 0 ) then print * , \"test_arrays returned error for B_sub_theta_vmec\" ierr = ierr + 1 end if call test_arrays ( B_X * d_X_d_s + B_Y * d_Y_d_s + B_Z * d_Z_d_s , B_sub_s , . false ., 1.0e-2 , 'B_sub_s' , ierr2 ) if ( ierr2 /= 0 ) then print * , \"test_arrays returned error for B_sub_s\" ierr = ierr + 1 end if call test_arrays ( B_X * d_X_d_zeta + B_Y * d_Y_d_zeta + B_Z * d_Z_d_zeta , B_sub_zeta , . false ., 1.0e-2 , 'B_sub_zeta' , ierr2 ) if ( ierr2 /= 0 ) then print * , \"test_arrays returned error for B_sub_zeta\" ierr = ierr + 1 end if call test_arrays ( B_X * grad_s_X + B_Y * grad_s_Y + B_Z * grad_s_Z , temp2D , . true ., 1.0e-2 , 'B_sup_s' , ierr2 ) if ( ierr2 /= 0 ) then print * , \"test_arrays returned error for B_sup_s\" ierr = ierr + 1 end if call test_arrays ( B_X * grad_zeta_X + B_Y * grad_zeta_Y + B_Z * grad_zeta_Z , B_sup_zeta , . false ., 1.0e-2 , 'B_sup_zeta' , ierr2 ) if ( ierr2 /= 0 ) then print * , \"test_arrays returned error for B_sup_zeta\" ierr = ierr + 1 end if call test_arrays ( B_X * grad_theta_vmec_X + B_Y * grad_theta_vmec_Y + B_Z * grad_theta_vmec_Z , B_sup_theta_vmec , . false ., 1.0e-2 , 'B_sup_theta_vmec' , ierr2 ) if ( ierr2 /= 0 ) then print * , \"test_arrays returned error for B_sup_theta_vmec\" ierr = ierr + 1 end if !********************************************************************* ! For gbdrift, we need \\vect{B} cross grad |B| dot grad alpha. ! For cvdrift, we also need \\vect{B} cross grad s dot grad alpha. ! Let us compute both of these quantities 2 ways, and make sure the two ! approaches give the same answer (within some tolerance). !********************************************************************* B_cross_grad_s_dot_grad_alpha = ( B_sub_zeta * ( 1 + d_Lambda_d_theta_vmec ) & - B_sub_theta_vmec * ( d_Lambda_d_zeta - iota )) / sqrt_g B_cross_grad_s_dot_grad_alpha_alternate = 0 & + B_X * grad_s_Y * grad_alpha_Z & + B_Y * grad_s_Z * grad_alpha_X & + B_Z * grad_s_X * grad_alpha_Y & - B_Z * grad_s_Y * grad_alpha_X & - B_X * grad_s_Z * grad_alpha_Y & - B_Y * grad_s_X * grad_alpha_Z call test_arrays ( B_cross_grad_s_dot_grad_alpha , B_cross_grad_s_dot_grad_alpha_alternate , & . false ., 1.0e-2 , 'B_cross_grad_s_dot_grad_alpha' , ierr2 ) if ( ierr2 /= 0 ) then print * , \"test_arrays returned error for B_cross_grad_s_dot_grad_alpha\" ierr = ierr + 1 end if do izeta = - nzgrid , nzgrid B_cross_grad_B_dot_grad_alpha (:, izeta ) = 0 & + ( B_sub_s (:, izeta ) * d_B_d_theta_vmec (:, izeta ) * ( d_Lambda_d_zeta (:, izeta ) - iota ) & + B_sub_theta_vmec (:, izeta ) * d_B_d_zeta (:, izeta ) * ( d_Lambda_d_s (:, izeta ) - zeta ( izeta ) * d_iota_d_s ) & + B_sub_zeta (:, izeta ) * d_B_d_s (:, izeta ) * ( 1 + d_Lambda_d_theta_vmec (:, izeta )) & - B_sub_zeta (:, izeta ) * d_B_d_theta_vmec (:, izeta ) * ( d_Lambda_d_s (:, izeta ) - zeta ( izeta ) * d_iota_d_s ) & - B_sub_theta_vmec (:, izeta ) * d_B_d_s (:, izeta ) * ( d_Lambda_d_zeta (:, izeta ) - iota ) & - B_sub_s (:, izeta ) * d_B_d_zeta (:, izeta ) * ( 1 + d_Lambda_d_theta_vmec (:, izeta ))) / sqrt_g (:, izeta ) end do B_cross_grad_B_dot_grad_alpha_alternate = 0 & + B_X * grad_B_Y * grad_alpha_Z & + B_Y * grad_B_Z * grad_alpha_X & + B_Z * grad_B_X * grad_alpha_Y & - B_Z * grad_B_Y * grad_alpha_X & - B_X * grad_B_Z * grad_alpha_Y & - B_Y * grad_B_X * grad_alpha_Z call test_arrays ( B_cross_grad_B_dot_grad_alpha , B_cross_grad_B_dot_grad_alpha_alternate , & . false ., 1.0e-2 , 'B_cross_grad_B_dot_grad_alpha' , ierr2 ) if ( ierr2 /= 0 ) then print * , \"test_arrays returned error for B_cross_grad_B_dot_grad_alpha\" ierr = ierr + 1 end if !********************************************************************* ! Finally, assemble the quantities needed for stella. !********************************************************************* ! See the latex note gs2_full_surface_stellarator_geometry in the \"doc\" directory for a derivation of the formulae that follow. bmag = B / B_reference gradpar_zeta = gradpar_zeta_prefac * L_reference * B_sup_zeta / B ! grad alpha . grad alpha in units of 1/L_ref&#94;2, with alpha = theta_pest - iota * zeta grad_alpha_grad_alpha = L_reference * L_reference * ( grad_alpha_X * grad_alpha_X + grad_alpha_Y * grad_alpha_Y + grad_alpha_Z * grad_alpha_Z ) ! this is grad alpha . grad psi_t in units of B_reference grad_alpha_grad_psi = ( grad_alpha_X * grad_psi_X + grad_alpha_Y * grad_psi_Y + grad_alpha_Z * grad_psi_Z ) / B_reference ! this is grad psi_t . grad psi_t in units of (B_reference*L_reference)&#94;2 grad_psi_grad_psi = ( grad_psi_X * grad_psi_X + grad_psi_Y * grad_psi_Y + grad_psi_Z * grad_psi_Z ) & / ( L_reference * L_reference * B_reference * B_reference ) ! dx/dpsitor = sign_torflux/rhotor/Lref/Bref ! dy/dalpha = Lref*rhotor ! this is shat * grad x . grad y = shat * (grad psi_tor . grad alpha) * dx/dpsi_tor * dy/dalpha ! = sign_torflux * shat * (grad psi_tor . grad alpha) / Bref !    gds21 = (grad_alpha_X * grad_psi_X + grad_alpha_Y * grad_psi_Y + grad_alpha_Z * grad_psi_Z) & !         * sign_toroidal_flux * shat / B_reference ! this is shat&#94;2 * | grad x | &#94;2 = shat&#94;2 * |grad psi_tor|&#94;2 * (dx/dpsitor)&#94;2 ! = shat&#94;2 * |grad psi_tor|&#94;2 * / rhotor&#94;2 / Lref&#94;2 / Bref&#94;2 !    gds22 = (grad_psi_X * grad_psi_X + grad_psi_Y * grad_psi_Y + grad_psi_Z * grad_psi_Z) & !         * shat * shat / (L_reference * L_reference * B_reference * B_reference * normalized_toroidal_flux_used) ! Define <gradzeta_gradx> = (grad zeta . grad x) / (B/Bref)&#94;2 ! gradzeta_gradx = (grad zeta . grad x) / bmag&#94;2 = (grad zeta . grad psi) * dx/dpsi / bmag&#94;2 !                = (grad zeta . grad psi) / (rhotor*Lref*Bref) / bmag&#94;2 gradzeta_gradx = ( grad_zeta_X * grad_psi_X + grad_zeta_Y * grad_psi_Y + grad_zeta_Z * grad_psi_Z ) & / ( L_reference * B_reference * sqrt ( normalized_toroidal_flux_used ) * bmag ** 2 ) ! this is (grad zeta . grad y_stella) / bmag&#94;2 = (grad zeta . grad alpha) * dy/dalpha / bmag&#94;2 ! = (grad zeta . grad alpha) * Lref * rhotor / bmag&#94;2 gradzeta_grady = ( grad_zeta_X * grad_alpha_X + grad_zeta_Y * grad_alpha_Y + grad_zeta_Z * grad_alpha_Z ) & * L_reference * sqrt ( normalized_toroidal_flux_used ) / bmag ** 2 ! this is (grad theta_pest . grad x_stella) / bmag&#94;2 gradtheta_gradx = ( grad_theta_pest_X * grad_psi_X + grad_theta_pest_Y * grad_psi_Y & + grad_theta_pest_Z * grad_psi_Z ) & / ( L_reference * B_reference * sqrt ( normalized_toroidal_flux_used ) * bmag ** 2 ) ! this is (grad theta_pest . grad y_stella) / bmag&#94;2 gradtheta_grady = ( grad_theta_pest_X * grad_alpha_X + grad_theta_pest_Y * grad_alpha_Y & + grad_theta_pest_Z * grad_alpha_Z ) & * L_reference * sqrt ( normalized_toroidal_flux_used ) / bmag ** 2 ! Define <gds23> = sgn(psi_t)/(B/Bref)&#94;2 * [(∇y . ∇ζ) * (∇x . ∇y) - (∇x . ∇ζ) * |∇y|&#94;2] ! Use ∇x . ∇y = (dy/dα)(dx/dψ) ∇α . ∇ψ = (1/Bref) ∇α . ∇ψ = <grad_alpha_grad_psi> ! Use |∇y|&#94;2 = (dy/dα)&#94;2 |∇α|&#94;2 = a&#94;2 ρ&#94;2 |∇α|&#94;2 = a&#94;2 |∇α|&#94;2 * ρ&#94;2 = <grad_alpha_grad_alpha> * <rhotor>&#94;2 ! Use (∇y . ∇ζ)/(B/Bref)&#94;2 = <gradzeta_grady> and (∇x . ∇ζ)/(B/Bref)&#94;2 = <gradzeta_gradx> ! Use ρ = sqrt(psi_t/psi_{t,LCFS}) thus ρ&#94;2 = s = psi_t/psi_{t,LCFS} = <normalized_toroidal_flux_used> ! <gds23> = sgn(psi_t)*(gradzeta_grady*grad_alpha_grad_psi - gradzeta_gradx*grad_alpha_grad_alpha*rhotor&#94;2) gds23 = sign_toroidal_flux * ( gradzeta_grady * grad_alpha_grad_psi - gradzeta_gradx * grad_alpha_grad_alpha * normalized_toroidal_flux_used ) ! Define <gds24> = sgn(psi_t)/(B/Bref)&#94;2 * [(∇y . ∇ζ) * |∇x|&#94;2 - (∇x . ∇ζ) * (∇x . ∇y)] ! Use ∇x . ∇y = (dy/dα)(dx/dψ) ∇α . ∇ψ = (1/Bref) ∇α . ∇ψ = <grad_alpha_grad_psi> ! Use |∇x|&#94;2 = (dx/dψ)&#94;2 |∇ψ|&#94;2 = 1/(a&#94;2 ρ&#94;2 Bref&#94;2) |∇ψ|&#94;2 = 1/(a&#94;2 Bref&#94;2) |∇ψ|&#94;2 * 1/ρ&#94;2  = <grad_psi_grad_psi> / <rhotor>&#94;2 ! Use (∇y . ∇ζ)/(B/Bref)&#94;2 = <gradzeta_grady> and (∇x . ∇ζ)/(B/Bref)&#94;2 = <gradzeta_gradx> ! Use ρ = sqrt(psi_t/psi_{t,LCFS}) thus ρ&#94;2 = s = psi_t/psi_{t,LCFS} = <normalized_toroidal_flux_used> ! <gds24> = sgn(psi_t)*(gradzeta_grady*grad_psi_grad_psi/rhotor&#94;2 - gradzeta_gradx*grad_alpha_grad_psi) gds24 = sign_toroidal_flux * ( gradzeta_grady * grad_psi_grad_psi / normalized_toroidal_flux_used - gradzeta_gradx * grad_alpha_grad_psi ) ! Define <gds25> = sgn(psi_t)/(B/Bref)&#94;2 * [(∇y . ∇θp) * |∇x|&#94;2 - (∇x . ∇θp) * (∇x . ∇y)] ! Use ∇x . ∇y = (dy/dα)(dx/dψ) ∇α . ∇ψ = (1/Bref) ∇α . ∇ψ = <grad_alpha_grad_psi> ! Use |∇y|&#94;2 = (dy/dα)&#94;2 |∇α|&#94;2 = a&#94;2 ρ&#94;2 |∇α|&#94;2 = a&#94;2 |∇α|&#94;2 * ρ&#94;2 = <grad_alpha_grad_alpha> * <rhotor>&#94;2 ! Use (∇y . ∇θp)/(B/Bref)&#94;2 = <gradtheta_grady> and (∇x . ∇θp)/(B/Bref)&#94;2 = <gradtheta_gradx> ! Use ρ = sqrt(psi_t/psi_{t,LCFS}) thus ρ&#94;2 = s = psi_t/psi_{t,LCFS} = <normalized_toroidal_flux_used> ! <gds25> = sgn(psi_t)*(gradtheta_grady*grad_alpha_grad_psi - gradtheta_gradx*grad_alpha_grad_alpha*rhotor&#94;2) ! Note that <gds25> was wrong before 17/09/2023 (branch upgrade_clockwise_vmecs) for CCW equilibria gds25 = gradtheta_grady * grad_alpha_grad_psi - gradtheta_gradx * grad_alpha_grad_alpha * normalized_toroidal_flux_used ! Define <gds26> = 1/2 * sgn(psi_t)/(B/Bref)&#94;2 * [(∇y . ∇θp) * |∇x|&#94;2 - (∇x . ∇θp) * (∇x . ∇y)] ! Use ∇x . ∇y = (dy/dα)(dx/dψ) ∇α . ∇ψ = (1/Bref) ∇α . ∇ψ = <grad_alpha_grad_psi> ! Use |∇x|&#94;2 = (dx/dψ)&#94;2 |∇ψ|&#94;2 = 1/(a&#94;2 ρ&#94;2 Bref&#94;2) |∇ψ|&#94;2 = 1/(a&#94;2 Bref&#94;2) |∇ψ|&#94;2 * 1/ρ&#94;2  = <grad_psi_grad_psi> / <rhotor>&#94;2 ! Use (∇y . ∇θp)/(B/Bref)&#94;2 = <gradtheta_grady> and (∇x . ∇θp)/(B/Bref)&#94;2 = <gradtheta_gradx> ! Use ρ = sqrt(psi_t/psi_{t,LCFS}) thus ρ&#94;2 = s = psi_t/psi_{t,LCFS} = <normalized_toroidal_flux_used> ! <gds26> = 0.5*sgn(psi_t)*(gradtheta_grady*grad_psi_grad_psi/rhotor&#94;2 - gradtheta_gradx*grad_alpha_grad_psi) ! Note that <gds26> was wrong before 17/09/2023 (branch upgrade_clockwise_vmecs) for CCW equilibria gds26 = 0.5 * ( gradtheta_grady * grad_psi_grad_psi / normalized_toroidal_flux_used - gradtheta_gradx * grad_alpha_grad_psi ) gbdrift_alpha = 2 * B_reference * L_reference * L_reference * B_cross_grad_B_dot_grad_alpha & / ( B * B * B ) !    gbdrift = 2 * B_reference * L_reference * L_reference * sqrt_s * B_cross_grad_B_dot_grad_alpha & ! Define <gbdrift0_psi> = hat{s} * (2/B&#94;3) * B x ∇B · ∇ψ ! Use hat{s} * (2/B&#94;3) = 2 * shat / (B * B * B) ! Use B x ∇B · ∇ψ = psi_LCFS / sqrt(g) * ( ∂B/∂ζ * Btheta - ∂B/∂θ * Bzeta ) ! Use psi_LCFS = sgn(psi_t) * psi_{t,LCFS} = <sign_toroidal_flux> * <edge_toroidal_flux_over_2pi> gbdrift0_psi = sign_toroidal_flux * edge_toroidal_flux_over_2pi * ( B_sub_theta_vmec * d_B_d_zeta & - B_sub_zeta * d_B_d_theta_vmec ) / sqrt_g * 2 * shat / ( B * B * B ) !    gbdrift0 = (B_sub_theta_vmec * d_B_d_zeta - B_sub_zeta * d_B_d_theta_vmec) / sqrt_g * edge_toroidal_flux_over_2pi & !    gbdrift0 = abs(edge_toroidal_flux_over_2pi) & !         * (B_sub_theta_vmec * d_B_d_zeta - B_sub_zeta * d_B_d_theta_vmec) / sqrt_g & !         * 2 * shat / (B * B * B * sqrt_s) ! In the above 2-line expression for gbdrift0, the first line is \\vec{B} \\times \\nabla B \\cdot \\nabla \\psi. cvdrift_alpha = gbdrift_alpha + 2 * B_reference * L_reference * L_reference * mu_0 * d_pressure_d_s & * B_cross_grad_s_dot_grad_alpha / ( B * B * B * B ) !    cvdrift = gbdrift + 2 * B_reference * L_reference * L_reference * sqrt_s * mu_0 * d_pressure_d_s & !         * B_cross_grad_s_dot_grad_alpha / (B * B * B * B) cvdrift0_psi = gbdrift0_psi ! calculate the ratio of the physical displacement due to movement in the stella x-coordinate to the x-coordinate itself ! This is |ds/dx|*sqrt((dR/ds)&#94;2+(dZ/ds)&#94;2) x_displacement_fac = 2.0 * sqrt ( normalized_toroidal_flux_used ) * sqrt ( d_R_d_s ** 2 + d_Z_d_s ** 2 ) / L_reference !********************************************************************* ! Free all arrays that were allocated. !********************************************************************* deallocate ( B ) deallocate ( temp2D ) deallocate ( sqrt_g ) deallocate ( R , Z ) deallocate ( d_B_d_theta_vmec ) deallocate ( d_B_d_zeta ) deallocate ( d_B_d_s ) deallocate ( d_R_d_theta_vmec ) deallocate ( d_R_d_zeta ) deallocate ( d_R_d_s ) deallocate ( d_Z_d_theta_vmec ) deallocate ( d_Z_d_zeta ) deallocate ( d_Z_d_s ) deallocate ( d_Lambda_d_theta_vmec ) deallocate ( d_Lambda_d_zeta ) deallocate ( d_Lambda_d_s ) deallocate ( B_sub_s ) !deallocate(B_sub_theta_vmec) !deallocate(B_sub_zeta) deallocate ( B_sup_theta_vmec ) deallocate ( B_sup_zeta ) deallocate ( d_B_d_s_mnc ) deallocate ( d_B_d_s_mns ) deallocate ( d_R_d_s_mnc ) deallocate ( d_R_d_s_mns ) deallocate ( d_Z_d_s_mnc ) deallocate ( d_Z_d_s_mns ) deallocate ( d_Lambda_d_s_mnc ) deallocate ( d_Lambda_d_s_mns ) deallocate ( d_X_d_s ) deallocate ( d_X_d_theta_vmec ) deallocate ( d_X_d_zeta ) deallocate ( d_Y_d_s ) deallocate ( d_Y_d_theta_vmec ) deallocate ( d_Y_d_zeta ) deallocate ( grad_s_X ) deallocate ( grad_s_Y ) deallocate ( grad_s_Z ) deallocate ( grad_theta_vmec_X ) deallocate ( grad_theta_vmec_Y ) deallocate ( grad_theta_vmec_Z ) deallocate ( grad_theta_pest_X ) deallocate ( grad_theta_pest_Y ) deallocate ( grad_theta_pest_Z ) deallocate ( grad_zeta_X ) deallocate ( grad_zeta_Y ) deallocate ( grad_zeta_Z ) deallocate ( grad_psi_X ) deallocate ( grad_psi_Y ) deallocate ( grad_psi_Z ) deallocate ( grad_alpha_X ) deallocate ( grad_alpha_Y ) deallocate ( grad_alpha_Z ) deallocate ( B_X ) deallocate ( B_Y ) deallocate ( B_Z ) deallocate ( grad_B_X ) deallocate ( grad_B_Y ) deallocate ( grad_B_Z ) deallocate ( B_cross_grad_B_dot_grad_alpha ) deallocate ( B_cross_grad_B_dot_grad_alpha_alternate ) deallocate ( B_cross_grad_s_dot_grad_alpha ) deallocate ( B_cross_grad_s_dot_grad_alpha_alternate ) deallocate ( gradzeta_grady ) deallocate ( gradzeta_gradx ) deallocate ( gradtheta_grady ) deallocate ( gradtheta_gradx ) deallocate ( normalized_toroidal_flux_full_grid ) deallocate ( normalized_toroidal_flux_half_grid ) if ( verbose ) then write ( * , * ) \"Leaving vmec_to_stella_geometry_interface.\" write ( * , * ) end if if ( allocated ( rmnc )) then deallocate ( xm , xn ) deallocate ( xm_nyq , xn_nyq ) deallocate ( rmnc , lmns , zmns , bmnc , gmnc ) deallocate ( bsupumnc , bsupvmnc , bsubumnc , bsubvmnc , bsubsmns ) deallocate ( phi , phip , iotas , iotaf , presf ) end if if ( allocated ( rmns )) then deallocate ( rmns , lmnc , zmnc , bmns , gmns ) deallocate ( bsupumns , bsupvmns , bsubumns , bsubvmns , bsubsmnc ) end if contains subroutine test_arrays ( array1 , array2 , should_be_0 , tolerance , name , ierr ) ! This subroutine is used for verifying the geometry arrays. ! When should_be_0 = .true., the subroutine verifies that |array1| = 0 to within !     an absolute tolerance specified by 'tolerance'. array2 is ignored in this case. ! When should_be_0 = .false., the subroutine verifies that array1 = array2 !     to within a relative tolerance specified by 'tolerance'. implicit none real , dimension ( nalpha , - nzgrid : nzgrid ) :: array1 , array2 real :: tolerance character ( len =* ) :: name logical :: should_be_0 real :: max_value , max_difference integer , intent ( out ) :: ierr ierr = 0 if ( should_be_0 ) then max_value = maxval ( abs ( array1 )) !         if (verbose) print *,\"  maxval(abs(\",trim(name),\")):\",max_value,\"(should be << 1.)\" if ( max_value > tolerance ) then ierr = 1 print * , \"Error! \" , trim ( name ), \" should be 0, but instead it is:\" do ialpha = 1 , nalpha print * , array1 ( ialpha , :) end do end if else max_difference = maxval ( abs ( array1 - array2 )) / maxval ( abs ( array1 ) + abs ( array2 )) !         if (verbose) print *,\"  Relative difference between two methods for computing \",trim(name),\":\",max_difference,\"(should be << 1.)\" if ( max_difference > tolerance ) then ierr = 1 print * , \"Error! Two methods for computing \" , trim ( name ), \" disagree. Here comes method 1:\" do ialpha = 1 , nalpha print * , array1 ( ialpha , :) end do print * , \"Here comes method 2:\" do ialpha = 1 , nalpha print * , array2 ( ialpha , :) end do print * , \"Here comes the difference:\" do ialpha = 1 , nalpha print * , array1 ( ialpha , :) - array2 ( ialpha , :) end do end if end if end subroutine test_arrays end subroutine vmec_to_stella_geometry_interface subroutine get_root ( a0 , b0 , root , converged ) implicit none real , intent ( in ) :: a0 , b0 real , intent ( out ) :: root logical , intent ( out ) :: converged integer , parameter :: itmax_bracket = 10 integer , parameter :: itmax_root = 10 real , parameter :: tol = 1.0e-10 integer :: it real :: a , b , c , d , e , fa , fb , fc , p , q , r , s , tol1 , xm , eps a = a0 b = b0 fa = fzero_residual ( a ) fb = fzero_residual ( b ) do it = 1 , itmax_bracket eps = epsilon ( a ) if (( fa > 0.0 . and . fb > 0.0 ) . or . ( fa < 0.0 . and . fb < 0.0 )) then write ( * , * ) write ( * , * ) 'in vmec_to_stella_geometry_interface, theta_min=' , a , ' and theta_max=' , b , ' do not bracket root.' write ( * , * ) 'f(theta_min)=' , fa , 'and f(theta_max)=' , fb , '.' a = a - 0.3 b = b + 0.3 write ( * , * ) 'Trying again with values ' , a , ' and ' , b , ' .' fa = fzero_residual ( a ) fb = fzero_residual ( b ) else exit end if end do c = b fc = fb do it = 1 , itmax_root if (( fb > 0.0 . and . fc > 0.0 ) . or . ( fb < 0.0 . and . fc < 0.0 )) then c = a fc = fa d = b - a e = d end if if ( abs ( fc ) < abs ( fb )) then a = b b = c c = a fa = fb fb = fc fc = fa end if tol1 = 2.0 * eps * abs ( b ) + 0.5 * tol xm = 0.5 * ( c - b ) if ( abs ( xm ) <= tol1 . or . fb == 0.0 ) then root = b converged = . true . exit end if if ( abs ( e ) >= tol1 . and . abs ( fa ) > abs ( fb )) then s = fb / fa if ( a == c ) then p = 2.0 * xm * s q = 1.0 - s else q = fa / fc r = fb / fc p = s * ( 2.0 * xm * q * ( q - r ) - ( b - a ) * ( r - 1.0 )) q = ( q - 1.0 ) * ( r - 1.0 ) * ( s - 1.0 ) end if if ( p > 0.0 ) q = - q p = abs ( p ) if ( 2.0 * p < min ( 3.0 * xm * q - abs ( tol1 * q ), abs ( e * q ))) then e = d d = p / q else d = xm e = d end if else d = xm e = d end if a = b fa = fb b = b + merge ( d , sign ( tol1 , xm ), abs ( d ) > tol1 ) fb = fzero_residual ( b ) end do end subroutine get_root function fzero_residual ( theta_vmec_try ) ! Note that lmns and lmnc use the non-Nyquist xm, xn, and mnmax. ! Also note that lmns and lmnc are on the HALF grid. implicit none real :: theta_vmec_try , fzero_residual real :: angle , sinangle , cosangle integer :: imn , which_surface ! residual = (theta_pest based on theta_vmec_try) - theta_pest_target = theta_vmec_try + Lambda - theta_pest_target fzero_residual = theta_vmec_try - theta_pest_target do imn = 1 , mnmax angle = xm ( imn ) * theta_vmec_try - xn ( imn ) * zeta0 sinangle = sin ( angle ) cosangle = cos ( angle ) do which_surface = 1 , 2 fzero_residual = fzero_residual + vmec_radial_weight_half ( which_surface ) * lmns ( imn , vmec_radial_index_half ( which_surface )) * sinangle if ( lasym ) then fzero_residual = fzero_residual + vmec_radial_weight_half ( which_surface ) * lmnc ( imn , vmec_radial_index_half ( which_surface )) * cosangle end if end do end do end function fzero_residual subroutine desired_zmin ( nalpha , nzgrid , zeta , twist_shift_factor_full , dkx_over_dky , new_zeta_min ) integer , intent ( in ) :: nzgrid , nalpha integer :: location real , intent ( in ) :: dkx_over_dky real , intent ( in ), dimension ( nalpha , - nzgrid : nzgrid ) :: zeta real , intent ( in ), dimension ( nalpha , - nzgrid : nzgrid ) :: twist_shift_factor_full real , intent ( out ) :: new_zeta_min real :: delt = 0.08 integer :: iz ! Just defined for nalpha = 1. Just the positive values since the factor is antisymmetric do iz = - nzgrid , nzgrid if (( abs ( twist_shift_factor_full ( 1 , iz )) + delt > dkx_over_dky ) . and . ( abs ( twist_shift_factor_full ( 1 , iz )) - delt < dkx_over_dky )) then location = iz end if end do if ( location == nzgrid ) then write ( * , * ) write ( * , * ) 'No point in the FT fullfils your requirements' write ( * , * ) 'Simulating nfield_periods indicated in the iput file' write ( * , * ) end if ! The last computed iz will be the closest value to the initial grid that fullfills the conditions required. new_zeta_min = zeta ( 1 , location ) end subroutine end module vmec_to_stella_geometry_interface_mod","tags":"","loc":"sourcefile/vmec_to_stella_geometry_interface.f90.html"},{"title":"coll_dougherty.f90 – stella","text":"Source Code module coll_dougherty implicit none public :: read_parameters_dougherty public :: init_collisions_dougherty public :: finish_collisions_dougherty public :: advance_collisions_dougherty_explicit public :: advance_collisions_dougherty_implicit private logical :: vpa_operator , mu_operator logical :: momentum_conservation , energy_conservation integer :: nresponse_vpa = 1 integer :: nresponse_mu = 1 real , dimension (:, :), allocatable :: aa_vpa , bb_vpa , cc_vpa real , dimension (:, :, :), allocatable :: aa_mu , cc_mu real , dimension (:, :), allocatable :: bb_mu complex , dimension (:, :, :), allocatable :: vpadiff_response integer , dimension (:, :), allocatable :: vpadiff_idx complex , dimension (:, :, :), allocatable :: mudiff_response integer , dimension (:, :), allocatable :: mudiff_idx complex , dimension (:, :, :), allocatable :: vpadiff_zf_response integer , dimension (:, :), allocatable :: vpadiff_zf_idx complex , dimension (:, :, :), allocatable :: mudiff_zf_response integer , dimension (:, :), allocatable :: mudiff_zf_idx logical :: dougherty_initialized = . false . contains subroutine read_parameters_dougherty use file_utils , only : input_unit_exist use mp , only : proc0 , broadcast implicit none namelist / collisions_dougherty / momentum_conservation , energy_conservation , & vpa_operator , mu_operator integer :: in_file logical :: dexist if ( proc0 ) then momentum_conservation = . true . ! momentum conservation for Dougherty operator energy_conservation = . true . ! energy conservation for Dougherty operator vpa_operator = . true . ! include vpa components in Dougherty or Fokker-Planck operator mu_operator = . true . ! include mu components in Dougherty or Fokker-Planck operator in_file = input_unit_exist ( \"collisions_dougherty\" , dexist ) if ( dexist ) read ( unit = in_file , nml = collisions_dougherty ) end if call broadcast ( momentum_conservation ) call broadcast ( energy_conservation ) call broadcast ( vpa_operator ) call broadcast ( mu_operator ) end subroutine read_parameters_dougherty subroutine init_collisions_dougherty ( collisions_implicit , cfl_dt_vpadiff , cfl_dt_mudiff ) use species , only : spec , nspec use vpamu_grids , only : dvpa , dmu , mu , nmu use stella_geometry , only : bmag implicit none logical , intent ( in ) :: collisions_implicit real , intent ( out ) :: cfl_dt_vpadiff , cfl_dt_mudiff integer :: is real :: vnew_max if ( dougherty_initialized ) return dougherty_initialized = . true . if ( collisions_implicit ) then if ( vpa_operator ) then call init_vpadiff_matrix call init_vpadiff_conserve end if if ( mu_operator ) then call init_mudiff_matrix call init_mudiff_conserve end if else vnew_max = 0.0 do is = 1 , nspec vnew_max = max ( vnew_max , maxval ( spec ( is )% vnew )) end do cfl_dt_vpadiff = 2.0 * dvpa ** 2 / vnew_max cfl_dt_mudiff = minval ( bmag ) / ( vnew_max * maxval ( mu ( 2 :) / dmu (: nmu - 1 ) ** 2 )) end if end subroutine init_collisions_dougherty subroutine init_vpadiff_matrix use stella_time , only : code_dt use species , only : nspec , spec use vpamu_grids , only : dvpa , vpa , nvpa use stella_layouts , only : kxkyz_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , is_idx use stella_geometry , only : bmag use dist_fn_arrays , only : kperp2 implicit none integer :: ikxkyz , iky , ikx , iz , is integer :: ia if (. not . allocated ( aa_vpa )) allocate ( aa_vpa ( nvpa , nspec )) !    if (.not.allocated(bb_vpa)) allocate (bb_vpa(nvpa,nspec)) if (. not . allocated ( bb_vpa )) allocate ( bb_vpa ( nvpa , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) if (. not . allocated ( cc_vpa )) allocate ( cc_vpa ( nvpa , nspec )) ! deal with boundary points (BC is f(vpa)=0 beyond +/- vpa_max) aa_vpa ( 1 , :) = 0.0 ; cc_vpa ( nvpa , :) = 0.0 ! 2nd order centered differences for d/dvpa (1/2 dh/dvpa + vpa h) do is = 1 , nspec aa_vpa ( 2 :, is ) = - code_dt * spec ( is )% vnew ( is ) * 0.5 * ( 1.0 / dvpa - vpa (: nvpa - 1 )) / dvpa !       bb_vpa(:,is) = 1.0+code_dt*spec(is)%vnew(is)/dvpa**2 cc_vpa (: nvpa - 1 , is ) = - code_dt * spec ( is )% vnew ( is ) * 0.5 * ( 1.0 / dvpa + vpa ( 2 :)) / dvpa end do ia = 1 do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) bb_vpa (:, ikxkyz ) = 1.0 + code_dt * spec ( is )% vnew ( is ) & * ( 0.25 * kperp2 ( iky , ikx , ia , iz ) * ( spec ( is )% smz / bmag ( ia , iz )) ** 2 + 1. / dvpa ** 2 ) end do end subroutine init_vpadiff_matrix subroutine init_mudiff_matrix use stella_time , only : code_dt use species , only : nspec , spec use zgrid , only : nzgrid use stella_geometry , only : bmag use vpamu_grids , only : dmu , nmu use vpamu_grids , only : dmu_cell , mu_cell , wgts_mu_bare use stella_layouts , only : kxkyz_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , is_idx use dist_fn_arrays , only : kperp2 implicit none integer :: ikxkyz , iky , ikx , iz , is integer :: ia ! TMP FOR TESTING -- MAB !    integer :: imu if (. not . allocated ( aa_mu )) allocate ( aa_mu ( - nzgrid : nzgrid , nmu , nspec )) if (. not . allocated ( bb_mu )) allocate ( bb_mu ( nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) if (. not . allocated ( cc_mu )) allocate ( cc_mu ( - nzgrid : nzgrid , nmu , nspec )) ia = 1 ! deal with boundary points (BC is f(mu)=0 beyond mu_max and collision operator vanishes for mu -> 0) aa_mu (:, 1 , :) = 0.0 ; cc_mu (:, nmu , :) = 0.0 ! 2nd order centered differences for dt * nu * d/dmu (mu/B*dh/dmu + 2*mu*h) do is = 1 , nspec do iz = - nzgrid , nzgrid aa_mu ( iz , 2 :, is ) = - code_dt * spec ( is )% vnew ( is ) * mu_cell (: nmu - 1 ) * ( 1.0 / ( bmag ( ia , iz ) * dmu ) - 1.0 ) / wgts_mu_bare ( 2 :) cc_mu ( iz , : nmu - 1 , is ) = - code_dt * spec ( is )% vnew ( is ) * mu_cell (: nmu - 1 ) * ( 1.0 / ( bmag ( ia , iz ) * dmu ) + 1.0 ) / wgts_mu_bare (: nmu - 1 ) end do end do !1st derivative here is  2 d/dmu( mu h) -> (mu(i+1/2)h(i+1/2) - mu(i-1/2)h(i-1/2))/(mu(i+1/2)-mu(i-1/2)) !where h(i+1/2) = 0.5*[h(i+1)+h(i)] and mu(i+1/2) = 0.5*(mu(i+1)+mu(i)) !2nd derivative here is d/dmu ( mu dh/dmu ) = (mu(i+1/2)h'(i+1/2) - mu(i-1/2)h'(i-1/2))/(mu(i+1/2)-mu(i-1/2)) !where h'(i+1/2) = (h(i+1)-h(i))/(mu(i+1)-mu(i)) !left  endpoint i=1   -> mu(i-1/2) = 0 !right endpoint i=nmu -> h(i+1/2) = h'(i+1/2) = 0 (these are the two boundary conditions) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) bb_mu ( 1 , ikxkyz ) = 1.0 + code_dt * spec ( is )% vnew ( is ) & * ( 0.25 * kperp2 ( iky , ikx , ia , iz ) * ( spec ( is )% smz / bmag ( ia , iz )) ** 2 & + dmu_cell ( 1 ) * ( 1.0 / ( dmu ( 1 ) * bmag ( ia , iz )) - 1.0 ) / wgts_mu_bare ( 1 )) bb_mu ( 2 : nmu - 1 , ikxkyz ) = 1.0 + code_dt * spec ( is )% vnew ( is ) & * ( 0.25 * kperp2 ( iky , ikx , ia , iz ) * ( spec ( is )% smz / bmag ( ia , iz )) ** 2 & + ( mu_cell ( 2 : nmu - 1 ) / dmu ( 2 :) + mu_cell (: nmu - 2 ) / dmu (: nmu - 2 )) & / ( wgts_mu_bare ( 2 : nmu - 1 ) * bmag ( ia , iz )) - dmu_cell ( 2 : nmu - 1 ) / wgts_mu_bare ( 2 : nmu - 1 )) bb_mu ( nmu , ikxkyz ) = 1.0 + code_dt * spec ( is )% vnew ( is ) & * ( 0.25 * kperp2 ( iky , ikx , ia , iz ) * ( spec ( is )% smz / bmag ( ia , iz )) ** 2 & + mu_cell ( nmu - 1 ) * ( 1.0 / ( dmu ( nmu - 1 ) * bmag ( ia , iz )) + 1.0 ) / wgts_mu_bare ( nmu )) end do end subroutine init_mudiff_matrix subroutine init_vpadiff_conserve use mp , only : sum_allreduce use finite_differences , only : tridag use linear_solve , only : lu_decomposition , lu_inverse use stella_time , only : code_dt use species , only : nspec , spec , has_electron_species use zgrid , only : nzgrid , ntubes use vpamu_grids , only : ztmax , maxwell_vpa , maxwell_mu use vpamu_grids , only : nmu , vpa , vperp2 use vpamu_grids , only : set_vpa_weights use kt_grids , only : naky , nakx , zonal_mode use stella_layouts , only : kxkyz_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , it_idx , is_idx use stella_geometry , only : dl_over_b use dist_fn_arrays , only : gvmu use gyro_averages , only : aj0v use fields , only : get_fields , get_fields_by_spec , efac , gamtot_h use physics_flags , only : adiabatic_option_switch use physics_flags , only : adiabatic_option_fieldlineavg implicit none integer :: ikxkyz , iky , ikx , iz , it , is , ia integer :: imu integer :: idx logical :: conservative_wgts real :: dum2 complex , dimension (:, :, :, :), allocatable :: dum1 complex , dimension (:, :, :, :), allocatable :: dum3 complex , dimension (:, :, :, :, :), allocatable :: field complex , dimension (:, :), allocatable :: temp_mat ia = 1 nresponse_vpa = 1 if ( momentum_conservation ) nresponse_vpa = nresponse_vpa + nspec if ( energy_conservation ) nresponse_vpa = nresponse_vpa + nspec if (. not . allocated ( vpadiff_response )) then allocate ( vpadiff_response ( nresponse_vpa , nresponse_vpa , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) vpadiff_response = 0. allocate ( vpadiff_idx ( nresponse_vpa , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) end if if (. not . has_electron_species ( spec ) . and . adiabatic_option_switch == adiabatic_option_fieldlineavg ) then if (. not . allocated ( vpadiff_zf_response )) then allocate ( vpadiff_zf_response ( nresponse_vpa , nresponse_vpa , nakx )) vpadiff_zf_response = 0. allocate ( vpadiff_zf_idx ( nresponse_vpa , nakx )) end if end if allocate ( dum1 ( naky , nakx , - nzgrid : nzgrid , ntubes )) allocate ( dum3 ( naky , nakx , - nzgrid : nzgrid , ntubes )) allocate ( field ( naky , nakx , - nzgrid : nzgrid , ntubes , nspec )) ! set wgts to be equally spaced to ensure exact conservation properties conservative_wgts = . true . call set_vpa_weights ( conservative_wgts ) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) do imu = 1 , nmu gvmu (:, imu , ikxkyz ) = ztmax (:, is ) * maxwell_mu ( 1 , iz , imu , is ) * aj0v ( imu , ikxkyz ) call tridag ( 1 , aa_vpa (:, is ), bb_vpa (:, ikxkyz ), cc_vpa (:, is ), gvmu (:, imu , ikxkyz )) end do end do ! gvmu contains dhs/dphi ! for phi equation, need 1-P[dhs/dphi] ! for upar equations, need -Us[dhs/dphi] ! for energy conservation, need -Qs[dhs/dphi] call get_fields ( gvmu , field (:, :, :, :, 1 ), dum1 , dum3 , dist = 'h' , skip_fsa = . true .) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) vpadiff_response ( 1 , 1 , ikxkyz ) = 1.0 - field ( iky , ikx , iz , it , 1 ) end do idx = 2 if ( momentum_conservation ) then call get_upar ( gvmu , field ) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) vpadiff_response ( idx : idx + nspec - 1 , 1 , ikxkyz ) = - field ( iky , ikx , iz , it , :) end do idx = idx + nspec end if if ( energy_conservation ) then call get_temp ( gvmu , field ) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) vpadiff_response ( idx : idx + nspec - 1 , 1 , ikxkyz ) = - field ( iky , ikx , iz , it , :) end do end if idx = 2 if ( momentum_conservation ) then do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) do imu = 1 , nmu gvmu (:, imu , ikxkyz ) = 2. * code_dt * spec ( is )% vnew ( is ) * vpa * aj0v ( imu , ikxkyz ) * maxwell_vpa (:, is ) * maxwell_mu ( 1 , iz , imu , is ) call tridag ( 1 , aa_vpa (:, is ), bb_vpa (:, ikxkyz ), cc_vpa (:, is ), gvmu (:, imu , ikxkyz )) end do end do ! gvmu now contains dhs/dupars ! need to get -Ps[dhs/dupars] for phi equation ! need to get 1-Us[dhs/dupars] for momentum conservation ! need to get -Qs[dhs/dupars] for energy conservation call get_fields_by_spec ( gvmu , field , skip_fsa = . true .) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) vpadiff_response ( 1 , idx : idx + nspec - 1 , ikxkyz ) = - field ( iky , ikx , iz , it , :) end do call get_upar ( gvmu , field ) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) do is = 1 , nspec vpadiff_response ( idx + is - 1 , idx + is - 1 , ikxkyz ) = 1.0 - field ( iky , ikx , iz , it , is ) end do end do if ( energy_conservation ) then call get_temp ( gvmu , field ) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) do is = 1 , nspec vpadiff_response ( idx + is + nspec - 1 , idx + is - 1 , ikxkyz ) = - field ( iky , ikx , iz , it , is ) end do end do end if idx = idx + nspec end if if ( energy_conservation ) then do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) do imu = 1 , nmu gvmu (:, imu , ikxkyz ) = 2. * code_dt * spec ( is )% vnew ( is ) * ( vpa ** 2 + vperp2 ( 1 , iz , imu ) - 1.5 ) & * aj0v ( imu , ikxkyz ) * maxwell_vpa (:, is ) * maxwell_mu ( 1 , iz , imu , is ) call tridag ( 1 , aa_vpa (:, is ), bb_vpa (:, ikxkyz ), cc_vpa (:, is ), gvmu (:, imu , ikxkyz )) end do end do ! gvmu now contains dhs/dQs ! need to get -Ps[dhs/dQs] for phi equation ! need to get 1-Us[dhs/dQs] for momentum conservation ! need to get -Qs[dhs/dQs] for energy conservation call get_fields_by_spec ( gvmu , field , skip_fsa = . true .) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) vpadiff_response ( 1 , idx : idx + nspec - 1 , ikxkyz ) = - field ( iky , ikx , iz , it , :) end do if ( momentum_conservation ) then call get_upar ( gvmu , field ) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) do is = 1 , nspec vpadiff_response ( idx + is - 1 - nspec , idx + is - 1 , ikxkyz ) = - field ( iky , ikx , iz , it , is ) end do end do end if call get_temp ( gvmu , field ) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) do is = 1 , nspec vpadiff_response ( idx + is - 1 , idx + is - 1 , ikxkyz ) = 1.0 - field ( iky , ikx , iz , it , is ) end do end do end if ! now get LU decomposition for vpadiff_response do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc call lu_decomposition ( vpadiff_response (:, :, ikxkyz ), vpadiff_idx (:, ikxkyz ), dum2 ) end do ! if electrons are adiabatic, compute the matrices for the flux-surface-average if (. not . has_electron_species ( spec ) . and . zonal_mode ( 1 ) & . and . adiabatic_option_switch == adiabatic_option_fieldlineavg ) then allocate ( temp_mat ( nresponse_vpa , nresponse_vpa )) vpadiff_zf_response = 0.0 do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) if ( iky /= 1 . or . it /= 1 ) cycle !calculate inverse of vpadiff_response call lu_inverse ( vpadiff_response (:, :, ikxkyz ), vpadiff_idx (:, ikxkyz ), temp_mat ) !calculate -inv(vpadiff_response).Q, where Q has a single entry do idx = 1 , nresponse_vpa vpadiff_zf_response ( idx , 1 , ikx ) = vpadiff_zf_response ( idx , 1 , ikx ) & - temp_mat ( idx , 1 ) * ( efac / gamtot_h ) * dl_over_b ( ia , iz ) end do end do !finish the flux surface average call sum_allreduce ( vpadiff_zf_response ) !calculate 1 - fsa(inv(vpadiff_response).Q) do idx = 1 , nresponse_vpa vpadiff_zf_response ( idx , idx , :) = vpadiff_zf_response ( idx , idx , :) + 1.0 end do do ikx = 1 , nakx call lu_decomposition ( vpadiff_zf_response (:, :, ikx ), vpadiff_zf_idx (:, ikx ), dum2 ) end do deallocate ( temp_mat ) end if ! reset wgts to default setting conservative_wgts = . false . call set_vpa_weights ( conservative_wgts ) deallocate ( dum1 , dum3 , field ) end subroutine init_vpadiff_conserve subroutine init_mudiff_conserve use mp , only : sum_allreduce use finite_differences , only : tridag use linear_solve , only : lu_decomposition , lu_inverse use stella_time , only : code_dt use species , only : nspec , spec , has_electron_species use zgrid , only : nzgrid , ntubes use vpamu_grids , only : ztmax , maxwell_vpa , maxwell_mu use vpamu_grids , only : nvpa , vpa , vperp2 use kt_grids , only : naky , nakx , zonal_mode use stella_geometry , only : dl_over_b , bmag use stella_layouts , only : kxkyz_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , it_idx , is_idx use dist_fn_arrays , only : gvmu , kperp2 use gyro_averages , only : aj0v , aj1v use fields , only : get_fields , get_fields_by_spec , efac , gamtot_h use physics_flags , only : adiabatic_option_switch use physics_flags , only : adiabatic_option_fieldlineavg implicit none integer :: ikxkyz , iky , ikx , iz , it , is , ia integer :: iv integer :: idx real :: dum2 complex , dimension (:, :), allocatable :: temp_mat complex , dimension (:, :, :, :), allocatable :: dum1 , dum3 complex , dimension (:, :, :, :, :), allocatable :: field nresponse_mu = 1 if ( momentum_conservation ) nresponse_mu = nresponse_mu + nspec if ( energy_conservation ) nresponse_mu = nresponse_mu + nspec if (. not . allocated ( mudiff_response )) then allocate ( mudiff_response ( nresponse_mu , nresponse_mu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) mudiff_response = 0. allocate ( mudiff_idx ( nresponse_mu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) end if if (. not . has_electron_species ( spec ) . and . adiabatic_option_switch == adiabatic_option_fieldlineavg ) then if (. not . allocated ( mudiff_zf_response )) then allocate ( mudiff_zf_response ( nresponse_mu , nresponse_mu , nakx )) mudiff_zf_response = 0. allocate ( mudiff_zf_idx ( nresponse_mu , nakx )) end if end if allocate ( dum1 ( naky , nakx , - nzgrid : nzgrid , ntubes )) allocate ( dum3 ( naky , nakx , - nzgrid : nzgrid , ntubes )) allocate ( field ( naky , nakx , - nzgrid : nzgrid , ntubes , nspec )) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) do iv = 1 , nvpa gvmu ( iv , :, ikxkyz ) = ztmax ( iv , is ) * maxwell_mu ( 1 , iz , :, is ) * aj0v (:, ikxkyz ) call tridag ( 1 , aa_mu ( iz , :, is ), bb_mu (:, ikxkyz ), cc_mu ( iz , :, is ), gvmu ( iv , :, ikxkyz )) end do end do ! gvmu contains dhs/dphi ! for phi equation, need 1-P[dhs/dphi] ! for uperp equations, need -Us[dhs/dphi] ! for energy conservation, need -Qs[dhs/dphi] call get_fields ( gvmu , field (:, :, :, :, 1 ), dum1 , dum3 , dist = 'h' , skip_fsa = . true .) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) mudiff_response ( 1 , 1 , ikxkyz ) = 1.0 - field ( iky , ikx , iz , it , 1 ) end do idx = 2 if ( momentum_conservation ) then call get_uperp ( gvmu , field ) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) mudiff_response ( idx : idx + nspec - 1 , 1 , ikxkyz ) = - field ( iky , ikx , iz , it , :) end do idx = idx + nspec end if if ( energy_conservation ) then call get_temp_mu ( gvmu , field ) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) mudiff_response ( idx : idx + nspec - 1 , 1 , ikxkyz ) = - field ( iky , ikx , iz , it , :) end do end if idx = 2 if ( momentum_conservation ) then ia = 1 do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) do iv = 1 , nvpa gvmu ( iv , :, ikxkyz ) = 2. * code_dt * spec ( is )% vnew ( is ) * kperp2 ( iky , ikx , ia , iz ) * vperp2 ( ia , iz , :) & * ( spec ( is )% smz / bmag ( ia , iz )) ** 2 * aj1v (:, ikxkyz ) * maxwell_vpa ( iv , is ) * maxwell_mu ( ia , iz , :, is ) call tridag ( 1 , aa_mu ( iz , :, is ), bb_mu (:, ikxkyz ), cc_mu ( iz , :, is ), gvmu ( iv , :, ikxkyz )) end do end do ! gvmu now contains dhs/dupars ! need to get -Ps[dhs/dupars] for phi equation ! need to get 1-Us[dhs/dupars] for momentum conservation ! need to get -Qs[dhs/dupars] for energy conservation call get_fields_by_spec ( gvmu , field , skip_fsa = . true .) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) mudiff_response ( 1 , idx : idx + nspec - 1 , ikxkyz ) = - field ( iky , ikx , iz , it , :) end do call get_uperp ( gvmu , field ) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) do is = 1 , nspec mudiff_response ( idx + is - 1 , idx + is - 1 , ikxkyz ) = 1.0 - field ( iky , ikx , iz , it , is ) end do end do if ( energy_conservation ) then call get_temp_mu ( gvmu , field ) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) do is = 1 , nspec mudiff_response ( idx + is + nspec - 1 , idx + is - 1 , ikxkyz ) = - field ( iky , ikx , iz , it , is ) end do end do end if idx = idx + nspec end if if ( energy_conservation ) then do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) do iv = 1 , nvpa gvmu ( iv , :, ikxkyz ) = 2.0 * code_dt * spec ( is )% vnew ( is ) * ( vpa ( iv ) ** 2 + vperp2 ( 1 , iz , :) - 1.5 ) & * aj0v (:, ikxkyz ) * maxwell_vpa ( iv , is ) * maxwell_mu ( 1 , iz , :, is ) call tridag ( 1 , aa_mu ( iz , :, is ), bb_mu (:, ikxkyz ), cc_mu ( iz , :, is ), gvmu ( iv , :, ikxkyz )) end do end do ! gvmu now contains dhs/dQs ! need to get -Ps[dhs/dQs] for phi equation ! need to get 1-Us[dhs/dQs] for momentum conservation ! need to get -Qs[dhs/dQs] for energy conservation call get_fields_by_spec ( gvmu , field , skip_fsa = . true .) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) mudiff_response ( 1 , idx : idx + nspec - 1 , ikxkyz ) = - field ( iky , ikx , iz , it , :) end do if ( momentum_conservation ) then call get_uperp ( gvmu , field ) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) do is = 1 , nspec mudiff_response ( idx + is - 1 - nspec , idx + is - 1 , ikxkyz ) = - field ( iky , ikx , iz , it , is ) end do end do end if call get_temp_mu ( gvmu , field ) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) do is = 1 , nspec mudiff_response ( idx + is - 1 , idx + is - 1 , ikxkyz ) = 1.0 - field ( iky , ikx , iz , it , is ) end do end do end if ! now get LU decomposition for mudiff_response do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc call lu_decomposition ( mudiff_response (:, :, ikxkyz ), mudiff_idx (:, ikxkyz ), dum2 ) end do ! if electrons are adiabatic, compute the matrices for the flux-surface-average if (. not . has_electron_species ( spec ) . and . zonal_mode ( 1 ) & . and . adiabatic_option_switch == adiabatic_option_fieldlineavg ) then allocate ( temp_mat ( nresponse_mu , nresponse_mu )) mudiff_zf_response = 0.0 do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) if ( iky /= 1 . or . it /= 1 ) cycle !calculate inverse of mudiff_response call lu_inverse ( mudiff_response (:, :, ikxkyz ), mudiff_idx (:, ikxkyz ), temp_mat ) !calculate -inv(mudiff_response).Q, where Q has a single entry do idx = 1 , nresponse_mu mudiff_zf_response ( idx , 1 , ikx ) = mudiff_zf_response ( idx , 1 , ikx ) & - temp_mat ( idx , 1 ) * ( efac / gamtot_h ) * dl_over_b ( ia , iz ) end do end do !finish the flux surface average call sum_allreduce ( mudiff_zf_response ) !calculate 1 - fsa(inv(mudiff_response).Q) do idx = 1 , nresponse_mu mudiff_zf_response ( idx , idx , :) = mudiff_zf_response ( idx , idx , :) + 1.0 end do do ikx = 1 , nakx call lu_decomposition ( mudiff_zf_response (:, :, ikx ), mudiff_zf_idx (:, ikx ), dum2 ) end do deallocate ( temp_mat ) end if deallocate ( dum1 , dum3 , field ) end subroutine init_mudiff_conserve subroutine finish_collisions_dougherty implicit none call finish_vpadiff_matrix call finish_mudiff_matrix call finish_vpadiff_response call finish_mudiff_response dougherty_initialized = . false . end subroutine finish_collisions_dougherty subroutine finish_vpadiff_matrix implicit none if ( allocated ( aa_vpa )) deallocate ( aa_vpa ) if ( allocated ( bb_vpa )) deallocate ( bb_vpa ) if ( allocated ( cc_vpa )) deallocate ( cc_vpa ) end subroutine finish_vpadiff_matrix subroutine finish_mudiff_matrix implicit none if ( allocated ( aa_mu )) deallocate ( aa_mu ) if ( allocated ( bb_mu )) deallocate ( bb_mu ) if ( allocated ( cc_mu )) deallocate ( cc_mu ) end subroutine finish_mudiff_matrix subroutine finish_vpadiff_response implicit none if ( allocated ( vpadiff_response )) deallocate ( vpadiff_response ) if ( allocated ( vpadiff_idx )) deallocate ( vpadiff_idx ) end subroutine finish_vpadiff_response subroutine finish_mudiff_response implicit none if ( allocated ( mudiff_response )) deallocate ( mudiff_response ) if ( allocated ( mudiff_idx )) deallocate ( mudiff_idx ) end subroutine finish_mudiff_response subroutine get_upar ( g , fld ) use mp , only : sum_allreduce use zgrid , only : nzgrid use vpamu_grids , only : integrate_vmu use vpamu_grids , only : nvpa , nmu use vpamu_grids , only : vpa use stella_layouts , only : kxkyz_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , it_idx , is_idx use gyro_averages , only : aj0v implicit none complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :, :), intent ( out ) :: fld integer :: ikxkyz , iky , ikx , iz , it , is complex , dimension (:, :), allocatable :: g0 allocate ( g0 ( nvpa , nmu )) fld = 0. do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) g0 = g (:, :, ikxkyz ) * spread ( vpa , 2 , nmu ) * spread ( aj0v (:, ikxkyz ), 1 , nvpa ) call integrate_vmu ( g0 , iz , fld ( iky , ikx , iz , it , is )) end do deallocate ( g0 ) call sum_allreduce ( fld ) end subroutine get_upar subroutine get_uperp ( g , fld ) use mp , only : sum_allreduce use zgrid , only : nzgrid use vpamu_grids , only : integrate_vmu use vpamu_grids , only : nvpa , nmu use vpamu_grids , only : vperp2 use stella_layouts , only : kxkyz_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , it_idx , is_idx use gyro_averages , only : aj1v implicit none complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :, :), intent ( out ) :: fld integer :: ikxkyz , iky , ikx , iz , it , is complex , dimension (:, :), allocatable :: g0 allocate ( g0 ( nvpa , nmu )) fld = 0. do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) !        g0 = 2.0*g(:,:,ikxkyz)*spread((vperp2(1,iz,:)-0.5)*aj1v(:,ikxkyz),1,nvpa) g0 = g (:, :, ikxkyz ) * spread (( vperp2 ( 1 , iz , :) - 0.5 ) * aj1v (:, ikxkyz ), 1 , nvpa ) call integrate_vmu ( g0 , iz , fld ( iky , ikx , iz , it , is )) end do deallocate ( g0 ) call sum_allreduce ( fld ) end subroutine get_uperp subroutine get_temp ( g , fld ) use mp , only : sum_allreduce use zgrid , only : nzgrid use vpamu_grids , only : integrate_vmu use vpamu_grids , only : nvpa , nmu use vpamu_grids , only : vpa use stella_layouts , only : kxkyz_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , it_idx , is_idx use gyro_averages , only : aj0v implicit none complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :, :), intent ( out ) :: fld integer :: ikxkyz , iky , ikx , iz , it , is complex , dimension (:, :), allocatable :: g0 allocate ( g0 ( nvpa , nmu )) fld = 0. do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) g0 = g (:, :, ikxkyz ) * ( spread ( vpa ** 2 , 2 , nmu ) - 0.5 ) & * spread ( aj0v (:, ikxkyz ), 1 , nvpa ) / 1.5 call integrate_vmu ( g0 , iz , fld ( iky , ikx , iz , it , is )) end do deallocate ( g0 ) call sum_allreduce ( fld ) end subroutine get_temp subroutine get_temp_mu ( g , fld ) use mp , only : sum_allreduce use zgrid , only : nzgrid use vpamu_grids , only : integrate_vmu use vpamu_grids , only : nvpa , nmu , vperp2 use stella_layouts , only : kxkyz_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , it_idx , is_idx use gyro_averages , only : aj0v implicit none complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :, :), intent ( out ) :: fld integer :: ikxkyz , iky , ikx , iz , it , is complex , dimension (:, :), allocatable :: g0 allocate ( g0 ( nvpa , nmu )) fld = 0. do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) g0 = g (:, :, ikxkyz ) * ( spread ( vperp2 ( 1 , iz , :), 1 , nvpa ) - 1.0 ) & * spread ( aj0v (:, ikxkyz ), 1 , nvpa ) / 1.5 call integrate_vmu ( g0 , iz , fld ( iky , ikx , iz , it , is )) end do deallocate ( g0 ) call sum_allreduce ( fld ) end subroutine get_temp_mu subroutine advance_collisions_dougherty_explicit ( g , phi , bpar , gke_rhs , time_collisions ) use mp , only : proc0 , mp_abort use job_manage , only : time_message use redistribute , only : scatter , gather use stella_time , only : code_dt use zgrid , only : nzgrid , ntubes use species , only : spec use run_parameters , only : fphi use physics_flags , only : radial_variation , full_flux_surface use kt_grids , only : naky , nakx , multiply_by_rho , rho_d_clamped use vpamu_grids , only : nvpa , nmu use vpamu_grids , only : set_vpa_weights use stella_geometry , only : bmag , dBdrho use stella_layouts , only : vmu_lo , kxkyz_lo use stella_layouts , only : is_idx , iky_idx , ikx_idx , iz_idx use dist_redistribute , only : kxkyz2vmu use dist_fn_arrays , only : gvmu , kperp2 , dkperp2dr use fields_arrays , only : phi_corr_QN use g_tofrom_h , only : g_to_h use stella_transforms , only : transform_kx2x_unpadded , transform_x2kx_unpadded implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: phi , bpar complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: gke_rhs real , dimension (:, :), intent ( in out ) :: time_collisions integer :: is , ikxkyz , imu , iv , ivmu , ikx , iky , iz , ia , it logical :: conservative_wgts real :: tfac , kfac complex , dimension (:), allocatable :: mucoll complex , dimension (:, :, :), allocatable :: coll complex , dimension (:, :, :, :, :), allocatable :: tmp_vmulo complex , dimension (:, :), allocatable :: g0k , g0x ia = 1 if ( full_flux_surface ) then call mp_abort ( \"collisions not currently supported for full_flux_surface=T.  Aborting.\" ) end if if ( proc0 ) call time_message (. false ., time_collisions (:, 1 ), ' collisions' ) kfac = 0.0 if ( mu_operator ) kfac = kfac + 0.5 if ( vpa_operator ) kfac = kfac + 0.5 allocate ( tmp_vmulo ( naky , nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) ! want exact conservation properties for collision operator conservative_wgts = . true . call set_vpa_weights ( conservative_wgts ) if ( radial_variation ) then allocate ( g0k ( naky , nakx )) allocate ( g0x ( naky , nakx )) !TODO (DSO) - could perhaps operator split the profile variation pieces off the main pieces, and so !             this portion of the code could just treat the terms that vary in x ! switch from g = <f> to h = f + Z*e*phi/T * F0 tmp_vmulo = g call g_to_h ( tmp_vmulo , phi , bpar , fphi , phi_corr_QN ) !handle gyroviscous term do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) do it = 1 , ntubes do iz = - nzgrid , nzgrid g0k = 0.5 * kfac * tmp_vmulo (:, :, iz , it , ivmu ) * kperp2 (:, :, ia , iz ) * ( spec ( is )% smz / bmag ( ia , iz )) ** 2 gke_rhs (:, :, iz , it , ivmu ) = gke_rhs (:, :, iz , it , ivmu ) - code_dt * spec ( is )% vnew ( is ) * g0k g0k = g0k * ( dkperp2dr (:, :, ia , iz ) - 2.0 * dBdrho ( iz ) / bmag ( ia , iz ) - spec ( is )% tprim ) call multiply_by_rho ( g0k ) gke_rhs (:, :, iz , it , ivmu ) = gke_rhs (:, :, iz , it , ivmu ) - code_dt * spec ( is )% vnew ( is ) * g0k end do end do end do !handle the conservation terms if ( momentum_conservation ) call conserve_momentum_vmulo ( tmp_vmulo , gke_rhs ) if ( energy_conservation ) call conserve_energy_vmulo ( tmp_vmulo , gke_rhs ) !since Bessel functions do not appear under the velocity derivatives, these terms are one-point in x space ! and we can simply inverse Fourier transform do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid call transform_kx2x_unpadded ( tmp_vmulo (:, :, iz , it , ivmu ), g0x ) tmp_vmulo (:, :, iz , it , ivmu ) = g0x end do end do end do ! remap so that (vpa,mu) local if ( proc0 ) call time_message (. false ., time_collisions (:, 2 ), ' coll_redist' ) call scatter ( kxkyz2vmu , tmp_vmulo , gvmu ) if ( proc0 ) call time_message (. false ., time_collisions (:, 2 ), ' coll_redist' ) ! take vpa derivatives allocate ( coll ( nvpa , nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) allocate ( mucoll ( nmu )) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) if ( vpa_operator ) then !fix the temperature term tfac = ( spec ( is )% temp / spec ( is )% temp_psi0 ) * ( 1.0 - rho_d_clamped ( ikx ) * spec ( is )% tprim ) do imu = 1 , nmu call vpa_differential_operator ( tfac , gvmu (:, imu , ikxkyz ), coll (:, imu , ikxkyz )) end do else coll (:, :, ikxkyz ) = 0.0 end if if ( mu_operator ) then !fix the temperature/bmag term tfac = ( spec ( is )% temp / spec ( is )% temp_psi0 ) & * ( 1.0 - rho_d_clamped ( ikx ) * ( spec ( is )% tprim + dBdrho ( iz ) / bmag ( ia , iz ))) do iv = 1 , nvpa call mu_differential_operator ( tfac , iz , ia , gvmu ( iv , :, ikxkyz ), mucoll ) coll ( iv , :, ikxkyz ) = coll ( iv , :, ikxkyz ) + mucoll end do end if gvmu (:, :, ikxkyz ) = coll (:, :, ikxkyz ) end do deallocate ( coll , mucoll ) ! remap so that (ky,kx,z,tube) local call gather ( kxkyz2vmu , gvmu , tmp_vmulo ) !don't forget to Fourier transform do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) do it = 1 , ntubes do iz = - nzgrid , nzgrid call transform_x2kx_unpadded ( tmp_vmulo (:, :, iz , it , ivmu ), g0k ) tmp_vmulo (:, :, iz , it , ivmu ) = g0k end do end do end do do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) gke_rhs (:, :, :, :, ivmu ) = gke_rhs (:, :, :, :, ivmu ) + code_dt * spec ( is )% vnew ( is ) * tmp_vmulo (:, :, :, :, ivmu ) end do deallocate ( g0k , g0x ) else ! switch from g = <f> to h = f + Z*e*phi/T * F0 tmp_vmulo = g call g_to_h ( tmp_vmulo , phi , bpar , fphi ) ! remap so that (vpa,mu) local if ( proc0 ) call time_message (. false ., time_collisions (:, 2 ), ' coll_redist' ) call scatter ( kxkyz2vmu , tmp_vmulo , gvmu ) if ( proc0 ) call time_message (. false ., time_collisions (:, 2 ), ' coll_redist' ) ia = 1 ! take vpa derivatives allocate ( coll ( nvpa , nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) allocate ( mucoll ( nmu )) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) if ( vpa_operator ) then do imu = 1 , nmu call vpa_differential_operator ( 1.0 , gvmu (:, imu , ikxkyz ), coll (:, imu , ikxkyz )) end do else coll (:, :, ikxkyz ) = 0.0 end if if ( mu_operator ) then do iv = 1 , nvpa call mu_differential_operator ( 1.0 , iz , ia , gvmu ( iv , :, ikxkyz ), mucoll ) coll ( iv , :, ikxkyz ) = coll ( iv , :, ikxkyz ) + mucoll end do end if if ( momentum_conservation ) call conserve_momentum ( iky , ikx , iz , is , ikxkyz , gvmu (:, :, ikxkyz ), coll (:, :, ikxkyz )) if ( energy_conservation ) call conserve_energy ( iz , is , ikxkyz , gvmu (:, :, ikxkyz ), coll (:, :, ikxkyz )) ! save memory by using gvmu and deallocating coll below ! before re-allocating tmp_vmulo gvmu (:, :, ikxkyz ) = coll (:, :, ikxkyz ) - 0.5 * kfac * kperp2 ( iky , ikx , ia , iz ) * ( spec ( is )% smz / bmag ( ia , iz )) ** 2 * gvmu (:, :, ikxkyz ) end do deallocate ( coll , mucoll ) ! remap so that (ky,kx,z,tube) local call gather ( kxkyz2vmu , gvmu , tmp_vmulo ) do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) gke_rhs (:, :, :, :, ivmu ) = gke_rhs (:, :, :, :, ivmu ) + code_dt * spec ( is )% vnew ( is ) * tmp_vmulo (:, :, :, :, ivmu ) end do end if deallocate ( tmp_vmulo ) ! reset to default integration wgts conservative_wgts = . false . call set_vpa_weights ( conservative_wgts ) if ( proc0 ) call time_message (. false ., time_collisions (:, 1 ), ' collisions' ) end subroutine advance_collisions_dougherty_explicit subroutine vpa_differential_operator ( tfac , h , Dh ) use vpamu_grids , only : nvpa , vpa , dvpa implicit none real , intent ( in ) :: tfac complex , dimension (:), intent ( in ) :: h complex , dimension (:), intent ( out ) :: Dh integer :: iv ! use h = 0 at ghost cells beyond +/- vpa_max iv = 1 Dh ( iv ) = ( 0.5 * h ( iv + 1 ) * ( tfac / dvpa + vpa ( iv + 1 )) - tfac * h ( iv ) / dvpa ) / dvpa iv = nvpa Dh ( iv ) = ( - tfac * h ( iv ) / dvpa + 0.5 * h ( iv - 1 ) * ( tfac / dvpa - vpa ( iv - 1 ))) / dvpa do iv = 2 , nvpa - 1 Dh ( iv ) = ( 0.5 * h ( iv + 1 ) * ( tfac / dvpa + vpa ( iv + 1 )) - tfac * h ( iv ) / dvpa & + 0.5 * h ( iv - 1 ) * ( tfac / dvpa - vpa ( iv - 1 ))) / dvpa end do end subroutine vpa_differential_operator subroutine mu_differential_operator ( tfac , iz , ia , h , Dh ) use vpamu_grids , only : nmu , dmu use vpamu_grids , only : mu_cell , dmu_cell , wgts_mu_bare use vpamu_grids , only : equally_spaced_mu_grid use stella_geometry , only : bmag implicit none real , intent ( in ) :: tfac integer , intent ( in ) :: iz , ia complex , dimension (:), intent ( in ) :: h complex , dimension (:), intent ( out ) :: Dh integer :: imu real :: mm , m0 , mp ! the following finite difference method is explained in init_mudiff_matrix imu = 1 m0 = dmu_cell ( imu ) * ( 1.0 - tfac / ( dmu ( imu ) * bmag ( ia , iz ))) / wgts_mu_bare ( imu ) mp = mu_cell ( imu ) * ( tfac / ( bmag ( ia , iz ) * dmu ( imu )) + 1.0 ) / wgts_mu_bare ( imu ) Dh ( imu ) = m0 * h ( imu ) + mp * h ( imu + 1 ) imu = nmu mm = mu_cell ( imu - 1 ) * ( tfac / ( bmag ( ia , iz ) * dmu ( imu - 1 )) - 1.0 ) / wgts_mu_bare ( imu ) m0 = - mu_cell ( imu - 1 ) * ( tfac / ( dmu ( imu - 1 ) * bmag ( ia , iz )) + 1.0 ) / wgts_mu_bare ( imu ) Dh ( imu ) = mm * h ( imu - 1 ) + m0 * h ( imu ) do imu = 2 , nmu - 1 mm = mu_cell ( imu - 1 ) * ( tfac / ( bmag ( ia , iz ) * dmu ( imu - 1 )) - 1.0 ) / wgts_mu_bare ( imu ) m0 = - ( mu_cell ( imu ) / dmu ( imu ) + mu_cell ( imu - 1 ) / dmu ( imu - 1 )) & * tfac / ( wgts_mu_bare ( imu ) * bmag ( ia , iz )) + dmu_cell ( imu ) / wgts_mu_bare ( imu ) mp = mu_cell ( imu ) * ( tfac / ( bmag ( ia , iz ) * dmu ( imu )) + 1.0 ) / wgts_mu_bare ( imu ) Dh ( imu ) = mm * h ( imu - 1 ) + m0 * h ( imu ) + mp * h ( imu + 1 ) end do end subroutine mu_differential_operator subroutine conserve_momentum ( iky , ikx , iz , is , ikxkyz , h , Ch ) use species , only : spec use stella_geometry , only : bmag use vpamu_grids , only : integrate_vmu use vpamu_grids , only : vpa , nvpa , nmu , vperp2 use vpamu_grids , only : maxwell_vpa , maxwell_mu !     use vpamu_grids, only: int_vpa2 use dist_fn_arrays , only : kperp2 use gyro_averages , only : aj0v , aj1v implicit none integer , intent ( in ) :: iky , ikx , iz , is , ikxkyz complex , dimension (:, :), intent ( in ) :: h complex , dimension (:, :), intent ( in out ) :: Ch complex , dimension (:, :), allocatable :: u_fac complex :: integral integer :: ia real :: norm allocate ( u_fac ( nvpa , nmu )) ia = 1 !   norm = 1.0/int_vpa2(ia,iz,is) norm = 2.0 if ( vpa_operator ) then u_fac = spread ( aj0v (:, ikxkyz ), 1 , nvpa ) * spread ( vpa , 2 , nmu ) call integrate_vmu ( u_fac * h , iz , integral ) Ch = Ch + norm * u_fac * integral * spread ( maxwell_mu ( 1 , iz , :, is ), 1 , nvpa ) * spread ( maxwell_vpa (:, is ), 2 , nmu ) end if if ( mu_operator ) then u_fac = spread ( vperp2 ( ia , iz , :) * aj1v (:, ikxkyz ), 1 , nvpa ) * sqrt ( kperp2 ( iky , ikx , ia , iz )) * spec ( is )% smz / bmag ( ia , iz ) call integrate_vmu ( u_fac * h , iz , integral ) Ch = Ch + norm * u_fac * integral * spread ( maxwell_mu ( 1 , iz , :, is ), 1 , nvpa ) * spread ( maxwell_vpa (:, is ), 2 , nmu ) end if deallocate ( u_fac ) end subroutine conserve_momentum subroutine conserve_energy ( iz , is , ikxkyz , h , Ch ) use vpamu_grids , only : integrate_vmu use vpamu_grids , only : vpa , nvpa , nmu , vperp2 use vpamu_grids , only : maxwell_vpa , maxwell_mu !   use vpamu_grids, only: int_unit, int_vpa2, int_vperp2, int_vfrth use gyro_averages , only : aj0v implicit none integer , intent ( in ) :: iz , is , ikxkyz complex , dimension (:, :), intent ( in ) :: h complex , dimension (:, :), intent ( in out ) :: Ch complex , dimension (:, :), allocatable :: T_fac complex :: integral real :: norm integer :: ia allocate ( T_fac ( nvpa , nmu )) ia = 1 T_fac = 0.0 if ( vpa_operator ) T_fac = spread ( aj0v (:, ikxkyz ), 1 , nvpa ) * ( spread ( vpa ** 2 , 2 , nmu )) - 0.5 if ( mu_operator ) T_fac = T_fac + spread ( vperp2 ( ia , iz , :), 1 , nvpa ) - 1.0 call integrate_vmu ( T_fac * h , iz , integral ) !     norm = 1.0/(int_vfrth(ia,iz,is) - (int_vperp2(ia,iz,is) + int_vpa2(ia,iz,is))**2/int_unit(ia,iz,is)) norm = 2.0 / 3.0 Ch = Ch + 2.0 * norm * T_fac * integral * spread ( maxwell_mu ( ia , iz , :, is ), 1 , nvpa ) * spread ( maxwell_vpa (:, is ), 2 , nmu ) deallocate ( T_fac ) end subroutine conserve_energy subroutine conserve_momentum_vmulo ( h , gke_rhs ) use mp , only : sum_allreduce use stella_time , only : code_dt use stella_layouts , only : vmu_lo use stella_layouts , only : imu_idx , iv_idx , is_idx use species , only : spec use physics_flags , only : radial_variation use stella_geometry , only : bmag , dBdrho use kt_grids , only : nakx , naky , multiply_by_rho use zgrid , only : nzgrid , ntubes use vpamu_grids , only : integrate_species , mu , vpa , vperp2 use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use dist_fn_arrays , only : kperp2 , dkperp2dr use gyro_averages , only : gyro_average , gyro_average_j1 , aj0x , aj1x implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: h complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: gke_rhs complex , dimension (:, :), allocatable :: g0k , g1k complex , dimension (:, :, :), allocatable :: gyro_g complex , dimension (:, :, :, :), allocatable :: field1 , field2 real :: prefac , energy integer :: it , iz , ivmu , imu , iv , ia , is ia = 1 allocate ( g0k ( naky , nakx )) allocate ( g1k ( naky , nakx )) allocate ( gyro_g ( naky , nakx , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) allocate ( field1 ( naky , nakx , - nzgrid : nzgrid , ntubes )) allocate ( field2 ( naky , nakx , - nzgrid : nzgrid , ntubes )) !component from vpa do it = 1 , ntubes do iz = - nzgrid , nzgrid do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) iv = iv_idx ( vmu_lo , ivmu ) call gyro_average ( h (:, :, iz , it , ivmu ), iz , ivmu , gyro_g (:, :, ivmu )) gyro_g (:, :, ivmu ) = gyro_g (:, :, ivmu ) * vpa ( iv ) g0k = 0.0 if ( radial_variation ) then g0k (:, :) = gyro_g (:, :, ivmu ) & * ( - 0.5 * aj1x (:, :, iz , ivmu ) / aj0x (:, :, iz , ivmu ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 (:, :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) & + dBdrho ( iz ) / bmag ( ia , iz )) call multiply_by_rho ( g0k ) end if gyro_g (:, :, ivmu ) = gyro_g (:, :, ivmu ) + g0k end do call integrate_species ( gyro_g , iz , spec % dens_psi0 * spec % temp_psi0 , field1 (:, :, iz , it ), reduce_in = . false .) end do end do call sum_allreduce ( field1 ) !component from vperp do it = 1 , ntubes do iz = - nzgrid , nzgrid do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) iv = iv_idx ( vmu_lo , ivmu ) !component from vpa call gyro_average_j1 ( h (:, :, iz , it , ivmu ), iz , ivmu , gyro_g (:, :, ivmu )) gyro_g (:, :, ivmu ) = gyro_g (:, :, ivmu ) * vperp2 ( ia , iz , imu ) * sqrt ( kperp2 (:, :, ia , iz )) * spec ( is )% smz_psi0 / bmag ( ia , iz ) g0k = 0.0 if ( radial_variation ) then g0k = gyro_g (:, :, ivmu ) * ( dBdrho ( iz ) / bmag ( ia , iz ) + 0.5 * dkperp2dr (:, :, ia , iz )) & + h (:, :, iz , it , ivmu ) * ( 0.5 * aj0x (:, :, iz , ivmu ) - aj1x (:, :, iz , ivmu )) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) * vperp2 ( ia , iz , imu ) & * sqrt ( kperp2 (:, :, ia , iz )) * spec ( is )% smz_psi0 / bmag ( ia , iz ) call multiply_by_rho ( g0k ) end if gyro_g (:, :, ivmu ) = gyro_g (:, :, ivmu ) + g0k end do call integrate_species ( gyro_g , iz , spec % dens_psi0 * spec % temp_psi0 , field2 (:, :, iz , it ), reduce_in = . false .) end do end do call sum_allreduce ( field2 ) deallocate ( gyro_g ) do it = 1 , ntubes do iz = - nzgrid , nzgrid do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) iv = iv_idx ( vmu_lo , ivmu ) prefac = 2.0 / ( spec ( is )% dens * spec ( is )% temp ) * code_dt * spec ( is )% vnew ( is ) & * maxwell_mu ( ia , iz , imu , is ) * maxwell_vpa ( iv , is ) * maxwell_fac ( is ) g0k = aj0x (:, :, iz , ivmu ) * vpa ( iv ) * field1 (:, :, iz , it ) & + aj1x (:, :, iz , ivmu ) * vperp2 ( ia , iz , imu ) * field2 (:, :, iz , it ) & * spec ( is )% smz_psi0 * sqrt ( kperp2 (:, :, ia , iz )) / bmag ( ia , iz ) gke_rhs (:, :, iz , it , ivmu ) = gke_rhs (:, :, iz , it , ivmu ) + prefac * g0k if ( radial_variation ) then energy = ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu )) * ( spec ( is )% temp_psi0 / spec ( is )% temp ) g1k = field1 (:, :, iz , it ) * vpa ( iv ) * ( - 0.5 * aj1x (:, :, iz , ivmu ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 (:, :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz ))) & + field2 (:, :, iz , it ) * spec ( is )% smz_psi0 * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) * sqrt ( kperp2 (:, :, ia , iz )) & * ( 0.5 * aj1x (:, :, iz , ivmu ) * dkperp2dr (:, :, ia , iz ) + ( 0.5 * aj0x (:, :, iz , ivmu ) - aj1x (:, :, iz , ivmu )) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz ))) g1k = g1k + g0k * ( spec ( is )% tprim * ( energy - 2.5 ) + 2 * mu ( imu ) * dBdrho ( iz )) call multiply_by_rho ( g1k ) gke_rhs (:, :, iz , it , ivmu ) = gke_rhs (:, :, iz , it , ivmu ) + prefac * g1k end if end do end do end do deallocate ( g0k , g1k ) deallocate ( field1 , field2 ) end subroutine conserve_momentum_vmulo subroutine conserve_energy_vmulo ( h , gke_rhs ) use mp , only : sum_allreduce use stella_time , only : code_dt use stella_layouts , only : vmu_lo use stella_layouts , only : imu_idx , iv_idx , is_idx use species , only : spec use physics_flags , only : radial_variation use stella_geometry , only : bmag , dBdrho use kt_grids , only : nakx , naky , multiply_by_rho use zgrid , only : nzgrid , ntubes use vpamu_grids , only : integrate_species use vpamu_grids , only : mu , vpa , nmu , vperp2 use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use dist_fn_arrays , only : kperp2 , dkperp2dr use gyro_averages , only : gyro_average , gyro_average_j1 , aj0x , aj1x implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: h complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: gke_rhs complex , dimension (:, :), allocatable :: g0k , g1k complex , dimension (:, :, :), allocatable :: gyro_g complex , dimension (:, :, :, :), allocatable :: field real :: prefac , energy integer :: it , iz , ivmu , imu , iv , ia , is ia = 1 allocate ( g0k ( naky , nakx )) allocate ( g1k ( naky , nakx )) allocate ( gyro_g ( naky , nakx , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) allocate ( field ( naky , nakx , - nzgrid : nzgrid , ntubes )) !component from vpa do it = 1 , ntubes do iz = - nzgrid , nzgrid do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) iv = iv_idx ( vmu_lo , ivmu ) call gyro_average ( h (:, :, iz , it , ivmu ), iz , ivmu , gyro_g (:, :, ivmu )) gyro_g (:, :, ivmu ) = gyro_g (:, :, ivmu ) * ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu ) - 1.5 * spec ( is )% temp / spec ( is )% temp_psi0 ) g0k = 0.0 if ( radial_variation ) then g0k (:, :) = gyro_g (:, :, ivmu ) & * ( - 0.5 * aj1x (:, :, iz , ivmu ) / aj0x (:, :, iz , ivmu ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 (:, :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) & + dBdrho ( iz ) / bmag ( ia , iz )) & + h (:, :, iz , it , ivmu ) * aj0x (:, :, iz , ivmu ) * ( vperp2 ( ia , iz , imu ) * dBdrho ( iz ) / bmag ( ia , iz ) & + 1.5 * spec ( is )% tprim ) call multiply_by_rho ( g0k ) end if gyro_g (:, :, ivmu ) = gyro_g (:, :, ivmu ) + g0k end do call integrate_species ( gyro_g , iz , spec % dens_psi0 * spec % temp_psi0 ** 2 , field (:, :, iz , it ), reduce_in = . false .) end do end do call sum_allreduce ( field ) deallocate ( gyro_g ) do it = 1 , ntubes do iz = - nzgrid , nzgrid do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) iv = iv_idx ( vmu_lo , ivmu ) prefac = 4.0 / ( 3.0 * spec ( is )% dens * spec ( is )% temp ** 2 ) * code_dt * spec ( is )% vnew ( is ) & * maxwell_mu ( ia , iz , imu , is ) * maxwell_vpa ( iv , is ) * maxwell_fac ( is ) g0k = aj0x (:, :, iz , ivmu ) * field (:, :, iz , it ) & * ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu ) - 1.5 * spec ( is )% temp / spec ( is )% temp_psi0 ) gke_rhs (:, :, iz , it , ivmu ) = gke_rhs (:, :, iz , it , ivmu ) + prefac * g0k if ( radial_variation ) then energy = ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu )) * ( spec ( is )% temp_psi0 / spec ( is )% temp ) g1k = field (:, :, iz , it ) * ( energy - 1.5 ) * ( - 0.5 * aj1x (:, :, iz , ivmu ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 (:, :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz ))) & + field (:, :, iz , it ) * aj0x (:, :, iz , ivmu ) * ( vperp2 ( ia , iz , imu ) * dBdrho ( iz ) / bmag ( ia , iz ) + 1.5 * spec ( is )% tprim ) g1k = g1k + g0k * ( spec ( is )% tprim * ( energy - 3.5 ) + 2 * mu ( imu ) * dBdrho ( iz )) call multiply_by_rho ( g1k ) gke_rhs (:, :, iz , it , ivmu ) = gke_rhs (:, :, iz , it , ivmu ) + prefac * g1k end if end do end do end do deallocate ( g0k , g1k ) deallocate ( field ) end subroutine conserve_energy_vmulo subroutine advance_collisions_dougherty_implicit ( phi , apar , bpar ) use zgrid , only : nzgrid use dist_fn_arrays , only : gvmu implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in out ) :: phi , apar , bpar if ( vpa_operator ) call advance_vpadiff_implicit ( phi , apar , bpar , gvmu ) if ( mu_operator ) call advance_mudiff_implicit ( phi , apar , bpar , gvmu ) end subroutine advance_collisions_dougherty_implicit subroutine advance_vpadiff_implicit ( phi , apar , bpar , g ) use mp , only : sum_allreduce use finite_differences , only : tridag use linear_solve , only : lu_back_substitution use stella_time , only : code_dt use run_parameters , only : fphi use species , only : nspec , spec , has_electron_species use zgrid , only : nzgrid , ntubes use vpamu_grids , only : nmu , nvpa use vpamu_grids , only : maxwell_vpa , maxwell_mu , vpa , vperp2 use vpamu_grids , only : set_vpa_weights use kt_grids , only : naky , nakx , zonal_mode use stella_geometry , only : dl_over_b use stella_layouts , only : kxkyz_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , it_idx , is_idx use g_tofrom_h , only : g_to_h use gyro_averages , only : aj0v use fields , only : get_fields , efac , gamtot_h use physics_flags , only : adiabatic_option_switch use physics_flags , only : adiabatic_option_fieldlineavg implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in out ) :: phi , apar , bpar complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( in out ) :: g integer :: ikxkyz , iky , ikx , iz , it , is , ia integer :: imu integer :: idx real , dimension (:, :), allocatable :: tmp complex , dimension (:, :, :, :, :), allocatable :: flds complex , dimension (:), allocatable :: tmp2 complex , dimension (:, :, :), allocatable :: flds_zf , g_in ia = 1 ! store input g for use later, as g will be overwritten below allocate ( g_in ( nvpa , nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) g_in = g ! since backwards difference in time, (I-dt*D)h_inh&#94;{n+1} = g&#94;{***} ! g = g&#94;{***}.  tridag below inverts above equation to get h_inh&#94;{n+1} do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc is = is_idx ( kxkyz_lo , ikxkyz ) do imu = 1 , nmu call tridag ( 1 , aa_vpa (:, is ), bb_vpa (:, ikxkyz ), cc_vpa (:, is ), g (:, imu , ikxkyz )) end do end do allocate ( flds ( naky , nakx , - nzgrid : nzgrid , ntubes , nresponse_vpa )) allocate ( flds_zf ( nakx , ntubes , nresponse_vpa )); flds_zf = 0. ! need to obtain phi&#94;{n+1} and conservation terms using response matrix approach ! first get phi_inh&#94;{n+1} call get_fields ( g , phi , apar , bpar , dist = 'h' , skip_fsa = . true .) flds (:, :, :, :, 1 ) = phi idx = 2 ! get upar_inh&#94;{n+1} if ( momentum_conservation ) then call get_upar ( g , flds (:, :, :, :, idx : idx + nspec - 1 )) idx = idx + nspec end if ! get temp_inh&#94;{n+1} if ( energy_conservation ) call get_temp ( g , flds (:, :, :, :, idx : idx + nspec - 1 )) phi = 0.0 do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) ! all is indices inside ikxkyz super-index have same info ! no need to compute multiple times is = is_idx ( kxkyz_lo , ikxkyz ); if ( is /= 1 ) cycle call lu_back_substitution ( vpadiff_response (:, :, ikxkyz ), vpadiff_idx (:, ikxkyz ), & flds ( iky , ikx , iz , it , :)) if (. not . has_electron_species ( spec ) . and . zonal_mode ( iky ) & . and . adiabatic_option_switch == adiabatic_option_fieldlineavg ) then flds_zf ( ikx , it , :) = flds_zf ( ikx , it , :) + dl_over_b ( ia , iz ) * flds ( iky , ikx , iz , it , :) end if phi ( iky , ikx , iz , it ) = flds ( iky , ikx , iz , it , 1 ) end do if (. not . has_electron_species ( spec ) . and . zonal_mode ( 1 ) & . and . adiabatic_option_switch == adiabatic_option_fieldlineavg ) then !complete flux-surface average call sum_allreduce ( flds_zf ) do it = 1 , ntubes do ikx = 1 , nakx call lu_back_substitution ( vpadiff_zf_response (:, :, ikx ), vpadiff_zf_idx (:, ikx ), & flds_zf ( ikx , it , :)) !multiply by Q, which has a single non-zero component flds_zf ( ikx , it , 1 ) = ( efac / gamtot_h ) * flds_zf ( ikx , it , 1 ) flds_zf ( ikx , it , 2 :) = 0. end do end do allocate ( tmp2 ( nresponse_vpa )) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) if ( iky /= 1 . or . is /= 1 ) cycle tmp2 = flds_zf ( ikx , it , :) call lu_back_substitution ( vpadiff_response (:, :, ikxkyz ), vpadiff_idx (:, ikxkyz ), & tmp2 ) phi ( 1 , ikx , iz , it ) = phi ( 1 , ikx , iz , it ) + tmp2 ( 1 ) end do deallocate ( tmp2 ) end if call sum_allreduce ( phi ) g = g_in ! RHS is g&#94;{***} + Ze/T*<phi&#94;{n+1}>*F0 + 2*dt*nu*J0*F0*(vpa*upar+(v&#94;2-3/2)*temp) ! first two terms added via g_to_h subroutine call g_to_h ( g , phi , bpar , fphi ) allocate ( tmp ( nvpa , nmu )) if ( momentum_conservation . or . energy_conservation ) then do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) tmp = 2.0 * code_dt * spec ( is )% vnew ( is ) & * spread ( maxwell_vpa (:, is ), 2 , nmu ) * spread ( aj0v (:, ikxkyz ) * maxwell_mu ( 1 , iz , :, is ), 1 , nvpa ) if ( momentum_conservation ) & g (:, :, ikxkyz ) = g (:, :, ikxkyz ) + tmp * spread ( vpa * flds ( iky , ikx , iz , it , is + 1 ), 2 , nmu ) if ( energy_conservation ) & g (:, :, ikxkyz ) = g (:, :, ikxkyz ) & + tmp * ( spread ( vpa ** 2 , 2 , nmu ) + spread ( vperp2 ( 1 , iz , :), 1 , nvpa ) - 1.5 ) * flds ( iky , ikx , iz , it , idx + is - 1 ) end do end if deallocate ( tmp , flds , flds_zf ) ! now invert system to get h&#94;{n+1} do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc is = is_idx ( kxkyz_lo , ikxkyz ) do imu = 1 , nmu call tridag ( 1 , aa_vpa (:, is ), bb_vpa (:, ikxkyz ), cc_vpa (:, is ), g (:, imu , ikxkyz )) end do end do ! now get g&#94;{n+1} from h&#94;{n+1} and phi&#94;{n+1} call g_to_h ( g , phi , bpar , - fphi ) deallocate ( g_in ) end subroutine advance_vpadiff_implicit subroutine advance_mudiff_implicit ( phi , apar , bpar , g ) use mp , only : sum_allreduce use finite_differences , only : tridag use linear_solve , only : lu_back_substitution use stella_time , only : code_dt use run_parameters , only : fphi use species , only : nspec , spec , has_electron_species use zgrid , only : nzgrid , ntubes use vpamu_grids , only : nmu , nvpa use vpamu_grids , only : maxwell_vpa , maxwell_mu , vpa , vperp2 use vpamu_grids , only : set_vpa_weights use kt_grids , only : naky , nakx , zonal_mode use stella_layouts , only : kxkyz_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , it_idx , is_idx use dist_fn_arrays , only : kperp2 use gyro_averages , only : aj0v , aj1v use g_tofrom_h , only : g_to_h use fields , only : get_fields , efac , gamtot_h use stella_geometry , only : bmag , dl_over_b use physics_flags , only : adiabatic_option_switch use physics_flags , only : adiabatic_option_fieldlineavg ! TMP FOR TESTING !    use vpamu_grids, only: mu implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in out ) :: phi , apar , bpar complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( in out ) :: g integer :: ikxkyz , iky , ikx , iz , it , is , ia integer :: iv integer :: idx ! TMP FOR TESTING !    integer :: imu real , dimension (:, :), allocatable :: tmp complex , dimension (:), allocatable :: tmp2 complex , dimension (:, :, :, :, :), allocatable :: flds complex , dimension (:, :, :), allocatable :: flds_zf , g_in ia = 1 ! store input g for use later, as g will be overwritten below allocate ( g_in ( nvpa , nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) g_in = g ! since backwards difference in time, (I-dt*D)h_inh&#94;{n+1} = g&#94;{***} ! g = g&#94;{***}.  tridag below inverts above equation to get h_inh&#94;{n+1} do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) ! TMP FOR TESTING !       do imu = 1, nmu !          g(:,imu,ikxkyz) = maxwell_vpa*maxwell_mu(1,iz,imu) !       end do do iv = 1 , nvpa call tridag ( 1 , aa_mu ( iz , :, is ), bb_mu (:, ikxkyz ), cc_mu ( iz , :, is ), g ( iv , :, ikxkyz )) end do ! TMP FOR TESTING !       iv = nvpa/2 !       do imu = 1, nmu !          write (*,*) 'ggg', mu(imu), real(g(iv,imu,ikxkyz)), aimag(g(iv,imu,ikxkyz)), maxwell_vpa(iv,is)*maxwell_mu(1,iz,imu) !       end do end do allocate ( flds ( naky , nakx , - nzgrid : nzgrid , ntubes , nresponse_mu )) allocate ( flds_zf ( nakx , ntubes , nresponse_mu )); flds_zf = 0. ! need to obtain phi&#94;{n+1} and conservation terms using response matrix approach ! first get phi_inh&#94;{n+1} call get_fields ( g , phi , apar , bpar , dist = 'h' , skip_fsa = . true .) flds (:, :, :, :, 1 ) = phi idx = 2 ! get upar_inh&#94;{n+1} if ( momentum_conservation ) then call get_uperp ( g , flds (:, :, :, :, idx : idx + nspec - 1 )) idx = idx + nspec end if ! get temp_inh&#94;{n+1} if ( energy_conservation ) call get_temp_mu ( g , flds (:, :, :, :, idx : idx + nspec - 1 )) phi = 0.0 do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) ! all is indices inside ikxkyz super-index have same info ! no need to compute multiple times is = is_idx ( kxkyz_lo , ikxkyz ); if ( is /= 1 ) cycle call lu_back_substitution ( mudiff_response (:, :, ikxkyz ), mudiff_idx (:, ikxkyz ), & flds ( iky , ikx , iz , it , :)) if (. not . has_electron_species ( spec ) . and . zonal_mode ( iky ) & . and . adiabatic_option_switch == adiabatic_option_fieldlineavg ) then flds_zf ( ikx , it , :) = flds_zf ( ikx , it , :) + dl_over_b ( ia , iz ) * flds ( iky , ikx , iz , it , :) end if phi ( iky , ikx , iz , it ) = flds ( iky , ikx , iz , it , 1 ) end do if (. not . has_electron_species ( spec ) . and . zonal_mode ( 1 ) & . and . adiabatic_option_switch == adiabatic_option_fieldlineavg ) then !complete flux-surface average call sum_allreduce ( flds_zf ) do it = 1 , ntubes do ikx = 1 , nakx call lu_back_substitution ( mudiff_zf_response (:, :, ikx ), mudiff_zf_idx (:, ikx ), & flds_zf ( ikx , it , :)) !multiply by Q, which has a single non-zero component flds_zf ( ikx , it , 1 ) = ( efac / gamtot_h ) * flds_zf ( ikx , it , 1 ) flds_zf ( ikx , it , 2 :) = 0. end do end do allocate ( tmp2 ( nresponse_mu )) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) if ( iky /= 1 . or . is /= 1 ) cycle tmp2 = flds_zf ( ikx , it , :) call lu_back_substitution ( mudiff_response (:, :, ikxkyz ), mudiff_idx (:, ikxkyz ), & tmp2 ) phi ( 1 , ikx , iz , it ) = phi ( 1 , ikx , iz , it ) + tmp2 ( 1 ) end do deallocate ( tmp2 ) end if call sum_allreduce ( phi ) g = g_in ! RHS is g&#94;{***} + Ze/T*<phi&#94;{n+1}>*F0 + ... ! first two terms added via g_to_h subroutine call g_to_h ( g , phi , bpar , fphi ) allocate ( tmp ( nvpa , nmu )) if ( momentum_conservation . or . energy_conservation ) then do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) tmp = 2.0 * code_dt * spec ( is )% vnew ( is ) & * spread ( maxwell_vpa (:, is ), 2 , nmu ) * spread ( maxwell_mu ( 1 , iz , :, is ), 1 , nvpa ) if ( momentum_conservation ) & g (:, :, ikxkyz ) = g (:, :, ikxkyz ) + tmp * kperp2 ( iky , ikx , ia , iz ) & * spread ( vperp2 ( ia , iz , :) * aj1v (:, ikxkyz ), 1 , nvpa ) * ( spec ( is )% smz / bmag ( ia , iz )) ** 2 & * flds ( iky , ikx , iz , it , is + 1 ) if ( energy_conservation ) & g (:, :, ikxkyz ) = g (:, :, ikxkyz ) & + flds ( iky , ikx , iz , it , idx + is - 1 ) * tmp * spread ( aj0v (:, ikxkyz ), 1 , nvpa ) & * ( spread ( vpa ** 2 , 2 , nmu ) + spread ( vperp2 ( 1 , iz , :), 1 , nvpa ) - 1.5 ) end do end if deallocate ( tmp , flds , flds_zf ) ! now invert system to get h&#94;{n+1} do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) do iv = 1 , nvpa call tridag ( 1 , aa_mu ( iz , :, is ), bb_mu (:, ikxkyz ), cc_mu ( iz , :, is ), g ( iv , :, ikxkyz )) end do end do ! now get g&#94;{n+1} from h&#94;{n+1} and phi&#94;{n+1} call g_to_h ( g , phi , bpar , - fphi ) deallocate ( g_in ) end subroutine advance_mudiff_implicit end module coll_dougherty","tags":"","loc":"sourcefile/coll_dougherty.f90.html"},{"title":"ezcdf.f90 – stella","text":"Source Code !EZcdf, Easy Interface to netCDF Routine Calls !============================================= !The module is available through the NTCC Webpage, !w3.pppl.gov/NTTC  under \"Modules Library\", as compressed !tarfile, ezcdf.tar.gz, and as zip archive, ezcdf.zip. !Alternatively it can be obtained from ftp.pppl.gov !in pub/NTCC/. ! AUTHORS !Conceived by 7/98 by Sunitinder Sekhon !Modified by J. Menard 12/98 to run on Cray C90 !Completely re-written by C.Ludescher 2/99 !Added complex support (64 and 128 bit) by A. Pletzer 5/01 ! CONTACT ! C. Ludescher cludescher@pppl.gov ! A. Pletzer   pletzer@pppl.gov ! REVISION HISTORY !      date         Description ! February  1999  -- Created ! April     2000  -- A.Pletzer: Added R4 ! May 01,   2000  -- C. Ludescher: Simplified by adding module ezcdf ! May 17,   2001  -- A. Pletzer: Added C8 and C16 ! Interface for cdfopn to handle optional argument ier ! 04/28/00 C.Ludescher ! + ezcdf_close for symmetry (ap) ! September 2002  -- S. Hirshman, added aliases to mimic F90 I/O routines !                    added cdf_inquire with OPTIONAL xtype argument !                    added 'LOG' data type (nf_int) to handle logicals !                    (user may use 'INT' interchangeably) ! ! April 2003      -- removed ONLY and some rename clauses from USE stmts !                    (D. McCune).  These caused problems, because an !                    application with \"use ezcdf\" would indirectly see !                    \"use ezcdf_inqvar\" with various ONLY clauses; it !                    was unclear which one would rule, but, at load time !                    it was clear that the ONLY clauses were making some !                    legitimate ezcdf entries invisible, at least when !                    built using Lahey-Fujitsu fortran.  Also, the !                    indirect presence of multiple \"USE ezcdf_opencls\" !                    with rename lists caused problems which were resolved !                    by removing the rename lists ans using INTERFACE !                    statements inside ezcdf_opncls instead. ! MODULE ezcdf ! No aliases. this caused the Intel compiler to fail, so I had to duplicate ! 2 interfaces: cdfPutVar <=> cdf_write and cdfGetVar <=> cdf_read (pletzer) USE ezcdf_GenGet USE ezcdf_opncls END MODULE ezcdf","tags":"","loc":"sourcefile/ezcdf.f90.html"},{"title":"test_vmec_to_stella_geometry_interface.f90 – stella","text":"Source Code program test_vmec_to_stella_geometry_interface use vmec_to_stella_geometry_interface_mod implicit none !********************************************************************* ! Input parameters !********************************************************************* character ( len = 2000 ) :: vmec_filename = 'equilibria/wout_w7x_standardConfig.nc' !  character(len=2000) :: vmec_filename = 'equilibria/wout_161s1.nc' integer , parameter :: nalpha = 5 integer , parameter :: nzgrid = 7 real :: alpha0 = 0.0 real :: gradpar_zeta_prefac = 1.0 ! JFP Feb 11 2022 real :: zeta_center = 0.0 real :: number_of_field_periods_to_include = 1 real :: desired_normalized_toroidal_flux = 0.6354167d+0 integer :: vmec_surface_option = 0 logical :: verbose = . true . !********************************************************************* ! Output arrays !********************************************************************* real :: normalized_toroidal_flux_used , safety_factor_q , shat , L_reference , B_reference , nfp integer :: sign_toroidal_flux real , dimension ( nalpha ) :: alpha real , dimension ( - nzgrid : nzgrid ) :: zeta real , dimension ( nalpha , - nzgrid : nzgrid ) :: bmag , gradpar , gds2 , gds21 , gds22 , gds23 , gds24 , gds25 , gds26 real , dimension ( nalpha , - nzgrid : nzgrid ) :: gbdrift , gbdrift0 , cvdrift , cvdrift0 real , dimension ( nalpha , - nzgrid : nzgrid ) :: theta_vmec real , dimension ( nalpha , - nzgrid : nzgrid ) :: B_sub_zeta , B_sub_theta_vmec , displacement ! This code uses normalizations in which kxfac is always 1, so kxfac is not presently returned. !********************************************************************* ! Variables used internally by this program !********************************************************************* integer :: j , iunit , ierr !********************************************************************* ! Beginning of executable statements !********************************************************************* call read_vmec_equilibrium ( vmec_filename , verbose , ierr ) call vmec_to_stella_geometry_interface ( nalpha , alpha0 , nzgrid , zeta_center , & number_of_field_periods_to_include , & desired_normalized_toroidal_flux , vmec_surface_option , verbose , & normalized_toroidal_flux_used , safety_factor_q , shat , L_reference , B_reference , nfp , & sign_toroidal_flux , & alpha , zeta , bmag , gradpar , gds2 , gds21 , gds22 , gds23 , gds24 , gds25 , gds26 , & gbdrift , gbdrift0 , cvdrift , cvdrift0 , & theta_vmec , B_sub_zeta , B_sub_theta_vmec , displacement , gradpar_zeta_prefac , & ierr ) print * , \"-------------- Input parameters ------------------\" print * , \"vmec_filename: \" , trim ( vmec_filename ) print * , \"nalpha:\" , nalpha print * , \"alpha0:\" , alpha0 print * , \"nzgrid:\" , nzgrid print * , \"zeta_center:\" , zeta_center print * , \"number_of_field_periods_to_include:\" , number_of_field_periods_to_include print * , \"desired_normalized_toroidal_flux:\" , desired_normalized_toroidal_flux print * , \"vmec_surface_option:\" , vmec_surface_option print * , \"gradpar_zeta_prefac:\" , gradpar_zeta_prefac print * , \"-------------- Output parameters -----------------\" print * , \"normalized_toroidal_flux_used:\" , normalized_toroidal_flux_used print * , \"safety_factor_q:\" , safety_factor_q print * , \"shat:\" , shat print * , \"L_reference:\" , L_reference print * , \"B_reference:\" , B_reference print * , \"nfp:\" , nfp print * , \"alpha:\" print * , alpha print * , \"zeta:\" print * , zeta print * , \"bmag:\" do j = 1 , nalpha print * , bmag ( j , :) end do print * , \"gradpar:\" do j = 1 , nalpha print * , gradpar ( j , :) end do print * , \"gds2:\" do j = 1 , nalpha print * , gds2 ( j , :) end do print * , \"gds21:\" do j = 1 , nalpha print * , gds21 ( j , :) end do print * , \"gds22:\" do j = 1 , nalpha print * , gds22 ( j , :) end do print * , \"gds23:\" do j = 1 , nalpha print * , gds23 ( j , :) end do print * , \"gds24:\" do j = 1 , nalpha print * , gds24 ( j , :) end do print * , \"gds25:\" do j = 1 , nalpha print * , gds25 ( j , :) end do print * , \"gds26:\" do j = 1 , nalpha print * , gds26 ( j , :) end do print * , \"gbdrift:\" do j = 1 , nalpha print * , gbdrift ( j , :) end do print * , \"gbdrift0:\" do j = 1 , nalpha print * , gbdrift0 ( j , :) end do print * , \"cvdrfit:\" do j = 1 , nalpha print * , cvdrift ( j , :) end do print * , \"cvdrift0:\" do j = 1 , nalpha print * , cvdrift0 ( j , :) end do print * , \"theta_vmec:\" do j = 1 , nalpha print * , theta_vmec ( j , :) end do iunit = 6 open ( file = 'geometry.dat' , unit = iunit ) write ( iunit , * ) 'nalpha nzgrid' write ( iunit , * ) nalpha , nzgrid write ( iunit , * ) 'alpha' write ( iunit , * ) alpha write ( iunit , * ) 'zeta' write ( iunit , * ) zeta write ( iunit , * ) 'bmag' do j = 1 , nalpha write ( iunit , * ) bmag ( j , :) end do write ( iunit , * ) 'gradpar' do j = 1 , nalpha write ( iunit , * ) gradpar ( j , :) end do write ( iunit , * ) 'gds2' do j = 1 , nalpha write ( iunit , * ) gds2 ( j , :) end do write ( iunit , * ) 'gds21' do j = 1 , nalpha write ( iunit , * ) gds21 ( j , :) end do write ( iunit , * ) 'gds22' do j = 1 , nalpha write ( iunit , * ) gds22 ( j , :) end do write ( iunit , * ) 'gds23' do j = 1 , nalpha write ( iunit , * ) gds23 ( j , :) end do write ( iunit , * ) 'gds24' do j = 1 , nalpha write ( iunit , * ) gds24 ( j , :) end do write ( iunit , * ) 'gds25' do j = 1 , nalpha write ( iunit , * ) gds25 ( j , :) end do write ( iunit , * ) 'gds26' do j = 1 , nalpha write ( iunit , * ) gds26 ( j , :) end do write ( iunit , * ) 'gbdrift' do j = 1 , nalpha write ( iunit , * ) gbdrift ( j , :) end do write ( iunit , * ) 'gbdrift0' do j = 1 , nalpha write ( iunit , * ) gbdrift0 ( j , :) end do write ( iunit , * ) 'cvdrift' do j = 1 , nalpha write ( iunit , * ) cvdrift ( j , :) end do write ( iunit , * ) 'cvdrift0' do j = 1 , nalpha write ( iunit , * ) cvdrift0 ( j , :) end do write ( iunit , * ) 'theta_vmec' do j = 1 , nalpha write ( iunit , * ) theta_vmec ( j , :) end do close ( iunit ) end program test_vmec_to_stella_geometry_interface","tags":"","loc":"sourcefile/test_vmec_to_stella_geometry_interface.f90.html"},{"title":"sources.fpp – stella","text":"Source Code module sources #ifdef ISO_C_BINDING use mpi #endif implicit none public :: init_sources , finish_sources public :: init_quasineutrality_source public :: init_source_timeaverage public :: update_quasineutrality_source public :: source_option_switch , source_option_none public :: source_option_krook , source_option_projection public :: include_qn_source public :: update_tcorr_krook public :: project_out_zero public :: add_krook_operator public :: tcorr_source , exclude_boundary_regions , exp_fac public :: int_krook , int_proj public :: qn_source_initialized public :: time_sources private logical :: krook_odd , exclude_boundary_regions logical :: from_zero logical :: conserve_momentum , conserve_density integer :: ikxmax_source real :: nu_krook , tcorr_source , int_krook , int_proj real :: exp_fac logical :: qn_source_initialized , include_qn_source logical :: debug = . false . real , dimension ( 2 , 2 ) :: time_sources = 0. integer :: source_option_switch integer , parameter :: source_option_none = 1 , & source_option_krook = 2 , & source_option_projection = 3 contains subroutine init_sources use mp , only : job , proc0 use run_parameters , only : fphi use run_parameters , only : ky_solve_radial , ky_solve_real use kt_grids , only : naky , nakx , zonal_mode use zgrid , only : nzgrid , ntubes use stella_layouts , only : vmu_lo use dist_fn_arrays , only : g_krook , g_proj , g_symm use fields_arrays , only : phi_proj , phi_proj_stage use physics_flags , only : radial_variation use species , only : spec , has_electron_species use physics_flags , only : adiabatic_option_switch use physics_flags , only : adiabatic_option_fieldlineavg use file_utils , only : runtype_option_switch , runtype_multibox implicit none logical :: has_elec , adia_elec real :: fac debug = debug . and . proc0 call read_parameters if ( source_option_switch == source_option_krook . and . . not . allocated ( g_krook )) then allocate ( g_krook ( nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) g_krook = 0. end if if ( source_option_switch == source_option_projection . and . . not . allocated ( g_proj )) then allocate ( g_proj ( nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) g_proj = 0. end if if (. not . allocated ( phi_proj )) then allocate ( phi_proj ( nakx , - nzgrid : nzgrid , ntubes )); phi_proj = 0. end if if (. not . allocated ( phi_proj_stage )) then allocate ( phi_proj_stage ( nakx , - nzgrid : nzgrid , ntubes )); phi_proj_stage = 0. end if if (( conserve_momentum . or . conserve_density ) . and . . not . allocated ( g_symm )) then allocate ( g_symm ( naky , nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) end if fac = 1. if ( from_zero ) fac = 0. if ( int_krook < 0. ) int_krook = fac * tcorr_source if ( int_proj < 0. ) int_proj = fac * tcorr_source include_qn_source = . false . if ( fphi > epsilon ( 0.0 ) . and . radial_variation . and . ky_solve_radial > 0 ) then has_elec = has_electron_species ( spec ) adia_elec = . not . has_elec . and . zonal_mode ( 1 ) & . and . adiabatic_option_switch == adiabatic_option_fieldlineavg if ( adia_elec ) then if ( runtype_option_switch /= runtype_multibox . or . ( job == 1 . and . . not . ky_solve_real )) then include_qn_source = . true . end if end if end if end subroutine init_sources subroutine read_parameters use file_utils , only : input_unit_exist , error_unit use physics_flags , only : radial_variation use mp , only : proc0 , broadcast use kt_grids , only : ikx_max , periodic_variation use fields_arrays , only : tcorr_source_qn , exclude_boundary_regions_qn use text_options , only : text_option , get_option_value implicit none type ( text_option ), dimension ( 4 ), parameter :: sourceopts = & ( / text_option ( 'default' , source_option_none ), & text_option ( 'none' , source_option_none ), & text_option ( 'krook' , source_option_krook ), & text_option ( 'projection' , source_option_projection ) / ) character ( 30 ) :: source_option integer :: in_file , ierr logical :: dexist namelist / sources / & source_option , nu_krook , tcorr_source , & ikxmax_source , krook_odd , exclude_boundary_regions , & tcorr_source_qn , exclude_boundary_regions_qn , from_zero , & conserve_momentum , conserve_density if ( proc0 ) then exclude_boundary_regions = radial_variation . and . . not . periodic_variation exclude_boundary_regions_qn = exclude_boundary_regions nu_krook = 0.05 tcorr_source = 0.02 tcorr_source_qn = 0.0 ikxmax_source = 1 ! kx=0 if ( periodic_variation ) ikxmax_source = 2 ! kx=0 and kx=1 krook_odd = . true . ! damp only the odd mode that can affect profiles from_zero = . true . source_option = 'none' conserve_momentum = . false . conserve_density = . false . in_file = input_unit_exist ( \"sources\" , dexist ) if ( dexist ) read ( unit = in_file , nml = sources ) ierr = error_unit () call get_option_value & ( source_option , sourceopts , source_option_switch , & ierr , \"source_option in sources\" ) if ( tcorr_source_qn < 0 ) tcorr_source_qn = tcorr_source end if ikxmax_source = min ( ikxmax_source , ikx_max ) int_proj = - 1. int_krook = - 1. call broadcast ( source_option_switch ) call broadcast ( exclude_boundary_regions ) call broadcast ( exclude_boundary_regions_qn ) call broadcast ( nu_krook ) call broadcast ( tcorr_source ) call broadcast ( tcorr_source_qn ) call broadcast ( ikxmax_source ) call broadcast ( krook_odd ) call broadcast ( from_zero ) call broadcast ( conserve_momentum ) call broadcast ( conserve_density ) end subroutine read_parameters subroutine init_source_timeaverage use stella_time , only : code_dt use fields_arrays , only : tcorr_source_qn , exp_fac_qn implicit none if ( tcorr_source > 0.0 ) then exp_fac = exp ( - code_dt / tcorr_source ) else exp_fac = 0.0 end if if ( tcorr_source_qn > 0.0 ) then exp_fac_qn = exp ( - code_dt / tcorr_source_qn ) else exp_fac_qn = 0.0 end if end subroutine init_source_timeaverage subroutine finish_sources use dist_fn_arrays , only : g_krook , g_proj , g_symm use fields_arrays , only : phi_proj , phi_proj_stage #ifdef ISO_C_BINDING use fields_arrays , only : qn_zf_window #else use fields_arrays , only : phizf_solve , phi_ext #endif implicit none integer :: ierr if ( allocated ( g_krook )) deallocate ( g_krook ) if ( allocated ( g_proj )) deallocate ( g_proj ) if ( allocated ( g_symm )) deallocate ( g_symm ) if ( allocated ( phi_proj )) deallocate ( phi_proj ) if ( allocated ( phi_proj_stage )) deallocate ( phi_proj_stage ) #ifdef ISO_C_BINDING if ( qn_zf_window /= MPI_WIN_NULL ) then call mpi_win_free ( qn_zf_window , ierr ) end if #else if ( associated ( phizf_solve % zloc )) deallocate ( phizf_solve % zloc ) if ( associated ( phizf_solve % idx )) deallocate ( phizf_solve % idx ) if ( associated ( phi_ext )) deallocate ( phi_ext ) #endif end subroutine finish_sources subroutine add_krook_operator ( g , gke_rhs ) use mp , only : proc0 use job_manage , only : time_message use zgrid , only : nzgrid , ntubes use constants , only : pi , zi use kt_grids , only : akx , nakx , zonal_mode , boundary_size use stella_layouts , only : vmu_lo use stella_time , only : code_dt use dist_fn_arrays , only : g_krook , g_symm use stella_transforms , only : transform_kx2x_unpadded , transform_x2kx_unpadded implicit none complex :: tmp integer :: ikx , jkx , iz , it , ia , ivmu , npts complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ), target :: g complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: gke_rhs complex , dimension (:, :, :, :, :), pointer :: g_work complex , dimension (:, :), allocatable :: g0k , g0x , g1x real , dimension (:), allocatable :: basis_func ia = 1 if (. not . zonal_mode ( 1 )) return if ( proc0 ) call time_message (. false ., time_sources (:, 1 ), ' sources' ) if ( debug ) write ( 6 , * ) 'sources::add_krook_operator' g_work => g if ( conserve_momentum . or . conserve_density ) then g_work => g_symm g_work = g end if if ( debug ) write ( 6 , * ) 'sources::add_krook_operator::conservation' if ( conserve_momentum ) call enforce_momentum_conservation ( g_work ) if ( conserve_density ) call enforce_density_conservation ( g_work ( 1 , :, :, :, :)) if ( exclude_boundary_regions ) then if ( debug ) write ( 6 , * ) 'sources::add_krook_operator::exclude_boundary_regions' npts = nakx - 2 * boundary_size allocate ( g0k ( 1 , nakx )) allocate ( g0x ( 1 , nakx )) allocate ( g1x ( 1 , nakx )) allocate ( basis_func ( npts )) do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid g0k ( 1 , :) = g_work ( 1 , :, iz , it , ivmu ) g1x = 0. call transform_kx2x_unpadded ( g0k , g0x ) do ikx = 1 , ikxmax_source if ( ikx == 1 ) then basis_func = 1.0 tmp = sum ( g0x ( 1 , ( boundary_size + 1 ):( nakx - boundary_size ))) / real ( npts ) else do jkx = 1 , npts basis_func ( jkx ) = sin ( 2.0 * pi * ( ikx - 1 ) * jkx / real ( npts + 1 )) end do tmp = 2.0 * sum ( basis_func * g0x ( 1 , ( boundary_size + 1 ):( nakx - boundary_size ))) / real ( npts + 1 ) end if if ( tcorr_source > epsilon ( 0.0 )) then tmp = ( code_dt * tmp + exp_fac * int_krook * g_krook ( ikx , iz , it , ivmu )) & / ( code_dt + exp_fac * int_krook ) end if do jkx = 1 , npts g1x ( 1 , boundary_size + jkx ) = g1x ( 1 , boundary_size + jkx ) + tmp * basis_func ( jkx ) end do end do call transform_x2kx_unpadded ( g1x , g0k ) gke_rhs ( 1 , :, iz , it , ivmu ) = gke_rhs ( 1 , :, iz , it , ivmu ) - code_dt * nu_krook * g0k ( 1 , :) end do end do end do deallocate ( g0k , g0x , g1x , basis_func ) else if ( debug ) write ( 6 , * ) 'sources::add_krook_operator::include_boundary_regions' do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid do ikx = 1 , nakx if ( abs ( akx ( ikx )) > akx ( ikxmax_source )) cycle tmp = g_work ( 1 , ikx , iz , it , ivmu ) if ( krook_odd . and . abs ( akx ( ikx )) > epsilon ( 0.0 )) tmp = zi * aimag ( tmp ) if ( tcorr_source <= epsilon ( 0.0 )) then gke_rhs ( 1 , ikx , iz , it , ivmu ) = gke_rhs ( 1 , ikx , iz , it , ivmu ) - code_dt * nu_krook * tmp else gke_rhs ( 1 , ikx , iz , it , ivmu ) = gke_rhs ( 1 , ikx , iz , it , ivmu ) - code_dt * nu_krook & * ( code_dt * tmp + exp_fac * int_krook * g_krook ( ikx , iz , it , ivmu )) & / ( code_dt + exp_fac * int_krook ) end if end do end do end do end do end if if ( proc0 ) call time_message (. false ., time_sources (:, 1 ), ' sources' ) end subroutine add_krook_operator subroutine update_tcorr_krook ( g ) use mp , only : proc0 use job_manage , only : time_message use constants , only : pi , zi use dist_fn_arrays , only : g_krook , g_symm use zgrid , only : nzgrid , ntubes use kt_grids , only : akx , nakx , zonal_mode , boundary_size use stella_layouts , only : vmu_lo use stella_time , only : code_dt use stella_transforms , only : transform_kx2x_unpadded , transform_x2kx_unpadded implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), target , intent ( in ) :: g complex , dimension (:, :), allocatable :: g0k , g0x complex , dimension (:, :, :, :, :), pointer :: g_work integer :: ivmu , iz , it , ikx , jkx , ia , npts real :: int_krook_old complex :: tmp if (. not . zonal_mode ( 1 )) return if ( proc0 ) call time_message (. false ., time_sources (:, 1 ), ' sources' ) ia = 1 if ( debug ) write ( 6 , * ) 'sources::update_tcorr_krook' g_work => g if ( conserve_momentum . or . conserve_density ) then g_work => g_symm g_work = g end if if ( conserve_momentum ) call enforce_momentum_conservation ( g_work ) if ( conserve_density ) call enforce_density_conservation ( g_work ( 1 , :, :, :, :)) int_krook_old = int_krook int_krook = code_dt + exp_fac * int_krook_old if ( exclude_boundary_regions ) then npts = nakx - 2 * boundary_size allocate ( g0k ( 1 , nakx )) allocate ( g0x ( 1 , nakx )) do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid g0k ( 1 , :) = g_work ( 1 , :, iz , it , ivmu ) call transform_kx2x_unpadded ( g0k , g0x ) do ikx = 1 , ikxmax_source if ( ikx == 1 ) then tmp = sum ( g0x ( 1 , ( boundary_size + 1 ):( nakx - boundary_size ))) / real ( npts ) else tmp = 0. do jkx = 1 , npts tmp = tmp + sin ( 2.0 * pi * ( ikx - 1 ) * jkx / real ( npts + 1 )) * g0x ( 1 , boundary_size + jkx ) end do tmp = 2.0 * tmp / real ( npts + 1 ) end if g_krook ( ikx , iz , it , ivmu ) = ( code_dt * tmp + exp_fac * int_krook_old * g_krook ( ikx , iz , it , ivmu )) & / int_krook end do end do end do end do deallocate ( g0k , g0x ) else do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid do ikx = 1 , nakx tmp = g ( 1 , ikx , iz , it , ivmu ) if ( krook_odd . and . abs ( akx ( ikx )) > epsilon ( 0.0 )) tmp = zi * aimag ( tmp ) g_krook ( ikx , iz , it , ivmu ) = ( code_dt * tmp + exp_fac * int_krook_old * g_krook ( ikx , iz , it , ivmu )) / int_krook end do end do end do end do end if if ( proc0 ) call time_message (. false ., time_sources (:, 1 ), ' sources' ) end subroutine update_tcorr_krook subroutine enforce_momentum_conservation ( g_work ) use mp , only : proc0 use job_manage , only : time_message use redistribute , only : scatter , gather use stella_layouts , only : vmu_lo , kxkyz_lo use stella_layouts , only : imu_idx , is_idx , iv_idx use vpamu_grids , only : nvgrid , nvpa , nmu use dist_redistribute , only : kxkyz2vmu use dist_fn_arrays , only : gvmu use zgrid , only : nzgrid implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( inout ) :: g_work integer :: ikxkyz , imu , iv , iv2 complex :: tmp if ( proc0 ) call time_message (. false ., time_sources (:, 2 ), ' source_redist' ) call scatter ( kxkyz2vmu , g_work , gvmu ) if ( proc0 ) call time_message (. false ., time_sources (:, 2 ), ' source_redist' ) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc do imu = 1 , nmu do iv = 1 , nvgrid iv2 = nvpa - iv + 1 tmp = 0.5 * ( gvmu ( iv , imu , ikxkyz ) + gvmu ( iv2 , imu , ikxkyz )) gvmu ( iv , imu , ikxkyz ) = tmp gvmu ( iv2 , imu , ikxkyz ) = tmp end do end do end do if ( proc0 ) call time_message (. false ., time_sources (:, 2 ), ' source_redist' ) call gather ( kxkyz2vmu , gvmu , g_work ) if ( proc0 ) call time_message (. false ., time_sources (:, 2 ), ' source_redist' ) end subroutine enforce_momentum_conservation subroutine enforce_density_conservation ( g_work ) use mp , only : sum_allreduce use species , only : spec use physics_flags , only : radial_variation use vpamu_grids , only : integrate_species , mu , vpa , vperp2 use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use kt_grids , only : nakx , rho_d_clamped use stella_layouts , only : vmu_lo , imu_idx , is_idx , iv_idx use stella_geometry , only : bmag , dBdrho , dl_over_b , d_dl_over_b_drho use gyro_averages , only : gyro_average , aj0x , aj1x use dist_fn_arrays , only : kperp2 , dkperp2dr use zgrid , only : nzgrid , ntubes use stella_transforms , only : transform_kx2x_unpadded , transform_x2kx_unpadded implicit none complex , dimension (:, - nzgrid :, :, vmu_lo % llim_proc :), intent ( inout ) :: g_work integer :: ia , ikx , it , iz , imu , iv , ivmu , is complex , dimension (:, :), allocatable :: gyro_g , g0k , g0x complex , dimension (:), allocatable :: g_fsa real :: energy ia = 1 allocate ( gyro_g ( nakx , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) allocate ( g0k ( 1 , nakx )) allocate ( g0x ( 1 , nakx )) allocate ( g_fsa ( nakx )); g_fsa = 0. do it = 1 , ntubes do iz = - nzgrid , nzgrid do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) iv = iv_idx ( vmu_lo , ivmu ) gyro_g (:, ivmu ) = g_work (:, iz , it , ivmu ) * aj0x ( 1 , :, iz , ivmu ) g0k = 0.0 if ( radial_variation ) then g0k ( 1 , :) = gyro_g (:, ivmu ) & * ( - 0.5 * aj1x ( 1 , :, iz , ivmu ) / aj0x ( 1 , :, iz , ivmu ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 ( 1 , :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr ( 1 , :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) & + dBdrho ( iz ) / bmag ( ia , iz )) call transform_kx2x_unpadded ( g0k , g0x ) g0x ( 1 , :) = rho_d_clamped * g0x ( 1 , :) call transform_x2kx_unpadded ( g0x , g0k ) end if gyro_g (:, ivmu ) = gyro_g (:, ivmu ) + g0k ( 1 , :) end do do ikx = 1 , nakx call integrate_species ( gyro_g ( ikx , :), iz , spec % dens_psi0 , g0k ( 1 , ikx ), reduce_in = . false .) end do call sum_allreduce ( g0k ) !we now have delta n. Flux surface average call transform_kx2x_unpadded ( g0k , g0x ) g_fsa = g_fsa + dl_over_b ( ia , iz ) * g0x ( 1 , :) if ( radial_variation ) g_fsa = g_fsa + d_dl_over_b_drho ( ia , iz ) * rho_d_clamped * g0x ( 1 , :) end do end do g_fsa = g_fsa / ntubes do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) iv = iv_idx ( vmu_lo , ivmu ) do it = 1 , ntubes do iz = - nzgrid , nzgrid g0x ( 1 , :) = g_fsa !multiply by f0 g0x ( 1 , :) = g0x ( 1 , :) * maxwell_vpa ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) * maxwell_fac ( is ) if ( radial_variation ) then !variation in the density cancels energy = ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu )) * ( spec ( is )% temp_psi0 / spec ( is )% temp ) g0x ( 1 , :) = g0x ( 1 , :) * ( 1.0 - rho_d_clamped * ( spec ( is )% tprim * ( energy - 1.5 ) + 2. * mu ( imu ) * dBdrho ( iz ))) end if call transform_x2kx_unpadded ( g0x , g0k ) g_work (:, iz , it , ivmu ) = g_work (:, iz , it , ivmu ) - g0k ( 1 , :) end do end do end do deallocate ( gyro_g , g0k , g0x , g_fsa ) end subroutine enforce_density_conservation subroutine project_out_zero ( gold , gnew ) use mp , only : proc0 use job_manage , only : time_message use zgrid , only : nzgrid , ntubes use constants , only : pi , zi use kt_grids , only : zonal_mode , akx , nakx , boundary_size use stella_layouts , only : vmu_lo use stella_time , only : code_dt use dist_fn_arrays , only : g_proj , g_symm use stella_transforms , only : transform_kx2x_unpadded , transform_x2kx_unpadded implicit none complex :: tmp integer :: ikx , jkx , iz , it , ia , ivmu , npts complex , dimension (:, :), allocatable :: g0k , g0x , g1x real , dimension (:), allocatable :: basis_func complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: gold complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( inout ) :: gnew complex , allocatable , dimension (:, :, :, :) :: g ia = 1 if (. not . zonal_mode ( 1 )) return if ( debug ) write ( 6 , * ) 'sources::project_out_zero' if ( proc0 ) call time_message (. false ., time_sources (:, 1 ), ' sources' ) allocate ( g ( nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) !divide by code_dt to ensure time averaging is performed correctly if ( conserve_momentum ) then g_symm = ( gnew - gold ) / code_dt call enforce_momentum_conservation ( g_symm ) g = g_symm ( 1 , :, :, :, :) else g = ( gnew ( 1 , :, :, :, :) - gold ( 1 , :, :, :, :)) / code_dt end if if ( conserve_density ) call enforce_density_conservation ( g ) if ( exclude_boundary_regions ) then npts = nakx - 2 * boundary_size allocate ( g0k ( 1 , nakx )) allocate ( g0x ( 1 , nakx )) allocate ( g1x ( 1 , nakx )) allocate ( basis_func ( npts )) do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid g0k ( 1 , :) = g (:, iz , it , ivmu ) g1x = 0. call transform_kx2x_unpadded ( g0k , g0x ) do ikx = 1 , ikxmax_source !physical region should have an odd number of collocation points if ( ikx == 1 ) then basis_func = 1.0 tmp = sum ( g0x ( 1 , ( boundary_size + 1 ):( nakx - boundary_size ))) / real ( npts ) else ! here we use a Fourier basis due to periodicity, ! though we could use Legendre polynomials ! NB: Only a constant or linear function (or nearly linear, i.e. first ! sine harmonic) make physical sense as sources, so ikxmax_source <= 2 do jkx = 1 , npts basis_func ( jkx ) = sin ( 2.0 * pi * ( ikx - 1 ) * jkx / real ( npts + 1 )) end do tmp = 2.0 * sum ( basis_func * g0x ( 1 , ( boundary_size + 1 ):( nakx - boundary_size ))) / real ( npts + 1 ) end if if ( tcorr_source > epsilon ( 0. )) then tmp = ( code_dt * tmp + exp_fac * int_proj * g_proj ( ikx , iz , it , ivmu )) & / ( code_dt + exp_fac * int_proj ) g_proj ( ikx , iz , it , ivmu ) = tmp end if do jkx = 1 , npts g1x ( 1 , boundary_size + jkx ) = g1x ( 1 , boundary_size + jkx ) + tmp * basis_func ( jkx ) end do end do call transform_x2kx_unpadded ( g1x , g0k ) g (:, iz , it , ivmu ) = g0k ( 1 , :) end do end do end do deallocate ( g0k , g0x , g1x , basis_func ) else do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid do ikx = 1 , nakx if ( abs ( akx ( ikx )) > akx ( ikxmax_source )) then g ( ikx , iz , it , ivmu ) = 0.0 else tmp = g ( ikx , iz , it , ivmu ) if ( krook_odd . and . abs ( akx ( ikx )) > epsilon ( 0.0 )) tmp = zi * aimag ( tmp ) if ( tcorr_source <= epsilon ( 0. )) then g ( ikx , iz , it , ivmu ) = tmp else g ( ikx , iz , it , ivmu ) = ( code_dt * tmp + exp_fac * int_proj * g_proj ( ikx , iz , it , ivmu )) & / ( code_dt + exp_fac * int_proj ) end if end if if ( krook_odd . and . abs ( akx ( ikx )) > epsilon ( 0.0 )) then g_proj ( ikx , iz , it , ivmu ) = zi * aimag ( g ( ikx , iz , it , ivmu )) else g_proj ( ikx , iz , it , ivmu ) = g ( ikx , iz , it , ivmu ) end if end do end do end do end do end if int_proj = code_dt + exp_fac * int_proj gnew ( 1 , :, :, :, :) = gnew ( 1 , :, :, :, :) - code_dt * g deallocate ( g ) if ( proc0 ) call time_message (. false ., time_sources (:, 1 ), ' sources' ) end subroutine project_out_zero subroutine init_quasineutrality_source #ifdef ISO_C_BINDING use , intrinsic :: iso_c_binding , only : c_ptr , c_f_pointer , c_intptr_t use fields_arrays , only : qn_zf_window use mp , only : sgproc0 , sharedsubprocs , comm_sgroup use mp , only : real_size , nbytes_real , create_shared_memory_window use mp_lu_decomposition , only : lu_decomposition_local , lu_inverse_local use mpi #endif use stella_geometry , only : dl_over_b , d_dl_over_b_drho use stella_transforms , only : transform_kx2x_unpadded , transform_x2kx_unpadded use zgrid , only : nzgrid , nztot use kt_grids , only : nakx , rho_d_clamped , boundary_size use linear_solve , only : lu_decomposition use fields_arrays , only : phizf_solve , c_mat , theta , phi_ext use fields_arrays , only : tcorr_source_qn , exclude_boundary_regions_qn , exp_fac_qn implicit none integer :: iz , ikx , ia , jkx , jz integer :: inmat , jnmat , nmat_zf real :: dum #ifdef ISO_C_BINDING integer :: ierr , temp_window integer ( c_intptr_t ) :: cur_pos integer ( kind = MPI_ADDRESS_KIND ) :: win_size type ( c_ptr ) :: cptr complex , dimension (:, :), pointer :: temp_mat #endif complex , dimension (:, :), allocatable :: g0k , g0x , g1k ia = 1 if ( qn_source_initialized ) return qn_source_initialized = . true . if ( include_qn_source ) then nmat_zf = nakx * ( nztot - 1 ) #ifdef ISO_C_BINDING if ( qn_zf_window == MPI_WIN_NULL ) then win_size = 0 if ( sgproc0 ) then win_size = int ( nmat_zf , MPI_ADDRESS_KIND ) * 4_MPI_ADDRESS_KIND & + int ( nmat_zf * ( nmat_zf + 1 ), MPI_ADDRESS_KIND ) * 2 * real_size !complex size end if if ( debug ) write ( 6 , * ) 'sources::init_quasineutrality_source::win_allocate' call create_shared_memory_window ( win_size , qn_zf_window , cur_pos ) !allocate the memory if (. not . associated ( phizf_solve % zloc )) then cptr = transfer ( cur_pos , cptr ) call c_f_pointer ( cptr , phizf_solve % zloc , ( / nmat_zf , nmat_zf / )) end if cur_pos = cur_pos + nmat_zf ** 2 * 2 * nbytes_real if (. not . associated ( phi_ext )) then cptr = transfer ( cur_pos , cptr ) call c_f_pointer ( cptr , phi_ext , ( / nmat_zf / )) end if cur_pos = cur_pos + nmat_zf * 2 * nbytes_real if (. not . associated ( phizf_solve % idx )) then cptr = transfer ( cur_pos , cptr ) call c_f_pointer ( cptr , phizf_solve % idx , ( / nmat_zf / )) end if call mpi_win_fence ( 0 , qn_zf_window , ierr ) end if #else if ( debug ) write ( 6 , * ) 'sources::init_quasineutrality_source::allocate_phizf' if (. not . associated ( phizf_solve % zloc )) allocate ( phizf_solve % zloc ( nmat_zf , nmat_zf )) if (. not . associated ( phizf_solve % idx )) allocate ( phizf_solve % idx ( nmat_zf )) if (. not . associated ( phi_ext )) allocate ( phi_ext ( nmat_zf )) #endif #ifdef ISO_C_BINDING if ( sgproc0 ) then #endif allocate ( g0k ( 1 , nakx )) allocate ( g0x ( 1 , nakx )) allocate ( g1k ( 1 , nakx )) phizf_solve % zloc = 0. !get the big matrix do jz = - nzgrid , nzgrid - 1 do jkx = 1 , nakx jnmat = jkx + nakx * ( jz + nzgrid ) ! C.phi do ikx = 1 , nakx inmat = ikx + nakx * ( jz + nzgrid ) phizf_solve % zloc ( inmat , jnmat ) = phizf_solve % zloc ( inmat , jnmat ) + c_mat ( ikx , jkx ) end do ! -C.<phi>_\\psi g0k = 0.0 ; g0k ( 1 , jkx ) = 1.0 call transform_kx2x_unpadded ( g0k , g0x ) g0x ( 1 , :) = ( dl_over_b ( ia , jz ) + d_dl_over_b_drho ( ia , jz ) * rho_d_clamped ) * g0x ( 1 , :) call transform_x2kx_unpadded ( g0x , g0k ) !set the gauge potential if ( jkx == 1 ) g0k ( 1 , 1 ) = 0. do ikx = 1 , nakx g1k ( 1 , ikx ) = sum ( c_mat ( ikx , :) * g0k ( 1 , :)) end do do iz = - nzgrid , nzgrid - 1 do ikx = 1 , nakx inmat = ikx + nakx * ( iz + nzgrid ) phizf_solve % zloc ( inmat , jnmat ) = phizf_solve % zloc ( inmat , jnmat ) - g1k ( 1 , ikx ) end do end do ! get theta.phi g1k ( 1 , :) = theta (:, jkx , jz ) ! +theta.phi do ikx = 1 , nakx inmat = ikx + nakx * ( jz + nzgrid ) phizf_solve % zloc ( inmat , jnmat ) = phizf_solve % zloc ( inmat , jnmat ) + g1k ( 1 , ikx ) end do ! -<<theta.phi>_psi>_T call transform_kx2x_unpadded ( g1k , g0x ) g0x ( 1 , :) = ( dl_over_b ( ia , jz ) + d_dl_over_b_drho ( ia , jz ) * rho_d_clamped ) * g0x ( 1 , :) if ( exclude_boundary_regions_qn ) then g0x ( 1 , :) = sum ( g0x ( 1 , ( boundary_size + 1 ):( nakx - boundary_size ))) & / ( nakx - 2 * boundary_size ) g0x ( 1 , 1 : boundary_size ) = 0.0 g0x ( 1 , ( nakx - boundary_size + 1 ):) = 0.0 else g0x ( 1 , :) = sum ( g0x ( 1 , :)) / nakx end if call transform_x2kx_unpadded ( g0x , g0k ) if ( tcorr_source_qn > epsilon ( 0. )) then g0k = ( 1. - exp_fac_qn ) * g0k end if do iz = - nzgrid , nzgrid - 1 do ikx = 1 , nakx inmat = ikx + nakx * ( iz + nzgrid ) phizf_solve % zloc ( inmat , jnmat ) = phizf_solve % zloc ( inmat , jnmat ) & - g0k ( 1 , ikx ) end do end do end do end do deallocate ( g0k , g1k , g0x ) #ifdef ISO_C_BINDING end if call mpi_win_fence ( 0 , qn_zf_window , ierr ) if ( debug ) write ( 6 , * ) 'sources::init_quasineutrality_source::lu_decomposition' call lu_decomposition_local ( comm_sgroup , 0 , qn_zf_window , & phizf_solve % zloc , phizf_solve % idx , dum ) call mpi_win_fence ( 0 , qn_zf_window , ierr ) if ( debug ) write ( 6 , * ) 'sources::init_quasineutrality_source::temp_mat' win_size = 0 if ( sgproc0 ) then win_size = int ( nmat_zf ** 2 , MPI_ADDRESS_KIND ) * 2 * real_size !complex size end if if ( debug ) write ( 6 , * ) 'sources::init_quasineutrality_source::win_allocate' call create_shared_memory_window ( win_size , temp_window , cur_pos ) cptr = transfer ( cur_pos , cptr ) call c_f_pointer ( cptr , temp_mat , ( / nmat_zf , nmat_zf / )) if ( sgproc0 ) temp_mat = phizf_solve % zloc call mpi_win_fence ( 0 , temp_window , ierr ) ! inverse is calculated since it is more straightforward to parallelize ! inverse calculation/matrix multiplication than the lu back substitution if ( debug ) write ( 6 , * ) 'sources::init_quasineutrality_source::lu_inverse' call lu_inverse_local ( comm_sgroup , qn_zf_window , & temp_mat , phizf_solve % idx , phizf_solve % zloc ) call mpi_win_free ( temp_window , ierr ) #else if ( debug ) write ( 6 , * ) 'sources::init_quasineutrality_source::lu_decomposition' call lu_decomposition ( phizf_solve % zloc , phizf_solve % idx , dum ) #endif end if end subroutine init_quasineutrality_source subroutine update_quasineutrality_source use fields_arrays , only : phi_proj , phi_proj_stage use fields_arrays , only : tcorr_source_qn , exp_fac_qn implicit none if ( tcorr_source_qn < epsilon ( 0. )) then phi_proj = phi_proj_stage else phi_proj = exp_fac_qn * phi_proj + ( 1. - exp_fac_qn ) * phi_proj_stage end if end subroutine update_quasineutrality_source end module sources","tags":"","loc":"sourcefile/sources.fpp.html"},{"title":"species.f90 – stella","text":"Source Code module species use common_types , only : spec_type implicit none public :: init_species , finish_species public :: read_species_knobs public :: reinit_species public :: communicate_species_multibox !public :: init_trin_species public :: nspec , spec , pfac public :: ion_species , electron_species , slowing_down_species , tracer_species public :: has_electron_species , has_slowing_down_species public :: ions , electrons , impurity public :: modified_adiabatic_electrons , adiabatic_electrons private integer , parameter :: ion_species = 1 integer , parameter :: electron_species = 2 ! for collision operator integer , parameter :: slowing_down_species = 3 ! slowing-down distn integer , parameter :: tracer_species = 4 ! for test particle diffusion studies integer :: species_option_switch integer , parameter :: species_option_stella = 1 integer , parameter :: species_option_inputprofs = 2 integer , parameter :: species_option_euterpe = 3 integer , parameter :: species_option_multibox = 4 integer :: nspec logical :: read_profile_variation , write_profile_variation logical :: ecoll_zeff logical :: modified_adiabatic_electrons , adiabatic_electrons type ( spec_type ), dimension (:), allocatable :: spec integer :: ions , electrons , impurity real :: pfac !  integer :: ntspec_trin !  real, dimension (:), allocatable :: dens_trin, temp_trin, fprim_trin, tprim_trin, nu_trin character ( 20 ) :: species_option logical :: initialized = . false . contains subroutine init_species !    use mp, only: trin_flag use mp , only : proc0 , broadcast use physics_parameters , only : vnew_ref , zeff use physics_flags , only : include_pressure_variation use physics_flags , only : adiabatic_option_switch , adiabatic_option_fieldlineavg use inputprofiles_interface , only : read_inputprof_spec use euterpe_interface , only : read_species_euterpe implicit none integer :: is , is2 if ( initialized ) return initialized = . true . allocate ( spec ( nspec )) if ( proc0 ) then select case ( species_option_switch ) case ( species_option_stella ) call read_species_stella case ( species_option_inputprofs ) call read_species_stella call read_inputprof_spec ( nspec , spec ) case ( species_option_euterpe ) call read_species_stella call read_species_euterpe ( nspec , spec ) case ( species_option_multibox ) call read_species_stella !this will be called by the central box in stella.f90 after !ktgrids is set up as we need to know the radial box size call communicate_species_multibox end select if ( ecoll_zeff ) then ! AVB: only intra-species collisions, account for e-i and e-impurity collisions using zeff do is = 1 , nspec ! initialize nu_ss' = 0 for all s' spec ( is )% vnew = 0. ! FLAG -- only contains self-collisions at the moment spec ( is )% vnew ( is ) = vnew_ref * spec ( is )% dens * spec ( is )% z ** 4 & / ( sqrt ( spec ( is )% mass ) * spec ( is )% temp ** 1.5 ) ! include electron-ion collisions if ( spec ( is )% type == electron_species ) then spec ( is )% vnew ( is ) = spec ( is )% vnew ( is ) * ( 1. + zeff ) end if end do else ! AVB: full intra- and inter-species collision frequencies do is = 1 , nspec do is2 = 1 , nspec if ( spec ( is )% type == electron_species ) then spec ( is )% vnew ( is2 ) = vnew_ref * spec ( is2 )% dens * spec ( is )% z ** 2 * spec ( is2 )% z ** 2 & / ( sqrt ( spec ( is )% mass ) * spec ( is )% temp ** 1.5 ) else if (( spec ( is )% type == ion_species ) . and . ( spec ( is2 )% type == ion_species )) then spec ( is )% vnew ( is2 ) = vnew_ref * spec ( is2 )% dens * spec ( is )% z ** 2 * spec ( is2 )% z ** 2 & / ( sqrt ( spec ( is )% mass ) * spec ( is )% temp ** 1.5 ) else if (( spec ( is )% type == ion_species ) . and . ( spec ( is2 )% type == electron_species )) then spec ( is )% vnew ( is2 ) = vnew_ref * spec ( is2 )% dens * spec ( is )% z ** 2 * spec ( is2 )% z ** 2 & / ( sqrt ( spec ( is )% mass ) * spec ( is )% temp ** 1.5 ) end if end do end do end if call dump_species_input end if pfac = 1.0 if (. not . include_pressure_variation ) pfac = 0.0 call broadcast_parameters ! set flag adiabatic_electrons to true if no kinetic electron species evolved adiabatic_electrons = . not . has_electron_species ( spec ) ! set flag modified_adiabatic_electrons to true if no kinetic electron species evolved ! and field-line-avg chosen as the adiabatic option modified_adiabatic_electrons = adiabatic_electrons & . and . adiabatic_option_switch == adiabatic_option_fieldlineavg !    if (trin_flag) call reinit_species (ntspec_trin, dens_trin, & !         temp_trin, fprim_trin, tprim_trin, nu_trin) end subroutine init_species subroutine read_species_knobs use mp , only : proc0 , job , broadcast , mp_abort use file_utils , only : error_unit , input_unit_exist use file_utils , only : runtype_option_switch , runtype_multibox use physics_flags , only : radial_variation use text_options , only : text_option , get_option_value implicit none integer :: ierr , in_file logical :: exist namelist / species_knobs / nspec , species_option , & read_profile_variation , & write_profile_variation , & ecoll_zeff type ( text_option ), dimension ( 4 ), parameter :: specopts = ( / & text_option ( 'default' , species_option_stella ), & text_option ( 'stella' , species_option_stella ), & text_option ( 'input.profiles' , species_option_inputprofs ), & text_option ( 'euterpe' , species_option_euterpe ) / ) if ( proc0 ) then nspec = 2 read_profile_variation = . false . write_profile_variation = . false . species_option = 'stella' ecoll_zeff = . false . in_file = input_unit_exist ( \"species_knobs\" , exist ) if ( exist ) read ( unit = in_file , nml = species_knobs ) ierr = error_unit () call get_option_value ( species_option , specopts , species_option_switch , & ierr , \"species_option in species_knobs\" ) if ( runtype_option_switch == runtype_multibox . and . ( job /= 1 ) . and . radial_variation ) then !will need to readjust the species parameters in the left/right boxes species_option_switch = species_option_multibox end if if ( nspec < 1 ) then ierr = error_unit () write ( unit = ierr , & fmt = \"('Invalid nspec in species_knobs: ', i5)\" ) nspec call mp_abort ( 'Invalid nspec in species_knobs' ) end if end if call broadcast ( nspec ) call broadcast ( read_profile_variation ) call broadcast ( write_profile_variation ) call broadcast ( ecoll_zeff ) call broadcast ( species_option_switch ) end subroutine read_species_knobs subroutine read_species_stella use file_utils , only : error_unit , get_indexed_namelist_unit use text_options , only : text_option , get_option_value use stella_geometry , only : geo_surf implicit none real :: z , mass , dens , temp , tprim , fprim , d2ndr2 , d2Tdr2 , dr , bess_fac integer :: ierr , unit , is character ( len = 128 ) :: filename character ( 20 ) :: type type ( text_option ), dimension ( 9 ), parameter :: typeopts = ( / & text_option ( 'default' , ion_species ), & text_option ( 'ion' , ion_species ), & text_option ( 'electron' , electron_species ), & text_option ( 'e' , electron_species ), & text_option ( 'beam' , slowing_down_species ), & text_option ( 'fast' , slowing_down_species ), & text_option ( 'alpha' , slowing_down_species ), & text_option ( 'slowing-down' , slowing_down_species ), & text_option ( 'trace' , tracer_species ) / ) namelist / species_parameters / z , mass , dens , temp , & tprim , fprim , d2ndr2 , d2Tdr2 , bess_fac , type do is = 1 , nspec call get_indexed_namelist_unit ( unit , \"species_parameters\" , is ) z = 1 mass = 1.0 dens = 1.0 temp = 1.0 tprim = - 99 9.9 fprim = - 99 9.9 d2ndr2 = 0.0 d2Tdr2 = 0.0 bess_fac = 1.0 type = \"default\" read ( unit = unit , nml = species_parameters ) close ( unit = unit ) spec ( is )% z = z spec ( is )% mass = mass spec ( is )% dens = dens spec ( is )% temp = temp spec ( is )% tprim = tprim spec ( is )% fprim = fprim ! this is (1/n_s)*d&#94;2 n_s / drho&#94;2 spec ( is )% d2ndr2 = d2ndr2 ! this is (1/T_s)*d&#94;2 T_s / drho&#94;2 spec ( is )% d2Tdr2 = d2Tdr2 spec ( is )% dens_psi0 = dens spec ( is )% temp_psi0 = temp spec ( is )% bess_fac = bess_fac if ( write_profile_variation ) then write ( filename , \"(A,I1)\" ) \"specprof_\" , is open ( 1002 , file = filename , status = 'unknown' ) write ( 1002 , '(6e13.5)' ) dens , temp , fprim , tprim , d2ndr2 , d2Tdr2 close ( 1002 ) end if if ( read_profile_variation ) then write ( filename , \"(A,I1)\" ) \"specprof_\" , is open ( 1002 , file = filename , status = 'unknown' ) read ( 1002 , '(6e13.5)' ) dens , temp , fprim , tprim , d2ndr2 , d2Tdr2 close ( 1002 ) dr = geo_surf % rhoc - geo_surf % rhoc_psi0 spec ( is )% dens = dens * ( 1.0 - dr * fprim ) ! + 0.5*dr**2*d2ndr2) spec ( is )% temp = temp * ( 1.0 - dr * tprim ) ! + 0.5*dr**2*d2Tdr2) spec ( is )% fprim = ( fprim - dr * d2ndr2 ) * ( dens / spec ( is )% dens ) spec ( is )% tprim = ( tprim - dr * d2Tdr2 ) * ( temp / spec ( is )% temp ) !spec(is)%dens = 1.0 !spec(is)%temp = 1.0 end if ierr = error_unit () call get_option_value ( type , typeopts , spec ( is )% type , ierr , \"type in species_parameters_x\" ) end do end subroutine read_species_stella subroutine broadcast_parameters use mp , only : broadcast implicit none integer :: is do is = 1 , nspec call broadcast ( spec ( is )% z ) call broadcast ( spec ( is )% mass ) call broadcast ( spec ( is )% dens ) call broadcast ( spec ( is )% temp ) call broadcast ( spec ( is )% tprim ) call broadcast ( spec ( is )% fprim ) call broadcast ( spec ( is )% vnew ) call broadcast ( spec ( is )% d2ndr2 ) call broadcast ( spec ( is )% d2Tdr2 ) call broadcast ( spec ( is )% dens_psi0 ) call broadcast ( spec ( is )% temp_psi0 ) call broadcast ( spec ( is )% bess_fac ) call broadcast ( spec ( is )% type ) spec ( is )% stm = sqrt ( spec ( is )% temp / spec ( is )% mass ) spec ( is )% zstm = spec ( is )% z / sqrt ( spec ( is )% temp * spec ( is )% mass ) spec ( is )% tz = spec ( is )% temp / spec ( is )% z spec ( is )% zt = spec ( is )% z / spec ( is )% temp spec ( is )% smz = abs ( sqrt ( spec ( is )% temp * spec ( is )% mass ) / spec ( is )% z ) spec ( is )% stm_psi0 = sqrt ( spec ( is )% temp_psi0 / spec ( is )% mass ) spec ( is )% zstm_psi0 = spec ( is )% z / sqrt ( spec ( is )% temp_psi0 * spec ( is )% mass ) spec ( is )% tz_psi0 = spec ( is )% temp_psi0 / spec ( is )% z spec ( is )% zt_psi0 = spec ( is )% z / spec ( is )% temp_psi0 spec ( is )% smz_psi0 = abs ( sqrt ( spec ( is )% temp_psi0 * spec ( is )% mass ) / spec ( is )% z ) end do end subroutine broadcast_parameters pure function has_electron_species ( spec ) use common_types , only : spec_type implicit none type ( spec_type ), dimension (:), intent ( in ) :: spec logical :: has_electron_species has_electron_species = any ( spec % type == electron_species ) end function has_electron_species pure function has_slowing_down_species ( spec ) use common_types , only : spec_type implicit none type ( spec_type ), dimension (:), intent ( in ) :: spec logical :: has_slowing_down_species has_slowing_down_species = any ( spec % type == slowing_down_species ) end function has_slowing_down_species subroutine finish_species implicit none deallocate ( spec ) initialized = . false . end subroutine finish_species subroutine reinit_species ( ntspec , dens , temp , fprim , tprim , bess_fac ) use mp , only : broadcast , proc0 , mp_abort implicit none integer , intent ( in ) :: ntspec real , dimension (:), intent ( in ) :: dens , fprim , temp , tprim , bess_fac integer :: is logical , save :: first = . true . if ( first ) then if ( nspec == 1 ) then ions = 1 electrons = 0 impurity = 0 else ! if 2 or more species in GS2 calculation, figure out which is main ion ! and which is electron via mass (main ion mass assumed to be one) do is = 1 , nspec if ( abs ( spec ( is )% mass - 1.0 ) <= epsilon ( 0.0 )) then ions = is else if ( spec ( is )% mass < 0.3 ) then ! for electrons, assuming electrons are at least a factor of 3 less massive ! than main ion and other ions are no less than 30% the mass of the main ion electrons = is else if ( spec ( is )% mass > 1.0 + epsilon ( 0.0 )) then impurity = is else if ( proc0 ) write ( * , * ) & \"Error: TRINITY requires the main ions to have mass 1\" , & \"and the secondary ions to be impurities (mass > 1)\" call mp_abort ( 'TRINITY requires the main ions to have mass 1 and the secondary ions mass > 1' ) end if end do end if first = . false . end if if ( proc0 ) then nspec = ntspec ! Species are passed in following order: main ion, electron, impurity (if present) if ( nspec == 1 ) then spec ( 1 )% dens = dens ( 1 ) spec ( 1 )% temp = temp ( 1 ) spec ( 1 )% fprim = fprim ( 1 ) spec ( 1 )% tprim = tprim ( 1 ) spec ( 1 )% bess_fac = bess_fac ( 1 ) else spec ( ions )% dens = dens ( 1 ) spec ( ions )% temp = temp ( 1 ) spec ( ions )% fprim = fprim ( 1 ) spec ( ions )% tprim = tprim ( 1 ) spec ( ions )% bess_fac = bess_fac ( 1 ) spec ( electrons )% dens = dens ( 2 ) spec ( electrons )% temp = temp ( 2 ) spec ( electrons )% fprim = fprim ( 2 ) spec ( electrons )% tprim = tprim ( 2 ) spec ( electrons )% bess_fac = bess_fac ( 2 ) if ( nspec > 2 ) then spec ( impurity )% dens = dens ( 3 ) spec ( impurity )% temp = temp ( 3 ) spec ( impurity )% fprim = fprim ( 3 ) spec ( impurity )% tprim = tprim ( 3 ) spec ( impurity )% bess_fac = bess_fac ( 3 ) end if end if do is = 1 , nspec spec ( is )% stm = sqrt ( spec ( is )% temp / spec ( is )% mass ) spec ( is )% zstm = spec ( is )% z / sqrt ( spec ( is )% temp * spec ( is )% mass ) spec ( is )% tz = spec ( is )% temp / spec ( is )% z spec ( is )% zt = spec ( is )% z / spec ( is )% temp spec ( is )% smz = abs ( sqrt ( spec ( is )% temp * spec ( is )% mass ) / spec ( is )% z ) !          write (*,100) 'reinit_species', rhoc_ms, spec(is)%temp, spec(is)%fprim, & !               spec(is)%tprim, spec(is)%vnewk, real(is) end do call dump_species_input end if !100 format (a15,9(1x,1pg18.11)) call broadcast ( nspec ) do is = 1 , nspec call broadcast ( spec ( is )% dens ) call broadcast ( spec ( is )% temp ) call broadcast ( spec ( is )% fprim ) call broadcast ( spec ( is )% tprim ) call broadcast ( spec ( is )% bess_fac ) call broadcast ( spec ( is )% stm ) call broadcast ( spec ( is )% zstm ) call broadcast ( spec ( is )% tz ) call broadcast ( spec ( is )% zt ) call broadcast ( spec ( is )% smz ) end do end subroutine reinit_species subroutine communicate_species_multibox ( dr_m , dr_p ) use job_manage , only : njobs use mp , only : job , scope , mp_abort , & crossdomprocs , subprocs , & send , receive implicit none real , optional , intent ( in ) :: dr_m , dr_p real , dimension (:), allocatable :: dens , ldens , ltemp , lfprim , ltprim real , dimension (:), allocatable :: temp , rdens , rtemp , rfprim , rtprim integer :: i allocate ( dens ( nspec )) allocate ( temp ( nspec )) allocate ( ldens ( nspec )) allocate ( ltemp ( nspec )) allocate ( lfprim ( nspec )) allocate ( ltprim ( nspec )) allocate ( rdens ( nspec )) allocate ( rtemp ( nspec )) allocate ( rfprim ( nspec )) allocate ( rtprim ( nspec )) if ( job == 1 ) then ! recall that fprim and tprim are the negative gradients ldens = spec % dens * ( 1.0 - dr_m * spec % fprim ) ! + 0.5*dr_m**2*spec%d2ndr2) ltemp = spec % temp * ( 1.0 - dr_m * spec % tprim ) ! + 0.5*dr_m**2*spec%d2Tdr2) lfprim = ( spec % fprim - dr_m * spec % d2ndr2 ) * ( spec % dens / ldens ) ltprim = ( spec % tprim - dr_m * spec % d2Tdr2 ) * ( spec % temp / ltemp ) rdens = spec % dens * ( 1.0 - dr_p * spec % fprim ) ! + 0.5*dr_p**2*spec%d2ndr2) rtemp = spec % temp * ( 1.0 - dr_p * spec % tprim ) ! + 0.5*dr_p**2*spec%d2Tdr2) rfprim = ( spec % fprim - dr_p * spec % d2ndr2 ) * ( spec % dens / rdens ) rtprim = ( spec % tprim - dr_p * spec % d2Tdr2 ) * ( spec % temp / rtemp ) do i = 1 , nspec if ( ldens ( i ) < 0 . or . ltemp ( i ) < 0 . or . & rdens ( i ) < 0 . or . rtemp ( i ) < 0 ) then call mp_abort ( 'Negative n/T encountered. Try reducing rhostar.' ) end if end do end if call scope ( crossdomprocs ) if ( job == 1 ) then call send ( ldens , 0 , 120 ) call send ( ltemp , 0 , 121 ) call send ( lfprim , 0 , 122 ) call send ( ltprim , 0 , 123 ) call send ( spec % dens , 0 , 124 ) call send ( spec % temp , 0 , 125 ) call send ( rdens , njobs - 1 , 130 ) call send ( rtemp , njobs - 1 , 131 ) call send ( rfprim , njobs - 1 , 132 ) call send ( rtprim , njobs - 1 , 133 ) call send ( spec % dens , njobs - 1 , 134 ) call send ( spec % temp , njobs - 1 , 135 ) elseif ( job == 0 ) then call receive ( ldens , 1 , 120 ) call receive ( ltemp , 1 , 121 ) call receive ( lfprim , 1 , 122 ) call receive ( ltprim , 1 , 123 ) call receive ( dens , 1 , 124 ) call receive ( temp , 1 , 125 ) spec % dens = ldens spec % temp = ltemp spec % fprim = lfprim spec % tprim = ltprim spec % dens_psi0 = dens spec % temp_psi0 = temp elseif ( job == njobs - 1 ) then call receive ( rdens , 1 , 130 ) call receive ( rtemp , 1 , 131 ) call receive ( rfprim , 1 , 132 ) call receive ( rtprim , 1 , 133 ) call receive ( dens , 1 , 134 ) call receive ( temp , 1 , 135 ) spec % dens = rdens spec % temp = rtemp spec % fprim = rfprim spec % tprim = rtprim spec % dens_psi0 = dens spec % temp_psi0 = temp end if call scope ( subprocs ) deallocate ( dens ) deallocate ( temp ) deallocate ( ldens ) deallocate ( ltemp ) deallocate ( lfprim ) deallocate ( ltprim ) deallocate ( rdens ) deallocate ( rtemp ) deallocate ( rfprim ) deallocate ( rtprim ) end subroutine communicate_species_multibox subroutine dump_species_input use file_utils , only : run_name implicit none integer :: is character ( 300 ) :: filename filename = trim ( trim ( run_name ) // '.species.input' ) open ( 1003 , file = filename , status = 'unknown' ) write ( 1003 , '(9a12,a9)' ) '#1.z' , '2.mass' , '3.dens' , & '4.temp' , '5.tprim' , '6.fprim' , '7.vnewss' , & '8.dens_psi0' , '9.temp_psi0' , '11.type' do is = 1 , nspec write ( 1003 , '(9e12.4,i9)' ) spec ( is )% z , spec ( is )% mass , & spec ( is )% dens , spec ( is )% temp , spec ( is )% tprim , & spec ( is )% fprim , spec ( is )% vnew ( is ), & spec ( is )% dens_psi0 , spec ( is )% temp_psi0 , & spec ( is )% type end do close ( 1003 ) end subroutine dump_species_input !   subroutine init_trin_species (ntspec_in, dens_in, temp_in, fprim_in, tprim_in, nu_in) !     implicit none !     integer, intent (in) :: ntspec_in !     real, dimension (:), intent (in) :: dens_in, fprim_in, temp_in, tprim_in, nu_in !     if (.not. allocated(temp_trin)) then !        allocate (dens_trin(size(dens_in))) !        allocate (fprim_trin(size(fprim_in))) !        allocate (temp_trin(size(temp_in))) !        allocate (tprim_trin(size(tprim_in))) !        allocate (nu_trin(size(nu_in))) !     end if !     ntspec_trin = ntspec_in !     dens_trin = dens_in !     temp_trin = temp_in !     fprim_trin = fprim_in !     tprim_trin = tprim_in !     nu_trin = nu_in !   end subroutine init_trin_species end module species","tags":"","loc":"sourcefile/species.f90.html"},{"title":"implicit_solve.f90 – stella","text":"Source Code module implicit_solve implicit none public :: time_implicit_advance public :: sweep_zed_zonal public :: advance_implicit_terms public :: get_gke_rhs public :: sweep_g_zext private real , dimension ( 2 , 3 ) :: time_implicit_advance = 0. contains subroutine advance_implicit_terms ( g , phi , apar , bpar ) use mp , only : proc0 use job_manage , only : time_message use stella_layouts , only : vmu_lo use physics_flags , only : include_apar , include_bpar use zgrid , only : nzgrid , ntubes use kt_grids , only : naky , nakx use dist_fn_arrays , only : g1 use run_parameters , only : stream_matrix_inversion use run_parameters , only : use_deltaphi_for_response_matrix use run_parameters , only : tupwnd_p => time_upwind_plus use run_parameters , only : tupwnd_m => time_upwind_minus use run_parameters , only : fphi use fields , only : advance_fields , fields_updated use extended_zgrid , only : map_to_extended_zgrid , map_from_extended_zgrid use extended_zgrid , only : nsegments , nzed_segment implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( in out ) :: phi , apar , bpar integer :: nz_ext complex , dimension (:, :, :, :), allocatable :: phi_old , apar_old , bpar_old complex , dimension (:, :, :, :), allocatable :: phi_source , apar_source , bpar_source character ( 5 ) :: dist_choice if ( proc0 ) call time_message (. false ., time_implicit_advance (:, 1 ), ' Implicit time advance' ) allocate ( phi_source ( naky , nakx , - nzgrid : nzgrid , ntubes )) allocate ( apar_source ( naky , nakx , - nzgrid : nzgrid , ntubes )) allocate ( bpar_source ( naky , nakx , - nzgrid : nzgrid , ntubes )) !> dist_choice indicates whether the non-Boltzmann part of the pdf (h) is evolved !> in parallel streaming or if the guiding centre distribution (g = <f>) is evolved dist_choice = 'g' !> if using delphi formulation for response matrix, then phi = phi&#94;n replaces !> phi&#94;{n+1} in the inhomogeneous GKE; else set phi_{n+1} to zero in inhomogeneous equation if ( use_deltaphi_for_response_matrix ) then phi_source = phi if ( include_bpar ) bpar_source = bpar else phi_source = tupwnd_m * phi if ( include_bpar ) bpar_source = tupwnd_m * bpar end if ! save the incoming pdf and fields, as they will be needed later g1 = g allocate ( phi_old ( naky , nakx , - nzgrid : nzgrid , ntubes )) phi_old = phi allocate ( apar_old ( naky , nakx , - nzgrid : nzgrid , ntubes )) apar_old = apar allocate ( bpar_old ( naky , nakx , - nzgrid : nzgrid , ntubes )) bpar_old = bpar if ( include_apar ) then ! when solving for the 'inhomogeneous' piece of the pdf, ! use part of apar weighted towards previous time level apar_source = tupwnd_m * apar ! set apar=0, as in update_pdf it is used as the contribution from ! apar&#94;{n+1}, which should not be part of the 'inhomogeneous' GKE eqn apar = 0.0 end if ! solve for the 'inhomogeneous' piece of the pdf, stored in g_scratch call update_pdf fields_updated = . false . ! we now have g_{inh}&#94;{n+1} ! calculate associated fields (phi_{inh}&#94;{n+1}, apar_{inh}&#94;{n+1}) call advance_fields ( g , phi , apar , bpar , dist = trim ( dist_choice )) ! solve response_matrix*(phi&#94;{n+1}-phi&#94;{n*}) = phi_{inh}&#94;{n+1}-phi&#94;{n*} ! phi = phi_{inh}&#94;{n+1}-phi&#94;{n*} is input and overwritten by phi = phi&#94;{n+1}-phi&#94;{n*} if ( use_deltaphi_for_response_matrix ) phi = phi - phi_old if ( use_deltaphi_for_response_matrix . and . include_bpar ) bpar = bpar - bpar_old if ( proc0 ) call time_message (. false ., time_implicit_advance (:, 3 ), ' (back substitution)' ) call invert_parstream_response ( phi , apar , bpar ) if ( proc0 ) call time_message (. false ., time_implicit_advance (:, 3 ), ' (back substitution)' ) !> If using deltaphi formulation, must account for fact that phi = phi&#94;{n+1}-phi&#94;{n*}, but !> tupwnd_p should multiply phi&#94;{n+1} if ( use_deltaphi_for_response_matrix ) phi = phi + phi_old if ( use_deltaphi_for_response_matrix . and . include_bpar ) bpar = bpar + bpar_old ! get time-centered phi phi_source = tupwnd_m * phi_old + tupwnd_p * phi ! get time-centered apar if ( include_apar ) apar_source = tupwnd_m * apar_old + tupwnd_p * apar ! get time-centered bpar if ( include_bpar ) bpar_source = tupwnd_m * bpar_old + tupwnd_p * bpar ! solve for the final, updated pdf now that we have phi&#94;{n+1} and apar&#94;{n+1} call update_pdf deallocate ( phi_old , apar_old , bpar_old ) deallocate ( phi_source , apar_source , bpar_source ) if ( proc0 ) call time_message (. false ., time_implicit_advance (:, 1 ), ' Stream advance' ) contains subroutine update_pdf use extended_zgrid , only : neigen integer :: ie , it , iky , ivmu integer :: ulim complex , dimension (:), allocatable :: pdf1 , pdf2 complex , dimension (:), allocatable :: phiext , bparext complex , dimension (:), allocatable :: aparext , aparext_new , aparext_old ! start the timer for the pdf update if ( proc0 ) call time_message (. false ., time_implicit_advance (:, 2 ), ' (bidiagonal solve)' ) do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc ! solve for the pdf, given the sources for phi and the pdf on the RHS of the GK equation ! we do this on set of connected zed segments at a time do iky = 1 , naky do it = 1 , ntubes do ie = 1 , neigen ( iky ) ! nz_ext is the number of grid points in the extended zed domain nz_ext = nsegments ( ie , iky ) * nzed_segment + 1 ! pdf1 and pdf2 will be scratch arrays needed to compute the pdf itself, ! as well as contributions to the GK equation allocate ( pdf1 ( nz_ext ), pdf2 ( nz_ext )) ! phiext should contain the appropriate contribution to the time-centred phi; ! for the 'inhomogeneous' GKE, it should have time_upwind_minus * phi&#94;{n}; ! for the 'homogeneous' GKE, it should have time_upwind_plus * phi&#94;{n+1}; ! and for the full GKE, it should be the sum of these two allocate ( phiext ( nz_ext )) ! bpar is treated like phi above MRH allocate ( bparext ( nz_ext )) ! if advancing apar, aparext should contain the appropriate contribution ! to the time-centred apar; ! for the 'inhomogeneous' GKE, it should have time_upwind_minus * apar&#94;{n}; ! for the 'homogeneous' GKE, it should have time_upwind_plus * apar&#94;{n+1}; ! and for the full GKE, it should be the sum of these two allocate ( aparext ( nz_ext )); aparext = 0.0 ! if advancing apar, aparext_new should be zero if advancing the 'inhomogeneous' ! piece of g or apar&#94;{n+1} otherwise allocate ( aparext_new ( nz_ext )); aparext_new = 0.0 ! if advancing apar, aparext_old will contain the apar originally passed into ! the implicit time advance; needed to convert from g&#94;{n} to gbar&#94;{n} allocate ( aparext_old ( nz_ext )); aparext_old = 0.0 ! map the incoming pdf 'g1' onto the extended zed domain and call it 'pdf1' call map_to_extended_zgrid ( it , ie , iky , g1 ( iky , :, :, :, ivmu ), pdf1 , ulim ) ! map the incoming potential 'phi_source' onto the extended zed domain and call it 'phiext' call map_to_extended_zgrid ( it , ie , iky , phi_source ( iky , :, :, :), phiext , ulim ) ! map incoming parallel magnetic vector potetial 'apar_sosurce' onto ! extended zed domain and call 'aparext' if ( include_apar ) then call map_to_extended_zgrid ( it , ie , iky , apar_source ( iky , :, :, :), aparext , ulim ) call map_to_extended_zgrid ( it , ie , iky , apar ( iky , :, :, :), aparext_new , ulim ) call map_to_extended_zgrid ( it , ie , iky , apar_old ( iky , :, :, :), aparext_old , ulim ) end if ! map incoming bpar \"bpar_source\" onto the extended zed domain and call it \"bparext\" if ( include_bpar ) call map_to_extended_zgrid ( it , ie , iky , bpar_source ( iky , :, :, :), bparext , ulim ) ! calculate the RHS of the GK equation (using pdf1 and phi_source as the ! pdf and potential, respectively) and store it in pdf2 call get_gke_rhs ( ivmu , iky , ie , pdf1 , phiext , aparext , aparext_new , aparext_old , bparext , pdf2 ) ! given the RHS of the GK equation (pdf2), solve for the pdf at the ! new time level by sweeping in zed on the extended domain; ! the rhs is input as 'pdf2' and over-written with the updated solution for the pdf call sweep_g_zext ( iky , ie , it , ivmu , pdf2 ) ! map the pdf 'pdf2' from the extended zed domain ! to the standard zed domain; the mapped pdf is called 'g' call map_from_extended_zgrid ( it , ie , iky , pdf2 , g ( iky , :, :, :, ivmu )) deallocate ( pdf1 , pdf2 , phiext , aparext , aparext_new , aparext_old , bparext ) end do end do end do end do ! stop the timer for the pdf update if ( proc0 ) call time_message (. false ., time_implicit_advance (:, 2 ), ' (bidiagonal solve)' ) end subroutine update_pdf end subroutine advance_implicit_terms !> get_gke_rhs calculates the RHS of the GK equation. !> as the response matrix approach requires separate solution of the 'inhomogeneous' GKE, !> the homogeneous GKE (to obtain the response matrix itself), !> and the full GKE, which RHS is obtained depends on the input values !> for 'pdf', 'phi', 'apar', 'aparnew' and 'aparold' subroutine get_gke_rhs ( ivmu , iky , ie , pdf , phi , apar , aparnew , aparold , bpar , rhs ) use kt_grids , only : naky , nakx implicit none integer , intent ( in ) :: ivmu , iky , ie complex , dimension (:), intent ( in ) :: pdf complex , dimension (:), intent ( in ) :: phi , apar , aparnew , aparold , bpar complex , dimension (:), intent ( out ) :: rhs integer :: nz_ext complex , dimension (:), allocatable :: rhs_fields ! obtain the RHS of the GK eqn for given fields ! nz_ext is the number of grid points in this extended zed domain nz_ext = size ( pdf ) ! rhs_fields will be the contribution to the GKE RHS from the given fields allocate ( rhs_fields ( nz_ext )) ! NB: rhs is used as a scratch array in get_contributions_from_fields ! so be careful not to move get_contributions_from_pdf before it, or rhs will be over-written call get_contributions_from_fields ( phi , apar , aparnew , bpar , ivmu , iky , ie , rhs , rhs_fields ) call get_contributions_from_pdf ( pdf , aparold , ivmu , iky , ie , rhs ) ! construct RHS of GK eqn rhs = rhs + rhs_fields deallocate ( rhs_fields ) end subroutine get_gke_rhs !> get_contributions_from_fields takes as input the appropriately averaged !> electrostatic potential phi and magnetic vector potential components apar !> and returns in rhs the sum of the source terms !> involving phi and apar that appear on the RHS of the GK equation when g is the pdf subroutine get_contributions_from_fields ( phi , apar , aparnew , bpar , ivmu , iky , ie , scratch , rhs ) use physics_flags , only : include_apar , include_bpar use extended_zgrid , only : map_to_iz_ikx_from_izext implicit none complex , dimension (:), intent ( in ) :: phi , apar , aparnew , bpar integer , intent ( in ) :: ivmu , iky , ie complex , dimension (:), intent ( out ) :: scratch , rhs integer , dimension (:), allocatable :: iz_from_izext , ikx_from_izext integer :: nz_ext ! nz_ext is the number of grid points in the extended zed domain nz_ext = size ( phi ) ! determine the mapping from the extended domain zed index (izext) to the ! zed and kx domain indices (iz, ikx) allocate ( iz_from_izext ( nz_ext )) allocate ( ikx_from_izext ( nz_ext )) call map_to_iz_ikx_from_izext ( iky , ie , iz_from_izext , ikx_from_izext ) ! calculate the contributions to the RHS of the GKE due to source terms proportional to phi call get_contributions_from_phi ( phi , ivmu , iky , iz_from_izext , ikx_from_izext , scratch , rhs ) ! if advancing apar, get its contribution to the RHS of the GKE and add to phi contribution if ( include_apar ) then call get_contributions_from_apar ( apar , aparnew , ivmu , iky , iz_from_izext , ikx_from_izext , scratch , rhs ) end if ! if advancing bpar, get its contribution to the RHS of the GKE and add to phi contribution if ( include_bpar ) then call get_contributions_from_bpar ( bpar , ivmu , iky , iz_from_izext , ikx_from_izext , scratch , rhs ) end if deallocate ( iz_from_izext , ikx_from_izext ) end subroutine get_contributions_from_fields !> get_contributions_from_phi takes as input the appropriately averaged !> electrostatic potential phi and returns in rhs the sum of the source terms !> involving phi that appear on the RHS of the GK equation when g is the pdf subroutine get_contributions_from_phi ( phi , ivmu , iky , iz_from_izext , ikx_from_izext , scratch , rhs ) use stella_time , only : code_dt use species , only : spec use zgrid , only : nzgrid , ntubes use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use vpamu_grids , only : vpa use kt_grids , only : naky , nakx use run_parameters , only : driftkinetic_implicit , maxwellian_normalization use run_parameters , only : maxwellian_inside_zed_derivative use run_parameters , only : drifts_implicit use stella_layouts , only : vmu_lo , iv_idx , imu_idx , is_idx use neoclassical_terms , only : include_neoclassical_terms use neoclassical_terms , only : dfneo_dvpa use extended_zgrid , only : map_to_iz_ikx_from_izext implicit none complex , dimension (:), intent ( in ) :: phi integer , intent ( in ) :: ivmu , iky integer , dimension (:), intent ( in ) :: iz_from_izext , ikx_from_izext complex , dimension (:), intent ( out ) :: scratch , rhs real , dimension (:), allocatable :: z_scratch integer :: ia , iz , iv , imu , is integer :: nz_ext ia = 1 iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) ! nz_ext is the number of grid points in the extended zed domain nz_ext = size ( phi ) ! allocate a 1d array in zed for use as a scratch array allocate ( z_scratch ( - nzgrid : nzgrid )) ! set scratc to be phi or <phi> depending on whether parallel streaming is ! implicit or only implicit in the kperp = 0 (drift kinetic) piece if ( driftkinetic_implicit ) then scratch = phi else call gyro_average_zext ( iky , ivmu , ikx_from_izext , iz_from_izext , phi , scratch ) end if call add_streaming_contribution_phi if ( drifts_implicit ) call add_drifts_contribution_phi deallocate ( z_scratch ) contains subroutine add_streaming_contribution_phi use extended_zgrid , only : fill_zext_ghost_zones use parallel_streaming , only : get_zed_derivative_extended_domain use parallel_streaming , only : center_zed use parallel_streaming , only : gradpar_c , stream_sign integer :: izext complex :: scratch_left , scratch_right ! fill ghost zones beyond ends of extended zed domain for <phi> ! and store values in scratch_left and scratch_right call fill_zext_ghost_zones ( iky , scratch , scratch_left , scratch_right ) ! obtain the zed derivative of <phi> (stored in scratch) and store in rhs call get_zed_derivative_extended_domain ( iv , scratch , scratch_left , scratch_right , rhs ) if (. not . maxwellian_normalization ) then ! center Maxwellian factor in mu ! and store in dummy variable z_scratch z_scratch = maxwell_mu ( ia , :, imu , is ) call center_zed ( iv , z_scratch , - nzgrid ) ! multiply by Maxwellian factor do izext = 1 , nz_ext rhs ( izext ) = rhs ( izext ) * z_scratch ( iz_from_izext ( izext )) end do end if ! NB: could do this once at beginning of simulation to speed things up ! this is vpa*Z/T*exp(-vpa&#94;2) z_scratch = vpa ( iv ) * spec ( is )% zt if (. not . maxwellian_normalization ) z_scratch = z_scratch * maxwell_vpa ( iv , is ) * maxwell_fac ( is ) ! if including neoclassical correction to equilibrium distribution function ! then must also account for -vpa*dF_neo/dvpa*Z/T ! CHECK TO ENSURE THAT DFNEO_DVPA EXCLUDES EXP(-MU*B/T) FACTOR !! if ( include_neoclassical_terms ) then do iz = - nzgrid , nzgrid z_scratch ( iz ) = z_scratch ( iz ) - 0.5 * dfneo_dvpa ( ia , iz , ivmu ) * spec ( is )% zt end do call center_zed ( iv , z_scratch , - nzgrid ) end if if ( stream_sign ( iv ) > 0 ) then z_scratch = z_scratch * gradpar_c (:, - 1 ) * code_dt * spec ( is )% stm_psi0 else z_scratch = z_scratch * gradpar_c (:, 1 ) * code_dt * spec ( is )% stm_psi0 end if do izext = 1 , nz_ext rhs ( izext ) = - z_scratch ( iz_from_izext ( izext )) * rhs ( izext ) end do end subroutine add_streaming_contribution_phi subroutine add_drifts_contribution_phi use constants , only : zi use kt_grids , only : nakx , naky use kt_grids , only : aky , akx use dist_fn_arrays , only : wstar , wdriftx_phi , wdrifty_phi use parallel_streaming , only : center_zed use extended_zgrid , only : periodic integer :: izext , iz , ikx ! 'scratch' starts out as the gyro-average of phi, evaluated at zed grid points do izext = 1 , nz_ext ikx = ikx_from_izext ( izext ) iz = iz_from_izext ( izext ) scratch ( izext ) = zi * scratch ( izext ) * ( akx ( ikx ) * wdriftx_phi ( ia , iz , ivmu ) & + aky ( iky ) * ( wdrifty_phi ( ia , iz , ivmu ) + wstar ( ia , iz , ivmu ))) end do call center_zed ( iv , scratch , 1 , periodic ( iky )) rhs = rhs + scratch end subroutine add_drifts_contribution_phi end subroutine get_contributions_from_phi !> get_contributions_from_bpar takes as input the appropriately averaged !> electrostatic potential bpar and returns in rhs the sum of the source terms !> involving bpar that appear on the RHS of the GK equation when g is the pdf subroutine get_contributions_from_bpar ( bpar , ivmu , iky , iz_from_izext , ikx_from_izext , scratch , rhs ) use stella_time , only : code_dt use species , only : spec use zgrid , only : nzgrid , ntubes use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use vpamu_grids , only : vpa , mu use kt_grids , only : naky , nakx use run_parameters , only : driftkinetic_implicit , maxwellian_normalization use run_parameters , only : maxwellian_inside_zed_derivative use run_parameters , only : drifts_implicit use stella_layouts , only : vmu_lo , iv_idx , imu_idx , is_idx use neoclassical_terms , only : include_neoclassical_terms use neoclassical_terms , only : dfneo_dvpa use extended_zgrid , only : map_to_iz_ikx_from_izext implicit none complex , dimension (:), intent ( in ) :: bpar integer , intent ( in ) :: ivmu , iky integer , dimension (:), intent ( in ) :: iz_from_izext , ikx_from_izext complex , dimension (:), intent ( out ) :: scratch , rhs complex , dimension (:), allocatable :: scratch2 real , dimension (:), allocatable :: z_scratch integer :: ia , iz , iv , imu , is integer :: nz_ext ia = 1 iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) ! nz_ext is the number of grid points in the extended zed domain nz_ext = size ( bpar ) ! allocate a 1d array in zed for use as a scratch array allocate ( z_scratch ( - nzgrid : nzgrid )) ! allocate a 1d array to replace the rhs array as a scratch array allocate ( scratch2 ( nz_ext )) ! set scratch to be bpar or <bpar> depending on whether parallel streaming is ! implicit or only implicit in the kperp = 0 (drift kinetic) piece if ( driftkinetic_implicit ) then scratch = bpar else call gyro_average_j1_zext ( iky , ivmu , ikx_from_izext , iz_from_izext , bpar , scratch ) end if call add_streaming_contribution_bpar if ( drifts_implicit ) call add_drifts_contribution_bpar deallocate ( z_scratch , scratch2 ) contains subroutine add_streaming_contribution_bpar use extended_zgrid , only : fill_zext_ghost_zones use parallel_streaming , only : get_zed_derivative_extended_domain use parallel_streaming , only : center_zed use parallel_streaming , only : gradpar_c , stream_sign integer :: izext complex :: scratch_left , scratch_right ! fill ghost zones beyond ends of extended zed domain for <bpar> ! and store values in scratch_left and scratch_right call fill_zext_ghost_zones ( iky , scratch , scratch_left , scratch_right ) ! obtain the zed derivative of <bpar> (stored in scratch) and store in scratch2 call get_zed_derivative_extended_domain ( iv , scratch , scratch_left , scratch_right , scratch2 ) if (. not . maxwellian_normalization ) then ! center Maxwellian factor in mu ! and store in dummy variable z_scratch z_scratch = maxwell_mu ( ia , :, imu , is ) call center_zed ( iv , z_scratch , - nzgrid ) ! multiply by Maxwellian factor do izext = 1 , nz_ext scratch2 ( izext ) = scratch2 ( izext ) * z_scratch ( iz_from_izext ( izext )) end do end if ! NB: could do this once at beginning of simulation to speed things up ! this is vpa*Z/T*exp(-vpa&#94;2) z_scratch = vpa ( iv ) * 4. * mu ( imu ) if (. not . maxwellian_normalization ) z_scratch = z_scratch * maxwell_vpa ( iv , is ) * maxwell_fac ( is ) ! if including neoclassical correction to equilibrium distribution function ! then must also account for -vpa*dF_neo/dvpa*4*mu ! CHECK TO ENSURE THAT DFNEO_DVPA EXCLUDES EXP(-MU*B/T) FACTOR !! if ( include_neoclassical_terms ) then do iz = - nzgrid , nzgrid z_scratch ( iz ) = z_scratch ( iz ) - 0.5 * dfneo_dvpa ( ia , iz , ivmu ) * 4. * mu ( imu ) end do call center_zed ( iv , z_scratch , - nzgrid ) end if if ( stream_sign ( iv ) > 0 ) then z_scratch = z_scratch * gradpar_c (:, - 1 ) * code_dt * spec ( is )% stm_psi0 else z_scratch = z_scratch * gradpar_c (:, 1 ) * code_dt * spec ( is )% stm_psi0 end if do izext = 1 , nz_ext scratch2 ( izext ) = - z_scratch ( iz_from_izext ( izext )) * scratch2 ( izext ) end do ! add scratch2 to rhs rhs = rhs + scratch2 end subroutine add_streaming_contribution_bpar subroutine add_drifts_contribution_bpar use constants , only : zi use kt_grids , only : nakx , naky use kt_grids , only : aky , akx use dist_fn_arrays , only : wstar , wdriftx_bpar , wdrifty_bpar use parallel_streaming , only : center_zed use extended_zgrid , only : periodic integer :: izext , iz , ikx real :: constant_factor ! 'scratch' starts out as the gyro-average of bpar, evaluated at zed grid points constant_factor = 4. * mu ( imu ) * spec ( is )% tz do izext = 1 , nz_ext ikx = ikx_from_izext ( izext ) iz = iz_from_izext ( izext ) ! the bpar part of Zs <chi>/Ts = 4 mu J1 bpar / bs, and wdrifty_bpar and wdriftx_bpar contain the 4 mu factor ! the 4 mu Ts/Zs factor must be included explicitly in the wstar term here scratch ( izext ) = zi * scratch ( izext ) * ( akx ( ikx ) * wdriftx_bpar ( ia , iz , ivmu ) & + aky ( iky ) * ( wdrifty_bpar ( ia , iz , ivmu ) + constant_factor * wstar ( ia , iz , ivmu ))) end do call center_zed ( iv , scratch , 1 , periodic ( iky )) rhs = rhs + scratch end subroutine add_drifts_contribution_bpar end subroutine get_contributions_from_bpar !> get_contributions_from_apar takes as input the appropriately averaged !> parallel component of the vector potential, apar, and returns in rhs the sum of the source terms !> involving apar that appear on the RHS of the GK equation when g is the pdf subroutine get_contributions_from_apar ( apar , aparnew , ivmu , iky , iz_from_izext , ikx_from_izext , scratch , rhs ) use run_parameters , only : driftkinetic_implicit , drifts_implicit use stella_layouts , only : vmu_lo , iv_idx , imu_idx , is_idx implicit none complex , dimension (:), intent ( in ) :: apar , aparnew integer , intent ( in ) :: ivmu , iky integer , dimension (:), intent ( in ) :: iz_from_izext , ikx_from_izext complex , dimension (:), intent ( out ) :: scratch complex , dimension (:), intent ( in out ) :: rhs complex , dimension (:), allocatable :: scratch2 integer :: ia , iv , imu , is integer :: nz_ext ia = 1 iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) ! nz_ext is number of grid points in extended zed domain nz_ext = size ( scratch ) allocate ( scratch2 ( nz_ext )) ! set scratch to be apar or <apar> depending on whether parallel streaming is ! implicit or only implicit in the kperp = 0 (drift kinetic) piece if ( driftkinetic_implicit ) then scratch = apar scratch2 = aparnew else call gyro_average_zext ( iky , ivmu , ikx_from_izext , iz_from_izext , apar , scratch ) call gyro_average_zext ( iky , ivmu , ikx_from_izext , iz_from_izext , aparnew , scratch2 ) end if call add_gbar_to_g_contribution_apar ( scratch2 , iky , ia , iv , imu , is , nz_ext , iz_from_izext , rhs ) if ( drifts_implicit ) call add_drifts_contribution_apar ( scratch , iky , ia , ivmu , iv , is , nz_ext , iz_from_izext , rhs ) deallocate ( scratch2 ) end subroutine get_contributions_from_apar !> adds the contributions to the GKE RHS that comes from switching from !> gbar&#94;{n+1} = g&#94;{n+1} + (Ze/T)*(vpa/c)*<Apar&#94;{n+1}>*F0 to g&#94;{n+1} = <f&#94;{n+1}> !> in the time derivative; ! as it involves apar&#94;{n+1}, it should not be present in the solution of the ! 'inhomogeneous' GKE; this should have been accounted for by passing in ! aparnew=0 so that scratch2 will be zero below subroutine add_gbar_to_g_contribution_apar ( scratch2 , iky , ia , iv , imu , is , nz_ext , iz_from_izext , rhs ) use run_parameters , only : maxwellian_normalization use vpamu_grids , only : vpa , maxwell_vpa , maxwell_mu , maxwell_fac use parallel_streaming , only : center_zed use species , only : spec use extended_zgrid , only : periodic implicit none complex , dimension (:), intent ( in out ) :: scratch2 integer , intent ( in ) :: iky , ia , iv , imu , is , nz_ext integer , dimension (:), intent ( in ) :: iz_from_izext complex , dimension (:), intent ( in out ) :: rhs integer :: izext , iz real :: constant_factor ! avoid repeated multiplication in below izext loop constant_factor = - 2.0 * spec ( is )% zt_psi0 * spec ( is )% stm_psi0 * vpa ( iv ) ! incoming 'scratch2' is <apar&#94;{n+1}> do izext = 1 , nz_ext iz = iz_from_izext ( izext ) scratch2 ( izext ) = constant_factor * scratch2 ( izext ) end do ! if the pdf is not normalized by a Maxwellian then the source term contains a Maxwellian factor if (. not . maxwellian_normalization ) then do izext = 1 , nz_ext iz = iz_from_izext ( izext ) scratch2 ( izext ) = scratch2 ( izext ) * maxwell_vpa ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) * maxwell_fac ( is ) end do end if call center_zed ( iv , scratch2 , 1 , periodic ( iky )) rhs = rhs + scratch2 end subroutine add_gbar_to_g_contribution_apar subroutine add_drifts_contribution_apar ( scratch , iky , ia , ivmu , iv , is , nz_ext , iz_from_izext , rhs ) use constants , only : zi use species , only : spec use kt_grids , only : aky use dist_fn_arrays , only : wstar use parallel_streaming , only : center_zed use extended_zgrid , only : periodic use vpamu_grids , only : vpa implicit none complex , dimension (:), intent ( in out ) :: scratch , rhs integer , intent ( in ) :: iky , ia , ivmu , iv , is , nz_ext integer , dimension (:), intent ( in ) :: iz_from_izext integer :: izext , iz complex :: constant_factor constant_factor = - 2.0 * zi * spec ( is )% stm_psi0 * vpa ( iv ) * aky ( iky ) do izext = 1 , nz_ext iz = iz_from_izext ( izext ) scratch ( izext ) = constant_factor * scratch ( izext ) * wstar ( ia , iz , ivmu ) end do call center_zed ( iv , scratch , 1 , periodic ( iky )) rhs = rhs + scratch end subroutine add_drifts_contribution_apar subroutine gbar_to_g_zext ( pdf , apar , facapar , iky , ivmu , ikx_from_izext , iz_from_izext ) use species , only : spec use stella_layouts , only : vmu_lo , iv_idx , imu_idx , is_idx use run_parameters , only : maxwellian_normalization use vpamu_grids , only : vpa , maxwell_vpa , maxwell_mu , maxwell_fac implicit none complex , dimension (:), intent ( in out ) :: pdf integer , intent ( in ) :: ivmu , iky integer , dimension (:), intent ( in ) :: ikx_from_izext , iz_from_izext complex , dimension (:), intent ( in ) :: apar real , intent ( in ) :: facapar integer :: iv , imu , is integer :: izext , iz , ia integer :: nz_ext complex , dimension (:), allocatable :: field , gyro_field iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) nz_ext = size ( apar ) allocate ( field ( nz_ext )) allocate ( gyro_field ( nz_ext )) ia = 1 field = 2.0 * spec ( is )% zt * spec ( is )% stm_psi0 * vpa ( iv ) * facapar * apar if (. not . maxwellian_normalization ) then do izext = 1 , nz_ext iz = iz_from_izext ( izext ) field ( izext ) = field ( izext ) * maxwell_vpa ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) * maxwell_fac ( is ) end do end if call gyro_average_zext ( iky , ivmu , ikx_from_izext , iz_from_izext , field , gyro_field ) pdf = pdf - gyro_field deallocate ( field , gyro_field ) end subroutine gbar_to_g_zext subroutine gyro_average_zext ( iky , ivmu , ikx_from_izext , iz_from_izext , fld , gyro_fld ) use gyro_averages , only : gyro_average implicit none integer , intent ( in ) :: iky , ivmu integer , dimension (:), intent ( in ) :: ikx_from_izext , iz_from_izext complex , dimension (:), intent ( in ) :: fld complex , dimension (:), intent ( out ) :: gyro_fld integer :: izext , nz_ext nz_ext = size ( fld ) do izext = 1 , nz_ext call gyro_average ( fld ( izext ), iky , ikx_from_izext ( izext ), iz_from_izext ( izext ), ivmu , gyro_fld ( izext )) end do end subroutine gyro_average_zext subroutine gyro_average_j1_zext ( iky , ivmu , ikx_from_izext , iz_from_izext , fld , gyro_fld ) use gyro_averages , only : gyro_average_j1 implicit none integer , intent ( in ) :: iky , ivmu integer , dimension (:), intent ( in ) :: ikx_from_izext , iz_from_izext complex , dimension (:), intent ( in ) :: fld complex , dimension (:), intent ( out ) :: gyro_fld integer :: izext , nz_ext nz_ext = size ( fld ) do izext = 1 , nz_ext call gyro_average_j1 ( fld ( izext ), iky , ikx_from_izext ( izext ), iz_from_izext ( izext ), ivmu , gyro_fld ( izext )) end do end subroutine gyro_average_j1_zext !> get_contributions_from_pdf takes as an argument the evolved pdf !> (either guiding centre distribution g=<f> or maxwellian-normlized, non-Boltzmann distribution h/F0=f/F0+(Ze*phi/T)) !> and the scratch array rhs, and returns the source terms that depend on the pdf in rhs subroutine get_contributions_from_pdf ( pdf , apar , ivmu , iky , ie , rhs ) use constants , only : zi use stella_time , only : code_dt use physics_flags , only : include_apar use species , only : spec use zgrid , only : nzgrid , ntubes use kt_grids , only : naky , nakx use kt_grids , only : aky , akx use vpamu_grids , only : vpa use stella_layouts , only : vmu_lo , iv_idx , is_idx use run_parameters , only : time_upwind_minus use run_parameters , only : drifts_implicit use parallel_streaming , only : get_zed_derivative_extended_domain , center_zed use parallel_streaming , only : gradpar_c , stream_sign use dist_fn_arrays , only : wdriftx_g , wdrifty_g use extended_zgrid , only : fill_zext_ghost_zones use extended_zgrid , only : map_to_iz_ikx_from_izext use extended_zgrid , only : periodic implicit none complex , dimension (:), intent ( in ) :: pdf , apar integer , intent ( in ) :: ivmu , iky , ie complex , dimension (:), intent ( out ) :: rhs real , dimension (:), allocatable :: gradpar_fac complex , dimension (:), allocatable :: dpdf_dz real :: constant_factor integer :: iv , is , iz integer :: ia , ikx integer , dimension (:), allocatable :: iz_from_izext , ikx_from_izext integer :: nz_ext , izext complex :: pdf_left , pdf_right ia = 1 iv = iv_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) ! nz_ext is the number of grid points in the extended zed domain nz_ext = size ( pdf ) ! determine the mapping from the extended domain zed index (izext) to the ! zed and kx domain indices (iz, ikx) allocate ( iz_from_izext ( nz_ext )) allocate ( ikx_from_izext ( nz_ext )) call map_to_iz_ikx_from_izext ( iky , ie , iz_from_izext , ikx_from_izext ) ! fill ghost zones beyond ends of extended zed domain for the pdf ! and store values in scratch_left and scratch_right call fill_zext_ghost_zones ( iky , pdf , pdf_left , pdf_right ) ! obtain the zed derivative of the pdf and store in dpdf_dz allocate ( dpdf_dz ( nz_ext )) call get_zed_derivative_extended_domain ( iv , pdf , pdf_left , pdf_right , dpdf_dz ) ! compute the z-independent factor appearing in front of the d(pdf)/dz term on the RHS of the Gk equation constant_factor = - code_dt * spec ( is )% stm_psi0 * vpa ( iv ) * time_upwind_minus ! use the correctly centred (b . grad z) pre-factor for this sign of vpa allocate ( gradpar_fac ( - nzgrid : nzgrid )) if ( stream_sign ( iv ) > 0 ) then gradpar_fac = gradpar_c (:, - 1 ) * constant_factor else gradpar_fac = gradpar_c (:, 1 ) * constant_factor end if rhs = pdf ! if advancing apar, need to use gbar rather than g=<f> for part of source on RHS of GKE, ! so convert from g to gbar if ( include_apar ) then call gbar_to_g_zext ( rhs , apar , - 1.0 , iky , ivmu , ikx_from_izext , iz_from_izext ) end if if ( drifts_implicit ) then do izext = 1 , nz_ext ikx = ikx_from_izext ( izext ) iz = iz_from_izext ( izext ) rhs ( izext ) = rhs ( izext ) + pdf ( izext ) * zi * time_upwind_minus & * ( wdriftx_g ( ia , iz , ivmu ) * akx ( ikx ) + wdrifty_g ( ia , iz , ivmu ) * aky ( iky )) !            rhs(izext) = rhs(izext) * (1.0 + zi * time_upwind_minus & !                                       * (wdriftx_g(ia, iz, ivmu) * akx(ikx) + wdrifty_g(ia, iz, ivmu) * aky(iky))) end do end if ! cell-center the terms involving the pdf call center_zed ( iv , rhs , 1 , periodic ( iky )) ! construct the source term on the RHS of the GK equation coming from ! the pdf evaluated at the previous time level do izext = 1 , nz_ext rhs ( izext ) = rhs ( izext ) + gradpar_fac ( iz_from_izext ( izext )) * dpdf_dz ( izext ) end do deallocate ( dpdf_dz ) deallocate ( gradpar_fac ) deallocate ( iz_from_izext , ikx_from_izext ) end subroutine get_contributions_from_pdf subroutine sweep_g_zext ( iky , ie , it , ivmu , pdf ) use constants , only : zi use zgrid , only : nzgrid , ntubes , delzed use run_parameters , only : drifts_implicit use run_parameters , only : zed_upwind_plus , zed_upwind_minus use run_parameters , only : time_upwind_plus use kt_grids , only : nakx , akx , aky use dist_fn_arrays , only : wdriftx_g , wdrifty_g use extended_zgrid , only : map_to_extended_zgrid use extended_zgrid , only : periodic , phase_shift use parallel_streaming , only : stream_sign , stream_c use parallel_streaming , only : center_zed use stella_layouts , only : vmu_lo , iv_idx , is_idx implicit none integer , intent ( in ) :: iky , ie , it , ivmu complex , dimension (:), intent ( in out ) :: pdf complex , dimension (:), allocatable :: wdrift_ext , pdf_cf complex , dimension (:, :), allocatable :: wdrift complex :: wd_factor , fac1 , phase_factor real :: zupwnd_p , zupwnd_m , tupwnd_p real :: stream_term integer :: iz , ikx , ia integer :: iv , is integer :: ulim , sgn , iz1 , iz2 iv = iv_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) sgn = stream_sign ( iv ) ! avoid repeated calculation of constants zupwnd_p = 2.0 * zed_upwind_plus zupwnd_m = 2.0 * zed_upwind_minus tupwnd_p = 2.0 * time_upwind_plus ! if treating magentic drifts implicitly in time, ! get the drift frequency on the extended zed grid if ( drifts_implicit ) then allocate ( wdrift ( nakx , - nzgrid : nzgrid )) ia = 1 ! sum up the kx and ky contributions to the magnetic drift frequency do iz = - nzgrid , nzgrid do ikx = 1 , nakx wdrift ( ikx , iz ) = - zi * ( wdriftx_g ( ia , iz , ivmu ) * akx ( ikx ) + wdrifty_g ( ia , iz , ivmu ) * aky ( iky )) end do end do ! obtain the drift frequency on the extended zed domain allocate ( wdrift_ext ( size ( pdf ))) call map_to_extended_zgrid ( it , ie , iky , spread ( wdrift , 3 , ntubes ), wdrift_ext , ulim ) ! NB: need to check if passing periodic(iky) is the right thing to do here call center_zed ( iv , wdrift_ext , 1 , periodic ( iky )) else ulim = size ( pdf ) end if ! determine the starting and ending indices for sweep over the extended zed grid. ! as we are using a zero-incoming BC, these indices depend on the sign of the advection velocity ! note that sgn < 0 actually corresponds to positive advection velocity if ( sgn < 0 ) then iz1 = 1 ; iz2 = ulim else iz1 = ulim ; iz2 = 1 end if ! the case of periodic BC must be treated separately from the zero-incoming-BC case if ( periodic ( iky )) then ! to enforce periodicity, decompose the pdf into a particular integral ! and complementary function. ! calculate the particular integral, with zero BC, and store in pdf iz = sgn * nzgrid pdf ( iz1 ) = 0.0 call get_updated_pdf ( iz , iv , is , sgn , iz1 , iz2 , wdrift_ext , pdf ) ! calculate the complementary function, with unit BC, and store in pdf_cf allocate ( pdf_cf ( ulim )) iz = sgn * nzgrid pdf_cf = 0.0 ; pdf_cf ( iz1 ) = 1.0 call get_updated_pdf ( iz , iv , is , sgn , iz1 , iz2 , wdrift_ext , pdf_cf ) ! construct pdf = pdf_PI + (pdf_PI(zend)/(1-pdf_CF(zend))) * pdf_CF phase_factor = phase_shift ( iky ) ** ( - sgn ) pdf = pdf + ( phase_factor * pdf ( iz2 ) / ( 1.0 - phase_factor * pdf_cf ( iz2 ))) * pdf_cf deallocate ( pdf_cf ) else ! specially treat the most upwind grid point iz = sgn * nzgrid wd_factor = 1.0 if ( drifts_implicit ) wd_factor = 1.0 + 0.5 * tupwnd_p * wdrift_ext ( iz1 ) stream_term = tupwnd_p * stream_c ( iz , iv , is ) / delzed ( 0 ) fac1 = zupwnd_p * wd_factor + sgn * stream_term pdf ( iz1 ) = pdf ( iz1 ) * 2.0 / fac1 ! now that we have the pdf at the most upwind point, sweep over the ! rest of the extended zed domain to obtain the pdf(z) call get_updated_pdf ( iz , iv , is , sgn , iz1 , iz2 , wdrift_ext , pdf ) end if if ( drifts_implicit ) deallocate ( wdrift , wdrift_ext ) end subroutine sweep_g_zext subroutine get_updated_pdf ( iz , iv , is , sgn , iz1 , iz2 , wdrift_ext , pdf ) use zgrid , only : nzgrid , delzed use run_parameters , only : drifts_implicit use run_parameters , only : zed_upwind_plus , zed_upwind_minus use run_parameters , only : time_upwind_plus use parallel_streaming , only : stream_c implicit none integer , intent ( in out ) :: iz integer , intent ( in ) :: iv , is , sgn , iz1 , iz2 complex , dimension (:), intent ( in ) :: wdrift_ext complex , dimension (:), intent ( in out ) :: pdf integer :: izext real :: stream_term real :: tupwnd_p , zupwnd_p , zupwnd_m complex :: wd_factor , fac1 , fac2 tupwnd_p = 2.0 * time_upwind_plus zupwnd_p = 2.0 * zed_upwind_plus zupwnd_m = 2.0 * zed_upwind_minus ! wd_factor will be modified from below unity to account for magnetic drifts ! if the drifts are treated implicitly wd_factor = 1.0 do izext = iz1 - sgn , iz2 , - sgn if ( iz == - sgn * nzgrid ) then iz = sgn * nzgrid - sgn else iz = iz - sgn end if if ( drifts_implicit ) wd_factor = 1.0 + 0.5 * tupwnd_p * wdrift_ext ( izext ) stream_term = tupwnd_p * stream_c ( iz , iv , is ) / delzed ( 0 ) fac1 = zupwnd_p * wd_factor + sgn * stream_term fac2 = zupwnd_m * wd_factor - sgn * stream_term pdf ( izext ) = ( - pdf ( izext + sgn ) * fac2 + 2.0 * pdf ( izext )) / fac1 end do end subroutine get_updated_pdf subroutine sweep_zed_zonal ( iky , iv , is , sgn , g , llim ) use zgrid , only : nzgrid , delzed use extended_zgrid , only : phase_shift use run_parameters , only : zed_upwind , time_upwind use parallel_streaming , only : stream_c implicit none integer , intent ( in ) :: iky , iv , is , sgn , llim complex , dimension ( llim :), intent ( in out ) :: g integer :: iz , izext , iz1 , iz2 , npts , ulim real :: fac1 , fac2 complex :: pf complex , dimension (:), allocatable :: gcf , gpi npts = size ( g ) ulim = llim + npts - 1 allocate ( gpi ( llim : ulim )) allocate ( gcf ( llim : ulim )) ! ky=0 is 2pi periodic (no extended zgrid) ! decompose into complementary function + particular integral ! zero BC for particular integral ! unit BC for complementary function (no source) if ( sgn < 0 ) then iz1 = llim ; iz2 = ulim else iz1 = ulim ; iz2 = llim end if pf = phase_shift ( iky ) ** ( - sgn ) gpi ( iz1 ) = 0. ; gcf ( iz1 ) = 1. iz = sgn * nzgrid do izext = iz1 - sgn , iz2 , - sgn if ( iz == - sgn * nzgrid ) then iz = sgn * nzgrid - sgn else iz = iz - sgn end if fac1 = 1.0 + zed_upwind + sgn * ( 1.0 + time_upwind ) * stream_c ( iz , iv , is ) / delzed ( 0 ) fac2 = 1.0 - zed_upwind - sgn * ( 1.0 + time_upwind ) * stream_c ( iz , iv , is ) / delzed ( 0 ) gpi ( izext ) = ( - gpi ( izext + sgn ) * fac2 + 2.0 * g ( izext )) / fac1 gcf ( izext ) = - gcf ( izext + sgn ) * fac2 / fac1 end do ! g = g_PI + (g_PI(pi)/(1-g_CF(pi))) * g_CF g = gpi + ( pf * gpi ( iz2 ) / ( 1.0 - pf * gcf ( iz2 ))) * gcf deallocate ( gpi , gcf ) end subroutine sweep_zed_zonal !> use the LU-decomposed response matrix and the contributions from the !> 'inhomogeneous' fields (phi, apar) to solve for (phi&#94;{n+1}, apar&#94;{n+1}) subroutine invert_parstream_response ( phi , apar , bpar ) use linear_solve , only : lu_back_substitution use physics_flags , only : include_apar , include_bpar use zgrid , only : nzgrid , ntubes use extended_zgrid , only : neigen use extended_zgrid , only : nsegments use extended_zgrid , only : nzed_segment use extended_zgrid , only : map_to_extended_zgrid use extended_zgrid , only : map_from_extended_zgrid use extended_zgrid , only : ikxmod use extended_zgrid , only : periodic , phase_shift use kt_grids , only : naky use fields , only : nfields use fields_arrays , only : response_matrix implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in out ) :: phi , apar , bpar integer :: iky , ie , it , ulim integer :: ikx integer :: offset_apar , offset_bpar integer :: nresponse_per_field , nresponse , nzp complex , dimension (:), allocatable :: fld_ext , phi_ext , apar_ext , bpar_ext complex , dimension (:), allocatable :: fld ! put the fields onto the extended zed grid and use LU back substitution do iky = 1 , naky ! avoid double counting of periodic endpoints for zonal (and any other periodic) modes if ( periodic ( iky )) then nzp = 2 * nzgrid allocate ( fld ( nzp * nfields )) ! set offset integers for array slices involving apar and bpar if ( include_apar ) then offset_apar = nzp else offset_apar = 0 end if if ( include_bpar ) offset_bpar = offset_apar + nzp do it = 1 , ntubes do ie = 1 , neigen ( iky ) ikx = ikxmod ( 1 , ie , iky ) ! construct the field vector, consisting of phi (and apar if evolving) fld (: nzp ) = phi ( iky , ikx , - nzgrid : nzgrid - 1 , it ) if ( include_apar ) fld ( offset_apar + 1 : nzp + offset_apar ) = apar ( iky , ikx , - nzgrid : nzgrid - 1 , it ) if ( include_bpar ) fld ( offset_bpar + 1 : nzp + offset_bpar ) = bpar ( iky , ikx , - nzgrid : nzgrid - 1 , it ) ! use LU back substitution to solve the linear response matrix system call lu_back_substitution ( response_matrix ( iky )% eigen ( ie )% zloc , & response_matrix ( iky )% eigen ( ie )% idx , fld ) ! unpack phi (and apar if evolving) from the field vector; ! also apply phase shift at periodic point phi ( iky , ikx , - nzgrid : nzgrid - 1 , it ) = fld (: nzp ) phi ( iky , ikx , nzgrid , it ) = phi ( iky , ikx , - nzgrid , it ) / phase_shift ( iky ) if ( include_apar ) then apar ( iky , ikx , - nzgrid : nzgrid - 1 , it ) = fld ( offset_apar + 1 : nzp + offset_apar ) apar ( iky , ikx , nzgrid , it ) = apar ( iky , ikx , - nzgrid , it ) / phase_shift ( iky ) end if if ( include_bpar ) then bpar ( iky , ikx , - nzgrid : nzgrid - 1 , it ) = fld ( offset_bpar + 1 : nzp + offset_bpar ) bpar ( iky , ikx , nzgrid , it ) = bpar ( iky , ikx , - nzgrid , it ) / phase_shift ( iky ) end if end do end do deallocate ( fld ) else do it = 1 , ntubes do ie = 1 , neigen ( iky ) ! solve response_matrix*(phi&#94;{n+1}, apar&#94;{n+1}) = (phi_{inh}&#94;{n+1}, apar_{inh}&#94;{n+1}) nresponse_per_field = nsegments ( ie , iky ) * nzed_segment + 1 nresponse = nresponse_per_field * nfields ! fld_ext will contain phi or (phi, apar), depending on whether apar is evolved allocate ( fld_ext ( nresponse )) ! set offset integers for array slices involving apar and bpar if ( include_apar ) then offset_apar = nresponse_per_field else offset_apar = 0 end if if ( include_bpar ) offset_bpar = offset_apar + nresponse_per_field ! phi_ext contains phi on the extended zed domain allocate ( phi_ext ( nresponse_per_field )) call map_to_extended_zgrid ( it , ie , iky , phi ( iky , :, :, :), phi_ext , ulim ) ! include the phi_ext contribution to fld_ext fld_ext (: nresponse_per_field ) = phi_ext ! if apar evolved, obtain apar on the extended zed domain (apar_ext) ! and include its contribution to fld_ext if ( include_apar ) then allocate ( apar_ext ( nresponse_per_field )) call map_to_extended_zgrid ( it , ie , iky , apar ( iky , :, :, :), apar_ext , ulim ) fld_ext ( offset_apar + 1 : nresponse_per_field + offset_apar ) = apar_ext end if if ( include_bpar ) then allocate ( bpar_ext ( nresponse_per_field )) call map_to_extended_zgrid ( it , ie , iky , bpar ( iky , :, :, :), bpar_ext , ulim ) fld_ext ( offset_bpar + 1 : nresponse_per_field + offset_bpar ) = bpar_ext end if ! use LU back substitution to solve linear response matrix system call lu_back_substitution ( response_matrix ( iky )% eigen ( ie )% zloc , & response_matrix ( iky )% eigen ( ie )% idx , fld_ext ) ! get phi_ext contribution from fld_ext and map back to normal (z, kx) grid phi_ext = fld_ext (: nresponse_per_field ) call map_from_extended_zgrid ( it , ie , iky , phi_ext , phi ( iky , :, :, :)) ! if advancing apar, get apar_ext from fld_ext and map back to (z, kx) grid if ( include_apar ) then apar_ext = fld_ext ( offset_apar + 1 : nresponse_per_field + offset_apar ) call map_from_extended_zgrid ( it , ie , iky , apar_ext , apar ( iky , :, :, :)) end if if ( include_bpar ) then bpar_ext = fld_ext ( offset_bpar + 1 : nresponse_per_field + offset_bpar ) call map_from_extended_zgrid ( it , ie , iky , bpar_ext , bpar ( iky , :, :, :)) end if deallocate ( fld_ext ) deallocate ( phi_ext ) if ( allocated ( apar_ext )) deallocate ( apar_ext ) if ( allocated ( bpar_ext )) deallocate ( bpar_ext ) end do end do end if end do end subroutine invert_parstream_response end module implicit_solve","tags":"","loc":"sourcefile/implicit_solve.f90.html"},{"title":"stella_io.fpp – stella","text":"Source Code # include \"define.inc\" module stella_io # ifdef NETCDF use netcdf , only : nf90_noerr use netcdf_utils , only : netcdf_error , kind_nf # endif implicit none private public :: init_stella_io , finish_stella_io public :: write_time_nc public :: write_phi2_nc public :: write_apar2_nc public :: write_bpar2_nc public :: write_phi_nc public :: write_apar_nc public :: write_bpar_nc public :: write_gvmus_nc public :: write_gzvs_nc public :: write_kspectra_nc public :: write_kspectra_species_nc public :: write_omega_nc public :: write_moments_nc public :: write_radial_fluxes_nc public :: write_radial_moments_nc public :: write_fluxes_kxkyz_nc public :: write_fluxes_nc public :: get_nout public :: sync_nc # ifdef NETCDF integer ( kind_nf ) :: ncid integer ( kind_nf ) :: char10_dim integer :: code_id !> Write a `complex` array to netcdf !> !> Converts the `complex` array to a `real` array with an extra dimension interface netcdf_write_complex module procedure write_complex_rank2 , write_complex_rank4 , write_complex_rank5 end interface netcdf_write_complex # endif real , parameter :: zero = epsilon ( 0.0 ) contains !============================================== !============ INITIATE STELLA IO ============== !============================================== subroutine init_stella_io ( restart ) # ifdef NETCDF use mp , only : proc0 use file_utils , only : run_name use neasyf , only : neasyf_open , neasyf_metadata use git_version , only : get_git_version # endif implicit none !> Is this run a restart? logical , intent ( in ) :: restart # ifdef NETCDF character ( 300 ) :: filename ! The netcdf file has the extension \".out.nc\" filename = trim ( trim ( run_name ) // '.out.nc' ) ! Only the first processor (proc0) opens the file if ( proc0 ) then if ( restart ) then ncid = neasyf_open ( trim ( filename ), \"rw\" ) else ncid = neasyf_open ( trim ( filename ), \"w\" ) end if call neasyf_metadata ( ncid , title = \"stella simulation data\" , software_name = \"stella\" , & software_version = get_git_version (), auto_date = . true .) call write_grids ( ncid ) call define_vars () call nc_species ( ncid ) call nc_geo ( ncid ) call save_input ( ncid ) end if # endif end subroutine init_stella_io !> Ensure the netCDF file contains all the dimensions and grids, !> creating them if necessary subroutine write_grids ( file_id ) # ifdef NETCDF use kt_grids , only : nakx , naky , akx , aky , nalpha , theta0 , phase_shift_angle , x_d , rho_d use zgrid , only : nzgrid , ntubes , zed use vpamu_grids , only : nvpa , vpa , nmu , mu use species , only : nspec use physics_flags , only : radial_variation use physics_parameters , only : rhostar use stella_geometry , only : geo_surf , dxdXcoord , q_as_x use mp , only : nproc use neasyf , only : neasyf_dim , neasyf_write # endif !> NetCDF ID of the file integer , intent ( in ) :: file_id # ifdef NETCDF integer :: ix ! Total number of mesh points real :: nmesh ! Radial grid real , dimension (:, :), allocatable :: rg ! Grids themselves call neasyf_dim ( file_id , \"ky\" , values = aky , long_name = \"Wavenumber perpendicular to flux surface\" , units = \"1/rho_ref\" ) call neasyf_dim ( file_id , \"kx\" , values = akx , long_name = \"Wavenumber in direction of grad alpha\" , units = \"1/rho_ref\" ) call neasyf_dim ( file_id , \"tube\" , dim_size = ntubes ) call neasyf_dim ( file_id , \"zed\" , values = zed ) call neasyf_dim ( file_id , \"alpha\" , dim_size = nalpha ) call neasyf_dim ( file_id , \"vpa\" , values = vpa ) call neasyf_dim ( file_id , \"mu\" , values = mu ) call neasyf_dim ( file_id , \"species\" , dim_size = nspec ) call neasyf_dim ( file_id , \"t\" , unlimited = . true ., long_name = \"Time\" , units = \"a_ref/v_ref\" ) ! Dimensions for various string variables call neasyf_dim ( file_id , \"char10\" , dim_size = 10 , dimid = char10_dim ) call neasyf_dim ( file_id , \"char200\" , dim_size = 200 ) call neasyf_dim ( file_id , \"nlines\" , unlimited = . true ., long_name = \"Input file line number\" ) call neasyf_dim ( file_id , \"ri\" , dim_size = 2 , long_name = \"Complex components\" , units = \"(real, imaginary)\" ) if ( radial_variation ) then call neasyf_dim ( file_id , \"radgridvar\" , dim_size = 3 , long_name = \"x, q/psi, rho\" ) end if ! Grid sizes call neasyf_write ( file_id , \"nkx\" , nakx , long_name = \"Number of kx points\" ) call neasyf_write ( file_id , \"nky\" , naky , long_name = \"Number of ky points\" ) call neasyf_write ( file_id , \"ntubes\" , ntubes , long_name = \"Number of tubes\" ) call neasyf_write ( file_id , \"nzed_tot\" , 2 * nzgrid + 1 , long_name = \"Number of zed points\" ) call neasyf_write ( file_id , \"theta0\" , theta0 , dim_names = [ \"ky\" , \"kx\" ], long_name = \"Theta_0\" ) call neasyf_write ( file_id , \"nspecies\" , nspec , long_name = \"Number of species\" ) call neasyf_write ( file_id , \"nvpa_tot\" , nvpa , long_name = \"Number of vpa points\" ) call neasyf_write ( file_id , \"nmu\" , nmu , long_name = \"Number of mu points\" ) call neasyf_write ( file_id , \"phase_shift_angle\" , phase_shift_angle ) call neasyf_write ( file_id , \"nproc\" , nproc , long_name = \"Number of processors\" ) if ( radial_variation ) then allocate ( rg ( 3 , nakx )) if ( q_as_x ) then do ix = 1 , nakx rg ( 1 , ix ) = x_d ( ix ) rg ( 2 , ix ) = rhostar * x_d ( ix ) / dxdXcoord + geo_surf % qinp rg ( 3 , ix ) = rho_d ( ix ) + geo_surf % rhoc end do else do ix = 1 , nakx rg ( 1 , ix ) = x_d ( ix ) rg ( 2 , ix ) = rhostar * x_d ( ix ) / dxdXcoord rg ( 3 , ix ) = rho_d ( ix ) + geo_surf % rhoc end do end if call neasyf_write ( file_id , \"rad_grid\" , rg , dim_names = [ character ( 10 ) :: \"radgridvar\" , \"kx\" ]) deallocate ( rg ) end if nmesh = ( 2 * nzgrid + 1 ) * ntubes * nvpa * nmu * nakx * naky * nspec call neasyf_write ( file_id , \"nmesh\" , nmesh , long_name = \"Number of mesh points\" ) # endif end subroutine write_grids subroutine finish_stella_io use mp , only : proc0 # ifdef NETCDF use neasyf , only : neasyf_close if ( proc0 ) then call neasyf_close ( ncid ) end if # endif end subroutine finish_stella_io !> Save the input file in the NetCDF file subroutine save_input ( file_id ) #ifdef NETCDF use file_utils , only : num_input_lines , get_input_unit use neasyf , only : neasyf_write , neasyf_error use netcdf , only : nf90_inq_dimid , nf90_inquire_dimension , NF90_NOERR , NF90_EBADDIM #endif implicit none !> NetCDF ID of the file to write to integer , intent ( in ) :: file_id #ifdef NETCDF integer , parameter :: line_length = 200 character ( line_length ), dimension (:), allocatable :: input_file_array integer :: n , unit , status , dim_id , previous_nlines ! Don't attempt to write zero-sized arrays if ( num_input_lines <= 0 ) return ! If the existing input file in the output file was longer than ! the current one, blank out the whole thing so that we're not ! left with \"extra\" bits at the end status = nf90_inq_dimid ( file_id , \"nlines\" , dim_id ) if ( status == NF90_NOERR ) then status = nf90_inquire_dimension ( file_id , dim_id , len = previous_nlines ) call neasyf_error ( status , ncid = file_id , dim = \"nlines\" , dimid = dim_id ) if ( previous_nlines > num_input_lines ) then allocate ( input_file_array ( previous_nlines )) call neasyf_write ( file_id , \"input_file\" , input_file_array , & long_name = \"Input file\" , dim_names = [ \"char200\" , \"nlines \" ]) deallocate ( input_file_array ) end if else call neasyf_error ( status , ncid = file_id , dim = \"nlines\" , dimid = dim_id ) end if ! We need to convert the input file text into an array, one ! element per line allocate ( input_file_array ( num_input_lines )) call get_input_unit ( unit ) rewind ( unit = unit ) do n = 1 , num_input_lines read ( unit = unit , fmt = \"(a)\" ) input_file_array ( n ) end do call neasyf_write ( file_id , \"input_file\" , input_file_array , & long_name = \"Input file\" , dim_names = [ \"char200\" , \"nlines \" ]) #endif end subroutine save_input subroutine define_vars () # ifdef NETCDF use netcdf , only : nf90_char use netcdf , only : nf90_def_var , nf90_inq_varid , nf90_put_att , nf90_put_var use netcdf , only : nf90_inq_libvers # endif implicit none # ifdef NETCDF character ( 5 ) :: ci character ( 20 ) :: datestamp , timestamp , timezone integer :: status ! Write some useful general information such as the website, ! date and time into the NetCDF file datestamp (:) = ' ' timestamp (:) = ' ' timezone (:) = ' ' call date_and_time ( datestamp , timestamp , timezone ) status = nf90_inq_varid ( ncid , 'code_info' , code_id ) if ( status /= nf90_noerr ) then status = nf90_def_var ( ncid , 'code_info' , nf90_char , char10_dim , code_id ) if ( status /= nf90_noerr ) call netcdf_error ( status , var = 'code_info' ) end if status = nf90_put_att ( ncid , code_id , 'long_name' , 'stella' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , code_id , att = 'long_name' ) ci = 'c1' status = nf90_put_att ( ncid , code_id , trim ( ci ), 'Date: ' // trim ( datestamp )) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , code_id , att = ci ) ci = 'c2' status = nf90_put_att ( ncid , code_id , trim ( ci ), & 'Time: ' // trim ( timestamp ) // ' ' // trim ( timezone )) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , code_id , att = ci ) ci = 'c3' status = nf90_put_att ( ncid , code_id , trim ( ci ), & 'netCDF version ' // trim ( nf90_inq_libvers ())) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , code_id , att = ci ) ci = 'c4' status = nf90_put_att ( ncid , code_id , trim ( ci ), & 'Units are determined with respect to reference temperature (T_ref),' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , code_id , att = ci ) ci = 'c5' status = nf90_put_att ( ncid , code_id , trim ( ci ), & 'reference charge (q_ref), reference mass (mass_ref),' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , code_id , att = ci ) ci = 'c6' status = nf90_put_att ( ncid , code_id , trim ( ci ), & 'reference field (B_ref), and reference length (a_ref)' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , code_id , att = ci ) ci = 'c7' status = nf90_put_att ( ncid , code_id , trim ( ci ), & 'from which one may construct rho_ref and vt_ref/a,' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , code_id , att = ci ) ci = 'c8' status = nf90_put_att ( ncid , code_id , trim ( ci ), & 'which are the basic units of perpendicular length and time.' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , code_id , att = ci ) ci = 'c9' status = nf90_put_att ( ncid , code_id , trim ( ci ), & 'Macroscopic lengths are normalized to the minor radius.' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , code_id , att = ci ) ci = 'c10' status = nf90_put_att ( ncid , code_id , trim ( ci ), & 'The difference between rho (normalized minor radius) and rho (gyroradius)' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , code_id , att = ci ) ci = 'c11' status = nf90_put_att ( ncid , code_id , trim ( ci ), & 'should be clear from the context in which they appear below.' ) if ( status /= nf90_noerr ) call netcdf_error ( status , ncid , code_id , att = ci ) # endif end subroutine define_vars !> Write simulation time to netCDF output file !> !> Also flushes to disk subroutine write_time_nc ( nout , time ) # ifdef NETCDF use neasyf , only : neasyf_write , neasyf_error # endif implicit none !> Current timestep integer , intent ( in ) :: nout !> Current simulation time real , intent ( in ) :: time # ifdef NETCDF call neasyf_write ( ncid , \"t\" , time , dim_names = [ \"t\" ], start = [ nout ]) # endif end subroutine write_time_nc !> Write amplitude of electrostatic potential to netCDF subroutine write_phi2_nc ( nout , phi2 ) # ifdef NETCDF use neasyf , only : neasyf_write # endif implicit none !> Current timestep integer , intent ( in ) :: nout !> Amplitude of electrostatic potential real , intent ( in ) :: phi2 # ifdef NETCDF call neasyf_write ( ncid , \"phi2\" , phi2 , dim_names = [ \"t\" ], & units = \"(T_ref/q rho_ref/a_ref)**2\" , & long_name = \"Amplitude of electrostatic potential\" , & start = [ nout ]) # endif end subroutine write_phi2_nc subroutine write_apar2_nc ( nout , apar2 ) # ifdef NETCDF use neasyf , only : neasyf_write # endif implicit none !> Current timestep integer , intent ( in ) :: nout !> Amplitude of parallel vector potential real , intent ( in ) :: apar2 # ifdef NETCDF call neasyf_write ( ncid , \"apar2\" , apar2 , dim_names = [ \"t\" ], & units = \"(B_ref (rho_ref)**2 / a_ref)**2\" , & long_name = \"Amplitude of parallel vector potential apar\" , & start = [ nout ]) # endif end subroutine write_apar2_nc subroutine write_bpar2_nc ( nout , bpar2 ) # ifdef NETCDF use neasyf , only : neasyf_write # endif implicit none !> Current timestep integer , intent ( in ) :: nout !> Amplitude of parallel vector potential real , intent ( in ) :: bpar2 # ifdef NETCDF call neasyf_write ( ncid , \"bpar2\" , bpar2 , dim_names = [ \"t\" ], & units = \"(B_ref rho_ref / a_ref)**2\" , & long_name = \"Amplitude of parallel magnetic field fluctuation bpar\" , & start = [ nout ]) # endif end subroutine write_bpar2_nc !> Write time trace of electrostatic potential to netCDF subroutine write_phi_nc ( nout , phi ) use zgrid , only : nzgrid implicit none !> Current timestep integer , intent ( in ) :: nout !> Electrostatic potential complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: phi # ifdef NETCDF call netcdf_write_complex ( ncid , \"phi_vs_t\" , phi , & [ character ( len = 4 ) :: \"ri\" , \"ky\" , \"kx\" , \"zed\" , \"tube\" , \"t\" ], & long_name = \"Electrostatic potential\" , & start = [ 1 , 1 , 1 , 1 , 1 , nout ]) # endif end subroutine write_phi_nc !> Write time trace of electromagnetic field A|| to netCDF subroutine write_apar_nc ( nout , apar ) use zgrid , only : nzgrid implicit none !> Current timestep integer , intent ( in ) :: nout complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: apar # ifdef NETCDF call netcdf_write_complex ( ncid , \"apar_vs_t\" , apar , & [ character ( len = 4 ) :: \"ri\" , \"ky\" , \"kx\" , \"zed\" , \"tube\" , \"t\" ], & long_name = \"Electromagnetic parallel vector potential apar\" , & start = [ 1 , 1 , 1 , 1 , 1 , nout ]) # endif end subroutine write_apar_nc !> Write time trace of electromagnetic field B|| to netCDF subroutine write_bpar_nc ( nout , bpar ) use zgrid , only : nzgrid implicit none !> Current timestep integer , intent ( in ) :: nout complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: bpar # ifdef NETCDF call netcdf_write_complex ( ncid , \"bpar_vs_t\" , bpar , & [ character ( len = 4 ) :: \"ri\" , \"ky\" , \"kx\" , \"zed\" , \"tube\" , \"t\" ], & long_name = \"Electromagnetic field bpar\" , & start = [ 1 , 1 , 1 , 1 , 1 , nout ]) # endif end subroutine write_bpar_nc !> Write the complex frequency to netCDF subroutine write_omega_nc ( nout , omega ) implicit none integer , intent ( in ) :: nout complex , dimension (:, :), intent ( in ) :: omega # ifdef NETCDF call netcdf_write_complex ( ncid , \"omega\" , omega , & dim_names = [ \"ri\" , \"ky\" , \"kx\" , \"t \" ], & start = [ 1 , 1 , 1 , nout ], & long_name = \"Complex frequency\" , units = \"a_ref/v_ref\" ) # endif end subroutine write_omega_nc !> Write fluxes to netCDF subroutine write_radial_fluxes_nc ( nout , pflux , vflux , qflux ) # ifdef NETCDF use neasyf , only : neasyf_write # endif implicit none !> Current timestep integer , intent ( in ) :: nout !> Particle, velocity, heat flux real , dimension (:, :), intent ( in ) :: pflux , vflux , qflux # ifdef NETCDF call neasyf_write ( ncid , \"pflux_x\" , pflux , & dim_names = [ character ( len = 7 ) :: \"kx\" , \"species\" , \"t\" ], & start = [ 1 , 1 , nout ]) call neasyf_write ( ncid , \"vflux_x\" , vflux , & dim_names = [ character ( len = 7 ) :: \"kx\" , \"species\" , \"t\" ], & start = [ 1 , 1 , nout ]) call neasyf_write ( ncid , \"qflux_x\" , qflux , & dim_names = [ character ( len = 7 ) :: \"kx\" , \"species\" , \"t\" ], & start = [ 1 , 1 , nout ]) # endif end subroutine write_radial_fluxes_nc !> Write radial moments to netCDF subroutine write_radial_moments_nc ( nout , dens_x , upar_x , temp_x ) # ifdef NETCDF use neasyf , only : neasyf_write # endif implicit none !> Current timestep integer , intent ( in ) :: nout !> Radial moments for density, parallel velocity, temperature real , dimension (:, :), intent ( in ) :: dens_x , upar_x , temp_x # ifdef NETCDF call neasyf_write ( ncid , \"dens_x\" , dens_x , & dim_names = [ character ( len = 7 ) :: \"kx\" , \"species\" , \"t\" ], & start = [ 1 , 1 , nout ]) call neasyf_write ( ncid , \"upar_x\" , upar_x , & dim_names = [ character ( len = 7 ) :: \"kx\" , \"species\" , \"t\" ], & start = [ 1 , 1 , nout ]) call neasyf_write ( ncid , \"temp_x\" , temp_x , & dim_names = [ character ( len = 7 ) :: \"kx\" , \"species\" , \"t\" ], & start = [ 1 , 1 , nout ]) # endif end subroutine write_radial_moments_nc subroutine write_kspectra_nc ( nout , field_vs_kxky , keyname , longname ) # ifdef NETCDF use neasyf , only : neasyf_write # endif implicit none !> Current timestep integer , intent ( in ) :: nout real , dimension (:, :), intent ( in ) :: field_vs_kxky character ( len =* ), intent ( in ) :: keyname , longname # ifdef NETCDF call neasyf_write ( ncid , keyname , field_vs_kxky , & dim_names = [ \"ky\" , \"kx\" , \"t \" ], & start = [ 1 , 1 , nout ], & long_name = longname ) # endif end subroutine write_kspectra_nc subroutine write_kspectra_species_nc ( nout , field_vs_kxkys , keyname , longname ) # ifdef NETCDF use neasyf , only : neasyf_write # endif implicit none !> Current timestep integer , intent ( in ) :: nout real , dimension (:, :, :), intent ( in ) :: field_vs_kxkys character ( len =* ), intent ( in ) :: keyname , longname # ifdef NETCDF call neasyf_write ( ncid , keyname , field_vs_kxkys , & dim_names = [ character ( len = 7 ) :: \"ky\" , \"kx\" , \"species\" , \"t \" ], & start = [ 1 , 1 , 1 , nout ], & long_name = longname ) # endif end subroutine write_kspectra_species_nc subroutine write_fluxes_nc ( nout , pflx , vflx , qflx ) # ifdef NETCDF use neasyf , only : neasyf_write # endif implicit none !> Current timestep integer , intent ( in ) :: nout real , dimension (:), intent ( in ) :: pflx , vflx , qflx # ifdef NETCDF call neasyf_write ( ncid , \"pflx\" , pflx , & dim_names = [ character ( len = 7 ) :: \"species\" , \"t\" ], & start = [ 1 , nout ], & units = \"n_ref * v_ref * (rho_ref/a_ref)&#94;2 (with v_ref = sqrt(2 T_ref/m_ref))\" , & long_name = \"Particle flux\" ) call neasyf_write ( ncid , \"vflx\" , vflx , & dim_names = [ character ( len = 7 ) :: \"species\" , \"t\" ], & start = [ 1 , nout ], & units = \"m_ref*n_ref*(v_ref)&#94;2*(rho_ref/a_ref)&#94;2\" , & long_name = \"Momentum flux\" ) call neasyf_write ( ncid , \"qflx\" , qflx , & dim_names = [ character ( len = 7 ) :: \"species\" , \"t\" ], & start = [ 1 , nout ], & units = \"n_ref * T_ref * v_ref * (rho_ref/a_ref)&#94;2\" , & long_name = \"Heat flux\" ) # endif end subroutine write_fluxes_nc subroutine write_fluxes_kxkyz_nc ( nout , pflx_kxkyz , vflx_kxkyz , qflx_kxkyz ) # ifdef NETCDF use neasyf , only : neasyf_write # endif implicit none !> Current timestep integer , intent ( in ) :: nout real , dimension (:, :, :, :, :), intent ( in ) :: pflx_kxkyz , vflx_kxkyz , qflx_kxkyz # ifdef NETCDF call neasyf_write ( ncid , \"pflx_kxky\" , pflx_kxkyz , & dim_names = [ character ( len = 7 ) :: \"ky\" , \"kx\" , \"zed\" , \"tube\" , \"species\" , \"t\" ], & start = [ 1 , 1 , 1 , 1 , 1 , nout ], & long_name = \"Particle flux\" ) call neasyf_write ( ncid , \"vflx_kxky\" , vflx_kxkyz , & dim_names = [ character ( len = 7 ) :: \"ky\" , \"kx\" , \"zed\" , \"tube\" , \"species\" , \"t\" ], & start = [ 1 , 1 , 1 , 1 , 1 , nout ], & long_name = \"Momentum flux\" ) call neasyf_write ( ncid , \"qflx_kxky\" , qflx_kxkyz , & dim_names = [ character ( len = 7 ) :: \"ky\" , \"kx\" , \"zed\" , \"tube\" , \"species\" , \"t\" ], & start = [ 1 , 1 , 1 , 1 , 1 , nout ], & long_name = \"Heat flux\" ) # endif end subroutine write_fluxes_kxkyz_nc subroutine write_moments_nc ( nout , density , upar , temperature , spitzer2 ) implicit none integer , intent ( in ) :: nout complex , dimension (:, :, :, :, :), intent ( in ) :: density , upar , temperature , spitzer2 # ifdef NETCDF character ( * ), dimension ( * ), parameter :: dims = [ character ( 7 ) :: \"ri\" , \"ky\" , \"kx\" , \"zed\" , \"tube\" , \"species\" , \"t\" ] integer , dimension ( 7 ) :: start start = [ 1 , 1 , 1 , 1 , 1 , 1 , nout ] call netcdf_write_complex ( ncid , \"density\" , density , & dim_names = dims , start = start , & long_name = \"Perturbed density\" ) call netcdf_write_complex ( ncid , \"upar\" , upar , & dim_names = dims , start = start , & long_name = \"Perturbed upar\" ) call netcdf_write_complex ( ncid , \"temperature\" , temperature , & dim_names = dims , start = start , & long_name = \"Perturbed temperature\" ) ! AVB: added: (move this to a separate diagnostic in the future) call netcdf_write_complex ( ncid , \"spitzer2\" , spitzer2 , & dim_names = dims , start = start , & long_name = \"Integral required for second Spitzer coefficient\" ) # endif end subroutine write_moments_nc !> Write guiding center distribution function averaged over real space subroutine write_gvmus_nc ( nout , gvmus ) # ifdef NETCDF use neasyf , only : neasyf_write # endif implicit none !> Current timestep integer , intent ( in ) :: nout !> Guiding centre distribution function real , dimension (:, :, :), intent ( in ) :: gvmus # ifdef NETCDF call neasyf_write ( ncid , \"gvmus\" , gvmus , & dim_names = [ character ( len = 7 ) :: \"vpa\" , \"mu\" , \"species\" , \"t\" ], & start = [ 1 , 1 , 1 , nout ], & long_name = \"Guiding center distribution function averaged over real space\" ) # endif end subroutine write_gvmus_nc !> Write guiding center distribution function averaged over (kx, ky, mu) subroutine write_gzvs_nc ( nout , gzvs ) # ifdef NETCDF use neasyf , only : neasyf_write # endif implicit none !> Current timestep integer , intent ( in ) :: nout !> Guiding centre distribution function real , dimension (:, :, :, :), intent ( in ) :: gzvs # ifdef NETCDF call neasyf_write ( ncid , \"gzvs\" , gzvs , & dim_names = [ character ( len = 7 ) :: \"tube\" , \"zed\" , \"vpa\" , \"species\" , \"t\" ], & start = [ 1 , 1 , 1 , 1 , nout ], & long_name = \"Guiding center distribution function averaged over (kx, ky, mu)\" ) # endif end subroutine write_gzvs_nc !> Write [[species:spec]] to output netCDF file subroutine nc_species ( file_id ) #ifdef NETCDF use species , only : spec , nspec use neasyf , only : neasyf_write #endif implicit none !> NetCDF ID of the file to write to integer , intent ( in ) :: file_id #ifdef NETCDF integer :: is ! FIXME: FLAG - ignoring cross-species collisions for now real , dimension ( nspec ) :: vnew do is = 1 , nspec vnew ( is ) = spec ( is )% vnew ( is ) end do ! Additional brackets around `(spec%z)` etc to workaround gfortran bug call neasyf_write ( file_id , \"charge\" , ( spec % z ), dim_names = [ \"species\" ], & long_name = \"Charge\" , units = \"e\" ) call neasyf_write ( file_id , \"mass\" , ( spec % mass ), dim_names = [ \"species\" ], & long_name = \"Atomic mass\" , units = \"AMU\" ) call neasyf_write ( file_id , \"dens\" , ( spec % dens ), dim_names = [ \"species\" ], & long_name = \"Normalised density\" , units = \"n_ref\" ) call neasyf_write ( file_id , \"temp\" , ( spec % temp ), dim_names = [ \"species\" ], & long_name = \"Normalised temperature\" , units = \"T_ref\" ) call neasyf_write ( file_id , \"tprim\" , ( spec % tprim ), dim_names = [ \"species\" ], & long_name = \"Normalised temperature gradient scale length -1/rho dT/drho\" , units = \"1/a_ref\" ) call neasyf_write ( file_id , \"fprim\" , ( spec % fprim ), dim_names = [ \"species\" ], & long_name = \"Normalised density gradient scale length -1/rho dn/drho\" , units = \"1/a_ref\" ) call neasyf_write ( file_id , \"vnew\" , vnew , dim_names = [ \"species\" ], & long_name = \"Collisionality\" , units = \"v_ref/a_ref\" ) call neasyf_write ( file_id , \"type_of_species\" , ( spec % type ), dim_names = [ \"species\" ], & long_name = \"Species type: 1=ion, 2=electron, 3=slowing down, 4=trace\" ) #endif end subroutine nc_species !> Write various geometric quantities to output netCDF file subroutine nc_geo ( file_id ) # ifdef NETCDF use neasyf , only : neasyf_write use stella_geometry , only : bmag , gradpar , gbdrift , gbdrift0 , & cvdrift , cvdrift0 , gds2 , gds21 , gds22 , grho , jacob , & drhodpsi , djacdrho , b_dot_grad_z use stella_geometry , only : geo_surf use physics_parameters , only : beta use dist_fn_arrays , only : kperp2 use kt_grids , only : naky , nakx , jtwist #endif implicit none !> NetCDF ID of the file to write to integer , intent ( in ) :: file_id # ifdef NETCDF character ( len =* ), dimension ( * ), parameter :: flux_surface_dim = [ \"alpha\" , \"zed  \" ] call neasyf_write ( file_id , \"bmag\" , bmag , dim_names = flux_surface_dim , & long_name = \"Magnitude of magnetic field\" , units = \"B_0\" ) call neasyf_write ( file_id , \"b_dot_grad_z\" , b_dot_grad_z , dim_names = flux_surface_dim ) call neasyf_write ( file_id , \"gradpar\" , gradpar , dim_names = [ \"zed\" ], & long_name = \"Parallel derivative multiplier\" ) call neasyf_write ( file_id , \"gbdrift\" , gbdrift , dim_names = flux_surface_dim , & long_name = \"Magnetic gradient drift\" ) call neasyf_write ( file_id , \"gbdrift0\" , gbdrift0 , dim_names = flux_surface_dim ) call neasyf_write ( file_id , \"cvdrift\" , cvdrift , dim_names = flux_surface_dim ) call neasyf_write ( file_id , \"cvdrift0\" , cvdrift0 , dim_names = flux_surface_dim ) call neasyf_write ( file_id , \"kperp2\" , kperp2 , dim_names = [ character ( len = 5 ) :: \"ky\" , \"kx\" , \"alpha\" , \"zed\" ]) call neasyf_write ( file_id , \"gds2\" , gds2 , dim_names = flux_surface_dim ) call neasyf_write ( file_id , \"gds21\" , gds21 , dim_names = flux_surface_dim ) call neasyf_write ( file_id , \"gds22\" , gds22 , dim_names = flux_surface_dim ) call neasyf_write ( file_id , \"grho\" , grho , dim_names = flux_surface_dim ) call neasyf_write ( file_id , \"jacob\" , jacob , dim_names = flux_surface_dim ) call neasyf_write ( file_id , \"djacdrho\" , djacdrho , dim_names = flux_surface_dim ) call neasyf_write ( file_id , \"beta\" , beta , & long_name = \"Reference beta\" , units = \"2.mu0.n_ref.T_ref/B_a**2\" ) call neasyf_write ( file_id , \"q\" , geo_surf % qinp , & long_name = \"Local safety factor\" ) call neasyf_write ( file_id , \"shat\" , geo_surf % shat , & long_name = \"(rho/q) dq/drho\" ) call neasyf_write ( file_id , \"d2qdr2\" , geo_surf % d2qdr2 ) call neasyf_write ( file_id , \"drhodpsi\" , drhodpsi , & long_name = \"drho/dPsi\" ) call neasyf_write ( file_id , \"d2psidr2\" , geo_surf % d2psidr2 ) call neasyf_write ( file_id , \"jtwist\" , jtwist , & long_name = \"2*pi*shat*dky/dkx\" ) # endif end subroutine nc_geo !> Get the index of the time dimension in the netCDF file that corresponds to !> a time no larger than `tstart` subroutine get_nout ( tstart , nout ) use netcdf , only : nf90_inquire_dimension , nf90_inq_dimid use neasyf , only : neasyf_read , neasyf_error implicit none !> Simulation time to find real , intent ( in ) :: tstart !> Index of time dimension integer , intent ( out ) :: nout real , dimension (:), allocatable :: times integer :: i , length , time_dim nout = 1 call neasyf_error ( nf90_inq_dimid ( ncid , \"t\" , time_dim ), ncid ) call neasyf_error ( nf90_inquire_dimension ( ncid , time_dim , len = length ), ncid ) if ( length > 0 ) then allocate ( times ( length )) call neasyf_read ( ncid , \"t\" , times ) i = length do while ( times ( i ) > tstart . and . i > 0 ) i = i - 1 end do nout = i + 1 deallocate ( times ) end if end subroutine get_nout !> Flush netCDF file to disk subroutine sync_nc #ifdef NETCDF use netcdf , only : nf90_sync use neasyf , only : neasyf_error call neasyf_error ( nf90_sync ( ncid ), ncid = ncid , message = \"Couldn't flush to disk\" ) #endif end subroutine sync_nc subroutine write_complex_rank2 ( parent_id , name , values , dim_names , units , long_name , start ) use neasyf , only : neasyf_write use convert , only : c2r !> Name of the variable character ( len =* ), intent ( in ) :: name !> NetCDF ID of the parent group/file integer , intent ( in ) :: parent_id !> Array to be written complex , dimension (:, :), intent ( in ) :: values !> Array of dimension names character ( len =* ), dimension (:), intent ( in ) :: dim_names !> Units of coordinate character ( len =* ), optional , intent ( in ) :: units !> Long descriptive name character ( len =* ), optional , intent ( in ) :: long_name integer , dimension (:), optional , intent ( in ) :: start real , dimension ( 2 , & size ( values , 1 ), & size ( values , 2 ) & ) :: real_values call c2r ( values , real_values ) call neasyf_write ( parent_id , name , real_values , dim_names = dim_names , units = units , long_name = long_name , start = start ) end subroutine write_complex_rank2 subroutine write_complex_rank4 ( parent_id , name , values , dim_names , units , long_name , start ) use neasyf , only : neasyf_write use convert , only : c2r !> Name of the variable character ( len =* ), intent ( in ) :: name !> NetCDF ID of the parent group/file integer , intent ( in ) :: parent_id !> Array to be written complex , dimension (:, :, :, :), intent ( in ) :: values !> Array of dimension names character ( len =* ), dimension (:), intent ( in ) :: dim_names !> Units of coordinate character ( len =* ), optional , intent ( in ) :: units !> Long descriptive name character ( len =* ), optional , intent ( in ) :: long_name integer , dimension (:), optional , intent ( in ) :: start real , dimension ( 2 , & size ( values , 1 ), & size ( values , 2 ), & size ( values , 3 ), & size ( values , 4 ) & ) :: real_values call c2r ( values , real_values ) call neasyf_write ( parent_id , name , real_values , dim_names = dim_names , units = units , long_name = long_name , start = start ) end subroutine write_complex_rank4 subroutine write_complex_rank5 ( parent_id , name , values , dim_names , units , long_name , start ) use neasyf , only : neasyf_write use convert , only : c2r !> Name of the variable character ( len =* ), intent ( in ) :: name !> NetCDF ID of the parent group/file integer , intent ( in ) :: parent_id !> Array to be written complex , dimension (:, :, :, :, :), intent ( in ) :: values !> Array of dimension names character ( len =* ), dimension (:), intent ( in ) :: dim_names !> Units of coordinate character ( len =* ), optional , intent ( in ) :: units !> Long descriptive name character ( len =* ), optional , intent ( in ) :: long_name integer , dimension (:), optional , intent ( in ) :: start real , dimension ( 2 , & size ( values , 1 ), & size ( values , 2 ), & size ( values , 3 ), & size ( values , 4 ), & size ( values , 5 ) & ) :: real_values call c2r ( values , real_values ) call neasyf_write ( parent_id , name , real_values , dim_names = dim_names , units = units , long_name = long_name , start = start ) end subroutine write_complex_rank5 end module stella_io","tags":"","loc":"sourcefile/stella_io.fpp.html"},{"title":"vmec_geo.f90 – stella","text":"Source Code module vmec_geo implicit none public :: read_vmec_parameters public :: get_vmec_geo real :: alpha0 integer :: zgrid_refinement_factor real :: zgrid_scalefac , gradpar_zeta_prefac integer :: surface_option real :: nfield_periods real :: zeta_center , torflux logical :: verbose character ( 2000 ) :: vmec_filename integer :: n_tolerated_test_arrays_inconsistencies contains subroutine read_vmec_parameters use file_utils , only : input_unit_exist use mp , only : mp_abort use zgrid , only : zed_equal_arc implicit none integer :: in_file logical :: exist namelist / vmec_parameters / alpha0 , zeta_center , nfield_periods , & torflux , zgrid_scalefac , zgrid_refinement_factor , surface_option , & verbose , vmec_filename , gradpar_zeta_prefac , n_tolerated_test_arrays_inconsistencies call init_vmec_defaults in_file = input_unit_exist ( \"vmec_parameters\" , exist ) if ( exist ) read ( unit = in_file , nml = vmec_parameters ) if ( zgrid_scalefac < 1.0 - epsilon ( 0. )) then write ( * , * ) 'zgrid_scalefac = ' , zgrid_scalefac call mp_abort ( 'zgrid_scalefac should always be >= 1.0.  aborting' ) else if (. not . zed_equal_arc ) then if ( zgrid_scalefac > 1.0 + epsilon ( 0. )) then write ( * , * ) 'There is no reason to use zgrid_scalefac different from 1.0 unless zed_equal_arc=T' write ( * , * ) 'Setting zgrid_scalefac = 1.0' zgrid_scalefac = 1.0 else if ( zgrid_refinement_factor > 1 ) then write ( * , * ) 'There is no reason to use zgrid_refinement_factor > 1 unless zed_equal_arc=T' write ( * , * ) 'Setting zgrid_refinement_factor = 1' zgrid_refinement_factor = 1 end if end if if ( n_tolerated_test_arrays_inconsistencies < 0 ) then write ( * , * ) 'n_tolerated_test_arrays_inconsistencies = ' , n_tolerated_test_arrays_inconsistencies call mp_abort ( 'n_tolerated_test_arrays_inconsistencies should always be >= 0.  aborting' ) end if end subroutine read_vmec_parameters subroutine init_vmec_defaults use zgrid , only : zed_equal_arc implicit none vmec_filename = 'equilibria/wout_w7x_standardConfig.nc' alpha0 = 0.0 zeta_center = 0.0 nfield_periods = - 1.0 torflux = 0.6354167d+0 surface_option = 0 verbose = . true . gradpar_zeta_prefac = 1.0 ! originally planned to make gradpar independent of alpha ! for full flux surface simulations. this required ! the code to obtain vmec geo quantities ! on a zeta grid that is longer than ! will ultimately be used in simulation ! this is unlikely to be needed in the future, ! but leaving in as an option until sure it is not needed. zgrid_scalefac = 1.0 if ( zed_equal_arc ) then zgrid_refinement_factor = 4 else zgrid_refinement_factor = 1 end if n_tolerated_test_arrays_inconsistencies = 0 end subroutine init_vmec_defaults subroutine get_vmec_geo ( new_zeta_min , stellarator_symmetric_BC , & nzgrid , nalpha , naky , surf , grho , bmag , gradpar , & b_dot_grad_z , grad_alpha_grad_alpha , & grad_alpha_grad_psi , grad_psi_grad_psi , & gds23 , gds24 , gds25 , gds26 , gbdrift_alpha , gbdrift0_psi , cvdrift_alpha , & cvdrift0_psi , sign_torflux , & theta_vmec , zed_scalefac , L_reference , B_reference , alpha , zeta , & field_period_ratio , x_displacement_fac ) use constants , only : pi use common_types , only : flux_surface_type use splines , only : geo_spline use physics_flags , only : full_flux_surface , const_alpha_geo use vmec_to_stella_geometry_interface_mod , only : vmec_to_stella_geometry_interface use vmec_to_stella_geometry_interface_mod , only : read_vmec_equilibrium use zgrid , only : zed_equal_arc , get_total_arc_length , get_arc_length_grid use zgrid , only : zed use file_utils , only : open_output_file use mp , only : mp_abort implicit none integer , intent ( in ) :: nzgrid , nalpha , naky logical , intent ( in ) :: stellarator_symmetric_BC real , intent ( in ) :: new_zeta_min type ( flux_surface_type ), intent ( out ) :: surf real , dimension ( - nzgrid :), intent ( out ) :: gradpar real , dimension (:, - nzgrid :), intent ( out ) :: grho , bmag , b_dot_grad_z , & grad_alpha_grad_alpha , grad_alpha_grad_psi , grad_psi_grad_psi , & gds23 , gds24 , gds25 , gds26 , gbdrift_alpha , gbdrift0_psi , & cvdrift_alpha , cvdrift0_psi , theta_vmec , zeta , & ! JCP x_displacement_fac real , dimension (:), intent ( out ) :: alpha real , intent ( out ) :: zed_scalefac , L_reference , B_reference integer , intent ( out ) :: sign_torflux real , intent ( out ) :: field_period_ratio logical , parameter :: debug = . false . integer :: tmpunit integer :: i , j , ia , iz integer :: nzgrid_vmec integer :: zetamax_idx real :: nfp real , dimension (:), allocatable :: zeta_vmec real , dimension (:, :), allocatable :: thetamod_vmec real , dimension ( nalpha , - nzgrid : nzgrid ) :: B_sub_theta_vmec , B_sub_zeta ! JFP real , dimension (:, :), allocatable :: B_sub_theta_vmec_mod , B_sub_zeta_mod ! JFP real , dimension (:, :), allocatable :: bmag_vmec , gradpar_vmec , gradpar_zeta real , dimension (:, :), allocatable :: grad_alpha_grad_alpha_vmec real , dimension (:, :), allocatable :: grad_alpha_grad_psi_vmec real , dimension (:, :), allocatable :: grad_psi_grad_psi_vmec real , dimension (:, :), allocatable :: gds23_vmec , gds24_vmec , gds25_vmec , gds26_vmec real , dimension (:, :), allocatable :: gbdrift_alpha_vmec , gbdrift0_psi_vmec real , dimension (:, :), allocatable :: cvdrift_alpha_vmec , cvdrift0_psi_vmec real , dimension (:, :), allocatable :: x_displacement_fac_vmec real , dimension (:), allocatable :: zed_domain_size real , dimension (:, :), allocatable :: arc_length real :: dzeta_vmec , zmin , zmax real , dimension ( nalpha , - nzgrid : nzgrid ) :: theta integer :: ierr !> To avoid writting twice in the output file when recomputing zeta. if ( stellarator_symmetric_BC ) verbose = . false . !> first read in equilibrium information from vmec file !> this is stored as a set of global variables in read_wout_mod !> in mini_libstell.  it will be accessible if ( debug ) write ( * , * ) 'get_vmec_geo::read_vmec_equilibrium' call read_vmec_equilibrium ( vmec_filename , verbose , ierr ) if ( ierr /= 0 ) then call mp_abort ( 'read_vmec_equilibrium returned error.' ) end if ! !> nzgrid_vmec is the number of positive/negative zeta locations ! !> at which to get geometry data from vmec ! !> can be > than nzgrid for full_flux_surface case ! !> where z(zeta_max)-z(zeta_min) varies with alpha ! !> and thus a larger than usual range of zeta_max/min ! !> values are needed to avoid extrapolation ! if (zed_equal_arc) then ! if (debug) write (*,*) 'get_vmec_geo::get_modified_vmec_zeta_grid' call get_modified_vmec_zeta_grid ( new_zeta_min , stellarator_symmetric_BC , nzgrid_vmec , dzeta_vmec ) ! else !   nzgrid_vmec = nzgrid ! end if !> if desired, increase number of sampled zeta grid points in VMEC data !> to increase accuracy of later integration in zeta and interpolation !> onto stella zed grid nzgrid_vmec = nzgrid * zgrid_refinement_factor !> allocate vmec geometry arrays of size 2*nzgrid_vmec+1 allocate ( zeta_vmec ( - nzgrid_vmec : nzgrid_vmec )) allocate ( thetamod_vmec ( nalpha , - nzgrid_vmec : nzgrid_vmec )) allocate ( B_sub_zeta_mod ( nalpha , - nzgrid_vmec : nzgrid_vmec )) ! JFP allocate ( B_sub_theta_vmec_mod ( nalpha , - nzgrid_vmec : nzgrid_vmec )) ! JFP allocate ( bmag_vmec ( nalpha , - nzgrid_vmec : nzgrid_vmec )) allocate ( gradpar_vmec ( nalpha , - nzgrid_vmec : nzgrid_vmec )) allocate ( grad_alpha_grad_alpha_vmec ( nalpha , - nzgrid_vmec : nzgrid_vmec )) allocate ( grad_alpha_grad_psi_vmec ( nalpha , - nzgrid_vmec : nzgrid_vmec )) allocate ( grad_psi_grad_psi_vmec ( nalpha , - nzgrid_vmec : nzgrid_vmec )) allocate ( gds23_vmec ( nalpha , - nzgrid_vmec : nzgrid_vmec )) allocate ( gds24_vmec ( nalpha , - nzgrid_vmec : nzgrid_vmec )) allocate ( gds25_vmec ( nalpha , - nzgrid_vmec : nzgrid_vmec )) allocate ( gds26_vmec ( nalpha , - nzgrid_vmec : nzgrid_vmec )) allocate ( gbdrift_alpha_vmec ( nalpha , - nzgrid_vmec : nzgrid_vmec )) allocate ( gbdrift0_psi_vmec ( nalpha , - nzgrid_vmec : nzgrid_vmec )) allocate ( cvdrift_alpha_vmec ( nalpha , - nzgrid_vmec : nzgrid_vmec )) allocate ( cvdrift0_psi_vmec ( nalpha , - nzgrid_vmec : nzgrid_vmec )) allocate ( x_displacement_fac_vmec ( nalpha , - nzgrid_vmec : nzgrid_vmec )) allocate ( arc_length ( nalpha , - nzgrid_vmec : nzgrid_vmec )) if ( debug ) write ( * , * ) 'get_vmec_geo::vmec_to_stella_geometry_interface' call vmec_to_stella_geometry_interface ( nalpha , alpha0 , & nzgrid_vmec , zeta_center , nfield_periods * zgrid_scalefac , torflux , & surface_option , verbose , & surf % rhoc , surf % qinp , surf % shat , L_reference , B_reference , nfp , & sign_torflux , alpha , zeta_vmec , & bmag_vmec , gradpar_vmec , grad_alpha_grad_alpha_vmec , & grad_alpha_grad_psi_vmec , grad_psi_grad_psi_vmec , & gds23_vmec , gds24_vmec , & gds25_vmec , gds26_vmec , gbdrift_alpha_vmec , gbdrift0_psi_vmec , & cvdrift_alpha_vmec , & cvdrift0_psi_vmec , thetamod_vmec , B_sub_zeta_mod , B_sub_theta_vmec_mod , & x_displacement_fac_vmec , gradpar_zeta_prefac , ierr ) if ( ierr /= 0 ) then if ( ierr > n_tolerated_test_arrays_inconsistencies . or . ierr < 0 ) then call mp_abort ( 'vmec_to_stella_geometry_interface returned error.' ) end if end if !> get ratio of number of simulated field periods to the number of field periods of the device field_period_ratio = nfield_periods / real ( nfp ) dzeta_vmec = zeta_vmec ( 1 ) - zeta_vmec ( 0 ) allocate ( zed_domain_size ( nalpha )) !    if (nzgrid_vmec /= nzgrid) then if ( zed_equal_arc ) then !> must interpolate geometric quantities from (zeta,alpha) grid to !> (zed,alpha) grid, with zed the normalised arc-length !> first need to get zed(zeta,alpha) !> defined via H(alpha) = b . grad z = b . grad zeta * dz/dzeta !> and z_min = zeta_min, z_max = zeta_max (independent of alpha). !> note that nzgrid*zgrid_refinement_factor gives index !> for the max zeta of the nominal zeta grid !zetamax_idx = nzgrid*zgrid_refinement_factor zetamax_idx = nzgrid_vmec if ( debug ) write ( * , * ) 'get_vmec_geo::get_total_arc_length' do ia = 1 , nalpha !> zed_domain_size is z(zeta_max) - z(zeta_min) for nominal zeta domain call get_total_arc_length ( zetamax_idx , gradpar_vmec ( ia , - zetamax_idx : zetamax_idx ), & dzeta_vmec , zed_domain_size ( ia )) !> z(zeta_min) should be zeta_min zmin = - zed_domain_size ( ia ) * 0.5 call get_arc_length_grid ( zetamax_idx , nzgrid_vmec , zmin , & gradpar_vmec ( ia , :), dzeta_vmec , arc_length ( ia , :)) !> b_dot_grad_z is the total arc-length for one toroidal turn, !> multiplied by 2*pi b_dot_grad_z ( ia , :) = 2.0 * pi / zed_domain_size ( ia ) end do !> now that we know the min/max values of z corresponding to min/max values !> of the nominal zeta at each of the alphas, construct a regular z grid !> set the max z value on this regular grid to the maximum over all alpha !> of z(zeta_max,alpha) zmax = maxval ( zed_domain_size ) * 0.5 !> scale zed so that it is arc-length compressed (or expanded) !> to the range [-pi:pi] !zed_scalefac = pi/zmax arc_length = 2.0 * pi * arc_length / spread ( zed_domain_size , 2 , 2 * nzgrid_vmec + 1 ) zed_scalefac = 1.0 !       arc_length = arc_length*zed_scalefac if (. not . allocated ( gradpar_zeta )) allocate ( gradpar_zeta ( nalpha , - nzgrid : nzgrid )) if ( debug ) write ( * , * ) 'get_vmec_geo::geo_spline' do ia = 1 , nalpha !> now that we have z(alpha,zeta), interpolate from regular zeta grid (which is irregular in z) !> to regular zed grid (irregular in zeta) call geo_spline ( arc_length ( ia , :), zeta_vmec , zed , zeta ( ia , :)) call geo_spline ( arc_length ( ia , :), gradpar_vmec ( ia , :), zed , gradpar_zeta ( ia , :)) call geo_spline ( arc_length ( ia , :), bmag_vmec ( ia , :), zed , bmag ( ia , :)) call geo_spline ( arc_length ( ia , :), grad_alpha_grad_alpha_vmec ( ia , :), zed , grad_alpha_grad_alpha ( ia , :)) call geo_spline ( arc_length ( ia , :), grad_alpha_grad_psi_vmec ( ia , :), zed , grad_alpha_grad_psi ( ia , :)) call geo_spline ( arc_length ( ia , :), grad_psi_grad_psi_vmec ( ia , :), zed , grad_psi_grad_psi ( ia , :)) call geo_spline ( arc_length ( ia , :), gds23_vmec ( ia , :), zed , gds23 ( ia , :)) call geo_spline ( arc_length ( ia , :), gds24_vmec ( ia , :), zed , gds24 ( ia , :)) call geo_spline ( arc_length ( ia , :), gds25_vmec ( ia , :), zed , gds25 ( ia , :)) call geo_spline ( arc_length ( ia , :), gds26_vmec ( ia , :), zed , gds26 ( ia , :)) call geo_spline ( arc_length ( ia , :), gbdrift_alpha_vmec ( ia , :), zed , gbdrift_alpha ( ia , :)) call geo_spline ( arc_length ( ia , :), gbdrift0_psi_vmec ( ia , :), zed , gbdrift0_psi ( ia , :)) call geo_spline ( arc_length ( ia , :), cvdrift_alpha_vmec ( ia , :), zed , cvdrift_alpha ( ia , :)) call geo_spline ( arc_length ( ia , :), cvdrift0_psi_vmec ( ia , :), zed , cvdrift0_psi ( ia , :)) call geo_spline ( arc_length ( ia , :), thetamod_vmec ( ia , :), zed , theta_vmec ( ia , :)) call geo_spline ( arc_length ( ia , :), B_sub_zeta_mod ( ia , :), zed , B_sub_zeta ( ia , :)) ! JFP call geo_spline ( arc_length ( ia , :), B_sub_theta_vmec_mod ( ia , :), zed , B_sub_theta_vmec ( ia , :)) ! JFP call geo_spline ( arc_length ( ia , :), x_displacement_fac_vmec ( ia , :), zed , x_displacement_fac ( ia , :)) !B_sub_zeta = B_sub_zeta_mod !B_sub_theta_vmec = B_sub_theta_vmec_mod !> gradpar at this point is b . grad zeta !> but want it to be b . grad z = b . grad zeta * dz/dzeta. !> we have constructed b_dot_grad_z = b . grad to be a function purely of alpha, !> so dz/dzeta = b_dot_grad_z(alpha) / b_dot_grad_zeta(alpha,zeta) !          ! we have constructed z so that b . grad z = 1 !          ! so dz/dzeta = 1 / b . grad zeta !> gds23 and gds24 involve grad z factors !> but currently calculated in terms of grad zeta !> so convert via multiplication with dz/dzeta gds23 ( ia , :) = gds23 ( ia , :) * b_dot_grad_z ( ia , :) / gradpar_zeta ( ia , :) gds24 ( ia , :) = gds24 ( ia , :) * b_dot_grad_z ( ia , :) / gradpar_zeta ( ia , :) end do ! gradpar = 1.0 !> define gradpar to be the average value of b_dot_grad_z in alpha gradpar = sum ( b_dot_grad_z , 1 ) / size ( b_dot_grad_z , 1 ) !> we now have geometric coefficients on an alpha-grid. !> as we will be multiplying this with functions of g and phi, !> we must take care to avoid aliasing. !> this is accomplished by filtering out the highest third of !> the wavenumber spectra if ( debug ) write ( * , * ) 'get_vmec_geo::filter_geo_coef' if ( full_flux_surface . and . . not . const_alpha_geo ) then do iz = - nzgrid , nzgrid call filter_geo_coef ( naky , bmag (:, iz )) call filter_geo_coef ( naky , grad_alpha_grad_alpha (:, iz )) call filter_geo_coef ( naky , grad_alpha_grad_psi (:, iz )) call filter_geo_coef ( naky , grad_psi_grad_psi (:, iz )) call filter_geo_coef ( naky , gds23 (:, iz )) call filter_geo_coef ( naky , gds24 (:, iz )) call filter_geo_coef ( naky , gds25 (:, iz )) call filter_geo_coef ( naky , gds26 (:, iz )) call filter_geo_coef ( naky , gbdrift_alpha (:, iz )) call filter_geo_coef ( naky , gbdrift0_psi (:, iz )) call filter_geo_coef ( naky , cvdrift_alpha (:, iz )) call filter_geo_coef ( naky , cvdrift0_psi (:, iz )) call filter_geo_coef ( naky , b_dot_grad_z (:, iz )) end do end if else !> if zed_equal_arc = F, zed coordinate is the same as VMEC's zeta coordinate, !> so no need to interpolate onto a new grid zeta = spread ( zeta_vmec , 1 , nalpha ) bmag = bmag_vmec gradpar = gradpar_vmec ( 1 , :) b_dot_grad_z = gradpar_vmec grad_alpha_grad_alpha = grad_alpha_grad_alpha_vmec grad_alpha_grad_psi = grad_alpha_grad_psi_vmec grad_psi_grad_psi = grad_psi_grad_psi_vmec gds23 = gds23_vmec gds24 = gds24_vmec gds25 = gds25_vmec gds26 = gds26_vmec gbdrift_alpha = gbdrift_alpha_vmec gbdrift0_psi = gbdrift0_psi_vmec cvdrift_alpha = cvdrift_alpha_vmec cvdrift0_psi = cvdrift0_psi_vmec x_displacement_fac = x_displacement_fac_vmec theta_vmec = thetamod_vmec B_sub_theta_vmec = B_sub_theta_vmec_mod ! JFP B_sub_zeta = B_sub_zeta_mod ! JFP ! scale zed so that it is zeta compressed (or expanded) ! to the range [-pi,pi] ! this is 1/p from stella JCP paper zed_scalefac = real ( nfp ) / nfield_periods end if !> gradpar is b . grad zed (or its alpha-average, in the case of full_flux_surface=T), !> with zed = zeta or normalised arc-length, both scaled to run from -pi to pi gradpar = gradpar * zed_scalefac b_dot_grad_z = b_dot_grad_z * zed_scalefac gds23 = gds23 * zed_scalefac gds24 = gds24 * zed_scalefac ! arrays over extended zeta-grid no longer needed, so deallocate deallocate ( zed_domain_size ) deallocate ( zeta_vmec ) deallocate ( thetamod_vmec ) deallocate ( B_sub_theta_vmec_mod ) deallocate ( B_sub_zeta_mod ) deallocate ( bmag_vmec , gradpar_vmec ) if ( allocated ( gradpar_zeta )) deallocate ( gradpar_zeta ) deallocate ( grad_alpha_grad_alpha_vmec , grad_alpha_grad_psi_vmec , grad_psi_grad_psi_vmec ) deallocate ( gds23_vmec , gds24_vmec , gds25_vmec , gds26_vmec ) deallocate ( gbdrift_alpha_vmec , gbdrift0_psi_vmec ) deallocate ( cvdrift_alpha_vmec , cvdrift0_psi_vmec ) deallocate ( x_displacement_fac_vmec ) deallocate ( arc_length ) !> vmec_to_stella_geometry_interface returns psitor/psitor_lcfs as rhoc !> stella uses rhoc = sqrt(psitor/psitor_lcfs) = rhotor surf % rhoc = sqrt ( surf % rhoc ) surf % rhotor = surf % rhoc ! rho = sqrt(psi_t / psi_{t,LCFS}) ! Bref = 2|psi_LCFS|/a&#94;2 ! grho = a * |grad rho| = a * |drho/dpsi_t| * |grad psi_t| ! = |drho/dpsi_t|*(a&#94;2*Bref) * |grad psi_t|/(a*Bref) ! = a&#94;2*Bref/(2*rho)/|psi_LCFS| * sqrt(grad_psi_grad_psi) ! = 1/rho * sqrt(grad_psi_grad_psi) grho = sqrt ( grad_psi_grad_psi ) / surf % rhotor ! grho = |grad rho| = |drho/dx| * |grad x| ! |drho/dx| = L_reference ! gds22 = shat&#94;2 * |grad x|&#94;2 !    grho = sqrt(gds22/surf%shat**2)/L_reference surf % drhotordrho = 1.0 surf % psitor_lcfs = 0.5 * sign_torflux ! this is zeta0 that appears everywhere in tandem with zeta-zeta0 ! converted to the zed coordinate (which is possibly arc-length ! and is compressed to fit on the range -pi,pi) surf % zed0_fac = - zed ( nzgrid ) / zeta ( 1 , nzgrid ) * surf % qinp ! scale the vmec output ! alpha = theta_pest - iota*zeta ! theta_pest = theta_vmec + Lambda(psi,alpha,theta_vmec) ! with theta_pest a straight-field-line angle ! but not theta_vmec ! so theta is theta_pest up to constant (alpha) !    theta = zeta/nfp/surf%qinp theta = spread ( alpha , 2 , 2 * nzgrid + 1 ) + zeta / surf % qinp ! this is the vmec theta (not straight-field-line coordinate) ! scaled to run between -pi and pi theta_vmec = theta_vmec / nfp call open_output_file ( tmpunit , '.vmec.geo' ) write ( tmpunit , '(6a12)' ) '#rhotor' , 'qinp' , 'shat' , 'aref' , 'Bref' , 'z_scalefac' write ( tmpunit , '(6e12.4)' ) surf % rhoc , surf % qinp , surf % shat , L_reference , B_reference , zed_scalefac write ( tmpunit , '(17a12)' ) '#    alpha' , 'zeta' , 'bmag' , 'gradpar' , 'bdot_grad_z' , 'grad_alpha2' , & 'gd_alph_psi' , 'grad_psi2' , 'gds23' , 'gds24' , 'gbdriftalph' , 'gbdrift0psi' , 'cvdriftalph' , & 'cvdrift0psi' , 'theta_vmec' , 'B_sub_theta' , 'B_sub_zeta' ! JFP adding B_poloidal and B_toroidal Apr21 do j = - nzgrid , nzgrid do i = 1 , nalpha write ( tmpunit , '(17e12.4)' ) alpha ( i ), zeta ( i , j ), bmag ( i , j ), gradpar ( j ), b_dot_grad_z ( i , j ), & grad_alpha_grad_alpha ( i , j ), grad_alpha_grad_psi ( i , j ), grad_psi_grad_psi ( i , j ), & gds23 ( i , j ), gds24 ( i , j ), & gbdrift_alpha ( i , j ), gbdrift0_psi ( i , j ), cvdrift_alpha ( i , j ), cvdrift0_psi ( i , j ), theta_vmec ( i , j ), B_sub_theta_vmec ( i , j ), B_sub_zeta ( i , j ) ! JFP end do write ( tmpunit , * ) end do close ( tmpunit ) end subroutine get_vmec_geo subroutine filter_geo_coef ( naky , geocoef ) use stella_transforms , only : transform_alpha2kalpha , transform_kalpha2alpha implicit none integer , intent ( in ) :: naky real , dimension (:), intent ( in out ) :: geocoef complex , dimension (:), allocatable :: fourier allocate ( fourier ( naky )) ! filtering and padding are built-in to the ! Fourier transform routines below call transform_alpha2kalpha ( geocoef , fourier ) call transform_kalpha2alpha ( fourier , geocoef ) deallocate ( fourier ) end subroutine filter_geo_coef subroutine get_modified_vmec_zeta_grid ( new_zeta_min , stellarator_symmetric_BC , nzgrid_modified , dzeta_modified ) use zgrid , only : nzgrid use vmec_to_stella_geometry_interface_mod , only : get_nominal_vmec_zeta_grid implicit none logical , intent ( in ) :: stellarator_symmetric_BC real , intent ( in ) :: new_zeta_min integer , intent ( out ) :: nzgrid_modified integer :: nzgrid_excess real :: nfield_periods_device real :: zeta_max , excess_zeta real :: tmp , dzeta , dzeta_modified real , dimension (:), allocatable :: zeta !> need to extend the maximum and minimum zeta values !> by zgrid_scalefac to ensure that we have information !> about geometric coefficients everywhere on a fixed !> equal-arc grid in zed !> first figure out how many extra zeta grid points are !> required at the nominal grid spacing to get out !> to the ends of the extended zeta domain !> first calculate the nominal zeta grid used for vmec if (. not . allocated ( zeta )) allocate ( zeta ( - nzgrid : nzgrid )) !> note that nfield_periods is the number of field periods !> sampled in stella, while nfield_periods_device !> is the number of field periods in the device !> nfield_periods may be reasonably bigger than nfield_periods_device !> as the former is sampled while keeping alpha fixed (rather than theta) call get_nominal_vmec_zeta_grid ( new_zeta_min , stellarator_symmetric_BC , nzgrid , zeta_center , & nfield_periods , nfield_periods_device , zeta ) !> maximum zeta value for nominal zeta grid zeta_max = zeta ( nzgrid ) !> excess_zeta is difference between expanded zeta_max and nominal zeta_max excess_zeta = zeta_max * ( zgrid_scalefac - 1.0 ) !> assumes equal grid spacing in zeta dzeta = zeta ( 1 ) - zeta ( 0 ) tmp = excess_zeta / dzeta !> nzgrid_excess is the number of additional zeta grid points needed to !> cover at least excess_zeta if ( abs ( tmp - nint ( tmp )) < 0.1 ) then nzgrid_excess = nint ( tmp ) else nzgrid_excess = nint ( tmp ) + 1 end if !> now refine the zeta grid by desired amount in !> preparation for interpolation nzgrid_modified = ( nzgrid + nzgrid_excess ) * zgrid_refinement_factor dzeta_modified = dzeta / real ( zgrid_refinement_factor ) if ( allocated ( zeta )) deallocate ( zeta ) end subroutine get_modified_vmec_zeta_grid end module vmec_geo","tags":"","loc":"sourcefile/vmec_geo.f90.html"},{"title":"dist_fn_arrays.f90 – stella","text":"Source Code !> A container for the arrays that are used to store the distribution function among other things. !!  These need to be accessible at a lower dependency level than the dist_fn module itself. !! These arrays are allocated in the function dist_fn::allocate_arrays. module dist_fn_arrays public :: gnew , gold , g_symm , g_scratch public :: g0 , g1 , g2 , g3 public :: g_krook , g_proj public :: gvmu public :: kperp2 , dkperp2dr public :: wstar , wstarp public :: wdriftx_g , wdrifty_g public :: wdriftx_phi , wdrifty_phi public :: wdriftx_bpar , wdrifty_bpar public :: wdriftpx_g , wdriftpy_g public :: wdriftpx_phi , wdriftpy_phi ! dist fn complex , dimension (:, :, :, :, :), allocatable :: gnew , gold , g_scratch ! (naky, nakx, -nzgrid:nzgrid, ntubes, -vmu-layout-) complex , dimension (:, :, :, :, :), target , allocatable :: g_symm ! (naky, nakx, -nzgrid:nzgrid, ntubes, -vmu-layout-) complex , dimension (:, :, :, :, :), allocatable :: g0 , g1 , g2 , g3 ! (naky, nakx, -nzgrid:nzgrid, ntubes, -vmu-layout-) ! needed to implement time-delayed source when using Krook operator complex , dimension (:, :, :, :), allocatable :: g_krook ! (nakx, -nzgrid:nzgrid, ntubes, -vmu-layout-) ! needed to implement time-delayed source when using projection method complex , dimension (:, :, :, :), allocatable :: g_proj ! (nakx, -nzgrid:nzgrid, ntubes, -vmu-layout-) complex , dimension (:, :, :), allocatable :: gvmu ! (nvpa, nmu, -kxkyz-layout-) real , dimension (:, :, :), allocatable :: wstar , wstarp ! (nalpha, -nzgrid:nzgrid, -vmu-layout-) real , dimension (:, :, :), allocatable :: wdriftx_g , wdrifty_g real , dimension (:, :, :), allocatable :: wdriftx_phi , wdrifty_phi real , dimension (:, :, :), allocatable :: wdriftx_bpar , wdrifty_bpar real , dimension (:, :, :), allocatable :: wdriftpx_g , wdriftpy_g real , dimension (:, :, :), allocatable :: wdriftpx_phi , wdriftpy_phi ! (nalpha, -nzgrid:nzgrid, -vmu-layout-) !> dkperp2dr will contain the radial variation of kperp2 real , dimension (:, :, :, :), allocatable :: kperp2 , dkperp2dr ! (naky, nakx, nalpha, -nzgrid:nzgrid) ! note: dkperp2dr is divided by kperp2 end module dist_fn_arrays","tags":"","loc":"sourcefile/dist_fn_arrays.f90.html"},{"title":"fields.fpp – stella","text":"Source Code module fields use common_types , only : eigen_type use mpi use common_types , only : coupled_alpha_type , gam0_ffs_type implicit none public :: init_fields , finish_fields public :: advance_fields , get_fields public :: advance_apar public :: get_radial_correction public :: enforce_reality_field public :: rescale_fields public :: get_fields_by_spec , get_fields_by_spec_idx public :: gamtot_h , gamtot3_h public :: apar_denom public :: time_field_solve public :: fields_updated public :: get_dchidy , get_dchidx public :: efac , efacp public :: nfields private real , dimension (:, :, :), allocatable :: apar_denom real :: gamtot_h , gamtot3_h , efac , efacp !> arrays allocated/used if simulating a full flux surface type ( coupled_alpha_type ), dimension (:, :, :), allocatable :: gam0_ffs type ( gam0_ffs_type ), dimension (:, :), allocatable :: lu_gam0_ffs complex , dimension (:), allocatable :: adiabatic_response_factor logical :: fields_updated = . false . logical :: fields_initialized = . false . #ifdef ISO_C_BINDING integer :: phi_shared_window = MPI_WIN_NULL #endif logical :: debug = . false . integer :: zm integer :: nfields real , dimension ( 2 , 5 ) :: time_field_solve = 0. interface get_dchidy module procedure get_dchidy_4d module procedure get_dchidy_2d end interface get_dchidy interface advance_fields module procedure advance_fields_vmu_lo module procedure advance_fields_kxkyz_lo end interface advance_fields contains subroutine init_fields use mp , only : proc0 use linear_solve , only : lu_decomposition use physics_flags , only : full_flux_surface use physics_flags , only : include_apar , include_bpar implicit none debug = debug . and . proc0 if ( full_flux_surface ) then call init_fields_ffs else call init_fields_fluxtube end if nfields = 1 if ( include_apar ) nfields = nfields + 1 if ( include_bpar ) nfields = nfields + 1 end subroutine init_fields !> @todo would be tidier if the code related to radial profile variation !> were gathered into a separate subroutine or subroutines !> init_fields_fluxtube allocates and fills arrays needed during main time advance !> loop for the field solve for flux tube simulations subroutine init_fields_fluxtube use mp , only : sum_allreduce use stella_layouts , only : kxkyz_lo use stella_layouts , onlY : iz_idx , it_idx , ikx_idx , iky_idx , is_idx use dist_fn_arrays , only : kperp2 , dkperp2dr use gyro_averages , only : aj0v , aj1v use run_parameters , only : fphi use run_parameters , only : ky_solve_radial use run_parameters , only : maxwellian_normalization use physics_parameters , only : tite , nine , beta use physics_flags , only : radial_variation use species , only : spec , has_electron_species , ion_species use stella_geometry , only : dl_over_b , dBdrho , bmag use zgrid , only : nzgrid use vpamu_grids , only : nvpa , nmu , mu use vpamu_grids , only : vpa , vperp2 use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use vpamu_grids , only : integrate_vmu use species , only : spec use kt_grids , only : naky , nakx , akx use kt_grids , only : zonal_mode use physics_flags , only : include_apar , include_bpar use physics_flags , only : adiabatic_option_switch use physics_flags , only : adiabatic_option_fieldlineavg use fields_arrays , only : gamtot , dgamtotdr , gamtot3 use fields_arrays , only : gamtot13 , gamtot31 , gamtot33 use fields_arrays , only : gamtotinv11 , gamtotinv13 , gamtotinv31 , gamtotinv33 implicit none integer :: ikxkyz , iz , it , ikx , iky , is , ia real :: tmp , wgt , denom_tmp real , dimension (:, :), allocatable :: g0 real , dimension (:), allocatable :: g1 ia = 1 zm = 0 ! do not see why this is before fields_initialized check below call allocate_arrays if ( fields_initialized ) return fields_initialized = . true . ! could move these array allocations to allocate_arrays to clean up code if (. not . allocated ( gamtot )) allocate ( gamtot ( naky , nakx , - nzgrid : nzgrid )); gamtot = 0. if (. not . allocated ( gamtot3 )) then if (. not . has_electron_species ( spec ) & . and . adiabatic_option_switch == adiabatic_option_fieldlineavg ) then allocate ( gamtot3 ( nakx , - nzgrid : nzgrid )); gamtot3 = 0. else allocate ( gamtot3 ( 1 , 1 )); gamtot3 = 0. end if end if if (. not . allocated ( apar_denom )) then if ( include_apar ) then allocate ( apar_denom ( naky , nakx , - nzgrid : nzgrid )); apar_denom = 0. else allocate ( apar_denom ( 1 , 1 , 1 )); apar_denom = 0. end if end if if (. not . allocated ( gamtot33 )) then if ( include_bpar ) then allocate ( gamtot33 ( naky , nakx , - nzgrid : nzgrid )); gamtot33 = 0. else allocate ( gamtot33 ( 1 , 1 , 1 )); gamtot33 = 0. end if end if ! gamtot13 and gamtot31 required if include_bpar = .true. if (. not . allocated ( gamtot13 )) then if ( include_bpar ) then allocate ( gamtot13 ( naky , nakx , - nzgrid : nzgrid )); gamtot13 = 0. else allocate ( gamtot13 ( 1 , 1 , 1 )); gamtot13 = 0. end if end if if (. not . allocated ( gamtot31 )) then if ( include_bpar ) then allocate ( gamtot31 ( naky , nakx , - nzgrid : nzgrid )); gamtot31 = 0. else allocate ( gamtot31 ( 1 , 1 , 1 )); gamtot31 = 0. end if end if if (. not . allocated ( gamtotinv11 )) then if ( include_bpar ) then allocate ( gamtotinv11 ( naky , nakx , - nzgrid : nzgrid )); gamtotinv11 = 0. else allocate ( gamtotinv11 ( 1 , 1 , 1 )); gamtotinv11 = 0. end if end if if (. not . allocated ( gamtotinv31 )) then if ( include_bpar ) then allocate ( gamtotinv31 ( naky , nakx , - nzgrid : nzgrid )); gamtotinv31 = 0. else allocate ( gamtotinv31 ( 1 , 1 , 1 )); gamtotinv31 = 0. end if end if if (. not . allocated ( gamtotinv13 )) then if ( include_bpar ) then allocate ( gamtotinv13 ( naky , nakx , - nzgrid : nzgrid )); gamtotinv13 = 0. else allocate ( gamtotinv13 ( 1 , 1 , 1 )); gamtotinv13 = 0. end if end if if (. not . allocated ( gamtotinv33 )) then if ( include_bpar ) then allocate ( gamtotinv33 ( naky , nakx , - nzgrid : nzgrid )); gamtotinv33 = 0. else allocate ( gamtotinv33 ( 1 , 1 , 1 )); gamtotinv31 = 0. end if end if if ( radial_variation ) then if (. not . allocated ( dgamtotdr )) allocate ( dgamtotdr ( naky , nakx , - nzgrid : nzgrid )); dgamtotdr = 0. else if (. not . allocated ( dgamtotdr )) allocate ( dgamtotdr ( 1 , 1 , 1 )); dgamtotdr = 0. end if if ( fphi > epsilon ( 0.0 )) then allocate ( g0 ( nvpa , nmu )) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc it = it_idx ( kxkyz_lo , ikxkyz ) ! gamtot does not depend on flux tube index, ! so only compute for one flux tube index if ( it /= 1 ) cycle iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) g0 = spread (( 1.0 - aj0v (:, ikxkyz ) ** 2 ), 1 , nvpa ) if (. not . maxwellian_normalization ) then g0 = g0 * spread ( maxwell_vpa (:, is ), 2 , nmu ) * spread ( maxwell_mu ( ia , iz , :, is ), 1 , nvpa ) * maxwell_fac ( is ) end if wgt = spec ( is )% z * spec ( is )% z * spec ( is )% dens_psi0 / spec ( is )% temp call integrate_vmu ( g0 , iz , tmp ) gamtot ( iky , ikx , iz ) = gamtot ( iky , ikx , iz ) + tmp * wgt end do call sum_allreduce ( gamtot ) gamtot_h = sum ( spec % z * spec % z * spec % dens / spec % temp ) if ( radial_variation ) then allocate ( g1 ( nmu )) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc it = it_idx ( kxkyz_lo , ikxkyz ) ! gamtot does not depend on flux tube index, ! so only compute for one flux tube index if ( it /= 1 ) cycle iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) g1 = aj0v (:, ikxkyz ) * aj1v (:, ikxkyz ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 ( iky , ikx , ia , iz ) * vperp2 ( ia , iz , :) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr ( iky , ikx , ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) & / ( 1.0 - aj0v (:, ikxkyz ) ** 2 + 10 0. * epsilon ( 0.0 )) g0 = spread (( 1.0 - aj0v (:, ikxkyz ) ** 2 ), 1 , nvpa ) & * spread ( maxwell_vpa (:, is ), 2 , nmu ) * spread ( maxwell_mu ( ia , iz , :, is ), 1 , nvpa ) * maxwell_fac ( is ) & * ( - spec ( is )% tprim * ( spread ( vpa ** 2 , 2 , nmu ) + spread ( vperp2 ( ia , iz , :), 1 , nvpa ) - 2.5 ) & - spec ( is )% fprim + ( dBdrho ( iz ) / bmag ( ia , iz )) * ( 1.0 - 2.0 * spread ( mu , 1 , nvpa ) * bmag ( ia , iz )) & + spread ( g1 , 1 , nvpa )) wgt = spec ( is )% z * spec ( is )% z * spec ( is )% dens / spec ( is )% temp call integrate_vmu ( g0 , iz , tmp ) dgamtotdr ( iky , ikx , iz ) = dgamtotdr ( iky , ikx , iz ) + tmp * wgt end do call sum_allreduce ( dgamtotdr ) deallocate ( g1 ) end if ! avoid divide by zero when kx=ky=0 ! do not evolve this mode, so value is irrelevant if ( zonal_mode ( 1 ) . and . akx ( 1 ) < epsilon ( 0. ) . and . has_electron_species ( spec )) then gamtot ( 1 , 1 , :) = 0.0 dgamtotdr ( 1 , 1 , :) = 0.0 zm = 1 end if if (. not . has_electron_species ( spec )) then efac = tite / nine * ( spec ( ion_species )% dens / spec ( ion_species )% temp ) efacp = efac * ( spec ( ion_species )% tprim - spec ( ion_species )% fprim ) gamtot = gamtot + efac gamtot_h = gamtot_h + efac if ( radial_variation ) dgamtotdr = dgamtotdr + efacp if ( adiabatic_option_switch == adiabatic_option_fieldlineavg ) then if ( zonal_mode ( 1 )) then gamtot3_h = efac / ( sum ( spec % zt * spec % z * spec % dens )) do ikx = 1 , nakx ! avoid divide by zero for kx=ky=0 mode, ! which we do not need anyway !if (abs(akx(ikx)) < epsilon(0.)) cycle tmp = 1. / efac - sum ( dl_over_b ( ia , :) / gamtot ( 1 , ikx , :)) gamtot3 ( ikx , :) = 1. / ( gamtot ( 1 , ikx , :) * tmp ) end do if ( akx ( 1 ) < epsilon ( 0. )) then gamtot3 ( 1 , :) = 0.0 end if end if end if end if deallocate ( g0 ) if ( radial_variation . and . ky_solve_radial > 0 ) call init_radial_field_solve end if if ( include_apar ) then allocate ( g0 ( nvpa , nmu )) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc it = it_idx ( kxkyz_lo , ikxkyz ) ! apar_denom does not depend on flux tube index, ! so only compute for one flux tube index if ( it /= 1 ) cycle iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) g0 = spread ( maxwell_vpa (:, is ) * vpa ** 2 , 2 , nmu ) * maxwell_fac ( is ) & * spread ( maxwell_mu ( ia , iz , :, is ) * aj0v (:, ikxkyz ) ** 2 , 1 , nvpa ) wgt = 2.0 * beta * spec ( is )% z * spec ( is )% z * spec ( is )% dens / spec ( is )% mass call integrate_vmu ( g0 , iz , tmp ) apar_denom ( iky , ikx , iz ) = apar_denom ( iky , ikx , iz ) + tmp * wgt end do call sum_allreduce ( apar_denom ) apar_denom = apar_denom + kperp2 (:, :, ia , :) deallocate ( g0 ) end if if ( include_bpar ) then ! gamtot33 allocate ( g0 ( nvpa , nmu )) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc it = it_idx ( kxkyz_lo , ikxkyz ) ! gamtot33 does not depend on flux tube index, ! so only compute for one flux tube index ! gamtot33 = 1 + 8 * beta * sum_s (n*T* integrate_vmu(mu*mu*exp(-v&#94;2) *(J1/gamma)*(J1/gamma))) if ( it /= 1 ) cycle iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) g0 = spread (( mu (:) * mu (:) * aj1v (:, ikxkyz ) * aj1v (:, ikxkyz )), 1 , nvpa ) & * spread ( maxwell_vpa (:, is ), 2 , nmu ) * spread ( maxwell_mu ( ia , iz , :, is ), 1 , nvpa ) * maxwell_fac ( is ) wgt = 8.0 * spec ( is )% temp * spec ( is )% dens_psi0 call integrate_vmu ( g0 , iz , tmp ) gamtot33 ( iky , ikx , iz ) = gamtot33 ( iky , ikx , iz ) + tmp * wgt end do call sum_allreduce ( gamtot33 ) gamtot33 = 1.0 + beta * gamtot33 !gamtot13 do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc it = it_idx ( kxkyz_lo , ikxkyz ) ! gamtot13 does not depend on flux tube index, ! so only compute for one flux tube index ! gamtot13 = -4 * sum_s (Z*n* integrate_vmu(mu*exp(-v&#94;2) * J0 *J1/gamma)) if ( it /= 1 ) cycle iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) g0 = spread (( mu (:) * aj0v (:, ikxkyz ) * aj1v (:, ikxkyz )), 1 , nvpa ) & * spread ( maxwell_vpa (:, is ), 2 , nmu ) * spread ( maxwell_mu ( ia , iz , :, is ), 1 , nvpa ) * maxwell_fac ( is ) wgt = - 4.0 * spec ( is )% z * spec ( is )% dens_psi0 call integrate_vmu ( g0 , iz , tmp ) gamtot13 ( iky , ikx , iz ) = gamtot13 ( iky , ikx , iz ) + tmp * wgt end do call sum_allreduce ( gamtot13 ) ! gamtot31 = 2 * beta * sum_s (Z*n* integrate_vmu(mu*exp(-v&#94;2) * J0 *J1/gamma)) !          = -(gamtot13 / 2) * beta gamtot31 = - 0.5 * beta * gamtot13 deallocate ( g0 ) end if if ( fphi > epsilon ( 0.0 ) . and . include_bpar ) then !> compute coefficients for even part of field solve (phi, bpar) do iz =- nzgrid , nzgrid do ikx = 1 , nakx do iky = 1 , naky !> gamtotinv11 denom_tmp = gamtot ( iky , ikx , iz ) - (( gamtot13 ( iky , ikx , iz ) * gamtot31 ( iky , ikx , iz )) / gamtot33 ( iky , ikx , iz )) if ( denom_tmp < epsilon ( 0.0 )) then gamtotinv11 ( iky , ikx , iz ) = 0.0 else gamtotinv11 ( iky , ikx , iz ) = 1.0 / denom_tmp end if !> gamtotinv13, gamtotinv31, gamtotinv33 denom_tmp = gamtot ( iky , ikx , iz ) * gamtot33 ( iky , ikx , iz ) - gamtot13 ( iky , ikx , iz ) * gamtot31 ( iky , ikx , iz ) if ( denom_tmp < epsilon ( 0.0 )) then gamtotinv13 ( iky , ikx , iz ) = 0.0 gamtotinv31 ( iky , ikx , iz ) = 0.0 gamtotinv33 ( iky , ikx , iz ) = 0.0 else gamtotinv13 ( iky , ikx , iz ) = - gamtot13 ( iky , ikx , iz ) / denom_tmp gamtotinv33 ( iky , ikx , iz ) = gamtot ( iky , ikx , iz ) / denom_tmp gamtotinv31 ( iky , ikx , iz ) = - gamtot31 ( iky , ikx , iz ) / denom_tmp end if end do end do end do end if end subroutine init_fields_fluxtube subroutine init_radial_field_solve use mp , only : job #ifdef ISO_C_BINDING use , intrinsic :: iso_c_binding , only : c_ptr , c_f_pointer , c_intptr_t use fields_arrays , only : qn_window , phi_shared use mp , only : sgproc0 , curr_focus , sharedsubprocs use mp , only : scope , real_size , nbytes_real use mp , only : split_n_tasks , create_shared_memory_window use mpi #endif use run_parameters , only : ky_solve_radial , ky_solve_real use species , only : spec , has_electron_species use stella_transforms , only : transform_kx2x_unpadded , transform_x2kx_unpadded use zgrid , only : nzgrid , ntubes , nztot use species , only : spec use kt_grids , only : naky , nakx use kt_grids , only : zonal_mode , rho_d_clamped use physics_flags , only : adiabatic_option_switch use physics_flags , only : adiabatic_option_fieldlineavg use linear_solve , only : lu_decomposition , lu_inverse use multibox , only : init_mb_get_phi use fields_arrays , only : gamtot , dgamtotdr use fields_arrays , only : phi_solve , c_mat , theta use file_utils , only : runtype_option_switch , runtype_multibox implicit none integer :: iz , ikx , iky , ia , zmi , naky_r real :: dum logical :: has_elec , adia_elec #ifdef ISO_C_BINDING integer :: prior_focus , ierr integer :: counter , c_lo , c_hi integer ( c_intptr_t ) :: cur_pos integer ( kind = MPI_ADDRESS_KIND ) :: win_size complex , dimension (:), pointer :: phi_shared_temp type ( c_ptr ) :: cptr #endif complex , dimension (:, :), allocatable :: g0k , g0x ia = 1 naky_r = min ( naky , ky_solve_radial ) has_elec = has_electron_species ( spec ) adia_elec = . not . has_elec . and . zonal_mode ( 1 ) & . and . adiabatic_option_switch == adiabatic_option_fieldlineavg if ( runtype_option_switch == runtype_multibox . and . job == 1 . and . ky_solve_real ) then call init_mb_get_phi ( has_elec , adia_elec , efac , efacp ) elseif ( runtype_option_switch /= runtype_multibox . or . ( job == 1 . and . . not . ky_solve_real )) then allocate ( g0k ( 1 , nakx )) allocate ( g0x ( 1 , nakx )) if (. not . allocated ( phi_solve )) allocate ( phi_solve ( naky_r , - nzgrid : nzgrid )) #ifdef ISO_C_BINDING prior_focus = curr_focus call scope ( sharedsubprocs ) !the following is to parallelize the calculation of QN for radial variation sims if ( debug ) write ( * , * ) 'fields::init_fields::phi_shared_init' if ( phi_shared_window == MPI_WIN_NULL ) then win_size = 0 if ( sgproc0 ) then win_size = int ( naky * nakx * nztot * ntubes , MPI_ADDRESS_KIND ) * 2 * real_size !complex size end if call create_shared_memory_window ( win_size , phi_shared_window , cur_pos ) cptr = transfer ( cur_pos , cptr ) if (. not . associated ( phi_shared )) then ! associate array with lower bounds of 1 call c_f_pointer ( cptr , phi_shared_temp , ( / naky * nakx * nztot * ntubes / )) ! now get the correct bounds phi_shared ( 1 : naky , 1 : nakx , - nzgrid : nzgrid , 1 : ntubes ) => phi_shared_temp end if call mpi_win_fence ( 0 , phi_shared_window , ierr ) end if if ( debug ) write ( * , * ) 'fields::init_fields::qn_window_init' if ( qn_window == MPI_WIN_NULL ) then win_size = 0 if ( sgproc0 ) then win_size = int ( nakx * nztot * naky_r , MPI_ADDRESS_KIND ) * 4_MPI_ADDRESS_KIND & + int ( nakx ** 2 * nztot * naky_r , MPI_ADDRESS_KIND ) * 2 * real_size !complex size end if call create_shared_memory_window ( win_size , qn_window , cur_pos ) !allocate the memory do iky = 1 , naky_r zmi = 0 if ( iky == 1 ) zmi = zm !zero mode may or may not be included in matrix do iz = - nzgrid , nzgrid if (. not . associated ( phi_solve ( iky , iz )% zloc )) then allocate ( phi_solve ( iky , iz )% zloc ( nakx - zmi , nakx - zmi )) cptr = transfer ( cur_pos , cptr ) call c_f_pointer ( cptr , phi_solve ( iky , iz )% zloc , ( / nakx - zmi , nakx - zmi / )) end if cur_pos = cur_pos + ( nakx - zmi ) ** 2 * 2 * nbytes_real if (. not . associated ( phi_solve ( iky , iz )% idx )) then cptr = transfer ( cur_pos , cptr ) call c_f_pointer ( cptr , phi_solve ( iky , iz )% idx , ( / nakx - zmi / )) end if cur_pos = cur_pos + ( nakx - zmi ) * 4 end do end do call mpi_win_fence ( 0 , qn_window , ierr ) end if call split_n_tasks ( nztot * naky_r , c_lo , c_hi ) call scope ( prior_focus ) counter = 0 #else do iky = 1 , naky_r zmi = 0 if ( iky == 1 ) zmi = zm !zero mode may or may not be included in matrix do iz = - nzgrid , nzgrid if (. not . associated ( phi_solve ( iky , iz )% zloc )) & allocate ( phi_solve ( iky , iz )% zloc ( nakx - zmi , nakx - zmi )) if (. not . associated ( phi_solve ( iky , iz )% idx )) & allocate ( phi_solve ( iky , iz )% idx ( nakx - zmi )) end do end do #endif do iky = 1 , naky_r zmi = 0 if ( iky == 1 ) zmi = zm !zero mode may or may not be included in matrix do iz = - nzgrid , nzgrid #ifdef ISO_C_BINDING counter = counter + 1 if (( counter >= c_lo ) . and . ( counter <= c_hi )) then #endif phi_solve ( iky , iz )% zloc = 0.0 phi_solve ( iky , iz )% idx = 0 do ikx = 1 + zmi , nakx g0k ( 1 , :) = 0.0 g0k ( 1 , ikx ) = dgamtotdr ( iky , ikx , iz ) call transform_kx2x_unpadded ( g0k , g0x ) g0x ( 1 , :) = rho_d_clamped * g0x ( 1 , :) call transform_x2kx_unpadded ( g0x , g0k ) !row column phi_solve ( iky , iz )% zloc (:, ikx - zmi ) = g0k ( 1 , ( 1 + zmi ):) phi_solve ( iky , iz )% zloc ( ikx - zmi , ikx - zmi ) = phi_solve ( iky , iz )% zloc ( ikx - zmi , ikx - zmi ) & + gamtot ( iky , ikx , iz ) end do call lu_decomposition ( phi_solve ( iky , iz )% zloc , phi_solve ( iky , iz )% idx , dum ) #ifdef ISO_C_BINDING end if #endif end do end do if ( adia_elec ) then if (. not . allocated ( c_mat )) allocate ( c_mat ( nakx , nakx )); if (. not . allocated ( theta )) allocate ( theta ( nakx , nakx , - nzgrid : nzgrid )); !get C do ikx = 1 , nakx g0k ( 1 , :) = 0.0 g0k ( 1 , ikx ) = 1.0 call transform_kx2x_unpadded ( g0k , g0x ) g0x ( 1 , :) = ( efac + efacp * rho_d_clamped ) * g0x ( 1 , :) call transform_x2kx_unpadded ( g0x , g0k ) !row column c_mat (:, ikx ) = g0k ( 1 , :) end do !get Theta do iz = - nzgrid , nzgrid !get Theta do ikx = 1 , nakx g0k ( 1 , :) = 0.0 g0k ( 1 , ikx ) = dgamtotdr ( 1 , ikx , iz ) - efacp call transform_kx2x_unpadded ( g0k , g0x ) g0x ( 1 , :) = rho_d_clamped * g0x ( 1 , :) call transform_x2kx_unpadded ( g0x , g0k ) !row column theta (:, ikx , iz ) = g0k ( 1 , :) theta ( ikx , ikx , iz ) = theta ( ikx , ikx , iz ) + gamtot ( 1 , ikx , iz ) - efac end do end do end if deallocate ( g0k , g0x ) end if end subroutine init_radial_field_solve !> init_fields_ffs allocates and fills arrays needed during main time advance !> loop for the field solve for full_flux_surface simulations subroutine init_fields_ffs use species , only : modified_adiabatic_electrons implicit none if ( fields_initialized ) return fields_initialized = . true . !> allocate arrays such as phi that are needed !> throughout the simulation call allocate_arrays !> calculate and LU factorise the matrix multiplying the electrostatic potential in quasineutrality !> this involves the factor 1-Gamma_0(kperp(alpha)) call init_gamma0_factor_ffs !> if using a modified Boltzmann response for the electrons if ( modified_adiabatic_electrons ) then !> obtain the response of phi_homogeneous to a unit perturbation in flux-surface-averaged phi call init_adiabatic_response_factor end if end subroutine init_fields_ffs !> calculate and LU factorise the matrix multiplying the electrostatic potential in quasineutrality !> this involves the factor 1-Gamma_0(kperp(alpha)) subroutine init_gamma0_factor_ffs use spfunc , only : j0 use dist_fn_arrays , only : kperp2 use stella_transforms , only : transform_alpha2kalpha use physics_parameters , only : nine , tite use species , only : spec , nspec use species , only : adiabatic_electrons use zgrid , only : nzgrid use stella_geometry , only : bmag use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx , imu_idx , is_idx use kt_grids , only : nalpha , ikx_max , naky_all , naky use kt_grids , only : swap_kxky_ordered use vpamu_grids , only : vperp2 use vpamu_grids , only : integrate_species use gyro_averages , only : band_lu_factorisation_ffs implicit none integer :: iky , ikx , iz , ia integer :: ivmu , iv , imu , is real :: arg real , dimension (:, :, :), allocatable :: kperp2_swap real , dimension (:), allocatable :: aj0_alpha , gam0_alpha real , dimension (:), allocatable :: wgts complex , dimension (:), allocatable :: gam0_kalpha if ( debug ) write ( * , * ) 'fields::init_fields::init_gamm0_factor_ffs' allocate ( kperp2_swap ( naky_all , ikx_max , nalpha )) allocate ( aj0_alpha ( vmu_lo % llim_proc : vmu_lo % ulim_alloc )) allocate ( gam0_alpha ( nalpha )) allocate ( gam0_kalpha ( naky )) !> wgts are species-dependent factors appearing in Gamma0 factor allocate ( wgts ( nspec )) wgts = spec % dens * spec % z ** 2 / spec % temp !> allocate gam0_ffs array, which will contain the Fourier coefficients in y !> of the Gamma0 factor that appears in quasineutrality if (. not . allocated ( gam0_ffs )) then allocate ( gam0_ffs ( naky_all , ikx_max , - nzgrid : nzgrid )) end if do iz = - nzgrid , nzgrid !> in calculating the Fourier coefficients for Gamma_0, change loop orders !> so that inner loop is over ivmu super-index; !> this is done because we must integrate over v-space and sum over species, !> and we want to minimise memory usage where possible (so, e.g., aj0_alpha need !> only be a function of ivmu and can be over-written for each (ia,iky,ikx)). do ia = 1 , nalpha call swap_kxky_ordered ( kperp2 (:, :, ia , iz ), kperp2_swap (:, :, ia )) end do do ikx = 1 , ikx_max do iky = 1 , naky_all do ia = 1 , nalpha !> get J0 for all vpar, mu, spec values do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) iv = iv_idx ( vmu_lo , ivmu ) !> calculate the argument of the Bessel function J0 arg = spec ( is )% bess_fac * spec ( is )% smz_psi0 * sqrt ( vperp2 ( ia , iz , imu ) * kperp2_swap ( iky , ikx , ia )) / bmag ( ia , iz ) !> compute J0 corresponding to the given argument arg aj0_alpha ( ivmu ) = j0 ( arg ) !> form coefficient needed to calculate 1-Gamma_0 aj0_alpha ( ivmu ) = ( 1.0 - aj0_alpha ( ivmu ) ** 2 ) end do !> calculate gamma0(kalpha,alpha,...) = sum_s Zs&#94;2 * ns / Ts int d3v (1-J0&#94;2)*F_{Maxwellian} !> note that v-space Jacobian contains alpha-dependent factor, B(z,alpha), !> but this is not a problem as we have yet to transform from alpha to k_alpha call integrate_species ( aj0_alpha , iz , wgts , gam0_alpha ( ia ), ia ) !> if Boltzmann response used, account for non-flux-surface-averaged component of electron density if ( adiabatic_electrons ) then gam0_alpha ( ia ) = gam0_alpha ( ia ) + tite / nine else if ( ikx == 1 . and . iky == naky ) then !> if kx = ky = 0, 1-Gam0 factor is zero; !> this leads to eqn of form 0 * phi_00 = int d3v g. !> hack for now is to set phi_00 = 0, as above inversion is singular. !> to avoid singular inversion, set gam0_alpha = 1.0 gam0_alpha ( ia ) = 1.0 end if end do !> fourier transform Gamma_0(alpha) from alpha to k_alpha space call transform_alpha2kalpha ( gam0_alpha , gam0_kalpha ) gam0_ffs ( iky , ikx , iz )% max_idx = naky !> allocate array to hold the Fourier coefficients if (. not . associated ( gam0_ffs ( iky , ikx , iz )% fourier )) & allocate ( gam0_ffs ( iky , ikx , iz )% fourier ( gam0_ffs ( iky , ikx , iz )% max_idx )) !> fill the array with the requisite coefficients gam0_ffs ( iky , ikx , iz )% fourier = gam0_kalpha (: gam0_ffs ( iky , ikx , iz )% max_idx ) !                call test_ffs_bessel_coefs (gam0_ffs(iky,ikx,iz)%fourier, gam0_alpha, iky, ikx, iz, gam0_ffs_unit) end do end do end do !> LU factorise array of gam0, using the LAPACK zgbtrf routine for banded matrices if (. not . allocated ( lu_gam0_ffs )) then allocate ( lu_gam0_ffs ( ikx_max , - nzgrid : nzgrid )) !          call test_band_lu_factorisation (gam0_ffs, lu_gam0_ffs) call band_lu_factorisation_ffs ( gam0_ffs , lu_gam0_ffs ) end if deallocate ( wgts ) deallocate ( kperp2_swap ) deallocate ( aj0_alpha , gam0_alpha ) deallocate ( gam0_kalpha ) end subroutine init_gamma0_factor_ffs !> solves Delta * phi_hom = -delta_{ky,0} * ne/Te for phi_hom !> this is the vector describing the response of phi_hom to a unit impulse in phi_fsa !> it is the sum over ky and integral over kx of this that is needed, and this !> is stored in adiabatic_response_factor subroutine init_adiabatic_response_factor use physics_parameters , only : nine , tite use zgrid , only : nzgrid use stella_transforms , only : transform_alpha2kalpha use kt_grids , only : naky , naky_all , ikx_max use gyro_averages , only : band_lu_solve_ffs use volume_averages , only : flux_surface_average_ffs implicit none integer :: ikx complex , dimension (:, :, :), allocatable :: adiabatic_response_vector allocate ( adiabatic_response_vector ( naky_all , ikx_max , - nzgrid : nzgrid )) if (. not . allocated ( adiabatic_response_factor )) allocate ( adiabatic_response_factor ( ikx_max )) !> adiabatic_response_vector is initialised to be the rhs of the equation for the !> 'homogeneous' part of phi, with a unit impulse assumed for the flux-surface-averaged phi !> only the ky=0 component contributes to the flux-surface-averaged potential adiabatic_response_vector = 0.0 adiabatic_response_vector ( naky , :, :) = tite / nine !> pass in the rhs and overwrite with the solution for phi_homogeneous call band_lu_solve_ffs ( lu_gam0_ffs , adiabatic_response_vector ) !> obtain the flux surface average of the response vector do ikx = 1 , ikx_max call flux_surface_average_ffs ( adiabatic_response_vector (:, ikx , :), adiabatic_response_factor ( ikx )) end do adiabatic_response_factor = 1.0 / ( 1.0 - adiabatic_response_factor ) deallocate ( adiabatic_response_vector ) end subroutine init_adiabatic_response_factor subroutine allocate_arrays use fields_arrays , only : phi , phi_old use fields_arrays , only : apar , apar_old use fields_arrays , only : bpar , bpar_old use fields_arrays , only : phi_corr_QN , phi_corr_GA use fields_arrays , only : apar_corr_QN , apar_corr_GA use zgrid , only : nzgrid , ntubes use stella_layouts , only : vmu_lo use physics_flags , only : radial_variation use kt_grids , only : naky , nakx implicit none if (. not . allocated ( phi )) then allocate ( phi ( naky , nakx , - nzgrid : nzgrid , ntubes )) phi = 0. end if if (. not . allocated ( phi_old )) then allocate ( phi_old ( naky , nakx , - nzgrid : nzgrid , ntubes )) phi_old = 0. end if if (. not . allocated ( apar )) then allocate ( apar ( naky , nakx , - nzgrid : nzgrid , ntubes )) apar = 0. end if if (. not . allocated ( apar_old )) then allocate ( apar_old ( naky , nakx , - nzgrid : nzgrid , ntubes )) apar_old = 0. end if if (. not . allocated ( bpar )) then allocate ( bpar ( naky , nakx , - nzgrid : nzgrid , ntubes )) bpar = 0. end if if (. not . allocated ( bpar_old )) then allocate ( bpar_old ( naky , nakx , - nzgrid : nzgrid , ntubes )) bpar_old = 0. end if if (. not . allocated ( phi_corr_QN ) . and . radial_variation ) then allocate ( phi_corr_QN ( naky , nakx , - nzgrid : nzgrid , ntubes )) phi_corr_QN = 0. end if if (. not . allocated ( phi_corr_GA ) . and . radial_variation ) then allocate ( phi_corr_GA ( naky , nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) phi_corr_GA = 0. end if if (. not . allocated ( apar_corr_QN ) . and . radial_variation ) then !allocate (apar_corr(naky,nakx,-nzgrid:nzgrid,ntubes,vmu_lo%llim_proc:vmu_lo%ulim_alloc)) allocate ( apar_corr_QN ( 1 , 1 , 1 , 1 )) apar_corr_QN = 0. end if if (. not . allocated ( apar_corr_GA ) . and . radial_variation ) then !allocate (apar_corr(naky,nakx,-nzgrid:nzgrid,ntubes,vmu_lo%llim_proc:vmu_lo%ulim_alloc)) allocate ( apar_corr_GA ( 1 , 1 , 1 , 1 , 1 )) apar_corr_GA = 0. end if end subroutine allocate_arrays subroutine enforce_reality_field ( fin ) !DSO> while most of the modes in the box have reality built in (as we !     throw out half the kx-ky plane, modes with ky=0 do not have !     this enforcement built in. In theory this should not be a problem !     as these modes should be stable, but I made this function (and !     its relative in the dist file) just in case use kt_grids , only : nakx use zgrid , only : nzgrid implicit none complex , dimension (:, :, - nzgrid :, :), intent ( inout ) :: fin integer ikx fin ( 1 , 1 , :, :) = real ( fin ( 1 , 1 , :, :)) do ikx = 2 , nakx / 2 + 1 fin ( 1 , ikx , :, :) = 0.5 * ( fin ( 1 , ikx , :, :) + conjg ( fin ( 1 , nakx - ikx + 2 , :, :))) fin ( 1 , nakx - ikx + 2 , :, :) = conjg ( fin ( 1 , ikx , :, :)) end do end subroutine enforce_reality_field subroutine advance_fields_vmu_lo ( g , phi , apar , bpar , dist ) use mp , only : proc0 use stella_layouts , only : vmu_lo use job_manage , only : time_message use redistribute , only : scatter use dist_fn_arrays , only : gvmu use zgrid , only : nzgrid use dist_redistribute , only : kxkyz2vmu use run_parameters , only : fields_kxkyz use physics_flags , only : full_flux_surface implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( out ) :: phi , apar , bpar character ( * ), intent ( in ) :: dist if ( fields_updated ) return !> time the communications + field solve if ( proc0 ) call time_message (. false ., time_field_solve (:, 1 ), ' fields' ) !> fields_kxkyz = F is the default if ( fields_kxkyz ) then !> first gather (vpa,mu) onto processor for v-space operations !> v-space operations are field solve, dg/dvpa, and collisions if ( debug ) write ( * , * ) 'fields::advance_fields_vmu_lo::scatter' if ( proc0 ) call time_message (. false ., time_field_solve (:, 2 ), ' fields_redist' ) call scatter ( kxkyz2vmu , g , gvmu ) if ( proc0 ) call time_message (. false ., time_field_solve (:, 2 ), ' fields_redist' ) !> given gvmu with vpa and mu local, calculate the corresponding fields if ( debug ) write ( * , * ) 'fields::advance_fields_vmu_lo::get_fields' call get_fields ( gvmu , phi , apar , bpar , dist ) else if ( full_flux_surface ) then if ( debug ) write ( * , * ) 'fields::advance_fields_vmu_lo::get_fields_ffs' call get_fields_ffs ( g , phi , apar ) else call get_fields_vmulo ( g , phi , apar , bpar , dist ) end if end if !> set a flag to indicate that the fields have been updated !> this helps avoid unnecessary field solves fields_updated = . true . !> time the communications + field solve if ( proc0 ) call time_message (. false ., time_field_solve (:, 1 ), ' fields' ) end subroutine advance_fields_vmu_lo subroutine advance_fields_kxkyz_lo ( gvmu , phi , apar , bpar , dist ) use mp , only : proc0 use stella_layouts , only : kxkyz_lo use job_manage , only : time_message use redistribute , only : scatter use zgrid , only : nzgrid use run_parameters , only : fields_kxkyz use physics_flags , only : full_flux_surface implicit none complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( in ) :: gvmu complex , dimension (:, :, - nzgrid :, :), intent ( out ) :: phi , apar , bpar character ( * ), intent ( in ) :: dist if ( fields_updated ) return !> time the communications + field solve if ( proc0 ) call time_message (. false ., time_field_solve (:, 1 ), ' fields' ) !> given gvmu with vpa and mu local, calculate the corresponding fields if ( debug ) write ( * , * ) 'dist_fn::advance_stella::advance_fields_kxkyz_lo::get_fields' call get_fields ( gvmu , phi , apar , bpar , dist ) !> set a flag to indicate that the fields have been updated !> this helps avoid unnecessary field solves fields_updated = . true . !> time the communications + field solve if ( proc0 ) call time_message (. false ., time_field_solve (:, 1 ), ' fields' ) end subroutine advance_fields_kxkyz_lo subroutine get_fields ( g , phi , apar , bpar , dist , skip_fsa ) use mp , only : proc0 use mp , only : sum_allreduce , mp_abort use job_manage , only : time_message use stella_layouts , only : kxkyz_lo use stella_layouts , only : iz_idx , it_idx , ikx_idx , iky_idx , is_idx use dist_fn_arrays , only : kperp2 use gyro_averages , only : gyro_average , gyro_average_j1 use physics_flags , only : include_apar , include_bpar use run_parameters , only : fphi use physics_parameters , only : beta use zgrid , only : nzgrid , ntubes use vpamu_grids , only : nvpa , nmu use vpamu_grids , only : vpa , mu use vpamu_grids , only : integrate_vmu use species , only : spec implicit none complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( out ) :: phi , apar , bpar logical , optional , intent ( in ) :: skip_fsa character ( * ), intent ( in ) :: dist complex :: tmp real :: wgt complex , dimension (:, :), allocatable :: g0 integer :: ikxkyz , iz , it , ikx , iky , is , ia logical :: skip_fsa_local skip_fsa_local = . false . if ( present ( skip_fsa )) skip_fsa_local = skip_fsa if ( debug ) write ( * , * ) 'dist_fn::advance_stella::get_fields_kxkyzlo' ia = 1 phi = 0. bpar = 0. if ( fphi > epsilon ( 0.0 ) . and . . not . include_bpar ) then if ( proc0 ) call time_message (. false ., time_field_solve (:, 3 ), ' int_dv_g' ) allocate ( g0 ( nvpa , nmu )) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iky = iky_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) call gyro_average ( g (:, :, ikxkyz ), ikxkyz , g0 ) wgt = spec ( is )% z * spec ( is )% dens_psi0 call integrate_vmu ( g0 , iz , tmp ) phi ( iky , ikx , iz , it ) = phi ( iky , ikx , iz , it ) + wgt * tmp end do deallocate ( g0 ) call sum_allreduce ( phi ) if ( proc0 ) call time_message (. false ., time_field_solve (:, 3 ), ' int_dv_g' ) call get_phi ( phi , dist , skip_fsa_local ) elseif ( fphi > epsilon ( 0.0 ) . and . include_bpar ) then if ( proc0 ) call time_message (. false ., time_field_solve (:, 3 ), ' int_dv_g int_dv_g_vperp2' ) allocate ( g0 ( nvpa , nmu )) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iky = iky_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) !> integrate g to get sum_s Z_s n_s J0 g and store in phi call gyro_average ( g (:, :, ikxkyz ), ikxkyz , g0 ) wgt = spec ( is )% z * spec ( is )% dens_psi0 call integrate_vmu ( g0 , iz , tmp ) phi ( iky , ikx , iz , it ) = phi ( iky , ikx , iz , it ) + wgt * tmp !> integrate g to get - 2 beta sum_s n_s T_s J1 mu g and store in bpar call gyro_average_j1 ( spread ( mu , 1 , nvpa ) * g (:, :, ikxkyz ), ikxkyz , g0 ) wgt = - 2.0 * beta * spec ( is )% z * spec ( is )% dens_psi0 * spec ( is )% temp_psi0 call integrate_vmu ( g0 , iz , tmp ) bpar ( iky , ikx , iz , it ) = bpar ( iky , ikx , iz , it ) + wgt * tmp end do deallocate ( g0 ) call sum_allreduce ( phi ) call sum_allreduce ( bpar ) if ( proc0 ) call time_message (. false ., time_field_solve (:, 3 ), ' int_dv_g int_dv_g_vperp2' ) call get_phi_and_bpar ( phi , bpar , dist , skip_fsa_local ) end if apar = 0. if ( include_apar ) then allocate ( g0 ( nvpa , nmu )) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iky = iky_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) call gyro_average ( spread ( vpa , 2 , nmu ) * g (:, :, ikxkyz ), ikxkyz , g0 ) wgt = 2.0 * beta * spec ( is )% z * spec ( is )% dens * spec ( is )% stm call integrate_vmu ( g0 , iz , tmp ) apar ( iky , ikx , iz , it ) = apar ( iky , ikx , iz , it ) + tmp * wgt end do call sum_allreduce ( apar ) if ( dist == 'g' . or . dist == 'h' ) then where ( spread ( kperp2 (:, :, ia , :), 4 , ntubes ) > epsilon ( 0.0 )) apar = apar / spread ( kperp2 (:, :, ia , :), 4 , ntubes ) elsewhere apar = 0.0 end where else if ( dist == 'gbar' ) then apar = apar / spread ( apar_denom , 4 , ntubes ) else if ( dist == 'gstar' ) then write ( * , * ) 'APAR NOT SETUP FOR GSTAR YET. aborting.' call mp_abort ( 'APAR NOT SETUP FOR GSTAR YET. aborting.' ) else if ( proc0 ) write ( * , * ) 'unknown dist option in get_fields. aborting' call mp_abort ( 'unknown dist option in get_fields. aborting' ) end if deallocate ( g0 ) end if end subroutine get_fields subroutine get_fields_vmulo ( g , phi , apar , bpar , dist , skip_fsa ) use mp , only : mp_abort , proc0 use job_manage , only : time_message use stella_layouts , only : vmu_lo , iv_idx , imu_idx use gyro_averages , only : gyro_average , gyro_average_j1 use run_parameters , only : fphi use physics_parameters , only : beta use physics_flags , only : include_apar , include_bpar use physics_flags , only : radial_variation use dist_fn_arrays , only : g_scratch use zgrid , only : nzgrid use vpamu_grids , only : integrate_species use vpamu_grids , only : vpa , mu use species , only : spec implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( out ) :: phi , apar , bpar logical , optional , intent ( in ) :: skip_fsa character ( * ), intent ( in ) :: dist integer :: iv , ivmu , imu logical :: skip_fsa_local skip_fsa_local = . false . if ( present ( skip_fsa )) skip_fsa_local = skip_fsa if ( debug ) write ( * , * ) 'dist_fn::advance_stella::get_fields_vmulo' phi = 0. bpar = 0. if ( fphi > epsilon ( 0.0 ) . and . . not . include_bpar ) then if ( proc0 ) call time_message (. false ., time_field_solve (:, 3 ), ' int_dv_g' ) ! gyroaverage the distribution function g at each phase space location call gyro_average ( g , g_scratch ) ! <g> requires modification if radial profile variation is included if ( radial_variation ) call add_radial_correction_int_species ( g_scratch ) ! integrate <g> over velocity space and sum over species !> store result in phi, which will be further modified below to account for polarization term if ( debug ) write ( * , * ) 'dist_fn::advance_stella::get_fields_vmulo::integrate_species_phi' call integrate_species ( g_scratch , spec % z * spec % dens_psi0 , phi ) if ( proc0 ) call time_message (. false ., time_field_solve (:, 3 ), ' int_dv_g' ) call get_phi ( phi , dist , skip_fsa_local ) else if ( fphi > epsilon ( 0.0 ) . and . include_bpar ) then if ( proc0 ) call time_message (. false ., time_field_solve (:, 3 ), ' int_dv_g int_dv_g_vperp2' ) ! gyroaverage the distribution function g at each phase space location call gyro_average ( g , g_scratch ) ! <g> requires modification if radial profile variation is included if ( radial_variation ) call add_radial_correction_int_species ( g_scratch ) ! integrate <g> over velocity space and sum over species !> store result in phi, which will be further modified below to account for polarization term if ( debug ) write ( * , * ) 'dist_fn::advance_stella::get_fields_vmulo::integrate_species_phi' call integrate_species ( g_scratch , spec % z * spec % dens_psi0 , phi ) ! gyroaverage the distribution function g at each phase space location call gyro_average_j1 ( g , g_scratch ) ! multiply by mu factor from vperp2 do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc imu = imu_idx ( vmu_lo , ivmu ) g_scratch (:, :, :, :, ivmu ) = g_scratch (:, :, :, :, ivmu ) * mu ( imu ) end do ! <g> requires modification if radial profile variation is included ! not supported for bpar MRH ! integrate <g> over velocity space and sum over species !> store result in bpar, which will be further modified below to account for polarization term if ( debug ) write ( * , * ) 'dist_fn::advance_stella::get_fields_vmulo::integrate_species_bpar' call integrate_species ( g_scratch , - 2.0 * beta * spec % temp_psi0 * spec % dens_psi0 , bpar ) if ( proc0 ) call time_message (. false ., time_field_solve (:, 3 ), ' int_dv_g int_dv_g_vperp2' ) call get_phi_and_bpar ( phi , bpar , dist , skip_fsa_local ) end if apar = 0. if ( include_apar ) then if ( proc0 ) call time_message (. false ., time_field_solve (:, 3 ), ' int_dv_g' ) ! if fphi > 0, then g_scratch = <g> already calculated above !if (fphi < epsilon(0.0)) call gyro_average(g, g_scratch) ! MRH remove optimisation for ease of including bpar call gyro_average ( g , g_scratch ) ! for parallel Ampere's Law, need to calculate parallel current rather than density, ! so multiply <g> by vpa before integrating do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc ! get the vpa index iv = iv_idx ( vmu_lo , ivmu ) ! multiply by vpa g_scratch (:, :, :, :, ivmu ) = g_scratch (:, :, :, :, ivmu ) * vpa ( iv ) end do ! integrate vpa*<g> over velocity space and sum over species !> store result in apar, which will be further modified below to account for apar pre-factor if ( debug ) write ( * , * ) 'dist_fn::advance_stella::get_fields_vmulo::integrate_species_apar' call integrate_species ( g_scratch , spec % z * spec % dens_psi0 * spec % stm_psi0 * beta , apar ) if ( proc0 ) call time_message (. false ., time_field_solve (:, 3 ), ' int_dv_g' ) ! divide the apar obtained above by the appropriate Apar pre-factor; ! this is just kperp2 if g = <f> is used or apar_denom = (kperp2 + ...) ! if gbar = g + <vpa*apar/c> * Ze/T * F_0 is used call get_apar ( apar , dist ) end if end subroutine get_fields_vmulo !> get_fields_ffs accepts as input the guiding centre distribution function g !> and calculates/returns the electronstatic potential phi for full_flux_surface simulations subroutine get_fields_ffs ( g , phi , apar ) use mp , only : mp_abort use physics_parameters , only : nine , tite use physics_flags , only : include_apar use stella_layouts , only : vmu_lo use run_parameters , only : fphi use species , only : modified_adiabatic_electrons , adiabatic_electrons use zgrid , only : nzgrid use kt_grids , only : nakx , ikx_max , naky , naky_all use kt_grids , only : swap_kxky_ordered use volume_averages , only : flux_surface_average_ffs implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( out ) :: phi , apar integer :: iz , ikx complex , dimension (:), allocatable :: phi_fsa complex , dimension (:, :, :), allocatable :: phi_swap , source if ( fphi > epsilon ( 0.0 )) then allocate ( source ( naky , nakx , - nzgrid : nzgrid )) !> calculate the contribution to quasineutrality coming from the velocity space !> integration of the guiding centre distribution function g; !> the sign is consistent with phi appearing on the RHS of the eqn and int g appearing on the LHS. !> this is returned in source if ( debug ) write ( * , * ) 'fields::advance_fields::get_fields_ffs::get_g_integral_contribution' call get_g_integral_contribution ( g , source ) !> use sum_s int d3v <g> and QN to solve for phi !> NB: assuming here that ntubes = 1 for FFS sim if ( debug ) write ( * , * ) 'fields::advance_fields::get_phi_ffs' call get_phi_ffs ( source , phi (:, :, :, 1 )) !> if using a modified Boltzmann response for the electrons, then phi !> at this stage is the 'inhomogeneous' part of phi. if ( modified_adiabatic_electrons ) then !> first must get phi on grid that includes positive and negative ky (but only positive kx) allocate ( phi_swap ( naky_all , ikx_max , - nzgrid : nzgrid )) if ( debug ) write ( * , * ) 'fields::advance_fields::get_fields_ffs::swap_kxky_ordered' do iz = - nzgrid , nzgrid call swap_kxky_ordered ( phi (:, :, iz , 1 ), phi_swap (:, :, iz )) end do !> calculate the flux surface average of this phi_inhomogeneous allocate ( phi_fsa ( nakx )) if ( debug ) write ( * , * ) 'fields::advance_fields::get_fields_ffs::flux_surface_average_ffs' do ikx = 1 , nakx call flux_surface_average_ffs ( phi_swap (:, ikx , :), phi_fsa ( ikx )) end do !> use the flux surface average of phi_inhomogeneous, together with the !> adiabatic_response_factor, to obtain the flux-surface-averaged phi phi_fsa = phi_fsa * adiabatic_response_factor !> use the computed flux surface average of phi as an additional sosurce in quasineutrality !> to obtain the electrostatic potential; only affects the ky=0 component of QN do ikx = 1 , nakx source ( 1 , ikx , :) = source ( 1 , ikx , :) + phi_fsa ( ikx ) * tite / nine end do if ( debug ) write ( * , * ) 'fields::advance_fields::get_fields_ffs::get_phi_ffs2s' call get_phi_ffs ( source , phi (:, :, :, 1 )) deallocate ( phi_swap , phi_fsa ) end if deallocate ( source ) else if (. not . adiabatic_electrons ) then !> if adiabatic electrons are not employed, then !> no explicit equation for the ky=kx=0 component of phi; !> hack for now is to set it equal to zero. phi ( 1 , 1 , :, :) = 0. end if apar = 0. if ( include_apar ) then call mp_abort ( 'apar not yet supported for full_flux_surface = T. aborting.' ) end if contains subroutine get_g_integral_contribution ( g , source ) use mp , only : sum_allreduce use stella_layouts , only : vmu_lo use species , only : spec use zgrid , only : nzgrid use kt_grids , only : naky , nakx use vpamu_grids , only : integrate_species_ffs use gyro_averages , only : gyro_average , j0_B_maxwell_ffs implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :), intent ( in out ) :: source integer :: it , iz , ivmu complex , dimension (:, :, :), allocatable :: gyro_g !> assume there is only a single flux surface being simulated it = 1 allocate ( gyro_g ( naky , nakx , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) !> loop over zed location within flux tube do iz = - nzgrid , nzgrid !> loop over super-index ivmu, which include vpa, mu and spec do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc !> gyroaverage the distribution function g at each phase space location call gyro_average ( g (:, :, iz , it , ivmu ), gyro_g (:, :, ivmu ), j0_B_maxwell_ffs (:, :, iz , ivmu )) end do !> integrate <g> over velocity space and sum over species within each processor !> as v-space and species possibly spread over processors, wlil need to !> gather sums from each proceessor and sum them all together below call integrate_species_ffs ( gyro_g , spec % z * spec % dens_psi0 , source (:, :, iz ), reduce_in = . false .) end do !> gather sub-sums from each processor and add them together !> store result in phi, which will be further modified below to account for polarization term call sum_allreduce ( source ) !> no longer need <g>, so deallocate deallocate ( gyro_g ) end subroutine get_g_integral_contribution end subroutine get_fields_ffs subroutine get_fields_by_spec ( g , fld , skip_fsa ) use mp , only : sum_allreduce use stella_layouts , only : kxkyz_lo use stella_layouts , only : iz_idx , it_idx , ikx_idx , iky_idx , is_idx use gyro_averages , only : gyro_average use run_parameters , only : fphi use stella_geometry , only : dl_over_b use zgrid , only : nzgrid , ntubes use vpamu_grids , only : nvpa , nmu use vpamu_grids , only : integrate_vmu use kt_grids , only : nakx use kt_grids , only : zonal_mode use species , only : spec , nspec , has_electron_species use physics_flags , only : adiabatic_option_switch use physics_flags , only : adiabatic_option_fieldlineavg implicit none complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :, :), intent ( out ) :: fld logical , optional , intent ( in ) :: skip_fsa real :: wgt complex , dimension (:, :), allocatable :: g0 integer :: ikxkyz , iz , it , ikx , iky , is , ia logical :: skip_fsa_local complex , dimension ( nspec ) :: tmp skip_fsa_local = . false . if ( present ( skip_fsa )) skip_fsa_local = skip_fsa if ( debug ) write ( * , * ) 'dist_fn::advance_stella::get_fields_by_spec' ia = 1 fld = 0. if ( fphi > epsilon ( 0.0 )) then allocate ( g0 ( nvpa , nmu )) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iky = iky_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) wgt = spec ( is )% z * spec ( is )% dens_psi0 call gyro_average ( g (:, :, ikxkyz ), ikxkyz , g0 ) g0 = g0 * wgt call integrate_vmu ( g0 , iz , fld ( iky , ikx , iz , it , is )) end do call sum_allreduce ( fld ) fld = fld / gamtot_h if (. not . has_electron_species ( spec ) . and . (. not . skip_fsa_local ) . and . & adiabatic_option_switch == adiabatic_option_fieldlineavg ) then if ( zonal_mode ( 1 )) then do ikx = 1 , nakx do it = 1 , ntubes do is = 1 , nspec tmp ( is ) = sum ( dl_over_b ( ia , :) * fld ( 1 , ikx , :, it , is )) fld ( 1 , ikx , :, it , is ) = fld ( 1 , ikx , :, it , is ) + tmp ( is ) * gamtot3_h end do end do end do end if end if deallocate ( g0 ) end if end subroutine get_fields_by_spec subroutine get_fields_by_spec_idx ( isa , g , fld ) ! apply phi_isa[ ] to all species indices contained in g ! ie get phi_isa[g_is1], phi_isa[g_is2], phi_isa[g_is3] ... use mp , only : sum_allreduce use stella_layouts , only : kxkyz_lo use stella_layouts , only : iz_idx , it_idx , ikx_idx , iky_idx , is_idx use gyro_averages , only : gyro_average use run_parameters , only : fphi use stella_geometry , only : dl_over_b , bmag use zgrid , only : nzgrid , ntubes use vpamu_grids , only : vperp2 , nvpa , nmu use vpamu_grids , only : integrate_vmu use kt_grids , only : nakx use kt_grids , only : zonal_mode use species , only : spec , nspec , has_electron_species use physics_flags , only : adiabatic_option_switch use physics_flags , only : adiabatic_option_fieldlineavg use dist_fn_arrays , only : kperp2 use spfunc , only : j0 implicit none complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :, :), intent ( out ) :: fld integer , intent ( in ) :: isa complex , dimension (:, :), allocatable :: g0 integer :: ikxkyz , iz , it , ikx , iky , is , ia , imu complex , dimension ( nspec ) :: tmp real :: wgt real :: arg ia = 1 fld = 0. if ( fphi > epsilon ( 0.0 )) then allocate ( g0 ( nvpa , nmu )) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iky = iky_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) wgt = spec ( isa )% z * spec ( isa )% dens do imu = 1 , nmu ! AVB: changed this for use of j0, check arg = spec ( isa )% bess_fac * spec ( isa )% smz_psi0 * sqrt ( vperp2 ( ia , iz , imu ) * kperp2 ( iky , ikx , ia , iz )) / bmag ( ia , iz ) g0 (:, imu ) = g (:, imu , ikxkyz ) * j0 ( arg ) ! AVB: gyroaverage end do g0 = g0 * wgt call integrate_vmu ( g0 , iz , fld ( iky , ikx , iz , it , is )) end do call sum_allreduce ( fld ) fld = fld / gamtot_h if (. not . has_electron_species ( spec ) . and . & adiabatic_option_switch == adiabatic_option_fieldlineavg ) then if ( zonal_mode ( 1 )) then do ikx = 1 , nakx do it = 1 , ntubes do is = 1 , nspec tmp ( is ) = sum ( dl_over_b ( ia , :) * fld ( 1 , ikx , :, it , is )) fld ( 1 , ikx , :, it , is ) = fld ( 1 , ikx , :, it , is ) + tmp ( is ) * gamtot3_h end do end do end do end if end if deallocate ( g0 ) end if end subroutine get_fields_by_spec_idx subroutine get_phi ( phi , dist , skip_fsa ) use mp , only : proc0 , mp_abort , job use job_manage , only : time_message use physics_flags , only : radial_variation use run_parameters , only : ky_solve_radial , ky_solve_real use zgrid , only : nzgrid , ntubes use stella_geometry , only : dl_over_b use kt_grids , only : nakx , naky , zonal_mode use physics_flags , only : adiabatic_option_switch use physics_flags , only : adiabatic_option_fieldlineavg use species , only : spec , has_electron_species use multibox , only : mb_get_phi use fields_arrays , only : gamtot , gamtot3 use file_utils , only : runtype_option_switch , runtype_multibox implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in out ) :: phi logical , optional , intent ( in ) :: skip_fsa real , dimension (:, :, :, :), allocatable :: gamtot_t integer :: ia , it , ikx complex :: tmp logical :: skip_fsa_local logical :: has_elec , adia_elec logical :: global_quasineutrality , center_cell logical :: multibox_mode character ( * ), intent ( in ) :: dist if ( debug ) write ( * , * ) 'dist_fn::advance_stella::get_phi' skip_fsa_local = . false . if ( present ( skip_fsa )) skip_fsa_local = skip_fsa ia = 1 has_elec = has_electron_species ( spec ) adia_elec = . not . has_elec & . and . adiabatic_option_switch == adiabatic_option_fieldlineavg global_quasineutrality = radial_variation . and . ky_solve_radial > 0 multibox_mode = runtype_option_switch == runtype_multibox center_cell = multibox_mode . and . job == 1 . and . . not . ky_solve_real if ( proc0 ) call time_message (. false ., time_field_solve (:, 4 ), ' get_phi' ) if ( dist == 'h' ) then phi = phi / gamtot_h else if ( dist == 'g' . or . dist == 'gbar' ) then if ( global_quasineutrality . and . ( center_cell . or . . not . multibox_mode ) . and . . not . ky_solve_real ) then call get_phi_radial ( phi ) else if ( global_quasineutrality . and . center_cell . and . ky_solve_real ) then call mb_get_phi ( phi , has_elec , adia_elec ) else ! divide <g> by sum_s (\\Gamma_0s-1) Zs&#94;2*e*ns/Ts to get phi allocate ( gamtot_t ( naky , nakx , - nzgrid : nzgrid , ntubes )) gamtot_t = spread ( gamtot , 4 , ntubes ) where ( gamtot_t < epsilon ( 0.0 )) phi = 0.0 elsewhere phi = phi / gamtot_t end where deallocate ( gamtot_t ) end if else if ( proc0 ) write ( * , * ) 'unknown dist option in get_fields. aborting' call mp_abort ( 'unknown dist option in get_fields. aborting' ) return end if if ( any ( gamtot ( 1 , 1 , :) < epsilon ( 0. ))) phi ( 1 , 1 , :, :) = 0.0 if ( proc0 ) call time_message (. false ., time_field_solve (:, 4 ), ' get_phi' ) ! now handle adiabatic electrons if needed if ( proc0 ) call time_message (. false ., time_field_solve (:, 5 ), 'get_phi_adia_elec' ) if ( adia_elec . and . zonal_mode ( 1 ) . and . . not . skip_fsa_local ) then if ( debug ) write ( * , * ) 'dist_fn::advance_stella::adiabatic_electrons' if ( dist == 'h' ) then do it = 1 , ntubes do ikx = 1 , nakx tmp = sum ( dl_over_b ( ia , :) * phi ( 1 , ikx , :, it )) phi ( 1 , ikx , :, it ) = phi ( 1 , ikx , :, it ) + tmp * gamtot3_h end do end do else if ( dist == 'g' . or . dist == 'gbar' ) then if ( global_quasineutrality . and . center_cell . and . ky_solve_real ) then !this is already taken care of in mb_get_phi elseif ( global_quasineutrality . and . ( center_cell . or . . not . multibox_mode ) & . and . . not . ky_solve_real ) then call add_adiabatic_response_radial ( phi ) else do ikx = 1 , nakx do it = 1 , ntubes tmp = sum ( dl_over_b ( ia , :) * phi ( 1 , ikx , :, it )) phi ( 1 , ikx , :, it ) = phi ( 1 , ikx , :, it ) + tmp * gamtot3 ( ikx , :) end do end do end if else if ( proc0 ) write ( * , * ) 'unknown dist option in get_fields. aborting' call mp_abort ( 'unknown dist option in get_fields. aborting' ) end if end if if ( proc0 ) call time_message (. false ., time_field_solve (:, 5 ), 'get_phi_adia_elec' ) end subroutine get_phi subroutine get_phi_and_bpar ( phi , bpar , dist , skip_fsa ) use mp , only : proc0 , mp_abort , job use job_manage , only : time_message use physics_flags , only : radial_variation use run_parameters , only : ky_solve_radial , ky_solve_real use zgrid , only : nzgrid , ntubes use stella_geometry , only : dl_over_b use kt_grids , only : nakx , naky , zonal_mode use physics_flags , only : adiabatic_option_switch use physics_flags , only : adiabatic_option_fieldlineavg use species , only : spec , has_electron_species use multibox , only : mb_get_phi use fields_arrays , only : gamtotinv11 , gamtotinv13 , gamtotinv33 , gamtotinv31 use file_utils , only : runtype_option_switch , runtype_multibox implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in out ) :: phi , bpar logical , optional , intent ( in ) :: skip_fsa integer :: ia , it , ikx , iky , iz complex :: antot1 , antot3 character ( * ), intent ( in ) :: dist if ( debug ) write ( * , * ) 'dist_fn::advance_stella::get_phi_and_bpar' ia = 1 if ( proc0 ) call time_message (. false ., time_field_solve (:, 4 ), ' get_phi_and_bpar' ) if ( dist == 'gbar' . or . dist == 'g' ) then do it = 1 , ntubes do iz = - nzgrid , nzgrid do ikx = 1 , nakx do iky = 1 , naky antot1 = phi ( iky , ikx , iz , it ) antot3 = bpar ( iky , ikx , iz , it ) phi ( iky , ikx , iz , it ) = gamtotinv11 ( iky , ikx , iz ) * antot1 + gamtotinv13 ( iky , ikx , iz ) * antot3 bpar ( iky , ikx , iz , it ) = gamtotinv31 ( iky , ikx , iz ) * antot1 + gamtotinv33 ( iky , ikx , iz ) * antot3 end do end do end do end do else if ( dist == 'h' ) then !> divide sum ( Zs int J0 h d&#94;3 v) by sum(Zs&#94;2 ns / Ts) phi = phi / gamtot_h !> do nothing for bpar because !> bpar = - 2 * beta * sum(Ts ns int (J1/bs) mu h d&#94;3 v) !> which is already stored in bpar when dist = 'h'. else if ( proc0 ) write ( * , * ) 'unknown dist option in get_fields. aborting' call mp_abort ( 'unknown dist option in get_fields. aborting' ) return end if end subroutine get_phi_and_bpar !> Non-perturbative approach to solving quasineutrality for radially !> global simulations subroutine get_phi_radial ( phi ) #ifdef ISO_C_BINDING use mpi use mp , only : curr_focus , sharedsubprocs , scope use mp , only : split_n_tasks , sgproc0 use zgrid , only : nztot use fields_arrays , only : phi_shared use mp_lu_decomposition , only : lu_matrix_multiply_local #endif use stella_transforms , only : transform_kx2x_unpadded , transform_x2kx_unpadded use physics_flags , only : adiabatic_option_switch use physics_flags , only : adiabatic_option_fieldlineavg use run_parameters , only : ky_solve_radial use zgrid , only : nzgrid , ntubes use species , only : spec , has_electron_species use kt_grids , only : nakx , naky , zonal_mode use linear_solve , only : lu_back_substitution use fields_arrays , only : gamtot , phi_solve implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in out ) :: phi integer :: it , iz , iky , zmi integer :: naky_r complex , dimension (:, :), allocatable :: g0k , g0x logical :: has_elec , adia_elec #ifdef ISO_C_BINDING integer :: counter , c_lo , c_hi integer :: prior_focus , ierr #endif allocate ( g0k ( 1 , nakx )) allocate ( g0x ( 1 , nakx )) has_elec = has_electron_species ( spec ) adia_elec = . not . has_elec & . and . adiabatic_option_switch == adiabatic_option_fieldlineavg naky_r = min ( naky , ky_solve_radial ) #ifdef ISO_C_BINDING prior_focus = curr_focus call scope ( sharedsubprocs ) call split_n_tasks ( nztot * ntubes * naky_r , c_lo , c_hi ) call scope ( prior_focus ) counter = 0 if ( sgproc0 ) phi_shared = phi call mpi_win_fence ( 0 , phi_shared_window , ierr ) #endif do it = 1 , ntubes do iz = - nzgrid , nzgrid do iky = 1 , naky_r #ifdef ISO_C_BINDING counter = counter + 1 if (( counter >= c_lo ) . and . ( counter <= c_hi )) then if (. not . ( adia_elec . and . zonal_mode ( iky ))) then zmi = 0 if ( iky == 1 ) zmi = zm !zero mode may or may not be included in matrix call lu_back_substitution ( phi_solve ( iky , iz )% zloc , & phi_solve ( iky , iz )% idx , phi_shared ( iky , ( 1 + zmi ):, iz , it )) if ( zmi > 0 ) phi ( iky , zmi , iz , it ) = 0.0 end if end if #else if (. not . ( adia_elec . and . zonal_mode ( iky ))) then zmi = 0 if ( iky == 1 ) zmi = zm !zero mode may or may not be included in matrix call lu_back_substitution ( phi_solve ( iky , iz )% zloc , & phi_solve ( iky , iz )% idx , phi ( iky , ( 1 + zmi ):, iz , it )) if ( zmi > 0 ) phi ( iky , zmi , iz , it ) = 0.0 end if #endif end do end do end do #ifdef ISO_C_BINDING call mpi_win_fence ( 0 , phi_shared_window , ierr ) phi = phi_shared #endif do it = 1 , ntubes do iz = - nzgrid , nzgrid do iky = naky_r + 1 , naky phi ( iky , :, iz , it ) = phi ( iky , :, iz , it ) / gamtot ( iky , :, iz ) end do end do end do if ( ky_solve_radial == 0 . and . any ( gamtot ( 1 , 1 , :) < epsilon ( 0. ))) & phi ( 1 , 1 , :, :) = 0.0 deallocate ( g0k , g0x ) end subroutine get_phi_radial ! get_apar solves pre-factor * Apar = beta_ref * sum_s Z_s n_s vth_s int d3v vpa * J0 * pdf ! for apar, with pdf being either g or gbar (specified by dist input). ! the input apar is the RHS of the above equation and is overwritten by the true apar ! the pre-factor depends on whether g or gbar is used (kperp2 in former case, with additional ! term appearing in latter case) subroutine get_apar ( apar , dist ) use mp , only : proc0 , mp_abort use zgrid , only : nzgrid , ntubes use dist_fn_arrays , only : kperp2 implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in out ) :: apar character ( * ), intent ( in ) :: dist integer :: ia ! this subroutine only considers flux tubes, so set ia = 1 ia = 1 if ( dist == 'g' ) then where ( spread ( kperp2 (:, :, ia , :), 4 , ntubes ) > epsilon ( 0.0 )) apar = apar / spread ( kperp2 (:, :, ia , :), 4 , ntubes ) elsewhere apar = 0.0 end where else if ( dist == 'gbar' ) then apar = apar / spread ( apar_denom , 4 , ntubes ) else if ( proc0 ) write ( * , * ) 'unknown dist option in get_apar. aborting' call mp_abort ( 'unkown dist option in get_apar. aborting' ) end if end subroutine get_apar subroutine advance_apar ( g , dist , apar ) use mp , only : mp_abort , sum_allreduce use stella_layouts , only : kxkyz_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , it_idx , is_idx use physics_flags , only : include_apar use physics_parameters , only : beta use species , only : spec use zgrid , only : nzgrid , ntubes use vpamu_grids , only : nvpa , nmu , vpa use vpamu_grids , only : integrate_vmu use gyro_averages , only : gyro_average implicit none complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( in ) :: g character ( * ), intent ( in ) :: dist complex , dimension (:, :, - nzgrid :, :), intent ( out ) :: apar integer :: ikxkyz , iky , ikx , iz , it , is real :: wgt complex :: tmp complex , dimension (:, :), allocatable :: scratch apar = 0. if ( include_apar ) then allocate ( scratch ( nvpa , nmu )) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iky = iky_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) call gyro_average ( spread ( vpa , 2 , nmu ) * g (:, :, ikxkyz ), ikxkyz , scratch ) wgt = beta * spec ( is )% z * spec ( is )% dens_psi0 * spec ( is )% stm_psi0 call integrate_vmu ( scratch , iz , tmp ) apar ( iky , ikx , iz , it ) = apar ( iky , ikx , iz , it ) + tmp * wgt end do ! apar for different species may be spread over processors at this point, so ! broadcast to all procs and sum over species call sum_allreduce ( apar ) ! divide by the appropriate apar pre-factor to get apar call get_apar ( apar , dist ) deallocate ( scratch ) end if end subroutine advance_apar !> Add the adiabatic eletron contribution for globally radial simulations. !> This actually entails solving for the whole ky = 0 slice of phi at once (not really adding!) subroutine add_adiabatic_response_radial ( phi ) #ifdef ISO_C_BINDING use mpi use mp , only : sgproc0 , comm_sgroup use fields_arrays , only : qn_zf_window use mp_lu_decomposition , only : lu_matrix_multiply_local #else use linear_solve , only : lu_back_substitution #endif use zgrid , only : nzgrid , ntubes use stella_transforms , only : transform_kx2x_unpadded , transform_x2kx_unpadded use stella_geometry , only : dl_over_b , d_dl_over_b_drho use kt_grids , only : nakx , boundary_size , rho_d_clamped use fields_arrays , only : phizf_solve , phi_ext use fields_arrays , only : phi_proj , phi_proj_stage , theta use fields_arrays , only : exclude_boundary_regions_qn , exp_fac_qn , tcorr_source_qn implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in out ) :: phi integer :: ia , it , iz , ikx integer :: inmat complex , dimension (:, :), allocatable :: g0k , g1k , g0x #ifdef ISO_C_BINDING integer :: ierr #endif allocate ( g0k ( 1 , nakx )) allocate ( g1k ( 1 , nakx )) allocate ( g0x ( 1 , nakx )) ia = 1 do it = 1 , ntubes ! calculate <<g>_psi>_T g1k = 0.0 do iz = - nzgrid , nzgrid - 1 g0k ( 1 , :) = phi ( 1 , :, iz , it ) call transform_kx2x_unpadded ( g0k , g0x ) g0x ( 1 , :) = ( dl_over_b ( ia , iz ) + d_dl_over_b_drho ( ia , iz ) * rho_d_clamped ) * g0x ( 1 , :) if ( exclude_boundary_regions_qn ) then g0x ( 1 , :) = sum ( g0x ( 1 , ( boundary_size + 1 ):( nakx - boundary_size ))) & / ( nakx - 2 * boundary_size ) g0x ( 1 , 1 : boundary_size ) = 0.0 g0x ( 1 , ( nakx - boundary_size + 1 ):) = 0.0 else g0x ( 1 , :) = sum ( g0x ( 1 , :)) / nakx end if call transform_x2kx_unpadded ( g0x , g0k ) g1k = g1k + g0k end do phi_proj_stage (:, 1 , it ) = g1k ( 1 , :) if ( tcorr_source_qn < epsilon ( 0.0 )) then do iz = - nzgrid , nzgrid - 1 phi ( 1 , :, iz , it ) = phi ( 1 , :, iz , it ) - g1k ( 1 , :) end do else do iz = - nzgrid , nzgrid - 1 phi ( 1 , :, iz , it ) = phi ( 1 , :, iz , it ) & - ( 1. - exp_fac_qn ) * g1k ( 1 , :) - exp_fac_qn * phi_proj (:, 1 , it ) end do end if #ifdef ISO_C_BINDING if ( sgproc0 ) then #endif do iz = - nzgrid , nzgrid - 1 do ikx = 1 , nakx inmat = ikx + nakx * ( iz + nzgrid ) phi_ext ( inmat ) = phi ( 1 , ikx , iz , it ) end do end do #ifdef ISO_C_BINDING end if call mpi_win_fence ( 0 , qn_zf_window , ierr ) #endif #ifdef ISO_C_BINDING call lu_matrix_multiply_local ( comm_sgroup , qn_zf_window , phizf_solve % zloc , phi_ext ) call mpi_win_fence ( 0 , qn_zf_window , ierr ) #else call lu_back_substitution ( phizf_solve % zloc , phizf_solve % idx , phi_ext ) #endif do iz = - nzgrid , nzgrid - 1 do ikx = 1 , nakx inmat = ikx + nakx * ( iz + nzgrid ) phi ( 1 , ikx , iz , it ) = phi_ext ( inmat ) end do end do !enforce periodicity phi ( 1 , :, nzgrid , it ) = phi ( 1 , :, - nzgrid , it ) ! calculate Theta.phi g1k = 0.0 do iz = - nzgrid , nzgrid - 1 do ikx = 1 , nakx g0k ( 1 , ikx ) = sum ( theta ( ikx , :, iz ) * phi ( 1 , :, iz , it )) end do call transform_kx2x_unpadded ( g0k , g0x ) g0x ( 1 , :) = ( dl_over_b ( ia , iz ) + d_dl_over_b_drho ( ia , iz ) * rho_d_clamped ) * g0x ( 1 , :) if ( exclude_boundary_regions_qn ) then g0x ( 1 , :) = sum ( g0x ( 1 , ( boundary_size + 1 ):( nakx - boundary_size ))) & / ( nakx - 2 * boundary_size ) g0x ( 1 , 1 : boundary_size ) = 0.0 g0x ( 1 , ( nakx - boundary_size + 1 ):) = 0.0 else g0x ( 1 , :) = sum ( g0x ( 1 , :)) / nakx end if call transform_x2kx_unpadded ( g0x , g0k ) g1k = g1k + g0k end do phi_proj_stage (:, 1 , it ) = phi_proj_stage (:, 1 , it ) - g1k ( 1 , :) end do deallocate ( g0k , g1k , g0x ) end subroutine add_adiabatic_response_radial subroutine get_phi_ffs ( rhs , phi ) use zgrid , only : nzgrid use kt_grids , only : swap_kxky_ordered , swap_kxky_back_ordered use kt_grids , only : naky_all , ikx_max use gyro_averages , only : band_lu_solve_ffs implicit none complex , dimension (:, :, - nzgrid :), intent ( in ) :: rhs complex , dimension (:, :, - nzgrid :), intent ( out ) :: phi integer :: iz complex , dimension (:, :, :), allocatable :: rhs_swap allocate ( rhs_swap ( naky_all , ikx_max , - nzgrid : nzgrid )) !> change from rhs defined on grid with ky >=0 and kx from 0,...,kxmax,-kxmax,...,-dkx !> to rhs_swap defined on grid with ky = -kymax,...,kymax and kx >= 0 do iz = - nzgrid , nzgrid call swap_kxky_ordered ( rhs (:, :, iz ), rhs_swap (:, :, iz )) end do !> solve sum_s Z_s int d&#94;3v <g> = gam0*phi !> where sum_s Z_s int d&#94;3v <g> is initially passed in as rhs_swap !> and then rhs_swap is over-written with the solution to the linear system call band_lu_solve_ffs ( lu_gam0_ffs , rhs_swap ) !> swap back from the ordered grid in ky to the original (kx,ky) grid do iz = - nzgrid , nzgrid call swap_kxky_back_ordered ( rhs_swap (:, :, iz ), phi (:, :, iz )) end do deallocate ( rhs_swap ) end subroutine get_phi_ffs !> Add radial variation of the Jacobian and gyroaveraing in the velocity integration of !> <g>, needed for radially global simulations subroutine add_radial_correction_int_species ( g_in ) use stella_layouts , only : vmu_lo use stella_layouts , only : imu_idx , is_idx use gyro_averages , only : aj0x , aj1x use stella_geometry , only : dBdrho , bmag use dist_fn_arrays , only : kperp2 , dkperp2dr use zgrid , only : nzgrid , ntubes use vpamu_grids , only : vperp2 use kt_grids , only : nakx , naky , multiply_by_rho use run_parameters , only : ky_solve_radial use species , only : spec implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( inout ) :: g_in integer :: ivmu , iz , it , ia , imu , is , iky complex , dimension (:, :), allocatable :: g0k if ( ky_solve_radial <= 0 ) return allocate ( g0k ( naky , nakx )) ia = 1 ! loop over super-index ivmu, which include vpa, mu and spec do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc ! is = species index is = is_idx ( vmu_lo , ivmu ) ! imu = mu index imu = imu_idx ( vmu_lo , ivmu ) ! loop over flux tubes in flux tube train do it = 1 , ntubes ! loop over zed location within flux tube do iz = - nzgrid , nzgrid g0k = 0.0 do iky = 1 , min ( ky_solve_radial , naky ) g0k ( iky , :) = g_in ( iky , :, iz , it , ivmu ) & * ( - 0.5 * aj1x ( iky , :, iz , ivmu ) / aj0x ( iky , :, iz , ivmu ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 ( iky , :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr ( iky , :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) & + dBdrho ( iz ) / bmag ( ia , iz )) end do !g0k(1,1) = 0. call multiply_by_rho ( g0k ) g_in (:, :, iz , it , ivmu ) = g_in (:, :, iz , it , ivmu ) + g0k end do end do end do deallocate ( g0k ) end subroutine add_radial_correction_int_species !> the following routine gets the correction in phi both from gyroaveraging and quasineutrality subroutine get_radial_correction ( g , phi0 , dist ) use mp , only : proc0 , mp_abort , sum_allreduce use stella_layouts , only : vmu_lo use gyro_averages , only : gyro_average , gyro_average_j1 use gyro_averages , only : aj0x , aj1x use run_parameters , only : fphi , ky_solve_radial use stella_geometry , only : dl_over_b , d_dl_over_b_drho , bmag , dBdrho use stella_layouts , only : imu_idx , is_idx use zgrid , only : nzgrid , ntubes use vpamu_grids , only : integrate_species , vperp2 use kt_grids , only : nakx , nx , naky , rho_d_clamped use kt_grids , only : zonal_mode , multiply_by_rho use species , only : spec , has_electron_species use fields_arrays , only : phi_corr_QN , phi_corr_GA use fields_arrays , only : gamtot , dgamtotdr use fields_arrays , only : gamtot3 use dist_fn_arrays , only : kperp2 , dkperp2dr use physics_flags , only : adiabatic_option_switch use physics_flags , only : adiabatic_option_fieldlineavg use stella_transforms , only : transform_kx2x_unpadded , transform_x2kx_unpadded implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: phi0 complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g character ( * ), intent ( in ) :: dist integer :: ikx , iky , ivmu , iz , it , ia , is , imu complex :: tmp real , dimension (:, :, :, :), allocatable :: gamtot_t complex , dimension (:, :, :, :), allocatable :: phi1 complex , dimension (:, :, :), allocatable :: gyro_g complex , dimension (:, :), allocatable :: g0k , g1k , g1x ia = 1 if ( fphi > epsilon ( 0.0 )) then allocate ( gyro_g ( naky , nakx , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) allocate ( g0k ( naky , nakx )) allocate ( phi1 ( naky , nakx , - nzgrid : nzgrid , ntubes )) phi1 = 0. do it = 1 , ntubes do iz = - nzgrid , nzgrid do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) g0k = g (:, :, iz , it , ivmu ) & * ( - 0.5 * aj1x (:, :, iz , ivmu ) / aj0x (:, :, iz , ivmu ) & * ( spec ( is )% smz ) ** 2 & * ( kperp2 (:, :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) & + dBdrho ( iz ) / bmag ( ia , iz )) call gyro_average ( g0k , iz , ivmu , gyro_g (:, :, ivmu )) end do call integrate_species ( gyro_g , iz , spec % z * spec % dens_psi0 , phi1 (:, :, iz , it ), reduce_in = . false .) end do end do call sum_allreduce ( phi1 ) !apply radial operator Xhat do it = 1 , ntubes do iz = - nzgrid , nzgrid g0k = phi1 (:, :, iz , it ) - dgamtotdr (:, :, iz ) * phi0 (:, :, iz , it ) call multiply_by_rho ( g0k ) phi1 (:, :, iz , it ) = g0k end do end do if ( dist == 'gbar' . or . dist == 'g' ) then allocate ( gamtot_t ( naky , nakx , - nzgrid : nzgrid , ntubes )) gamtot_t = spread ( gamtot , 4 , ntubes ) where ( gamtot_t < epsilon ( 0.0 )) phi1 = 0.0 elsewhere phi1 = phi1 / gamtot_t end where deallocate ( gamtot_t ) else if ( dist == 'h' ) then if ( proc0 ) write ( * , * ) 'dist option \"h\" not implemented in radial_correction. aborting' call mp_abort ( 'dist option \"h\" in radial_correction. aborting' ) else if ( proc0 ) write ( * , * ) 'unknown dist option in radial_correction. aborting' call mp_abort ( 'unknown dist option in radial_correction. aborting' ) end if if (. not . has_electron_species ( spec ) . and . & adiabatic_option_switch == adiabatic_option_fieldlineavg ) then if ( zonal_mode ( 1 )) then if ( dist == 'g' . or . dist == 'gbar' ) then allocate ( g1k ( 1 , nakx )) allocate ( g1x ( 1 , nakx )) do it = 1 , ntubes do ikx = 1 , nakx g1k ( 1 , ikx ) = sum ( phi0 ( 1 , ikx , :, it ) & * ( efacp * dl_over_b ( ia , :) + efac * d_dl_over_b_drho ( ia , :))) end do call transform_kx2x_unpadded ( g1k , g1x ) g1x ( 1 , :) = rho_d_clamped * g1x ( 1 , :) call transform_x2kx_unpadded ( g1x , g1k ) do ikx = 1 , nakx phi1 ( 1 , ikx , :, it ) = phi1 ( 1 , ikx , :, it ) + g1k ( 1 , ikx ) / gamtot ( 1 , ikx , :) tmp = sum ( dl_over_b ( ia , :) * phi1 ( 1 , ikx , :, it )) phi1 ( 1 , ikx , :, it ) = phi1 ( 1 , ikx , :, it ) + gamtot3 ( ikx , :) * tmp end do end do deallocate ( g1k , g1x ) else if ( proc0 ) write ( * , * ) 'unknown dist option in radial_correction. aborting' call mp_abort ( 'unknown dist option in radial_correction. aborting' ) end if end if end if !> collect quasineutrality corrections in wavenumber space phi_corr_QN = phi1 !> zero out the ones we have already solved for using the full method do iky = 1 , min ( ky_solve_radial , naky ) phi_corr_QN ( iky , :, :, :) = 0.0 end do deallocate ( phi1 ) !> collect gyroaveraging corrections in wavenumber space do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) do it = 1 , ntubes do iz = - nzgrid , nzgrid call gyro_average_j1 ( phi0 (:, :, iz , it ), iz , ivmu , g0k ) g0k = - g0k * ( spec ( is )% smz ) ** 2 & * ( kperp2 (:, :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * 0.5 * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) call multiply_by_rho ( g0k ) phi_corr_GA (:, :, iz , it , ivmu ) = g0k end do end do end do deallocate ( g0k ) deallocate ( gyro_g ) end if end subroutine get_radial_correction !> rescale fields, including the distribution function subroutine rescale_fields ( target_amplitude ) use mp , only : scope , subprocs , crossdomprocs , sum_allreduce use fields_arrays , only : phi , apar use dist_fn_arrays , only : gnew , gvmu use volume_averages , only : volume_average use job_manage , only : njobs use file_utils , only : runtype_option_switch , runtype_multibox implicit none real , intent ( in ) :: target_amplitude real :: phi2 , rescale call volume_average ( phi , phi2 ) if ( runtype_option_switch == runtype_multibox ) then call scope ( crossdomprocs ) call sum_allreduce ( phi2 ) call scope ( subprocs ) phi2 = phi2 / njobs end if rescale = target_amplitude / sqrt ( phi2 ) phi = rescale * phi apar = rescale * apar gnew = rescale * gnew gvmu = rescale * gvmu end subroutine rescale_fields !> compute d<chi>/dy in (ky,kx,z,tube) space subroutine get_dchidy_4d ( phi , apar , bpar , dchidy ) use constants , only : zi use gyro_averages , only : gyro_average use gyro_averages , only : gyro_average_j1 use stella_layouts , only : vmu_lo use stella_layouts , only : is_idx , iv_idx , imu_idx use physics_flags , only : include_apar use physics_flags , only : include_bpar use run_parameters , only : fphi use species , only : spec use zgrid , only : nzgrid , ntubes use vpamu_grids , only : vpa , mu use kt_grids , only : aky , naky , nakx implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: phi , apar , bpar complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( out ) :: dchidy integer :: ivmu , iv , is , iky , imu complex , dimension (:, :, :, :), allocatable :: field , gyro_tmp allocate ( field ( naky , nakx , - nzgrid : nzgrid , ntubes )) allocate ( gyro_tmp ( naky , nakx , - nzgrid : nzgrid , ntubes )) do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) ! intermediate calculation to get factor involving phi contribution field = fphi * phi ! add apar contribution if including it if ( include_apar ) field = field - 2.0 * vpa ( iv ) * spec ( is )% stm_psi0 * apar ! take spectral y-derivative do iky = 1 , naky field ( iky , :, :, :) = zi * aky ( iky ) * field ( iky , :, :, :) end do call gyro_average ( field , ivmu , dchidy (:, :, :, :, ivmu )) if ( include_bpar ) then field = 4.0 * mu ( imu ) * ( spec ( is )% tz ) * bpar do iky = 1 , naky field ( iky , :, :, :) = zi * aky ( iky ) * field ( iky , :, :, :) end do call gyro_average_j1 ( field , ivmu , gyro_tmp ) !> include bpar contribution dchidy (:, :, :, :, ivmu ) = dchidy (:, :, :, :, ivmu ) + gyro_tmp end if end do deallocate ( field ) deallocate ( gyro_tmp ) end subroutine get_dchidy_4d !> compute d<chi>/dy in (ky,kx) space subroutine get_dchidy_2d ( iz , ivmu , phi , apar , bpar , dchidy ) use constants , only : zi use gyro_averages , only : gyro_average use gyro_averages , only : gyro_average_j1 use stella_layouts , only : vmu_lo use stella_layouts , only : is_idx , iv_idx , imu_idx use physics_flags , only : include_apar use physics_flags , only : include_bpar use run_parameters , only : fphi use species , only : spec use vpamu_grids , only : vpa , mu use kt_grids , only : nakx , aky , naky implicit none integer , intent ( in ) :: ivmu , iz complex , dimension (:, :), intent ( in ) :: phi , apar , bpar complex , dimension (:, :), intent ( out ) :: dchidy integer :: iv , is , imu complex , dimension (:, :), allocatable :: field , gyro_tmp allocate ( field ( naky , nakx )) allocate ( gyro_tmp ( naky , nakx )) is = is_idx ( vmu_lo , ivmu ) iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) field = fphi * phi if ( include_apar ) field = field - 2.0 * vpa ( iv ) * spec ( is )% stm_psi0 * apar field = zi * spread ( aky , 2 , nakx ) * field call gyro_average ( field , iz , ivmu , dchidy ) if ( include_bpar ) then field = 4.0 * mu ( imu ) * ( spec ( is )% tz ) * bpar field = zi * spread ( aky , 2 , nakx ) * field call gyro_average_j1 ( field , iz , ivmu , gyro_tmp ) !> include bpar contribution dchidy = dchidy + gyro_tmp end if deallocate ( field ) deallocate ( gyro_tmp ) end subroutine get_dchidy_2d !> compute d<chi>/dx in (ky,kx) space subroutine get_dchidx ( iz , ivmu , phi , apar , bpar , dchidx ) use constants , only : zi use gyro_averages , only : gyro_average use gyro_averages , only : gyro_average_j1 use stella_layouts , only : vmu_lo use stella_layouts , only : is_idx , iv_idx , imu_idx use physics_flags , only : include_apar use physics_flags , only : include_bpar use run_parameters , only : fphi use species , only : spec use vpamu_grids , only : vpa , mu use kt_grids , only : akx , naky , nakx implicit none integer , intent ( in ) :: ivmu , iz complex , dimension (:, :), intent ( in ) :: phi , apar , bpar complex , dimension (:, :), intent ( out ) :: dchidx integer :: iv , is , imu complex , dimension (:, :), allocatable :: field , gyro_tmp allocate ( field ( naky , nakx )) allocate ( gyro_tmp ( naky , nakx )) is = is_idx ( vmu_lo , ivmu ) iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) field = fphi * phi if ( include_apar ) field = field - 2.0 * vpa ( iv ) * spec ( is )% stm_psi0 * apar field = zi * spread ( akx , 1 , naky ) * field call gyro_average ( field , iz , ivmu , dchidx ) if ( include_bpar ) then field = 4 * mu ( imu ) * ( spec ( is )% tz ) * bpar field = zi * spread ( akx , 1 , naky ) * field call gyro_average_j1 ( field , iz , ivmu , gyro_tmp ) !> include bpar contribution dchidx = dchidx + gyro_tmp end if deallocate ( field ) deallocate ( gyro_tmp ) end subroutine get_dchidx subroutine finish_fields use fields_arrays , only : phi , phi_old use fields_arrays , only : apar , apar_old use fields_arrays , only : bpar , bpar_old use fields_arrays , only : phi_corr_QN , phi_corr_GA use fields_arrays , only : apar_corr_QN , apar_corr_GA use fields_arrays , only : gamtot , dgamtotdr , gamtot3 use fields_arrays , only : gamtot13 , gamtot33 , gamtot31 use fields_arrays , only : c_mat , theta #ifdef ISO_C_BINDING use fields_arrays , only : qn_window use mpi #else use fields_arrays , only : phi_solve #endif implicit none #ifdef ISO_C_BINDING integer ierr #endif if ( allocated ( phi )) deallocate ( phi ) if ( allocated ( phi_old )) deallocate ( phi_old ) if ( allocated ( apar )) deallocate ( apar ) if ( allocated ( apar_old )) deallocate ( apar_old ) if ( allocated ( bpar )) deallocate ( bpar ) if ( allocated ( bpar_old )) deallocate ( bpar_old ) if ( allocated ( phi_corr_QN )) deallocate ( phi_corr_QN ) if ( allocated ( phi_corr_GA )) deallocate ( phi_corr_GA ) if ( allocated ( apar_corr_QN )) deallocate ( apar_corr_QN ) if ( allocated ( apar_corr_GA )) deallocate ( apar_corr_GA ) if ( allocated ( gamtot )) deallocate ( gamtot ) if ( allocated ( gamtot3 )) deallocate ( gamtot3 ) if ( allocated ( dgamtotdr )) deallocate ( dgamtotdr ) if ( allocated ( apar_denom )) deallocate ( apar_denom ) if ( allocated ( gamtot33 )) deallocate ( gamtot33 ) if ( allocated ( gamtot13 )) deallocate ( gamtot13 ) if ( allocated ( gamtot31 )) deallocate ( gamtot31 ) #ifdef ISO_C_BINDING if ( phi_shared_window /= MPI_WIN_NULL ) call mpi_win_free ( phi_shared_window , ierr ) if ( qn_window /= MPI_WIN_NULL ) then call mpi_win_free ( qn_window , ierr ) end if #else if ( allocated ( phi_solve )) deallocate ( phi_solve ) #endif if ( allocated ( c_mat )) deallocate ( c_mat ) if ( allocated ( theta )) deallocate ( theta ) !> arrays only allocated/used if simulating a full flux surface if ( allocated ( gam0_ffs )) deallocate ( gam0_ffs ) if ( allocated ( lu_gam0_ffs )) deallocate ( lu_gam0_ffs ) if ( allocated ( adiabatic_response_factor )) deallocate ( adiabatic_response_factor ) fields_initialized = . false . end subroutine finish_fields end module fields","tags":"","loc":"sourcefile/fields.fpp.html"},{"title":"ezcdf_GenGet.f90 – stella","text":"Source Code MODULE ezcdf_GenGet USE ezcdf_opncls USE ezcdf_inqvar !DEC$ IF DEFINED (NETCDF) EXTERNAL handle_err PRIVATE include \"netcdf.inc\" INTEGER , PARAMETER :: r4 = SELECTED_REAL_KIND ( 6 , 37 ) INTEGER , PARAMETER :: r8 = SELECTED_REAL_KIND ( 12 , 100 ) CHARACTER * ( * ), PARAMETER :: cmplx_name = '__CmPlx_Re_Im' PRIVATE :: r4 , r8 , cmplx_name PUBLIC :: cdfr_3i , cdfr_3l , cdfr_3d , cdfr_3c16 , cdfr_3f , cdfr_3c8 , & & cdfr_2i , cdfr_2l , cdfr_2d , cdfr_2c16 , cdfr_2f , cdfr_2c8 , cdfr_2c , & & cdfr_1i , cdfr_1l , cdfr_1d , cdfr_1c16 , cdfr_1f , cdfr_1c8 , cdfr_1c , & & cdfr_0i , cdfr_0l , cdfr_0d , cdfr_0c16 , cdfr_0f , cdfr_0c8 , cdfGetVar , & & cdf_read ! Generic Interface to Read netcdf data Variables ! 03/10/99 C. Ludescher ! C. Ludescher/A. Pletzer Tue Apr  4 10:11:33 EDT 2000 ! + support for complex types (ap) Wed May 16 15:18:05 EDT 2001 !==================================================================== ! Generic Read Routines: cdfGetVar ! alias to cdfGetVar (ifc does not like => ) INTERFACE cdf_read MODULE PROCEDURE cdfr_3i , cdfr_3l , cdfr_3d , cdfr_3c16 , cdfr_3f , cdfr_3c8 , & cdfr_2i , cdfr_2l , cdfr_2d , cdfr_2c16 , cdfr_2f , cdfr_2c8 , cdfr_2c , & cdfr_1i , cdfr_1l , cdfr_1d , cdfr_1c16 , cdfr_1f , cdfr_1c8 , cdfr_1c , & cdfr_0i , cdfr_0l , cdfr_0d , cdfr_0c16 , cdfr_0f , cdfr_0c8 END INTERFACE ! same as above (Intel compiler does not handle well aliases) INTERFACE cdfGetVar MODULE PROCEDURE cdfr_3i , cdfr_3l , cdfr_3d , cdfr_3c16 , cdfr_3f , cdfr_3c8 , & cdfr_2i , cdfr_2l , cdfr_2d , cdfr_2c16 , cdfr_2f , cdfr_2c8 , cdfr_2c , & cdfr_1i , cdfr_1l , cdfr_1d , cdfr_1c16 , cdfr_1f , cdfr_1c8 , cdfr_1c , & cdfr_0i , cdfr_0l , cdfr_0d , cdfr_0c16 , cdfr_0f , cdfr_0c8 END INTERFACE CONTAINS !--------------------------------------------- !cdfGetVar implementation routines SUBROUTINE cdfr_3i ( ncid , varnam , varval , ier ) ! Read 3 dimensional Integer array ! implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output integer , dimension (:, :, :), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 3 ) :: ldim integer :: varid , status integer , dimension ( 3 ) :: dimlens integer , dimension (:, :, :), allocatable :: temp integer :: ndim1 , ndim2 , ndim3 if ( PRESENT ( ier )) ier = 1 ldim = shape ( varval ) call cdfgv ( ncid , varnam , varid , dimlens , ldim , 'i' , status ) if ( status /= 0 ) return ! if ( dimlens ( 1 ) == ldim ( 1 ) . and . dimlens ( 2 ) == ldim ( 2 ) . and . dimlens ( 3 ) == ldim ( 3 )) then status = nf_get_var_int ( ncid , varid , varval ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_3i' , 'nf_get_var_int' ) return end if else allocate ( temp ( dimlens ( 1 ), dimlens ( 2 ), dimlens ( 3 ))) status = nf_get_var_int ( ncid , varid , temp ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_3i' , 'nf_get_var_int' ) deallocate ( temp ) return end if ndim1 = min ( dimlens ( 1 ), ldim ( 1 )) ndim2 = min ( dimlens ( 2 ), ldim ( 2 )) ndim3 = min ( dimlens ( 3 ), ldim ( 3 )) varval ( 1 : ndim1 , 1 : ndim2 , 1 : ndim3 ) = temp ( 1 : ndim1 , 1 : ndim2 , 1 : ndim3 ) deallocate ( temp ) end if !!$  st(1) = 1 !!$  cnt(1) = min(dimlens(1),ldim(1)) ! x count !!$  cnt(2) = 1 !!$  cnt(3) = 1 !!$  do k = 1,min(dimlens(2),ldim(2)) !!$     st(2) = k !!$     do j = 1,min(dimlens(3),ldim(3)) ! For each Z : read slab in varval !!$        st(3) = j           ! Start of slab !!$        status = nf_get_vara_int(ncid,varid,st,cnt,varval(1,k,j)) !!$        if (status .ne. NF_NOERR) then !!$           call handle_err(status,varnam,'cdfr_3i',                 & !!$                &              'nf_get_vara_int') !!$           return !!$        end if !!$     end do !!$  end do if ( PRESENT ( ier )) ier = 0 END SUBROUTINE cdfr_3i SUBROUTINE cdfr_3l ( ncid , varnam , varval , ier ) ! Read 3 dimensional logical array ! implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output logical , dimension (:, :, :), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer , dimension (:, :, :), allocatable :: varval_i character * 11 , parameter :: logical_name = '__logical__' ALLOCATE ( varval_i ( size ( varval , 1 ), size ( varval , 2 ), size ( varval , 3 ))) call cdfr_3i ( ncid , trim ( varnam ) // logical_name , varval_i , ier ) WHERE ( varval_i == 0 ) varval = . false . ELSEWHERE varval = . true . END WHERE DEALLOCATE ( varval_i ) END SUBROUTINE cdfr_3l SUBROUTINE cdfr_3d ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output REAL ( KIND = r8 ), dimension (:, :, :), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 3 ) :: ldim integer :: varid , status integer , dimension ( 3 ) :: dimlens real ( r8 ), dimension (:, :, :), allocatable :: temp integer ndim1 , ndim2 , ndim3 if ( PRESENT ( ier )) ier = 1 ldim = shape ( varval ) call cdfgv ( ncid , varnam , varid , dimlens , ldim , 'd' , status ) if ( status /= 0 ) return ! if ( dimlens ( 1 ) == ldim ( 1 ) . and . dimlens ( 2 ) == ldim ( 2 ) . and . dimlens ( 3 ) == ldim ( 3 )) then status = nf_get_var_double ( ncid , varid , varval ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_3d' , 'nf_get_var_double' ) return end if else allocate ( temp ( dimlens ( 1 ), dimlens ( 2 ), dimlens ( 3 ))) status = nf_get_var_double ( ncid , varid , temp ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_3d' , 'nf_get_var_double' ) deallocate ( temp ) return end if ndim1 = min ( dimlens ( 1 ), ldim ( 1 )) ndim2 = min ( dimlens ( 2 ), ldim ( 2 )) ndim3 = min ( dimlens ( 3 ), ldim ( 3 )) varval ( 1 : ndim1 , 1 : ndim2 , 1 : ndim3 ) = temp ( 1 : ndim1 , 1 : ndim2 , 1 : ndim3 ) deallocate ( temp ) end if !!$  st(1) = 1 !!$  cnt(1) = min(dimlens(1),ldim(1)) ! x count !!$  cnt(2) = 1 !!$  cnt(3) = 1 !!$  do k = 1,min(dimlens(2),ldim(2)) !!$     st(2) = k !!$     do j = 1,min(dimlens(3),ldim(3)) ! For each Z : read slab into varval !!$        st(3) = j                      ! Start of slab !!$        status = nf_get_vara_double(ncid,varid,st,cnt,varval(1,k,j)) !!$        if (status .ne. NF_NOERR) then !!$           call handle_err(status,varnam,'cdfr_3d',                    & !!$                &           'nf_get_vara_double') !!$           return !!$        end if !!$     end do !!$  end do if ( PRESENT ( ier )) ier = 0 END SUBROUTINE cdfr_3d SUBROUTINE cdfr_3c16 ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output COMPLEX ( KIND = r8 ), dimension (:, :, :), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 3 ) :: ldim integer :: varid , status , i integer , dimension ( 3 ) :: dimlens real ( r8 ), dimension (:, :, :), allocatable :: temp integer ndim1 , ndim2 , ndim3 if ( PRESENT ( ier )) ier = 1 ldim = shape ( varval ) ldim ( 1 ) = 2 * ldim ( 1 ) ! Re/Im pairs call cdfgv ( ncid , trim ( varnam ) // cmplx_name , varid , dimlens , ldim , 'd' , status ) if ( status /= 0 ) return ! if ( dimlens ( 1 ) == ldim ( 1 ) . and . dimlens ( 2 ) == ldim ( 2 ) . and . dimlens ( 3 ) == ldim ( 3 )) then status = nf_get_var_double ( ncid , varid , varval ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_3c16' , 'nf_get_var_double' ) return end if else allocate ( temp ( dimlens ( 1 ), dimlens ( 2 ), dimlens ( 3 ))) status = nf_get_var_double ( ncid , varid , temp ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_3c16' , 'nf_get_var_double' ) deallocate ( temp ) return end if ndim1 = min ( dimlens ( 1 ), ldim ( 1 )) ndim2 = min ( dimlens ( 2 ), ldim ( 2 )) ndim3 = min ( dimlens ( 3 ), ldim ( 3 )) do i = 1 , ndim1 / 2 varval ( i , 1 : ndim2 , 1 : ndim3 ) = temp ( 2 * ( i - 1 ) + 1 , 1 : ndim2 , 1 : ndim3 ) + & & ( 0._r8 , 1._r8 ) * temp ( 2 * ( i - 1 ) + 2 , 1 : ndim2 , 1 : ndim3 ) end do deallocate ( temp ) end if !!$ !!$  st(1) = 1 !!$  cnt(1) = min(dimlens(1),ldim(1)) ! x count !!$  cnt(2) = 1 !!$  cnt(3) = 1 !!$  do k = 1,min(dimlens(2),ldim(2)) !!$     st(2) = k !!$     do j = 1,min(dimlens(3),ldim(3)) ! For each Z : read slab into varval !!$        st(3) = j                      ! Start of slab !!$        status = nf_get_vara_double(ncid,varid,st,cnt,varval(1,k,j)) !!$        if (status .ne. NF_NOERR) then !!$           call handle_err(status,varnam,'cdfr_3c16',                    & !!$                &           'nf_get_vara_double') !!$           return !!$        end if !!$     end do !!$  end do if ( PRESENT ( ier )) ier = 0 END SUBROUTINE cdfr_3c16 SUBROUTINE cdfr_3f ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output REAL ( KIND = r4 ), dimension (:, :, :), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 3 ) :: ldim integer :: varid , status integer , dimension ( 3 ) :: dimlens real , dimension (:, :, :), allocatable :: temp integer ndim1 , ndim2 , ndim3 if ( PRESENT ( ier )) ier = 1 ldim = shape ( varval ) call cdfgv ( ncid , varnam , varid , dimlens , ldim , 'r' , status ) if ( status /= 0 ) return ! if ( dimlens ( 1 ) == ldim ( 1 ) . and . dimlens ( 2 ) == ldim ( 2 ) . and . dimlens ( 3 ) == ldim ( 3 )) then status = nf_get_var_real ( ncid , varid , varval ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_3f' , 'nf_get_var_real' ) return end if else allocate ( temp ( dimlens ( 1 ), dimlens ( 2 ), dimlens ( 3 ))) status = nf_get_var_real ( ncid , varid , temp ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_3f' , 'nf_get_var_real' ) deallocate ( temp ) return end if ndim1 = min ( dimlens ( 1 ), ldim ( 1 )) ndim2 = min ( dimlens ( 2 ), ldim ( 2 )) ndim3 = min ( dimlens ( 3 ), ldim ( 3 )) varval ( 1 : ndim1 , 1 : ndim2 , 1 : ndim3 ) = temp ( 1 : ndim1 , 1 : ndim2 , 1 : ndim3 ) deallocate ( temp ) end if !!$  st(1) = 1 !!$  cnt(1) = min(dimlens(1),ldim(1)) ! x count !!$  cnt(2) = 1 !!$  cnt(3) = 1 !!$  do k = 1,min(dimlens(2),ldim(2)) !!$     st(2) = k !!$     do j = 1,min(dimlens(3),ldim(3)) ! For each Z : read slab into varval !!$        st(3) = j                      ! Start of slab !!$        status = nf_get_vara_real(ncid,varid,st,cnt,varval(1,k,j)) !!$        if (status .ne. NF_NOERR) then !!$           call handle_err(status,varnam,'cdfr_3f',                    & !!$                &           'nf_get_vara_real') !!$           return !!$        end if !!$     end do !!$  end do if ( PRESENT ( ier )) ier = 0 END SUBROUTINE cdfr_3f SUBROUTINE cdfr_3c8 ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output COMPLEX ( KIND = r4 ), dimension (:, :, :), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 3 ) :: ldim integer :: varid , status integer , dimension ( 3 ) :: dimlens real , dimension (:, :, :), allocatable :: temp integer ndim1 , ndim2 , ndim3 , i if ( PRESENT ( ier )) ier = 1 ldim = shape ( varval ) ldim ( 1 ) = 2 * ldim ( 1 ) ! Re/Im pairs call cdfgv ( ncid , trim ( varnam ) // cmplx_name , varid , dimlens , ldim , 'r' , status ) if ( status /= 0 ) return ! if ( dimlens ( 1 ) == ldim ( 1 ) . and . dimlens ( 2 ) == ldim ( 2 ) . and . dimlens ( 3 ) == ldim ( 3 )) then status = nf_get_var_real ( ncid , varid , varval ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_3c8' , 'nf_get_var_real' ) return end if else allocate ( temp ( dimlens ( 1 ), dimlens ( 2 ), dimlens ( 3 ))) status = nf_get_var_real ( ncid , varid , temp ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_3c8' , 'nf_get_var_real' ) deallocate ( temp ) return end if ndim1 = min ( dimlens ( 1 ), ldim ( 1 )) ndim2 = min ( dimlens ( 2 ), ldim ( 2 )) ndim3 = min ( dimlens ( 3 ), ldim ( 3 )) do i = 1 , ndim1 / 2 varval ( i , 1 : ndim2 , 1 : ndim3 ) = temp ( 2 * ( i - 1 ) + 1 , 1 : ndim2 , 1 : ndim3 ) + & & ( 0. , 1. ) * temp ( 2 * ( i - 1 ) + 2 , 1 : ndim2 , 1 : ndim3 ) end do deallocate ( temp ) end if !!$  st(1) = 1 !!$  cnt(1) = min(dimlens(1),ldim(1)) ! x count !!$  cnt(2) = 1 !!$  cnt(3) = 1 !!$  do k = 1,min(dimlens(2),ldim(2)) !!$     st(2) = k !!$     do j = 1,min(dimlens(3),ldim(3)) ! For each Z : read slab into varval !!$        st(3) = j                      ! Start of slab !!$        status = nf_get_vara_real(ncid,varid,st,cnt,varval(1,k,j)) !!$        if (status .ne. NF_NOERR) then !!$           call handle_err(status,varnam,'cdfr_3c8',                    & !!$                &           'nf_get_vara_real') !!$           return !!$        end if !!$     end do !!$  end do if ( PRESENT ( ier )) ier = 0 END SUBROUTINE cdfr_3c8 SUBROUTINE cdfr_2i ( ncid , varnam , varval , ier ) ! Read 2 dimensional Integer array ! implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output integer , dimension (:, :), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 2 ) :: ldim integer :: varid , status integer , dimension ( 2 ) :: dimlens integer , dimension (:, :), allocatable :: temp integer ndim1 , ndim2 if ( PRESENT ( ier )) ier = 1 ldim = shape ( varval ) call cdfgv ( ncid , varnam , varid , dimlens , ldim , 'i' , status ) if ( status /= 0 ) return ! if ( dimlens ( 1 ) == ldim ( 1 ) . and . dimlens ( 2 ) == ldim ( 2 )) then status = nf_get_var_int ( ncid , varid , varval ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_2i' , 'nf_get_var_int' ) return end if else allocate ( temp ( dimlens ( 1 ), dimlens ( 2 ))) status = nf_get_var_int ( ncid , varid , temp ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_2i' , 'nf_get_var_int' ) deallocate ( temp ) return end if ndim1 = min ( dimlens ( 1 ), ldim ( 1 )) ndim2 = min ( dimlens ( 2 ), ldim ( 2 )) varval ( 1 : ndim1 , 1 : ndim2 ) = temp ( 1 : ndim1 , 1 : ndim2 ) deallocate ( temp ) end if !!$  st(1) = 1 !!$  cnt(1) = min(dimlens(1),ldim(1)) ! x count !!$  cnt(2) = 1 !!$  do j = 1,min(dimlens(2),ldim(2)) ! For each Y : read slab into varval !!$     st(2) = j              ! Start of slab !!$     status = nf_get_vara_int(ncid,varid,st,cnt,varval(1,j)) !!$     if (status .ne. NF_NOERR) then !!$        call handle_err(status,varnam,'cdfr_2i',                    & !!$             &           'nf_get_vara_int') !!$        return !!$     end if !!$  end do if ( PRESENT ( ier )) ier = 0 END SUBROUTINE cdfr_2i SUBROUTINE cdfr_2l ( ncid , varnam , varval , ier ) ! Read 2 dimensional logical array ! implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output logical , dimension (:, :), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer , dimension (:, :), allocatable :: varval_i character * 11 , parameter :: logical_name = '__logical__' ALLOCATE ( varval_i ( size ( varval , 1 ), size ( varval , 2 ))) call cdfr_2i ( ncid , trim ( varnam ) // logical_name , varval_i , ier ) WHERE ( varval_i == 0 ) varval = . false . ELSEWHERE varval = . true . END WHERE DEALLOCATE ( varval_i ) END SUBROUTINE cdfr_2l SUBROUTINE cdfr_2d ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output REAL ( KIND = r8 ), dimension (:, :), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 2 ) :: ldim integer :: varid , status integer , dimension ( 2 ) :: dimlens real ( r8 ), dimension (:, :), allocatable :: temp integer ndim1 , ndim2 if ( PRESENT ( ier )) ier = 1 ldim = shape ( varval ) call cdfgv ( ncid , varnam , varid , dimlens , ldim , 'd' , status ) if ( status /= 0 ) return ! if ( dimlens ( 1 ) == ldim ( 1 ) . and . dimlens ( 2 ) == ldim ( 2 )) then status = nf_get_var_double ( ncid , varid , varval ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_2d' , 'nf_get_var_double' ) return end if else allocate ( temp ( dimlens ( 1 ), dimlens ( 2 ))) status = nf_get_var_double ( ncid , varid , temp ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_2d' , 'nf_get_var_double' ) deallocate ( temp ) return end if ndim1 = min ( dimlens ( 1 ), ldim ( 1 )) ndim2 = min ( dimlens ( 2 ), ldim ( 2 )) varval ( 1 : ndim1 , 1 : ndim2 ) = temp ( 1 : ndim1 , 1 : ndim2 ) deallocate ( temp ) end if !!$  st(1) = 1 !!$  cnt(1) = min(dimlens(1),ldim(1)) ! x count !!$  cnt(2) = 1 !!$  do j = 1,min(dimlens(2),ldim(2)) ! For each Y : read slab into varval !!$     st(2) = j              ! Start of slab !!$     status = nf_get_vara_double(ncid,varid,st,cnt,varval(1,j)) !!$     if (status .ne. NF_NOERR) then !!$        call handle_err(status,varnam,'cdfr_2d',                    & !!$             &           'nf_get_vara_double') !!$        return !!$     end if !!$  end do if ( PRESENT ( ier )) ier = 0 END SUBROUTINE cdfr_2d SUBROUTINE cdfr_2c16 ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output COMPLEX ( KIND = r8 ), dimension (:, :), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 2 ) :: ldim integer :: varid , status , i integer , dimension ( 2 ) :: dimlens real ( r8 ), dimension (:, :), allocatable :: temp integer ndim1 , ndim2 if ( PRESENT ( ier )) ier = 1 ldim = shape ( varval ) ldim ( 1 ) = 2 * ldim ( 1 ) ! Re/Im pairs call cdfgv ( ncid , trim ( varnam ) // cmplx_name , varid , dimlens , ldim , 'd' , status ) if ( status /= 0 ) return ! if ( dimlens ( 1 ) == ldim ( 1 ) . and . dimlens ( 2 ) == ldim ( 2 )) then status = nf_get_var_double ( ncid , varid , varval ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_2c16' , 'nf_get_var_double' ) return end if else allocate ( temp ( dimlens ( 1 ), dimlens ( 2 ))) status = nf_get_var_double ( ncid , varid , temp ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_2c16' , 'nf_get_var_double' ) deallocate ( temp ) return end if ndim1 = min ( dimlens ( 1 ), ldim ( 1 )) ndim2 = min ( dimlens ( 2 ), ldim ( 2 )) do i = 1 , ndim1 / 2 varval ( i , 1 : ndim2 ) = temp ( 2 * ( i - 1 ) + 1 , 1 : ndim2 ) + & & ( 0._r8 , 1._r8 ) * temp ( 2 * ( i - 1 ) + 2 , 1 : ndim2 ) end do deallocate ( temp ) end if !!$  st(1) = 1 !!$  cnt(1) = min(dimlens(1),ldim(1)) ! x count !!$  cnt(2) = 1 !!$  do j = 1,min(dimlens(2),ldim(2)) ! For each Y : read slab into varval !!$     st(2) = j              ! Start of slab !!$     status = nf_get_vara_double(ncid,varid,st,cnt,varval(1,j)) !!$     if (status .ne. NF_NOERR) then !!$        call handle_err(status,varnam,'cdfr_2c16',                    & !!$             &           'nf_get_vara_double') !!$        return !!$     end if !!$  end do if ( PRESENT ( ier )) ier = 0 END SUBROUTINE cdfr_2c16 SUBROUTINE cdfr_2f ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output REAL ( KIND = r4 ), dimension (:, :), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 2 ) :: ldim integer :: varid , status integer , dimension ( 2 ) :: dimlens real , dimension (:, :), allocatable :: temp integer ndim1 , ndim2 if ( PRESENT ( ier )) ier = 1 ldim = shape ( varval ) call cdfgv ( ncid , varnam , varid , dimlens , ldim , 'r' , status ) if ( status /= 0 ) return ! if ( dimlens ( 1 ) == ldim ( 1 ) . and . dimlens ( 2 ) == ldim ( 2 )) then status = nf_get_var_real ( ncid , varid , varval ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_2f' , 'nf_get_var_real' ) return end if else allocate ( temp ( dimlens ( 1 ), dimlens ( 2 ))) status = nf_get_var_real ( ncid , varid , temp ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_2f' , 'nf_get_var_real' ) deallocate ( temp ) return end if ndim1 = min ( dimlens ( 1 ), ldim ( 1 )) ndim2 = min ( dimlens ( 2 ), ldim ( 2 )) varval ( 1 : ndim1 , 1 : ndim2 ) = temp ( 1 : ndim1 , 1 : ndim2 ) deallocate ( temp ) end if !!$  st(1) = 1 !!$  cnt(1) = min(dimlens(1),ldim(1)) ! x count !!$  cnt(2) = 1 !!$  do j = 1,min(dimlens(2),ldim(2)) ! For each Y : read slab into varval !!$     st(2) = j              ! Start of slab !!$     status = nf_get_vara_real(ncid,varid,st,cnt,varval(1,j)) !!$     if (status .ne. NF_NOERR) then !!$        call handle_err(status,varnam,'cdfr_2f',                    & !!$             &           'nf_get_vara_real') !!$        return !!$     end if !!$  end do if ( PRESENT ( ier )) ier = 0 END SUBROUTINE cdfr_2f SUBROUTINE cdfr_2c8 ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output COMPLEX ( KIND = r4 ), dimension (:, :), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 2 ) :: ldim integer :: varid , status , i integer , dimension ( 2 ) :: dimlens real ( r8 ), dimension (:, :), allocatable :: temp integer ndim1 , ndim2 if ( PRESENT ( ier )) ier = 1 ldim = shape ( varval ) ldim ( 1 ) = 2 * ldim ( 1 ) ! Re/Pairs call cdfgv ( ncid , trim ( varnam ) // cmplx_name , varid , dimlens , ldim , 'r' , status ) if ( status /= 0 ) return ! if ( dimlens ( 1 ) == ldim ( 1 ) . and . dimlens ( 2 ) == ldim ( 2 )) then status = nf_get_var_real ( ncid , varid , varval ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_2c8' , 'nf_get_var_real' ) return end if else allocate ( temp ( dimlens ( 1 ), dimlens ( 2 ))) status = nf_get_var_real ( ncid , varid , temp ) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_2c8' , 'nf_get_var_real' ) deallocate ( temp ) return end if ndim1 = min ( dimlens ( 1 ), ldim ( 1 )) ndim2 = min ( dimlens ( 2 ), ldim ( 2 )) do i = 1 , ndim1 / 2 varval ( i , 1 : ndim2 ) = temp ( 2 * ( i - 1 ) + 1 , 1 : ndim2 ) + & & ( 0. , 1. ) * temp ( 2 * ( i - 1 ) + 2 , 1 : ndim2 ) end do deallocate ( temp ) end if !!$  st(1) = 1 !!$  cnt(1) = min(dimlens(1),ldim(1)) ! x count !!$  cnt(2) = 1 !!$  do j = 1,min(dimlens(2),ldim(2)) ! For each Y : read slab into varval !!$     st(2) = j              ! Start of slab !!$     status = nf_get_vara_real(ncid,varid,st,cnt,varval(1,j)) !!$     if (status .ne. NF_NOERR) then !!$        call handle_err(status,varnam,'cdfr_2c8',                    & !!$             &           'nf_get_vara_real') !!$        return !!$     end if !!$  end do if ( PRESENT ( ier )) ier = 0 END SUBROUTINE cdfr_2c8 SUBROUTINE cdfr_2c ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output character * ( * ), dimension (:), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer , dimension ( 2 ) :: st , cnt , ldim integer :: varid , status , j integer , dimension ( 2 ) :: dimlens if ( PRESENT ( ier )) ier = 1 ldim ( 1 ) = len ( varval ) ldim ( 2 ) = size ( varval ) call cdfgv ( ncid , varnam , varid , dimlens , ldim , 'c' , status ) if ( status /= 0 ) return ! st ( 1 ) = 1 cnt ( 1 ) = min ( dimlens ( 1 ), ldim ( 1 )) ! x count cnt ( 2 ) = 1 do j = 1 , min ( dimlens ( 2 ), ldim ( 2 )) ! For each Y : read slab into varval st ( 2 ) = j ! Start of slab status = nf_get_vara_text ( ncid , varid , st , cnt , varval ( j )) if ( status /= NF_NOERR ) then call handle_err ( status , varnam , 'cdfr_2c' , & & 'nf_get_var_text' ) return end if end do if ( PRESENT ( ier )) ier = 0 END SUBROUTINE cdfr_2c SUBROUTINE cdfr_1i ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output integer , dimension (:), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer :: varid , status integer , dimension ( 1 ) :: dimlens , ldim if ( PRESENT ( ier )) ier = 1 ldim = shape ( varval ) call cdfgv ( ncid , varnam , varid , dimlens , ldim , 'i' , status ) if ( status /= 0 ) return ! status = nf_get_var_int ( ncid , varid , varval ) call handle_err ( status , varnam , 'cdfr_1i' , 'nf_get_var_int' ) if ( PRESENT ( ier )) ier = status END SUBROUTINE cdfr_1i SUBROUTINE cdfr_1l ( ncid , varnam , varval , ier ) ! Read 1 dimensional logical array ! implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output logical , dimension (:), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer , dimension (:), allocatable :: varval_i character * 11 , parameter :: logical_name = '__logical__' ALLOCATE ( varval_i ( size ( varval , 1 ))) call cdfr_1i ( ncid , trim ( varnam ) // logical_name , varval_i , ier ) WHERE ( varval_i == 0 ) varval = . false . ELSEWHERE varval = . true . END WHERE DEALLOCATE ( varval_i ) END SUBROUTINE cdfr_1l SUBROUTINE cdfr_1d ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output REAL ( KIND = r8 ), dimension (:), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer :: varid , status integer , dimension ( 1 ) :: dimlens , ldim if ( PRESENT ( ier )) ier = 1 ldim = shape ( varval ) call cdfgv ( ncid , varnam , varid , dimlens , ldim , 'd' , status ) if ( status /= 0 ) return ! status = nf_get_var_double ( ncid , varid , varval ) call handle_err ( status , varnam , 'cdfr_1d' , 'nf_get_var_double' ) if ( PRESENT ( ier )) ier = status END SUBROUTINE cdfr_1d SUBROUTINE cdfr_1c16 ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output COMPLEX ( KIND = r8 ), dimension (:), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer :: varid , status integer , dimension ( 1 ) :: dimlens , ldim if ( PRESENT ( ier )) ier = 1 ldim = shape ( varval ) ldim ( 1 ) = 2 * ldim ( 1 ) ! Re/Im pairs call cdfgv ( ncid , trim ( varnam ) // cmplx_name , varid , dimlens , ldim , 'd' , status ) if ( status /= 0 ) return ! status = nf_get_var_double ( ncid , varid , varval ) call handle_err ( status , varnam , 'cdfr_1c16' , 'nf_get_var_double' ) if ( PRESENT ( ier )) ier = status END SUBROUTINE cdfr_1c16 SUBROUTINE cdfr_1f ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output REAL ( KIND = r4 ), dimension (:), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer :: varid , status integer , dimension ( 1 ) :: dimlens , ldim if ( PRESENT ( ier )) ier = 1 ldim = shape ( varval ) call cdfgv ( ncid , varnam , varid , dimlens , ldim , 'r' , status ) if ( status /= 0 ) return ! status = nf_get_var_real ( ncid , varid , varval ) call handle_err ( status , varnam , 'cdfr_1f' , 'nf_get_var_real' ) if ( PRESENT ( ier )) ier = status END SUBROUTINE cdfr_1f SUBROUTINE cdfr_1c8 ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output COMPLEX ( KIND = r4 ), dimension (:), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer :: varid , status integer , dimension ( 1 ) :: dimlens , ldim if ( PRESENT ( ier )) ier = 1 ldim = shape ( varval ) ldim ( 1 ) = 2 * ldim ( 1 ) call cdfgv ( ncid , trim ( varnam ) // cmplx_name , varid , dimlens , ldim , 'r' , status ) if ( status /= 0 ) return ! status = nf_get_var_real ( ncid , varid , varval ) call handle_err ( status , varnam , 'cdfr_1c8' , 'nf_get_var_real' ) if ( PRESENT ( ier )) ier = status END SUBROUTINE cdfr_1c8 SUBROUTINE cdfr_1c ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output character * ( * ), intent ( inout ) :: varval integer , optional , intent ( out ) :: ier ! Local integer :: varid , status integer , dimension ( 1 ) :: dimlens , ldim if ( PRESENT ( ier )) ier = 1 ldim ( 1 ) = len ( varval ) call cdfgv ( ncid , varnam , varid , dimlens , ldim , 'c' , status ) if ( status /= 0 ) return ! status = nf_get_var_text ( ncid , varid , varval ) call handle_err ( status , varnam , 'cdfr_1c' , 'nf_get_var_text' ) if ( PRESENT ( ier )) ier = status END SUBROUTINE cdfr_1c SUBROUTINE cdfr_0i ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output integer , intent ( out ) :: varval integer , optional , intent ( out ) :: ier ! Local integer :: varid , status integer , dimension ( 1 ) :: dimlens , ldim if ( PRESENT ( ier )) ier = 1 ldim ( 1 ) = 0 call cdfgv ( ncid , varnam , varid , dimlens , ldim , 'i' , status ) if ( status /= 0 ) return ! status = nf_get_var_int ( ncid , varid , varval ) call handle_err ( status , varnam , 'cdfr_0i' , 'nf_get_var_int' ) if ( PRESENT ( ier )) ier = status END SUBROUTINE cdfr_0i SUBROUTINE cdfr_0l ( ncid , varnam , varval , ier ) ! Read scalar logical array ! implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output logical , intent ( out ) :: varval integer , optional , intent ( out ) :: ier ! Local integer :: varval_i character * 11 , parameter :: logical_name = '__logical__' varval_i = 0 call cdfr_0i ( ncid , trim ( varnam ) // logical_name , varval_i , ier ) IF ( varval_i == 0 ) THEN varval = . false . ELSE varval = . true . END IF END SUBROUTINE cdfr_0l SUBROUTINE cdfr_0d ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output REAL ( KIND = r8 ), intent ( out ) :: varval integer , optional , intent ( out ) :: ier ! Local integer :: varid , status integer , dimension ( 1 ) :: dimlens , ldim if ( PRESENT ( ier )) ier = 1 ldim ( 1 ) = 0 call cdfgv ( ncid , varnam , varid , dimlens , ldim , 'd' , status ) if ( status /= 0 ) return ! status = nf_get_var_double ( ncid , varid , varval ) call handle_err ( status , varnam , 'cdfr_0d' , 'nf_get_var_double' ) if ( PRESENT ( ier )) ier = status END SUBROUTINE cdfr_0d SUBROUTINE cdfr_0c16 ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output COMPLEX ( KIND = r8 ), intent ( out ) :: varval integer , optional , intent ( out ) :: ier ! Local integer :: varid , status integer , dimension ( 1 ) :: dimlens , ldim if ( PRESENT ( ier )) ier = 1 ldim ( 1 ) = 2 ! Re/Im pair call cdfgv ( ncid , trim ( varnam ) // cmplx_name , varid , dimlens , ldim , 'd' , status ) if ( status /= 0 ) return ! status = nf_get_var_double ( ncid , varid , varval ) call handle_err ( status , varnam , 'cdfr_0d' , 'nf_get_var_double' ) if ( PRESENT ( ier )) ier = status END SUBROUTINE cdfr_0c16 SUBROUTINE cdfr_0f ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output REAL ( KIND = r4 ), intent ( out ) :: varval integer , optional , intent ( out ) :: ier ! Local integer :: varid , status integer , dimension ( 1 ) :: dimlens , ldim if ( PRESENT ( ier )) ier = 1 ldim ( 1 ) = 0 call cdfgv ( ncid , varnam , varid , dimlens , ldim , 'r' , status ) if ( status /= 0 ) return ! status = nf_get_var_real ( ncid , varid , varval ) call handle_err ( status , varnam , 'cdfr_0f' , 'nf_get_var_real' ) if ( PRESENT ( ier )) ier = status END SUBROUTINE cdfr_0f SUBROUTINE cdfr_0c8 ( ncid , varnam , varval , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output COMPLEX ( KIND = r4 ), intent ( out ) :: varval integer , optional , intent ( out ) :: ier ! Local integer :: varid , status integer , dimension ( 1 ) :: dimlens , ldim if ( PRESENT ( ier )) ier = 1 ldim ( 1 ) = 2 ! Re/Im pair call cdfgv ( ncid , trim ( varnam ) // cmplx_name , varid , dimlens , ldim , 'r' , status ) if ( status /= 0 ) return ! status = nf_get_var_real ( ncid , varid , varval ) call handle_err ( status , varnam , 'cdfr_0f' , 'nf_get_var_real' ) if ( PRESENT ( ier )) ier = status END SUBROUTINE cdfr_0c8 !DEC$ ENDIF END MODULE ezcdf_GenGet","tags":"","loc":"sourcefile/ezcdf_genget.f90.html"},{"title":"netcdf_utils.fpp – stella","text":"Source Code # include \"define.inc\" module netcdf_utils # ifdef NETCDF use netcdf , only : NF90_FLOAT , NF90_DOUBLE use netcdf , only : NF90_NOWRITE , NF90_CLOBBER , NF90_NOERR use netcdf , only : nf90_strerror use netcdf , only : nf90_inquire_variable use netcdf , only : nf90_inquire_dimension use netcdf , only : nf90_open , nf90_close use netcdf , only : nf90_inq_varid use netcdf , only : NF90_INT # endif implicit none public :: netcdf_error public :: get_netcdf_code_precision public :: check_netcdf_file_precision public :: netcdf_real , kind_nf , netcdf_int private # ifdef NETCDF integer , parameter :: kind_nf = kind ( NF90_NOERR ) # else integer , parameter :: kind_nf = kind ( 1 ) # endif integer ( kind_nf ) :: netcdf_real = 0 , netcdf_int = 0 logical :: test = . false . contains function get_netcdf_code_precision () result ( code_real ) use constants , only : pi , kind_rs , kind_rd use file_utils , only : error_unit integer :: code_real # ifdef NETCDF ! second condition for Cray if (( kind ( pi ) == kind_rs ) . or . ( kind_rs == kind_rd )) then code_real = NF90_FLOAT else if ( kind ( pi ) == kind_rd ) then code_real = NF90_DOUBLE else write ( error_unit (), * ) & 'ERROR: precision mismatch in get_netcdf_code_precision' end if # endif end function get_netcdf_code_precision subroutine check_netcdf_file_precision ( ncid , filename ) use file_utils , only : error_unit integer ( kind_nf ), intent ( in ), optional :: ncid character ( * ), intent ( in ), optional :: filename # ifdef NETCDF integer ( kind_nf ) :: file_real integer ( kind_nf ) :: ist , ncid_private , tid integer :: ierr !SET integer type: NOTE: This is not checked for compatability!!!! GGH 20 JAN 2012 netcdf_int = NF90_INT ist = NF90_NOERR file_real = - 1 if ( present ( ncid )) then if ( present ( filename )) then ierr = error_unit () write ( ierr , * ) 'WARNING: in calling check_netcdf_file_precision' write ( ierr , * ) & 'WARNING: both filename and ncid given -- filename ignored' end if ncid_private = ncid else if ( present ( filename )) then ist = nf90_open ( filename , NF90_NOWRITE , ncid_private ) if ( test ) write ( error_unit (), * ) & 'opened netcdf file ' , trim ( filename ), ' with ncid: ' , & ncid_private , ' in check_netcdf_file_precision' if ( ist /= NF90_NOERR ) then call netcdf_error ( ist , file = filename ) return end if else ierr = error_unit () write ( ierr , * ) 'ERROR: in calling check_netcdf_file_precision' write ( ierr , * ) 'ERROR: either filename or ncid should be given' return end if end if ist = nf90_inq_varid ( ncid_private , 't0' , tid ) if ( ist /= NF90_NOERR ) call netcdf_error ( ist , var = 't0' ) ! get file_real if ( ist == NF90_NOERR ) then ist = nf90_inquire_variable ( ncid_private , tid , xtype = file_real ) if ( ist /= NF90_NOERR ) call netcdf_error ( ist , ncid_private , tid ) end if if (. not . present ( ncid )) then ist = nf90_close ( ncid_private ) if ( ist /= NF90_NOERR ) call netcdf_error ( ist , file = filename ) end if ! check if file_real == code_real if ( file_real /= netcdf_real ) then ierr = error_unit () write ( ierr , * ) 'WARNING: precision mismatch in input netcdf file and running code' if ( file_real == NF90_FLOAT ) then write ( ierr , * ) 'WARNING: file_real = NF90_FLOAT' else if ( file_real == NF90_DOUBLE ) then write ( ierr , * ) 'WARNING: file_real = NF90_DOUBLE' else write ( ierr , * ) 'WARNING: unknown file_real' , file_real end if if ( netcdf_real == NF90_FLOAT ) then write ( ierr , * ) 'WARNING: code_real = NF90_FLOAT' else if ( netcdf_real == NF90_DOUBLE ) then write ( ierr , * ) 'WARNING: code_real = NF90_DOUBLE' else write ( ierr , * ) 'WARNING: unknown code_real' end if end if # endif end subroutine check_netcdf_file_precision subroutine netcdf_error & ( istatus , ncid , varid , dimid , file , dim , var , att , message , abort ) use file_utils , only : error_unit use mp , only : proc0 , finish_mp # ifdef NETCDF use netcdf , only : NF90_GLOBAL # endif integer ( kind_nf ), intent ( in ) :: istatus integer ( kind_nf ), intent ( in ), optional :: ncid integer ( kind_nf ), intent ( in ), optional :: varid integer ( kind_nf ), intent ( in ), optional :: dimid character ( * ), intent ( in ), optional :: file character ( * ), intent ( in ), optional :: dim character ( * ), intent ( in ), optional :: var character ( * ), intent ( in ), optional :: att character ( * ), intent ( in ), optional :: message logical , intent ( in ), optional :: abort # ifdef NETCDF integer ( kind_nf ) :: ist integer :: ierr character ( 20 ) :: varname , dimname ierr = error_unit () write ( ierr , '(2a)' , advance = 'no' ) 'ERROR: ' , trim ( nf90_strerror ( istatus )) ! TT: If $ control fails, there is an alternative advance='no' specifier if ( present ( file )) & write ( ierr , '(2a)' , advance = 'no' ) ' in file: ' , trim ( file ) if ( present ( dim )) & write ( ierr , '(2a)' , advance = 'no' ) ' in dimension: ' , trim ( dim ) if ( present ( var )) & write ( ierr , '(2a)' , advance = 'no' ) ' in variable: ' , trim ( var ) if ( present ( varid )) then if ( present ( ncid )) then if (( varid == NF90_GLOBAL ) . and . present ( att )) then write ( ierr , '(2a)' ) ' in global attribute: ' , trim ( att ) return else ist = nf90_inquire_variable ( ncid , varid , varname ) if ( ist == NF90_NOERR ) then write ( ierr , '(a,i8,2a)' , advance = 'no' ) ' in varid: ' , varid , & & ' variable name: ' , trim ( varname ) else write ( ierr , * ) write ( ierr , '(3a,i8,a,i8)' , advance = 'no' ) 'ERROR in netcdf_error: ' , & trim ( nf90_strerror ( ist )), ' in varid: ' , varid , & ', ncid: ' , ncid end if end if if ( present ( att )) & write ( ierr , '(2a)' ) ' with the attribute: ' , trim ( att ) else write ( ierr , * ) write ( ierr , '(2a)' , advance = 'no' ) 'ERROR in netcdf_error: ' , & & 'ncid missing while varid present in the argument' end if end if if ( present ( dimid )) then if ( present ( ncid )) then ist = nf90_inquire_dimension ( ncid , dimid , dimname ) if ( ist == NF90_NOERR ) then write ( ierr , '(a,i8,2a)' , advance = 'no' ) ' in dimid: ' , dimid , & & ' dimension name: ' , trim ( dimname ) else write ( ierr , * ) write ( ierr , '(3a,i8,a,i8)' , advance = 'no' ) 'ERROR in netcdf_error: ' , & trim ( nf90_strerror ( ist )), ' in dimid: ' , dimid , & ', ncid: ' , ncid end if else write ( ierr , * ) write ( ierr , '(2a)' , advance = 'no' ) 'ERROR in netcdf_error: ' , & & 'ncid missing while dimid present in the argument' end if end if if ( present ( message )) write ( ierr , '(a)' , advance = 'no' ) trim ( message ) ! append line-break write ( ierr , * ) ! if error is detected, the program should abort immediately if ( present ( abort )) then if ( abort ) then call finish_mp if ( proc0 ) stop 'Aborted by netcdf_error' stop end if end if # endif end subroutine netcdf_error end module netcdf_utils","tags":"","loc":"sourcefile/netcdf_utils.fpp.html"},{"title":"dissipation.f90 – stella","text":"Source Code module dissipation implicit none public :: read_parameters public :: init_dissipation , finish_dissipation public :: init_collisions , collisions_initialized public :: advance_collisions_explicit , advance_collisions_implicit public :: include_collisions public :: hyper_dissipation public :: collisions_implicit public :: cfl_dt_mudiff , cfl_dt_vpadiff public :: time_collisions private logical :: collisions_initialized = . false . logical :: include_collisions logical :: collisions_implicit logical :: hyper_dissipation character ( 30 ) :: collision_model real :: cfl_dt_mudiff = huge ( 0.0 ), cfl_dt_vpadiff = huge ( 0.0 ) real , dimension ( 2 , 2 ) :: time_collisions = 0. contains subroutine init_dissipation use mp , only : proc0 use hyper , only : init_hyper implicit none call read_parameters if ( proc0 ) then write ( * , '(A)' ) \"############################################################\" write ( * , '(A)' ) \"                         COLLISIONS\" write ( * , '(A)' ) \"############################################################\" if ( include_collisions ) then if ( collision_model == \"dougherty\" ) then write ( * , * ) write ( * , * ) 'Coll. model:     Dougherty' if ( collisions_implicit ) then write ( * , * ) 'Coll. algorithm: implicit' else write ( * , * ) 'Coll. algorithm: explicit' end if else if ( collision_model == \"fokker-planck\" ) then write ( * , * ) 'Coll. model:     Fokker-Planck' if ( collisions_implicit ) then write ( * , * ) 'Coll. algorithm: implicit' else write ( * , * ) 'Coll. algorithm: explicit' end if end if write ( * , * ) else write ( * , * ) 'Coll. model:     None' write ( * , * ) end if end if if ( hyper_dissipation ) then call init_hyper end if end subroutine init_dissipation subroutine read_parameters use file_utils , only : input_unit_exist use mp , only : proc0 , broadcast use run_parameters , only : fully_explicit use coll_dougherty , only : read_parameters_dougherty use coll_fokkerplanck , only : read_parameters_fp use hyper , only : read_parameters_hyper implicit none namelist / dissipation / include_collisions , collisions_implicit , collision_model , hyper_dissipation integer :: in_file logical :: dexist if ( proc0 ) then include_collisions = . false . collisions_implicit = . true . collision_model = \"dougherty\" ! dougherty or fokker-planck hyper_dissipation = . false . in_file = input_unit_exist ( \"dissipation\" , dexist ) if ( dexist ) read ( unit = in_file , nml = dissipation ) end if call broadcast ( include_collisions ) call broadcast ( collisions_implicit ) call broadcast ( collision_model ) call broadcast ( hyper_dissipation ) if (. not . include_collisions ) collisions_implicit = . false . if ( include_collisions ) then if ( collision_model == \"dougherty\" ) then call read_parameters_dougherty else if ( collision_model == \"fokker-planck\" ) then call read_parameters_fp end if end if if ( hyper_dissipation ) then call read_parameters_hyper fully_explicit = . false . end if end subroutine read_parameters subroutine init_collisions use coll_dougherty , only : init_collisions_dougherty use coll_fokkerplanck , only : init_collisions_fp implicit none if ( collisions_initialized ) return collisions_initialized = . true . if ( collision_model == \"dougherty\" ) then call init_collisions_dougherty ( collisions_implicit , cfl_dt_vpadiff , cfl_dt_mudiff ) else if ( collision_model == \"fokker-planck\" ) then call init_collisions_fp ( collisions_implicit , cfl_dt_vpadiff , cfl_dt_mudiff ) end if end subroutine init_collisions subroutine finish_dissipation implicit none call finish_collisions end subroutine finish_dissipation subroutine finish_collisions use coll_dougherty , only : finish_collisions_dougherty use coll_fokkerplanck , only : finish_collisions_fp implicit none if ( collision_model == \"dougherty\" ) then call finish_collisions_dougherty else if ( collision_model == \"fokker-planck\" ) then call finish_collisions_fp end if collisions_initialized = . false . end subroutine finish_collisions subroutine advance_collisions_explicit ( g , phi , bpar , gke_rhs ) use mp , only : mp_abort use physics_flags , only : full_flux_surface use stella_layouts , only : vmu_lo use zgrid , only : nzgrid use coll_dougherty , only : advance_collisions_dougherty_explicit use coll_fokkerplanck , only : advance_collisions_fp_explicit implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: phi , bpar complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: gke_rhs if ( full_flux_surface ) then call mp_abort ( \"collisions not currently supported for full_flux_surface=T.  Aborting.\" ) end if if ( collision_model == \"dougherty\" ) then call advance_collisions_dougherty_explicit ( g , phi , bpar , gke_rhs , time_collisions ) else if ( collision_model == \"fokker-planck\" ) then call advance_collisions_fp_explicit ( g , phi , bpar , gke_rhs , time_collisions ) end if end subroutine advance_collisions_explicit subroutine advance_collisions_implicit ( mirror_implicit , phi , apar , bpar , g ) use mp , only : proc0 use redistribute , only : gather , scatter use dist_redistribute , only : kxkyz2vmu use job_manage , only : time_message use zgrid , only : nzgrid use vpamu_grids , only : set_vpa_weights use stella_layouts , only : vmu_lo use dist_fn_arrays , only : gvmu use coll_dougherty , only : advance_collisions_dougherty_implicit use coll_fokkerplanck , only : advance_collisions_fp_implicit implicit none logical , intent ( in ) :: mirror_implicit complex , dimension (:, :, - nzgrid :, :), intent ( in out ) :: phi , apar , bpar complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: g logical :: conservative_wgts if ( proc0 ) call time_message (. false ., time_collisions (:, 1 ), ' collisions' ) !> switch the vpa integration weights to ensure correct integration by parts conservative_wgts = . true . call set_vpa_weights ( conservative_wgts ) if ( proc0 ) call time_message (. false ., time_collisions (:, 2 ), ' coll_redist' ) call scatter ( kxkyz2vmu , g , gvmu ) if ( proc0 ) call time_message (. false ., time_collisions (:, 2 ), ' coll_redist' ) if ( collision_model == \"dougherty\" ) then call advance_collisions_dougherty_implicit ( phi , apar , bpar ) else if ( collision_model == \"fokker-planck\" ) then call advance_collisions_fp_implicit ( phi , apar , bpar ) end if if (. not . mirror_implicit ) then ! then take the results and remap again so ky,kx,z local. if ( proc0 ) call time_message (. false ., time_collisions (:, 2 ), ' coll_redist' ) call gather ( kxkyz2vmu , gvmu , g ) if ( proc0 ) call time_message (. false ., time_collisions (:, 2 ), ' coll_redist' ) end if conservative_wgts = . false . call set_vpa_weights ( conservative_wgts ) if ( proc0 ) call time_message (. false ., time_collisions (:, 1 ), ' collisions' ) end subroutine advance_collisions_implicit end module dissipation","tags":"","loc":"sourcefile/dissipation.f90.html"},{"title":"fitpack.f – stella","text":"Source Code !From inet!cs.utexas.edu!cline Tue Oct 31 17:10:31 CST 1989 !Received: from mojave.cs.utexas.edu by cs.utexas.edu (5.59/1.44) !\tid AA29509; Tue, 31 Oct 89 17:11:51 CST !Posted-Date: Tue, 31 Oct 89 17:10:31 CST !Message-Id: <8910312310.AA04442@mojave.cs.utexas.edu> !Received: by mojave.cs.utexas.edu (14.5/1.4-Client) !\tid AA04442; Tue, 31 Oct 89 17:10:34 cst !Date: Tue, 31 Oct 89 17:10:31 CST !X-Mailer: Mail User's Shell (6.5 4/17/89) !From: cline@cs.utexas.edu (Alan Cline) !To: ehg@research.att.com !Subject: New FITPACK Subset for netlib !This new version of FITPACK distributed by netlib is about 20% of !the total package in terms of characters, lines of code, and num- !ber of subprograms. However, these 25 subprograms represent about !95% of usages of the package.  What has been omitted are such ca- !pabilities as: !  1. Automatic tension determination, !  2. Derivatives, arclengths, and enclosed areas for planar !     curves, !  3. Three dimensional curves, !  4. Special surface fitting using equispacing assumptions, !  5. Surface fitting in annular, wedge, polar, toroidal, lunar, !     and spherical geometries, !  6. B-splines in tension generation and usage, !  7. General surface fitting in three dimensional space. !(The code previously circulated in netlib is less than 10% of the !total  package  and is more than a decade old.  Its usage is dis- !couraged.) !Please note:  Two versions of the subroutine snhcsh are included. !Both serve the same purpose:  obtaining approximations to certain !hyperbolic trigonometric-like functions.  The first is less accu- !rate (but more efficient) than the second.  Installers should se- !lect the one with the precision they desire. !Interested parties can obtain the entire package on disk or  tape !from Pleasant  Valley Software, 8603 Altus Cove, Austin TX (USA), !78759 at a cost of $495 US. A 340 page manual  is  available  for ! $30  US  per  copy.  The  package  includes  examples and machine !readable documentation. subroutine curv1 ( n , x , y , slp1 , slpn , islpsw , yp , temp , * sigma , ierr ) c integer n , islpsw , ierr real x ( n ), y ( n ), slp1 , slpn , yp ( n ), temp ( n ), sigma c c                                 coded by alan kaylor cline c                           from fitpack -- january 26, 1987 c                        a curve and surface fitting package c                      a product of pleasant valley software c                  8603 altus cove, austin, texas 78759, usa c c this subroutine determines the parameters necessary to c compute an interpolatory spline under tension through c a sequence of functional values. the slopes at the two c ends of the curve may be specified or omitted.  for actual c computation of points on the curve it is necessary to call c the function curv2. c c on input-- c c   n is the number of values to be interpolated (n.ge.2). c c   x is an array of the n increasing abscissae of the c   functional values. c c   y is an array of the n ordinates of the values, (i. e. c   y(k) is the functional value corresponding to x(k) ). c c   slp1 and slpn contain the desired values for the first c   derivative of the curve at x(1) and x(n), respectively. c   the user may omit values for either or both of these c   parameters and signal this with islpsw. c c   islpsw contains a switch indicating which slope data c   should be used and which should be estimated by this c   subroutine, c          = 0 if slp1 and slpn are to be used, c          = 1 if slp1 is to be used but not slpn, c          = 2 if slpn is to be used but not slp1, c          = 3 if both slp1 and slpn are to be estimated c              internally. c c   yp is an array of length at least n. c c   temp is an array of length at least n which is used for c   scratch storage. c c and c c   sigma contains the tension factor. this value indicates c   the curviness desired. if abs(sigma) is nearly zero c   (e.g. .001) the resulting curve is approximately a c   cubic spline. if abs(sigma) is large (e.g. 50.) the c   resulting curve is nearly a polygonal line. if sigma c   equals zero a cubic spline results.  a standard value c   for sigma is approximately 1. in absolute value. c c on output-- c c   yp contains the values of the second derivative of the c   curve at the given nodes. c c   ierr contains an error flag, c        = 0 for normal return, c        = 1 if n is less than 2, c        = 2 if x-values are not strictly increasing. c c and c c   n, x, y, slp1, slpn, islpsw and sigma are unaltered. c c this subroutine references package modules ceez, terms, c and snhcsh. c c----------------------------------------------------------- c nm1 = n - 1 np1 = n + 1 ierr = 0 if ( n . le . 1 ) go to 8 if ( x ( n ) . le . x ( 1 )) go to 9 c c denormalize tension factor c sigmap = abs ( sigma ) * float ( n - 1 ) / ( x ( n ) - x ( 1 )) c c approximate end slopes c if ( islpsw . ge . 2 ) go to 1 slpp1 = slp1 go to 2 1 delx1 = x ( 2 ) - x ( 1 ) delx2 = delx1 + delx1 if ( n . gt . 2 ) delx2 = x ( 3 ) - x ( 1 ) if ( delx1 . le . 0. . or . delx2 . le . delx1 ) go to 9 call ceez ( delx1 , delx2 , sigmap , c1 , c2 , c3 , n ) slpp1 = c1 * y ( 1 ) + c2 * y ( 2 ) if ( n . gt . 2 ) slpp1 = slpp1 + c3 * y ( 3 ) 2 if ( islpsw . eq . 1 . or . islpsw . eq . 3 ) go to 3 slppn = slpn go to 4 3 delxn = x ( n ) - x ( nm1 ) delxnm = delxn + delxn if ( n . gt . 2 ) delxnm = x ( n ) - x ( n - 2 ) if ( delxn . le . 0. . or . delxnm . le . delxn ) go to 9 call ceez ( - delxn , - delxnm , sigmap , c1 , c2 , c3 , n ) slppn = c1 * y ( n ) + c2 * y ( nm1 ) if ( n . gt . 2 ) slppn = slppn + c3 * y ( n - 2 ) c c set up right hand side and tridiagonal system for yp and c perform forward elimination c 4 delx1 = x ( 2 ) - x ( 1 ) if ( delx1 . le . 0. ) go to 9 dx1 = ( y ( 2 ) - y ( 1 )) / delx1 call terms ( diag1 , sdiag1 , sigmap , delx1 ) yp ( 1 ) = ( dx1 - slpp1 ) / diag1 temp ( 1 ) = sdiag1 / diag1 if ( n . eq . 2 ) go to 6 do 5 i = 2 , nm1 delx2 = x ( i + 1 ) - x ( i ) if ( delx2 . le . 0. ) go to 9 dx2 = ( y ( i + 1 ) - y ( i )) / delx2 call terms ( diag2 , sdiag2 , sigmap , delx2 ) diag = diag1 + diag2 - sdiag1 * temp ( i - 1 ) yp ( i ) = ( dx2 - dx1 - sdiag1 * yp ( i - 1 )) / diag temp ( i ) = sdiag2 / diag dx1 = dx2 diag1 = diag2 5 sdiag1 = sdiag2 6 diag = diag1 - sdiag1 * temp ( nm1 ) yp ( n ) = ( slppn - dx1 - sdiag1 * yp ( nm1 )) / diag c c perform back substitution c do 7 i = 2 , n ibak = np1 - i 7 yp ( ibak ) = yp ( ibak ) - temp ( ibak ) * yp ( ibak + 1 ) return c c too few points c 8 ierr = 1 return c c x-values not strictly increasing c 9 ierr = 2 return end subroutine curvs ( n , x , y , d , isw , s , eps , ys , ysp , sigma , temp , * ierr ) c integer n , isw , ierr real x ( n ), y ( n ), d ( n ), s , eps , ys ( n ), ysp ( n ), sigma , temp ( n , 9 ) c c                                 coded by alan kaylor cline c                           from fitpack -- january 26, 1987 c                        a curve and surface fitting package c                      a product of pleasant valley software c                  8603 altus cove, austin, texas 78759, usa c c this subroutine determines the parameters necessary to c compute a smoothing spline under tension. for a given c increasing sequence of abscissae (x(i)), i = 1,..., n and c associated ordinates (y(i)), i = 1,..., n, the function c determined minimizes the summation from i = 1 to n-1 of c the square of the second derivative of f plus sigma c squared times the difference of the first derivative of f c and (f(x(i+1))-f(x(i)))/(x(i+1)-x(i)) squared, over all c functions f with two continuous derivatives such that the c summation of the square of (f(x(i))-y(i))/d(i) is less c than or equal to a given constant s, where (d(i)), i = 1, c ..., n are a given set of observation weights. the c function determined is a spline under tension with third c derivative discontinuities at (x(i)), i = 2,..., n-1. for c actual computation of points on the curve it is necessary c to call the function curv2. the determination of the curve c is performed by subroutine curvss, the subroutine curvs c only decomposes the workspace for curvss. c c on input-- c c   n is the number of values to be smoothed (n.ge.2). c c   x is an array of the n increasing abscissae of the c   values to be smoothed. c c   y is an array of the n ordinates of the values to be c   smoothed, (i. e. y(k) is the functional value c   corresponding to x(k) ). c c   d is a parameter containing the observation weights. c   this may either be an array of length n or a scalar c   (interpreted as a constant). the value of d c   corresponding to the observation (x(k),y(k)) should c   be an approximation to the standard deviation of error. c c   isw contains a switch indicating whether the parameter c   d is to be considered a vector or a scalar, c          = 0 if d is an array of length n, c          = 1 if d is a scalar. c c   s contains the value controlling the smoothing. this c   must be non-negative. for s equal to zero, the c   subroutine does interpolation, larger values lead to c   smoother funtions. if parameter d contains standard c   deviation estimates, a reasonable value for s is c   float(n). c c   eps contains a tolerance on the relative precision to c   which s is to be interpreted. this must be greater than c   or equal to zero and less than or equal to one. a c   reasonable value for eps is sqrt(2./float(n)). c c   ys is an array of length at least n. c c   ysp is an array of length at least n. c c   sigma contains the tension factor. this value indicates c   the degree to which the first derivative part of the c   smoothing functional is emphasized. if sigma is nearly c   zero (e. g. .001) the resulting curve is approximately a c   cubic spline. if sigma is large (e. g. 50.) the c   resulting curve is nearly a polygonal line. if sigma c   equals zero a cubic spline results. a standard value for c   sigma is approximately 1. c c and c c   temp is an array of length at least 9*n which is used c   for scratch storage. c c on output-- c c   ys contains the smoothed ordinate values. c c   ysp contains the values of the second derivative of the c   smoothed curve at the given nodes. c c   ierr contains an error flag, c        = 0 for normal return, c        = 1 if n is less than 2, c        = 2 if s is negative, c        = 3 if eps is negative or greater than one, c        = 4 if x-values are not strictly increasing, c        = 5 if a d-value is non-positive. c c and c c   n, x, y, d, isw, s, eps, and sigma are unaltered. c c this subroutine references package modules curvss, terms, c and snhcsh. c c----------------------------------------------------------- c c decompose temp into nine arrays and call curvss c call curvss ( n , x , y , d , isw , s , eps , ys , ysp , sigma , temp ( 1 , 1 ), * temp ( 1 , 2 ), temp ( 1 , 3 ), temp ( 1 , 4 ), temp ( 1 , 5 ), * temp ( 1 , 6 ), temp ( 1 , 7 ), temp ( 1 , 8 ), temp ( 1 , 9 ), * ierr ) return end function curv2 ( t , n , x , y , yp , sigma ) c integer n real t , x ( n ), y ( n ), yp ( n ), sigma c c                                 coded by alan kaylor cline c                           from fitpack -- january 26, 1987 c                        a curve and surface fitting package c                      a product of pleasant valley software c                  8603 altus cove, austin, texas 78759, usa c c this function interpolates a curve at a given point c using a spline under tension. the subroutine curv1 should c be called earlier to determine certain necessary c parameters. c c on input-- c c   t contains a real value to be mapped onto the interpo- c   lating curve. c c   n contains the number of points which were specified to c   determine the curve. c c   x and y are arrays containing the abscissae and c   ordinates, respectively, of the specified points. c c   yp is an array of second derivative values of the curve c   at the nodes. c c and c c   sigma contains the tension factor (its sign is ignored). c c the parameters n, x, y, yp, and sigma should be input c unaltered from the output of curv1. c c on output-- c c   curv2 contains the interpolated value. c c none of the input parameters are altered. c c this function references package modules intrvl and c snhcsh. c c----------------------------------------------------------- c c determine interval c im1 = intrvl ( t , x , n ) i = im1 + 1 c c denormalize tension factor c sigmap = abs ( sigma ) * float ( n - 1 ) / ( x ( n ) - x ( 1 )) c c set up and perform interpolation c del1 = t - x ( im1 ) del2 = x ( i ) - t dels = x ( i ) - x ( im1 ) sum = ( y ( i ) * del1 + y ( im1 ) * del2 ) / dels if ( sigmap . ne . 0. ) go to 1 curv2 = sum - del1 * del2 * ( yp ( i ) * ( del1 + dels ) + yp ( im1 ) * * ( del2 + dels )) / ( 6. * dels ) return 1 sigdel = sigmap * dels call snhcsh ( ss , dummy , sigdel , - 1 ) call snhcsh ( s1 , dummy , sigmap * del1 , - 1 ) call snhcsh ( s2 , dummy , sigmap * del2 , - 1 ) curv2 = sum + ( yp ( i ) * del1 * ( s1 - ss ) + yp ( im1 ) * del2 * ( s2 - ss )) / * ( sigdel * sigmap * ( 1. + ss )) return end function curvd ( t , n , x , y , yp , sigma ) c integer n real t , x ( n ), y ( n ), yp ( n ), sigma c c                                 coded by alan kaylor cline c                           from fitpack -- january 26, 1987 c                        a curve and surface fitting package c                      a product of pleasant valley software c                  8603 altus cove, austin, texas 78759, usa c c this function differentiates a curve at a given point c using a spline under tension. the subroutine curv1 should c be called earlier to determine certain necessary c parameters. c c on input-- c c   t contains a real value at which the derivative is to be c   determined. c c   n contains the number of points which were specified to c   determine the curve. c c   x and y are arrays containing the abscissae and c   ordinates, respectively, of the specified points. c c   yp is an array of second derivative values of the curve c   at the nodes. c c and c c   sigma contains the tension factor (its sign is ignored). c c the parameters n, x, y, yp, and sigma should be input c unaltered from the output of curv1. c c on output-- c c   curvd contains the derivative value. c c none of the input parameters are altered. c c this function references package modules intrvl and c snhcsh. c c----------------------------------------------------------- c c determine interval c im1 = intrvl ( t , x , n ) i = im1 + 1 c c denormalize tension factor c sigmap = abs ( sigma ) * float ( n - 1 ) / ( x ( n ) - x ( 1 )) c c set up and perform differentiation c del1 = t - x ( im1 ) del2 = x ( i ) - t dels = x ( i ) - x ( im1 ) sum = ( y ( i ) - y ( im1 )) / dels if ( sigmap . ne . 0. ) go to 1 curvd = sum + ( yp ( i ) * ( 2. * del1 * del1 - del2 * ( del1 + dels )) - * yp ( im1 ) * ( 2. * del2 * del2 - del1 * ( del2 + dels ))) * / ( 6. * dels ) return 1 sigdel = sigmap * dels call snhcsh ( ss , dummy , sigdel , - 1 ) call snhcsh ( dummy , c1 , sigmap * del1 , 1 ) call snhcsh ( dummy , c2 , sigmap * del2 , 1 ) curvd = sum + ( yp ( i ) * ( c1 - ss ) - yp ( im1 ) * ( c2 - ss )) / * ( sigdel * sigmap * ( 1. + ss )) return end function curvi ( xl , xu , n , x , y , yp , sigma ) c integer n real xl , xu , x ( n ), y ( n ), yp ( n ), sigma c c                                 coded by alan kaylor cline c                           from fitpack -- january 26, 1987 c                        a curve and surface fitting package c                      a product of pleasant valley software c                  8603 altus cove, austin, texas 78759, usa c c this function integrates a curve specified by a spline c under tension between two given limits. the subroutine c curv1 should be called earlier to determine necessary c parameters. c c on input-- c c   xl and xu contain the upper and lower limits of inte- c   gration, respectively. (sl need not be less than or c   equal to xu, curvi (xl,xu,...) .eq. -curvi (xu,xl,...) ). c c   n contains the number of points which were specified to c   determine the curve. c c   x and y are arrays containing the abscissae and c   ordinates, respectively, of the specified points. c c   yp is an array from subroutine curv1 containing c   the values of the second derivatives at the nodes. c c and c c   sigma contains the tension factor (its sign is ignored). c c the parameters n, x, y, yp, and sigma should be input c unaltered from the output of curv1. c c on output-- c c   curvi contains the integral value. c c none of the input parameters are altered. c c this function references package modules intrvl and c snhcsh. c c----------------------------------------------------------- c c denormalize tension factor c sigmap = abs ( sigma ) * float ( n - 1 ) / ( x ( n ) - x ( 1 )) c c determine actual upper and lower bounds c xxl = xl xxu = xu ssign = 1. if ( xl . lt . xu ) go to 1 xxl = xu xxu = xl ssign = - 1. if ( xl . gt . xu ) go to 1 c c return zero if xl .eq. xu c curvi = 0. return c c search for proper intervals c 1 ilm1 = intrvl ( xxl , x , n ) il = ilm1 + 1 ium1 = intrvl ( xxu , x , n ) iu = ium1 + 1 if ( il . eq . iu ) go to 8 c c integrate from xxl to x(il) c sum = 0. if ( xxl . eq . x ( il )) go to 3 del1 = xxl - x ( ilm1 ) del2 = x ( il ) - xxl dels = x ( il ) - x ( ilm1 ) t1 = ( del1 + dels ) * del2 / ( 2. * dels ) t2 = del2 * del2 / ( 2. * dels ) sum = t1 * y ( il ) + t2 * y ( ilm1 ) if ( sigma . eq . 0. ) go to 2 call snhcsh ( dummy , c1 , sigmap * del1 , 2 ) call snhcsh ( dummy , c2 , sigmap * del2 , 2 ) call snhcsh ( ss , cs , sigmap * dels , 3 ) sum = sum + (( dels * dels * ( cs - ss / 2. ) - del1 * del1 * ( c1 - ss / 2. )) * * yp ( il ) + del2 * del2 * ( c2 - ss / 2. ) * yp ( ilm1 )) / * ( sigmap * sigmap * dels * ( 1. + ss )) go to 3 2 sum = sum - t1 * t1 * dels * yp ( il ) / 6. * - t2 * ( del1 * ( del2 + dels ) + dels * dels ) * yp ( ilm1 ) / 1 2. c c integrate over interior intervals c 3 if ( iu - il . eq . 1 ) go to 6 ilp1 = il + 1 do 5 i = ilp1 , ium1 dels = x ( i ) - x ( i - 1 ) sum = sum + ( y ( i ) + y ( i - 1 )) * dels / 2. if ( sigma . eq . 0. ) go to 4 call snhcsh ( ss , cs , sigmap * dels , 3 ) sum = sum + ( yp ( i ) + yp ( i - 1 )) * dels * ( cs - ss / 2. ) / * ( sigmap * sigmap * ( 1. + ss )) go to 5 4 sum = sum - ( yp ( i ) + yp ( i - 1 )) * dels * dels * dels / 2 4. 5 continue c c integrate from x(iu-1) to xxu c 6 if ( xxu . eq . x ( ium1 )) go to 10 del1 = xxu - x ( ium1 ) del2 = x ( iu ) - xxu dels = x ( iu ) - x ( ium1 ) t1 = del1 * del1 / ( 2. * dels ) t2 = ( del2 + dels ) * del1 / ( 2. * dels ) sum = sum + t1 * y ( iu ) + t2 * y ( ium1 ) if ( sigma . eq . 0. ) go to 7 call snhcsh ( dummy , c1 , sigmap * del1 , 2 ) call snhcsh ( dummy , c2 , sigmap * del2 , 2 ) call snhcsh ( ss , cs , sigmap * dels , 3 ) sum = sum + ( yp ( iu ) * del1 * del1 * ( c1 - ss / 2. ) + yp ( ium1 ) * * ( dels * dels * ( cs - ss / 2. ) - del2 * del2 * ( c2 - ss / 2. ))) * / ( sigmap * sigmap * dels * ( 1. + ss )) go to 10 7 sum = sum - t1 * ( del2 * ( del1 + dels ) + dels * dels ) * yp ( iu ) / 1 2. * - t2 * t2 * dels * yp ( ium1 ) / 6. go to 10 c c integrate from xxl to xxu c 8 delu1 = xxu - x ( ium1 ) delu2 = x ( iu ) - xxu dell1 = xxl - x ( ium1 ) dell2 = x ( iu ) - xxl dels = x ( iu ) - x ( ium1 ) deli = xxu - xxl t1 = ( delu1 + dell1 ) * deli / ( 2. * dels ) t2 = ( delu2 + dell2 ) * deli / ( 2. * dels ) sum = t1 * y ( iu ) + t2 * y ( ium1 ) if ( sigma . eq . 0. ) go to 9 call snhcsh ( dummy , cu1 , sigmap * delu1 , 2 ) call snhcsh ( dummy , cu2 , sigmap * delu2 , 2 ) call snhcsh ( dummy , cl1 , sigmap * dell1 , 2 ) call snhcsh ( dummy , cl2 , sigmap * dell2 , 2 ) call snhcsh ( ss , dummy , sigmap * dels , - 1 ) sum = sum + ( yp ( iu ) * ( delu1 * delu1 * ( cu1 - ss / 2. ) * - dell1 * dell1 * ( cl1 - ss / 2. )) * + yp ( ium1 ) * ( dell2 * dell2 * ( cl2 - ss / 2. ) * - delu2 * delu2 * ( cu2 - ss / 2. ))) / * ( sigmap * sigmap * dels * ( 1. + ss )) go to 10 9 sum = sum - t1 * ( delu2 * ( dels + delu1 ) + dell2 * ( dels + dell1 )) * * yp ( iu ) / 1 2. * - t2 * ( dell1 * ( dels + dell2 ) + delu1 * ( dels + delu2 )) * * yp ( ium1 ) / 1 2. c c correct sign and return c 10 curvi = ssign * sum return end subroutine curvp1 ( n , x , y , p , yp , temp , sigma , ierr ) c integer n , ierr real x ( n ), y ( n ), p , yp ( n ), temp ( 1 ), sigma c c                                 coded by alan kaylor cline c                           from fitpack -- january 26, 1987 c                        a curve and surface fitting package c                      a product of pleasant valley software c                  8603 altus cove, austin, texas 78759, usa c c this subroutine determines the parameters necessary to c compute a periodic interpolatory spline under tension c through a sequence of functional values. for actual ends c of the curve may be specified or omitted.  for actual c computation of points on the curve it is necessary to call c the function curvp2. c c on input-- c c   n is the number of values to be interpolated (n.ge.2). c c   x is an array of the n increasing abscissae of the c   functional values. c c   y is an array of the n ordinates of the values, (i. e. c   y(k) is the functional value corresponding to x(k) ). c c   p is the period (p .gt. x(n)-x(1)). c c   yp is an array of length at least n. c c   temp is an array of length at least 2*n which is used c   for scratch storage. c c and c c   sigma contains the tension factor.  this value indicates c   the curviness desired. if abs(sigma) is nearly zero c   (e.g. .001) the resulting curve is approximately a c   cubic spline. if abs(sigma) is large (e.g. 50.) the c   resulting curve is nearly a polygonal line. if sigma c   equals zero a cubic spline results.  a standard value c   for sigma is approximately 1. in absolute value. c c on output-- c c   yp contains the values of the second derivative of the c   curve at the given nodes. c c   ierr contains an error flag, c        = 0 for normal return, c        = 1 if n is less than 2, c        = 2 if p is less than or equal to x(n)-x(1), c        = 3 if x-values are not strictly increasing. c c and c c  n, x, y, and sigma are unaltered. c c this subroutine references package modules terms and c snhcsh. c c----------------------------------------------------------- c nm1 = n - 1 np1 = n + 1 ierr = 0 if ( n . le . 1 ) go to 6 if ( p . le . x ( n ) - x ( 1 ) . or . p . le . 0. ) go to 7 c c denormalize tension factor c sigmap = abs ( sigma ) * float ( n ) / p c c set up right hand side and tridiagonal system for yp and c perform forward elimination c delx1 = p - ( x ( n ) - x ( 1 )) dx1 = ( y ( 1 ) - y ( n )) / delx1 call terms ( diag1 , sdiag1 , sigmap , delx1 ) delx2 = x ( 2 ) - x ( 1 ) if ( delx2 . le . 0. ) go to 8 dx2 = ( y ( 2 ) - y ( 1 )) / delx2 call terms ( diag2 , sdiag2 , sigmap , delx2 ) diag = diag1 + diag2 yp ( 1 ) = ( dx2 - dx1 ) / diag temp ( np1 ) = - sdiag1 / diag temp ( 1 ) = sdiag2 / diag dx1 = dx2 diag1 = diag2 sdiag1 = sdiag2 if ( n . eq . 2 ) go to 2 do 1 i = 2 , nm1 npi = n + i delx2 = x ( i + 1 ) - x ( i ) if ( delx2 . le . 0. ) go to 8 dx2 = ( y ( i + 1 ) - y ( i )) / delx2 call terms ( diag2 , sdiag2 , sigmap , delx2 ) diag = diag1 + diag2 - sdiag1 * temp ( i - 1 ) yp ( i ) = ( dx2 - dx1 - sdiag1 * yp ( i - 1 )) / diag temp ( npi ) = - temp ( npi - 1 ) * sdiag1 / diag temp ( i ) = sdiag2 / diag dx1 = dx2 diag1 = diag2 1 sdiag1 = sdiag2 2 delx2 = p - ( x ( n ) - x ( 1 )) dx2 = ( y ( 1 ) - y ( n )) / delx2 call terms ( diag2 , sdiag2 , sigmap , delx2 ) yp ( n ) = dx2 - dx1 temp ( nm1 ) = temp ( 2 * n - 1 ) - temp ( nm1 ) if ( n . eq . 2 ) go to 4 c c perform first step of back substitution c do 3 i = 3 , n ibak = np1 - i npibak = n + ibak yp ( ibak ) = yp ( ibak ) - temp ( ibak ) * yp ( ibak + 1 ) 3 temp ( ibak ) = temp ( npibak ) - temp ( ibak ) * temp ( ibak + 1 ) 4 yp ( n ) = ( yp ( n ) - sdiag2 * yp ( 1 ) - sdiag1 * yp ( nm1 )) / * ( diag1 + diag2 + sdiag2 * temp ( 1 ) + sdiag1 * temp ( nm1 )) c c perform second step of back substitution c ypn = yp ( n ) do 5 i = 1 , nm1 5 yp ( i ) = yp ( i ) + temp ( i ) * ypn return c c too few points c 6 ierr = 1 return c c period too small c 7 ierr = 2 return c c x-values not strictly increasing c 8 ierr = 3 return end subroutine curvps ( n , x , y , p , d , isw , s , eps , ys , ysp , sigma , * temp , ierr ) c integer n , isw , ierr real x ( n ), y ( n ), p , d ( n ), s , eps , ys ( n ), ysp ( n ), sigma , * temp ( n , 11 ) c c                                 coded by alan kaylor cline c                           from fitpack -- january 26, 1987 c                        a curve and surface fitting package c                      a product of pleasant valley software c                  8603 altus cove, austin, texas 78759, usa c c this subroutine determines the parameters necessary to c compute a periodic smoothing spline under tension. for a c given increasing sequence of abscissae (x(i)), i = 1,...,n c and associated ordinates (y(i)), i = 1,...,n, letting p be c the period, x(n+1) = x(1)+p, and y(n+1) = y(1), the c function determined minimizes the summation from i = 1 to c n of the square of the second derivative of f plus sigma c squared times the difference of the first derivative of f c and (f(x(i+1))-f(x(i)))/(x(i+1)-x(i)) squared, over all c functions f with period p and two continuous derivatives c such that the summation of the square of c (f(x(i))-y(i))/d(i) is less than or equal to a given c constant s, where (d(i)), i = 1,...,n are a given set of c observation weights. the function determined is a periodic c spline under tension with third derivative discontinuities c at (x(i)) i = 1,...,n (and all periodic translations of c these values). for actual computation of points on the c curve it is necessary to call the function curvp2. the c determination of the curve is performed by subroutine c curvpp, the subroutin curvps only decomposes the workspace c for curvpp. c c on input-- c c   n is the number of values to be smoothed (n.ge.2). c c   x is an array of the n increasing abscissae of the c   values to be smoothed. c c   y is an array of the n ordinates of the values to be c   smoothed, (i. e. y(k) is the functional value c   corresponding to x(k) ). c c   p is the period (p .gt. x(n)-x(1)). c c   d is a parameter containing the observation weights. c   this may either be an array of length n or a scalar c   (interpreted as a constant). the value of d c   corresponding to the observation (x(k),y(k)) should c   be an approximation to the standard deviation of error. c c   isw contains a switch indicating whether the parameter c   d is to be considered a vector or a scalar, c          = 0 if d is an array of length n, c          = 1 if d is a scalar. c c   s contains the value controlling the smoothing. this c   must be non-negative. for s equal to zero, the c   subroutine does interpolation, larger values lead to c   smoother funtions. if parameter d contains standard c   deviation estimates, a reasonable value for s is c   float(n). c c   eps contains a tolerance on the relative precision to c   which s is to be interpreted. this must be greater than c   or equal to zero and less than or equal to one. a c   reasonable value for eps is sqrt(2./float(n)). c c   ys is an array of length at least n. c c   ysp is an array of length at least n. c c   sigma contains the tension factor. this value indicates c   the degree to which the first derivative part of the c   smoothing functional is emphasized. if sigma is nearly c   zero (e. g. .001) the resulting curve is approximately a c   cubic spline. if sigma is large (e. g. 50.) the c   resulting curve is nearly a polygonal line. if sigma c   equals zero a cubic spline results. a standard value for c   sigma is approximately 1. c c and c c   temp is an array of length at least 11*n which is used c   for scratch storage. c c on output-- c c   ys contains the smoothed ordinate values. c c   ysp contains the values of the second derivative of the c   smoothed curve at the given nodes. c c   ierr contains an error flag, c        = 0 for normal return, c        = 1 if n is less than 2, c        = 2 if s is negative, c        = 3 if eps is negative or greater than one, c        = 4 if x-values are not strictly increasing, c        = 5 if a d-value is non-positive, c        = 6 if p is less than or equal to x(n)-x(1). c c and c c   n, x, y, p, d, isw, s, eps, and sigma are unaltered. c c this subroutine references package modules curvpp, terms, c and snhcsh. c c----------------------------------------------------------- c c decompose temp into eleven arrays and call curvpp c call curvpp ( n , x , y , p , d , isw , s , eps , ys , ysp , sigma , * temp ( 1 , 1 ), temp ( 1 , 2 ), temp ( 1 , 3 ), temp ( 1 , 4 ), * temp ( 1 , 5 ), temp ( 1 , 6 ), temp ( 1 , 7 ), temp ( 1 , 8 ), * temp ( 1 , 9 ), temp ( 1 , 10 ), temp ( 1 , 11 ), ierr ) return end function curvp2 ( t , n , x , y , p , yp , sigma ) c integer n real t , x ( n ), y ( n ), p , yp ( n ), sigma c c                                 coded by alan kaylor cline c                           from fitpack -- january 26, 1987 c                        a curve and surface fitting package c                      a product of pleasant valley software c                  8603 altus cove, austin, texas 78759, usa c c this function interpolates a curve at a given point using c a periodic spline under tension. the subroutine curvp1 c should be called earlier to determine certain necessary c parameters. c c on input-- c c   t contains a real value to be mapped onto the interpo- c   lating curve. c c   n contains the number of points which were specified to c   determine the curve. c c   x and y are arrays containing the abscissae and c   ordinates, respectively, of the specified points. c c   p contains the period. c c   yp is an array of second derivative values of the curve c   at the nodes. c c and c c   sigma contains the tension factor (its sign is ignored). c c the parameters n, x, y, p, yp, and sigma should be input c unaltered from the output of curvp1. c c on output-- c c   curvp2 contains the interpolated value. c c none of the input parameters are altered. c c this function references package modules intrvp and c snhcsh. c c----------------------------------------------------------- c c determine interval c im1 = intrvp ( t , x , n , p , tp ) i = im1 + 1 c c denormalize tension factor c sigmap = abs ( sigma ) * float ( n ) / p c c set up and perform interpolation c del1 = tp - x ( im1 ) if ( im1 . eq . n ) go to 1 del2 = x ( i ) - tp dels = x ( i ) - x ( im1 ) go to 2 1 i = 1 del2 = x ( 1 ) + p - tp dels = p - ( x ( n ) - x ( 1 )) 2 sum = ( y ( i ) * del1 + y ( im1 ) * del2 ) / dels if ( sigmap . ne . 0. ) go to 3 curvp2 = sum - del1 * del2 * ( yp ( i ) * ( del1 + dels ) + yp ( im1 ) * * ( del2 + dels )) / ( 6. * dels ) return 3 sigdel = sigmap * dels call snhcsh ( ss , dummy , sigdel , - 1 ) call snhcsh ( s1 , dummy , sigmap * del1 , - 1 ) call snhcsh ( s2 , dummy , sigmap * del2 , - 1 ) curvp2 = sum + ( yp ( i ) * del1 * ( s1 - ss ) + yp ( im1 ) * del2 * ( s2 - ss )) / * ( sigdel * sigmap * ( 1. + ss )) return end function curvpi ( xl , xu , n , x , y , p , yp , sigma ) c integer n real xl , xu , x ( n ), y ( n ), p , yp ( n ), sigma c c                                 coded by alan kaylor cline c                           from fitpack -- january 26, 1987 c                        a curve and surface fitting package c                      a product of pleasant valley software c                  8603 altus cove, austin, texas 78759, usa c c this function integrates a curve specified by a periodic c spline under tension between two given limits. the c subroutine curvp1 should be called earlier to determine c necessary parameters. c c on input-- c c   xl and xu contain the upper and lower limits of inte- c   gration, respectively. (sl need not be less than or c   equal to xu, curvpi (xl,xu,...) .eq. -curvpi (xu,xl,...) ). c c   n contains the number of points which were specified to c   determine the curve. c c   x and y are arrays containing the abscissae and c   ordinates, respectively, of the specified points. c c   p contains the period. c c   yp is an array from subroutine curvp1 containing c   the values of the second derivatives at the nodes. c c and c c   sigma contains the tension factor (its sign is ignored). c c the parameters n, x, y, p, yp, and sigma should be input c unaltered from the output of curvp1. c c on output-- c c c   curvpi contains the integral value. c c none of the input parameters are altered. c c this function references package modules intrvp and c snhcsh. c c-------------------------------------------------------------- c integer uper logical bdy c c denormalize tension factor c sigmap = abs ( sigma ) * float ( n ) / p c c determine actual upper and lower bounds c x1pp = x ( 1 ) + p isign = 1 ilm1 = intrvp ( xl , x , n , p , xxl ) lper = int (( xl - x ( 1 )) / p ) if ( xl . lt . x ( 1 )) lper = lper - 1 ium1 = intrvp ( xu , x , n , p , xxu ) uper = int (( xu - x ( 1 )) / p ) if ( xu . lt . x ( 1 )) uper = uper - 1 ideltp = uper - lper bdy = float ( ideltp ) * ( xxu - xxl ) . lt . 0. if (( ideltp . eq . 0 . and . xxu . lt . xxl ) . or . * ideltp . lt . 0 ) isign = - 1 if ( bdy ) ideltp = ideltp - isign if ( xxu . ge . xxl ) go to 1 xsave = xxl xxl = xxu xxu = xsave isave = ilm1 ilm1 = ium1 ium1 = isave 1 il = ilm1 + 1 if ( ilm1 . eq . n ) il = 1 xil = x ( il ) if ( ilm1 . eq . n ) xil = x1pp iu = ium1 + 1 if ( ium1 . eq . n ) iu = 1 xiu = x ( iu ) if ( ium1 . eq . n ) xiu = x1pp s1 = 0. if ( ilm1 . eq . 1 . or . ( ideltp . eq . 0 . and . * . not . bdy )) go to 4 c c integrate from x(1) to x(ilm1), store in s1 c do 3 i = 2 , ilm1 dels = x ( i ) - x ( i - 1 ) s1 = s1 + ( y ( i ) + y ( i - 1 )) * dels / 2. if ( sigma . eq . 0. ) go to 2 call snhcsh ( ss , cs , sigmap * dels , 3 ) s1 = s1 + ( yp ( i ) + yp ( i - 1 )) * dels * ( cs - ss / 2. ) / * ( sigmap * sigmap * ( 1. + ss )) go to 3 2 s1 = s1 - ( yp ( i ) + yp ( i - 1 )) * dels * dels * dels / 2 4. 3 continue 4 s2 = 0. if ( x ( ilm1 ) . ge . xxl . or . ( ideltp . eq . 0 * . and . . not . bdy )) go to 6 c c integrate from x(ilm1) to xxl, store in s2 c del1 = xxl - x ( ilm1 ) del2 = xil - xxl dels = xil - x ( ilm1 ) t1 = del1 * del1 / ( 2. * dels ) t2 = ( del2 + dels ) * del1 / ( 2. * dels ) s2 = t1 * y ( il ) + t2 * y ( ilm1 ) if ( sigma . eq . 0. ) go to 5 call snhcsh ( dummy , c1 , sigmap * del1 , 2 ) call snhcsh ( dummy , c2 , sigmap * del2 , 2 ) call snhcsh ( ss , cs , sigmap * dels , 3 ) s2 = s2 + ( yp ( il ) * del1 * del1 * ( c1 - ss / 2. ) + yp ( ilm1 ) * * ( dels * dels * ( cs - ss / 2. ) - del2 * del2 * ( c2 - ss / 2. ))) * / ( sigmap * sigmap * dels * ( 1. + ss )) go to 6 5 s2 = s2 - t1 * ( del2 * ( del1 + dels ) * + dels * dels ) * yp ( il ) / 1 2. * - t2 * t2 * dels * yp ( ilm1 ) / 6. 6 s3 = 0. if ( xxl . ge . xil . or . ( ideltp . eq . 0 . and . bdy ) * . or . ilm1 . eq . ium1 ) go to 8 c c integrate from xxl to xil, store in s3 c del1 = xxl - x ( ilm1 ) del2 = xil - xxl dels = xil - x ( ilm1 ) t1 = ( del1 + dels ) * del2 / ( 2. * dels ) t2 = del2 * del2 / ( 2. * dels ) s3 = t1 * y ( il ) + t2 * y ( ilm1 ) if ( sigma . eq . 0. ) go to 7 call snhcsh ( dummy , c1 , sigmap * del1 , 2 ) call snhcsh ( dummy , c2 , sigmap * del2 , 2 ) call snhcsh ( ss , cs , sigmap * dels , 3 ) s3 = s3 + (( dels * dels * ( cs - ss / 2. ) - del1 * del1 * ( c1 - ss / 2. )) * * yp ( il ) + del2 * del2 * ( c2 - ss / 2. ) * yp ( ilm1 )) / * ( sigmap * sigmap * dels * ( 1. + ss )) go to 8 7 s3 = s3 - t1 * t1 * dels * yp ( il ) / 6. * - t2 * ( del1 * ( del2 + dels ) + dels * dels ) * * yp ( ilm1 ) / 1 2. 8 s4 = 0. if ( ilm1 . ge . ium1 - 1 . or . ( ideltp . eq . 0 . and . bdy )) * go to 11 c c integrate from xil to x(ium1), store in s4 c ilp1 = il + 1 do 10 i = ilp1 , ium1 dels = x ( i ) - x ( i - 1 ) s4 = s4 + ( y ( i ) + y ( i - 1 )) * dels / 2. if ( sigma . eq . 0. ) go to 9 call snhcsh ( ss , cs , sigmap * dels , 3 ) s4 = s4 + ( yp ( i ) + yp ( i - 1 )) * dels * ( cs - ss / 2. ) / * ( sigmap * sigmap * ( 1. + ss )) go to 10 9 s4 = s4 - ( yp ( i ) + yp ( i - 1 )) * dels * dels * dels / 2 4. 10 continue 11 s5 = 0. if ( x ( ium1 ) . ge . xxu . or . ( ideltp . eq . 0 . and . bdy ) * . or . ilm1 . eq . ium1 ) go to 13 c c integrate from x(ium1) to xxu, store in s5 c del1 = xxu - x ( ium1 ) del2 = xiu - xxu dels = xiu - x ( ium1 ) t1 = del1 * del1 / ( 2. * dels ) t2 = ( del2 + dels ) * del1 / ( 2. * dels ) s5 = t1 * y ( iu ) + t2 * y ( ium1 ) if ( sigma . eq . 0. ) go to 12 call snhcsh ( dummy , c1 , sigmap * del1 , 2 ) call snhcsh ( dummy , c2 , sigmap * del2 , 2 ) call snhcsh ( ss , cs , sigmap * dels , 3 ) s5 = s5 + ( yp ( iu ) * del1 * del1 * ( c1 - ss / 2. ) + yp ( ium1 ) * * ( dels * dels * ( cs - ss / 2. ) - del2 * del2 * ( c2 - ss / 2. ))) * / ( sigmap * sigmap * dels * ( 1. + ss )) go to 13 12 s5 = s5 - t1 * ( del2 * ( del1 + dels ) * + dels * dels ) * yp ( iu ) / 1 2. * - t2 * t2 * dels * yp ( ium1 ) / 6. 13 s6 = 0. if ( xxu . ge . xiu . or . ( ideltp . eq . 0 . and . * . not . bdy )) go to 15 c c integrate from xxu to xiu, store in s6 c del1 = xxu - x ( ium1 ) del2 = xiu - xxu dels = xiu - x ( ium1 ) t1 = ( del1 + dels ) * del2 / ( 2. * dels ) t2 = del2 * del2 / ( 2. * dels ) s6 = t1 * y ( iu ) + t2 * y ( ium1 ) if ( sigma . eq . 0. ) go to 14 call snhcsh ( dummy , c1 , sigmap * del1 , 2 ) call snhcsh ( dummy , c2 , sigmap * del2 , 2 ) call snhcsh ( ss , cs , sigmap * dels , 3 ) s6 = s6 + (( dels * dels * ( cs - ss / 2. ) - del1 * del1 * ( c1 - ss / 2. )) * * yp ( iu ) + del2 * del2 * ( c2 - ss / 2. ) * yp ( ium1 )) / * ( sigmap * sigmap * dels * ( 1. + ss )) go to 15 14 s6 = s6 - t1 * t1 * dels * yp ( iu ) / 6. * - t2 * ( del1 * ( del2 + dels ) + dels * dels ) * * yp ( ium1 ) / 1 2. 15 s7 = 0. if ( iu . eq . 1 . or . ( ideltp . eq . 0 . and . . not . bdy )) * go to 18 c c integrate from xiu to x1pp, store in s7 c np1 = n + 1 iup1 = iu + 1 do 17 ii = iup1 , np1 im1 = ii - 1 i = ii if ( i . eq . np1 ) i = 1 dels = x ( i ) - x ( im1 ) if ( dels . le . 0. ) dels = dels + p s7 = s7 + ( y ( i ) + y ( im1 )) * dels / 2. if ( sigma . eq . 0. ) go to 16 call snhcsh ( ss , cs , sigmap * dels , 3 ) s7 = s7 + ( yp ( i ) + yp ( im1 )) * dels * ( cs - ss / 2. ) / * ( sigmap * sigmap * ( 1. + ss )) go to 17 16 s7 = s7 - ( yp ( i ) + yp ( im1 )) * dels * dels * dels / 2 4. 17 continue 18 s8 = 0. if ( ilm1 . lt . ium1 . or . ( ideltp . eq . 0 . and . bdy )) * go to 20 c c integrate from xxl to xxu, store in s8 c delu1 = xxu - x ( ium1 ) delu2 = xiu - xxu dell1 = xxl - x ( ium1 ) dell2 = xiu - xxl dels = xiu - x ( ium1 ) deli = xxu - xxl t1 = ( delu1 + dell1 ) * deli / ( 2. * dels ) t2 = ( delu2 + dell2 ) * deli / ( 2. * dels ) s8 = t1 * y ( iu ) + t2 * y ( ium1 ) if ( sigma . eq . 0. ) go to 19 call snhcsh ( dummy , cu1 , sigmap * delu1 , 2 ) call snhcsh ( dummy , cu2 , sigmap * delu2 , 2 ) call snhcsh ( dummy , cl1 , sigmap * dell1 , 2 ) call snhcsh ( dummy , cl2 , sigmap * dell2 , 2 ) call snhcsh ( ss , dummy , sigmap * dels , - 1 ) s8 = s8 + ( yp ( iu ) * ( delu1 * delu1 * ( cu1 - ss / 2. ) * - dell1 * dell1 * ( cl1 - ss / 2. )) * + yp ( ium1 ) * ( dell2 * dell2 * ( cl2 - ss / 2. ) * - delu2 * delu2 * ( cu2 - ss / 2. ))) / * ( sigmap * sigmap * dels * ( 1. + ss )) go to 20 19 s8 = s8 - t1 * ( delu2 * ( dels + delu1 ) * + dell2 * ( dels + dell1 )) * yp ( iu ) / 1 2. * - t2 * ( dell1 * ( dels + dell2 ) * + delu1 * ( dels + delu2 )) * yp ( ium1 ) / 1 2. 20 so = s1 + s2 + s6 + s7 si = s3 + s4 + s5 + s8 if ( bdy ) go to 21 curvpi = float ( ideltp ) * ( so + si ) + float ( isign ) * si return 21 curvpi = float ( ideltp ) * ( so + si ) + float ( isign ) * so return end subroutine kurv1 ( n , x , y , slp1 , slpn , islpsw , xp , yp , temp , s , * sigma , ierr ) c integer n , islpsw , ierr real x ( n ), y ( n ), slp1 , slpn , xp ( n ), yp ( n ), temp ( n ), s ( n ), * sigma c c                                 coded by alan kaylor cline c                           from fitpack -- january 26, 1987 c                        a curve and surface fitting package c                      a product of pleasant valley software c                  8603 altus cove, austin, texas 78759, usa c c this subroutine determines the parameters necessary to c compute a spline under tension forming a curve in the c plane and passing through a sequence of pairs (x(1),y(1)), c ...,(x(n),y(n)). for actual computation of points on the c curve it is necessary to call the subroutine kurv2. c c on input-- c c   n is the number of points to be interpolated (n.ge.2). c c   x is an array containing the n x-coordinates of the c   points. c c   y is an array containing the n y-coordinates of the c   points. (adjacent x-y pairs must be distinct, i. e. c   either x(i) .ne. x(i+1) or y(i) .ne. y(i+1), for c   i = 1,...,n-1.) c c   slp1 and slpn contain the desired values for the angles c   (in radians) of the slope at (x(1),y(1)) and (x(n),y(n)) c   respectively. the angles are measured counter-clock- c   wise from the x-axis and the positive sense of the curve c   is assumed to be that moving from point 1 to point n. c   the user may omit values for either or both of these c   parameters and signal this with islpsw. c c   islpsw contains a switch indicating which slope data c   should be used and which should be estimated by this c   subroutine, c          = 0 if slp1 and slpn are to be used, c          = 1 if slp1 is to be used but not slpn, c          = 2 if slpn is to be used but not slp1, c          = 3 if both slp1 and slpn are to be estimated c              internally. c c   xp and yp are arrays of length at least n. c c   temp is an array of length at least n which is used c   for scratch storage. c c   s is an array of length at least n. c c and c c   sigma contains the tension factor. this value indicates c   the curviness desired. if abs(sigma) is nearly zero c   (e.g. .001) the resulting curve is approximately a cubic c   spline. if abs(sigma) is large (e. g. 50.) the resulting c   curve is nearly a polygonal line. if sigma equals zero a c   cubic spline results. a standard value for sigma is c   approximately 1. in absolute value. c c on output-- c c   xp and yp contain information about the curvature of the c   curve at the given nodes. c c   s contains the polygonal arclengths of the curve. c c   ierr contains an error flag, c        = 0 for normal return, c        = 1 if n is less than 2, c        = 2 if adjacent coordinate pairs coincide. c c and c c   n, x, y, slp1, slpn, islpsw, and sigma are unaltered. c c this subroutine references package modules ceez, terms, c and snhcsh. c c----------------------------------------------------------- c nm1 = n - 1 np1 = n + 1 ierr = 0 if ( n . le . 1 ) go to 11 c c determine polygonal arclengths c s ( 1 ) = 0. do 1 i = 2 , n im1 = i - 1 1 s ( i ) = s ( im1 ) + sqrt (( x ( i ) - x ( im1 )) ** 2 + * ( y ( i ) - y ( im1 )) ** 2 ) c c denormalize tension factor c sigmap = abs ( sigma ) * float ( n - 1 ) / s ( n ) c c approximate end slopes c if ( islpsw . ge . 2 ) go to 2 slpp1x = cos ( slp1 ) slpp1y = sin ( slp1 ) go to 4 2 dels1 = s ( 2 ) - s ( 1 ) dels2 = dels1 + dels1 if ( n . gt . 2 ) dels2 = s ( 3 ) - s ( 1 ) if ( dels1 . eq . 0. . or . dels2 . eq . 0. ) go to 12 call ceez ( dels1 , dels2 , sigmap , c1 , c2 , c3 , n ) sx = c1 * x ( 1 ) + c2 * x ( 2 ) sy = c1 * y ( 1 ) + c2 * y ( 2 ) if ( n . eq . 2 ) go to 3 sx = sx + c3 * x ( 3 ) sy = sy + c3 * y ( 3 ) 3 delt = sqrt ( sx * sx + sy * sy ) slpp1x = sx / delt slpp1y = sy / delt 4 if ( islpsw . eq . 1 . or . islpsw . eq . 3 ) go to 5 slppnx = cos ( slpn ) slppny = sin ( slpn ) go to 7 5 delsn = s ( n ) - s ( nm1 ) delsnm = delsn + delsn if ( n . gt . 2 ) delsnm = s ( n ) - s ( n - 2 ) if ( delsn . eq . 0. . or . delsnm . eq . 0. ) go to 12 call ceez ( - delsn , - delsnm , sigmap , c1 , c2 , c3 , n ) sx = c1 * x ( n ) + c2 * x ( nm1 ) sy = c1 * y ( n ) + c2 * y ( nm1 ) if ( n . eq . 2 ) go to 6 sx = sx + c3 * x ( n - 2 ) sy = sy + c3 * y ( n - 2 ) 6 delt = sqrt ( sx * sx + sy * sy ) slppnx = sx / delt slppny = sy / delt c c set up right hand sides and tridiagonal system for xp and c yp and perform forward elimination c 7 dx1 = ( x ( 2 ) - x ( 1 )) / s ( 2 ) dy1 = ( y ( 2 ) - y ( 1 )) / s ( 2 ) call terms ( diag1 , sdiag1 , sigmap , s ( 2 )) xp ( 1 ) = ( dx1 - slpp1x ) / diag1 yp ( 1 ) = ( dy1 - slpp1y ) / diag1 temp ( 1 ) = sdiag1 / diag1 if ( n . eq . 2 ) go to 9 do 8 i = 2 , nm1 dels2 = s ( i + 1 ) - s ( i ) if ( dels2 . eq . 0. ) go to 12 dx2 = ( x ( i + 1 ) - x ( i )) / dels2 dy2 = ( y ( i + 1 ) - y ( i )) / dels2 call terms ( diag2 , sdiag2 , sigmap , dels2 ) diag = diag1 + diag2 - sdiag1 * temp ( i - 1 ) diagin = 1. / diag xp ( i ) = ( dx2 - dx1 - sdiag1 * xp ( i - 1 )) * diagin yp ( i ) = ( dy2 - dy1 - sdiag1 * yp ( i - 1 )) * diagin temp ( i ) = sdiag2 * diagin dx1 = dx2 dy1 = dy2 diag1 = diag2 8 sdiag1 = sdiag2 9 diag = diag1 - sdiag1 * temp ( nm1 ) xp ( n ) = ( slppnx - dx1 - sdiag1 * xp ( nm1 )) / diag yp ( n ) = ( slppny - dy1 - sdiag1 * yp ( nm1 )) / diag c c perform back substitution c do 10 i = 2 , n ibak = np1 - i xp ( ibak ) = xp ( ibak ) - temp ( ibak ) * xp ( ibak + 1 ) 10 yp ( ibak ) = yp ( ibak ) - temp ( ibak ) * yp ( ibak + 1 ) return c c too few points c 11 ierr = 1 return c c coincident adjacent points c 12 ierr = 2 return end subroutine kurv2 ( t , xs , ys , n , x , y , xp , yp , s , sigma ) c integer n real t , xs , ys , x ( n ), y ( n ), xp ( n ), yp ( n ), s ( n ), sigma c c                                 coded by alan kaylor cline c                           from fitpack -- january 26, 1987 c                        a curve and surface fitting package c                      a product of pleasant valley software c                  8603 altus cove, austin, texas 78759, usa c c this subroutine performs the mapping of points in the c interval (0.,1.) onto a curve in the plane. the subroutine c kurv1 should be called earlier to determine certain c necessary parameters. the resulting curve has a parametric c representation both of whose components are splines under c tension and functions of the polygonal arclength c parameter. c c on input-- c c   t contains a real value to be mapped to a point on the c   curve. the interval (0.,1.) is mapped onto the entire c   curve, with 0. mapping to (x(1),y(1)) and 1. mapping c   to (x(n),y(n)). values outside this interval result in c   extrapolation. c c   n contains the number of points which were specified c   to determine the curve. c c   x and y are arrays containing the x- and y-coordinates c   of the specified points. c c   xp and yp are the arrays output from kurv1 containing c   curvature information. c c   s is an array containing the polygonal arclengths of c   the curve. c c and c c   sigma contains the tension factor (its sign is ignored). c c the parameters n, x, y, xp, yp, s, and sigma should be c input unaltered from the output of kurv1. c c on output-- c c   xs and ys contain the x- and y-coordinates of the image c   point on the curve. c c none of the input parameters are altered. c c this subroutine references package modules intrvl and c snhcsh. c c----------------------------------------------------------- c c determine interval c tn = s ( n ) * t im1 = intrvl ( tn , s , n ) i = im1 + 1 c c denormalize tension factor c sigmap = abs ( sigma ) * float ( n - 1 ) / s ( n ) c c set up and perform interpolation c del1 = tn - s ( im1 ) del2 = s ( i ) - tn dels = s ( i ) - s ( im1 ) sumx = ( x ( i ) * del1 + x ( im1 ) * del2 ) / dels sumy = ( y ( i ) * del1 + y ( im1 ) * del2 ) / dels if ( sigmap . ne . 0. ) go to 1 d = del1 * del2 / ( 6. * dels ) c1 = ( del1 + dels ) * d c2 = ( del2 + dels ) * d xs = sumx - xp ( i ) * c1 - xp ( im1 ) * c2 ys = sumy - yp ( i ) * c1 - yp ( im1 ) * c2 return 1 sigdel = sigmap * dels call snhcsh ( ss , dummy , sigdel , - 1 ) call snhcsh ( s1 , dummy , sigmap * del1 , - 1 ) call snhcsh ( s2 , dummy , sigmap * del2 , - 1 ) d = sigdel * sigmap * ( 1. + ss ) c1 = del1 * ( s1 - ss ) / d c2 = del2 * ( s2 - ss ) / d xs = sumx + xp ( i ) * c1 + xp ( im1 ) * c2 ys = sumy + yp ( i ) * c1 + yp ( im1 ) * c2 return end subroutine kurvd ( t , xs , ys , xst , yst , xstt , ystt , n , x , y , xp , * yp , s , sigma ) c integer n real t , xs , ys , xst , yst , xstt , ystt , x ( n ), y ( n ), xp ( n ), yp ( n ), * s ( n ), sigma c c                                 coded by alan kaylor cline c                           from fitpack -- january 26, 1987 c                        a curve and surface fitting package c                      a product of pleasant valley software c                  8603 altus cove, austin, texas 78759, usa c c this subroutine performs the mapping of points in the c interval (0.,1.) onto a curve in the plane. it also c returns the first and second derivatives of the component c functions. the subroutine kurv1 should be called earlier c to determine certain necessary parameters. the resulting c curve has a parametric representation both of whose c components are splines under tension and functions of the c polygonal arclength parameter. c c on input-- c c   t contains a real value to be mapped to a point on the c   curve. the interval (0.,1.) is mapped onto the entire c   curve, with 0. mapping to (x(1),y(1)) and 1. mapping c   to (x(n),y(n)). values outside this interval result in c   extrapolation. c c   n contains the number of points which were specified c   to determine the curve. c c   x and y are arrays containing the x- and y-coordinates c   of the specified points. c c   xp and yp are the arrays output from kurv1 containing c   curvature information. c c   s is an array containing the polygonal arclengths of c   the curve. c c and c c   sigma contains the tension factor (its sign is ignored). c c the parameters n, x, y, xp, yp, s, and sigma should be c input unaltered from the output of kurv1. c c on output-- c c   xs and ys contain the x- and y-coordinates of the image c   point on the curve. xst and yst contain the first c   derivatives of the x- and y-components of the mapping c   with respect to t. xstt and ystt contain the second c   derivatives of the x- and y-components of the mapping c   with respect to t. c c none of the input parameters are altered. c c this subroutine references package modules intrvl and c snhcsh. c c----------------------------------------------------------- c c determine interval c tn = s ( n ) * t im1 = intrvl ( tn , s , n ) i = im1 + 1 c c denormalize tension factor c sigmap = abs ( sigma ) * float ( n - 1 ) / s ( n ) c c set up and perform interpolation c del1 = tn - s ( im1 ) del2 = s ( i ) - tn dels = s ( i ) - s ( im1 ) sumx = ( x ( i ) * del1 + x ( im1 ) * del2 ) / dels sumy = ( y ( i ) * del1 + y ( im1 ) * del2 ) / dels sumxt = s ( n ) * ( x ( i ) - x ( im1 )) / dels sumyt = s ( n ) * ( y ( i ) - y ( im1 )) / dels if ( sigmap . ne . 0. ) go to 1 dels6 = 6. * dels d = del1 * del2 / dels6 c1 = - ( del1 + dels ) * d c2 = - ( del2 + dels ) * d dels6 = dels6 / s ( n ) ct1 = ( 2. * del1 * del1 - del2 * ( del1 + dels )) / dels6 ct2 = - ( 2. * del2 * del2 - del1 * ( del2 + dels )) / dels6 dels = dels / ( s ( n ) * s ( n )) ctt1 = del1 / dels ctt2 = del2 / dels go to 2 1 sigdel = sigmap * dels call snhcsh ( ss , dummy , sigdel , - 1 ) call snhcsh ( s1 , co1 , sigmap * del1 , 0 ) call snhcsh ( s2 , co2 , sigmap * del2 , 0 ) d = sigdel * sigmap * ( 1. + ss ) c1 = del1 * ( s1 - ss ) / d c2 = del2 * ( s2 - ss ) / d ct1 = ( co1 - ss ) * s ( n ) / d ct2 = - ( co2 - ss ) * s ( n ) / d ctt1 = del1 * ( 1. + s1 ) * s ( n ) * s ( n ) / ( dels * ( 1. + ss )) ctt2 = del2 * ( 1. + s2 ) * s ( n ) * s ( n ) / ( dels * ( 1. + ss )) 2 xs = sumx + c1 * xp ( i ) + c2 * xp ( im1 ) ys = sumy + c1 * yp ( i ) + c2 * yp ( im1 ) xst = sumxt + ct1 * xp ( i ) + ct2 * xp ( im1 ) yst = sumyt + ct1 * yp ( i ) + ct2 * yp ( im1 ) xstt = ctt1 * xp ( i ) + ctt2 * xp ( im1 ) ystt = ctt1 * yp ( i ) + ctt2 * yp ( im1 ) return end subroutine kurvp1 ( n , x , y , xp , yp , temp , s , sigma , ierr ) c integer n , ierr real x ( n ), y ( n ), xp ( n ), yp ( n ), temp ( 1 ), s ( n ), sigma c c                                 coded by alan kaylor cline c                           from fitpack -- january 26, 1987 c                        a curve and surface fitting package c                      a product of pleasant valley software c                  8603 altus cove, austin, texas 78759, usa c c this subroutine determines the parameters necessary to c compute a spline under tension forming a closed curve in c the plane and passing through a sequence of pairs c (x(1),y(1)),...,(x(n),y(n)). for actual computation of c points on the curve it is necessary to call the subroutine c kurvp2. c c on input-- c c   n is the number of points to be interpolated (n.ge.2). c c   x is an array containing the n x-coordinates of the c   points. c c   y is an array containing the n y-coordinates of the c   points. (adjacent x-y pairs must be distinct, i. e. c   either x(i) .ne. x(i+1) or y(i) .ne. y(i+1), for c   i = 1,...,n-1 and either x(1) .ne. x(n) or y(1) .ne. y(n).) c c   xp and yp are arrays of length at least n. c c   temp is an array of length at least 2*n which is used c   for scratch storage. c c   s is an array of length at least n. c c and c c   sigma contains the tension factor. this value indicates c   the curviness desired. if abs(sigma) is nearly zero c   (e.g. .001) the resulting curve is approximately a cubic c   spline. if abs(sigma) is large (e. g. 50.) the resulting c   curve is nearly a polygonal line. if sigma equals zero a c   cubic spline results. a standard value for sigma is c   approximately 1. in absolute value. c c on output-- c c   xp and yp contain information about the curvature of the c   curve at the given nodes. c c   s contains the polygonal arclengths of the curve. c c   ierr contains an error flag, c        = 0 for normal return, c        = 1 if n is less than 2, c        = 2 if adjacent coordinate pairs coincide. c c and c c   n, x, y, and sigma are unaltered, c c this subroutine references package modules terms and c snhcsh. c c----------------------------------------------------------- c nm1 = n - 1 np1 = n + 1 ierr = 0 if ( n . le . 1 ) go to 7 c c determine polygonal arclengths c s ( 1 ) = sqrt (( x ( n ) - x ( 1 )) ** 2 + ( y ( n ) - y ( 1 )) ** 2 ) do 1 i = 2 , n im1 = i - 1 1 s ( i ) = s ( im1 ) + sqrt (( x ( i ) - x ( im1 )) ** 2 + * ( y ( i ) - y ( im1 )) ** 2 ) c c denormalize tension factor c sigmap = abs ( sigma ) * float ( n ) / s ( n ) c c set up right hand sides of tridiagonal (with corner c elements) linear system for xp and yp c dels1 = s ( 1 ) if ( dels1 . eq . 0. ) go to 8 dx1 = ( x ( 1 ) - x ( n )) / dels1 dy1 = ( y ( 1 ) - y ( n )) / dels1 call terms ( diag1 , sdiag1 , sigmap , dels1 ) dels2 = s ( 2 ) - s ( 1 ) if ( dels2 . eq . 0. ) go to 8 dx2 = ( x ( 2 ) - x ( 1 )) / dels2 dy2 = ( y ( 2 ) - y ( 1 )) / dels2 call terms ( diag2 , sdiag2 , sigmap , dels2 ) diag = diag1 + diag2 diagin = 1. / diag xp ( 1 ) = ( dx2 - dx1 ) * diagin yp ( 1 ) = ( dy2 - dy1 ) * diagin temp ( np1 ) = - sdiag1 * diagin temp ( 1 ) = sdiag2 * diagin dx1 = dx2 dy1 = dy2 diag1 = diag2 sdiag1 = sdiag2 if ( n . eq . 2 ) go to 3 do 2 i = 2 , nm1 npi = n + i dels2 = s ( i + 1 ) - s ( i ) if ( dels2 . eq . 0. ) go to 8 dx2 = ( x ( i + 1 ) - x ( i )) / dels2 dy2 = ( y ( i + 1 ) - y ( i )) / dels2 call terms ( diag2 , sdiag2 , sigmap , dels2 ) diag = diag1 + diag2 - sdiag1 * temp ( i - 1 ) diagin = 1. / diag xp ( i ) = ( dx2 - dx1 - sdiag1 * xp ( i - 1 )) * diagin yp ( i ) = ( dy2 - dy1 - sdiag1 * yp ( i - 1 )) * diagin temp ( npi ) = - temp ( npi - 1 ) * sdiag1 * diagin temp ( i ) = sdiag2 * diagin dx1 = dx2 dy1 = dy2 diag1 = diag2 2 sdiag1 = sdiag2 3 dels2 = s ( 1 ) dx2 = ( x ( 1 ) - x ( n )) / dels2 dy2 = ( y ( 1 ) - y ( n )) / dels2 call terms ( diag2 , sdiag2 , sigmap , dels2 ) xp ( n ) = dx2 - dx1 yp ( n ) = dy2 - dy1 temp ( nm1 ) = temp ( 2 * n - 1 ) - temp ( nm1 ) if ( n . eq . 2 ) go to 5 c c perform first step of back substitution c do 4 i = 3 , n ibak = np1 - i npibak = n + ibak xp ( ibak ) = xp ( ibak ) - temp ( ibak ) * xp ( ibak + 1 ) yp ( ibak ) = yp ( ibak ) - temp ( ibak ) * yp ( ibak + 1 ) 4 temp ( ibak ) = temp ( npibak ) - temp ( ibak ) * temp ( ibak + 1 ) 5 xp ( n ) = ( xp ( n ) - sdiag2 * xp ( 1 ) - sdiag1 * xp ( nm1 )) / * ( diag1 + diag2 + sdiag2 * temp ( 1 ) + sdiag1 * temp ( nm1 )) yp ( n ) = ( yp ( n ) - sdiag2 * yp ( 1 ) - sdiag1 * yp ( nm1 )) / * ( diag1 + diag2 + sdiag2 * temp ( 1 ) + sdiag1 * temp ( nm1 )) c c perform second step of back substitution c xpn = xp ( n ) ypn = yp ( n ) do 6 i = 1 , nm1 xp ( i ) = xp ( i ) + temp ( i ) * xpn 6 yp ( i ) = yp ( i ) + temp ( i ) * ypn return c c too few points c 7 ierr = 1 return c c coincident adjacent points c 8 ierr = 2 return end subroutine kurvp2 ( t , xs , ys , n , x , y , xp , yp , s , sigma ) c integer n real t , xs , ys , x ( n ), y ( n ), xp ( n ), yp ( n ), s ( n ), sigma c c                                 coded by alan kaylor cline c                           from fitpack -- january 26, 1987 c                        a curve and surface fitting package c                      a product of pleasant valley software c                  8603 altus cove, austin, texas 78759, usa c c this subroutine performs the mapping of points in the c interval (0.,1.) onto a closed curve in the plane. the c subroutine kurvp1 should be called earlier to determine c certain necessary parameters. the resulting curve has a c parametric representation both of whose components are c periodic splines under tension and functions of the poly- c gonal arclength parameter. c c on input-- c c   t contains a value to be mapped onto the curve. the c   interval (0.,1.) is mapped onto the entire closed curve c   with both 0. and 1. mapping to (x(1),y(1)). the mapping c   is periodic with period one thus any interval of the c   form (tt,tt+1.) maps onto the entire curve. c c   n contains the number of points which were specified c   to determine the curve. c c   x and y are arrays containing the x- and y-coordinates c   of the specified points. c c   xp and yp are the arrays output from kurvp1 containing c   curvature information. c c   s is an array containing the polygonal arclengths of c   the curve. c c and c c   sigma contains the tension factor (its sign is ignored). c c the parameters n, x, y, xp, yp, s and sigma should c be input unaltered from the output of kurvp1. c c on output-- c c   xs and ys contain the x- and y-coordinates of the image c   point on the curve. c c none of the input parameters are altered. c c this subroutine references package modules intrvl and c snhcsh. c c----------------------------------------------------------- c c determine interval c tn = t - float ( ifix ( t )) if ( tn . lt . 0. ) tn = tn + 1. tn = s ( n ) * tn + s ( 1 ) im1 = n if ( tn . lt . s ( n )) im1 = intrvl ( tn , s , n ) i = im1 + 1 if ( i . gt . n ) i = 1 c c denormalize tension factor c sigmap = abs ( sigma ) * float ( n ) / s ( n ) c c set up and perform interpolation c si = s ( i ) if ( im1 . eq . n ) si = s ( n ) + s ( 1 ) del1 = tn - s ( im1 ) del2 = si - tn dels = si - s ( im1 ) sumx = ( x ( i ) * del1 + x ( im1 ) * del2 ) / dels sumy = ( y ( i ) * del1 + y ( im1 ) * del2 ) / dels if ( sigmap . ne . 0. ) go to 1 d = del1 * del2 / ( 6. * dels ) c1 = ( del1 + dels ) * d c2 = ( del2 + dels ) * d xs = sumx - xp ( i ) * c1 - xp ( im1 ) * c2 ys = sumy - yp ( i ) * c1 - yp ( im1 ) * c2 return 1 sigdel = sigmap * dels call snhcsh ( ss , dummy , sigdel , - 1 ) call snhcsh ( s1 , dummy , sigmap * del1 , - 1 ) call snhcsh ( s2 , dummy , sigmap * del2 , - 1 ) d = sigdel * sigmap * ( 1. + ss ) ci = del1 * ( s1 - ss ) / d cim1 = del2 * ( s2 - ss ) / d xs = sumx + xp ( i ) * ci + xp ( im1 ) * cim1 ys = sumy + yp ( i ) * ci + yp ( im1 ) * cim1 return end subroutine kurvpd ( t , xs , ys , xst , yst , xstt , ystt , n , x , y , xp , * yp , s , sigma ) c integer n real t , xs , ys , xst , yst , xstt , ystt , x ( n ), y ( n ), xp ( n ), yp ( n ), * s ( n ), sigma c c                                 coded by alan kaylor cline c                           from fitpack -- january 26, 1987 c                        a curve and surface fitting package c                      a product of pleasant valley software c                  8603 altus cove, austin, texas 78759, usa c c this subroutine performs the mapping of points in the c interval (0.,1.) onto a closed curve in the plane. it also c returns the first and second derivatives of the component c functions. the subroutine kurvp1 should be called earlier c to determine certain necessary parameters. the resulting c curve has a parametric representation both of whose c components are periodic splines under tension and c functions of the polygonal arclength parameter. c c on input-- c c   t contains a value to be mapped onto the curve. the c   interval (0.,1.) is mapped onto the entire closed curve c   with both 0. and 1. mapping to (x(1),y(1)). the mapping c   is periodic with period one thus any interval of the c   form (tt,tt+1.) maps onto the entire curve. c c   n contains the number of points which were specified c   to determine the curve. c c   x and y are arrays containing the x- and y-coordinates c   of the specified points. c c   xp and yp are the arrays output from kurvp1 containing c   curvature information. c c   s is an array containing the polygonal arclengths of c   the curve. c c and c c   sigma contains the tension factor (its sign is ignored). c c the parameters n, x, y, xp, yp, s and sigma should c be input unaltered from the output of kurvp1. c c on output-- c c   xs and ys contain the x- and y-coordinates of the image c   point on the curve. xst and yst contain the first c   derivatives of the x- and y-components of the mapping c   with respect to t. xstt and ystt contain the second c   derivatives of the x- and y-components of the mapping c   with respect to t. c c none of the input parameters are altered. c c this subroutine references package modules intrvl and c snhcsh. c c----------------------------------------------------------- c c determine interval c tn = t - float ( ifix ( t )) if ( tn . lt . 0. ) tn = tn + 1. tn = s ( n ) * tn + s ( 1 ) im1 = n if ( tn . lt . s ( n )) im1 = intrvl ( tn , s , n ) i = im1 + 1 if ( i . gt . n ) i = 1 c c denormalize tension factor c sigmap = abs ( sigma ) * float ( n ) / s ( n ) c c set up and perform interpolation c si = s ( i ) if ( im1 . eq . n ) si = s ( n ) + s ( 1 ) del1 = tn - s ( im1 ) del2 = si - tn dels = si - s ( im1 ) sumx = ( x ( i ) * del1 + x ( im1 ) * del2 ) / dels sumy = ( y ( i ) * del1 + y ( im1 ) * del2 ) / dels sumxt = s ( n ) * ( x ( i ) - x ( im1 )) / dels sumyt = s ( n ) * ( y ( i ) - y ( im1 )) / dels if ( sigmap . ne . 0. ) go to 1 dels6 = 6. * dels d = del1 * del2 / dels6 c1 = - ( del1 + dels ) * d c2 = - ( del2 + dels ) * d dels6 = dels6 / s ( n ) ct1 = ( 2. * del1 * del1 - del2 * ( del1 + dels )) / dels6 ct2 = - ( 2. * del2 * del2 - del1 * ( del2 + dels )) / dels6 dels = dels / ( s ( n ) * s ( n )) ctt1 = del1 / dels ctt2 = del2 / dels go to 2 1 sigdel = sigmap * dels call snhcsh ( ss , dummy , sigdel , - 1 ) call snhcsh ( s1 , co1 , sigmap * del1 , 0 ) call snhcsh ( s2 , co2 , sigmap * del2 , 0 ) d = sigdel * sigmap * ( 1. + ss ) c1 = del1 * ( s1 - ss ) / d c2 = del2 * ( s2 - ss ) / d ct1 = ( co1 - ss ) * s ( n ) / d ct2 = - ( co2 - ss ) * s ( n ) / d ctt1 = del1 * ( 1. + s1 ) * s ( n ) * s ( n ) / ( dels * ( 1. + ss )) ctt2 = del2 * ( 1. + s2 ) * s ( n ) * s ( n ) / ( dels * ( 1. + ss )) 2 xs = sumx + c1 * xp ( i ) + c2 * xp ( im1 ) ys = sumy + c1 * yp ( i ) + c2 * yp ( im1 ) xst = sumxt + ct1 * xp ( i ) + ct2 * xp ( im1 ) yst = sumyt + ct1 * yp ( i ) + ct2 * yp ( im1 ) xstt = ctt1 * xp ( i ) + ctt2 * xp ( im1 ) ystt = ctt1 * yp ( i ) + ctt2 * yp ( im1 ) return end subroutine surf1 ( m , n , x , y , z , iz , zx1 , zxm , zy1 , zyn , zxy11 , * zxym1 , zxy1n , zxymn , islpsw , zp , temp , * sigma , ierr ) c integer m , n , iz , islpsw , ierr real x ( m ), y ( n ), z ( iz , n ), zx1 ( n ), zxm ( n ), zy1 ( m ), zyn ( m ), * zxy11 , zxym1 , zxy1n , zxymn , zp ( m , n , 3 ), temp ( 1 ), sigma c c                                 coded by alan kaylor cline c                           from fitpack -- january 26, 1987 c                        a curve and surface fitting package c                      a product of pleasant valley software c                  8603 altus cove, austin, texas 78759, usa c c this subroutine determines the parameters necessary to c compute an interpolatory surface passing through a rect- c angular grid of functional values. the surface determined c can be represented as the tensor product of splines under c tension. the x- and y-partial derivatives around the c boundary and the x-y-partial derivatives at the four c corners may be specified or omitted. for actual mapping c of points onto the surface it is necessary to call the c function surf2. c c on input-- c c   m is the number of grid lines in the x-direction, i. e. c   lines parallel to the y-axis (m .ge. 2). c c   n is the number of grid lines in the y-direction, i. e. c   lines parallel to the x-axis (n .ge. 2). c c   x is an array of the m x-coordinates of the grid lines c   in the x-direction. these should be strictly increasing. c c   y is an array of the n y-coordinates of the grid lines c   in the y-direction. these should be strictly increasing. c c   z is an array of the m * n functional values at the grid c   points, i. e. z(i,j) contains the functional value at c   (x(i),y(j)) for i = 1,...,m and j = 1,...,n. c c   iz is the row dimension of the matrix z used in the c   calling program (iz .ge. m). c c   zx1 and zxm are arrays of the m x-partial derivatives c   of the function along the x(1) and x(m) grid lines, c   respectively. thus zx1(j) and zxm(j) contain the x-part- c   ial derivatives at the points (x(1),y(j)) and c   (x(m),y(j)), respectively, for j = 1,...,n. either of c   these parameters will be ignored (and approximations c   supplied internally) if islpsw so indicates. c c   zy1 and zyn are arrays of the n y-partial derivatives c   of the function along the y(1) and y(n) grid lines, c   respectively. thus zy1(i) and zyn(i) contain the y-part- c   ial derivatives at the points (x(i),y(1)) and c   (x(i),y(n)), respectively, for i = 1,...,m. either of c   these parameters will be ignored (and estimations c   supplied internally) if islpsw so indicates. c c   zxy11, zxym1, zxy1n, and zxymn are the x-y-partial c   derivatives of the function at the four corners, c   (x(1),y(1)), (x(m),y(1)), (x(1),y(n)), and (x(m),y(n)), c   respectively. any of the parameters will be ignored (and c   estimations supplied internally) if islpsw so indicates. c c   islpsw contains a switch indicating which boundary c   derivative information is user-supplied and which c   should be estimated by this subroutine. to determine c   islpsw, let c        i1 = 0 if zx1 is user-supplied (and = 1 otherwise), c        i2 = 0 if zxm is user-supplied (and = 1 otherwise), c        i3 = 0 if zy1 is user-supplied (and = 1 otherwise), c        i4 = 0 if zyn is user-supplied (and = 1 otherwise), c        i5 = 0 if zxy11 is user-supplied c                                       (and = 1 otherwise), c        i6 = 0 if zxym1 is user-supplied c                                       (and = 1 otherwise), c        i7 = 0 if zxy1n is user-supplied c                                       (and = 1 otherwise), c        i8 = 0 if zxymn is user-supplied c                                       (and = 1 otherwise), c   then islpsw = i1 + 2*i2 + 4*i3 + 8*i4 + 16*i5 + 32*i6 c                   + 64*i7 + 128*i8 c   thus islpsw = 0 indicates all derivative information is c   user-supplied and islpsw = 255 indicates no derivative c   information is user-supplied. any value between these c   limits is valid. c c   zp is an array of at least 3*m*n locations. c c   temp is an array of at least n+n+m locations which is c   used for scratch storage. c c and c c   sigma contains the tension factor. this value indicates c   the curviness desired. if abs(sigma) is nearly zero c   (e. g. .001) the resulting surface is approximately the c   tensor product of cubic splines. if abs(sigma) is large c   (e. g. 50.) the resulting surface is approximately c   bi-linear. if sigma equals zero tensor products of c   cubic splines result. a standard value for sigma is c   approximately 1. in absolute value. c c on output-- c c   zp contains the values of the xx-, yy-, and xxyy-partial c   derivatives of the surface at the given nodes. c c   ierr contains an error flag, c        = 0 for normal return, c        = 1 if n is less than 2 or m is less than 2, c        = 2 if the x-values or y-values are not strictly c            increasing. c c and c c   m, n, x, y, z, iz, zx1, zxm, zy1, zyn, zxy11, zxym1, c   zxy1n, zxymn, islpsw, and sigma are unaltered. c c this subroutine references package modules ceez, terms, c and snhcsh. c c----------------------------------------------------------- c mm1 = m - 1 mp1 = m + 1 nm1 = n - 1 np1 = n + 1 npm = n + m ierr = 0 if ( n . le . 1 . or . m . le . 1 ) go to 46 if ( y ( n ) . le . y ( 1 )) go to 47 c c denormalize tension factor in y-direction c sigmay = abs ( sigma ) * float ( n - 1 ) / ( y ( n ) - y ( 1 )) c c obtain y-partial derivatives along y = y(1) c if (( islpsw / 8 ) * 2 . ne . ( islpsw / 4 )) go to 2 do 1 i = 1 , m 1 zp ( i , 1 , 1 ) = zy1 ( i ) go to 5 2 dely1 = y ( 2 ) - y ( 1 ) dely2 = dely1 + dely1 if ( n . gt . 2 ) dely2 = y ( 3 ) - y ( 1 ) if ( dely1 . le . 0. . or . dely2 . le . dely1 ) go to 47 call ceez ( dely1 , dely2 , sigmay , c1 , c2 , c3 , n ) do 3 i = 1 , m 3 zp ( i , 1 , 1 ) = c1 * z ( i , 1 ) + c2 * z ( i , 2 ) if ( n . eq . 2 ) go to 5 do 4 i = 1 , m 4 zp ( i , 1 , 1 ) = zp ( i , 1 , 1 ) + c3 * z ( i , 3 ) c c obtain y-partial derivatives along y = y(n) c 5 if (( islpsw / 16 ) * 2 . ne . ( islpsw / 8 )) go to 7 do 6 i = 1 , m npi = n + i 6 temp ( npi ) = zyn ( i ) go to 10 7 delyn = y ( n ) - y ( nm1 ) delynm = delyn + delyn if ( n . gt . 2 ) delynm = y ( n ) - y ( n - 2 ) if ( delyn . le . 0. . or . delynm . le . delyn ) go to 47 call ceez ( - delyn , - delynm , sigmay , c1 , c2 , c3 , n ) do 8 i = 1 , m npi = n + i 8 temp ( npi ) = c1 * z ( i , n ) + c2 * z ( i , nm1 ) if ( n . eq . 2 ) go to 10 do 9 i = 1 , m npi = n + i 9 temp ( npi ) = temp ( npi ) + c3 * z ( i , n - 2 ) 10 if ( x ( m ) . le . x ( 1 )) go to 47 c c denormalize tension factor in x-direction c sigmax = abs ( sigma ) * float ( m - 1 ) / ( x ( m ) - x ( 1 )) c c obtain x-partial derivatives along x = x(1) c if (( islpsw / 2 ) * 2 . ne . islpsw ) go to 12 do 11 j = 1 , n 11 zp ( 1 , j , 2 ) = zx1 ( j ) if (( islpsw / 32 ) * 2 . eq . ( islpsw / 16 ) . and . * ( islpsw / 128 ) * 2 . eq . ( islpsw / 64 )) go to 15 12 delx1 = x ( 2 ) - x ( 1 ) delx2 = delx1 + delx1 if ( m . gt . 2 ) delx2 = x ( 3 ) - x ( 1 ) if ( delx1 . le . 0. . or . delx2 . le . delx1 ) go to 47 call ceez ( delx1 , delx2 , sigmax , c1 , c2 , c3 , m ) if (( islpsw / 2 ) * 2 . eq . islpsw ) go to 15 do 13 j = 1 , n 13 zp ( 1 , j , 2 ) = c1 * z ( 1 , j ) + c2 * z ( 2 , j ) if ( m . eq . 2 ) go to 15 do 14 j = 1 , n 14 zp ( 1 , j , 2 ) = zp ( 1 , j , 2 ) + c3 * z ( 3 , j ) c c obtain x-y-partial derivative at (x(1),y(1)) c 15 if (( islpsw / 32 ) * 2 . ne . ( islpsw / 16 )) go to 16 zp ( 1 , 1 , 3 ) = zxy11 go to 17 16 zp ( 1 , 1 , 3 ) = c1 * zp ( 1 , 1 , 1 ) + c2 * zp ( 2 , 1 , 1 ) if ( m . gt . 2 ) zp ( 1 , 1 , 3 ) = zp ( 1 , 1 , 3 ) + c3 * zp ( 3 , 1 , 1 ) c c obtain x-y-partial derivative at (x(1),y(n)) c 17 if (( islpsw / 128 ) * 2 . ne . ( islpsw / 64 )) go to 18 zxy1ns = zxy1n go to 19 18 zxy1ns = c1 * temp ( n + 1 ) + c2 * temp ( n + 2 ) if ( m . gt . 2 ) zxy1ns = zxy1ns + c3 * temp ( n + 3 ) c c obtain x-partial derivative along x = x(m) c 19 if (( islpsw / 4 ) * 2 . ne . ( islpsw / 2 )) go to 21 do 20 j = 1 , n npmpj = npm + j 20 temp ( npmpj ) = zxm ( j ) if (( islpsw / 64 ) * 2 . eq . ( islpsw / 32 ) . and . * ( islpsw / 256 ) * 2 . eq . ( islpsw / 128 )) go to 24 21 delxm = x ( m ) - x ( mm1 ) delxmm = delxm + delxm if ( m . gt . 2 ) delxmm = x ( m ) - x ( m - 2 ) if ( delxm . le . 0. . or . delxmm . le . delxm ) go to 47 call ceez ( - delxm , - delxmm , sigmax , c1 , c2 , c3 , m ) if (( islpsw / 4 ) * 2 . eq . ( islpsw / 2 )) go to 24 do 22 j = 1 , n npmpj = npm + j 22 temp ( npmpj ) = c1 * z ( m , j ) + c2 * z ( mm1 , j ) if ( m . eq . 2 ) go to 24 do 23 j = 1 , n npmpj = npm + j 23 temp ( npmpj ) = temp ( npmpj ) + c3 * z ( m - 2 , j ) c c obtain x-y-partial derivative at (x(m),y(1)) c 24 if (( islpsw / 64 ) * 2 . ne . ( islpsw / 32 )) go to 25 zp ( m , 1 , 3 ) = zxym1 go to 26 25 zp ( m , 1 , 3 ) = c1 * zp ( m , 1 , 1 ) + c2 * zp ( mm1 , 1 , 1 ) if ( m . gt . 2 ) zp ( m , 1 , 3 ) = zp ( m , 1 , 3 ) + c3 * zp ( m - 2 , 1 , 1 ) c c obtain x-y-partial derivative at (x(m),y(n)) c 26 if (( islpsw / 256 ) * 2 . ne . ( islpsw / 128 )) go to 27 zxymns = zxymn go to 28 27 zxymns = c1 * temp ( npm ) + c2 * temp ( npm - 1 ) if ( m . gt . 2 ) zxymns = zxymns + c3 * temp ( npm - 2 ) c c set up right hand sides and tridiagonal system for y-grid c perform forward elimination c 28 del1 = y ( 2 ) - y ( 1 ) if ( del1 . le . 0. ) go to 47 deli = 1. / del1 do 29 i = 1 , m 29 zp ( i , 2 , 1 ) = deli * ( z ( i , 2 ) - z ( i , 1 )) zp ( 1 , 2 , 3 ) = deli * ( zp ( 1 , 2 , 2 ) - zp ( 1 , 1 , 2 )) zp ( m , 2 , 3 ) = deli * ( temp ( npm + 2 ) - temp ( npm + 1 )) call terms ( diag1 , sdiag1 , sigmay , del1 ) diagi = 1. / diag1 do 30 i = 1 , m 30 zp ( i , 1 , 1 ) = diagi * ( zp ( i , 2 , 1 ) - zp ( i , 1 , 1 )) zp ( 1 , 1 , 3 ) = diagi * ( zp ( 1 , 2 , 3 ) - zp ( 1 , 1 , 3 )) zp ( m , 1 , 3 ) = diagi * ( zp ( m , 2 , 3 ) - zp ( m , 1 , 3 )) temp ( 1 ) = diagi * sdiag1 if ( n . eq . 2 ) go to 34 do 33 j = 2 , nm1 jm1 = j - 1 jp1 = j + 1 npmpj = npm + j del2 = y ( jp1 ) - y ( j ) if ( del2 . le . 0. ) go to 47 deli = 1. / del2 do 31 i = 1 , m 31 zp ( i , jp1 , 1 ) = deli * ( z ( i , jp1 ) - z ( i , j )) zp ( 1 , jp1 , 3 ) = deli * ( zp ( 1 , jp1 , 2 ) - zp ( 1 , j , 2 )) zp ( m , jp1 , 3 ) = deli * ( temp ( npmpj + 1 ) - temp ( npmpj )) call terms ( diag2 , sdiag2 , sigmay , del2 ) diagin = 1. / ( diag1 + diag2 - sdiag1 * temp ( jm1 )) do 32 i = 1 , m 32 zp ( i , j , 1 ) = diagin * ( zp ( i , jp1 , 1 ) - zp ( i , j , 1 ) - * sdiag1 * zp ( i , jm1 , 1 )) zp ( 1 , j , 3 ) = diagin * ( zp ( 1 , jp1 , 3 ) - zp ( 1 , j , 3 ) - * sdiag1 * zp ( 1 , jm1 , 3 )) zp ( m , j , 3 ) = diagin * ( zp ( m , jp1 , 3 ) - zp ( m , j , 3 ) - * sdiag1 * zp ( m , jm1 , 3 )) temp ( j ) = diagin * sdiag2 diag1 = diag2 33 sdiag1 = sdiag2 34 diagin = 1. / ( diag1 - sdiag1 * temp ( nm1 )) do 35 i = 1 , m npi = n + i 35 zp ( i , n , 1 ) = diagin * ( temp ( npi ) - zp ( i , n , 1 ) - * sdiag1 * zp ( i , nm1 , 1 )) zp ( 1 , n , 3 ) = diagin * ( zxy1ns - zp ( 1 , n , 3 ) - * sdiag1 * zp ( 1 , nm1 , 3 )) temp ( n ) = diagin * ( zxymns - zp ( m , n , 3 ) - * sdiag1 * zp ( m , nm1 , 3 )) c c perform back substitution c do 37 j = 2 , n jbak = np1 - j jbakp1 = jbak + 1 t = temp ( jbak ) do 36 i = 1 , m 36 zp ( i , jbak , 1 ) = zp ( i , jbak , 1 ) - t * zp ( i , jbakp1 , 1 ) zp ( 1 , jbak , 3 ) = zp ( 1 , jbak , 3 ) - t * zp ( 1 , jbakp1 , 3 ) 37 temp ( jbak ) = zp ( m , jbak , 3 ) - t * temp ( jbakp1 ) c c set up right hand sides and tridiagonal system for x-grid c perform forward elimination c del1 = x ( 2 ) - x ( 1 ) if ( del1 . le . 0. ) go to 47 deli = 1. / del1 do 38 j = 1 , n zp ( 2 , j , 2 ) = deli * ( z ( 2 , j ) - z ( 1 , j )) 38 zp ( 2 , j , 3 ) = deli * ( zp ( 2 , j , 1 ) - zp ( 1 , j , 1 )) call terms ( diag1 , sdiag1 , sigmax , del1 ) diagi = 1. / diag1 do 39 j = 1 , n zp ( 1 , j , 2 ) = diagi * ( zp ( 2 , j , 2 ) - zp ( 1 , j , 2 )) 39 zp ( 1 , j , 3 ) = diagi * ( zp ( 2 , j , 3 ) - zp ( 1 , j , 3 )) temp ( n + 1 ) = diagi * sdiag1 if ( m . eq . 2 ) go to 43 do 42 i = 2 , mm1 im1 = i - 1 ip1 = i + 1 npi = n + i del2 = x ( ip1 ) - x ( i ) if ( del2 . le . 0. ) go to 47 deli = 1. / del2 do 40 j = 1 , n zp ( ip1 , j , 2 ) = deli * ( z ( ip1 , j ) - z ( i , j )) 40 zp ( ip1 , j , 3 ) = deli * ( zp ( ip1 , j , 1 ) - zp ( i , j , 1 )) call terms ( diag2 , sdiag2 , sigmax , del2 ) diagin = 1. / ( diag1 + diag2 - sdiag1 * temp ( npi - 1 )) do 41 j = 1 , n zp ( i , j , 2 ) = diagin * ( zp ( ip1 , j , 2 ) - zp ( i , j , 2 ) - * sdiag1 * zp ( im1 , j , 2 )) 41 zp ( i , j , 3 ) = diagin * ( zp ( ip1 , j , 3 ) - zp ( i , j , 3 ) - * sdiag1 * zp ( im1 , j , 3 )) temp ( npi ) = diagin * sdiag2 diag1 = diag2 42 sdiag1 = sdiag2 43 diagin = 1. / ( diag1 - sdiag1 * temp ( npm - 1 )) do 44 j = 1 , n npmpj = npm + j zp ( m , j , 2 ) = diagin * ( temp ( npmpj ) - zp ( m , j , 2 ) - * sdiag1 * zp ( mm1 , j , 2 )) 44 zp ( m , j , 3 ) = diagin * ( temp ( j ) - zp ( m , j , 3 ) - * sdiag1 * zp ( mm1 , j , 3 )) c c perform back substitution c do 45 i = 2 , m ibak = mp1 - i ibakp1 = ibak + 1 npibak = n + ibak t = temp ( npibak ) do 45 j = 1 , n zp ( ibak , j , 2 ) = zp ( ibak , j , 2 ) - t * zp ( ibakp1 , j , 2 ) 45 zp ( ibak , j , 3 ) = zp ( ibak , j , 3 ) - t * zp ( ibakp1 , j , 3 ) return c c too few points c 46 ierr = 1 return c c points not strictly increasing c 47 ierr = 2 return end function surf2 ( xx , yy , m , n , x , y , z , iz , zp , sigma ) c integer m , n , iz real xx , yy , x ( m ), y ( n ), z ( iz , n ), zp ( m , n , 3 ), sigma c c                                 coded by alan kaylor cline c                           from fitpack -- january 26, 1987 c                        a curve and surface fitting package c                      a product of pleasant valley software c                  8603 altus cove, austin, texas 78759, usa c c this function interpolates a surface at a given coordinate c pair using a bi-spline under tension. the subroutine surf1 c should be called earlier to determine certain necessary c parameters. c c on input-- c c   xx and yy contain the x- and y-coordinates of the point c   to be mapped onto the interpolating surface. c c   m and n contain the number of grid lines in the x- and c   y-directions, respectively, of the rectangular grid c   which specified the surface. c c   x and y are arrays containing the x- and y-grid values, c   respectively, each in increasing order. c c   z is a matrix containing the m * n functional values c   corresponding to the grid values (i. e. z(i,j) is the c   surface value at the point (x(i),y(j)) for i = 1,...,m c   and j = 1,...,n). c c   iz contains the row dimension of the array z as declared c   in the calling program. c c   zp is an array of 3*m*n locations stored with the c   various surface derivative information determined by c   surf1. c c and c c   sigma contains the tension factor (its sign is ignored). c c the parameters m, n, x, y, z, iz, zp, and sigma should be c input unaltered from the output of surf1. c c on output-- c c   surf2 contains the interpolated surface value. c c none of the input parameters are altered. c c this function references package modules intrvl and c snhcsh. c c----------------------------------------------------------- c c inline one dimensional cubic spline interpolation c hermz ( f1 , f2 , fp1 , fp2 ) = ( f2 * del1 + f1 * del2 ) / dels - del1 * * del2 * ( fp2 * ( del1 + dels ) + * fp1 * ( del2 + dels )) / * ( 6. * dels ) c c inline one dimensional spline under tension interpolation c hermnz ( f1 , f2 , fp1 , fp2 , sigmap ) = ( f2 * del1 + f1 * del2 ) / dels * + ( fp2 * del1 * ( sinhm1 - sinhms ) * + fp1 * del2 * ( sinhm2 - sinhms ) * ) / ( sigmap * sigmap * dels * ( 1. + sinhms )) c c denormalize tension factor in x and y direction c sigmax = abs ( sigma ) * float ( m - 1 ) / ( x ( m ) - x ( 1 )) sigmay = abs ( sigma ) * float ( n - 1 ) / ( y ( n ) - y ( 1 )) c c determine y interval c jm1 = intrvl ( yy , y , n ) j = jm1 + 1 c c determine x interval c im1 = intrvl ( xx , x , m ) i = im1 + 1 del1 = yy - y ( jm1 ) del2 = y ( j ) - yy dels = y ( j ) - y ( jm1 ) if ( sigmay . ne . 0. ) go to 1 c c perform four interpolations in y-direction c zim1 = hermz ( z ( i - 1 , j - 1 ), z ( i - 1 , j ), zp ( i - 1 , j - 1 , 1 ), * zp ( i - 1 , j , 1 )) zi = hermz ( z ( i , j - 1 ), z ( i , j ), zp ( i , j - 1 , 1 ), zp ( i , j , 1 )) zxxim1 = hermz ( zp ( i - 1 , j - 1 , 2 ), zp ( i - 1 , j , 2 ), * zp ( i - 1 , j - 1 , 3 ), zp ( i - 1 , j , 3 )) zxxi = hermz ( zp ( i , j - 1 , 2 ), zp ( i , j , 2 ), * zp ( i , j - 1 , 3 ), zp ( i , j , 3 )) go to 2 1 call snhcsh ( sinhm1 , dummy , sigmay * del1 , - 1 ) call snhcsh ( sinhm2 , dummy , sigmay * del2 , - 1 ) call snhcsh ( sinhms , dummy , sigmay * dels , - 1 ) zim1 = hermnz ( z ( i - 1 , j - 1 ), z ( i - 1 , j ), zp ( i - 1 , j - 1 , 1 ), * zp ( i - 1 , j , 1 ), sigmay ) zi = hermnz ( z ( i , j - 1 ), z ( i , j ), zp ( i , j - 1 , 1 ), zp ( i , j , 1 ), * sigmay ) zxxim1 = hermnz ( zp ( i - 1 , j - 1 , 2 ), zp ( i - 1 , j , 2 ), * zp ( i - 1 , j - 1 , 3 ), zp ( i - 1 , j , 3 ), sigmay ) zxxi = hermnz ( zp ( i , j - 1 , 2 ), zp ( i , j , 2 ), * zp ( i , j - 1 , 3 ), zp ( i , j , 3 ), sigmay ) c c perform final interpolation in x-direction c 2 del1 = xx - x ( im1 ) del2 = x ( i ) - xx dels = x ( i ) - x ( im1 ) if ( sigmax . ne . 0. ) go to 3 surf2 = hermz ( zim1 , zi , zxxim1 , zxxi ) return 3 call snhcsh ( sinhm1 , dummy , sigmax * del1 , - 1 ) call snhcsh ( sinhm2 , dummy , sigmax * del2 , - 1 ) call snhcsh ( sinhms , dummy , sigmax * dels , - 1 ) surf2 = hermnz ( zim1 , zi , zxxim1 , zxxi , sigmax ) return end subroutine ceez ( del1 , del2 , sigma , c1 , c2 , c3 , n ) c real del1 , del2 , sigma , c1 , c2 , c3 c c                                 coded by alan kaylor cline c                           from fitpack -- january 26, 1987 c                        a curve and surface fitting package c                      a product of pleasant valley software c                  8603 altus cove, austin, texas 78759, usa c c this subroutine determines the coefficients c1, c2, and c3 c used to determine endpoint slopes. specifically, if c function values y1, y2, and y3 are given at points x1, x2, c and x3, respectively, the quantity c1*y1 + c2*y2 + c3*y3 c is the value of the derivative at x1 of a spline under c tension (with tension factor sigma) passing through the c three points and having third derivative equal to zero at c x1. optionally, only two values, c1 and c2 are determined. c c on input-- c c   del1 is x2-x1 (.gt. 0.). c c   del2 is x3-x1 (.gt. 0.). if n .eq. 2, this parameter is c   ignored. c c   sigma is the tension factor. c c and c c   n is a switch indicating the number of coefficients to c   be returned. if n .eq. 2 only two coefficients are c   returned. otherwise all three are returned. c c on output-- c c   c1, c2, and c3 contain the coefficients. c c none of the input parameters are altered. c c this subroutine references package module snhcsh. c c----------------------------------------------------------- c if ( n . eq . 2 ) go to 2 if ( sigma . ne . 0. ) go to 1 del = del2 - del1 c c tension .eq. 0. c c1 = - ( del1 + del2 ) / ( del1 * del2 ) c2 = del2 / ( del1 * del ) c3 = - del1 / ( del2 * del ) return c c tension .ne. 0. c 1 call snhcsh ( dummy , coshm1 , sigma * del1 , 1 ) call snhcsh ( dummy , coshm2 , sigma * del2 , 1 ) delp = sigma * ( del2 + del1 ) / 2. delm = sigma * ( del2 - del1 ) / 2. call snhcsh ( sinhmp , dummy , delp , - 1 ) call snhcsh ( sinhmm , dummy , delm , - 1 ) denom = coshm1 * ( del2 - del1 ) - 2. * del1 * delp * delm * * ( 1. + sinhmp ) * ( 1. + sinhmm ) c1 = 2. * delp * delm * ( 1. + sinhmp ) * ( 1. + sinhmm ) / denom c2 = - coshm2 / denom c3 = coshm1 / denom return c c two coefficients c 2 c1 = - 1. / del1 c2 = - c1 return end subroutine curvpp ( n , x , y , p , d , isw , s , eps , ys , ysp , sigma , * td , tsd1 , hd , hsd1 , hsd2 , rd , rsd1 , rsd2 , * rnm1 , rn , v , ierr ) c integer n , isw , ierr real x ( n ), y ( n ), p , d ( n ), s , eps , ys ( n ), ysp ( n ), sigma , td ( n ), * tsd1 ( n ), hd ( n ), hsd1 ( n ), hsd2 ( n ), rd ( n ), rsd1 ( n ), * rsd2 ( n ), rnm1 ( n ), rn ( n ), v ( n ) c c                                 coded by alan kaylor cline c                           from fitpack -- january 26, 1987 c                        a curve and surface fitting package c                      a product of pleasant valley software c                  8603 altus cove, austin, texas 78759, usa c c this subroutine determines the parameters necessary to c compute a periodic smoothing spline under tension. for a c given increasing sequence of abscissae (x(i)), i = 1,...,n c and associated ordinates (y(i)), i = 1,...,n, letting p be c the period, x(n+1) = x(1)+p, and y(n+1) = y(1), the c function determined minimizes the summation from i = 1 to c n of the square of the second derivative of f plus sigma c squared times the difference of the first derivative of f c and (f(x(i+1))-f(x(i)))/(x(i+1)-x(i)) squared, over all c functions f with period p and two continuous derivatives c such that the summation of the square of c (f(x(i))-y(i))/d(i) is less than or equal to a given c constant s, where (d(i)), i = 1,...,n are a given set of c observation weights. the function determined is a periodic c spline under tension with third derivative discontinuities c at (x(i)) i = 1,...,n (and all periodic translations of c these values). for actual computation of points on the c curve it is necessary to call the function curvp2. c c on input-- c c   n is the number of values to be smoothed (n.ge.2). c c   x is an array of the n increasing abscissae of the c   values to be smoothed. c c   y is an array of the n ordinates of the values to be c   smoothed, (i. e. y(k) is the functional value c   corresponding to x(k) ). c c   p is the period (p .gt. x(n)-x(1)). c c   d is a parameter containing the observation weights. c   this may either be an array of length n or a scalar c   (interpreted as a constant). the value of d c   corresponding to the observation (x(k),y(k)) should c   be an approximation to the standard deviation of error. c c   isw contains a switch indicating whether the parameter c   d is to be considered a vector or a scalar, c          = 0 if d is an array of length n, c          = 1 if d is a scalar. c c   s contains the value controlling the smoothing. this c   must be non-negative. for s equal to zero, the c   subroutine does interpolation, larger values lead to c   smoother funtions. if parameter d contains standard c   deviation estimates, a reasonable value for s is c   float(n). c c   eps contains a tolerance on the relative precision to c   which s is to be interpreted. this must be greater than c   or equal to zero and less than equal or equal to one. a c   reasonable value for eps is sqrt(2./float(n)). c c   ys is an array of length at least n. c c   ysp is an array of length at least n. c c   sigma contains the tension factor. this value indicates c   the degree to which the first derivative part of the c   smoothing functional is emphasized. if sigma is nearly c   zero (e. g. .001) the resulting curve is approximately a c   cubic spline. if sigma is large (e. g. 50.) the c   resulting curve is nearly a polygonal line. if sigma c   equals zero a cubic spline results. a standard value for c   sigma is approximately 1. c c and c c   td, tsd1, hd, hsd1, hsd2, rd, rsd1, rsd2, rnm1, rn, and c   v are arrays of length at least n which are used for c   scratch storage. c c on output-- c c   ys contains the smoothed ordinate values. c c   ysp contains the values of the second derivative of the c   smoothed curve at the given nodes. c c   ierr contains an error flag, c        = 0 for normal return, c        = 1 if n is less than 2, c        = 2 if s is negative, c        = 3 if eps is negative or greater than one, c        = 4 if x-values are not strictly increasing, c        = 5 if a d-value is non-positive, c        = 6 if p is less than or equal to x(n)-x(1). c c and c c   n, x, y, d, isw, s, eps, and sigma are unaltered. c c this subroutine references package modules terms and c snhcsh. c c----------------------------------------------------------- c if ( n . lt . 2 ) go to 25 if ( s . lt . 0. ) go to 26 if ( eps . lt . 0. . or . eps . gt . 1. ) go to 27 if ( p . le . x ( n ) - x ( 1 )) go to 30 ierr = 0 q = 0. rsd1 ( 1 ) = 0. rsd2 ( 1 ) = 0. rsd2 ( 2 ) = 0. rsd1 ( n - 1 ) = 0. rsd2 ( n - 1 ) = 0. rsd2 ( n ) = 0. c c denormalize tension factor c sigmap = abs ( sigma ) * float ( n ) / p c c form t matrix and second differences of y into ys c nm1 = n - 1 nm2 = n - 2 nm3 = n - 3 delxi1 = x ( 1 ) + p - x ( n ) delyi1 = ( y ( 1 ) - y ( n )) / delxi1 call terms ( dim1 , tsd1 ( 1 ), sigmap , delxi1 ) hsd1 ( 1 ) = 1. / delxi1 do 1 i = 1 , n ip1 = i + 1 if ( i . eq . n ) ip1 = 1 delxi = x ( ip1 ) - x ( i ) if ( i . eq . n ) delxi = x ( 1 ) + p - x ( n ) if ( delxi . le . 0. ) go to 28 delyi = ( y ( ip1 ) - y ( i )) / delxi ys ( i ) = delyi - delyi1 call terms ( di , tsd1 ( ip1 ), sigmap , delxi ) td ( i ) = di + dim1 hd ( i ) = - ( 1. / delxi + 1. / delxi1 ) hsd1 ( ip1 ) = 1. / delxi delxi1 = delxi delyi1 = delyi 1 dim1 = di hsd11 = hsd1 ( 1 ) if ( n . ge . 3 ) go to 2 tsd1 ( 2 ) = tsd1 ( 1 ) + tsd1 ( 2 ) tsd1 ( 1 ) = 0. hsd1 ( 2 ) = hsd1 ( 1 ) + hsd1 ( 2 ) hsd1 ( 1 ) = 0. c c calculate lower and upper tolerances c 2 sl = s * ( 1. - eps ) su = s * ( 1. + eps ) if ( d ( 1 ) . le . 0. ) go to 29 if ( isw . eq . 1 ) go to 5 c c form h matrix - d array c betapp = hsd1 ( n ) * d ( n ) * d ( n ) betap = hsd1 ( 1 ) * d ( 1 ) * d ( 1 ) alphap = hd ( n ) * d ( n ) * d ( n ) im1 = n sumd = 0. sumy = 0. do 3 i = 1 , n disq = d ( i ) * d ( i ) sumd = sumd + 1. / disq sumy = sumy + y ( i ) / disq ip1 = i + 1 if ( i . eq . n ) ip1 = 1 alpha = hd ( i ) * disq if ( d ( ip1 ) . le . 0. ) go to 29 hsd1ip = hsd1 ( ip1 ) if ( i . eq . n ) hsd1ip = hsd11 beta = hsd1ip * d ( ip1 ) * d ( ip1 ) hd ( i ) = ( hsd1 ( i ) * d ( im1 )) ** 2 + alpha * hd ( i ) * + beta * hsd1ip hsd2 ( i ) = hsd1 ( i ) * betapp hsd1 ( i ) = hsd1 ( i ) * ( alpha + alphap ) im1 = i alphap = alpha betapp = betap 3 betap = beta if ( n . eq . 3 ) hsd1 ( 3 ) = hsd1 ( 3 ) + hsd2 ( 2 ) c c test for straight line fit c con = sumy / sumd sum = 0. do 4 i = 1 , n 4 sum = sum + (( y ( i ) - con ) / d ( i )) ** 2 if ( sum . le . su ) go to 23 go to 8 c c form h matrix - d constant c 5 sl = d ( 1 ) * d ( 1 ) * sl su = d ( 1 ) * d ( 1 ) * su hsd1p = hsd1 ( n ) hdim1 = hd ( n ) sumy = 0. do 6 i = 1 , n sumy = sumy + y ( i ) hsd1ip = hsd11 if ( i . lt . n ) hsd1ip = hsd1 ( i + 1 ) hdi = hd ( i ) hd ( i ) = hsd1 ( i ) * hsd1 ( i ) + hdi * hdi + hsd1ip * hsd1ip hsd2 ( i ) = hsd1 ( i ) * hsd1p hsd1p = hsd1 ( i ) hsd1 ( i ) = hsd1p * ( hdi + hdim1 ) 6 hdim1 = hdi if ( n . eq . 3 ) hsd1 ( 3 ) = hsd1 ( 3 ) + hsd2 ( 2 ) c c test for straight line fit c con = sumy / float ( n ) sum = 0. do 7 i = 1 , n 7 sum = sum + ( y ( i ) - con ) ** 2 if ( sum . le . su ) go to 23 c c top of iteration c cholesky factorization of q*t+h into r c c c i = 1 c 8 rd ( 1 ) = 1. / ( q * td ( 1 ) + hd ( 1 )) rnm1 ( 1 ) = hsd2 ( 1 ) yspnm1 = ys ( nm1 ) rn ( 1 ) = q * tsd1 ( 1 ) + hsd1 ( 1 ) yspn = ys ( n ) ysp ( 1 ) = ys ( 1 ) rsd1i = q * tsd1 ( 2 ) + hsd1 ( 2 ) rsd1 ( 2 ) = rsd1i * rd ( 1 ) sumnm1 = 0. sum2 = 0. sumn = 0. if ( n . eq . 3 ) go to 11 if ( n . eq . 2 ) go to 12 c c i = 2 c rd ( 2 ) = 1. / ( q * td ( 2 ) + hd ( 2 ) - rsd1i * rsd1 ( 2 )) rnm1 ( 2 ) = - rnm1 ( 1 ) * rsd1 ( 2 ) rn ( 2 ) = hsd2 ( 2 ) - rn ( 1 ) * rsd1 ( 2 ) ysp ( 2 ) = ys ( 2 ) - rsd1 ( 2 ) * ysp ( 1 ) if ( n . eq . 4 ) go to 10 do 9 i = 3 , nm2 rsd2i = hsd2 ( i ) rsd1i = q * tsd1 ( i ) + hsd1 ( i ) - rsd2i * rsd1 ( i - 1 ) rsd2 ( i ) = rsd2i * rd ( i - 2 ) rsd1 ( i ) = rsd1i * rd ( i - 1 ) rd ( i ) = 1. / ( q * td ( i ) + hd ( i ) - rsd1i * rsd1 ( i ) * - rsd2i * rsd2 ( i )) rnm1 ( i ) = - rnm1 ( i - 2 ) * rsd2 ( i ) - rnm1 ( i - 1 ) * rsd1 ( i ) rnm1t = rnm1 ( i - 2 ) * rd ( i - 2 ) sumnm1 = sumnm1 + rnm1t * rnm1 ( i - 2 ) rnm1 ( i - 2 ) = rnm1t sum2 = sum2 + rnm1t * rn ( i - 2 ) yspnm1 = yspnm1 - rnm1t * ysp ( i - 2 ) rn ( i ) = - rn ( i - 2 ) * rsd2 ( i ) - rn ( i - 1 ) * rsd1 ( i ) rnt = rn ( i - 2 ) * rd ( i - 2 ) sumn = sumn + rnt * rn ( i - 2 ) rn ( i - 2 ) = rnt yspn = yspn - rnt * ysp ( i - 2 ) 9 ysp ( i ) = ys ( i ) - rsd1 ( i ) * ysp ( i - 1 ) - rsd2 ( i ) * ysp ( i - 2 ) c c i = n-3 c 10 rnm1 ( nm3 ) = hsd2 ( nm1 ) + rnm1 ( nm3 ) rnm1 ( nm2 ) = rnm1 ( nm2 ) - hsd2 ( nm1 ) * rsd1 ( nm2 ) rnm1t = rnm1 ( nm3 ) * rd ( nm3 ) sumnm1 = sumnm1 + rnm1t * rnm1 ( nm3 ) rnm1 ( nm3 ) = rnm1t sum2 = sum2 + rnm1t * rn ( nm3 ) yspnm1 = yspnm1 - rnm1t * ysp ( nm3 ) rnt = rn ( nm3 ) * rd ( nm3 ) sumn = sumn + rnt * rn ( nm3 ) rn ( nm3 ) = rnt yspn = yspn - rnt * ysp ( nm3 ) c c i = n-2 c 11 rnm1 ( nm2 ) = q * tsd1 ( nm1 ) + hsd1 ( nm1 ) + rnm1 ( nm2 ) rnm1t = rnm1 ( nm2 ) * rd ( nm2 ) sumnm1 = sumnm1 + rnm1t * rnm1 ( nm2 ) rnm1 ( nm2 ) = rnm1t rn ( nm2 ) = hsd2 ( n ) + rn ( nm2 ) sum2 = sum2 + rnm1t * rn ( nm2 ) yspnm1 = yspnm1 - rnm1t * ysp ( nm2 ) rnt = rn ( nm2 ) * rd ( nm2 ) sumn = sumn + rnt * rn ( nm2 ) rn ( nm2 ) = rnt yspn = yspn - rnt * ysp ( nm2 ) c c i = n-1 c 12 rd ( nm1 ) = 1. / ( q * td ( nm1 ) + hd ( nm1 ) - sumnm1 ) ysp ( nm1 ) = yspnm1 rn ( nm1 ) = q * tsd1 ( n ) + hsd1 ( n ) - sum2 rnt = rn ( nm1 ) * rd ( nm1 ) sumn = sumn + rnt * rn ( nm1 ) rn ( nm1 ) = rnt yspn = yspn - rnt * ysp ( nm1 ) c c i = n c rdn = q * td ( n ) + hd ( n ) - sumn rd ( n ) = 0. if ( rdn . gt . 0. ) rd ( n ) = 1. / rdn ysp ( n ) = yspn c c back solve of r(transpose)* r * ysp = ys c ysp ( n ) = rd ( n ) * ysp ( n ) ysp ( nm1 ) = rd ( nm1 ) * ysp ( nm1 ) - rn ( nm1 ) * ysp ( n ) if ( n . eq . 2 ) go to 14 yspn = ysp ( n ) yspnm1 = ysp ( nm1 ) do 13 ibak = 1 , nm2 i = nm1 - ibak 13 ysp ( i ) = rd ( i ) * ysp ( i ) - rsd1 ( i + 1 ) * ysp ( i + 1 ) * - rsd2 ( i + 2 ) * ysp ( i + 2 ) - rnm1 ( i ) * yspnm1 * - rn ( i ) * yspn 14 sum = 0. delyi1 = ( ysp ( 1 ) - ysp ( n )) / ( x ( 1 ) + p - x ( n )) if ( isw . eq . 1 ) go to 16 c c calculation of residual norm c  - d array c do 15 i = 1 , nm1 delyi = ( ysp ( i + 1 ) - ysp ( i )) / ( x ( i + 1 ) - x ( i )) v ( i ) = ( delyi - delyi1 ) * d ( i ) * d ( i ) sum = sum + v ( i ) * ( delyi - delyi1 ) 15 delyi1 = delyi delyi = ( ysp ( 1 ) - ysp ( n )) / ( x ( 1 ) + p - x ( n )) v ( n ) = ( delyi - delyi1 ) * d ( n ) * d ( n ) go to 18 c c calculation of residual norm c  - d constant c 16 do 17 i = 1 , nm1 delyi = ( ysp ( i + 1 ) - ysp ( i )) / ( x ( i + 1 ) - x ( i )) v ( i ) = delyi - delyi1 sum = sum + v ( i ) * ( delyi - delyi1 ) 17 delyi1 = delyi delyi = ( ysp ( 1 ) - ysp ( n )) / ( x ( 1 ) + p - x ( n )) v ( n ) = delyi - delyi1 18 sum = sum + v ( n ) * ( delyi - delyi1 ) c c test for convergence c if ( sum . le . su . and . sum . ge . sl . and . q . gt . 0. ) * go to 21 c c calculation of newton correction c f = 0. g = 0. rnm1sm = 0. rnsm = 0. im1 = n if ( n . eq . 2 ) go to 20 wim2 = 0. wim1 = 0. do 19 i = 1 , nm2 tui = tsd1 ( i ) * ysp ( im1 ) + td ( i ) * ysp ( i ) * + tsd1 ( i + 1 ) * ysp ( i + 1 ) wi = tui - rsd1 ( i ) * wim1 - rsd2 ( i ) * wim2 rnm1sm = rnm1sm - rnm1 ( i ) * wi rnsm = rnsm - rn ( i ) * wi f = f + tui * ysp ( i ) g = g + wi * wi * rd ( i ) im1 = i wim2 = wim1 19 wim1 = wi 20 tui = tsd1 ( nm1 ) * ysp ( im1 ) + td ( nm1 ) * ysp ( nm1 ) * + tsd1 ( n ) * ysp ( n ) wi = tui + rnm1sm f = f + tui * ysp ( nm1 ) g = g + wi * wi * rd ( nm1 ) tui = tsd1 ( n ) * ysp ( nm1 ) + td ( n ) * ysp ( n ) * + tsd1 ( 1 ) * ysp ( 1 ) wi = tui + rnsm - rn ( nm1 ) * wi f = f + tui * ysp ( n ) g = g + wi * wi * rd ( n ) h = f - q * g if ( h . le . 0. . and . q . gt . 0. ) go to 21 c c update q - newton step c step = ( sum - sqrt ( sum * sl )) / h if ( sl . ne . 0. ) step = step * sqrt ( sum / sl ) q = q + step go to 8 c c store smoothed y-values and second derivatives c 21 do 22 i = 1 , n ys ( i ) = y ( i ) - v ( i ) 22 ysp ( i ) = q * ysp ( i ) return c c store constant ys and zero ysp c 23 do 24 i = 1 , n ys ( i ) = con 24 ysp ( i ) = 0. return c c n less than 2 c 25 ierr = 1 return c c s negative c 26 ierr = 2 return c c eps negative or greater than 1 c 27 ierr = 3 return c c x-values not strictly increasing c 28 ierr = 4 return c c weight non-positive c 29 ierr = 5 return c c incorrect period c 30 ierr = 6 return end subroutine curvss ( n , x , y , d , isw , s , eps , ys , ysp , sigma , td , * tsd1 , hd , hsd1 , hsd2 , rd , rsd1 , rsd2 , v , * ierr ) c integer n , isw , ierr real x ( n ), y ( n ), d ( n ), s , eps , ys ( n ), ysp ( n ), sigma , td ( n ), * tsd1 ( n ), hd ( n ), hsd1 ( n ), hsd2 ( n ), rd ( n ), rsd1 ( n ), * rsd2 ( n ), v ( n ) c c                                 coded by alan kaylor cline c                           from fitpack -- january 26, 1987 c                        a curve and surface fitting package c                      a product of pleasant valley software c                  8603 altus cove, austin, texas 78759, usa c c this subroutine determines the parameters necessary to c compute a smoothing spline under tension. for a given c increasing sequence of abscissae (x(i)), i = 1,..., n and c associated ordinates (y(i)), i = 1,..., n, the function c determined minimizes the summation from i = 1 to n-1 of c the square of the second derivative of f plus sigma c squared times the difference of the first derivative of f c and (f(x(i+1))-f(x(i)))/(x(i+1)-x(i)) squared, over all c functions f with two continuous derivatives such that the c summation of the square of (f(x(i))-y(i))/d(i) is less c than or equal to a given constant s, where (d(i)), i = 1, c ..., n are a given set of observation weights. the c function determined is a spline under tension with third c derivative discontinuities at (x(i)), i = 2,..., n-1. for c actual computation of points on the curve it is necessary c to call the function curv2. c c on input-- c c   n is the number of values to be smoothed (n.ge.2). c c   x is an array of the n increasing abscissae of the c   values to be smoothed. c c   y is an array of the n ordinates of the values to be c   smoothed, (i. e. y(k) is the functional value c   corresponding to x(k) ). c c   d is a parameter containing the observation weights. c   this may either be an array of length n or a scalar c   (interpreted as a constant). the value of d c   corresponding to the observation (x(k),y(k)) should c   be an approximation to the standard deviation of error. c c   isw contains a switch indicating whether the parameter c   d is to be considered a vector or a scalar, c          = 0 if d is an array of length n, c          = 1 if d is a scalar. c c   s contains the value controlling the smoothing. this c   must be non-negative. for s equal to zero, the c   subroutine does interpolation, larger values lead to c   smoother funtions. if parameter d contains standard c   deviation estimates, a reasonable value for s is c   float(n). c c   eps contains a tolerance on the relative precision to c   which s is to be interpreted. this must be greater than c   or equal to zero and less than equal or equal to one. a c   reasonable value for eps is sqrt(2./float(n)). c c   ys is an array of length at least n. c c   ysp is an array of length at least n. c c   sigma contains the tension factor. this value indicates c   the degree to which the first derivative part of the c   smoothing functional is emphasized. if sigma is nearly c   zero (e. g. .001) the resulting curve is approximately a c   cubic spline. if sigma is large (e. g. 50.) the c   resulting curve is nearly a polygonal line. if sigma c   equals zero a cubic spline results. a standard value for c   sigma is approximately 1. c c and c c   td, tsd1, hd, hsd1, hsd2, rd, rsd1, rsd2, and v are c   arrays of length at least n which are used for scratch c   storage. c c on output-- c c   ys contains the smoothed ordinate values. c c   ysp contains the values of the second derivative of the c   smoothed curve at the given nodes. c c   ierr contains an error flag, c        = 0 for normal return, c        = 1 if n is less than 2, c        = 2 if s is negative, c        = 3 if eps is negative or greater than one, c        = 4 if x-values are not strictly increasing, c        = 5 if a d-value is non-positive. c c and c c   n, x, y, d, isw, s, eps, and sigma are unaltered. c c this subroutine references package modules terms and c snhcsh. c c----------------------------------------------------------- c if ( n . lt . 2 ) go to 16 if ( s . lt . 0. ) go to 17 if ( eps . lt . 0. . or . eps . gt . 1. ) go to 18 ierr = 0 p = 0. v ( 1 ) = 0. v ( n ) = 0. ysp ( 1 ) = 0. ysp ( n ) = 0. if ( n . eq . 2 ) go to 14 rsd1 ( 1 ) = 0. rd ( 1 ) = 0. rsd2 ( n ) = 0. rdim1 = 0. yspim2 = 0. c c denormalize tension factor c sigmap = abs ( sigma ) * float ( n - 1 ) / ( x ( n ) - x ( 1 )) c c form t matrix and second differences of y into ys c nm1 = n - 1 nm3 = n - 3 delxi1 = 1. delyi1 = 0. dim1 = 0. do 1 i = 1 , nm1 delxi = x ( i + 1 ) - x ( i ) if ( delxi . le . 0. ) go to 19 delyi = ( y ( i + 1 ) - y ( i )) / delxi ys ( i ) = delyi - delyi1 call terms ( di , tsd1 ( i + 1 ), sigmap , delxi ) td ( i ) = di + dim1 hd ( i ) = - ( 1. / delxi + 1. / delxi1 ) hsd1 ( i + 1 ) = 1. / delxi delxi1 = delxi delyi1 = delyi 1 dim1 = di c c calculate lower and upper tolerances c sl = s * ( 1. - eps ) su = s * ( 1. + eps ) if ( isw . eq . 1 ) go to 3 c c form h matrix - d array c if ( d ( 1 ) . le . 0. . or . d ( 2 ) . le . 0. ) go to 20 betapp = 0. betap = 0. alphap = 0. do 2 i = 2 , nm1 alpha = hd ( i ) * d ( i ) * d ( i ) if ( d ( i + 1 ) . le . 0. ) go to 20 beta = hsd1 ( i + 1 ) * d ( i + 1 ) * d ( i + 1 ) hd ( i ) = ( hsd1 ( i ) * d ( i - 1 )) ** 2 + alpha * hd ( i ) * + beta * hsd1 ( i + 1 ) hsd2 ( i ) = hsd1 ( i ) * betapp hsd1 ( i ) = hsd1 ( i ) * ( alpha + alphap ) alphap = alpha betapp = betap 2 betap = beta go to 5 c c form h matrix - d constant c 3 if ( d ( 1 ) . le . 0. ) go to 20 sl = d ( 1 ) * d ( 1 ) * sl su = d ( 1 ) * d ( 1 ) * su hsd1p = 0. hdim1 = 0. do 4 i = 2 , nm1 hdi = hd ( i ) hd ( i ) = hsd1 ( i ) * hsd1 ( i ) + hdi * hdi + hsd1 ( i + 1 ) * hsd1 ( i + 1 ) hsd2 ( i ) = hsd1 ( i ) * hsd1p hsd1p = hsd1 ( i ) hsd1 ( i ) = hsd1p * ( hdi + hdim1 ) 4 hdim1 = hdi c c top of iteration c cholesky factorization of p*t+h into r c 5 do 6 i = 2 , nm1 rsd2i = hsd2 ( i ) rsd1i = p * tsd1 ( i ) + hsd1 ( i ) - rsd2i * rsd1 ( i - 1 ) rsd2 ( i ) = rsd2i * rdim1 rdim1 = rd ( i - 1 ) rsd1 ( i ) = rsd1i * rdim1 rd ( i ) = 1. / ( p * td ( i ) + hd ( i ) - rsd1i * rsd1 ( i ) * - rsd2i * rsd2 ( i )) ysp ( i ) = ys ( i ) - rsd1 ( i ) * ysp ( i - 1 ) - rsd2 ( i ) * yspim2 6 yspim2 = ysp ( i - 1 ) c c back solve of r(transpose)* r * ysp = ys c ysp ( nm1 ) = rd ( nm1 ) * ysp ( nm1 ) if ( n . eq . 3 ) go to 8 do 7 ibak = 1 , nm3 i = nm1 - ibak 7 ysp ( i ) = rd ( i ) * ysp ( i ) - rsd1 ( i + 1 ) * ysp ( i + 1 ) * - rsd2 ( i + 2 ) * ysp ( i + 2 ) 8 sum = 0. delyi1 = 0. if ( isw . eq . 1 ) go to 10 c c calculation of residual norm c  - d array c do 9 i = 1 , nm1 delyi = ( ysp ( i + 1 ) - ysp ( i )) / ( x ( i + 1 ) - x ( i )) v ( i ) = ( delyi - delyi1 ) * d ( i ) * d ( i ) sum = sum + v ( i ) * ( delyi - delyi1 ) 9 delyi1 = delyi v ( n ) = - delyi1 * d ( n ) * d ( n ) go to 12 c c calculation of residual norm c  - d constant c 10 do 11 i = 1 , nm1 delyi = ( ysp ( i + 1 ) - ysp ( i )) / ( x ( i + 1 ) - x ( i )) v ( i ) = delyi - delyi1 sum = sum + v ( i ) * ( delyi - delyi1 ) 11 delyi1 = delyi v ( n ) = - delyi1 12 sum = sum - v ( n ) * delyi1 c c test for convergence c if ( sum . le . su ) go to 14 c c calculation of newton correction c f = 0. g = 0. wim2 = 0. wim1 = 0. do 13 i = 2 , nm1 tui = tsd1 ( i ) * ysp ( i - 1 ) + td ( i ) * ysp ( i ) * + tsd1 ( i + 1 ) * ysp ( i + 1 ) wi = tui - rsd1 ( i ) * wim1 - rsd2 ( i ) * wim2 f = f + tui * ysp ( i ) g = g + wi * wi * rd ( i ) wim2 = wim1 13 wim1 = wi h = f - p * g if ( h . le . 0. ) go to 14 c c update p - newton step c step = ( sum - sqrt ( sum * sl )) / h if ( sl . ne . 0. ) step = step * sqrt ( sum / sl ) p = p + step go to 5 c c store smoothed y-values and second derivatives c 14 do 15 i = 1 , n ys ( i ) = y ( i ) - v ( i ) 15 ysp ( i ) = p * ysp ( i ) return c c n less than 2 c 16 ierr = 1 return c c s negative c 17 ierr = 2 return c c eps negative or greater than 1 c 18 ierr = 3 return c c x-values not strictly increasing c 19 ierr = 4 return c c weight non-positive c 20 ierr = 5 return end function intrvl ( t , x , n ) c integer n real t , x ( n ) c c                                 coded by alan kaylor cline c                           from fitpack -- january 26, 1987 c                        a curve and surface fitting package c                      a product of pleasant valley software c                  8603 altus cove, austin, texas 78759, usa c c this function determines the index of the interval c (determined by a given increasing sequence) in which c a given value lies. c c on input-- c c   t is the given value. c c   x is a vector of strictly increasing values. c c and c c   n is the length of x (n .ge. 2). c c on output-- c c   intrvl returns an integer i such that c c          i =  1       if         e   t .lt. x(2)  , c          i =  n-1     if x(n-1) .le. t            , c          otherwise       x(i)  .le. t .le. x(i+1), c c none of the input parameters are altered. c c----------------------------------------------------------- c save i data i / 1 / c tt = t c c check for illegal i c if ( i . ge . n ) i = n / 2 c c check old interval and extremes c if ( tt . lt . x ( i )) then if ( tt . le . x ( 2 )) then i = 1 intrvl = 1 return else il = 2 ih = i end if else if ( tt . le . x ( i + 1 )) then intrvl = i return else if ( tt . ge . x ( n - 1 )) then i = n - 1 intrvl = n - 1 return else il = i + 1 ih = n - 1 end if c c binary search loop c 1 i = ( il + ih ) / 2 if ( tt . lt . x ( i )) then ih = i else if ( tt . gt . x ( i + 1 )) then il = i + 1 else intrvl = i return end if go to 1 end function intrvp ( t , x , n , p , tp ) c integer n real t , x ( n ), p , tp c c                                 coded by alan kaylor cline c                           from fitpack -- january 26, 1987 c                        a curve and surface fitting package c                      a product of pleasant valley software c                  8603 altus cove, austin, texas 78759, usa c c this function determines the index of the interval c (determined by a given increasing sequence) in which a c given value lies, after translating the value to within c the correct period.  it also returns this translated value. c c on input-- c c   t is the given value. c c   x is a vector of strictly increasing values. c c   n is the length of x (n .ge. 2). c c and c c   p contains the period. c c on output-- c c   tp contains a translated value of t (i. e. x(1) .le. tp, c   tp .lt. x(1)+p, and tp = t + k*p for some integer k). c c   intrvl returns an integer i such that c c          i = 1       if             tp .lt. x(2)  , c          i = n       if   x(n) .le. tp            , c          otherwise       x(i)  .le. tp .lt. x(i+1), c c none of the input parameters are altered. c c----------------------------------------------------------- c save i data i / 1 / c nper = ( t - x ( 1 )) / p tp = t - float ( nper ) * p if ( tp . lt . x ( 1 )) tp = tp + p tt = tp c c check for illegal i c if ( i . ge . n ) i = n / 2 c c check old interval and extremes c if ( tt . lt . x ( i )) then if ( tt . le . x ( 2 )) then i = 1 intrvp = 1 return else il = 2 ih = i end if else if ( tt . le . x ( i + 1 )) then intrvp = i return else if ( tt . ge . x ( n )) then i = n intrvp = n return else il = i + 1 ih = n end if c c binary search loop c 1 i = ( il + ih ) / 2 if ( tt . lt . x ( i )) then ih = i else if ( tt . gt . x ( i + 1 )) then il = i + 1 else intrvp = i return end if go to 1 end !      subroutine snhcsh (sinhm,coshm,x,isw) !c !      integer isw !      real sinhm,coshm,x !c !c                                 coded by alan kaylor cline !c                           from fitpack -- january 26, 1987 !c                        a curve and surface fitting package !c                      a product of pleasant valley software !c                  8603 altus cove, austin, texas 78759, usa !c !c this subroutine returns approximations to !c       sinhm(x) = sinh(x)/x-1 !c       coshm(x) = cosh(x)-1 !c and !c       coshmm(x) = (cosh(x)-1-x*x/2)/(x*x) !c with relative error less than 1.0e-6 !c !c on input-- !c !c   x contains the value of the independent variable. !c !c   isw indicates the function desired !c           = -1 if only sinhm is desired, !c           =  0 if both sinhm and coshm are desired, !c           =  1 if only coshm is desired, !c           =  2 if only coshmm is desired, !c           =  3 if both sinhm and coshmm are desired. !c !c on output-- !c !c   sinhm contains the value of sinhm(x) if isw .le. 0 or !c   isw .eq. 3 (sinhm is unaltered if isw .eq.1 or isw .eq. !c   2). !c !c   coshm contains the value of coshm(x) if isw .eq. 0 or !c   isw .eq. 1 and contains the value of coshmm(x) if isw !c   .ge. 2 (coshm is unaltered if isw .eq. -1). !c !c and !c !c   x and isw are unaltered. !c !c----------------------------------------------------------- !c !      data sp13/.3029390e-5/, !     *     sp12/.1975135e-3/, !     *     sp11/.8334261e-2/, !     *     sp10/.1666665e0/ !      data sp24/.3693467e-7/, !     *     sp23/.2459974e-5/, !     *     sp22/.2018107e-3/, !     *     sp21/.8315072e-2/, !     *     sp20/.1667035e0/ !      data sp33/.6666558e-5/, !     *     sp32/.6646307e-3/, !     *     sp31/.4001477e-1/, !     *     sq32/.2037930e-3/, !     *     sq31/-.6372739e-1/, !     *     sq30/.6017497e1/ !      data sp43/.2311816e-4/, !     *     sp42/.2729702e-3/, !     *     sp41/.9868757e-1/, !     *     sq42/.1776637e-3/, !     *     sq41/-.7549779e-1/, !     *     sq40/.9110034e1/ !      data cp4/.2982628e-6/, !     *     cp3/.2472673e-4/, !     *     cp2/.1388967e-2/, !     *     cp1/.4166665e-1/, !     *     cp0/.5000000e0/ !c !      ax = abs(x) !      if (isw .ge. 0) go to 5 !c !c sinhm approximation !c !      if (ax .gt. 4.45) go to 2 !      xs = ax*ax !      if (ax .gt. 2.3) go to 1 !c !c sinhm approximation on (0.,2.3) !c !      sinhm = xs*(((sp13*xs+sp12)*xs+sp11)*xs+sp10) !      return !c !c sinhm approximation on (2.3,4.45) !c !    1 sinhm = xs*((((sp24*xs+sp23)*xs+sp22)*xs+sp21) !     .               *xs+sp20) !      return !    2 if (ax .gt. 7.65) go to 3 !c !c sinhm approximation on (4.45,7.65) !c !      xs = ax*ax !      sinhm = xs*(((sp33*xs+sp32)*xs+sp31)*xs+1.)/ !     .             ((sq32*xs+sq31)*xs+sq30) !      return !    3 if (ax .gt. 10.1) go to 4 !c !c sinhm approximation on (7.65,10.1) !c !      xs = ax*ax !      sinhm = xs*(((sp43*xs+sp42)*xs+sp41)*xs+1.)/ !     .             ((sq42*xs+sq41)*xs+sq40) !      return !c !c sinhm approximation above 10.1 !c !    4 sinhm = exp(ax)/(ax+ax)-1. !      return !c !c coshm and (possibly) sinhm approximation !c !    5 if (isw .ge. 2) go to 7 !      if (ax .gt. 2.3) go to 6 !      xs = ax*ax !      coshm = xs*((((cp4*xs+cp3)*xs+cp2)*xs+cp1)*xs+cp0) !      if (isw .eq. 0) sinhm = xs*(((sp13*xs+sp12)*xs+sp11) !     .                              *xs+sp10) !      return !    6 expx = exp(ax) !      coshm = (expx+1./expx)/2.-1. !      if (isw .eq. 0) sinhm = (expx-1./expx)/(ax+ax)-1. !      return !c !c coshmm and (possibly) sinhm approximation !c !    7 xs = ax*ax !      if (ax .gt. 2.3) go to 8 !      coshm = xs*(((cp4*xs+cp3)*xs+cp2)*xs+cp1) !      if (isw .eq. 3) sinhm = xs*(((sp13*xs+sp12)*xs+sp11) !     .                              *xs+sp10) !      return !    8 expx = exp(ax) !      coshm = ((expx+1./expx-xs)/2.-1.)/xs !      if (isw .eq. 3) sinhm = (expx-1./expx)/(ax+ax)-1. !      return !      end subroutine snhcsh ( sinhm , coshm , x , isw ) c integer isw real sinhm , coshm , x c c                                 coded by alan kaylor cline c                           from fitpack -- january 26, 1987 c                        a curve and surface fitting package c                      a product of pleasant valley software c                  8603 altus cove, austin, texas 78759, usa c c this subroutine returns approximations to c       sinhm(x) = sinh(x)/x-1 c       coshm(x) = cosh(x)-1 c and c       coshmm(x) = (cosh(x)-1-x*x/2)/(x*x) c with relative error less than 4.0e-14. c c on input-- c c   x contains the value of the independent variable. c c   isw indicates the function desired c           = -1 if only sinhm is desired, c           =  0 if both sinhm and coshm are desired, c           =  1 if only coshm is desired, c           =  2 if only coshmm is desired, c           =  3 if both sinhm and coshmm are desired. c c on output-- c c   sinhm contains the value of sinhm(x) if isw .le. 0 or c   isw .eq. 3 (sinhm is unaltered if isw .eq.1 or isw .eq. c   2). c c   coshm contains the value of coshm(x) if isw .eq. 0 or c   isw .eq. 1 and contains the value of coshmm(x) if isw c   .ge. 2 (coshm is unaltered if isw .eq. -1). c c and c c   x and isw are unaltered. c c----------------------------------------------------------- c data sp14 / . 22758166097634 8e-7 / , * sp13 / . 61218986317169 4e-5 / , * sp12 / . 71531475921120 9e-3 / , * sp11 / . 39808828999297 3e-1 / , * sq12 / . 20638270141372 5e-3 / , * sq11 /- . 61147026000950 8e-1 / , * sq10 / . 59999999999998 6e+1 / data sp25 / . 12909415803727 2e-9 / , * sp24 / . 47373182310166 6e-7 / , * sp23 / . 84921345559845 5e-5 / , * sp22 / . 83326480332724 2e-3 / , * sp21 / . 42502414281322 6e-1 / , * sq22 / . 10600851574482 1e-3 / , * sq21 /- . 44985516951250 5e-1 / , * sq20 / . 60000000026861 9e+1 / data sp35 / . 15519394586494 2e-9 / , * sp34 / . 51152945166873 7e-7 / , * sp33 / . 88477563577678 4e-5 / , * sp32 / . 85044761769139 2e-3 / , * sp31 / . 42888814879177 7e-1 / , * sq32 / . 93312883106161 0e-4 / , * sq31 /- . 42667757053850 7e-1 / , * sq30 / . 60000014508648 9e+1 / data sp45 / . 18807063205833 1e-9 / , * sp44 / . 54579281771419 2e-7 / , * sp43 / . 92011953579522 2e-5 / , * sp42 / . 86655939167298 5e-3 / , * sp41 / . 43253523496085 8e-1 / , * sq42 / . 82489174882067 0e-4 / , * sq41 /- . 40493884167226 2e-1 / , * sq40 / . 60000500628383 4e+1 / data cp5 / . 55220061458474 4e-9 / , * cp4 / . 18166692362094 4e-6 / , * cp3 / . 27054012584652 5e-4 / , * cp2 / . 20627071950393 4e-2 / , * cp1 / . 74443720556904 0e-1 / , * cq2 / . 51460963864268 9e-4 / , * cq1 /- . 17779225552838 2e-1 / , * cq0 / . 20000000000000 0e+1 / data zp4 / . 66441880587683 5e-8 / , * zp3 / . 21827453568638 5e-5 / , * zp2 / . 32485105932716 1e-3 / , * zp1 / . 24451515017425 8e-1 / , * zq2 / . 61616578230662 1e-3 / , * zq1 /- . 21316363957942 5e0 / , * zq0 / . 24000000000000 0e+2 / c ax = abs ( x ) if ( isw . ge . 0 ) go to 5 c c sinhm approximation c if ( ax . gt . 3.9 ) go to 2 xs = ax * ax if ( ax . gt . 2.2 ) go to 1 c c sinhm approximation on (0.,2.2) c sinhm = xs * (((( sp14 * xs + sp13 ) * xs + sp12 ) * xs + sp11 ) * xs + 1. ) / . (( sq12 * xs + sq11 ) * xs + sq10 ) return c c sinhm approximation on (2.2,3.9) c 1 sinhm = xs * ((((( sp25 * xs + sp24 ) * xs + sp23 ) * xs + sp22 ) * xs + sp21 ) . * xs + 1. ) / (( sq22 * xs + sq21 ) * xs + sq20 ) return 2 if ( ax . gt . 5.1 ) go to 3 c c sinhm approximation on (3.9,5.1) c xs = ax * ax sinhm = xs * ((((( sp35 * xs + sp34 ) * xs + sp33 ) * xs + sp32 ) * xs + sp31 ) . * xs + 1. ) / (( sq32 * xs + sq31 ) * xs + sq30 ) return 3 if ( ax . gt . 6.1 ) go to 4 c c sinhm approximation on (5.1,6.1) c xs = ax * ax sinhm = xs * ((((( sp45 * xs + sp44 ) * xs + sp43 ) * xs + sp42 ) * xs + sp41 ) . * xs + 1. ) / (( sq42 * xs + sq41 ) * xs + sq40 ) return c c sinhm approximation above 6.1 c 4 expx = exp ( ax ) sinhm = ( expx - 1. / expx ) / ( ax + ax ) - 1. return c c coshm and (possibly) sinhm approximation c 5 if ( isw . ge . 2 ) go to 7 if ( ax . gt . 2.2 ) go to 6 xs = ax * ax coshm = xs * ((((( cp5 * xs + cp4 ) * xs + cp3 ) * xs + cp2 ) * xs + cp1 ) . * xs + 1. ) / (( cq2 * xs + cq1 ) * xs + cq0 ) if ( isw . eq . 0 ) sinhm = xs * (((( sp14 * xs + sp13 ) * xs + sp12 ) . * xs + sp11 ) * xs + 1. ) / (( sq12 * xs + sq11 ) * xs + sq10 ) return 6 expx = exp ( ax ) coshm = ( expx + 1. / expx ) / 2. - 1. if ( isw . eq . 0 ) sinhm = ( expx - 1. / expx ) / ( ax + ax ) - 1. return c c coshmm and (possibly) sinhm approximation c 7 xs = ax * ax if ( ax . gt . 2.2 ) go to 8 coshm = xs * (((( zp4 * xs + zp3 ) * xs + zp2 ) * xs + zp1 ) * xs + 1. ) / . (( zq2 * xs + zq1 ) * xs + zq0 ) if ( isw . eq . 3 ) sinhm = xs * (((( sp14 * xs + sp13 ) * xs + sp12 ) . * xs + sp11 ) * xs + 1. ) / (( sq12 * xs + sq11 ) * xs + sq10 ) return 8 expx = exp ( ax ) coshm = (( expx + 1. / expx - xs ) / 2. - 1. ) / xs if ( isw . eq . 3 ) sinhm = ( expx - 1. / expx ) / ( ax + ax ) - 1. return end subroutine terms ( diag , sdiag , sigma , del ) c real diag , sdiag , sigma , del c c                                 coded by alan kaylor cline c                           from fitpack -- january 26, 1987 c                        a curve and surface fitting package c                      a product of pleasant valley software c                  8603 altus cove, austin, texas 78759, usa c c this subroutine computes the diagonal and superdiagonal c terms of the tridiagonal linear system associated with c spline under tension interpolation. c c on input-- c c   sigma contains the tension factor. c c and c c   del contains the step size. c c on output-- c c                sigma*del*cosh(sigma*del) - sinh(sigma*del) c   diag = del*--------------------------------------------. c                     (sigma*del)**2 * sinh(sigma*del) c c                   sinh(sigma*del) - sigma*del c   sdiag = del*----------------------------------. c                (sigma*del)**2 * sinh(sigma*del) c c and c c   sigma and del are unaltered. c c this subroutine references package module snhcsh. c c----------------------------------------------------------- c if ( sigma . ne . 0. ) go to 1 diag = del / 3. sdiag = del / 6. return 1 sigdel = sigma * del call snhcsh ( sinhm , coshm , sigdel , 0 ) denom = sigma * sigdel * ( 1. + sinhm ) diag = ( coshm - sinhm ) / denom sdiag = sinhm / denom return end","tags":"","loc":"sourcefile/fitpack.f.html"},{"title":"coll_fokkerplanck.f90 – stella","text":"Source Code module coll_fokkerplanck implicit none public :: read_parameters_fp public :: init_collisions_fp , finish_collisions_fp public :: advance_collisions_fp_explicit , advance_collisions_fp_implicit public :: fieldpart private logical :: vpa_operator , mu_operator logical :: density_conservation , density_conservation_field , density_conservation_tp logical :: exact_conservation_tp , exact_conservation logical :: spitzer_problem , no_j1l1 , no_j1l2 , no_j0l2 logical :: fieldpart , testpart logical :: interspec , intraspec logical :: advfield_coll integer :: nresponse = 1 real :: cfac , cfac2 real :: nuxfac real :: iiknob , ieknob , eeknob , eiknob , eiediffknob , eideflknob , deflknob logical :: eimassr_approx integer :: jmax = 1 integer :: lmax = 1 integer :: nvel_local real , dimension (:, :), allocatable :: aa_vpa , bb_vpa , cc_vpa complex , dimension (:, :, :), allocatable :: fp_response integer , dimension (:, :), allocatable :: diff_idx complex , dimension (:, :, :, :, :), allocatable :: aa_blcs , cc_blcs complex , dimension (:, :, :, :, :), allocatable :: bb_blcs complex , dimension (:, :, :, :, :, :), allocatable :: cdiffmat_band complex , dimension (:, :, :, :), allocatable :: blockmatrix complex , dimension (:, :, :), allocatable :: blockmatrix_sum integer , dimension (:, :, :, :, :), allocatable :: ipiv real , dimension (:, :, :, :, :), allocatable :: nus , nuD , nupa , nux real , dimension (:, :, :, :), allocatable :: mw , modmw real , dimension (:, :, :), allocatable :: velvpamu integer :: info real , dimension (:), allocatable :: wgts_v real , dimension (:), allocatable :: vel real , dimension (:, :, :, :, :, :, :, :), allocatable :: deltaj , deltaj_tp complex , dimension (:, :, :, :), allocatable :: deltajint real , dimension (:, :, :, :, :), allocatable :: psijnorm real , dimension (:, :, :, :, :), allocatable :: legendre_vpamu real , dimension (:, :, :, :, :, :), allocatable :: jm real , dimension (:, :, :, :, :), allocatable :: jm0 real , dimension (:), allocatable :: mwnorm real , dimension (:), allocatable :: modmwnorm logical :: fp_initialized = . false . real :: i1fac , i2fac contains subroutine read_parameters_fp use file_utils , only : input_unit_exist use physics_flags , only : full_flux_surface , radial_variation use mp , only : proc0 , broadcast implicit none namelist / collisions_fp / testpart , fieldpart , lmax , jmax , nvel_local , & interspec , intraspec , iiknob , ieknob , eeknob , eiknob , eiediffknob , eideflknob , deflknob , eimassr_approx , advfield_coll , spitzer_problem , & density_conservation , density_conservation_field , density_conservation_tp , exact_conservation , exact_conservation_tp , & vpa_operator , mu_operator , & cfac , cfac2 , nuxfac , i1fac , i2fac , no_j1l1 , no_j1l2 , no_j0l2 integer :: in_file logical :: dexist if ( proc0 ) then !!! control parameters specific to the Fokker-Planck collision model testpart = . true . ! test particle component (TPO) of fokker-planck operator, must be True fieldpart = . false . ! enable the field particle component (FPO) of the fokker-planck operator intraspec = . true . ! intra-species collisions in the Fokker-Planck operator interspec = . true . ! inter-species iiknob = 1. ! control the ion-ion coll freq in Fokker-Planck operator ieknob = 1. ! ...ion-eon coll freq eeknob = 1. ! ...eon-eon coll freq eiknob = 1. ! ...eon-ion coll freq eiediffknob = 1. ! control the eon-ion energy diffusion in Fokker-Planck operator eideflknob = 1. ! deflknob = 1. ! control pitch angle scattering in Fokker-Planck operator, must be 1 or 0 eimassr_approx = . false . ! use mass ratio approximation for test particle operator, beta advfield_coll = . true . ! disable electrostatic potential terms in the field particle operator, beta density_conservation = . false . ! if True and equally_spaced_mu_grid=True and conservative_wgts_vpa=True, then TPO conserves density to machine precision density_conservation_field = . false . ! if True and jmax, lmax < 2, then FPO conserves density to machine precision density_conservation_tp = . false . ! if True add term to field particle operator to ensure density conservation, also on non-uniform grids exact_conservation = . false . ! if True and fieldpart=True and lmax=jmax=1 then momentum and energy conserved to machine precision - in beta & ! & works only if nux = 0, need to correct the discretisation of nux terms in TPO exact_conservation_tp = . false . ! if True and lmax=jmax=1 then momentum and energy conserved to machine precision, by using the test particle operator & ! to compute field particle terms; this is slower than exact_conservation spitzer_problem = . false . ! to solve the Spitzer problem for tests of the collision operator cfac = 1 ! scale gyrodiffusive term in test particle component of Fokker-Planck operator cfac2 = 1 ! scale gyrodiffusive terms in field particle component of Fokker-Planck operator - in beta nuxfac = 1 ! scale nux (mixed derivative) terms in test particle component of Fokker-Planck operator jmax = 1 ! maximum j in Hirshman-Sigmar expansion of the field particle operator lmax = 1 ! maximum l in spherical harmonic expansion of the field particle operator i1fac = 1 ! for Spitzer problem i2fac = 0 ! for Spitzer problem no_j1l1 = . true . ! disable j1l1 term in the field particle component of Fokker-Planck operator no_j1l2 = . false . ! disable j1l2 term no_j0l2 = . false . ! disable j0l2 term !!! vpa_operator = . true . ! include vpa components in Dougherty or Fokker-Planck operator mu_operator = . true . ! include mu components in Dougherty or Fokker-Planck operator nvel_local = 512 in_file = input_unit_exist ( \"collisions_fp\" , dexist ) if ( dexist ) read ( unit = in_file , nml = collisions_fp ) end if call broadcast ( fieldpart ) call broadcast ( testpart ) call broadcast ( interspec ) call broadcast ( intraspec ) call broadcast ( iiknob ) call broadcast ( ieknob ) call broadcast ( eeknob ) call broadcast ( eiknob ) call broadcast ( eiediffknob ) call broadcast ( deflknob ) call broadcast ( eimassr_approx ) call broadcast ( eideflknob ) call broadcast ( advfield_coll ) call broadcast ( density_conservation ) call broadcast ( density_conservation_field ) call broadcast ( density_conservation_tp ) call broadcast ( exact_conservation ) call broadcast ( exact_conservation_tp ) call broadcast ( spitzer_problem ) call broadcast ( vpa_operator ) call broadcast ( mu_operator ) call broadcast ( cfac ) call broadcast ( cfac2 ) call broadcast ( nuxfac ) call broadcast ( jmax ) call broadcast ( lmax ) call broadcast ( nvel_local ) call broadcast ( i1fac ) call broadcast ( i2fac ) call broadcast ( no_j1l1 ) call broadcast ( no_j1l2 ) call broadcast ( no_j0l2 ) end subroutine read_parameters_fp subroutine init_collisions_fp ( collisions_implicit , cfl_dt_vpadiff , cfl_dt_mudiff ) use species , only : spec , nspec use vpamu_grids , only : dvpa , dmu , mu , nmu use stella_geometry , only : bmag use stella_layouts use run_parameters , only : fully_explicit use common_types , only : spec_type implicit none logical , intent ( in ) :: collisions_implicit real , intent ( out ) :: cfl_dt_vpadiff , cfl_dt_mudiff integer :: is , is2 integer , parameter :: ion_species = 1 integer , parameter :: electron_species = 2 integer , parameter :: impurity_species = 3 ! AVB: clear up difference between slowing down species ('3' in species.f90) and impurity species real :: vnew_max if ( fp_initialized ) return fp_initialized = . true . ! disable inter-species collisions if interspec==false if (. not . interspec ) then do is = 1 , nspec do is2 = 1 , nspec if ( is /= is2 ) then spec ( is )% vnew ( is2 ) = 0. end if end do end do end if ! disable intra-species collisions if intraspec==false if (. not . intraspec ) then do is = 1 , nspec do is2 = 1 , nspec if ( is == is2 ) then spec ( is )% vnew ( is2 ) = 0. end if end do end do end if ! control inter-species collisions do is = 1 , nspec do is2 = 1 , nspec if (( spec ( is )% type == ion_species ) . and . ( spec ( is2 )% type == ion_species )) then spec ( is )% vnew ( is2 ) = spec ( is )% vnew ( is2 ) * iiknob else if (( spec ( is )% type == ion_species ) . and . ( spec ( is2 )% type == electron_species )) then spec ( is )% vnew ( is2 ) = spec ( is )% vnew ( is2 ) * ieknob else if (( spec ( is )% type == electron_species ) . and . ( spec ( is2 )% type == electron_species )) then spec ( is )% vnew ( is2 ) = spec ( is )% vnew ( is2 ) * eeknob else if (( spec ( is )% type == electron_species ) . and . ( spec ( is2 )% type == ion_species )) then spec ( is )% vnew ( is2 ) = spec ( is )% vnew ( is2 ) * eiknob else spec ( is )% vnew ( is2 ) = spec ( is )% vnew ( is2 ) end if ! AVB: to do - add impurity collision control end do end do ! initialise speed dependent collision frequencies call init_nusDpa if ( collisions_implicit ) then write ( * , * ) 'Coll. algorithm: implicit' fully_explicit = . false . call init_legendre call init_vgrid call init_bessel_fn call init_fp_diffmatrix call init_deltaj_vmu call init_fp_conserve else vnew_max = 0.0 do is = 1 , nspec vnew_max = max ( vnew_max , maxval ( spec ( is )% vnew )) end do cfl_dt_vpadiff = 2.0 * dvpa ** 2 / vnew_max cfl_dt_mudiff = minval ( bmag ) / ( vnew_max * maxval ( mu ( 2 :) / dmu (: nmu - 1 ) ** 2 )) end if end subroutine init_collisions_fp subroutine init_nusDpa ! AVB: compute the collision frequencies nuD, nus and nupa use zgrid , only : nzgrid use vpamu_grids , only : nmu , mu , vpa , nvpa , integrate_vmu use stella_geometry , only : bmag use species , only : spec , nspec use spfunc , only : erf => erf_ext use finite_differences , only : fd3pt use vpamu_grids , only : maxwell_mu , maxwell_vpa use constants , only : pi implicit none real , dimension ( - nzgrid : nzgrid ) :: v2mwint , v4mwint integer :: ia , imu , iv , iz , is , isb real :: x , Gf , massr if (. not . allocated ( nus )) allocate ( nus ( nvpa , nmu , - nzgrid : nzgrid , nspec , nspec )) if (. not . allocated ( nuD )) allocate ( nuD ( nvpa , nmu , - nzgrid : nzgrid , nspec , nspec )) if (. not . allocated ( nupa )) allocate ( nupa ( nvpa , nmu , - nzgrid : nzgrid , nspec , nspec )) if (. not . allocated ( nux )) allocate ( nux ( nvpa , nmu , - nzgrid : nzgrid , nspec , nspec )) if (. not . allocated ( mw )) allocate ( mw ( nvpa , nmu , - nzgrid : nzgrid , nspec )) if (. not . allocated ( modmw )) allocate ( modmw ( nvpa , nmu , - nzgrid : nzgrid , nspec )) if (. not . allocated ( velvpamu )) allocate ( velvpamu ( nvpa , nmu , - nzgrid : nzgrid )) ia = 1 do is = 1 , nspec do isb = 1 , nspec massr = spec ( is )% mass / spec ( isb )% mass do iz = - nzgrid , nzgrid do iv = 1 , nvpa do imu = 1 , nmu x = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mu ( imu )) Gf = ( erf ( x / sqrt ( massr )) - x / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - x ** 2 / massr )) / ( 2 * x ** 2 / massr ) nuD ( iv , imu , iz , is , isb ) = deflknob * spec ( is )% vnew ( isb ) * ( erf ( x / sqrt ( massr )) - Gf ) / x ** 3 nus ( iv , imu , iz , is , isb ) = spec ( is )% vnew ( isb ) * 2 * ( 1 + 1. / massr ) * Gf / x ! nus is never used; note - have assumed T_a = T_b here nupa ( iv , imu , iz , is , isb ) = spec ( is )% vnew ( isb ) * 2 * Gf / x ** 3 velvpamu ( iv , imu , iz ) = x mw ( iv , imu , iz , is ) = maxwell_vpa ( iv , is ) * maxwell_mu ( 1 , iz , imu , is ) end do end do end do ! electron-ion collisions ! approximation of Lorentz operator using mass-ratio expansion if (( is == 2 ) . and . ( isb == 1 ) . and . ( eimassr_approx )) then do iz = - nzgrid , nzgrid do iv = 1 , nvpa do imu = 1 , nmu x = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mu ( imu )) nuD ( iv , imu , iz , is , isb ) = deflknob * spec ( is )% vnew ( isb ) * 1. / x ** 3 end do end do end do end if end do end do ! get a function with vanishing energy moment, modmw do is = 1 , nspec do iz = - nzgrid , nzgrid call integrate_vmu ( velvpamu (:, :, iz ) ** 2 * mw (:, :, iz , is ), iz , v2mwint ( iz )) call integrate_vmu ( velvpamu (:, :, iz ) ** 4 * mw (:, :, iz , is ), iz , v4mwint ( iz )) modmw (:, :, iz , is ) = mw (:, :, iz , is ) - velvpamu (:, :, iz ) ** 2 * v2mwint ( iz ) / v4mwint ( iz ) * mw (:, :, iz , is ) end do end do nux = nuxfac * ( nupa - deflknob * nuD ) if ( nspec > 1 ) then ! eiediffknob controls e-i energy diffusion, note that it is also used in blockmatrix nux (:, :, :, 2 , 1 ) = nuxfac * ( eiediffknob * nupa (:, :, :, 2 , 1 ) - eideflknob * deflknob * nuD (:, :, :, 2 , 1 )) nuD (:, :, :, 2 , 1 ) = eideflknob * nuD (:, :, :, 2 , 1 ) end if end subroutine init_nusDpa subroutine finish_nusDpa implicit none if ( allocated ( nus )) deallocate ( nus ) if ( allocated ( nuD )) deallocate ( nuD ) if ( allocated ( nupa )) deallocate ( nupa ) if ( allocated ( nux )) deallocate ( nux ) if ( allocated ( mw )) deallocate ( mw ) if ( allocated ( modmw )) deallocate ( modmw ) if ( allocated ( velvpamu )) deallocate ( velvpamu ) end subroutine finish_nusDpa subroutine init_fp_diffmatrix use stella_time , only : code_dt use species , only : nspec , spec use zgrid , only : nzgrid , ntubes use vpamu_grids , only : dvpa , vpa , nvpa , mu , nmu , maxwell_mu , maxwell_vpa , dmu , equally_spaced_mu_grid use stella_layouts , only : kxkyz_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , is_idx use stella_geometry , only : bmag use dist_fn_arrays , only : kperp2 use physics_parameters , only : zeff use constants , only : pi use common_types , only : spec_type use kt_grids , only : naky , nakx use spfunc , only : erf => erf_ext use file_utils , only : open_output_file , close_output_file implicit none integer :: ikxkyz , iky , ikx , iz , is , isb integer :: imu , ia , iv , ivv , imm , imu2 integer :: nc , nb , lldab , bm_colind , bm_rowind real :: vpap , vpam , vfac , mum , mup real :: xpv , xmv , nupapv , nupamv , nuDpv , nuDmv , mwpv , mwmv , gam_mu , gam_mum , gam_mup real :: mwm , mwp , nuDm , nuDp , nupam , nupap , xm , xp real :: nuDfac , massr , eiediff , eidefl integer , parameter :: ion_species = 1 integer , parameter :: electron_species = 2 if (. not . allocated ( aa_blcs )) allocate ( aa_blcs ( nvpa , nmu , nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc , nspec )) if (. not . allocated ( bb_blcs )) allocate ( bb_blcs ( nvpa , nmu , nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc , nspec )) if (. not . allocated ( cc_blcs )) allocate ( cc_blcs ( nvpa , nmu , nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc , nspec )) if (. not . allocated ( cdiffmat_band )) allocate ( cdiffmat_band ( 3 * ( nmu + 1 ) + 1 , nmu * nvpa , naky , nakx , - nzgrid : nzgrid , nspec )) if (. not . allocated ( ipiv )) allocate ( ipiv ( nvpa * nmu , naky , nakx , - nzgrid : nzgrid , nspec )) ! AVB: calculate the discretisation matrix -\\Delta t C_test&#94;{ab} ! because of mixed vpa-mu derivatives in the test particle operator ! this matrix is block tri-diagonal, with dimension nmu*nvpa x nmu*nvpa ! store and operate with the matrix in band format ! aa_blcs stores subdiagonal blocks, bb_blcs diagonal blocks and cc_blcs superdiagonal blocks ! aa_blcs(1,:,:) and cc_blcs(nvpa,:,:) are never used ! mu-derivatives are contained within blocks, thus blocks have dimension nmu x nmu ia = 1 vfac = 1 ! zero vpa-operator, in beta nuDfac = 1. aa_blcs = 0. bb_blcs = 0. cc_blcs = 0. do imu = 1 , nmu do iv = 1 , nvpa do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) if ( spitzer_problem ) then if (. not . ( spec ( is )% type == electron_species )) cycle ! add eon-eon and eon-ion collisions only for Spitzer problem end if do isb = 1 , nspec ! for Spitzer problem, disable e-i energy diffusion if eiediffknob = 0. if ( spitzer_problem ) then if (( is == 2 ) . and . ( isb == 1 )) then eiediff = eiediffknob eidefl = eideflknob else eiediff = 1. eidefl = 1. end if else if (( is == 2 ) . and . ( isb == 1 )) then eiediff = eiediffknob eidefl = eideflknob else eiediff = 1. eidefl = 1. end if end if massr = spec ( is )% mass / spec ( isb )% mass if ( iv == 1 ) then vpap = 0.5 * ( vpa ( iv ) + vpa ( iv + 1 )) mwpv = exp ( - vpap ** 2 ) * maxwell_mu ( 1 , iz , imu , is ) xpv = sqrt ( vpap ** 2 + 2 * bmag ( ia , iz ) * mu ( imu )) nupapv = vfac * spec ( is )% vnew ( isb ) * 2 * ( erf ( xpv / sqrt ( massr )) & - xpv / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - ( xpv / sqrt ( massr )) ** 2 )) / ( 2 * ( xpv / sqrt ( massr )) ** 2 ) / xpv ** 3 if (( is == 2 ) . and . ( isb == 1 ) . and . ( eimassr_approx )) then nuDpv = vfac * spec ( is )% vnew ( isb ) / xpv ** 3 else nuDpv = vfac * spec ( is )% vnew ( isb ) * ( erf ( xpv / sqrt ( massr )) - ( erf ( xpv / sqrt ( massr )) & - ( xpv / sqrt ( massr )) * ( 2 / sqrt ( pi )) * exp ( - ( xpv / sqrt ( massr )) ** 2 )) / ( 2 * ( xpv / sqrt ( massr )) ** 2 )) / xpv ** 3 end if if ( imu == 1 ) then ! one-sided difference for mu-derivative at imu=1: !cc_blcs(iv,imu,imu+1,iz,is) = cc_blcs(iv,imu,imu+1,iz,is) & !  - vfac*code_dt*vpa(iv+1)*mu(imu)*nux(iv+1,imu,iz,is,isb)*mw(iv+1,imu,iz,is)/mw(iv+1,imu+1,iz,is) / (2*dvpa) / dmu(imu) !cc_blcs(iv,imu,imu,iz,is)   = cc_blcs(iv,imu,imu,iz,is) & !  - code_dt*0.5*(eiediff*nupapv*vpap**2 + 2*nuDpv*bmag(ia,iz)*mu(imu))*mwpv / dvpa**2 / mw(iv+1,imu,iz,is) & !                                +vfac*code_dt*vpa(iv+1)*mu(imu)*nux(iv+1,imu,iz,is,isb)*mw(iv+1,imu,iz,is)/mw(iv+1,imu,iz,is) / (2*dvpa) / dmu(imu) ! using ghost cell at mu=0: cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - 0.5 * vfac * code_dt * vpa ( iv + 1 ) * 0.5 * ( mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ) + mu ( imu + 1 ) * nux ( iv + 1 , imu + 1 , iz , is , isb ) * mw ( iv + 1 , imu + 1 , iz , is ))& / mw ( iv + 1 , imu + 1 , iz , is ) / ( dvpa ) / dmu ( imu ) cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * 0.5 * ( eiediff * nupapv * vpap ** 2 + eidefl * deflknob * 2 * nuDpv * bmag ( ia , iz ) * mu ( imu )) * mwpv / dvpa ** 2 / mw ( iv + 1 , imu , iz , is ) & + 0.5 * vfac * code_dt * vpa ( iv + 1 ) * 0.5 * ( mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ) + mu ( imu + 1 ) * nux ( iv + 1 , imu + 1 , iz , is , isb ) * mw ( iv + 1 , imu + 1 , iz , is ))& / mw ( iv + 1 , imu , iz , is ) / ( dvpa ) / dmu ( imu ) bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - 0.5 * vfac * code_dt * vpa ( iv ) * 0.5 * ( mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) + mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ))& / mw ( iv , imu + 1 , iz , is ) / ( dvpa ) / dmu ( imu ) bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & + 0.5 * vfac * code_dt * vpa ( iv ) * 0.5 * ( mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) + mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ))& / mw ( iv , imu , iz , is ) / ( dvpa ) / dmu ( imu ) ! bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & + code_dt * ( 0.5 * ( eiediff * nupapv * vpap ** 2 + eidefl * deflknob * 2 * nuDpv * bmag ( ia , iz ) * mu ( imu )) * mwpv ) / dvpa ** 2 / mw ( iv , imu , iz , is ) ! mu operator if ( mu_operator ) then ! use ghost cell at mu_{0} = 0 mup = 0.5 * ( mu ( imu ) + mu ( imu + 1 )) mwp = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mup ) xp = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mup ) if (( is == 2 ) . and . ( isb == 1 ) . and . ( eimassr_approx )) then nuDp = eidefl * deflknob * spec ( is )% vnew ( isb ) / xp ** 3 else nuDp = eidefl * deflknob * spec ( is )% vnew ( isb ) * ( erf ( xp / sqrt ( massr )) & - ( erf ( xp / sqrt ( massr )) - xp / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 / massr )) / ( 2 * xp ** 2 / massr )) / xp ** 3 end if nupap = spec ( is )% vnew ( isb ) * 2 * ( erf ( xp / sqrt ( massr )) - xp / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 / massr )) / ( 2 * xp ** 2 / massr ) / xp ** 3 gam_mu = 2 * ( eiediff * nupa ( iv , imu , iz , is , isb ) * mu ( imu ) ** 2 + eidefl * deflknob * nuD ( iv , imu , iz , is , isb ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mu ( imu )) * mw ( iv , imu , iz , is ) gam_mup = 2 * ( eiediff * nupap * mup ** 2 + eidefl * deflknob * nuDp * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mup ) * mwp bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) - code_dt * ( gam_mu *- 1 / dmu ( imu ) * dmu ( imu ) / 2. / mu ( imu ) & + ( gam_mup *- 1 / dmu ( imu ) - gam_mu *- 1 / dmu ( imu )) * mu ( imu ) / ( dmu ( imu ) / 2. )) / mw ( iv , imu , iz , is ) / ( dmu ( imu ) / 2. + mu ( imu )) bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) - code_dt * ( gam_mu * 1 / dmu ( imu ) * dmu ( imu ) / 2. / mu ( imu ) & + ( gam_mup * 1 / dmu ( imu ) - gam_mu * 1 / dmu ( imu )) * mu ( imu ) / ( dmu ( imu ) / 2. )) / mw ( iv , imu + 1 , iz , is ) / ( dmu ( imu ) / 2. + mu ( imu )) ! mixed derivative: if ( density_conservation ) then ! to ensure density conservation, change discretisation of mixed derivative term at imu=1 ! from explicit routine: Dmuh1 = (vpa(iv)*mu(imu)*nux(iv,imu,iz)*mw(iv,imu,iz,is)*Dvpah & !  + vpa(iv)*mu(imu+1)*nux(iv,imu+1,iz)*mw(iv,imu+1,iz,is)*Dvpah_p) / (2.*dmu(imu)) cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & - 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) + vpa ( iv + 1 ) * mu ( imu ) & * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is )) * 1 / mw ( iv + 1 , imu , iz , is )) / ( 2 * dmu ( imu )) / dvpa cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ) + vpa ( iv + 1 ) * mu ( imu + 1 ) & * nux ( iv + 1 , imu + 1 , iz , is , isb ) * mw ( iv + 1 , imu + 1 , iz , is )) * 1 / mw ( iv + 1 , imu + 1 , iz , is )) / ( 2 * dmu ( imu )) / dvpa bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & + 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) + vpa ( iv + 1 ) * mu ( imu ) & * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is )) * 1 / mw ( iv , imu , iz , is )) / ( 2 * dmu ( imu )) / dvpa bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & + 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ) + vpa ( iv + 1 ) * mu ( imu + 1 ) & * nux ( iv + 1 , imu + 1 , iz , is , isb ) * mw ( iv + 1 , imu + 1 , iz , is )) * 1 / mw ( iv , imu + 1 , iz , is )) / ( 2 * dmu ( imu )) / dvpa else cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & - 1.0 * code_dt * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) * 1 / mw ( iv + 1 , imu , iz , is ) * ( dmu ( imu ) / mu ( imu ) - mu ( imu ) / dmu ( imu )))& / ( mu ( imu ) + dmu ( imu )) / dvpa cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - 1.0 * code_dt * ( vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ) * 1 / mw ( iv + 1 , imu + 1 , iz , is ) * mu ( imu ) / dmu ( imu ))& / ( mu ( imu ) + dmu ( imu )) / dvpa bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & + 1.0 * code_dt * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) * 1 / mw ( iv , imu , iz , is ) * ( dmu ( imu ) / mu ( imu ) - mu ( imu ) / dmu ( imu )))& / ( mu ( imu ) + dmu ( imu )) / dvpa bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & + 1.0 * code_dt * ( vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ) * 1 / mw ( iv , imu + 1 , iz , is ) * mu ( imu ) / dmu ( imu ))& / ( mu ( imu ) + dmu ( imu )) / dvpa end if end if else if ( imu == nmu ) then ! AVB: one-sided difference for mu-derivative at imu=nmu: !cc_blcs(iv,imu,imu-1,iz,is) = cc_blcs(iv,imu,imu-1,iz,is) & !  + 1.000*vfac*code_dt*vpa(iv+1)*mu(imu)*nux(iv+1,imu,iz,is,isb)*mw(iv+1,imu,iz,is)/mw(iv+1,imu-1,iz,is) / (2*dvpa) / dmu(nmu-1) !cc_blcs(iv,imu,imu,iz,is)   = cc_blcs(iv,imu,imu,iz,is) & !  - code_dt*0.5*(eiediff*nupapv*vpap**2 + 2*nuDpv*bmag(ia,iz)*mu(imu))*mwpv / dvpa**2 / mw(iv+1,imu,iz,is) & !  - 1.000*vfac*code_dt*vpa(iv+1)*mu(imu)*nux(iv+1,imu,iz,is,isb)*mw(iv+1,imu,iz,is)/mw(iv+1,imu,iz,is) / (2*dvpa) / dmu(nmu-1) ! AVB: second-order: if ( density_conservation ) then cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & + 0.5 * vfac * code_dt * vpa ( iv + 1 ) * 0.5 * ( mu ( imu - 1 ) * nux ( iv + 1 , imu - 1 , iz , is , isb ) * mw ( iv + 1 , imu - 1 , iz , is ) + mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ))& / mw ( iv + 1 , imu - 1 , iz , is ) / ( dvpa ) / dmu ( nmu - 1 ) cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * 0.5 * ( eiediff * nupapv * vpap ** 2 + eidefl * deflknob * 2 * nuDpv * bmag ( ia , iz ) * mu ( imu )) * mwpv / dvpa ** 2 / mw ( iv + 1 , imu , iz , is ) & - 0.5 * vfac * code_dt * vpa ( iv + 1 ) * 0.5 * ( mu ( imu - 1 ) * nux ( iv + 1 , imu - 1 , iz , is , isb ) * mw ( iv + 1 , imu - 1 , iz , is ) + mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ))& / mw ( iv + 1 , imu , iz , is ) / ( dvpa ) / dmu ( nmu - 1 ) bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & + 0.5 * vfac * code_dt * vpa ( iv ) * 0.5 * ( mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ) + mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ))& / mw ( iv , imu - 1 , iz , is ) / ( dvpa ) / dmu ( nmu - 1 ) bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & - 0.5 * vfac * code_dt * vpa ( iv ) * 0.5 * ( mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ) + mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ))& / mw ( iv , imu , iz , is ) / ( dvpa ) / dmu ( nmu - 1 ) else cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & + 1.0 * vfac * code_dt * vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ) / mw ( iv + 1 , imu - 1 , iz , is ) / ( 2 * dvpa ) / dmu ( nmu - 1 ) cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * 0.5 * ( eiediff * nupapv * vpap ** 2 + eidefl * deflknob * 2 * nuDpv * bmag ( ia , iz ) * mu ( imu )) * mwpv / dvpa ** 2 / mw ( iv + 1 , imu , iz , is ) & - 1.0 * vfac * code_dt * vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ) / mw ( iv + 1 , imu , iz , is ) / ( 2 * dvpa ) / dmu ( nmu - 1 ) end if bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & + code_dt * ( 0.5 * ( eiediff * nupapv * vpap ** 2 + eidefl * deflknob * 2 * nuDpv * bmag ( ia , iz ) * mu ( imu )) * mwpv ) / dvpa ** 2 / mw ( iv , imu , iz , is ) ! mu operator if ( mu_operator ) then mum = 0.5 * ( mu ( imu ) + mu ( imu - 1 )) mwm = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mum ) xm = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mum ) if (( is == 2 ) . and . ( isb == 1 ) . and . ( eimassr_approx )) then nuDm = eidefl * deflknob * spec ( is )% vnew ( isb ) / xm ** 3 else nuDm = eidefl * deflknob * spec ( is )% vnew ( isb ) * ( erf ( xm / sqrt ( massr )) & - ( erf ( xm / sqrt ( massr )) - xm / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 / massr )) / ( 2 * xm ** 2 / massr )) / xm ** 3 end if nupam = spec ( is )% vnew ( isb ) * 2 * ( erf ( xm / sqrt ( massr )) - xm / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 / massr )) / ( 2 * xm ** 2 / massr ) / xm ** 3 gam_mu = 2 * ( eiediff * nupa ( iv , imu , iz , is , isb ) * mu ( imu ) ** 2 + eidefl * deflknob * nuD ( iv , imu , iz , is , isb ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mu ( imu )) * mw ( iv , imu , iz , is ) gam_mum = 2 * ( eiediff * nupam * mum ** 2 + eidefl * deflknob * nuDm * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mum ) * mwm if ( density_conservation ) then ! to ensure density conservation we assume that the argument of the outer derivative vanishes at nmu+1/2, ie ! d/dmu[...]_{nmu} = ([...]_{nmu+1/2} - [...]_{nmu-1/2})/(dmu_{nmu-1}/2+dmu(nmu-1)/2) ! where [...]_{nmu+1/2} is a ghost cell at mu = mu_{nmu} + dmu(nmu-1)/2, with [...]_{nmu+1/2} = 0. bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) - code_dt * (( gam_mu / dmu ( imu - 1 ) - gam_mum / dmu ( imu - 1 )) * dmu ( imu - 1 ) / ( dmu ( imu - 1 )) & + ( - gam_mu / dmu ( imu - 1 )) * dmu ( imu - 1 ) / dmu ( imu - 1 )) / mw ( iv , imu , iz , is ) / ( dmu ( imu - 1 ) / 2. + dmu ( imu - 1 ) / 2. ) bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) - code_dt * (( - gam_mu / dmu ( imu - 1 ) - gam_mum * - 1 / dmu ( imu - 1 )) * dmu ( imu - 1 ) / ( dmu ( imu - 1 )) & - gam_mu *- 1 / dmu ( imu - 1 ) * dmu ( imu - 1 ) / dmu ( imu - 1 )) / mw ( iv , imu - 1 , iz , is ) / ( dmu ( imu - 1 ) / 2. + dmu ( imu - 1 ) / 2. ) else bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) - code_dt * (( gam_mu / dmu ( imu - 1 ) - gam_mum / dmu ( imu - 1 )) * dmu ( imu - 1 ) / ( dmu ( imu - 1 ) / 2. ) & + ( - gam_mu / dmu ( imu - 1 )) * dmu ( imu - 1 ) / 2. / dmu ( imu - 1 )) / mw ( iv , imu , iz , is ) / ( dmu ( imu - 1 ) / 2. + dmu ( imu - 1 )) bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) - code_dt * (( - gam_mu / dmu ( imu - 1 ) - gam_mum * - 1 / dmu ( imu - 1 )) * dmu ( imu - 1 ) / ( dmu ( imu - 1 ) / 2. ) & - gam_mu *- 1 / dmu ( imu - 1 ) * dmu ( imu - 1 ) / 2. / dmu ( imu - 1 )) / mw ( iv , imu - 1 , iz , is ) / ( dmu ( imu - 1 ) / 2. + dmu ( imu - 1 )) end if ! mixed derivative: !cc_blcs(iv,imu,imu,iz,is)   = cc_blcs(iv,imu,imu  ,iz,is)  & ! - 1.000*code_dt*(vpa(iv)*mu(imu)*nux(iv,imu,iz,is,isb)*mw(iv,imu,iz,is)*1/mw(iv+1,imu,iz,is)*(dmu(imu-1)/dmu(imu-1)-dmu(imu-1)/dmu(imu-1))) / (dmu(imu-1)+dmu(imu-1)) / (dvpa) !cc_blcs(iv,imu,imu-1,iz,is) = cc_blcs(iv,imu,imu-1,iz,is)  & ! + 1.000*code_dt*(vpa(iv)*mu(imu-1)*nux(iv,imu-1,iz,is,isb)*mw(iv,imu-1,iz,is)*1/mw(iv+1,imu-1,iz,is)* dmu(imu-1)/dmu(imu-1)) / (dmu(imu-1)+dmu(imu-1)) / (dvpa) !bb_blcs(iv,imu,imu,ikxkyz)  = bb_blcs(iv,imu,imu  ,ikxkyz) & !+ 1.000*code_dt*(vpa(iv)*mu(imu)*nux(iv,imu,iz,is,isb)*mw(iv,imu,iz,is)*1/mw(iv,imu,iz,is)*(dmu(imu-1)/dmu(imu-1)-dmu(imu-1)/dmu(imu-1))) / (dmu(imu-1)+dmu(imu-1)) / (dvpa) !bb_blcs(iv,imu,imu-1,ikxkyz)= bb_blcs(iv,imu,imu-1,ikxkyz) & !- 1.000*code_dt*(vpa(iv)*mu(imu-1)*nux(iv,imu-1,iz,is,isb)*mw(iv,imu-1,iz,is)*1/mw(iv,imu-1,iz,is)* dmu(imu-1)/dmu(imu-1)) / (dmu(imu-1)+dmu(imu-1)) / (dvpa) if ( density_conservation ) then cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & + 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) + vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ))& * 1 / mw ( iv + 1 , imu , iz , is )) / ( 2 * dmu ( imu - 1 )) / dvpa cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & + 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ) + vpa ( iv + 1 ) * mu ( imu - 1 ) * nux ( iv + 1 , imu - 1 , iz , is , isb ) * mw ( iv + 1 , imu - 1 , iz , is ))& * 1 / mw ( iv + 1 , imu - 1 , iz , is )) / ( 2 * dmu ( imu - 1 )) / dvpa bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & - 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) + vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ))& * 1 / mw ( iv , imu , iz , is )) / ( 2 * dmu ( imu - 1 )) / dvpa bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ) + vpa ( iv + 1 ) * mu ( imu - 1 ) * nux ( iv + 1 , imu - 1 , iz , is , isb ) * mw ( iv + 1 , imu - 1 , iz , is ))& * 1 / mw ( iv , imu - 1 , iz , is )) / ( 2 * dmu ( imu - 1 )) / dvpa else cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & - 1.0 * code_dt * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) * 1 / mw ( iv + 1 , imu , iz , is ) * ( dmu ( imu - 1 ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu - 1 )))& / ( dmu ( imu - 1 ) + dmu ( imu - 1 )) / ( dvpa ) cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & + 1.0 * code_dt * ( vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ) * 1 / mw ( iv + 1 , imu - 1 , iz , is ) * dmu ( imu - 1 ) / dmu ( imu - 1 ))& / ( dmu ( imu - 1 ) + dmu ( imu - 1 )) / ( dvpa ) bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & + 1.0 * code_dt * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) * 1 / mw ( iv , imu , iz , is ) * ( dmu ( imu - 1 ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu - 1 )))& / ( dmu ( imu - 1 ) + dmu ( imu - 1 )) / ( dvpa ) bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - 1.0 * code_dt * ( vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ) * 1 / mw ( iv , imu - 1 , iz , is ) * dmu ( imu - 1 ) / dmu ( imu - 1 ))& / ( dmu ( imu - 1 ) + dmu ( imu - 1 )) / ( dvpa ) end if end if else ! interior mu points for iv = 1 ! use ghost cell for derivative ! d/dvpa [vpa*mu*nux*F0*dhdmu] = [ ]_nvpa+0.5-[ ]_nvpa-0.5 / dvpa = -[ ]_nvpa-0.5 / dvpa ! = -0.5*([ ]_nvpa-1 + [ ]_nvpa) / dvpa ! could be cleared up, by moving non-nux part of aa_blcs down to non-nux part of bb_bcls cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & + 0.5 * vfac * code_dt * vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ) / mw ( iv + 1 , imu - 1 , iz , is ) * dmu ( imu ) / dmu ( imu - 1 ) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - 0.5 * vfac * code_dt * vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ) / mw ( iv + 1 , imu + 1 , iz , is ) * dmu ( imu - 1 ) / dmu ( imu ) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * 0.5 * ( eiediff * nupapv * vpap ** 2 + eidefl * deflknob * 2 * nuDpv * bmag ( ia , iz ) * mu ( imu )) * mwpv / dvpa ** 2 / mw ( iv + 1 , imu , iz , is ) & - 0.5 * vfac * code_dt * vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & + 0.5 * vfac * code_dt * vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) / mw ( iv , imu - 1 , iz , is ) * dmu ( imu ) / dmu ( imu - 1 ) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - 0.5 * vfac * code_dt * vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) / mw ( iv , imu + 1 , iz , is ) * dmu ( imu - 1 ) / dmu ( imu ) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & - 0.5 * vfac * code_dt * vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & + code_dt * ( 0.5 * ( eiediff * nupapv * vpap ** 2 + eidefl * deflknob * 2 * nuDpv * bmag ( ia , iz ) * mu ( imu )) * mwpv ) / dvpa ** 2 / mw ( iv , imu , iz , is ) ! mu operator if ( mu_operator ) then ! quantities at mu_{i+1/2} and mu_{i-1/2}: mup = 0.5 * ( mu ( imu ) + mu ( imu + 1 )) mum = 0.5 * ( mu ( imu ) + mu ( imu - 1 )) mwp = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mup ) mwm = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mum ) xp = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mup ) xm = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mum ) if (( is == 2 ) . and . ( isb == 1 ) . and . ( eimassr_approx )) then nuDp = eidefl * deflknob * spec ( is )% vnew ( isb ) / xp ** 3 nuDm = eidefl * deflknob * spec ( is )% vnew ( isb ) / xm ** 3 else nuDp = eidefl * deflknob * spec ( is )% vnew ( isb ) * ( erf ( xp / sqrt ( massr )) & - ( erf ( xp / sqrt ( massr )) - xp / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 / massr )) / ( 2 * xp ** 2 / massr )) / xp ** 3 nuDm = eidefl * deflknob * spec ( is )% vnew ( isb ) * ( erf ( xm / sqrt ( massr )) & - ( erf ( xm / sqrt ( massr )) - xm / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 / massr )) / ( 2 * xm ** 2 / massr )) / xm ** 3 end if nupap = spec ( is )% vnew ( isb ) * 2 * ( erf ( xp / sqrt ( massr )) - xp / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 / massr )) / ( 2 * xp ** 2 / massr ) / xp ** 3 nupam = spec ( is )% vnew ( isb ) * 2 * ( erf ( xm / sqrt ( massr )) - xm / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 / massr )) / ( 2 * xm ** 2 / massr ) / xm ** 3 gam_mu = 2 * ( eiediff * nupa ( iv , imu , iz , is , isb ) * mu ( imu ) ** 2 + eidefl * deflknob * nuD ( iv , imu , iz , is , isb ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mu ( imu )) * mw ( iv , imu , iz , is ) gam_mum = 2 * ( eiediff * nupam * mum ** 2 + eidefl * deflknob * nuDm * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mum ) * mwm gam_mup = 2 * ( eiediff * nupap * mup ** 2 + eidefl * deflknob * nuDp * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mup ) * mwp bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * (( gam_mu * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) - gam_mum / dmu ( imu - 1 )) * dmu ( imu ) / dmu ( imu - 1 ) & + ( - gam_mu * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) - gam_mup / dmu ( imu )) * dmu ( imu - 1 ) / dmu ( imu )) & / mw ( iv , imu , iz , is ) * 2. / ( dmu ( imu - 1 ) + dmu ( imu )) bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - code_dt * (( gam_mu *- 1 * dmu ( imu ) / dmu ( imu - 1 ) / ( dmu ( imu - 1 ) + dmu ( imu )) - gam_mum *- 1 / dmu ( imu - 1 )) * dmu ( imu ) / dmu ( imu - 1 ) & - gam_mu *- 1 * dmu ( imu ) / dmu ( imu - 1 ) / ( dmu ( imu - 1 ) + dmu ( imu )) * dmu ( imu - 1 ) / dmu ( imu )) / mw ( iv , imu - 1 , iz , is ) * 2. / ( dmu ( imu - 1 ) + dmu ( imu )) bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - code_dt * ( gam_mu * dmu ( imu - 1 ) / dmu ( imu ) / ( dmu ( imu - 1 ) + dmu ( imu )) * dmu ( imu ) / dmu ( imu - 1 ) & + ( gam_mup / dmu ( imu ) - gam_mu * dmu ( imu - 1 ) / dmu ( imu ) / ( dmu ( imu - 1 ) + dmu ( imu ))) * dmu ( imu - 1 ) / dmu ( imu )) & / mw ( iv , imu + 1 , iz , is ) * 2 / ( dmu ( imu - 1 ) + dmu ( imu )) ! mixed derivative: cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & - 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) + vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ))& * 1 / mw ( iv + 1 , imu , iz , is ) * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu ))) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & + 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ) + vpa ( iv + 1 ) * mu ( imu - 1 ) * nux ( iv + 1 , imu - 1 , iz , is , isb ) * mw ( iv + 1 , imu - 1 , iz , is ))& * 1 / mw ( iv + 1 , imu - 1 , iz , is ) * dmu ( imu ) / dmu ( imu - 1 )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ) + vpa ( iv + 1 ) * mu ( imu + 1 ) * nux ( iv + 1 , imu + 1 , iz , is , isb ) * mw ( iv + 1 , imu + 1 , iz , is ))& * 1 / mw ( iv + 1 , imu + 1 , iz , is ) * dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & + 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) + vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ))& * 1 / mw ( iv , imu , iz , is ) * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu ))) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ) + vpa ( iv + 1 ) * mu ( imu - 1 ) * nux ( iv + 1 , imu - 1 , iz , is , isb ) * mw ( iv + 1 , imu - 1 , iz , is ))& * 1 / mw ( iv , imu - 1 , iz , is ) * dmu ( imu ) / dmu ( imu - 1 )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & + 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ) + vpa ( iv + 1 ) * mu ( imu + 1 ) * nux ( iv + 1 , imu + 1 , iz , is , isb ) * mw ( iv + 1 , imu + 1 , iz , is ))& * 1 / mw ( iv , imu + 1 , iz , is ) * dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) end if end if else if ( iv == nvpa ) then vpam = 0.5 * ( vpa ( iv ) + vpa ( iv - 1 )) mwmv = exp ( - vpam ** 2 ) * maxwell_mu ( 1 , iz , imu , is ) xmv = sqrt ( vpam ** 2 + 2 * bmag ( ia , iz ) * mu ( imu )) nupamv = vfac * spec ( is )% vnew ( isb ) * 2 * ( erf ( xmv / sqrt ( massr )) - xmv / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xmv ** 2 / massr )) / ( 2 * xmv ** 2 / massr ) / xmv ** 3 if (( is == 2 ) . and . ( isb == 1 ) . and . ( eimassr_approx )) then nuDmv = eidefl * deflknob * vfac * spec ( is )% vnew ( isb ) / xmv ** 3 else nuDmv = eidefl * deflknob * vfac * spec ( is )% vnew ( isb ) * ( erf ( xmv / sqrt ( massr )) & - ( erf ( xmv / sqrt ( massr )) - xmv / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xmv ** 2 / massr )) / ( 2 * xmv ** 2 / massr )) / xmv ** 3 end if if ( imu == 1 ) then ! one-sided difference for mu-derivative at imu=1: ! ie d/dvpa [vpa*mu*nux*F0*dhdmu] = [ ]_nvpa+0.5-[ ]_nvpa-0.5 / dvpa = -[ ]_nvpa-0.5 / dvpa ! = -0.5*([ ]_nvpa-1 + [ ]_nvpa) / dvpa ! could be cleared up, by moving non-nux part of aa_blcs down to non-nux part of bb_bcls aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & + 0.5 * vfac * code_dt * vpa ( iv - 1 ) * 0.5 * ( mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) + mu ( imu + 1 ) * nux ( iv - 1 , imu + 1 , iz , is , isb ) * mw ( iv - 1 , imu + 1 , iz , is ))& / mw ( iv - 1 , imu + 1 , iz , is ) / ( dvpa ) / dmu ( imu ) aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) - code_dt * 0.5 * ( eiediff * nupamv * vpam ** 2 & + eidefl * deflknob * 2 * nuDmv * bmag ( ia , iz ) * mu ( imu )) * mwmv / dvpa ** 2 / mw ( iv - 1 , imu , iz , is ) & - 0.5 * vfac * code_dt * vpa ( iv - 1 ) * 0.5 * ( mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) + mu ( imu + 1 ) * nux ( iv - 1 , imu + 1 , iz , is , isb ) * mw ( iv - 1 , imu + 1 , iz , is ))& / mw ( iv - 1 , imu , iz , is ) / ( dvpa ) / dmu ( imu ) bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & + 0.5 * vfac * code_dt * vpa ( iv ) * 0.5 * ( mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) + mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ))& / mw ( iv , imu + 1 , iz , is ) / ( dvpa ) / dmu ( imu ) bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & - 0.5 * vfac * code_dt * vpa ( iv ) * 0.5 * ( mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) + mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ))& / mw ( iv , imu , iz , is ) / ( dvpa ) / dmu ( imu ) bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & + code_dt * ( 0.5 * ( eiediff * nupamv * vpam ** 2 + eidefl * deflknob * 2 * nuDmv * bmag ( ia , iz ) * mu ( imu )) * mwmv ) / dvpa ** 2 / mw ( iv , imu , iz , is ) ! mu operator if ( mu_operator ) then ! use ghost cell at mu_{0} = 0 mup = 0.5 * ( mu ( imu ) + mu ( imu + 1 )) mwp = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mup ) xp = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mup ) if (( is == 2 ) . and . ( isb == 1 ) . and . ( eimassr_approx )) then nuDp = eidefl * deflknob * spec ( is )% vnew ( isb ) / xp ** 3 else nuDp = eidefl * deflknob * spec ( is )% vnew ( isb ) * ( erf ( xp / sqrt ( massr )) & - ( erf ( xp / sqrt ( massr )) - xp / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 / massr )) / ( 2 * xp ** 2 / massr )) / xp ** 3 end if nupap = spec ( is )% vnew ( isb ) * 2 * ( erf ( xp / sqrt ( massr )) - xp / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 / massr )) / ( 2 * xp ** 2 / massr ) / xp ** 3 gam_mu = 2 * ( eiediff * nupa ( iv , imu , iz , is , isb ) * mu ( imu ) ** 2 + eidefl * deflknob * nuD ( iv , imu , iz , is , isb ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mu ( imu )) * mw ( iv , imu , iz , is ) gam_mup = 2 * ( eiediff * nupap * mup ** 2 + eidefl * deflknob * nuDp * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mup ) * mwp bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) - code_dt * ( gam_mu *- 1 / dmu ( imu ) * dmu ( imu ) / 2. / mu ( imu ) & + ( gam_mup *- 1 / dmu ( imu ) - gam_mu *- 1 / dmu ( imu )) * mu ( imu ) / ( dmu ( imu ) / 2. )) / mw ( iv , imu , iz , is ) / ( dmu ( imu ) / 2. + mu ( imu )) bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) - code_dt * ( gam_mu * 1 / dmu ( imu ) * dmu ( imu ) / 2. / mu ( imu ) & + ( gam_mup * 1 / dmu ( imu ) - gam_mu * 1 / dmu ( imu )) * mu ( imu ) / ( dmu ( imu ) / 2. )) / mw ( iv , imu + 1 , iz , is ) / ( dmu ( imu ) / 2. + mu ( imu )) ! mixed derivative: if ( density_conservation ) then ! to ensure density conservation, change discretisation of mixed derivative term at imu=1 ! from explicit routine: Dmuh1 = (vpa(iv)*mu(imu)*nux(iv,imu,iz)*mw(iv,imu,iz,is)*Dvpah + vpa(iv)*mu(imu+1)*nux(iv,imu+1,iz)*mw(iv,imu+1,iz,is)*Dvpah_p) / (2.*dmu(imu)) aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) & + 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) + vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ))& * 1 / mw ( iv - 1 , imu , iz , is )) / ( 2 * dmu ( imu )) / ( dvpa ) aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & + 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv - 1 ) * mu ( imu + 1 ) * nux ( iv - 1 , imu + 1 , iz , is , isb ) * mw ( iv - 1 , imu + 1 , iz , is ) + vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ))& * 1 / mw ( iv - 1 , imu + 1 , iz , is )) / ( 2 * dmu ( imu )) / ( dvpa ) bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & - 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) + vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ))& * 1 / mw ( iv , imu , iz , is )) / ( 2 * dmu ( imu )) / ( dvpa ) bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv - 1 ) * mu ( imu + 1 ) * nux ( iv - 1 , imu + 1 , iz , is , isb ) * mw ( iv - 1 , imu + 1 , iz , is ) + vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ))& * 1 / mw ( iv , imu + 1 , iz , is )) / ( 2 * dmu ( imu )) / ( dvpa ) else aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) & + 1.0 * code_dt * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) * 1 / mw ( iv - 1 , imu , iz , is ) * ( dmu ( imu ) / mu ( imu ) - mu ( imu ) / dmu ( imu )))& / ( mu ( imu ) + dmu ( imu )) / ( dvpa ) aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & + 1.0 * code_dt * ( vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ) * 1 / mw ( iv - 1 , imu + 1 , iz , is ) * mu ( imu ) / dmu ( imu ))& / ( mu ( imu ) + dmu ( imu )) / ( dvpa ) bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & - 1.0 * code_dt * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) * 1 / mw ( iv , imu , iz , is ) * ( dmu ( imu ) / mu ( imu ) - mu ( imu ) / dmu ( imu )))& / ( mu ( imu ) + dmu ( imu )) / ( dvpa ) bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - 1.0 * code_dt * ( vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ) * 1 / mw ( iv , imu + 1 , iz , is ) * mu ( imu ) / dmu ( imu ))& / ( mu ( imu ) + dmu ( imu )) / ( dvpa ) end if end if else if ( imu == nmu ) then ! one-sided difference for mu-derivative at imu=nmu: !aa_blcs(iv,imu,imu-1,iz,is) = aa_blcs(iv,imu,imu-1,iz,is) - 1.000*vfac*code_dt*vpa(iv-1)*mu(imu)*nux(iv-1,imu,iz,is,isb)*mw(iv-1,imu,iz,is)/mw(iv-1,imu-1,iz,is) / (2*dvpa) / dmu(nmu-1) !aa_blcs(iv,imu,imu,iz,is)   = aa_blcs(iv,imu,imu,iz,is) - code_dt*0.5*(eiediff*nupamv*vpam**2 + 2*nuDmv*bmag(ia,iz)*mu(imu))*mwmv / dvpa**2  / mw(iv-1,imu,iz,is) & !  + 1.000*vfac*code_dt*vpa(iv-1)*mu(imu)*nux(iv-1,imu,iz,is,isb)*mw(iv-1,imu,iz,is)/mw(iv-1,imu,iz,is) / (2*dvpa) / dmu(nmu-1) ! 24.02.21, second order: if ( density_conservation ) then !aa_blcs(iv,imu,imu-1,iz,is) = aa_blcs(iv,imu,imu-1,iz,is) & !- 1.000*vfac*code_dt*vpa(iv-1)*0.5*(mu(imu-1)*nux(iv-1,imu-1,iz,is,isb)*mw(iv-1,imu-1,iz,is)+mu(imu)*nux(iv-1,imu,iz,is,isb)*mw(iv-1,imu,iz,is))/mw(iv-1,imu-1,iz,is) / (2*dvpa) / dmu(nmu-1) !aa_blcs(iv,imu,imu,iz,is)   = aa_blcs(iv,imu,imu  ,iz,is) - code_dt*0.5*(eiediff*nupamv*vpam**2 + 2*nuDmv*bmag(ia,iz)*mu(imu))*mwmv / dvpa**2 / mw(iv-1,imu,iz,is) & ! + 1.000*vfac*code_dt*vpa(iv-1)*0.5*(mu(imu-1)*nux(iv-1,imu-1,iz,is,isb)*mw(iv-1,imu-1,iz,is)+mu(imu)*nux(iv-1,imu,iz,is,isb)*mw(iv-1,imu,iz,is))/mw(iv-1,imu  ,iz,is) / (2*dvpa) / dmu(nmu-1) ! take vpa derivative using ghost cell at nvpa+0.5 ! ie d/dvpa [vpa*mu*nux*F0*dhdmu] = [ ]_nvpa+0.5-[ ]_nvpa-0.5 / dvpa = -[ ]_nvpa-0.5 / dvpa ! = -0.5*([ ]_nvpa-1 + [ ]_nvpa) / dvpa ! note this could be cleared up, by moving the non-nux part of aa_blcs down to the non-nux part of bb_bcls aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - 0.5 * vfac * code_dt * vpa ( iv - 1 ) * 0.5 * ( mu ( imu - 1 ) * nux ( iv - 1 , imu - 1 , iz , is , isb ) * mw ( iv - 1 , imu - 1 , iz , is ) + mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ))& / mw ( iv - 1 , imu - 1 , iz , is ) / ( dvpa ) / dmu ( nmu - 1 ) aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * 0.5 * ( eiediff * nupamv * vpam ** 2 + eidefl * deflknob * 2 * nuDmv * bmag ( ia , iz ) * mu ( imu )) * mwmv / dvpa ** 2 / mw ( iv - 1 , imu , iz , is ) & + 0.5 * vfac * code_dt * vpa ( iv - 1 ) * 0.5 * ( mu ( imu - 1 ) * nux ( iv - 1 , imu - 1 , iz , is , isb ) * mw ( iv - 1 , imu - 1 , iz , is ) + mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ))& / mw ( iv - 1 , imu , iz , is ) / ( dvpa ) / dmu ( nmu - 1 ) bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - 0.5 * vfac * code_dt * vpa ( iv ) * 0.5 * ( mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ) + mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ))& / mw ( iv , imu - 1 , iz , is ) / ( dvpa ) / dmu ( nmu - 1 ) bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & + 0.5 * vfac * code_dt * vpa ( iv ) * 0.5 * ( mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ) + mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ))& / mw ( iv , imu , iz , is ) / ( dvpa ) / dmu ( nmu - 1 ) else aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - 1.0 * vfac * code_dt * vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) / mw ( iv - 1 , imu - 1 , iz , is ) / ( 2 * dvpa ) / dmu ( nmu - 1 ) aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * 0.5 * ( eiediff * nupamv * vpam ** 2 + eidefl * deflknob * 2 * nuDmv * bmag ( ia , iz ) * mu ( imu )) * mwmv / dvpa ** 2 / mw ( iv - 1 , imu , iz , is ) & + 1.0 * vfac * code_dt * vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) / mw ( iv - 1 , imu , iz , is ) / ( 2 * dvpa ) / dmu ( nmu - 1 ) end if bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & + code_dt * ( 0.5 * ( eiediff * nupamv * vpam ** 2 + eidefl * deflknob * 2 * nuDmv * bmag ( ia , iz ) * mu ( imu )) * mwmv ) / dvpa ** 2 / mw ( iv , imu , iz , is ) ! mu operator if ( mu_operator ) then mum = 0.5 * ( mu ( imu ) + mu ( imu - 1 )) mwm = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mum ) xm = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mum ) if (( is == 2 ) . and . ( isb == 1 ) . and . ( eimassr_approx )) then nuDm = eidefl * deflknob * spec ( is )% vnew ( isb ) / xm ** 3 else nuDm = eidefl * deflknob * spec ( is )% vnew ( isb ) * ( erf ( xm / sqrt ( massr )) & - ( erf ( xm / sqrt ( massr )) - xm / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 / massr )) / ( 2 * xm ** 2 / massr )) / xm ** 3 end if nupam = spec ( is )% vnew ( isb ) * 2 * ( erf ( xm / sqrt ( massr )) - xm / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 / massr )) / ( 2 * xm ** 2 / massr ) / xm ** 3 gam_mu = 2 * ( eiediff * nupa ( iv , imu , iz , is , isb ) * mu ( imu ) ** 2 + eidefl * deflknob * nuD ( iv , imu , iz , is , isb ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mu ( imu )) * mw ( iv , imu , iz , is ) gam_mum = 2 * ( eiediff * nupam * mum ** 2 + eidefl * deflknob * nuDm * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mum ) * mwm if ( density_conservation ) then ! to ensure density conservation we assume that the argument of the outer derivative vanishes at nmu+1/2, ie ! d/dmu[...]_{nmu} = ([...]_{nmu+1/2} - [...]_{nmu-1/2})/(dmu_{nmu-1}/2+dmu(nmu-1)/2), where [...]_{nmu+1/2} is a ghost cell at mu = mu_{nmu} + dmu(nmu-1)/2, with [...]_{nmu+1/2} = 0. bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) - code_dt * (( gam_mu / dmu ( imu - 1 ) - gam_mum / dmu ( imu - 1 )) * dmu ( imu - 1 ) / ( dmu ( imu - 1 )) & + ( - gam_mu / dmu ( imu - 1 )) * dmu ( imu - 1 ) / dmu ( imu - 1 )) / mw ( iv , imu , iz , is ) / ( dmu ( imu - 1 ) / 2. + dmu ( imu - 1 ) / 2. ) bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) - code_dt * (( - gam_mu / dmu ( imu - 1 ) - gam_mum * - 1 / dmu ( imu - 1 )) * dmu ( imu - 1 ) / ( dmu ( imu - 1 )) & - gam_mu *- 1 / dmu ( imu - 1 ) * dmu ( imu - 1 ) / dmu ( imu - 1 )) / mw ( iv , imu - 1 , iz , is ) / ( dmu ( imu - 1 ) / 2. + dmu ( imu - 1 ) / 2. ) else bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) - code_dt * (( gam_mu / dmu ( imu - 1 ) - gam_mum / dmu ( imu - 1 )) * dmu ( imu - 1 ) / ( dmu ( imu - 1 ) / 2. ) & + ( - gam_mu / dmu ( imu - 1 )) * dmu ( imu - 1 ) / 2. / dmu ( imu - 1 )) / mw ( iv , imu , iz , is ) / ( dmu ( imu - 1 ) / 2. + dmu ( imu - 1 )) bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) - code_dt * (( - gam_mu / dmu ( imu - 1 ) - gam_mum * - 1 / dmu ( imu - 1 )) * dmu ( imu - 1 ) / ( dmu ( imu - 1 ) / 2. ) & - gam_mu *- 1 / dmu ( imu - 1 ) * dmu ( imu - 1 ) / 2. / dmu ( imu - 1 )) / mw ( iv , imu - 1 , iz , is ) / ( dmu ( imu - 1 ) / 2. + dmu ( imu - 1 )) end if ! mixed derivative: ! 24.02.21, commenting out !aa_blcs(iv,imu,imu,iz,is)    = aa_blcs(iv,imu,imu  ,iz,is) & !  + 1.000*code_dt*(vpa(iv)*mu(imu)*nux(iv,imu,iz,is,isb)*mw(iv,imu,iz,is)*1/mw(iv-1,imu,iz,is)*(dmu(imu-1)/dmu(imu-1)-dmu(imu-1)/dmu(imu-1))) / (dmu(imu-1)+dmu(imu-1)) / (dvpa) !aa_blcs(iv,imu,imu-1,iz,is)  = aa_blcs(iv,imu,imu-1,iz,is) & !  - 1.000*code_dt*(vpa(iv)*mu(imu-1)*nux(iv,imu-1,iz,is,isb)*mw(iv,imu-1,iz,is)*1/mw(iv-1,imu-1,iz,is)* dmu(imu-1)/dmu(imu-1)) / (dmu(imu-1)+dmu(imu-1)) / (dvpa) !bb_blcs(iv,imu,imu,ikxkyz)   = bb_blcs(iv,imu,imu  ,ikxkyz) & !  - 1.000*code_dt*(vpa(iv)*mu(imu)*nux(iv,imu,iz,is,isb)*mw(iv,imu,iz,is)*1/mw(iv,imu,iz,is)*(dmu(imu-1)/dmu(imu-1)-dmu(imu-1)/dmu(imu-1))) / (dmu(imu-1)+dmu(imu-1)) / (dvpa) !bb_blcs(iv,imu,imu-1,ikxkyz) = bb_blcs(iv,imu,imu-1,ikxkyz) & !  + 1.000*code_dt*(vpa(iv)*mu(imu-1)*nux(iv,imu-1,iz,is,isb)*mw(iv,imu-1,iz,is)*1/mw(iv,imu-1,iz,is)* dmu(imu-1)/dmu(imu-1)) / (dmu(imu-1)+dmu(imu-1)) / (dvpa) if ( density_conservation ) then ! 04.03. removed an extra bracket at end of lines in following block aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv - 1 ) * mu ( imu - 1 ) * nux ( iv - 1 , imu - 1 , iz , is , isb ) * mw ( iv - 1 , imu - 1 , iz , is ) + vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ))& * 1 / mw ( iv - 1 , imu - 1 , iz , is )) / ( 2 * dmu ( imu - 1 )) / dvpa aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) & - 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) + vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ))& * 1 / mw ( iv - 1 , imu , iz , is )) / ( 2 * dmu ( imu - 1 )) / dvpa bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & + 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv - 1 ) * mu ( imu - 1 ) * nux ( iv - 1 , imu - 1 , iz , is , isb ) * mw ( iv - 1 , imu - 1 , iz , is ) + vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ))& * 1 / mw ( iv , imu - 1 , iz , is )) / ( 2 * dmu ( imu - 1 )) / dvpa bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & + 0.5 * 1.0 * code_dt * ( 0.5 * ( vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) + vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ))& * 1 / mw ( iv , imu , iz , is )) / ( 2 * dmu ( imu - 1 )) / dvpa else aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) & + 1.0 * code_dt * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) * 1 / mw ( iv - 1 , imu , iz , is ) * ( dmu ( imu - 1 ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu - 1 )))& / ( dmu ( imu - 1 ) + dmu ( imu - 1 )) / ( dvpa ) aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - 1.0 * code_dt * ( vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ) * 1 / mw ( iv - 1 , imu - 1 , iz , is ) * dmu ( imu - 1 ) / dmu ( imu - 1 ))& / ( dmu ( imu - 1 ) + dmu ( imu - 1 )) / ( dvpa ) bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & - 1.0 * code_dt * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) * 1 / mw ( iv , imu , iz , is ) * ( dmu ( imu - 1 ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu - 1 )))& / ( dmu ( imu - 1 ) + dmu ( imu - 1 )) / ( dvpa ) bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & + 1.0 * code_dt * ( vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ) * 1 / mw ( iv , imu - 1 , iz , is ) * dmu ( imu - 1 ) / dmu ( imu - 1 ))& / ( dmu ( imu - 1 ) + dmu ( imu - 1 )) / ( dvpa ) end if end if else ! interior mu points for iv=nvpa ! take vpa derivative using ghost cell at nvpa+0.5 ! ie d/dvpa [vpa*mu*nux*F0*dhdmu] = [ ]_nvpa+0.5-[ ]_nvpa-0.5 / dvpa = -[ ]_nvpa-0.5 / dvpa ! = -0.5*([ ]_nvpa-1 + [ ]_nvpa) / dvpa ! note this could be cleared up, by moving the non-nux part of aa_blcs down to the non-nux part of bb_bcls aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - 0.5 * vfac * code_dt * vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) / mw ( iv - 1 , imu - 1 , iz , is ) * dmu ( imu ) / dmu ( imu - 1 ) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & + 0.5 * vfac * code_dt * vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) / mw ( iv - 1 , imu + 1 , iz , is ) * dmu ( imu - 1 ) / dmu ( imu ) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * 0.5 * ( eiediff * nupamv * vpam ** 2 + eidefl * deflknob * 2 * nuDmv * bmag ( ia , iz ) * mu ( imu )) * mwmv / dvpa ** 2 / mw ( iv - 1 , imu , iz , is ) & + 0.5 * vfac * code_dt * vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - 0.5 * vfac * code_dt * vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) / mw ( iv , imu - 1 , iz , is ) * dmu ( imu ) / dmu ( imu - 1 ) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & + 0.5 * vfac * code_dt * vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) / mw ( iv , imu + 1 , iz , is ) * dmu ( imu - 1 ) / dmu ( imu ) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & + 0.5 * vfac * code_dt * vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & + code_dt * ( 0.5 * ( eiediff * nupamv * vpam ** 2 + eidefl * deflknob * 2 * nuDmv * bmag ( ia , iz ) * mu ( imu )) * mwmv ) / dvpa ** 2 / mw ( iv , imu , iz , is ) ! mu operator if ( mu_operator ) then ! quantities at mu_{i+1/2} and mu_{i-1/2}: mup = 0.5 * ( mu ( imu ) + mu ( imu + 1 )) mum = 0.5 * ( mu ( imu ) + mu ( imu - 1 )) mwp = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mup ) mwm = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mum ) xp = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mup ) xm = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mum ) if (( is == 2 ) . and . ( isb == 1 ) . and . ( eimassr_approx )) then nuDp = eidefl * deflknob * spec ( is )% vnew ( isb ) / xp ** 3 nuDm = eidefl * deflknob * spec ( is )% vnew ( isb ) / xm ** 3 else nuDp = eidefl * deflknob * spec ( is )% vnew ( isb ) * ( erf ( xp / sqrt ( massr )) - ( erf ( xp / sqrt ( massr )) - xp / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 / massr )) / ( 2 * xp ** 2 / massr )) / xp ** 3 nuDm = eidefl * deflknob * spec ( is )% vnew ( isb ) * ( erf ( xm / sqrt ( massr )) - ( erf ( xm / sqrt ( massr )) - xm / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 / massr )) / ( 2 * xm ** 2 / massr )) / xm ** 3 end if nupap = spec ( is )% vnew ( isb ) * 2 * ( erf ( xp / sqrt ( massr )) - xp / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 / massr )) / ( 2 * xp ** 2 / massr ) / xp ** 3 nupam = spec ( is )% vnew ( isb ) * 2 * ( erf ( xm / sqrt ( massr )) - xm / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 / massr )) / ( 2 * xm ** 2 / massr ) / xm ** 3 gam_mu = 2 * ( eiediff * nupa ( iv , imu , iz , is , isb ) * mu ( imu ) ** 2 + eidefl * deflknob * nuD ( iv , imu , iz , is , isb ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mu ( imu )) * mw ( iv , imu , iz , is ) gam_mum = 2 * ( eiediff * nupam * mum ** 2 + eidefl * deflknob * nuDm * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mum ) * mwm gam_mup = 2 * ( eiediff * nupap * mup ** 2 + eidefl * deflknob * nuDp * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mup ) * mwp bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * (( gam_mu * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) - gam_mum / dmu ( imu - 1 )) * dmu ( imu ) / dmu ( imu - 1 ) & + ( - gam_mu * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) - gam_mup / dmu ( imu )) * dmu ( imu - 1 ) / dmu ( imu )) & / mw ( iv , imu , iz , is ) * 2. / ( dmu ( imu - 1 ) + dmu ( imu )) bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - code_dt * (( gam_mu *- 1 * dmu ( imu ) / dmu ( imu - 1 ) / ( dmu ( imu - 1 ) + dmu ( imu )) - gam_mum *- 1 / dmu ( imu - 1 )) * dmu ( imu ) / dmu ( imu - 1 ) & - gam_mu *- 1 * dmu ( imu ) / dmu ( imu - 1 ) / ( dmu ( imu - 1 ) + dmu ( imu )) * dmu ( imu - 1 ) / dmu ( imu )) / mw ( iv , imu - 1 , iz , is ) * 2. / ( dmu ( imu - 1 ) + dmu ( imu )) bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - code_dt * ( gam_mu * dmu ( imu - 1 ) / dmu ( imu ) / ( dmu ( imu - 1 ) + dmu ( imu )) * dmu ( imu ) / dmu ( imu - 1 ) & + ( gam_mup / dmu ( imu ) - gam_mu * dmu ( imu - 1 ) / dmu ( imu ) / ( dmu ( imu - 1 ) + dmu ( imu ))) * dmu ( imu - 1 ) / dmu ( imu )) & / mw ( iv , imu + 1 , iz , is ) * 2 / ( dmu ( imu - 1 ) + dmu ( imu )) ! mixed derivative, one-sided difference in vpa at iv = nvpa: ! use second order accurate treatment for vpa derivative at nvpa aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) & + 0.5 * code_dt * ( 0.5 * ( vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) + vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ))& * 1 / mw ( iv - 1 , imu , iz , is ) * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu ))) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - 0.5 * code_dt * ( 0.5 * ( vpa ( iv - 1 ) * mu ( imu - 1 ) * nux ( iv - 1 , imu - 1 , iz , is , isb ) * mw ( iv - 1 , imu - 1 , iz , is ) + vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ))& * 1 / mw ( iv - 1 , imu - 1 , iz , is ) * dmu ( imu ) / dmu ( imu - 1 )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & + 0.5 * code_dt * ( 0.5 * ( vpa ( iv - 1 ) * mu ( imu + 1 ) * nux ( iv - 1 , imu + 1 , iz , is , isb ) * mw ( iv - 1 , imu + 1 , iz , is ) + vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ))& * 1 / mw ( iv - 1 , imu + 1 , iz , is ) * dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & - 0.5 * code_dt * ( 0.5 * ( vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) + vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ))& * 1 / mw ( iv , imu , iz , is ) * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu ))) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & + 0.5 * code_dt * ( 0.5 * ( vpa ( iv - 1 ) * mu ( imu - 1 ) * nux ( iv - 1 , imu - 1 , iz , is , isb ) * mw ( iv - 1 , imu - 1 , iz , is ) + vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ))& * 1 / mw ( iv , imu - 1 , iz , is ) * dmu ( imu ) / dmu ( imu - 1 )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - 0.5 * code_dt * ( 0.5 * ( vpa ( iv - 1 ) * mu ( imu + 1 ) * nux ( iv - 1 , imu + 1 , iz , is , isb ) * mw ( iv - 1 , imu + 1 , iz , is ) + vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ))& * 1 / mw ( iv , imu + 1 , iz , is ) * dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( dvpa ) end if end if else ! interior vpa points vpam = 0.5 * ( vpa ( iv ) + vpa ( iv - 1 )) vpap = 0.5 * ( vpa ( iv ) + vpa ( iv + 1 )) mwmv = exp ( - vpam ** 2 ) * maxwell_mu ( 1 , iz , imu , is ) mwpv = exp ( - vpap ** 2 ) * maxwell_mu ( 1 , iz , imu , is ) xpv = sqrt ( vpap ** 2 + 2 * bmag ( ia , iz ) * mu ( imu )) xmv = sqrt ( vpam ** 2 + 2 * bmag ( ia , iz ) * mu ( imu )) nupamv = vfac * spec ( is )% vnew ( isb ) * 2 * ( erf ( xmv / sqrt ( massr )) - xmv / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xmv ** 2 / massr )) / ( 2 * xmv ** 2 / massr ) / xmv ** 3 nupapv = vfac * spec ( is )% vnew ( isb ) * 2 * ( erf ( xpv / sqrt ( massr )) - xpv / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xpv ** 2 / massr )) / ( 2 * xpv ** 2 / massr ) / xpv ** 3 if (( is == 2 ) . and . ( isb == 1 ) . and . ( eimassr_approx )) then nuDmv = eidefl * deflknob * vfac * spec ( is )% vnew ( isb ) / xmv ** 3 nuDpv = eidefl * deflknob * vfac * spec ( is )% vnew ( isb ) / xpv ** 3 else nuDmv = eidefl * deflknob * vfac * spec ( is )% vnew ( isb ) * ( erf ( xmv / sqrt ( massr )) & - ( erf ( xmv / sqrt ( massr )) - xmv / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xmv ** 2 / massr )) / ( 2 * xmv ** 2 / massr )) / xmv ** 3 nuDpv = eidefl * deflknob * vfac * spec ( is )% vnew ( isb ) * ( erf ( xpv / sqrt ( massr )) & - ( erf ( xpv / sqrt ( massr )) - xpv / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xpv ** 2 / massr )) / ( 2 * xpv ** 2 / massr )) / xpv ** 3 end if if ( imu == 1 ) then ! one-sided difference for mu-derivative at imu=1: if (. not . density_conservation ) then aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & + vfac * code_dt * vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) / mw ( iv - 1 , imu + 1 , iz , is ) / ( 2 * dvpa ) / dmu ( imu ) aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * 0.5 * ( eiediff * nupamv * vpam ** 2 + eidefl * deflknob * 2 * nuDmv * bmag ( ia , iz ) * mu ( imu )) * mwmv / dvpa ** 2 / mw ( iv - 1 , imu , iz , is ) & - vfac * code_dt * vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) / ( 2 * dvpa ) / dmu ( imu ) cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - vfac * code_dt * vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ) / mw ( iv + 1 , imu + 1 , iz , is ) / ( 2 * dvpa ) / dmu ( imu ) cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * 0.5 * ( eiediff * nupapv * vpap ** 2 + eidefl * deflknob * 2 * nuDpv * bmag ( ia , iz ) * mu ( imu )) * mwpv / dvpa ** 2 / mw ( iv + 1 , imu , iz , is ) & + vfac * code_dt * vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) / ( 2 * dvpa ) / dmu ( imu ) else if ( density_conservation ) then ! to ensure density conservation, assume that nux*F0 vanishes at iv=1 and iv=nvpa aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & + 0.5 * vfac * code_dt * vpa ( iv - 1 ) * ( mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) + mu ( imu + 1 ) * nux ( iv - 1 , imu + 1 , iz , is , isb ) * mw ( iv - 1 , imu + 1 , iz , is ))& / mw ( iv - 1 , imu + 1 , iz , is ) / ( 2 * dvpa ) / dmu ( imu ) aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * 0.5 * ( eiediff * nupamv * vpam ** 2 + eidefl * deflknob * 2 * nuDmv * bmag ( ia , iz ) * mu ( imu )) * mwmv / dvpa ** 2 / mw ( iv - 1 , imu , iz , is ) & - 0.5 * vfac * code_dt * vpa ( iv - 1 ) * ( mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) + mu ( imu + 1 ) * nux ( iv - 1 , imu + 1 , iz , is , isb ) * mw ( iv - 1 , imu + 1 , iz , is ))& / mw ( iv - 1 , imu , iz , is ) / ( 2 * dvpa ) / dmu ( imu ) cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - 0.5 * vfac * code_dt * vpa ( iv + 1 ) * ( mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ) + mu ( imu + 1 ) * nux ( iv + 1 , imu + 1 , iz , is , isb ) * mw ( iv + 1 , imu + 1 , iz , is ))& / mw ( iv + 1 , imu + 1 , iz , is ) / ( 2 * dvpa ) / dmu ( imu ) cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * 0.5 * ( eiediff * nupapv * vpap ** 2 + eidefl * deflknob * 2 * nuDpv * bmag ( ia , iz ) * mu ( imu )) * mwpv / dvpa ** 2 / mw ( iv + 1 , imu , iz , is ) & + 0.5 * vfac * code_dt * vpa ( iv + 1 ) * ( mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ) + mu ( imu + 1 ) * nux ( iv + 1 , imu + 1 , iz , is , isb ) * mw ( iv + 1 , imu + 1 , iz , is ))& / mw ( iv + 1 , imu , iz , is ) / ( 2 * dvpa ) / dmu ( imu ) end if bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & + code_dt * ( 0.5 * ( eiediff * nupapv * vpap ** 2 + eidefl * deflknob * 2 * nuDpv * bmag ( ia , iz ) * mu ( imu )) * mwpv & + 0.5 * ( eiediff * nupamv * vpam ** 2 + eidefl * deflknob * 2 * nuDmv * bmag ( ia , iz ) * mu ( imu )) * mwmv ) / dvpa ** 2 / mw ( iv , imu , iz , is ) ! mu operator if ( mu_operator ) then ! use ghost cell at mu_{0} = 0, where term vanishes, so dmu(0) = mu(1). mup = 0.5 * ( mu ( imu ) + mu ( imu + 1 )) mwp = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mup ) xp = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mup ) if (( is == 2 ) . and . ( isb == 1 ) . and . ( eimassr_approx )) then nuDp = eidefl * deflknob * spec ( is )% vnew ( isb ) / xp ** 3 else nuDp = eidefl * deflknob * spec ( is )% vnew ( isb ) * ( erf ( xp / sqrt ( massr )) & - ( erf ( xp / sqrt ( massr )) - xp / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 / massr )) / ( 2 * xp ** 2 / massr )) / xp ** 3 end if nupap = spec ( is )% vnew ( isb ) * 2 * ( erf ( xp / sqrt ( massr )) - xp / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 / massr )) / ( 2 * xp ** 2 / massr ) / xp ** 3 gam_mu = 2 * ( eiediff * nupa ( iv , imu , iz , is , isb ) * mu ( imu ) ** 2 + eidefl * deflknob * nuD ( iv , imu , iz , is , isb ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mu ( imu )) * mw ( iv , imu , iz , is ) gam_mup = 2 * ( eiediff * nupap * mup ** 2 + eidefl * deflknob * nuDp * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mup ) * mwp bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) - code_dt * ( gam_mu *- 1 / dmu ( imu ) * dmu ( imu ) / 2. / mu ( imu ) & + ( gam_mup *- 1 / dmu ( imu ) - gam_mu *- 1 / dmu ( imu )) * mu ( imu ) / ( dmu ( imu ) / 2. )) / mw ( iv , imu , iz , is ) / ( dmu ( imu ) / 2. + mu ( imu )) bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) - code_dt * ( gam_mu * 1 / dmu ( imu ) * dmu ( imu ) / 2. / mu ( imu ) & + ( gam_mup * 1 / dmu ( imu ) - gam_mu * 1 / dmu ( imu )) * mu ( imu ) / ( dmu ( imu ) / 2. )) / mw ( iv , imu + 1 , iz , is ) / ( dmu ( imu ) / 2. + mu ( imu )) ! mixed derivative: if ( density_conservation ) then ! to ensure density conservation, we change discretisation of mixed derivative term at imu=1 ! from explicit routine: Dmuh1 = (vpa(iv)*mu(imu)*nux(iv,imu,iz)*mw(iv,imu,iz,is)*Dvpah & !     + vpa(iv)*mu(imu+1)*nux(iv,imu+1,iz)*mw(iv,imu+1,iz,is)*Dvpah_p) / (2.*dmu(imu)) aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) & + code_dt * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) * 1 / mw ( iv - 1 , imu , iz , is )) / ( 2 * dmu ( imu )) / ( 2 * dvpa ) aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & + code_dt * ( vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ) * 1 / mw ( iv - 1 , imu + 1 , iz , is )) / ( 2 * dmu ( imu )) / ( 2 * dvpa ) cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) * 1 / mw ( iv + 1 , imu , iz , is )) / ( 2 * dmu ( imu )) / ( 2 * dvpa ) cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - code_dt * ( vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ) * 1 / mw ( iv + 1 , imu + 1 , iz , is )) / ( 2 * dmu ( imu )) / ( 2 * dvpa ) else aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) & + code_dt * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) * 1 / mw ( iv - 1 , imu , iz , is ) * ( dmu ( imu ) / mu ( imu ) - mu ( imu ) / dmu ( imu )))& / ( mu ( imu ) + dmu ( imu )) / ( 2 * dvpa ) aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & + code_dt * ( vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ) * 1 / mw ( iv - 1 , imu + 1 , iz , is ) * mu ( imu ) / dmu ( imu )) & / ( mu ( imu ) + dmu ( imu )) / ( 2 * dvpa ) cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) * 1 / mw ( iv + 1 , imu , iz , is ) * ( dmu ( imu ) / mu ( imu ) - mu ( imu ) / dmu ( imu ))) & / ( mu ( imu ) + dmu ( imu )) / ( 2 * dvpa ) cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - code_dt * ( vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ) * 1 / mw ( iv + 1 , imu + 1 , iz , is ) * mu ( imu ) / dmu ( imu )) & / ( mu ( imu ) + dmu ( imu )) / ( 2 * dvpa ) end if end if else if ( imu == nmu ) then ! one-sided difference for mu-derivative at imu=nmu: ! to be consistent with treatment of mixed mu operator; assume that nux(imu)=0. if ( density_conservation ) then aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - 1.0 * vfac * code_dt * vpa ( iv - 1 ) * 0.5 * ( mu ( imu - 1 ) * nux ( iv - 1 , imu - 1 , iz , is , isb ) * mw ( iv - 1 , imu - 1 , iz , is ) + mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ))& / mw ( iv - 1 , imu - 1 , iz , is ) / ( 2 * dvpa ) / dmu ( nmu - 1 ) aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * 0.5 * ( eiediff * nupamv * vpam ** 2 + eidefl * deflknob * 2 * nuDmv * bmag ( ia , iz ) * mu ( imu )) * mwmv / dvpa ** 2 / mw ( iv - 1 , imu , iz , is ) & + 1.0 * vfac * code_dt * vpa ( iv - 1 ) * 0.5 * ( mu ( imu - 1 ) * nux ( iv - 1 , imu - 1 , iz , is , isb ) * mw ( iv - 1 , imu - 1 , iz , is ) + mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ))& / mw ( iv - 1 , imu , iz , is ) / ( 2 * dvpa ) / dmu ( nmu - 1 ) cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & + 1.0 * vfac * code_dt * vpa ( iv + 1 ) * 0.5 * ( mu ( imu - 1 ) * nux ( iv + 1 , imu - 1 , iz , is , isb ) * mw ( iv + 1 , imu - 1 , iz , is ) + mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ))& / mw ( iv + 1 , imu - 1 , iz , is ) / ( 2 * dvpa ) / dmu ( nmu - 1 ) cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * 0.5 * ( eiediff * nupapv * vpap ** 2 + eidefl * deflknob * 2 * nuDpv * bmag ( ia , iz ) * mu ( imu )) * mwpv / dvpa ** 2 / mw ( iv + 1 , imu , iz , is ) & - 1.0 * vfac * code_dt * vpa ( iv + 1 ) * 0.5 * ( mu ( imu - 1 ) * nux ( iv + 1 , imu - 1 , iz , is , isb ) * mw ( iv + 1 , imu - 1 , iz , is ) + mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ))& / mw ( iv + 1 , imu , iz , is ) / ( 2 * dvpa ) / dmu ( nmu - 1 ) else aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - 1.0 * vfac * code_dt * vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) / mw ( iv - 1 , imu - 1 , iz , is ) / ( 2 * dvpa ) / dmu ( nmu - 1 ) aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * 0.5 * ( eiediff * nupamv * vpam ** 2 + eidefl * deflknob * 2 * nuDmv * bmag ( ia , iz ) * mu ( imu )) * mwmv / dvpa ** 2 / mw ( iv - 1 , imu , iz , is ) & + 1.0 * vfac * code_dt * vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) / ( 2 * dvpa ) / dmu ( nmu - 1 ) cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & + 1.0 * vfac * code_dt * vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ) / mw ( iv + 1 , imu - 1 , iz , is ) / ( 2 * dvpa ) / dmu ( nmu - 1 ) cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * 0.5 * ( eiediff * nupapv * vpap ** 2 + eidefl * deflknob * 2 * nuDpv * bmag ( ia , iz ) * mu ( imu )) * mwpv / dvpa ** 2 / mw ( iv + 1 , imu , iz , is ) & - 1.0 * vfac * code_dt * vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) / ( 2 * dvpa ) / dmu ( nmu - 1 ) end if bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & + code_dt * ( 0.5 * ( eiediff * nupapv * vpap ** 2 + eidefl * deflknob * 2 * nuDpv * bmag ( ia , iz ) * mu ( imu )) * mwpv & + 0.5 * ( eiediff * nupamv * vpam ** 2 + eidefl * deflknob * 2 * nuDmv * bmag ( ia , iz ) * mu ( imu )) * mwmv ) / dvpa ** 2 / mw ( iv , imu , iz , is ) ! mu operator if ( mu_operator ) then mum = 0.5 * ( mu ( imu ) + mu ( imu - 1 )) mwm = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mum ) xm = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mum ) if (( is == 2 ) . and . ( isb == 1 ) . and . ( eimassr_approx )) then nuDm = eidefl * deflknob * spec ( is )% vnew ( isb ) / xm ** 3 else nuDm = eidefl * deflknob * spec ( is )% vnew ( isb ) * ( erf ( xm / sqrt ( massr )) & - ( erf ( xm / sqrt ( massr )) - xm / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 / massr )) / ( 2 * xm ** 2 / massr )) / xm ** 3 end if nupam = spec ( is )% vnew ( isb ) * 2 * ( erf ( xm / sqrt ( massr )) - xm / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 / massr )) / ( 2 * xm ** 2 / massr ) / xm ** 3 gam_mu = 2 * ( eiediff * nupa ( iv , imu , iz , is , isb ) * mu ( imu ) ** 2 + eidefl * deflknob * nuD ( iv , imu , iz , is , isb ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mu ( imu )) * mw ( iv , imu , iz , is ) gam_mum = 2 * ( eiediff * nupam * mum ** 2 + eidefl * deflknob * nuDm * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mum ) * mwm if ( density_conservation ) then ! to ensure density conservation assume that argument of outer derivative vanishes at nmu+1/2, ie ! d/dmu[...]_{nmu} = ([...]_{nmu+1/2} - [...]_{nmu-1/2})/(dmu_{nmu-1}/2+dmu(nmu-1)/2) ! where [...]_{nmu+1/2} is a ghost cell at mu = mu_{nmu} + dmu(nmu-1)/2, with [...]_{nmu+1/2} = 0. bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * (( gam_mu / dmu ( imu - 1 ) - gam_mum / dmu ( imu - 1 )) * dmu ( imu - 1 ) / ( dmu ( imu - 1 )) & + ( - gam_mu / dmu ( imu - 1 )) * dmu ( imu - 1 ) / dmu ( imu - 1 )) / mw ( iv , imu , iz , is ) / ( dmu ( imu - 1 ) / 2. + dmu ( imu - 1 ) / 2. ) bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - code_dt * (( - gam_mu / dmu ( imu - 1 ) - gam_mum *- 1 / dmu ( imu - 1 )) * dmu ( imu - 1 ) / ( dmu ( imu - 1 )) & - gam_mu *- 1 / dmu ( imu - 1 ) * dmu ( imu - 1 ) / dmu ( imu - 1 )) / mw ( iv , imu - 1 , iz , is ) / ( dmu ( imu - 1 ) / 2. + dmu ( imu - 1 ) / 2. ) else bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * (( gam_mu / dmu ( imu - 1 ) - gam_mum / dmu ( imu - 1 )) * dmu ( imu - 1 ) / ( dmu ( imu - 1 ) / 2. ) & + ( - gam_mu / dmu ( imu - 1 )) * dmu ( imu - 1 ) / 2. / dmu ( imu - 1 )) / mw ( iv , imu , iz , is ) / ( dmu ( imu - 1 ) / 2. + dmu ( imu - 1 )) bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - code_dt * (( - gam_mu / dmu ( imu - 1 ) - gam_mum *- 1 / dmu ( imu - 1 )) * dmu ( imu - 1 ) / ( dmu ( imu - 1 ) / 2. ) & - gam_mu *- 1 / dmu ( imu - 1 ) * dmu ( imu - 1 ) / 2. / dmu ( imu - 1 )) / mw ( iv , imu - 1 , iz , is ) / ( dmu ( imu - 1 ) / 2. + dmu ( imu - 1 )) end if ! no distinction here between density_conserving and default if ( density_conservation ) then aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - code_dt * ( vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ) * 1 / mw ( iv - 1 , imu - 1 , iz , is )) / ( 2 * dmu ( imu - 1 )) / ( 2 * dvpa ) aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) * 1 / mw ( iv - 1 , imu , iz , is )) / ( 2 * dmu ( imu - 1 )) / ( 2 * dvpa ) cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & + code_dt * ( vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ) * 1 / mw ( iv + 1 , imu - 1 , iz , is )) / ( 2 * dmu ( imu - 1 )) / ( 2 * dvpa ) cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & + code_dt * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) * 1 / mw ( iv + 1 , imu , iz , is )) / ( 2 * dmu ( imu - 1 )) / ( 2 * dvpa ) else aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) & + code_dt * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) * 1 / mw ( iv - 1 , imu , iz , is ) * ( dmu ( imu - 1 ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu - 1 ))) & / ( dmu ( imu - 1 ) + dmu ( imu - 1 )) / ( 2 * dvpa ) aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - code_dt * ( vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ) * 1 / mw ( iv - 1 , imu - 1 , iz , is ) * dmu ( imu - 1 ) / dmu ( imu - 1 )) & / ( dmu ( imu - 1 ) + dmu ( imu - 1 )) / ( 2 * dvpa ) cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) * 1 / mw ( iv + 1 , imu , iz , is ) * ( dmu ( imu - 1 ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu - 1 ))) & / ( dmu ( imu - 1 ) + dmu ( imu - 1 )) / ( 2 * dvpa ) cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & + code_dt * ( vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ) * 1 / mw ( iv + 1 , imu - 1 , iz , is ) * dmu ( imu - 1 ) / dmu ( imu - 1 )) & / ( dmu ( imu - 1 ) + dmu ( imu - 1 )) / ( 2 * dvpa ) end if end if else ! interior mu points if ( density_conservation ) then aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * 0.5 * ( eiediff * nupamv * vpam ** 2 + eidefl * deflknob * 2 * nuDmv * bmag ( ia , iz ) * mu ( imu )) * mwmv / dvpa ** 2 / mw ( iv - 1 , imu , iz , is ) & + vfac * code_dt * vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( 2 * dvpa ) cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * 0.5 * ( eiediff * nupapv * vpap ** 2 + eidefl * deflknob * 2 * nuDpv * bmag ( ia , iz ) * mu ( imu )) * mwpv / dvpa ** 2 / mw ( iv + 1 , imu , iz , is ) & - vfac * code_dt * vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( 2 * dvpa ) ! vpa operator, mixed (interior treatment): aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - vfac * code_dt * vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) / mw ( iv - 1 , imu - 1 , iz , is ) * dmu ( imu ) / dmu ( imu - 1 ) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( 2 * dvpa ) aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & + vfac * code_dt * vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) / mw ( iv - 1 , imu + 1 , iz , is ) * dmu ( imu - 1 ) / dmu ( imu ) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( 2 * dvpa ) cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & + vfac * code_dt * vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ) / mw ( iv + 1 , imu - 1 , iz , is ) * dmu ( imu ) / dmu ( imu - 1 ) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( 2 * dvpa ) cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - vfac * code_dt * vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ) / mw ( iv + 1 , imu + 1 , iz , is ) * dmu ( imu - 1 ) / dmu ( imu ) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( 2 * dvpa ) else aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * 0.5 * ( eiediff * nupamv * vpam ** 2 + eidefl * deflknob * 2 * nuDmv * bmag ( ia , iz ) * mu ( imu )) * mwmv / dvpa ** 2 / mw ( iv - 1 , imu , iz , is ) & + vfac * code_dt * vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( 2 * dvpa ) cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * 0.5 * ( eiediff * nupapv * vpap ** 2 + eidefl * deflknob * 2 * nuDpv * bmag ( ia , iz ) * mu ( imu )) * mwpv / dvpa ** 2 / mw ( iv + 1 , imu , iz , is ) & - vfac * code_dt * vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( 2 * dvpa ) ! vpa operator, mixed (interior treatment): aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - vfac * code_dt * vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) / mw ( iv - 1 , imu - 1 , iz , is ) * dmu ( imu ) / dmu ( imu - 1 ) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( 2 * dvpa ) aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & + vfac * code_dt * vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , isb ) * mw ( iv - 1 , imu , iz , is ) / mw ( iv - 1 , imu + 1 , iz , is ) * dmu ( imu - 1 ) / dmu ( imu ) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( 2 * dvpa ) cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & + vfac * code_dt * vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ) / mw ( iv + 1 , imu - 1 , iz , is ) * dmu ( imu ) / dmu ( imu - 1 ) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( 2 * dvpa ) cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - vfac * code_dt * vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , isb ) * mw ( iv + 1 , imu , iz , is ) / mw ( iv + 1 , imu + 1 , iz , is ) * dmu ( imu - 1 ) / dmu ( imu ) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( 2 * dvpa ) end if bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & + code_dt * ( 0.5 * ( eiediff * nupapv * vpap ** 2 + 2 * eidefl * deflknob * nuDpv * bmag ( ia , iz ) * mu ( imu )) * mwpv & + 0.5 * ( eiediff * nupamv * vpam ** 2 + 2 * eidefl * deflknob * nuDmv * bmag ( ia , iz ) * mu ( imu )) * mwmv ) / dvpa ** 2 / mw ( iv , imu , iz , is ) ! mu operator if ( mu_operator ) then ! quantities at mu_{i+1/2} and mu_{i-1/2}: mup = 0.5 * ( mu ( imu ) + mu ( imu + 1 )) mum = 0.5 * ( mu ( imu ) + mu ( imu - 1 )) mwp = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mup ) mwm = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mum ) xp = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mup ) xm = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mum ) if (( is == 2 ) . and . ( isb == 1 ) . and . ( eimassr_approx )) then nuDp = eidefl * deflknob * spec ( is )% vnew ( isb ) / xp ** 3 nuDm = eidefl * deflknob * spec ( is )% vnew ( isb ) / xm ** 3 else nuDp = eidefl * deflknob * spec ( is )% vnew ( isb ) * ( erf ( xp / sqrt ( massr )) & - ( erf ( xp / sqrt ( massr )) - xp / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 / massr )) / ( 2 * xp ** 2 / massr )) / xp ** 3 nuDm = eidefl * deflknob * spec ( is )% vnew ( isb ) * ( erf ( xm / sqrt ( massr )) & - ( erf ( xm / sqrt ( massr )) - xm / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 / massr )) / ( 2 * xm ** 2 / massr )) / xm ** 3 end if nupap = spec ( is )% vnew ( isb ) * 2 * ( erf ( xp / sqrt ( massr )) - xp / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 / massr )) / ( 2 * xp ** 2 / massr ) / xp ** 3 nupam = spec ( is )% vnew ( isb ) * 2 * ( erf ( xm / sqrt ( massr )) - xm / sqrt ( massr ) * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 / massr )) / ( 2 * xm ** 2 / massr ) / xm ** 3 gam_mu = 2 * ( eiediff * nupa ( iv , imu , iz , is , isb ) * mu ( imu ) ** 2 + eidefl * deflknob * nuD ( iv , imu , iz , is , isb ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mu ( imu )) * mw ( iv , imu , iz , is ) gam_mum = 2 * ( eiediff * nupam * mum ** 2 + eidefl * deflknob * nuDm * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mum ) * mwm gam_mup = 2 * ( eiediff * nupap * mup ** 2 + eidefl * deflknob * nuDp * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mup ) * mwp ! mu_operator (interior treatment): bb_blcs ( iv , imu , imu , ikxkyz , isb ) = bb_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * (( gam_mu * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) - gam_mum / dmu ( imu - 1 )) * dmu ( imu ) / dmu ( imu - 1 ) & + ( - gam_mu * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) - gam_mup / dmu ( imu )) * dmu ( imu - 1 ) / dmu ( imu )) / mw ( iv , imu , iz , is ) * 2. / ( dmu ( imu - 1 ) + dmu ( imu )) bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - code_dt * (( gam_mu *- 1 * dmu ( imu ) / dmu ( imu - 1 ) / ( dmu ( imu - 1 ) + dmu ( imu )) - gam_mum *- 1 / dmu ( imu - 1 )) * dmu ( imu ) / dmu ( imu - 1 ) & - gam_mu *- 1 * dmu ( imu ) / dmu ( imu - 1 ) / ( dmu ( imu - 1 ) + dmu ( imu )) * dmu ( imu - 1 ) / dmu ( imu )) / mw ( iv , imu - 1 , iz , is ) * 2. / ( dmu ( imu - 1 ) + dmu ( imu )) bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = bb_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - code_dt * ( gam_mu * dmu ( imu - 1 ) / dmu ( imu ) / ( dmu ( imu - 1 ) + dmu ( imu )) * dmu ( imu ) / dmu ( imu - 1 ) & + ( gam_mup / dmu ( imu ) - gam_mu * dmu ( imu - 1 ) / dmu ( imu ) / ( dmu ( imu - 1 ) + dmu ( imu ))) * dmu ( imu - 1 ) / dmu ( imu )) / mw ( iv , imu + 1 , iz , is ) * 2 / ( dmu ( imu - 1 ) + dmu ( imu )) ! mu operator, mixed (interior treatment): aa_blcs ( iv , imu , imu , ikxkyz , isb ) = aa_blcs ( iv , imu , imu , ikxkyz , isb ) & + code_dt * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) * 1 / mw ( iv - 1 , imu , iz , is ) & * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu ))) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( 2 * dvpa ) aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & - code_dt * ( vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ) * 1 / mw ( iv - 1 , imu - 1 , iz , is ) & * dmu ( imu ) / dmu ( imu - 1 )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( 2 * dvpa ) aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = aa_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & + code_dt * ( vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ) * 1 / mw ( iv - 1 , imu + 1 , iz , is ) & * dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( 2 * dvpa ) cc_blcs ( iv , imu , imu , ikxkyz , isb ) = cc_blcs ( iv , imu , imu , ikxkyz , isb ) & - code_dt * ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , isb ) * mw ( iv , imu , iz , is ) * 1 / mw ( iv + 1 , imu , iz , is ) & * ( dmu ( imu ) / dmu ( imu - 1 ) - dmu ( imu - 1 ) / dmu ( imu ))) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( 2 * dvpa ) cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu - 1 , ikxkyz , isb ) & + code_dt * ( vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , isb ) * mw ( iv , imu - 1 , iz , is ) * 1 / mw ( iv + 1 , imu - 1 , iz , is ) & * dmu ( imu ) / dmu ( imu - 1 )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( 2 * dvpa ) cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) = cc_blcs ( iv , imu , imu + 1 , ikxkyz , isb ) & - code_dt * ( vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , isb ) * mw ( iv , imu + 1 , iz , is ) * 1 / mw ( iv + 1 , imu + 1 , iz , is ) & * dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) / ( 2 * dvpa ) end if end if end if end do end do end do end do if ( testpart . eqv . . false .) then aa_blcs = 0. cc_blcs = 0. bb_blcs = 0. do isb = 1 , nspec do imu = 1 , nmu do iv = 1 , nvpa do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc bb_blcs ( iv , imu , imu , ikxkyz , isb ) = 1. ! AVB: in beta end do end do end do end do end if ! construct full block matrix if (( exact_conservation_tp ) . or . ( density_conservation_tp )) then ! this is memory intensive, operating with blockmatrix is slow ! currently used for exact conservation scheme on non-uniform grids ! AVB: to do - replace this with band matrix operations if (. not . allocated ( blockmatrix )) allocate ( blockmatrix ( nvpa * nmu , nvpa * nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc , nspec )) if (. not . allocated ( blockmatrix_sum )) allocate ( blockmatrix_sum ( nvpa * nmu , nvpa * nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) blockmatrix = 0. do isb = 1 , nspec do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) do iv = 1 , nvpa ! diagonal blocks: blockmatrix ( nmu * ( iv - 1 ) + 1 : nmu * iv , nmu * ( iv - 1 ) + 1 : nmu * iv , ikxkyz , isb ) = bb_blcs ( iv , :, :, ikxkyz , isb ) if ( iv < nvpa ) then ! subdiagonal blocks: blockmatrix ( nmu * iv + 1 : nmu * ( iv + 1 ), nmu * ( iv - 1 ) + 1 : nmu * iv , ikxkyz , isb ) = aa_blcs ( iv + 1 , :, :, ikxkyz , isb ) ! superdiagonal blocks: blockmatrix ( nmu * ( iv - 1 ) + 1 : nmu * iv , nmu * iv + 1 : nmu * ( iv + 1 ), ikxkyz , isb ) = cc_blcs ( iv , :, :, ikxkyz , isb ) end if end do end do end do end if ! switch to band-storage for LAPACK banded solver routines: ! and sum the interspecies and intraspecies operators for each species ! a_ij is stored in aband(ku+1+i-j,j) for $\\max(1,j-ku) \\leq i \\leq \\min(m,j+kl)$ cdiffmat_band = 0. do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) ! loop through aa_blcs, bb_blcs, cc_blcs ! find corresponding index of blockmatrix at each location within blcs ! calculate index of cdiffmat_band do iv = 1 , nvpa ! bb_blcs do imu = 1 , nmu bm_rowind = ( iv - 1 ) * nmu + imu do imu2 = 1 , nmu bm_colind = ( iv - 1 ) * nmu + imu2 if (( max ( 1 , bm_colind - ( nmu + 1 )) <= bm_rowind ) . and . ( bm_rowind <= min ( nvpa * nmu , bm_colind + ( nmu + 1 )))) then cdiffmat_band ( nmu + 1 + nmu + 1 + 1 + bm_rowind - bm_colind , bm_colind , iky , ikx , iz , is ) = bb_blcs ( iv , imu , imu2 , ikxkyz , is ) end if end do end do ! cc_blcs if ( iv < nvpa ) then ! aa_blcs and cc_blcs contain only (nvpa-1) blocks, since they are off-diagonal do imu = 1 , nmu bm_rowind = ( iv - 1 ) * nmu + imu do imu2 = 1 , nmu bm_colind = nmu + ( iv - 1 ) * nmu + imu2 ! nvpa*nmu - nmu + imu2 if (( max ( 1 , bm_colind - ( nmu + 1 )) <= bm_rowind ) . and . ( bm_rowind <= min ( nvpa * nmu , bm_colind + ( nmu + 1 )))) then cdiffmat_band ( nmu + 1 + nmu + 1 + 1 + bm_rowind - bm_colind , bm_colind , iky , ikx , iz , is ) = cc_blcs ( iv , imu , imu2 , ikxkyz , is ) end if end do end do ! aa_blcs do imu = 1 , nmu bm_rowind = nmu + ( iv - 1 ) * nmu + imu do imu2 = 1 , nmu bm_colind = ( iv - 1 ) * nmu + imu2 if (( max ( 1 , bm_colind - ( nmu + 1 )) <= bm_rowind ) . and . ( bm_rowind <= min ( nvpa * nmu , bm_colind + ( nmu + 1 )))) then cdiffmat_band ( nmu + 1 + nmu + 1 + 1 + bm_rowind - bm_colind , bm_colind , iky , ikx , iz , is ) = aa_blcs ( 1 + iv , imu , imu2 , ikxkyz , is ) end if end do end do end if ! inter-species test particle contributions: do isb = 1 , nspec if ( isb == is ) cycle ! bb_blcs do imu = 1 , nmu bm_rowind = ( iv - 1 ) * nmu + imu do imu2 = 1 , nmu bm_colind = ( iv - 1 ) * nmu + imu2 if (( max ( 1 , bm_colind - ( nmu + 1 )) <= bm_rowind ) . and . ( bm_rowind <= min ( nvpa * nmu , bm_colind + ( nmu + 1 )))) then cdiffmat_band ( nmu + 1 + nmu + 1 + 1 + bm_rowind - bm_colind , bm_colind , iky , ikx , iz , is ) = & cdiffmat_band ( nmu + 1 + nmu + 1 + 1 + bm_rowind - bm_colind , bm_colind , iky , ikx , iz , is ) + bb_blcs ( iv , imu , imu2 , ikxkyz , isb ) end if end do end do ! cc_blcs if ( iv < nvpa ) then do imu = 1 , nmu bm_rowind = ( iv - 1 ) * nmu + imu do imu2 = 1 , nmu bm_colind = ( iv - 1 ) * nmu + nmu + imu2 if (( max ( 1 , bm_colind - ( nmu + 1 )) <= bm_rowind ) . and . ( bm_rowind <= min ( nvpa * nmu , bm_colind + ( nmu + 1 )))) then cdiffmat_band ( nmu + 1 + nmu + 1 + 1 + bm_rowind - bm_colind , bm_colind , iky , ikx , iz , is ) = & cdiffmat_band ( nmu + 1 + nmu + 1 + 1 + bm_rowind - bm_colind , bm_colind , iky , ikx , iz , is ) + cc_blcs ( iv , imu , imu2 , ikxkyz , isb ) end if end do end do ! aa_blcs do imu = 1 , nmu bm_rowind = ( iv - 1 ) * nmu + nmu + imu do imu2 = 1 , nmu bm_colind = ( iv - 1 ) * nmu + imu2 if (( max ( 1 , bm_colind - ( nmu + 1 )) <= bm_rowind ) . and . ( bm_rowind <= min ( nvpa * nmu , bm_colind + ( nmu + 1 )))) then cdiffmat_band ( nmu + 1 + nmu + 1 + 1 + bm_rowind - bm_colind , bm_colind , iky , ikx , iz , is ) = & cdiffmat_band ( nmu + 1 + nmu + 1 + 1 + bm_rowind - bm_colind , bm_colind , iky , ikx , iz , is ) + aa_blcs ( 1 + iv , imu , imu2 , ikxkyz , isb ) end if end do end do end if end do end do end do ! add the gyro-diffusive term to cdiffmat do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) do iv = 1 , nvpa do imu = 1 , nmu ! diagonal indices in blockmatrix ivv = nmu * ( iv - 1 ) + imu imm = ivv if (( max ( 1 , ivv - ( nmu + 1 )) <= imm ) . and . ( imm <= min ( nvpa * nmu , ivv + ( nmu + 1 )))) then ! intra-species: cdiffmat_band ( nmu + 1 + nmu + 1 + 1 + imm - ivv , ivv , iky , ikx , iz , is ) = cdiffmat_band ( nmu + 1 + nmu + 1 + 1 + imm - ivv , ivv , iky , ikx , iz , is ) & + code_dt * cfac * 0.5 * kperp2 ( iky , ikx , ia , iz ) * ( spec ( is )% smz / bmag ( ia , iz )) ** 2 * ( nupa ( iv , imu , iz , is , is ) * bmag ( ia , iz ) * mu ( imu ) & + deflknob * nuD ( iv , imu , iz , is , is ) * ( vpa ( iv ) ** 2 + bmag ( ia , iz ) * mu ( imu ))) ! inter-species: do isb = 1 , nspec if ( isb == is ) cycle if (( is == 2 ) . and . ( isb == 1 )) then eiediff = eiediffknob eidefl = eideflknob else eiediff = 1 eidefl = 1 end if cdiffmat_band ( nmu + 1 + nmu + 1 + 1 + imm - ivv , ivv , iky , ikx , iz , is ) = cdiffmat_band ( nmu + 1 + nmu + 1 + 1 + imm - ivv , ivv , iky , ikx , iz , is ) & + code_dt * cfac * 0.5 * kperp2 ( iky , ikx , ia , iz ) * ( spec ( is )% smz / bmag ( ia , iz )) ** 2 * ( eiediff * nupa ( iv , imu , iz , is , isb ) * bmag ( ia , iz ) * mu ( imu ) & + eidefl * deflknob * nuD ( iv , imu , iz , is , isb ) * ( vpa ( iv ) ** 2 + bmag ( ia , iz ) * mu ( imu ))) end do end if end do end do end do ! add 1 to the diagonal, since the matrix operator is 1 - C&#94;{ab}[h_a] do is = 1 , nspec do iv = 1 , nmu * nvpa do imu = 1 , nmu * nvpa if (( max ( 1 , iv - ( nmu + 1 )) <= imu ) . and . ( imu <= min ( nvpa * nmu , iv + ( nmu + 1 )))) then if ( iv == imu ) then cdiffmat_band ( nmu + 1 + nmu + 1 + 1 + imu - iv , iv , :, :, :, is ) = cdiffmat_band ( nmu + 1 + nmu + 1 + 1 + imu - iv , iv , :, :, :, is ) + 1. end if end if end do end do end do ! to write matrix in band-storage, for debugging !do ikxkyz = kxkyz_lo%llim_proc, kxkyz_lo%ulim_proc !    iky = iky_idx(kxkyz_lo,ikxkyz) !    ikx = ikx_idx(kxkyz_lo,ikxkyz) !    iz = iz_idx(kxkyz_lo,ikxkyz) !    is  = is_idx(kxkyz_lo,ikxkyz) !    if (iz/=0) cycle !    if (iky/=1) cycle !    if (is==2) then !        call open_output_file (tmpunit,'.cdiffmatband') !        do iv = 1, nvpa*nmu !          write (tmpunit,'(9es15.4e3)') cdiffmat_band(iv,:,iky,ikx,iz,is) !        end do !        write (tmpunit,*) !        call close_output_file (tmpunit) !    end if !end do ! AVB: LU factorise cdiffmat, using LAPACK's zgbtrf routine for banded matrices nc = nvpa * nmu nb = nmu + 1 lldab = 3 * ( nmu + 1 ) + 1 do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) call zgbtrf ( nc , nc , nb , nb , cdiffmat_band (:, :, iky , ikx , iz , is ), lldab , ipiv (:, iky , ikx , iz , is ), info ) end do end subroutine init_fp_diffmatrix elemental function associated_laguerre ( n , alpha , x ) integer , intent ( in ) :: n real , intent ( in ) :: x real , intent ( in ) :: alpha integer :: k real :: associated_laguerre , p , p1 , p2 p1 = dble ( 1.0 ) p2 = dble ( 1.0 ) + alpha - x if ( n == 0 ) then associated_laguerre = p1 return else if ( n == 1 ) then associated_laguerre = p2 return end if do k = 2 , n p = (( dble ( 2.0 ) * k - dble ( 1.0 ) + alpha - x ) * p2 - ( k - dble ( 1.0 ) + alpha ) * p1 ) / k p1 = p2 p2 = p end do associated_laguerre = p end function associated_laguerre elemental function associated_legendre ( l , m , x ) integer , intent ( in ) :: l , m double precision , intent ( in ) :: x integer :: k double precision :: associated_legendre , p , p1 , p2 , fac double precision :: pi pi = 3.14159265359 ! to start the recursion, use that P_l&#94;m = 0 for l < abs(m) ! and P_l&#94;l = (-1)&#94;l*(2l-1)!!(1-x&#94;2)&#94;(l/2) ! where (2l-1)!! = 2**l * Gamma(l+0.5) / sqrt(pi) p1 = 0. p2 = ( - 1 ) ** abs ( m ) * 2 ** abs ( m ) * gamma ( abs ( m ) + 0.5 ) / sqrt ( pi ) * ( 1. - x ** 2 ) ** ( abs ( m ) / 2. ) if ( abs ( m ) > l ) then associated_legendre = 0. return end if if ( l == 0 ) then associated_legendre = 1. return end if if ( l == m ) then associated_legendre = p2 return end if if ( l == - m ) then fac = ( - 1 ) ** abs ( m ) * gamma ( l - abs ( m ) + 1. ) / gamma ( l + abs ( m ) + 1. ) associated_legendre = p2 * fac return end if do k = abs ( m ) + 1 , l p = (( dble ( 2.0 ) * k - dble ( 1.0 )) * x * p2 - ( k - dble ( 1.0 ) + abs ( m )) * p1 ) / ( k - abs ( m )) p1 = p2 p2 = p end do if ( m < 0 ) then fac = ( - 1 ) ** abs ( m ) * gamma ( l - abs ( m ) + 1. ) / gamma ( l + abs ( m ) + 1. ) p = p * fac end if associated_legendre = p end function associated_legendre subroutine init_legendre use vpamu_grids , only : mu , nmu , vpa , nvpa use zgrid , only : nzgrid use stella_geometry , only : bmag use stella_layouts , only : iky_idx , ikx_idx , iz_idx , is_idx use file_utils , only : open_output_file , close_output_file implicit none integer :: iv , imu , iz , ia , mm , ll double precision :: xi allocate ( legendre_vpamu ( 0 : lmax , - lmax : lmax , nvpa , nmu , - nzgrid : nzgrid )) ! note lmin = 0, lmax = nsph-1 ! mmin = -lmax, mmax = lmax legendre_vpamu = 0. ia = 1 do iv = 1 , nvpa do imu = 1 , nmu do iz = - nzgrid , nzgrid do ll = 0 , lmax do mm = - lmax , lmax xi = dble ( vpa ( iv ) / sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mu ( imu ))) legendre_vpamu ( ll , mm , iv , imu , iz ) = associated_legendre ( ll , mm , xi ) end do end do end do end do end do end subroutine init_legendre subroutine init_bessel_fn use zgrid , only : nzgrid use vpamu_grids , only : nmu , vperp2 use stella_layouts , only : kxkyz_lo , iky_idx , ikx_idx , iz_idx , it_idx , is_idx use gyro_averages , only : aj0v use species , only : spec , nspec use stella_geometry , only : bmag use kt_grids , only : naky , nakx use dist_fn_arrays , only : kperp2 use file_utils , only : open_output_file , close_output_file implicit none integer :: ikxkyz , iky , ikx , iz , is , ia , mm , imu real :: arg , aj1fac , aj1exp , aj0exp allocate ( jm ( nmu , 0 : lmax , naky , nakx , - nzgrid : nzgrid , nspec )) allocate ( jm0 ( nmu , naky , nakx , - nzgrid : nzgrid , nspec )) jm = 0 ia = 1 aj1fac = 1.0 aj0exp = 1.0 aj1exp = 1.0 do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) jm0 (:, iky , ikx , iz , is ) = aj0v (:, ikxkyz ) ** aj0exp do mm = 0 , lmax if ( mm == 0 ) then jm (:, 0 , iky , ikx , iz , is ) = aj0v (:, ikxkyz ) ** aj0exp else if ( mm == 1 ) then !jm(:,1,iky,ikx,iz,is) = aj1fac*aj1v(:,ikxkyz)*spec(is)%smz_psi0*sqrt(vperp2(ia,iz,:)*kperp2(iky,ikx,ia,iz))/bmag(ia,iz) !mu*spec(is)%smz*sqrt(2*bmag(ia,iz)*kperp2(iky,ikx,ia,iz))/bmag(ia,iz) do imu = 1 , nmu arg = spec ( is )% smz_psi0 * sqrt ( vperp2 ( ia , iz , imu ) * kperp2 ( iky , ikx , ia , iz )) / bmag ( ia , iz ) jm ( imu , mm , iky , ikx , iz , is ) = bessel_jn ( mm , arg ) ** aj1exp * aj1fac end do else do imu = 1 , nmu arg = spec ( is )% smz_psi0 * sqrt ( vperp2 ( ia , iz , imu ) * kperp2 ( iky , ikx , ia , iz )) / bmag ( ia , iz ) !mu(imu)*spec(is)%smz*sqrt(2*bmag(ia,iz)*kperp2(iky,ikx,ia,iz))/bmag(ia,iz) jm ( imu , mm , iky , ikx , iz , is ) = bessel_jn ( mm , arg ) end do end if end do end do if ( cfac2 == 0. ) then ! disable gyro-diffusive effects in the field particle operator jm (:, 0 , :, :, :, :) = 1. if ( lmax > 0 ) then do mm = 1 , lmax jm (:, mm , :, :, :, :) = 0. end do end if end if end subroutine init_bessel_fn subroutine init_vgrid ! v grid used for writing various coll freqs to file for debugging use vpamu_grids , only : mu , nmu , vpa , vperp_max , vpa_max use stella_geometry , only : bmag integer :: ia , iv real :: delv , vmax , vmin allocate ( wgts_v ( nvel_local )); wgts_v = 0.0 allocate ( vel ( nvel_local )); vel = 0.0 ia = 1 ! calculation of Delta_j[x&#94;l L_j(x&#94;2) exp(-x&#94;2)] requires integrals over v, set these up below: ! velocity grid, equally spaced, from 0 to vmax: vmax = sqrt ( maxval ( vpa ) ** 2 + 2 * maxval ( bmag ( ia , :)) * maxval ( mu )) !sqrt(vperp_max**2 + vpa_max**2) !vmin = 1e-9 delv = vmax / nvel_local ! (vmax-vmin)/(nvel_local-1) vmin = sqrt ( minval ( abs ( vpa )) ** 2 + 2 * minval ( bmag ) * minval ( mu )) !delv !1e-9 do iv = 1 , nvel_local vel ( iv ) = vmin + ( iv - 1 ) * delv end do ! Trapezoidal rule: wgts_v = 0.5 * delv ! Composite Simpson's at interior nodes, average of Simpson's 3/8 and Composite at boundaries: ! Lower boundary, Simpson's 3/8: !del = 0.375*delv !wgts_v(1) = del !wgts_v(2:3) = 3.*del !wgts_v(4) = del ! Interior points, Composite: !nv_seg = (nvel_local-4)/2 !del = delv/3. !do iseg = 1, nv_seg !   idx = 2*(iseg-1) + 4 ! for iseg = 1, idx = 4; for iseg = nv_seg, idx = nv-2. !   wgts_v(idx) = wgts_v(idx) + del !   wgts_v(idx+1) = wgts_v(idx+1) + 4.*del !   wgts_v(idx+2) = wgts_v(idx+2) + del !end do ! Upper boundary, Simpson's 3/8: !del = 0.375*delv !wgts_v(nvel_local-3) = wgts_v(nvel_local-3) + del !wgts_v(nvel_local-2:nvel_local-1) = wgts_v(nvel_local-2:nvel_local-1) + 3.*del !wgts_v(nvel_local) = wgts_v(nvel_local) + del ! Interior points, Composite: !nv_seg = (nvel_local-4)/2 !del = delv/3. !do iseg = 1, nv_seg !   idx = 2*(iseg-1)+1 ! for iseg = 1, idx = 1; for iseg = nv_seg, idx = nv-5. !   wgts_v(idx) = wgts_v(idx) + del !   wgts_v(idx+1) = wgts_v(idx+1) + 4.*del !   wgts_v(idx+2) = wgts_v(idx+2) + del !end do ! AVB: the points idx = 4 and idx = nv-3 are counted three times ! divide by 2 to account for double-counting !wgts_v = 0.5*wgts_v end subroutine init_vgrid recursive subroutine gamlow ( a , x , gl ) ! recursive calculation of lower incomplete gamma function for half-integer a > 0 use constants , only : pi use spfunc , only : erf => erf_ext implicit none real , intent ( in ) :: a real , intent ( in ) :: x real , intent ( out ) :: gl real :: glm1 if ( a == 0.5 ) then gl = sqrt ( pi ) * erf ( sqrt ( x )) else call gamlow ( a - 1. , x , glm1 ) gl = ( a - 1. ) * glm1 - x ** ( a - 1. ) * exp ( - x ) end if end subroutine gamlow recursive subroutine gamup ( a , x , gu ) ! recursive calculation of the upper incomplete gamma function for integer a > 0 use constants , only : pi use spfunc , only : erf => erf_ext implicit none real , intent ( in ) :: a real , intent ( in ) :: x real , intent ( out ) :: gu real :: gum1 if ( a == 1.0 ) then gu = exp ( - x ) else call gamup ( a - 1. , x , gum1 ) gu = ( a - 1. ) * gum1 + x ** ( a - 1. ) * exp ( - x ) end if end subroutine gamup subroutine calc_delta0 ( xa , jj , ll , isa , isb , delt0 ) ! calculate Delta0&#94;{j,l,ab}(xa) (on xa grid) ! j and l denote the degree and index of the associated laguerre polynomial use species , only : nspec , spec use constants , only : pi implicit none integer , intent ( in ) :: jj , ll , isa , isb real , intent ( in ) :: xa real , intent ( out ) :: delt0 real :: massr , ckjl , xb , gaml1 , gaml2 , gamu1 , gamu2 integer :: kk massr = spec ( isa )% mass / spec ( isb )% mass xb = xa / sqrt ( massr ) delt0 = 0 do kk = 0 , jj ckjl = ( - 1 ) ** kk * gamma ( jj + ll + 0.5 + 1 ) / ( gamma ( jj - kk + 1. ) * gamma ( ll + kk + 0.5 + 1 ) * gamma ( kk + 1. )) call gamlow ( 1.5 + ll + kk , xb ** 2 , gaml1 ) call gamlow ( 2.5 + ll + kk , xb ** 2 , gaml2 ) call gamup ( 1. + kk , xb ** 2 , gamu1 ) call gamup ( 2. + kk , xb ** 2 , gamu2 ) delt0 = delt0 + ckjl * (( 2 * ll + 1. ) * xb ** ( ll + 2. * kk ) * exp ( - xb ** 2 ) & - xb * ( 1. - massr ) * ( - ( ll + 1. ) / xb ** ( ll + 2. ) * gaml1 + ll * xb ** ( ll - 1. ) * gamu1 ) & - ( 1. / xb ** ( ll + 1. ) * gaml1 + xb ** ll * gamu1 ) & + massr * xb ** 2 * (( ll + 1. ) * ( ll + 2. ) / ( 2 * ll + 3. ) * ( xb ** ( - ll - 3. ) * gaml2 + xb ** ll * gamu1 ) & - ll * ( ll - 1. ) / ( 2 * ll - 1. ) * ( xb ** ( - ll - 1. ) * gaml1 + xb ** ( ll - 2. ) * gamu2 ))) end do delt0 = delt0 * 4 * pi / ( pi ** 1.5 ) * exp ( - xa ** 2 ) * massr / ( 2 * ll + 1. ) end subroutine calc_delta0 recursive subroutine calc_deltaj_vmu ( jj , nn , ll , isa , isb , deltj ) ! calculate Delta_j&#94;{ab,l}[x_b&#94;l L_n&#94;{l+0.5}(x_b&#94;2) exp(-x_b&#94;2)](xa) (on x_a grid) ! these are normalised, and calculated without the collision frequency ! in contrast to Hirshman & Sigmar 1976 use species , only : nspec use vpamu_grids , only : mu , nmu , vpa , nvpa use zgrid , only : nzgrid use stella_geometry , only : bmag implicit none integer , intent ( in ) :: jj , nn , ll , isa , isb real , dimension ( nvpa , nmu , - nzgrid : nzgrid ), intent ( out ) :: deltj real , dimension ( nvpa , nmu , - nzgrid : nzgrid ) :: deltajm1_n , deltajm1_j integer :: iv , imu , iz , ia real :: v real , dimension ( - nzgrid : nzgrid ) :: psijm1_n ia = 1 if ( jj == 0 ) then do iv = 1 , nvpa do imu = 1 , nmu do iz = - nzgrid , nzgrid v = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mu ( imu )) call calc_delta0 ( v , nn , ll , isa , isb , deltj ( iv , imu , iz )) end do end do end do else ! get Delta_[j-1]&#94;{ab,l}[x_b&#94;l L_n&#94;{l+0.5}(x_b&#94;2) exp(-x_b&#94;2)](xa) call calc_deltaj_vmu ( jj - 1 , nn , ll , isa , isb , deltajm1_n ) ! get Delta_[j-1]&#94;{ab,l}[x_b&#94;l L_[j-1]&#94;{l+0.5}(x_b&#94;2) exp(-x_b&#94;2)](xa) call calc_deltaj_vmu ( jj - 1 , jj - 1 , ll , isa , isb , deltajm1_j ) ! get psi_[j-1]&#94;{ab,l}[x_b&#94;l L_n&#94;{l+0.5}(x_b&#94;2) exp(-x_b&#94;2)](xa) call calc_psi_vmu ( jj - 1 , nn , ll , isa , isb , psijm1_n ) deltj = deltajm1_n - spread ( spread ( psijm1_n , 1 , nvpa ), 2 , nmu ) * deltajm1_j end if end subroutine calc_deltaj_vmu subroutine vLj_vmu ( jj , ll , vLj ) use species , only : nspec use vpamu_grids , only : mu , nmu , vpa , nvpa use zgrid , only : nzgrid use stella_geometry , only : bmag implicit none integer , intent ( in ) :: jj , ll real , dimension ( nvpa , nmu , - nzgrid : nzgrid ), intent ( out ) :: vLj integer :: iv , imu , iz , ia real :: v ia = 1 do iv = 1 , nvpa do imu = 1 , nmu do iz = - nzgrid , nzgrid v = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mu ( imu )) vLj ( iv , imu , iz ) = v ** ll * associated_laguerre ( jj , ll + 1. / 2. , v ** 2 ) end do end do end do end subroutine vLj_vmu recursive subroutine calc_psi_vmu ( jj , nn , ll , isa , isb , psij ) ! calculate psi_j&#94;{ab,l}[x_b&#94;l L_n&#94;{l+0.5}(x_b&#94;2) exp(-x_b&#94;2)] ! have defined deltaj without collision frequency ! and normalised everthing to species thermal speeds use species , only : nspec , spec use vpamu_grids , only : nmu , nvpa , integrate_vmu use zgrid , only : nzgrid implicit none integer , intent ( in ) :: jj , nn , ll , isa , isb real , dimension ( nvpa , nmu , - nzgrid : nzgrid ) :: deltj_j , vLj , vLn !deltj_n real , dimension ( - nzgrid : nzgrid ), intent ( out ) :: psij integer :: iz real , dimension ( - nzgrid : nzgrid ) :: num , den if ( jj == 0 ) then if (( ll == 0 ) . and . ( nn == 0 )) then ! never used num = 1 den = 1 else ! get delta_j&#94;{ba}(x_a&#94;l L_j&#94;{l+0.5}(x_a&#94;2) exp(-x_a&#94;2)), on x_b grid call calc_deltaj_vmu ( jj , jj , ll , isb , isa , deltj_j ) ! multiply by x_b&#94;l L_n(x_b&#94;2) and integrate call vLj_vmu ( nn , ll , vLn ) do iz = - nzgrid , nzgrid call integrate_vmu ( vLn (:, :, iz ) * deltj_j (:, :, iz ), iz , num ( iz )) ! numerator in psijl end do ! if mb / ma < 1 use self-adjointness to avoid resolution problems if ( spec ( isb )% mass / spec ( isa )% mass < 1. ) then call calc_deltaj_vmu ( jj , jj , ll , isa , isb , deltj_j ) ! need to account for mass ratio normalisation ! and collision frequency ! \\int x_a&#94;l L_j&#94;{l+1/2}(x_a&#94;2) \\Delta_j'&#94;{ab}[\\tilde{f}_b/F0b * F0b] x_a&#94;2 dx_a !   = ma&#94;0.5/mb&#94;0.5 * ma&#94;3/mb&#94;3 \\int f_b/F0b \\Delta_j&#94;{ba}'[x_a&#94;l L_j&#94;{l+1/2}(x_a&#94;2) \\tilde{F0a}] x_b&#94;2 dx_b call vLj_vmu ( jj , ll , vLj ) do iz = - nzgrid , nzgrid call integrate_vmu ( spec ( isb )% mass ** 3.5 / spec ( isa )% mass ** 3.5 * vLj (:, :, iz ) * deltj_j (:, :, iz ), iz , den ( iz )) ! denominator in psijl end do else call vLj_vmu ( jj , ll , vLj ) do iz = - nzgrid , nzgrid call integrate_vmu ( vLj (:, :, iz ) * deltj_j (:, :, iz ), iz , den ( iz )) ! denominator in psijl end do end if end if else ! get delta_j&#94;{ba}(x_a&#94;l L_j&#94;{l+0.5}(x_a&#94;2) exp(-x_a&#94;2)), on x_b grid call calc_deltaj_vmu ( jj , jj , ll , isb , isa , deltj_j ) ! multiply by x_b&#94;l L_n(x_b&#94;2) and integrate call vLj_vmu ( nn , ll , vLn ) do iz = - nzgrid , nzgrid call integrate_vmu ( vLn (:, :, iz ) * deltj_j (:, :, iz ), iz , num ( iz )) ! numerator in psijl end do ! if mb / ma < 1 use self-adjointness to avoid resolution problems if ( spec ( isb )% mass / spec ( isa )% mass < 1. ) then call calc_deltaj_vmu ( jj , jj , ll , isa , isb , deltj_j ) ! need to account for mass ratio normalisation ! and collision frequency ! \\int x_a&#94;l L_j&#94;{l+1/2}(x_a&#94;2) \\Delta_j'&#94;{ab}[\\tilde{f}_b/F0b * F0b] x_a&#94;2 dx_a !   = ma&#94;0.5/mb&#94;0.5 * ma&#94;3/mb&#94;3 \\int f_b/F0b \\Delta_j&#94;{ba}'[x_a&#94;l L_j&#94;{l+1/2}(x_a&#94;2) \\tilde{F0a}] x_b&#94;2 dx_b call vLj_vmu ( jj , ll , vLj ) do iz = - nzgrid , nzgrid call integrate_vmu ( spec ( isb )% mass ** 3.5 / spec ( isa )% mass ** 3.5 * vLj (:, :, iz ) * deltj_j (:, :, iz ), iz , den ( iz )) ! denominator in psijl end do else call vLj_vmu ( jj , ll , vLj ) do iz = - nzgrid , nzgrid call integrate_vmu ( vLj (:, :, iz ) * deltj_j (:, :, iz ), iz , den ( iz )) ! denominator in psijl end do end if end if psij = num / den end subroutine calc_psi_vmu subroutine init_deltaj_vmu use species , only : nspec , spec use zgrid , only : nzgrid use stella_geometry , only : bmag use vpamu_grids , only : mu , nmu , vpa , nvpa , vperp_max , vpa_max , integrate_vmu , set_vpa_weights use file_utils , only : open_output_file , close_output_file use constants , only : pi use stella_layouts , only : kxkyz_lo , iky_idx , ikx_idx , iz_idx , is_idx , it_idx use stella_time , only : code_dt use kt_grids , only : naky implicit none real , dimension ( 0 : lmax , 0 : jmax , nvpa , nmu , 1 , - nzgrid : nzgrid ) :: vlaguerre_vmu integer :: ll , iv , jj , ia , imu , iz , is , isa , isb , ix , ikx , iky , ikxkyz real , dimension ( - nzgrid : nzgrid ) :: deltajint , deltajint_tp real , dimension ( nvpa * nmu , - nzgrid : nzgrid ) :: vpaF0vec , v2F0vec real , dimension ( nvpa * nmu , nvpa * nmu ) :: ident logical :: conservative_wgts ia = 1 allocate ( deltaj ( 0 : lmax , 0 : jmax , nspec , nspec , nvpa , nmu , ia , - nzgrid : nzgrid )) allocate ( deltaj_tp ( 0 : lmax , 0 : jmax , nspec , nspec , nvpa , nmu , ia , - nzgrid : nzgrid )) allocate ( psijnorm ( 0 : lmax , 0 : jmax , nspec , nspec , - nzgrid : nzgrid )) allocate ( mwnorm ( - nzgrid : nzgrid )) allocate ( modmwnorm ( - nzgrid : nzgrid )) if ( density_conservation ) then conservative_wgts = . true . call set_vpa_weights ( conservative_wgts ) else if ( exact_conservation_tp ) then conservative_wgts = . false . call set_vpa_weights ( conservative_wgts ) else conservative_wgts = . false . call set_vpa_weights ( conservative_wgts ) end if ! AVB: to do - option for cons_wgts when exact_conservation is true ! get Delta_j&#94;{l,ab}[x_b&#94;l L_j&#94;{l+0.5}(x_b&#94;2)F_{0b}](x_a) ! and Delta_j&#94;{l,ba}[x_a&#94;l L_j&#94;{l+0.5}(x_a&#94;2)F_{0a}](x_b) deltaj = 0 ! construct an identity matrix required below ident = 0 forall ( iv = 1 : nvpa * nmu ) ident ( iv , iv ) = 1. do isa = 1 , nspec do isb = 1 , nspec do ll = 0 , lmax do jj = 0 , jmax call calc_deltaj_vmu ( jj , jj , ll , isa , isb , deltaj ( ll , jj , isa , isb , :, :, ia , :)) call vLj_vmu ( jj , ll , vlaguerre_vmu ( ll , jj , :, :, ia , :)) if ( spitzer_problem ) then if (( exact_conservation ) . and . ( ll == 1 ) . and . ( jj == 0 ) & . and . . not . (( isa == 1 ) . and . ( isb == 1 )) & . and . . not . (( isa == 1 ) . and . ( isb == 2 )) & ) then ! to ensure conservation of momentum to machine precision !call open_output_file (tmpunit,'.deltaj_l1default') !do iv = 1, nvpa !    write (tmpunit,'(32es15.4e3)') ( deltaj(ll, jj, isa, isb, iv, imu, ia, 0), imu=1, nmu ) ! at z = 0 ! electron-ion !end do !write (tmpunit,*) !call close_output_file (tmpunit) ! calculate delta_{j=0,l=1}&#94;{ab} using the differential test particle operator C&#94;{ab} acting on m_a v_\\parallel F0a do iv = 1 , nvpa do imu = 1 , nmu do iz = - nzgrid , nzgrid vpaF0vec ( nmu * ( iv - 1 ) + imu , iz ) = vpa ( iv ) * mw ( iv , imu , iz , isa ) end do end do end do do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) if ( is /= isa ) cycle vpaF0vec (:, iz ) = matmul ( blockmatrix (:, :, ikxkyz , isb ) / code_dt / spec ( is )% vnew ( isb ), ( spec ( isa )% mass / spec ( isb )% mass ) ** 2 * vpaF0vec (:, iz )) end do do ix = 1 , nvpa deltaj_tp ( ll , jj , isa , isb , ix , :, ia , :) = vpaF0vec ( nmu * ( ix - 1 ) + 1 : nmu * ( ix - 1 ) + nmu , :) end do deltaj_tp ( ll , jj , isa , isb , :, :, ia , :) = deltaj_tp ( ll , jj , isa , isb , :, :, ia , :) * velvpamu / spread ( spread ( vpa , 2 , nmu ), 3 , 2 * nzgrid + 1 ) !call open_output_file (tmpunit,'.deltaj_l1modified') !do iv = 1, nvpa !    write (tmpunit,'(32es15.4e3)') ( deltaj_tp(ll, jj, isa, isb, iv, imu, ia, 0), imu=1, nmu ) ! at z = 0 !end do !write (tmpunit,*) !call close_output_file (tmpunit) end if else if (( exact_conservation ) . and . ( ll == 1 ) . and . ( jj == 0 )) then if ( spec ( isa )% vnew ( isb ) == 0 ) cycle !if ((isa==1).and.(isb==2)) then !   call open_output_file (tmpunit,'.deltaj_l1default_ie') !   do iv = 1, nvpa !       write (tmpunit,'(32es15.4e3)') ( deltaj(ll, jj, isa, isb, iv, imu, ia, 0), imu=1, nmu ) !   end do !   write (tmpunit,*) !   call close_output_file (tmpunit) !end if ! calculate delta_{j=0,l=1}&#94;{ab} using the differential test particle operator C&#94;{ab} acting on m_a v_\\parallel F0a do iv = 1 , nvpa do imu = 1 , nmu do iz = - nzgrid , nzgrid vpaF0vec ( nmu * ( iv - 1 ) + imu , iz ) = vpa ( iv ) * mw ( iv , imu , iz , isa ) end do end do end do do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) if ( iky /= naky ) cycle if ( is /= isa ) cycle vpaF0vec (:, iz ) = matmul ( blockmatrix (:, :, ikxkyz , isb ) / code_dt / spec ( is )% vnew ( isb ), ( spec ( isa )% mass / spec ( isb )% mass ) ** 2 * vpaF0vec (:, iz )) end do do ix = 1 , nvpa deltaj_tp ( ll , jj , isa , isb , ix , :, ia , :) = vpaF0vec ( nmu * ( ix - 1 ) + 1 : nmu * ( ix - 1 ) + nmu , :) end do deltaj_tp ( ll , jj , isa , isb , :, :, ia , :) = deltaj_tp ( ll , jj , isa , isb , :, :, ia , :) * velvpamu / spread ( spread ( vpa , 2 , nmu ), 3 , 2 * nzgrid + 1 ) !if ((isa==1).and.(isb==2)) then !call open_output_file (tmpunit,'.deltaj_l1modified_ie') !   do iv = 1, nvpa !       write (tmpunit,'(32es15.4e3)') ( deltaj_tp(ll, jj, isa, isb, iv, imu, ia, 0), imu=1, nmu ) ! at z = 0 !  end do !  write (tmpunit,*) !  call close_output_file (tmpunit) !end if end if end if if ( spitzer_problem ) then if (( exact_conservation ) . and . ( ll == 0 ) . and . ( jj == 1 ) & . and . . not . (( isa == 1 ) . and . ( isb == 1 )) & . and . . not . (( isa == 1 ) . and . ( isb == 2 )) & ) then ! energy conservation to machine precision !call open_output_file (tmpunit,'.deltaj_j1default') !do iv = 1, nvpa !    write (tmpunit,'(32es15.4e3)') ( deltaj(ll, jj, isa, isb, iv, imu, ia, 0), imu=1, nmu ) ! at z = 0 ! electron-ion !end do !write (tmpunit,*) !call close_output_file (tmpunit) ! calculate delta_{j=1,l=0}&#94;{ab} using the differential test particle operator C&#94;{ab} acting on m_a v&#94;2 F0a do iv = 1 , nvpa do imu = 1 , nmu do iz = - nzgrid , nzgrid v2F0vec ( nmu * ( iv - 1 ) + imu , iz ) = ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mu ( imu )) * mw ( iv , imu , iz , isa ) end do end do end do do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) if ( is /= isa ) cycle v2F0vec (:, iz ) = matmul ( blockmatrix (:, :, ikxkyz , isb ) / code_dt / spec ( is )% vnew ( isb ), - ( spec ( isa )% mass / spec ( isb )% mass ) ** 1.5 * v2F0vec (:, iz )) end do do ix = 1 , nvpa deltaj_tp ( ll , jj , isa , isb , ix , :, ia , :) = v2F0vec ( nmu * ( ix - 1 ) + 1 : nmu * ( ix - 1 ) + nmu , :) end do !call open_output_file (tmpunit,'.deltaj_j1modified') !do iv = 1, nvpa !    write (tmpunit,'(32es15.4e3)') ( deltaj_tp(ll, jj, isa, isb, iv, imu, ia, 0), imu=1, nmu ) ! at z = 0 !end do !write (tmpunit,*) !call close_output_file (tmpunit) end if else if (( exact_conservation ) . and . ( ll == 0 ) . and . ( jj == 1 )) then if ( spec ( isa )% vnew ( isb ) == 0 ) cycle !if ((isa==1).and.(isb==2)) then !    call open_output_file (tmpunit,'.deltaj_j1default_ie') !    do iv = 1, nvpa !        write (tmpunit,*) ( deltaj(ll, jj, isa, isb, iv, imu, ia, 0), imu=1, nmu ) ! at z = 0 ! electron-ion !    end do !    write (tmpunit,*) !    call close_output_file (tmpunit) !end if ! calculate delta_{j=1,l=0}&#94;{ab} using the differential test particle operator C&#94;{ab} acting on m_a v_\\parallel&#94;2 F0a do iv = 1 , nvpa do imu = 1 , nmu do iz = - nzgrid , nzgrid v2F0vec ( nmu * ( iv - 1 ) + imu , iz ) = ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mu ( imu )) * mw ( iv , imu , iz , isa ) end do end do end do do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) if ( is /= isa ) cycle if ( iky /= naky ) cycle v2F0vec (:, iz ) = matmul ( blockmatrix (:, :, ikxkyz , isb ) / code_dt / spec ( is )% vnew ( isb ), - ( spec ( isa )% mass / spec ( isb )% mass ) ** 1.5 * v2F0vec (:, iz )) end do do ix = 1 , nvpa deltaj_tp ( ll , jj , isa , isb , ix , :, ia , :) = v2F0vec ( nmu * ( ix - 1 ) + 1 : nmu * ( ix - 1 ) + nmu , :) end do !if ((isa==1).and.(isb==2)) then !    call open_output_file (tmpunit,'.deltaj_j1modified_ie') !    do iv = 1, nvpa !        write (tmpunit,*) ( deltaj_tp(ll, jj, isa, isb, iv, imu, ia, 0), imu=1, nmu ) ! at z = 0 !    end do !    write (tmpunit,*) !    call close_output_file (tmpunit) !end if end if end if !conservative_wgts = .false. !call set_vpa_weights (conservative_wgts) ! required integrals to ensure density conservation in field particle operator: do iz = - nzgrid , nzgrid call integrate_vmu ( mw (:, :, iz , isa ), iz , mwnorm ( iz )) end do do iz = - nzgrid , nzgrid call integrate_vmu ( modmw (:, :, iz , isa ), iz , modmwnorm ( iz )) end do ! to ensure number conservation to machine precision, \\Delta_{j=1} -> \\Delta_{j=1} - F0/\\int F0 dv * \\int \\Delta_{j=1} dv ! AVB: to do - need to generalise this to higher-order terms in the field particle operator if (( density_conservation_field ) . and . ( ll == 0 ) . and . ( jj == 1 )) then do iz = - nzgrid , nzgrid call integrate_vmu ( deltaj ( ll , jj , isa , isb , :, :, ia , iz ), iz , deltajint ( iz )) end do do iz = - nzgrid , nzgrid call integrate_vmu ( deltaj_tp ( ll , jj , isa , isb , :, :, ia , iz ), iz , deltajint_tp ( iz )) end do ! check accuracy of deltaj: !call open_output_file (tmpunit,'.deltaj_check') !do iv = 1, nvpa !    write (tmpunit,'(32es15.4e3)') ( deltaj(ll, jj, isa, isb, iv, imu, ia, 0), imu=1, nmu ) ! at z = 0 !end do !write (tmpunit,*) !call close_output_file (tmpunit) deltaj ( ll , jj , isa , isb , :, :, ia , :) = deltaj ( ll , jj , isa , isb , :, :, ia , :) & - mw (:, :, :, isa ) / spread ( spread ( mwnorm , 1 , nvpa ), 2 , nmu ) * spread ( spread ( deltajint , 1 , nvpa ), 2 , nmu ) deltaj_tp ( ll , jj , isa , isb , :, :, ia , :) = deltaj_tp ( ll , jj , isa , isb , :, :, ia , :) & - mw (:, :, :, isa ) / spread ( spread ( mwnorm , 1 , nvpa ), 2 , nmu ) * spread ( spread ( deltajint_tp , 1 , nvpa ), 2 , nmu ) !all open_output_file (tmpunit,'.deltaj_check_mod') !do iv = 1, nvpa !    write (tmpunit,'(32es15.4e3)') ( deltaj(ll, jj, isa, isb, iv, imu, ia, 0), imu=1, nmu ) ! at z = 0 !end do !write (tmpunit,*) !call close_output_file (tmpunit) ! check density conservation to machine precision !do iz = -nzgrid, nzgrid !    call integrate_vmu(deltaj(ll, jj, isa, isb, :, :, ia, iz), iz, deltajint(iz)) !end do end if end do end do end do end do ! get normalisations for psijls do isa = 1 , nspec do isb = 1 , nspec do ll = 0 , lmax do iz = - nzgrid , nzgrid do jj = 0 , jmax if (( ll == 0 ) . and . ( jj == 0 )) then psijnorm ( ll , jj , isa , isb , iz ) = 1 ! never used else ! note self-adjointness of deltaj after normalisation and without coll freqs (\\Delta_j') is ! \\int x_a&#94;l L_j&#94;{l+1/2}(x_a&#94;2) \\Delta_j'&#94;{ab}[\\tilde{f}_b/F0b * F0b] x_a&#94;2 dx_a ! = ma&#94;0.5/mb&#94;0.5 * ma&#94;3/mb&#94;3 \\int f_b/F0b \\Delta_j&#94;{ba}'[x_a&#94;l L_j&#94;{l+1/2}(x_a&#94;2) \\tilde{F0a}] x_b&#94;2 dx_b if (( exact_conservation ) . and . ( ll == 1 ) . and . ( jj == 0 )) then ! momentum conservation term for uniform mu grid call integrate_vmu ( 3 * legendre_vpamu ( ll , 0 , :, :, iz ) ** 2 * vlaguerre_vmu ( ll , jj , :, :, ia , iz ) * deltaj ( ll , jj , isa , isb , :, :, ia , iz ) & * ( spec ( isa )% mass / spec ( isb )% mass ) ** ( - 3 ) * ( spec ( isa )% mass / spec ( isb )% mass ) ** ( - 0.5 ), iz , psijnorm ( ll , jj , isa , isb , iz )) else if (( exact_conservation ) . and . ( ll == 0 ) . and . ( jj == 1 )) then ! energy conservation term for uniform mu grid call integrate_vmu ( legendre_vpamu ( ll , 0 , :, :, iz ) ** 2 * vlaguerre_vmu ( ll , jj , :, :, ia , iz ) * deltaj ( ll , jj , isa , isb , :, :, ia , iz ) & * ( spec ( isa )% mass / spec ( isb )% mass ) ** ( - 3 ) * ( spec ( isa )% mass / spec ( isb )% mass ) ** ( - 0.5 ), iz , psijnorm ( ll , jj , isa , isb , iz )) else if (( exact_conservation_tp ) . and . ( ll == 0 ) . and . ( jj == 1 )) then ! energy conservation term for non-uniform mu grid call integrate_vmu ( legendre_vpamu ( ll , 0 , :, :, iz ) ** 2 * vlaguerre_vmu ( ll , jj , :, :, ia , iz ) * deltaj ( ll , jj , isa , isb , :, :, ia , iz ) & * ( spec ( isa )% mass / spec ( isb )% mass ) ** ( - 3 ) * ( spec ( isa )% mass / spec ( isb )% mass ) ** ( - 0.5 ), iz , psijnorm ( ll , jj , isa , isb , iz )) else if (( exact_conservation_tp ) . and . ( ll == 1 ) . and . ( jj == 0 )) then ! momentum conservation term for non-uniform mu grid call integrate_vmu ( 3 * legendre_vpamu ( ll , 0 , :, :, iz ) ** 2 * vlaguerre_vmu ( ll , jj , :, :, ia , iz ) * deltaj ( ll , jj , isa , isb , :, :, ia , iz ) & * ( spec ( isa )% mass / spec ( isb )% mass ) ** ( - 3 ) * ( spec ( isa )% mass / spec ( isb )% mass ) ** ( - 0.5 ), iz , psijnorm ( ll , jj , isa , isb , iz )) else if (. not . (( exact_conservation ) . or . ( exact_conservation_tp )) . and . ( ll == 0 ) . and . ( jj == 1 )) then ! non-exact conservation of energy if ( spec ( isa )% mass / spec ( isb )% mass < 1. ) then ! use self-adjointness to avoid resolution problems call integrate_vmu (( - velvpamu (:, :, iz ) ** 2 ) * deltaj ( ll , jj , isb , isa , :, :, ia , iz ), iz , psijnorm ( ll , jj , isa , isb , iz )) else call integrate_vmu (( - velvpamu (:, :, iz ) ** 2 ) * deltaj ( ll , jj , isa , isb , :, :, ia , iz ) * ( spec ( isa )% mass / spec ( isb )% mass ) ** ( - 3 ) & * ( spec ( isa )% mass / spec ( isb )% mass ) ** ( - 0.5 ), iz , psijnorm ( ll , jj , isa , isb , iz )) end if else ! non-exact conservation of momentum, and higher-order terms if ( spec ( isa )% mass / spec ( isb )% mass < 1. ) then ! use self-adjointness to avoid resolution problems call integrate_vmu ( vlaguerre_vmu ( ll , jj , :, :, ia , iz ) * deltaj ( ll , jj , isb , isa , :, :, ia , iz ), iz , psijnorm ( ll , jj , isa , isb , iz )) else call integrate_vmu ( vlaguerre_vmu ( ll , jj , :, :, ia , iz ) * deltaj ( ll , jj , isa , isb , :, :, ia , iz ) * ( spec ( isa )% mass / spec ( isb )% mass ) ** ( - 3 ) & * ( spec ( isa )% mass / spec ( isb )% mass ) ** ( - 0.5 ), iz , psijnorm ( ll , jj , isa , isb , iz )) end if end if end if end do end do end do end do end do psijnorm = psijnorm / ( 4 * pi ) ! account for theta and phi integrals included in integrate_vmu ! to check self-adjointness !!print('Integral A =', np.trapz(vlinspace**lll * assoc_laguerre(vlinspace**2, jjj, lll+0.5) * fp0(vlinspace, ma, mb, jjj, lll) * vlinspace**2, x=vlinspace) ) !!print('Integral B =', np.trapz(ma**0.5/mb**0.5 * ma**3/mb**3 * vlinspace**lll * assoc_laguerre(vlinspace**2, jjj, lll+0.5) * fp0(vlinspace, mb, ma, jjj, lll) * vlinspace**2, x=vlinspace) ) !if (nspec > 1) then !    ia  = 1 !    ll  = 0 !    jj  = 1 !    isa = 1 !    isb = 2 !    print*,'' !    call integrate_vmu( vlaguerre_vmu(ll,jj,:,:,ia,0)*deltaj(ll,jj,isa,isb,:,:,ia,0), 0, psijnorm(ll,jj,isa,isb,0) ) !    print*,'Integral A j1l0 =', psijnorm(ll,jj,isa,isb,0) !    call integrate_vmu( vlaguerre_vmu(ll,jj,:,:,ia,0)*deltaj(ll,jj,isb,isa,:,:,ia,0) * (spec(isa)%mass/spec(isb)%mass)**3.0 * (spec(isa)%mass/spec(isb)%mass)**0.5, 0, psijnorm(ll,jj,isb,isa,0) ) !    print*,'Integral B j1l0 =', psijnorm(ll,jj,isb,isa,0) !    call integrate_vmu( (-velvpamu(:,:,0)**2)*deltaj(ll,jj,isb,isa,:,:,ia,0) * (spec(isa)%mass/spec(isb)%mass)**3.0 * (spec(isa)%mass/spec(isb)%mass)**0.5, 0, psijnorm(ll,jj,isb,isa,0) ) !    print*,'Integral B j1l0b=', psijnorm(ll,jj,isb,isa,0) !    print*,'' !    ia  = 1 !    ll  = 1 !    jj  = 0 !    isa = 1 !    isb = 2 !    print*,'' !    call integrate_vmu( vlaguerre_vmu(ll,jj,:,:,ia,0)*deltaj(ll,jj,isa,isb,:,:,ia,0), 0, psijnorm(ll,jj,isa,isb,0) ) !    print*,'Integral A l1j0 =', psijnorm(ll,jj,isa,isb,0) !    call integrate_vmu( vlaguerre_vmu(ll,jj,:,:,ia,0)*deltaj(ll,jj,isb,isa,:,:,ia,0) * (spec(isa)%mass/spec(isb)%mass)**3.0 * (spec(isa)%mass/spec(isb)%mass)**0.5, 0, psijnorm(ll,jj,isb,isa,0) ) !    print*,'Integral B l1j0 =', psijnorm(ll,jj,isb,isa,0) !    print*,'' !end if ! to write interspec delt0 to file !if (nspec > 1) then !    do iv = 1, nvel_local !        call calc_delta0 (vel(iv), 1, 0, 1, 2, delt0test1(iv)) ! jj=1, ll=0, ie !        call calc_delta0 (vel(iv), 1, 0, 2, 1, delt0test2(iv)) ! jj=1, ll=0, ei !        call calc_delta0 (vel(iv), 0, 1, 1, 2, delt0test3(iv)) ! jj=1, ll=0, ie !        call calc_delta0 (vel(iv), 0, 2, 2, 2, delt0test4(iv)) ! jj=1, ll=0, ei !    end do !    call open_output_file (tmpunit,'.delt0test') !    do iv = 1, nvel_local !      write (tmpunit,'(9es15.4e3)') vel(iv), delt0test1(iv), delt0test2(iv), delt0test3(iv), delt0test4(iv) !    end do !    write (tmpunit,*) !    call close_output_file (tmpunit) !    call open_output_file (tmpunit,'.delt0l2test') !    do iv = 1, nvel_local !      write (tmpunit,'(9es15.4e3)') vel(iv), delt0test4(iv) !    end do !    write (tmpunit,*) !    call close_output_file (tmpunit) !end if conservative_wgts = . false . call set_vpa_weights ( conservative_wgts ) ! save deltajl for inspection !call open_output_file (tmpunit,'.deltaj1l1_ee') !do iv = 1, nvpa !    write (tmpunit,*) ( deltaj(1, 1, 2, 2, iv, imu, 1, 0), imu=1, nmu ) ! at z = 0 !end do !write (tmpunit,*) !call close_output_file (tmpunit) !call open_output_file (tmpunit,'.deltaj2l1_ee') !do iv = 1, nvpa !    write (tmpunit,*) ( deltaj(1, 2, 2, 2, iv, imu, 1, 0), imu=1, nmu ) ! at z = 0 !end do !write (tmpunit,*) !call close_output_file (tmpunit) !call open_output_file (tmpunit,'.deltaj3l1_ee') !do iv = 1, nvpa !    write (tmpunit,*) ( deltaj(1, 3, 2, 2, iv, imu, 1, 0), imu=1, nmu ) ! at z = 0 !end do !write (tmpunit,*) !call close_output_file (tmpunit) !call open_output_file (tmpunit,'.deltaj1l1_ei') !do iv = 1, nvpa !    write (tmpunit,*) ( deltaj(1, 1, 2, 1, iv, imu, 1, 0), imu=1, nmu ) ! at z = 0 !end do !write (tmpunit,*) !call close_output_file (tmpunit) !call open_output_file (tmpunit,'.deltaj2l1_ei') !do iv = 1, nvpa !    write (tmpunit,*) ( deltaj(1, 2, 2, 1, iv, imu, 1, 0), imu=1, nmu ) ! at z = 0 !end do !write (tmpunit,*) !call close_output_file (tmpunit) !call open_output_file (tmpunit,'.deltaj3l1_ei') !do iv = 1, nvpa !    write (tmpunit,*) ( deltaj(1, 3, 2, 1, iv, imu, 1, 0), imu=1, nmu ) ! at z = 0 !end do !write (tmpunit,*) !call close_output_file (tmpunit) !call open_output_file (tmpunit,'.deltaj0l2_ee') !do iv = 1, nvpa !    write (tmpunit,*) ( deltaj(2, 0, 2, 2, iv, imu, 1, 0), imu=1, nmu ) ! at z = 0 !end do !write (tmpunit,*) !call close_output_file (tmpunit) !print*,'maxval deltaj0l2' !print*,maxval(abs(deltaj(2, 0, 2, 2, :, :, 1, 0))) !print*,'' !call open_output_file (tmpunit,'.deltaj1l2_ee') !do iv = 1, nvpa !    write (tmpunit,*) ( deltaj(2, 1, 2, 2, iv, imu, 1, 0), imu=1, nmu ) ! at z = 0 !end do !write (tmpunit,*) !call close_output_file (tmpunit) !call open_output_file (tmpunit,'.deltaj2l2_ee') !do iv = 1, nvpa !    write (tmpunit,*) ( deltaj(2, 2, 2, 2, iv, imu, 1, 0), imu=1, nmu ) ! at z = 0 !end do !write (tmpunit,*) !call close_output_file (tmpunit) !call open_output_file (tmpunit,'.deltaj0l1_ee') !do iv = 1, nvpa !    write (tmpunit,*) ( deltaj(1, 0, 2, 2, iv, imu, 1, 0), imu=1, nmu ) ! at z = 0 !end do !write (tmpunit,*) !call close_output_file (tmpunit) end subroutine init_deltaj_vmu subroutine get_testpart_density ( isa , isb , g , fld ) ! if isb==0: ! get the field tp_den_isa(g_isa), store it in fld(:,:,:,:,isa) ! if isa=0, fix the species indices of the operator tp_den, ie ! get the fields tp_den_isb(g_a), tp_den_isb(g_b), tp_den_isb(g_c) ... use mp , only : sum_allreduce use zgrid , only : nzgrid use vpamu_grids , only : integrate_vmu , set_vpa_weights , nvpa , nmu use stella_layouts , only : kxkyz_lo , iky_idx , ikx_idx , iz_idx , it_idx , is_idx use constants , only : pi use species , only : nspec use file_utils , only : open_output_file , close_output_file use stella_time , only : code_dt implicit none integer , intent ( in ) :: isa , isb complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :, :), intent ( out ) :: fld integer :: ikxkyz , iky , ikx , iz , it , is , ia , iv , ikxkyz_isb , is_b , iky_b , ikx_b , iz_b , it_b complex , dimension (:, :), allocatable :: g0 complex , dimension (:), allocatable :: ghrs allocate ( g0 ( nvpa , nmu )) allocate ( ghrs ( nmu * nvpa )) !conservative_wgts = .false. !call set_vpa_weights (conservative_wgts) ia = 1 fld = 0. if ( isb == 0 ) then do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) if ( is /= isa ) cycle do iv = 1 , nvpa ghrs ( nmu * ( iv - 1 ) + 1 : nmu * iv ) = g ( iv , :, ikxkyz ) end do ! blockmatrix_sum contains sum of interspecies test particle operators ghrs = matmul ( - blockmatrix_sum (:, :, ikxkyz ) / code_dt , ghrs ) do iv = 1 , nvpa g0 ( iv , :) = ghrs ( nmu * ( iv - 1 ) + 1 : nmu * iv ) end do call integrate_vmu ( g0 , iz , fld ( iky , ikx , iz , it , is )) end do else if ( isa == isb ) then ! apply the operator tp_den_isb[] to every species index of g; only used in the calculation of the response matrix ! where the species index, is, of g contains the response \\delta h_a / \\delta \\psi&#94;{a,is}; always given on an x_a grid do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) ! AVB: to do - cumbersome below, fix do iv = 1 , nvpa ghrs ( nmu * ( iv - 1 ) + 1 : nmu * iv ) = g ( iv , :, ikxkyz ) end do do ikxkyz_isb = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc is_b = is_idx ( kxkyz_lo , ikxkyz_isb ) iky_b = iky_idx ( kxkyz_lo , ikxkyz_isb ) ikx_b = ikx_idx ( kxkyz_lo , ikxkyz_isb ) iz_b = iz_idx ( kxkyz_lo , ikxkyz_isb ) it_b = it_idx ( kxkyz_lo , ikxkyz_isb ) if (( is_b /= isb ) . or . ( iky_b /= iky ) . or . ( ikx_b /= ikx ) . or . ( iz_b /= iz ) . or . ( it_b /= it )) cycle ghrs = matmul ( - blockmatrix_sum (:, :, ikxkyz_isb ) / code_dt , ghrs ) end do do iv = 1 , nvpa g0 ( iv , :) = ghrs ( nmu * ( iv - 1 ) + 1 : nmu * iv ) end do call integrate_vmu ( g0 , iz , fld ( iky , ikx , iz , it , is )) end do else fld = 0. end if deallocate ( g0 ) deallocate ( ghrs ) call sum_allreduce ( fld ) end subroutine get_testpart_density subroutine init_fp_conserve use linear_solve , only : lu_decomposition use stella_time , only : code_dt use species , only : nspec use zgrid , only : nzgrid , ntubes use vpamu_grids , only : ztmax , maxwell_mu , nmu , nvpa , set_vpa_weights use kt_grids , only : naky , nakx use stella_layouts , only : kxkyz_lo , iky_idx , ikx_idx , iz_idx , is_idx , it_idx use dist_fn_arrays , only : gvmu use fields , only : get_fields , get_fields_by_spec_idx use job_manage , only : time_message , timer_local use file_utils , only : open_output_file , close_output_file use constants , only : pi implicit none integer :: ikxkyz , iky , ikx , iz , is , it , iv , imu , ix , ia , idx1 , idx2 , il , im , ij , mm , ll , jj integer :: il1 , im1 , ij1 , mm1 , ll1 , jj1 integer :: il2 , im2 , ij2 , mm2 , ll2 , jj2 , isa , isb logical :: conservative_wgts real :: dum2 complex , dimension (:, :, :, :), allocatable :: dum1 , dum3 complex , dimension (:, :, :, :, :), allocatable :: field complex , dimension (:, :), allocatable :: sumdelta complex , dimension (:, :), allocatable :: gvmutr complex , dimension (:), allocatable :: ghrs complex , dimension (:, :, :, :, :), allocatable :: response_vpamu if (. not . allocated ( fp_response )) then if ( fieldpart ) then nresponse = 1 + ( jmax + 1 ) * ( lmax + 1 ) ** 2 * nspec ** 2 else nresponse = 1 end if allocate ( fp_response ( nresponse , nresponse , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )); fp_response = 0. allocate ( diff_idx ( nresponse , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) allocate ( response_vpamu ( nvpa , nmu , nvpa , nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) end if allocate ( dum1 ( naky , nakx , - nzgrid : nzgrid , ntubes )) allocate ( dum3 ( naky , nakx , - nzgrid : nzgrid , ntubes )) allocate ( field ( naky , nakx , - nzgrid : nzgrid , ntubes , nspec )) allocate ( sumdelta ( nvpa , nmu )); sumdelta = 0. allocate ( gvmutr ( nvpa , nmu )) allocate ( ghrs ( nmu * nvpa )); ghrs = 0. allocate ( deltajint ( jmax + 1 , nvpa , nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) ia = 1 ! set wgts to uniform to ensure exact conservation properties if ( density_conservation ) then conservative_wgts = . true . call set_vpa_weights ( conservative_wgts ) end if if ( exact_conservation_tp ) then conservative_wgts = . false . call set_vpa_weights ( conservative_wgts ) end if ! phi response do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) ghrs = reshape ( transpose ( spread ( ztmax (:, is ), 2 , nmu ) * spread ( maxwell_mu ( 1 , iz ,:, is ), 1 , nvpa ) * spread ( jm0 (:, iky , ikx , iz , is ), 1 , nvpa )), shape = ( / nmu * nvpa / )) call zgbtrs ( 'No transpose' , nvpa * nmu , nmu + 1 , nmu + 1 , 1 , cdiffmat_band (:,:, iky , ikx , iz , is ), 3 * ( nmu + 1 ) + 1 , ipiv (:, iky , ikx , iz , is ), ghrs , nvpa * nmu , info ) gvmu (:, :, ikxkyz ) = transpose ( reshape ( ghrs , shape = ( / nmu , nvpa / ))) end do ! gvmu contains dhs/dphi ! for phi equation, need 1-P[dhs/dphi] call get_fields ( gvmu , field (:, :, :, :, 1 ), dum1 , dum3 , dist = 'h' ) ! note that get_fields sums over species, as required in response matrix do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) fp_response ( 1 , 1 , ikxkyz ) = 1.0 - field ( iky , ikx , iz , it , 1 ) end do ! field particle operator ! collect all tp terms for species a in blockmatrix_sum(isa) ! required for tp density conservation to machine precision ! to do - avoid operations with blockmatrix or blockmatrix_sum, use band storage if ( density_conservation_tp ) then do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc is = is_idx ( kxkyz_lo , ikxkyz ) blockmatrix_sum (:, :, ikxkyz ) = blockmatrix (:, :, ikxkyz , is ) do isb = 1 , nspec if ( isb == is ) cycle blockmatrix_sum (:, :, ikxkyz ) = blockmatrix_sum (:, :, ikxkyz ) + blockmatrix (:, :, ikxkyz , isb ) end do end do end if ! field particle terms if ( fieldpart ) then idx1 = 1 ! first row (phi equation) do idx2 = 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 * nspec ! column indices isa = 1 + int (( idx2 - 1 ) / float (( jmax + 1 ) * ( lmax + 1 ) ** 2 )) ij = 1 + mod ( 1 + mod ( idx2 - 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 ) - 1 , jmax + 1 ) il = 1 + int ( sqrt ( 1.0 * ( 1 + mod ( idx2 - 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 ) - ij ) / ( jmax + 1 ))) im = 1 + ( 1 + mod ( idx2 - 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 ) - ij ) / ( jmax + 1 ) - ( il - 1 ) ** 2 ll = il - 1 mm = - ll + im - 1 jj = ij - 1 ! get psi response, dh/dpsi_{ikn}, need responses: ! dh/dpsi_aa, dh/dpsi_ab, ... ! dh/dpsi_bb, dh/dpsi_ba, ... ! jj=0, ll=0 term is zero because Delta_j&#94;l = 0 for jj=0, ll=0 ! optionally replace this term with density conserving term ! that ensures conservation of density of the test particle operator to machine precision when using non-uniform mu-grid if (( jj == 0 ) . and . ( ll == 0 ) . and . ( density_conservation_tp )) then gvmu = 0. ! get testpart_den response for kperp = 0, only need dh_isa / d testpart_den_isa ! since this includes all interspecies test-particle operators do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) if ( is /= isa ) cycle do iv = 1 , nvpa do imu = 1 , nmu ghrs ( nmu * ( iv - 1 ) + imu ) = - code_dt * modmw ( iv , imu , iz , is ) / modmwnorm ( iz ) end do end do call zgbtrs ( 'No transpose' , nvpa * nmu , nmu + 1 , nmu + 1 , 1 , cdiffmat_band (:,:, iky , ikx , iz , is ), 3 * ( nmu + 1 ) + 1 , ipiv (:, iky , ikx , iz , is ), ghrs , nvpa * nmu , info ) do ix = 1 , nvpa gvmu ( ix , :, ikxkyz ) = ghrs ( nmu * ( ix - 1 ) + 1 : nmu * ( ix - 1 ) + nmu ) end do end do ! get phi_isa(dh_is2a/dh_is1), phi_isa(dh_is2a/dh_is2) ... call get_fields_by_spec_idx ( isa , gvmu , field ) ! AVB: check - using by_spec_idx instead of by_spec_mod do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) fp_response ( idx1 , 2 + ( idx2 - 1 ) * nspec : 1 + idx2 * nspec , ikxkyz ) = - field ( iky , ikx , iz , it , :) end do else ! get the responses dh_is2a/dh_is1, dh_is2a/dh_is2, dh_is2a/dh_is3 ... call get_psi_response ( ll , mm , jj , isa , gvmu ) ! get phi_isa(dh_is2a/dh_is1), phi_isa(dh_is2a/dh_is2) ... call get_fields_by_spec_idx ( isa , gvmu , field ) ! AVB: check - using by_spec_idx instead of by_spec_mod do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) fp_response ( idx1 , 2 + ( idx2 - 1 ) * nspec : 1 + idx2 * nspec , ikxkyz ) = - field ( iky , ikx , iz , it , :) end do end if end do idx2 = 1 ! first column do idx1 = 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 * nspec ! row indices isa = 1 + int (( idx1 - 1 ) / float (( jmax + 1 ) * ( lmax + 1 ) ** 2 )) ij = 1 + mod ( 1 + mod ( idx1 - 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 ) - 1 , jmax + 1 ) il = 1 + int ( sqrt ( 1.0 * ( 1 + mod ( idx1 - 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 ) - ij ) / ( jmax + 1 ))) im = 1 + ( 1 + mod ( idx1 - 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 ) - ij ) / ( jmax + 1 ) - ( il - 1 ) ** 2 ll = il - 1 mm = - ll + im - 1 jj = ij - 1 ! get phi responses, dh_{isa}/dphi, dh_{isb}/dphi, dh_{isc}/dphi ... store in gvmu do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) do iv = 1 , nvpa do imu = 1 , nmu ghrs ( nmu * ( iv - 1 ) + imu ) = ztmax ( iv , is ) * maxwell_mu ( 1 , iz , imu , is ) * jm0 ( imu , iky , ikx , iz , is ) end do end do call zgbtrs ( 'No transpose' , nvpa * nmu , nmu + 1 , nmu + 1 , 1 , cdiffmat_band (:,:, iky , ikx , iz , is ), 3 * ( nmu + 1 ) + 1 , ipiv (:, iky , ikx , iz , is ), ghrs , nvpa * nmu , info ) do ix = 1 , nvpa gvmu ( ix , :, ikxkyz ) = ghrs ( nmu * ( ix - 1 ) + 1 : nmu * ( ix - 1 ) + nmu ) end do end do if (( jj == 0 ) . and . ( ll == 0 ) . and . ( density_conservation_tp )) then ! get C_testpart[isa,isa+isb+isc...][dh_a/dphi], store in field(:,:,:,:,isa) field = 0. call get_testpart_density ( isa , 0 , gvmu , field ) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) fp_response ( 2 + ( idx1 - 1 ) * nspec : 1 + idx1 * nspec , idx2 , ikxkyz ) = - field ( iky , ikx , iz , it , :) end do else ! get psi_{isa,isa}[dh_{isa}/dphi], psi_{isa,isb}[dh_{isb}/dphi], psi_{isa,isc}[dh_{isc}/dphi] ... call get_psi ( gvmu , field , isa , 0 , ll , mm , jj ) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) fp_response ( 2 + ( idx1 - 1 ) * nspec : 1 + idx1 * nspec , idx2 , ikxkyz ) = - field ( iky , ikx , iz , it , :) end do end if end do ! interior entries do idx1 = 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 * nspec ! row indices do idx2 = 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 * nspec ! column indices isa = 1 + int (( idx1 - 1 ) / float (( jmax + 1 ) * ( lmax + 1 ) ** 2 )) ij1 = 1 + mod ( 1 + mod ( idx1 - 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 ) - 1 , jmax + 1 ) il1 = 1 + int ( sqrt ( 1.0 * ( 1 + mod ( idx1 - 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 ) - ij1 ) / ( jmax + 1 ))) im1 = 1 + ( 1 + mod ( idx1 - 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 ) - ij1 ) / ( jmax + 1 ) - ( il1 - 1 ) ** 2 ll1 = il1 - 1 mm1 = - ll1 + im1 - 1 jj1 = ij1 - 1 isb = 1 + int (( idx2 - 1 ) / float (( jmax + 1 ) * ( lmax + 1 ) ** 2 )) ij2 = 1 + mod ( 1 + mod ( idx2 - 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 ) - 1 , jmax + 1 ) il2 = 1 + int ( sqrt ( 1.0 * ( 1 + mod ( idx2 - 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 ) - ij2 ) / ( jmax + 1 ))) im2 = 1 + ( 1 + mod ( idx2 - 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 ) - ij2 ) / ( jmax + 1 ) - ( il2 - 1 ) ** 2 ll2 = il2 - 1 mm2 = - ll2 + im2 - 1 jj2 = ij2 - 1 if (( jj2 == 0 ) . and . ( ll2 == 0 ) . and . ( density_conservation_tp )) then gvmu = 0. do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) if ( is /= isb ) cycle do iv = 1 , nvpa do imu = 1 , nmu ghrs ( nmu * ( iv - 1 ) + imu ) = - code_dt * modmw ( iv , imu , iz , is ) / modmwnorm ( iz ) end do end do call zgbtrs ( 'No transpose' , nvpa * nmu , nmu + 1 , nmu + 1 , 1 , cdiffmat_band (:,:, iky , ikx , iz , is ), 3 * ( nmu + 1 ) + 1 , ipiv (:, iky , ikx , iz , is ), ghrs , nvpa * nmu , info ) do ix = 1 , nvpa gvmu ( ix , :, ikxkyz ) = ghrs ( nmu * ( ix - 1 ) + 1 : nmu * ( ix - 1 ) + nmu ) end do end do else gvmu = 0. call get_psi_response ( ll2 , mm2 , jj2 , isb , gvmu ) end if if (( jj1 == 0 ) . and . ( ll1 == 0 ) . and . ( density_conservation_tp )) then ! get the fields C_testpart[isa,isa+isb+isc...][dh_a/dpsi&#94;ab], C_testpart[isa,isa+isb+isc...][dh_a/dpsi&#94;ac], C_testpart[isa,isa+isb+isc...][dh_a/dpsi&#94;ad] ... call get_testpart_density ( isa , isb , gvmu , field ) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) ! AVB: check - is index fp_response ( 2 + ( idx1 - 1 ) * nspec + ( isb - 1 ), 2 + ( idx2 - 1 ) * nspec : 1 + idx2 * nspec , ikxkyz ) = - field ( iky , ikx , iz , it , :) end do else ! get fields Q_(isa,isb)[dh_{is}/dpsi&#94;{is,isa}], Q_(isa,isb)[dh_{is}/dpsi&#94;{is,isa}], ... call get_psi ( gvmu , field , isa , isb , ll1 , mm1 , jj1 ) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) ! AVB: check - is index fp_response ( 2 + ( idx1 - 1 ) * nspec + ( isb - 1 ), 2 + ( idx2 - 1 ) * nspec : 1 + idx2 * nspec , ikxkyz ) = - field ( iky , ikx , iz , it , :) end do end if end do end do ! add 1 to diagonal do idx1 = 2 , 1 + ( jmax + 1 ) * ( lmax + 1 ) ** 2 * nspec ** 2 fp_response ( idx1 , idx1 , :) = fp_response ( idx1 , idx1 , :) + 1 end do end if ! save response matrix, to examine contents !do ikxkyz = kxkyz_lo%llim_proc, kxkyz_lo%ulim_proc ! iky = iky_idx(kxkyz_lo,ikxkyz) ! ikx = ikx_idx(kxkyz_lo,ikxkyz) ! iz  = iz_idx(kxkyz_lo,ikxkyz) ! is  = is_idx(kxkyz_lo,ikxkyz) !it  = it_idx(kxkyz_lo,ikxkyz) !if ((iky==naky).and.(is==1).and.(iz==0)) then !     call open_output_file (tmpunit,'.fp_response') !      do idx1 = 1, nresponse !          write(tmpunit,*) (real(fp_response(idx1,idx2,ikxkyz)), idx2 = 1,nresponse) ! (12es15.4e3) !      end do !      write (tmpunit,*) !      call close_output_file (tmpunit) !  end if !end do ! LU decomposition for response do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc call lu_decomposition ( fp_response (:, :, ikxkyz ), diff_idx (:, ikxkyz ), dum2 ) end do conservative_wgts = . false . call set_vpa_weights ( conservative_wgts ) deallocate ( dum1 , dum3 , field ) end subroutine init_fp_conserve subroutine get_psi_response ( ll , mm , jj , isa , response ) ! solve for responses dh_a / dpsi&#94;{aa}, dh_a / dpsi&#94;{ab}, dh_a / dpsi&#94;{ac} ... for all species b, c, ... use finite_differences , only : tridag use linear_solve , only : lu_decomposition use stella_time , only : code_dt use species , only : nspec , spec use zgrid , only : ntubes use vpamu_grids , only : nmu , nvpa use vpamu_grids , only : set_vpa_weights use kt_grids , only : naky , nakx use stella_layouts , only : kxkyz_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , is_idx , it_idx use fields , only : get_fields , get_fields_by_spec use job_manage , only : time_message , timer_local use constants , only : pi use file_utils , only : open_output_file , close_output_file implicit none complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( out ) :: response integer , intent ( in ) :: ll , mm , jj , isa complex , dimension (:), allocatable :: ghrs integer :: ikxkyz , iky , ikx , iz , is , ia , iv , imu real :: clm allocate ( ghrs ( nmu * nvpa )) ia = 1 clm = sqrt ((( 2 * ll + 1 ) * gamma ( ll - mm + 1. )) / ( 4 * pi * gamma ( ll + mm + 1. ))) ! calculate response dh/dpsi_jlm, for unit impulse to psi_jlm do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) ! isb ! supply unit impulse to psi_j&#94;(lm)&#94;{isa,isb} do iv = 1 , nvpa do imu = 1 , nmu if ( mm == 0 ) then ghrs ( nmu * ( iv - 1 ) + imu ) = code_dt * spec ( isa )% vnew ( is ) * clm * legendre_vpamu ( ll , mm , iv , imu , iz ) & * jm ( imu , mm , iky , ikx , iz , isa ) * ( spec ( isa )% mass / spec ( is )% mass ) ** ( - 1.5 ) * deltaj ( ll , jj , isa , is , iv , imu , ia , iz ) else if ( mm > 0 ) then ghrs ( nmu * ( iv - 1 ) + imu ) = code_dt * spec ( isa )% vnew ( is ) * clm * legendre_vpamu ( ll , mm , iv , imu , iz ) & * jm ( imu , mm , iky , ikx , iz , isa ) * ( spec ( isa )% mass / spec ( is )% mass ) ** ( - 1.5 ) * deltaj ( ll , jj , isa , is , iv , imu , ia , iz ) else if ( mm < 0 ) then ghrs ( nmu * ( iv - 1 ) + imu ) = ( - 1 ) ** mm * code_dt * spec ( isa )% vnew ( is ) * clm * legendre_vpamu ( ll , mm , iv , imu , iz ) & * jm ( imu , abs ( mm ), iky , ikx , iz , isa ) * ( spec ( isa )% mass / spec ( is )% mass ) ** ( - 1.5 ) * deltaj ( ll , jj , isa , is , iv , imu , ia , iz ) end if end do end do ! solve for response ! need to solve [1 - Deltat C_{test}] dh_a/dpsi&#94;ab = delta_{ab} for dh_a/dpsi&#94;ab. Here, C_{test} includes self collisions and a-b collisions, call zgbtrs ( 'No transpose' , nvpa * nmu , nmu + 1 , nmu + 1 , 1 , & cdiffmat_band (:, :, iky , ikx , iz , isa ), 3 * ( nmu + 1 ) + 1 , ipiv (:, iky , ikx , iz , isa ), ghrs , nvpa * nmu , info ) do iv = 1 , nvpa response ( iv , :, ikxkyz ) = ghrs ( nmu * ( iv - 1 ) + 1 : nmu * ( iv - 1 ) + nmu ) end do ! to zero l=1,j=1 term: if ( no_j1l1 ) then if (( ll == 1 ) . and . ( jj == 1 )) then response (:, :, ikxkyz ) = 0. end if end if if ( no_j1l2 ) then if (( ll == 2 ) . and . ( jj == 1 )) then response (:, :, ikxkyz ) = 0. end if end if if ( no_j0l2 ) then if (( ll == 2 ) . and . ( jj == 0 )) then response (:, :, ikxkyz ) = 0. end if end if if ( spitzer_problem ) then if (. not . (( isa == 2 ) . and . ( is == 2 ))) then response (:, :, ikxkyz ) = 0. end if end if end do deallocate ( ghrs ) end subroutine get_psi_response subroutine get_psi ( g , fld , isa , isb , ll , mm , jj ) ! if isb==0: ! get the fields psi_aa&#94;lmj(g_a), psi_ab&#94;lmj(g_b), psi_ac&#94;lmj(g_c) ..., for species b, c, ... ! if isb/=0, fix the species indices of the operator psi_ab, ie ! get the fields psi_ab&#94;lmj(g_a), psi_ab&#94;lmj(g_b), psi_ab&#94;lmj(g_c) ... use mp , only : sum_allreduce use zgrid , only : nzgrid use vpamu_grids , only : integrate_vmu , set_vpa_weights , nvpa , nmu , vpa use stella_layouts , only : kxkyz_lo , iky_idx , ikx_idx , iz_idx , it_idx , is_idx use constants , only : pi use species , only : spec , nspec use file_utils , only : open_output_file , close_output_file use stella_time , only : code_dt implicit none complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :, :), intent ( out ) :: fld integer , intent ( in ) :: isa , isb , ll , mm , jj integer :: ikxkyz , iky , ikx , iz , it , is , ia , iv , ikxkyz_isb , is_b , iky_b , ikx_b , iz_b , it_b complex , dimension (:, :), allocatable :: g0 complex , dimension (:), allocatable :: ghrs real :: clm logical :: conservative_wgts allocate ( g0 ( nvpa , nmu )) allocate ( ghrs ( nmu * nvpa )) if ( density_conservation ) then conservative_wgts = . true . call set_vpa_weights ( conservative_wgts ) else conservative_wgts = . false . call set_vpa_weights ( conservative_wgts ) end if clm = ( - 1 ) ** mm * sqrt ((( 2 * ll + 1 ) * gamma ( ll + mm + 1. )) / ( 4 * pi * gamma ( ll - mm + 1. ))) ia = 1 if ( isb == 0 ) then do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) if ( mm == 0 ) then if (( exact_conservation ) . and . ((( ll == 0 ) . and . ( jj == 1 )) . or . (( ll == 1 ) . and . ( jj == 0 )))) then g0 = clm * g (:,:, ikxkyz ) / mw (:,:, iz , is ) * spread ( jm (:, - mm , iky , ikx , iz , is ), 1 , nvpa ) * legendre_vpamu ( ll , - mm ,:,:, iz ) * deltaj_tp ( ll , jj , is , isa ,:,:, ia , iz ) else if (( exact_conservation_tp ) . and . (( ll == 1 ) . and . ( jj == 0 ))) then do iv = 1 , nvpa ghrs ( nmu * ( iv - 1 ) + 1 : nmu * iv ) = clm * ( spec ( is )% mass / spec ( isa )% mass ) ** 2 * jm (:, - mm , iky , ikx , iz , is ) * g ( iv , :, ikxkyz ) end do ghrs = matmul ( - blockmatrix (:, :, ikxkyz , isa ) / code_dt / spec ( is )% vnew ( isa ), ghrs ) do iv = 1 , nvpa g0 ( iv , :) = - vpa ( iv ) * ghrs ( nmu * ( iv - 1 ) + 1 : nmu * iv ) end do if ( spec ( is )% vnew ( isa ) == 0 ) then g0 = 0. end if else if (( exact_conservation_tp ) . and . (( ll == 0 ) . and . ( jj == 1 ))) then do iv = 1 , nvpa ghrs ( nmu * ( iv - 1 ) + 1 : nmu * iv ) = clm * ( spec ( is )% mass / spec ( isa )% mass ) ** 1.5 * jm (:, - mm , iky , ikx , iz , is ) * g ( iv , :, ikxkyz ) end do ghrs = matmul ( - blockmatrix (:, :, ikxkyz , isa ) / code_dt / spec ( is )% vnew ( isa ), ghrs ) do iv = 1 , nvpa g0 ( iv , :) = velvpamu ( iv , :, iz ) ** 2 * ghrs ( nmu * ( iv - 1 ) + 1 : nmu * iv ) end do if ( spec ( is )% vnew ( isa ) == 0 ) then g0 = 0. end if else g0 = clm * g (:,:, ikxkyz ) / mw (:,:, iz , is ) * spread ( jm (:, - mm , iky , ikx , iz , is ), 1 , nvpa ) * legendre_vpamu ( ll , - mm ,:,:, iz ) * deltaj ( ll , jj , is , isa ,:,:, ia , iz ) end if else if ( mm < 0 ) then if (( exact_conservation ) . and . ((( ll == 0 ) . and . ( jj == 1 )) . or . (( ll == 1 ) . and . ( jj == 0 )))) then g0 = ( - 1 ) ** mm * clm * g (:, :, ikxkyz ) / mw (:, :, iz , is ) * spread ( jm (:, abs ( mm ), iky , ikx , iz , is ), 1 , nvpa ) & * legendre_vpamu ( ll , - mm , :, :, iz ) * deltaj_tp ( ll , jj , is , isa , :, :, ia , iz ) else g0 = ( - 1 ) ** mm * clm * g (:, :, ikxkyz ) / mw (:, :, iz , is ) * spread ( jm (:, abs ( mm ), iky , ikx , iz , is ), 1 , nvpa ) & * legendre_vpamu ( ll , - mm , :, :, iz ) * deltaj ( ll , jj , is , isa , :, :, ia , iz ) end if else if ( mm > 0 ) then if (( exact_conservation ) . and . ((( ll == 0 ) . and . ( jj == 1 )) . or . (( ll == 1 ) . and . ( jj == 0 )))) then g0 = clm * g (:, :, ikxkyz ) / mw (:, :, iz , is ) * spread ( jm (:, mm , iky , ikx , iz , is ), 1 , nvpa ) & * legendre_vpamu ( ll , - mm , :, :, iz ) * deltaj_tp ( ll , jj , is , isa , :, :, ia , iz ) else g0 = clm * g (:, :, ikxkyz ) / mw (:, :, iz , is ) * spread ( jm (:, mm , iky , ikx , iz , is ), 1 , nvpa ) & * legendre_vpamu ( ll , - mm , :, :, iz ) * deltaj ( ll , jj , is , isa , :, :, ia , iz ) end if end if call integrate_vmu ( g0 , iz , fld ( iky , ikx , iz , it , is )) ! to zero l=1,j=1 term: if ( no_j1l1 ) then if (( ll == 1 ) . and . ( jj == 1 )) then fld (:, :, :, :, is ) = 0. end if end if if ( no_j1l2 ) then if (( ll == 2 ) . and . ( jj == 1 )) then fld (:, :, :, :, is ) = 0. end if end if if ( no_j0l2 ) then if (( ll == 2 ) . and . ( jj == 0 )) then fld (:, :, :, :, is ) = 0. end if end if if ( spitzer_problem ) then if (. not . (( isa == 2 ) . and . ( is == 2 ))) then fld (:, :, :, :, is ) = 0. end if end if end do else ! isb /= 0: ! apply the operator \\psi_ab&#94;jlm[] to every species index of g; only used in the calculation of the response matrix ! where the species index, is, of g contains the response \\delta h_a / \\delta \\psi&#94;{a,is} do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) if ( mm == 0 ) then if (( exact_conservation ) . and . ((( ll == 0 ) . and . ( jj == 1 )) . or . (( ll == 1 ) . and . ( jj == 0 )))) then g0 = clm * g (:, :, ikxkyz ) / mw (:, :, iz , is ) * spread ( jm (:, mm , iky , ikx , iz , isb ), 1 , nvpa ) & * legendre_vpamu ( ll , - mm , :, :, iz ) * deltaj_tp ( ll , jj , isb , isa , :, :, ia , iz ) else if (( exact_conservation_tp ) . and . (( ll == 1 ) . and . ( jj == 0 ))) then do iv = 1 , nvpa ghrs ( nmu * ( iv - 1 ) + 1 : nmu * iv ) = clm * ( spec ( isb )% mass / spec ( isa )% mass ) ** 2 & * jm (:, mm , iky , ikx , iz , isb ) * g ( iv , :, ikxkyz ) end do do ikxkyz_isb = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc is_b = is_idx ( kxkyz_lo , ikxkyz_isb ) iky_b = iky_idx ( kxkyz_lo , ikxkyz_isb ) ikx_b = ikx_idx ( kxkyz_lo , ikxkyz_isb ) iz_b = iz_idx ( kxkyz_lo , ikxkyz_isb ) it_b = it_idx ( kxkyz_lo , ikxkyz_isb ) if (( is_b /= isb ) . or . ( iky_b /= iky ) . or . ( ikx_b /= ikx ) . or . ( iz_b /= iz ) . or . ( it_b /= it )) cycle ghrs = matmul ( - blockmatrix (:, :, ikxkyz_isb , isa ) / code_dt / spec ( isb )% vnew ( isa ), ghrs ) end do do iv = 1 , nvpa g0 ( iv , :) = - vpa ( iv ) * ghrs ( nmu * ( iv - 1 ) + 1 : nmu * iv ) end do if ( spec ( isb )% vnew ( isa ) == 0 ) then g0 = 0. end if else if (( exact_conservation_tp ) . and . (( ll == 0 ) . and . ( jj == 1 ))) then do iv = 1 , nvpa ghrs ( nmu * ( iv - 1 ) + 1 : nmu * iv ) = clm * ( spec ( isb )% mass / spec ( isa )% mass ) ** 1.5 & * jm (:, mm , iky , ikx , iz , isb ) * g ( iv , :, ikxkyz ) end do do ikxkyz_isb = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc is_b = is_idx ( kxkyz_lo , ikxkyz_isb ) iky_b = iky_idx ( kxkyz_lo , ikxkyz_isb ) ikx_b = ikx_idx ( kxkyz_lo , ikxkyz_isb ) iz_b = iz_idx ( kxkyz_lo , ikxkyz_isb ) it_b = it_idx ( kxkyz_lo , ikxkyz_isb ) if (( is_b /= isb ) . or . ( iky_b /= iky ) . or . ( ikx_b /= ikx ) . or . ( iz_b /= iz ) . or . ( it_b /= it )) cycle ghrs = matmul ( - blockmatrix (:, :, ikxkyz_isb , isa ) / code_dt / spec ( isb )% vnew ( isa ), ghrs ) end do do iv = 1 , nvpa g0 ( iv , :) = velvpamu ( iv , :, iz ) ** 2 * ghrs ( nmu * ( iv - 1 ) + 1 : nmu * iv ) end do if ( spec ( isb )% vnew ( isa ) == 0 ) then g0 = 0. end if else g0 = clm * g (:, :, ikxkyz ) / mw (:, :, iz , is ) * spread ( jm (:, mm , iky , ikx , iz , isb ), 1 , nvpa ) & * legendre_vpamu ( ll , - mm , :, :, iz ) * deltaj ( ll , jj , isb , isa , :, :, ia , iz ) end if else if ( mm < 0 ) then if (( exact_conservation ) . and . ((( ll == 0 ) . and . ( jj == 1 )) . or . (( ll == 1 ) . and . ( jj == 0 )))) then g0 = ( - 1 ) ** mm * clm * g (:, :, ikxkyz ) / mw (:, :, iz , is ) * spread ( jm (:, abs ( mm ), iky , ikx , iz , isb ), 1 , nvpa ) & * legendre_vpamu ( ll , - mm , :, :, iz ) * deltaj_tp ( ll , jj , isb , isa , :, :, ia , iz ) else g0 = ( - 1 ) ** mm * clm * g (:, :, ikxkyz ) / mw (:, :, iz , is ) * spread ( jm (:, abs ( mm ), iky , ikx , iz , isb ), 1 , nvpa ) & * legendre_vpamu ( ll , - mm , :, :, iz ) * deltaj ( ll , jj , isb , isa , :, :, ia , iz ) end if else if ( mm > 0 ) then if (( exact_conservation ) . and . ((( ll == 0 ) . and . ( jj == 1 )) . or . (( ll == 1 ) . and . ( jj == 0 )))) then g0 = clm * g (:, :, ikxkyz ) / mw (:, :, iz , is ) * spread ( jm (:, mm , iky , ikx , iz , isb ), 1 , nvpa ) & * legendre_vpamu ( ll , - mm , :, :, iz ) * deltaj_tp ( ll , jj , isb , isa , :, :, ia , iz ) else g0 = clm * g (:, :, ikxkyz ) / mw (:, :, iz , is ) * spread ( jm (:, mm , iky , ikx , iz , isb ), 1 , nvpa ) & * legendre_vpamu ( ll , - mm , :, :, iz ) * deltaj ( ll , jj , isb , isa , :, :, ia , iz ) end if end if call integrate_vmu ( g0 , iz , fld ( iky , ikx , iz , it , is )) ! to zero l=1,j=1 term: if ( no_j1l1 ) then if (( ll == 1 ) . and . ( jj == 1 )) then fld (:, :, :, :, is ) = 0. end if end if if ( no_j1l2 ) then if (( ll == 2 ) . and . ( jj == 1 )) then fld (:, :, :, :, is ) = 0. end if end if if ( no_j0l2 ) then if (( ll == 2 ) . and . ( jj == 0 )) then fld (:, :, :, :, is ) = 0. end if end if if ( spitzer_problem ) then if (. not . (( isa == 2 ) . and . ( isb == 2 ))) then fld (:, :, :, :, is ) = 0. end if end if end do end if ! normalise psijs if ( isb == 0 ) then do is = 1 , nspec do iz = - nzgrid , nzgrid fld (:, :, iz , :, is ) = fld (:, :, iz , :, is ) / psijnorm ( ll , jj , isa , is , iz ) end do end do else do iz = - nzgrid , nzgrid fld (:, :, iz , :, :) = fld (:, :, iz , :, :) / psijnorm ( ll , jj , isa , isb , iz ) end do end if deallocate ( g0 ) deallocate ( ghrs ) conservative_wgts = . false . call set_vpa_weights ( conservative_wgts ) call sum_allreduce ( fld ) end subroutine get_psi subroutine finish_collisions_fp implicit none call finish_nusDpa call finish_fp_diffmatrix call finish_fp_response call finish_deltaj fp_initialized = . false . end subroutine finish_collisions_fp subroutine finish_deltaj implicit none if ( allocated ( deltaj )) deallocate ( deltaj ) if ( allocated ( psijnorm )) deallocate ( psijnorm ) if ( allocated ( mwnorm )) deallocate ( mwnorm ) end subroutine finish_deltaj subroutine finish_fp_diffmatrix implicit none if ( allocated ( aa_vpa )) deallocate ( aa_vpa ) if ( allocated ( bb_vpa )) deallocate ( bb_vpa ) if ( allocated ( cc_vpa )) deallocate ( cc_vpa ) if ( allocated ( aa_blcs )) deallocate ( aa_blcs ) if ( allocated ( bb_blcs )) deallocate ( bb_blcs ) if ( allocated ( cc_blcs )) deallocate ( cc_blcs ) if ( allocated ( cdiffmat_band )) deallocate ( cdiffmat_band ) if ( allocated ( blockmatrix )) deallocate ( blockmatrix ) if ( allocated ( blockmatrix_sum )) deallocate ( blockmatrix_sum ) end subroutine finish_fp_diffmatrix subroutine finish_fp_response implicit none if ( allocated ( fp_response )) deallocate ( fp_response ) if ( allocated ( diff_idx )) deallocate ( diff_idx ) end subroutine finish_fp_response subroutine advance_collisions_fp_explicit ( g , phi , bpar , gke_rhs , time_collisions ) use mp , only : proc0 , mp_abort use job_manage , only : time_message use redistribute , only : scatter , gather use stella_time , only : code_dt use zgrid , only : nzgrid , ntubes use run_parameters , only : fphi use physics_flags , only : full_flux_surface use kt_grids , only : naky , nakx use vpamu_grids , only : nvpa , nmu use vpamu_grids , only : set_vpa_weights use stella_layouts , only : vmu_lo , kxkyz_lo use stella_layouts , only : is_idx , iky_idx , ikx_idx , iz_idx use dist_redistribute , only : kxkyz2vmu use dist_fn_arrays , only : gvmu use g_tofrom_h , only : g_to_h implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: phi , bpar complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: gke_rhs real , dimension (:, :), intent ( in out ) :: time_collisions integer :: is , ikxkyz , imu , iv , ivmu , ikx , iky , iz , ia logical :: conservative_wgts complex , dimension (:, :, :, :, :), allocatable :: tmp_vmulo complex , dimension (:, :, :), allocatable :: mucoll_fp complex , dimension (:, :, :), allocatable :: coll_fp ia = 1 if ( full_flux_surface ) then call mp_abort ( \"collisions not currently supported for full_flux_surface=T.  Aborting.\" ) end if if ( proc0 ) call time_message (. false ., time_collisions (:, 1 ), ' collisions' ) allocate ( tmp_vmulo ( naky , nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) ! want exact conservation properties for collision operator conservative_wgts = . true . call set_vpa_weights ( conservative_wgts ) ! switch from g = <f> to h = f + Z*e*phi/T * F0 tmp_vmulo = g call g_to_h ( tmp_vmulo , phi , bpar , fphi ) ! remap so that (vpa,mu) local if ( proc0 ) call time_message (. false ., time_collisions (:, 2 ), ' coll_redist' ) call scatter ( kxkyz2vmu , tmp_vmulo , gvmu ) if ( proc0 ) call time_message (. false ., time_collisions (:, 2 ), ' coll_redist' ) ia = 1 ! take vpa derivatives allocate ( coll_fp ( nvpa , nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )); coll_fp = 0.0 allocate ( mucoll_fp ( nvpa , nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )); mucoll_fp = 0.0 if ( density_conservation ) then do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) if ( vpa_operator ) then do imu = 1 , nmu call vpa_differential_operator_fp_conservative ( gvmu (:, :, ikxkyz ), coll_fp (:, :, ikxkyz ), imu , iz , is , ia ) end do end if if ( mu_operator ) then do iv = 1 , nvpa call mu_differential_operator_fp_conservative ( gvmu (:, :, ikxkyz ), mucoll_fp (:, :, ikxkyz ), iv , iz , is , ia , iky , ikx , cfac ) end do end if gvmu (:, :, ikxkyz ) = coll_fp (:, :, ikxkyz ) + mucoll_fp (:, :, ikxkyz ) end do else do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) if ( vpa_operator ) then do imu = 1 , nmu call vpa_differential_operator_fp ( gvmu (:, :, ikxkyz ), coll_fp (:, :, ikxkyz ), imu , iz , is , ia ) end do end if if ( mu_operator ) then do iv = 1 , nvpa call mu_differential_operator_fp ( gvmu (:, :, ikxkyz ), mucoll_fp (:, :, ikxkyz ), iv , iz , is , ia , iky , ikx , cfac ) end do end if gvmu (:, :, ikxkyz ) = coll_fp (:, :, ikxkyz ) + mucoll_fp (:, :, ikxkyz ) end do end if deallocate ( coll_fp , mucoll_fp ) call gather ( kxkyz2vmu , gvmu , tmp_vmulo ) do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc gke_rhs (:, :, :, :, ivmu ) = gke_rhs (:, :, :, :, ivmu ) + code_dt * tmp_vmulo (:, :, :, :, ivmu ) end do deallocate ( tmp_vmulo ) ! reset to default integration wgts conservative_wgts = . false . call set_vpa_weights ( conservative_wgts ) if ( proc0 ) call time_message (. false ., time_collisions (:, 1 ), ' collisions' ) end subroutine advance_collisions_fp_explicit subroutine vpa_differential_operator_fp ( h , Dh , imu , iz , is , ia ) use vpamu_grids , only : nvpa , vpa , dvpa , mu , dmu , nmu , equally_spaced_mu_grid , maxwell_mu use stella_geometry , only : bmag use constants , only : pi use species , only : spec implicit none complex , dimension (:, :), intent ( out ) :: Dh complex , dimension (:, :), intent ( in ) :: h integer , intent ( in ) :: imu , iz , ia , is integer :: iv complex :: dmuhp , dmuhm , dvpahp , dvpahm real :: xp , xm , vpap , vpam , nupap , nupam , nuDp , nuDm , mwp , mwm iv = 1 vpap = 0.5 * ( vpa ( iv ) + vpa ( iv + 1 )) xp = sqrt ( vpap ** 2 + 2 * bmag ( ia , iz ) * mu ( imu )) nuDp = spec ( is )% vnew ( is ) * ( erf ( xp ) - ( erf ( xp ) - xp * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 )) / ( 2 * xp ** 2 )) / xp ** 3 nupap = spec ( is )% vnew ( is ) * 2 * ( erf ( xp ) - xp * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 )) / ( 2 * xp ** 2 ) / xp ** 3 mwp = exp ( - vpap ** 2 ) * maxwell_mu ( 1 , iz , imu , is ) dvpahp = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv , imu ) / mw ( iv , imu , iz , is )) / dvpa if ( imu == 1 ) then ! second-order accurate !a = -(2.*dmu(1) + dmu(2))/(dmu(1)*(dmu(1)+dmu(2))) !b = (dmu(1)+dmu(2))/(dmu(1)*dmu(2)) !c = -dmu(1)/(dmu(2)*(dmu(1)+dmu(2))) !dmuhp = a*h(iv+1,imu)/mw(iv+1,imu,iz,is)+ b*h(iv+1,imu+1)/mw(iv+1,imu+1,iz,is) + c*h(iv+1,imu+2)/mw(iv+1,imu+2,iz) ! first-order accurate, as in implicit routine: dmuhp = ( h ( iv + 1 , imu + 1 ) / mw ( iv + 1 , imu + 1 , iz , is ) - h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is )) / dmu ( imu ) else if ( imu == nmu ) then ! second-order accurate !a = dmu(nmu-1)/(dmu(nmu-2)*(dmu(nmu-2)+dmu(nmu-1))) !b = -(dmu(nmu-1)+dmu(nmu-2))/(dmu(nmu-2)*dmu(nmu-1)) !c = (2.*dmu(nmu-1)+dmu(nmu-2))/(dmu(nmu-1)*(dmu(nmu-1)+dmu(nmu-2))) !dmuhp = a*h(iv+1,imu-2)/mw(iv+1,imu-2,iz) + b*h(iv+1,imu-1)/mw(iv+1,imu-1,iz,is) + c*h(iv+1,imu)/mw(iv+1,imu,iz,is) ! first-order accurate, as in implicit routine: dmuhp = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv + 1 , imu - 1 ) / mw ( iv + 1 , imu - 1 , iz , is )) / dmu ( imu - 1 ) else dmuhp = (( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv + 1 , imu - 1 ) / mw ( iv + 1 , imu - 1 , iz , is )) * dmu ( imu ) / dmu ( imu - 1 ) & + ( h ( iv + 1 , imu + 1 ) / mw ( iv + 1 , imu + 1 , iz , is ) - h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is )) * dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) end if Dh ( iv , imu ) = ( 2 * 0.5 * ( nupap * vpap ** 2 + 2 * nuDp * bmag ( ia , iz ) * mu ( imu )) * mwp * dvpahp + vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , is ) * mw ( iv + 1 , imu , iz , is ) * dmuhp ) / ( 2 * dvpa ) iv = nvpa vpam = 0.5 * ( vpa ( iv ) + vpa ( iv - 1 )) xm = sqrt ( vpam ** 2 + 2 * bmag ( ia , iz ) * mu ( imu )) nuDm = spec ( is )% vnew ( is ) * ( erf ( xm ) - ( erf ( xm ) - xm * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 )) / ( 2 * xm ** 2 )) / xm ** 3 nupam = spec ( is )% vnew ( is ) * 2 * ( erf ( xm ) - xm * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 )) / ( 2 * xm ** 2 ) / xm ** 3 mwm = exp ( - vpam ** 2 ) * maxwell_mu ( 1 , iz , imu , is ) dvpahm = ( h ( iv , imu ) / mw ( iv , imu , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / dvpa if ( imu == 1 ) then ! second-order accurate !a = -(2.*dmu(1) + dmu(2))/(dmu(1)*(dmu(1)+dmu(2))) !b = (dmu(1)+dmu(2))/(dmu(1)*dmu(2)) !c = -dmu(1)/(dmu(2)*(dmu(1)+dmu(2))) !dmuhm = a*h(iv-1,imu)/mw(iv-1,imu,iz,is) + b*h(iv-1,imu+1)/mw(iv-1,imu+1,iz,is) + c*h(iv-1,imu+2)/mw(iv-1,imu+2,iz) ! first-order accurate, as in implicit routine: dmuhm = ( h ( iv - 1 , imu + 1 ) / mw ( iv - 1 , imu + 1 , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / dmu ( imu ) else if ( imu == nmu ) then ! second-order accurate !a = dmu(nmu-1)/(dmu(nmu-2)*(dmu(nmu-2)+dmu(nmu-1))) !b = -(dmu(nmu-1)+dmu(nmu-2))/(dmu(nmu-2)*dmu(nmu-1)) !c = (2.*dmu(nmu-1)+dmu(nmu-2))/(dmu(nmu-1)*(dmu(nmu-1)+dmu(nmu-2))) !dmuhm = a*h(iv-1,imu-2)/mw(iv-1,imu-2,iz) + b*h(iv-1,imu-1)/mw(iv-1,imu-1,iz,is) + c*h(iv-1,imu)/mw(iv-1,imu,iz,is) ! first-order accurate, as in implicit routine: dmuhm = ( h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is ) - h ( iv - 1 , imu - 1 ) / mw ( iv - 1 , imu - 1 , iz , is )) / dmu ( imu - 1 ) else dmuhm = (( h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is ) - h ( iv - 1 , imu - 1 ) / mw ( iv - 1 , imu - 1 , iz , is )) * dmu ( imu ) / dmu ( imu - 1 ) & + ( h ( iv - 1 , imu + 1 ) / mw ( iv - 1 , imu + 1 , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) * dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) end if Dh ( iv , imu ) = ( - 2 * 0.5 * ( nupam * vpam ** 2 + 2 * nuDm * bmag ( ia , iz ) * mu ( imu )) * mwm * dvpahm - vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , is ) * mw ( iv - 1 , imu , iz , is ) * dmuhm ) / ( 2 * dvpa ) do iv = 2 , nvpa - 1 ! AVB: interior nodes: ! quantities at half-grid-points: vpap = 0.5 * ( vpa ( iv ) + vpa ( iv + 1 )) vpam = 0.5 * ( vpa ( iv ) + vpa ( iv - 1 )) xp = sqrt ( vpap ** 2 + 2 * bmag ( ia , iz ) * mu ( imu )) xm = sqrt ( vpam ** 2 + 2 * bmag ( ia , iz ) * mu ( imu )) nuDp = spec ( is )% vnew ( is ) * ( erf ( xp ) - ( erf ( xp ) - xp * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 )) / ( 2 * xp ** 2 )) / xp ** 3 nuDm = spec ( is )% vnew ( is ) * ( erf ( xm ) - ( erf ( xm ) - xm * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 )) / ( 2 * xm ** 2 )) / xm ** 3 nupap = spec ( is )% vnew ( is ) * 2 * ( erf ( xp ) - xp * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 )) / ( 2 * xp ** 2 ) / xp ** 3 nupam = spec ( is )% vnew ( is ) * 2 * ( erf ( xm ) - xm * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 )) / ( 2 * xm ** 2 ) / xm ** 3 mwp = exp ( - vpap ** 2 ) * maxwell_mu ( 1 , iz , imu , is ) mwm = exp ( - vpam ** 2 ) * maxwell_mu ( 1 , iz , imu , is ) dvpahp = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv , imu ) / mw ( iv , imu , iz , is )) / dvpa dvpahm = ( h ( iv , imu ) / mw ( iv , imu , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / dvpa if ( imu == 1 ) then ! second-order accurate: !a = -(2.*dmu(1) + dmu(2))/(dmu(1)*(dmu(1)+dmu(2))) !b = (dmu(1)+dmu(2))/(dmu(1)*dmu(2)) !c = -dmu(1)/(dmu(2)*(dmu(1)+dmu(2))) !dmuhp = a*h(iv+1,imu)/mw(iv+1,imu,iz,is) + b*h(iv+1,imu+1)/mw(iv+1,imu+1,iz,is) + c*h(iv+1,imu+2)/mw(iv+1,imu+2,iz) !dmuhm = a*h(iv-1,imu)/mw(iv-1,imu,iz,is) + b*h(iv-1,imu+1)/mw(iv-1,imu+1,iz,is) + c*h(iv-1,imu+2)/mw(iv-1,imu+2,iz) ! or first-order accurate, as in implicit routine: dmuhp = ( h ( iv + 1 , imu + 1 ) / mw ( iv + 1 , imu + 1 , iz , is ) - h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is )) / dmu ( imu ) dmuhm = ( h ( iv - 1 , imu + 1 ) / mw ( iv - 1 , imu + 1 , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / dmu ( imu ) else if ( imu == nmu ) then ! second-order accurate: !a = dmu(nmu-1)/(dmu(nmu-2)*(dmu(nmu-2)+dmu(nmu-1))) !b = -(dmu(nmu-1)+dmu(nmu-2))/(dmu(nmu-2)*dmu(nmu-1)) !c = (2.*dmu(nmu-1)+dmu(nmu-2))/(dmu(nmu-1)*(dmu(nmu-1)+dmu(nmu-2))) !dmuhp = a*h(iv+1,imu-2)/mw(iv+1,imu-2,iz) + b*h(iv+1,imu-1)/mw(iv+1,imu-1,iz,is) + c*h(iv+1,imu)/mw(iv+1,imu,iz,is) !dmuhm = a*h(iv-1,imu-2)/mw(iv-1,imu-2,iz) + b*h(iv-1,imu-1)/mw(iv-1,imu-1,iz,is) + c*h(iv-1,imu)/mw(iv-1,imu,iz,is) ! or first-order accurate, as in implicit routine: dmuhp = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv + 1 , imu - 1 ) / mw ( iv + 1 , imu - 1 , iz , is )) / dmu ( imu - 1 ) dmuhm = ( h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is ) - h ( iv - 1 , imu - 1 ) / mw ( iv - 1 , imu - 1 , iz , is )) / dmu ( imu - 1 ) else dmuhp = (( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv + 1 , imu - 1 ) / mw ( iv + 1 , imu - 1 , iz , is )) * dmu ( imu ) / dmu ( imu - 1 ) & + ( h ( iv + 1 , imu + 1 ) / mw ( iv + 1 , imu + 1 , iz , is ) - h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is )) * dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) dmuhm = (( h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is ) - h ( iv - 1 , imu - 1 ) / mw ( iv - 1 , imu - 1 , iz , is )) * dmu ( imu ) / dmu ( imu - 1 ) & + ( h ( iv - 1 , imu + 1 ) / mw ( iv - 1 , imu + 1 , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) * dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) end if Dh ( iv , imu ) = ( 2 * 0.5 * ( nupap * vpap ** 2 + 2 * nuDp * bmag ( ia , iz ) * mu ( imu )) * mwp * dvpahp & + vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , is ) * mw ( iv + 1 , imu , iz , is ) * dmuhp & - 2 * 0.5 * ( nupam * vpam ** 2 + 2 * nuDm * bmag ( ia , iz ) * mu ( imu )) * mwm * dvpahm & - vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , is ) * mw ( iv - 1 , imu , iz , is ) * dmuhm ) / ( 2 * dvpa ) end do end subroutine vpa_differential_operator_fp subroutine mu_differential_operator_fp ( h , Dh , iv , iz , is , ia , iky , ikx , cfac ) use vpamu_grids , only : nmu , mu , dmu , vpa , dvpa , nvpa , maxwell_vpa , equally_spaced_mu_grid use stella_geometry , only : bmag use species , only : spec use dist_fn_arrays , only : kperp2 use constants , only : pi use job_manage , only : timer_local , time_message implicit none complex , dimension (:, :), intent ( in ) :: h complex , dimension (:, :), intent ( out ) :: Dh integer , intent ( in ) :: iv , iz , is , ia , iky , ikx real , intent ( in ) :: cfac complex :: Dvpah , Dvpah_p , Dvpah_m , Dmuh , Dmuh_m , Dmuh_p , Dmuh1 , Dmuh2 real :: nuDp , nuDm , nupap , nupam , mup , mum , xp , xm , mwm , mwp integer :: imu imu = 1 ! vpa-differential terms: if ( iv == 1 ) then ! AVB: first order accurate: Dvpah = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv , imu ) / mw ( iv , imu , iz , is )) / dvpa Dvpah_p = ( h ( iv + 1 , imu + 1 ) / mw ( iv + 1 , imu + 1 , iz , is ) - h ( iv , imu + 1 ) / mw ( iv , imu + 1 , iz , is )) / dvpa else if ( iv == nvpa ) then ! AVB: first order accurate: Dvpah = ( h ( iv , imu ) / mw ( iv , imu , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / dvpa Dvpah_p = ( h ( iv , imu + 1 ) / mw ( iv , imu + 1 , iz , is ) - h ( iv - 1 , imu + 1 ) / mw ( iv - 1 , imu + 1 , iz , is )) / dvpa else Dvpah = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / ( 2 * dvpa ) Dvpah_p = ( h ( iv + 1 , imu + 1 ) / mw ( iv + 1 , imu + 1 , iz , is ) - h ( iv - 1 , imu + 1 ) / mw ( iv - 1 , imu + 1 , iz , is )) / ( 2 * dvpa ) end if ! first mu-derivative term at mu_{i}: ! use ghost cell at mu_{0} = 0, where mu*vpa*nux(vpa,mu)*F0 vanishes, dmu(0) = mu(1). Dmuh1 = (( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , is ) * mw ( iv , imu , iz , is ) * Dvpah ) * dmu ( imu ) / mu ( imu ) & + ( vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , is ) * mw ( iv , imu + 1 , iz , is ) * Dvpah_p - vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , is ) * mw ( iv , imu , iz , is ) * Dvpah ) * mu ( imu ) / dmu ( imu )) / ( mu ( imu ) + dmu ( imu )) ! first derivative of h, at mu_{i+1/2}, and at mu_i: Dmuh = ( h ( iv , imu + 1 ) / mw ( iv , imu + 1 , iz , is ) - h ( iv , imu ) / mw ( iv , imu , iz , is )) / dmu ( imu ) ! first-order accurate, as used in implicit routine ! for second-order accuracy: !a = -(2.*dmu(1) + dmu(2))/(dmu(1)*(dmu(1)+dmu(2))) !b = (dmu(1)+dmu(2))/(dmu(1)*dmu(2)) !c = -dmu(1)/(dmu(2)*(dmu(1)+dmu(2))) !Dmuh   = a*h(iv,imu)/mw(iv,imu,iz,is) + b*h(iv,imu+1)/mw(iv,imu+1,iz,is) + c*h(iv,imu+2)/mw(iv,imu+2,iz) ! second order accurate Dmuh_p = ( h ( iv , imu + 1 ) / mw ( iv , imu + 1 , iz , is ) - h ( iv , imu ) / mw ( iv , imu , iz , is )) / dmu ( imu ) ! second-order accurate ! quantities at mu_{i+1/2}: mup = 0.5 * ( mu ( imu ) + mu ( imu + 1 )) mwp = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mup ) xp = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mup ) nuDp = spec ( is )% vnew ( is ) * ( erf ( xp ) - ( erf ( xp ) - xp * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 )) / ( 2 * xp ** 2 )) / xp ** 3 nupap = spec ( is )% vnew ( is ) * 2 * ( erf ( xp ) - xp * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 )) / ( 2 * xp ** 2 ) / xp ** 3 ! second mu-derivative term at mu_{i}: ! use d/dmu[...]_{1} = ([...]_{1+1/2} - [...]_{0})/(dmu_{1}/2+mu(1)), where [...]_{0} is a ghost cell at mu_{0} = 0, with [...]_{0} = 0. Dmuh2 = ( ( 2 * ( nupa ( iv , imu , iz , is , is ) * mu ( imu ) ** 2 + nuD ( iv , imu , iz , is , is ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mu ( imu )) * mw ( iv , imu , iz , is ) * Dmuh ) * dmu ( imu ) / 2. / mu ( imu ) & + ( 2 * ( nupap * mup ** 2 + nuDp * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mup ) * mwp * Dmuh_p & - 2 * ( nupa ( iv , imu , iz , is , is ) * mu ( imu ) ** 2 + nuD ( iv , imu , iz , is , is ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mu ( imu )) * mw ( iv , imu , iz , is ) * Dmuh ) * mu ( imu ) / ( dmu ( imu ) / 2. ) ) / ( mu ( imu ) + dmu ( imu ) / 2. ) ! add differential terms and gyro-diffusive term: Dh ( iv , imu ) = Dmuh2 + Dmuh1 - cfac * 0.5 * kperp2 ( iky , ikx , ia , iz ) * ( spec ( is )% smz / bmag ( ia , iz )) ** 2 & * ( nupa ( iv , imu , iz , is , is ) * bmag ( ia , iz ) * mu ( imu ) + nuD ( iv , imu , iz , is , is ) * ( vpa ( iv ) ** 2 + bmag ( ia , iz ) * mu ( imu ))) * h ( iv , imu ) imu = nmu ! vpa-differential terms: if ( iv == 1 ) then ! AVB: first order accurate: Dvpah = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv , imu ) / mw ( iv , imu , iz , is )) / dvpa Dvpah_m = ( h ( iv + 1 , imu - 1 ) / mw ( iv + 1 , imu - 1 , iz , is ) - h ( iv , imu - 1 ) / mw ( iv , imu - 1 , iz , is )) / dvpa else if ( iv == nvpa ) then ! AVB: first order accurate: Dvpah = ( h ( iv , imu ) / mw ( iv , imu , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / dvpa Dvpah_m = ( h ( iv , imu - 1 ) / mw ( iv , imu - 1 , iz , is ) - h ( iv - 1 , imu - 1 ) / mw ( iv - 1 , imu - 1 , iz , is )) / dvpa else Dvpah = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / ( 2 * dvpa ) Dvpah_m = ( h ( iv + 1 , imu - 1 ) / mw ( iv + 1 , imu - 1 , iz , is ) - h ( iv - 1 , imu - 1 ) / mw ( iv - 1 , imu - 1 , iz , is )) / ( 2 * dvpa ) end if ! first mu-derivative term at mu_{nmu}: Dmuh1 = (( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , is ) * mw ( iv , imu , iz , is ) * Dvpah & - vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , is ) * mw ( iv , imu - 1 , iz , is ) * Dvpah_m ) * dmu ( imu - 1 ) / dmu ( imu - 1 ) & + ( - vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , is ) * mw ( iv , imu , iz , is ) * Dvpah ) * dmu ( imu - 1 ) / dmu ( imu - 1 )) / ( dmu ( imu - 1 ) + dmu ( imu - 1 )) ! first derivative of h, at mu_{nmu} and mu_{nmu-1/2}: Dmuh_m = ( h ( iv , imu ) / mw ( iv , imu , iz , is ) - h ( iv , imu - 1 ) / mw ( iv , imu - 1 , iz , is )) / dmu ( imu - 1 ) Dmuh = ( h ( iv , imu ) / mw ( iv , imu , iz , is ) - h ( iv , imu - 1 ) / mw ( iv , imu - 1 , iz , is )) / dmu ( imu - 1 ) ! first-order accurate ! for second-order accuracy: !a = dmu(nmu-1)/(dmu(nmu-2)*(dmu(nmu-2)+dmu(nmu-1))) !b = -(dmu(nmu-1)+dmu(nmu-2))/(dmu(nmu-2)*dmu(nmu-1)) !c = (2.*dmu(nmu-1)+dmu(nmu-2))/(dmu(nmu-1)*(dmu(nmu-1)+dmu(nmu-2))) !Dmuh = a*h(iv,imu-2)/mw(iv,imu-2,iz) + b*h(iv,imu-1)/mw(iv,imu-1,iz,is) + c*h(iv,imu)/mw(iv,imu,iz,is) ! quantities at mu_{nmu-1/2}: mum = 0.5 * ( mu ( imu ) + mu ( imu - 1 )) mwm = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mum ) xm = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mum ) nuDm = spec ( is )% vnew ( is ) * ( erf ( xm ) - ( erf ( xm ) - xm * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 )) / ( 2 * xm ** 2 )) / xm ** 3 nupam = spec ( is )% vnew ( is ) * 2 * ( erf ( xm ) - xm * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 )) / ( 2 * xm ** 2 ) / xm ** 3 ! second mu-derivative term at mu_{nmu}: ! use d/dmu[...]_{nmu} = ([...]_{nmu+1} - [...]_{nmu-1/2})/(dmu_{nmu-1}/2+dmu(nmu-1)), where [...]_{nmu+1} is a ghost cell at mu = mu_{nmu} + dmu(nmu-1), with [...]_{nmu+1} = 0. Dmuh2 = (( 2 * ( nupa ( iv , imu , iz , is , is ) * mu ( imu ) ** 2 + nuD ( iv , imu , iz , is , is ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) & * mu ( imu )) * mw ( iv , imu , iz , is ) * Dmuh - 2 * ( nupam * mum ** 2 + nuDm * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mum ) * mwm * Dmuh_m ) * dmu ( imu - 1 ) / ( dmu ( imu - 1 ) / 2 ) & + ( - 2 * ( nupa ( iv , imu , iz , is , is ) * mu ( imu ) ** 2 + nuD ( iv , imu , iz , is , is ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) & * mu ( imu )) * mw ( iv , imu , iz , is ) * Dmuh ) * dmu ( imu - 1 ) / 2. / dmu ( imu - 1 )) / ( dmu ( imu - 1 ) / 2. + dmu ( imu - 1 )) ! add differential terms and gyro-diffusive term: Dh ( iv , imu ) = Dmuh2 + Dmuh1 - cfac * 0.5 * kperp2 ( iky , ikx , ia , iz ) * ( spec ( is )% smz / bmag ( ia , iz )) ** 2 & * ( nupa ( iv , imu , iz , is , is ) * bmag ( ia , iz ) * mu ( imu ) + nuD ( iv , imu , iz , is , is ) * ( vpa ( iv ) ** 2 + bmag ( ia , iz ) * mu ( imu ))) * h ( iv , imu ) do imu = 2 , nmu - 1 ! vpa-differential terms: if ( iv == 1 ) then ! AVB: first order accurate: Dvpah = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv , imu ) / mw ( iv , imu , iz , is )) / dvpa Dvpah_p = ( h ( iv + 1 , imu + 1 ) / mw ( iv + 1 , imu + 1 , iz , is ) - h ( iv , imu + 1 ) / mw ( iv , imu + 1 , iz , is )) / dvpa Dvpah_m = ( h ( iv + 1 , imu - 1 ) / mw ( iv + 1 , imu - 1 , iz , is ) - h ( iv , imu - 1 ) / mw ( iv , imu - 1 , iz , is )) / dvpa else if ( iv == nvpa ) then ! AVB: first order accurate: Dvpah = ( h ( iv , imu ) / mw ( iv , imu , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / dvpa Dvpah_p = ( h ( iv , imu + 1 ) / mw ( iv , imu + 1 , iz , is ) - h ( iv - 1 , imu + 1 ) / mw ( iv - 1 , imu + 1 , iz , is )) / dvpa Dvpah_m = ( h ( iv , imu - 1 ) / mw ( iv , imu - 1 , iz , is ) - h ( iv - 1 , imu - 1 ) / mw ( iv - 1 , imu - 1 , iz , is )) / dvpa else Dvpah = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / ( 2 * dvpa ) Dvpah_p = ( h ( iv + 1 , imu + 1 ) / mw ( iv + 1 , imu + 1 , iz , is ) - h ( iv - 1 , imu + 1 ) / mw ( iv - 1 , imu + 1 , iz , is )) / ( 2 * dvpa ) Dvpah_m = ( h ( iv + 1 , imu - 1 ) / mw ( iv + 1 , imu - 1 , iz , is ) - h ( iv - 1 , imu - 1 ) / mw ( iv - 1 , imu - 1 , iz , is )) / ( 2 * dvpa ) end if ! first mu-derivative of vpa-derivative term, at mu_{i}: Dmuh1 = (( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , is ) * mw ( iv , imu , iz , is ) * Dvpah & - vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , is ) * mw ( iv , imu - 1 , iz , is ) * Dvpah_m ) * dmu ( imu ) / dmu ( imu - 1 ) & + ( vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , is ) * mw ( iv , imu + 1 , iz , is ) * Dvpah_p & - vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , is ) * mw ( iv , imu , iz , is ) * Dvpah ) * dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) ! first mu-derivatives of h, at mu_i, mu_{i+1/2} and mu_{i-1/2}: Dmuh = (( h ( iv , imu ) / mw ( iv , imu , iz , is ) - h ( iv , imu - 1 ) / mw ( iv , imu - 1 , iz , is )) * dmu ( imu ) / dmu ( imu - 1 ) & + ( h ( iv , imu + 1 ) / mw ( iv , imu + 1 , iz , is ) - h ( iv , imu ) / mw ( iv , imu , iz , is )) * dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) Dmuh_m = ( h ( iv , imu ) / mw ( iv , imu , iz , is ) - h ( iv , imu - 1 ) / mw ( iv , imu - 1 , iz , is )) / dmu ( imu - 1 ) Dmuh_p = ( h ( iv , imu + 1 ) / mw ( iv , imu + 1 , iz , is ) - h ( iv , imu ) / mw ( iv , imu , iz , is )) / dmu ( imu ) ! quantities at mu_{i+1/2} and mu_{i-1/2}: mup = 0.5 * ( mu ( imu ) + mu ( imu + 1 )) mum = 0.5 * ( mu ( imu ) + mu ( imu - 1 )) mwp = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mup ) mwm = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mum ) xp = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mup ) xm = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mum ) nuDp = spec ( is )% vnew ( is ) * ( erf ( xp ) - ( erf ( xp ) - xp * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 )) / ( 2 * xp ** 2 )) / xp ** 3 nuDm = spec ( is )% vnew ( is ) * ( erf ( xm ) - ( erf ( xm ) - xm * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 )) / ( 2 * xm ** 2 )) / xm ** 3 nupap = spec ( is )% vnew ( is ) * 2 * ( erf ( xp ) - xp * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 )) / ( 2 * xp ** 2 ) / xp ** 3 nupam = spec ( is )% vnew ( is ) * 2 * ( erf ( xm ) - xm * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 )) / ( 2 * xm ** 2 ) / xm ** 3 ! second mu-derivative term at mu_{i}: Dmuh2 = ( ( 2 * ( nupa ( iv , imu , iz , is , is ) * mu ( imu ) ** 2 + nuD ( iv , imu , iz , is , is ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mu ( imu )) * mw ( iv , imu , iz , is ) * Dmuh & - 2 * ( nupam * mum ** 2 + nuDm * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mum ) * mwm * Dmuh_m ) * dmu ( imu ) / dmu ( imu - 1 ) & + ( 2 * ( nupap * mup ** 2 + nuDp * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mup ) * mwp * Dmuh_p - 2 * ( nupa ( iv , imu , iz , is , is ) * mu ( imu ) ** 2 & + nuD ( iv , imu , iz , is , is ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mu ( imu )) * mw ( iv , imu , iz , is ) * Dmuh ) * dmu ( imu - 1 ) / dmu ( imu ) ) * 2 / ( dmu ( imu - 1 ) + dmu ( imu )) ! add differential terms and gyro-diffusive term: Dh ( iv , imu ) = Dmuh2 + Dmuh1 - cfac * 0.5 * kperp2 ( iky , ikx , ia , iz ) * ( spec ( is )% smz / bmag ( ia , iz )) ** 2 * ( nupa ( iv , imu , iz , is , is ) * bmag ( ia , iz ) * mu ( imu ) & + nuD ( iv , imu , iz , is , is ) * ( vpa ( iv ) ** 2 + bmag ( ia , iz ) * mu ( imu ))) * h ( iv , imu ) end do end subroutine mu_differential_operator_fp subroutine vpa_differential_operator_fp_conservative ( h , Dh , imu , iz , is , ia ) use vpamu_grids , only : nvpa , vpa , dvpa , mu , dmu , nmu , equally_spaced_mu_grid , maxwell_mu use stella_geometry , only : bmag use constants , only : pi use species , only : spec implicit none complex , dimension (:, :), intent ( out ) :: Dh complex , dimension (:, :), intent ( in ) :: h integer , intent ( in ) :: imu , iz , ia , is integer :: iv complex :: dmuhp , dmuhm , dvpahp , dvpahm real :: xp , xm , vpap , vpam , nupap , nupam , nuDp , nuDm , mwp , mwm iv = 1 vpap = 0.5 * ( vpa ( iv ) + vpa ( iv + 1 )) xp = sqrt ( vpap ** 2 + 2 * bmag ( ia , iz ) * mu ( imu )) nuDp = spec ( is )% vnew ( is ) * ( erf ( xp ) - ( erf ( xp ) - xp * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 )) / ( 2 * xp ** 2 )) / xp ** 3 nupap = spec ( is )% vnew ( is ) * 2 * ( erf ( xp ) - xp * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 )) / ( 2 * xp ** 2 ) / xp ** 3 mwp = exp ( - vpap ** 2 ) * maxwell_mu ( 1 , iz , imu , is ) dvpahp = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv , imu ) / mw ( iv , imu , iz , is )) / dvpa if ( imu == 1 ) then ! second-order accurate !a = -(2.*dmu(1) + dmu(2))/(dmu(1)*(dmu(1)+dmu(2))) !b = (dmu(1)+dmu(2))/(dmu(1)*dmu(2)) !c = -dmu(1)/(dmu(2)*(dmu(1)+dmu(2))) !dmuhp = a*h(iv+1,imu)/mw(iv+1,imu,iz,is)+ b*h(iv+1,imu+1)/mw(iv+1,imu+1,iz,is) + c*h(iv+1,imu+2)/mw(iv+1,imu+2,iz) ! first-order accurate, as in implicit routine: dmuhp = ( h ( iv + 1 , imu + 1 ) / mw ( iv + 1 , imu + 1 , iz , is ) - h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is )) / dmu ( imu ) else if ( imu == nmu ) then ! second-order accurate !a = dmu(nmu-1)/(dmu(nmu-2)*(dmu(nmu-2)+dmu(nmu-1))) !b = -(dmu(nmu-1)+dmu(nmu-2))/(dmu(nmu-2)*dmu(nmu-1)) !c = (2.*dmu(nmu-1)+dmu(nmu-2))/(dmu(nmu-1)*(dmu(nmu-1)+dmu(nmu-2))) !dmuhp = a*h(iv+1,imu-2)/mw(iv+1,imu-2,iz) + b*h(iv+1,imu-1)/mw(iv+1,imu-1,iz,is) + c*h(iv+1,imu)/mw(iv+1,imu,iz,is) ! first-order accurate, as in implicit routine: dmuhp = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv + 1 , imu - 1 ) / mw ( iv + 1 , imu - 1 , iz , is )) / dmu ( imu - 1 ) else dmuhp = (( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv + 1 , imu - 1 ) / mw ( iv + 1 , imu - 1 , iz , is )) * dmu ( imu ) / dmu ( imu - 1 ) & + ( h ( iv + 1 , imu + 1 ) / mw ( iv + 1 , imu + 1 , iz , is ) - h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is )) * dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) end if Dh ( iv , imu ) = ( 2 * 0.5 * ( nupap * vpap ** 2 + 2 * nuDp * bmag ( ia , iz ) * mu ( imu )) * mwp * dvpahp + vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , is ) * mw ( iv + 1 , imu , iz , is ) * dmuhp ) / ( 2 * dvpa ) iv = nvpa vpam = 0.5 * ( vpa ( iv ) + vpa ( iv - 1 )) xm = sqrt ( vpam ** 2 + 2 * bmag ( ia , iz ) * mu ( imu )) nuDm = spec ( is )% vnew ( is ) * ( erf ( xm ) - ( erf ( xm ) - xm * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 )) / ( 2 * xm ** 2 )) / xm ** 3 nupam = spec ( is )% vnew ( is ) * 2 * ( erf ( xm ) - xm * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 )) / ( 2 * xm ** 2 ) / xm ** 3 mwm = exp ( - vpam ** 2 ) * maxwell_mu ( 1 , iz , imu , is ) dvpahm = ( h ( iv , imu ) / mw ( iv , imu , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / dvpa if ( imu == 1 ) then ! second-order accurate !a = -(2.*dmu(1) + dmu(2))/(dmu(1)*(dmu(1)+dmu(2))) !b = (dmu(1)+dmu(2))/(dmu(1)*dmu(2)) !c = -dmu(1)/(dmu(2)*(dmu(1)+dmu(2))) !dmuhm = a*h(iv-1,imu)/mw(iv-1,imu,iz,is) + b*h(iv-1,imu+1)/mw(iv-1,imu+1,iz,is) + c*h(iv-1,imu+2)/mw(iv-1,imu+2,iz) ! first-order accurate, as in implicit routine: dmuhm = ( h ( iv - 1 , imu + 1 ) / mw ( iv - 1 , imu + 1 , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / dmu ( imu ) else if ( imu == nmu ) then ! second-order accurate !a = dmu(nmu-1)/(dmu(nmu-2)*(dmu(nmu-2)+dmu(nmu-1))) !b = -(dmu(nmu-1)+dmu(nmu-2))/(dmu(nmu-2)*dmu(nmu-1)) !c = (2.*dmu(nmu-1)+dmu(nmu-2))/(dmu(nmu-1)*(dmu(nmu-1)+dmu(nmu-2))) !dmuhm = a*h(iv-1,imu-2)/mw(iv-1,imu-2,iz) + b*h(iv-1,imu-1)/mw(iv-1,imu-1,iz,is) + c*h(iv-1,imu)/mw(iv-1,imu,iz,is) ! first-order accurate, as in implicit routine: dmuhm = ( h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is ) - h ( iv - 1 , imu - 1 ) / mw ( iv - 1 , imu - 1 , iz , is )) / dmu ( imu - 1 ) else dmuhm = (( h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is ) - h ( iv - 1 , imu - 1 ) / mw ( iv - 1 , imu - 1 , iz , is )) * dmu ( imu ) / dmu ( imu - 1 ) & + ( h ( iv - 1 , imu + 1 ) / mw ( iv - 1 , imu + 1 , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) * dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) end if Dh ( iv , imu ) = ( - 2 * 0.5 * ( nupam * vpam ** 2 + 2 * nuDm * bmag ( ia , iz ) * mu ( imu )) * mwm * dvpahm - vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , is ) * mw ( iv - 1 , imu , iz , is ) * dmuhm ) / ( 2 * dvpa ) do iv = 2 , nvpa - 1 ! AVB: interior nodes: ! quantities at half-grid-points: vpap = 0.5 * ( vpa ( iv ) + vpa ( iv + 1 )) vpam = 0.5 * ( vpa ( iv ) + vpa ( iv - 1 )) xp = sqrt ( vpap ** 2 + 2 * bmag ( ia , iz ) * mu ( imu )) xm = sqrt ( vpam ** 2 + 2 * bmag ( ia , iz ) * mu ( imu )) nuDp = spec ( is )% vnew ( is ) * ( erf ( xp ) - ( erf ( xp ) - xp * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 )) / ( 2 * xp ** 2 )) / xp ** 3 nuDm = spec ( is )% vnew ( is ) * ( erf ( xm ) - ( erf ( xm ) - xm * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 )) / ( 2 * xm ** 2 )) / xm ** 3 nupap = spec ( is )% vnew ( is ) * 2 * ( erf ( xp ) - xp * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 )) / ( 2 * xp ** 2 ) / xp ** 3 nupam = spec ( is )% vnew ( is ) * 2 * ( erf ( xm ) - xm * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 )) / ( 2 * xm ** 2 ) / xm ** 3 mwp = exp ( - vpap ** 2 ) * maxwell_mu ( 1 , iz , imu , is ) mwm = exp ( - vpam ** 2 ) * maxwell_mu ( 1 , iz , imu , is ) dvpahp = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv , imu ) / mw ( iv , imu , iz , is )) / dvpa dvpahm = ( h ( iv , imu ) / mw ( iv , imu , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / dvpa if ( imu == 1 ) then ! second-order accurate: !a = -(2.*dmu(1) + dmu(2))/(dmu(1)*(dmu(1)+dmu(2))) !b = (dmu(1)+dmu(2))/(dmu(1)*dmu(2)) !c = -dmu(1)/(dmu(2)*(dmu(1)+dmu(2))) !dmuhp = a*h(iv+1,imu)/mw(iv+1,imu,iz,is) + b*h(iv+1,imu+1)/mw(iv+1,imu+1,iz,is) + c*h(iv+1,imu+2)/mw(iv+1,imu+2,iz) !dmuhm = a*h(iv-1,imu)/mw(iv-1,imu,iz,is) + b*h(iv-1,imu+1)/mw(iv-1,imu+1,iz,is) + c*h(iv-1,imu+2)/mw(iv-1,imu+2,iz) ! or first-order accurate, as in implicit routine: dmuhp = ( h ( iv + 1 , imu + 1 ) / mw ( iv + 1 , imu + 1 , iz , is ) - h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is )) / dmu ( imu ) dmuhm = ( h ( iv - 1 , imu + 1 ) / mw ( iv - 1 , imu + 1 , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / dmu ( imu ) else if ( imu == nmu ) then ! second-order accurate: !a = dmu(nmu-1)/(dmu(nmu-2)*(dmu(nmu-2)+dmu(nmu-1))) !b = -(dmu(nmu-1)+dmu(nmu-2))/(dmu(nmu-2)*dmu(nmu-1)) !c = (2.*dmu(nmu-1)+dmu(nmu-2))/(dmu(nmu-1)*(dmu(nmu-1)+dmu(nmu-2))) !dmuhp = a*h(iv+1,imu-2)/mw(iv+1,imu-2,iz) + b*h(iv+1,imu-1)/mw(iv+1,imu-1,iz,is) + c*h(iv+1,imu)/mw(iv+1,imu,iz,is) !dmuhm = a*h(iv-1,imu-2)/mw(iv-1,imu-2,iz) + b*h(iv-1,imu-1)/mw(iv-1,imu-1,iz,is) + c*h(iv-1,imu)/mw(iv-1,imu,iz,is) ! or first-order accurate, as in implicit routine: dmuhp = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv + 1 , imu - 1 ) / mw ( iv + 1 , imu - 1 , iz , is )) / dmu ( imu - 1 ) dmuhm = ( h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is ) - h ( iv - 1 , imu - 1 ) / mw ( iv - 1 , imu - 1 , iz , is )) / dmu ( imu - 1 ) else dmuhp = (( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv + 1 , imu - 1 ) / mw ( iv + 1 , imu - 1 , iz , is )) * dmu ( imu ) / dmu ( imu - 1 ) & + ( h ( iv + 1 , imu + 1 ) / mw ( iv + 1 , imu + 1 , iz , is ) - h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is )) * dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) dmuhm = (( h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is ) - h ( iv - 1 , imu - 1 ) / mw ( iv - 1 , imu - 1 , iz , is )) * dmu ( imu ) / dmu ( imu - 1 ) & + ( h ( iv - 1 , imu + 1 ) / mw ( iv - 1 , imu + 1 , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) * dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) end if if ( iv == 2 ) then ! assume vpa*mu*nux*F0*dh/dmu vanishes at iv=1, to ensure density conservation Dh ( iv , imu ) = ( 2 * 0.5 * ( nupap * vpap ** 2 + 2 * nuDp * bmag ( ia , iz ) * mu ( imu )) * mwp * dvpahp & + vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , is ) * mw ( iv + 1 , imu , iz , is ) * dmuhp & - 2 * 0.5 * ( nupam * vpam ** 2 + 2 * nuDm * bmag ( ia , iz ) * mu ( imu )) * mwm * dvpahm & - 0 * vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , is ) * mw ( iv - 1 , imu , iz , is ) * dmuhm ) / ( 2 * dvpa ) else if ( iv == nvpa - 1 ) then ! assume vpa*mu*nux*F0*dh/dmu vanishes at iv=nvpa, to ensure density conservation Dh ( iv , imu ) = ( 2 * 0.5 * ( nupap * vpap ** 2 + 2 * nuDp * bmag ( ia , iz ) * mu ( imu )) * mwp * dvpahp & + 0 * vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , is ) * mw ( iv + 1 , imu , iz , is ) * dmuhp & - 2 * 0.5 * ( nupam * vpam ** 2 + 2 * nuDm * bmag ( ia , iz ) * mu ( imu )) * mwm * dvpahm & - vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , is ) * mw ( iv - 1 , imu , iz , is ) * dmuhm ) / ( 2 * dvpa ) else Dh ( iv , imu ) = ( 2 * 0.5 * ( nupap * vpap ** 2 + 2 * nuDp * bmag ( ia , iz ) * mu ( imu )) * mwp * dvpahp & + vpa ( iv + 1 ) * mu ( imu ) * nux ( iv + 1 , imu , iz , is , is ) * mw ( iv + 1 , imu , iz , is ) * dmuhp & - 2 * 0.5 * ( nupam * vpam ** 2 + 2 * nuDm * bmag ( ia , iz ) * mu ( imu )) * mwm * dvpahm & - vpa ( iv - 1 ) * mu ( imu ) * nux ( iv - 1 , imu , iz , is , is ) * mw ( iv - 1 , imu , iz , is ) * dmuhm ) / ( 2 * dvpa ) end if end do end subroutine vpa_differential_operator_fp_conservative subroutine mu_differential_operator_fp_conservative ( h , Dh , iv , iz , is , ia , iky , ikx , cfac ) use vpamu_grids , only : nmu , mu , dmu , vpa , dvpa , nvpa , maxwell_vpa , equally_spaced_mu_grid use stella_geometry , only : bmag use species , only : spec use dist_fn_arrays , only : kperp2 use constants , only : pi use job_manage , only : timer_local , time_message implicit none complex , dimension (:, :), intent ( in ) :: h complex , dimension (:, :), intent ( out ) :: Dh integer , intent ( in ) :: iv , iz , is , ia , iky , ikx real , intent ( in ) :: cfac complex :: Dvpah , Dvpah_p , Dvpah_m , Dmuh , Dmuh_m , Dmuh_p , Dmuh1 , Dmuh2 real :: nuDp , nuDm , nupap , nupam , mup , mum , xp , xm , mwm , mwp integer :: imu imu = 1 ! vpa-differential terms: if ( iv == 1 ) then ! AVB: first order accurate: Dvpah = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv , imu ) / mw ( iv , imu , iz , is )) / dvpa Dvpah_p = ( h ( iv + 1 , imu + 1 ) / mw ( iv + 1 , imu + 1 , iz , is ) - h ( iv , imu + 1 ) / mw ( iv , imu + 1 , iz , is )) / dvpa else if ( iv == nvpa ) then ! AVB: first order accurate: Dvpah = ( h ( iv , imu ) / mw ( iv , imu , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / dvpa Dvpah_p = ( h ( iv , imu + 1 ) / mw ( iv , imu + 1 , iz , is ) - h ( iv - 1 , imu + 1 ) / mw ( iv - 1 , imu + 1 , iz , is )) / dvpa else Dvpah = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / ( 2 * dvpa ) Dvpah_p = ( h ( iv + 1 , imu + 1 ) / mw ( iv + 1 , imu + 1 , iz , is ) - h ( iv - 1 , imu + 1 ) / mw ( iv - 1 , imu + 1 , iz , is )) / ( 2 * dvpa ) end if ! first mu-derivative term at mu_{i}: ! use ghost cell at mu_{0} = 0, where mu*vpa*nux(vpa,mu)*F0 vanishes, dmu(0) = mu(1) ! to ensure conservation of density we approximate as follows: Dmuh1 = ( vpa ( iv ) * mu ( imu ) * nux ( iv , imu , iz , is , is ) * mw ( iv , imu , iz , is ) * Dvpah + vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , is ) * mw ( iv , imu + 1 , iz , is ) * Dvpah_p ) / ( 2. * dmu ( imu )) !!Dmuh1 = ((vpa(iv)*mu(imu  )*nux(iv,imu  ,iz)*mw(iv,imu  ,iz,is)*Dvpah)*dmu(imu)/mu(imu) & !!      +(vpa(iv)*mu(imu+1)*nux(iv,imu+1,iz)*mw(iv,imu+1,iz,is)*Dvpah_p - vpa(iv)*mu(imu)*nux(iv,imu,iz)*mw(iv,imu,iz,is)*Dvpah)*mu(imu)/dmu(imu)) / (mu(imu)+dmu(imu)) ! first derivative of h, at mu_{i+1/2}, and at mu_i: Dmuh = ( h ( iv , imu + 1 ) / mw ( iv , imu + 1 , iz , is ) - h ( iv , imu ) / mw ( iv , imu , iz , is )) / dmu ( imu ) ! first-order accurate, as used in implicit routine ! for second-order accuracy: !a = -(2.*dmu(1) + dmu(2))/(dmu(1)*(dmu(1)+dmu(2))) !b = (dmu(1)+dmu(2))/(dmu(1)*dmu(2)) !c = -dmu(1)/(dmu(2)*(dmu(1)+dmu(2))) !Dmuh   = a*h(iv,imu)/mw(iv,imu,iz,is) + b*h(iv,imu+1)/mw(iv,imu+1,iz,is) + c*h(iv,imu+2)/mw(iv,imu+2,iz) ! second order accurate Dmuh_p = ( h ( iv , imu + 1 ) / mw ( iv , imu + 1 , iz , is ) - h ( iv , imu ) / mw ( iv , imu , iz , is )) / dmu ( imu ) ! second-order accurate ! quantities at mu_{i+1/2}: mup = 0.5 * ( mu ( imu ) + mu ( imu + 1 )) mwp = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mup ) xp = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mup ) nuDp = spec ( is )% vnew ( is ) * ( erf ( xp ) - ( erf ( xp ) - xp * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 )) / ( 2 * xp ** 2 )) / xp ** 3 nupap = spec ( is )% vnew ( is ) * 2 * ( erf ( xp ) - xp * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 )) / ( 2 * xp ** 2 ) / xp ** 3 ! second mu-derivative term at mu_{i}: ! use d/dmu[...]_{1} = ([...]_{1+1/2} - [...]_{0})/(dmu_{1}/2+mu(1)), where [...]_{0} is a ghost cell at mu_{0} = 0, with [...]_{0} = 0. Dmuh2 = ( ( 2 * ( nupa ( iv , imu , iz , is , is ) * mu ( imu ) ** 2 + nuD ( iv , imu , iz , is , is ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mu ( imu )) * mw ( iv , imu , iz , is ) * Dmuh ) * dmu ( imu ) / 2. / mu ( imu ) & + ( 2 * ( nupap * mup ** 2 + nuDp * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mup ) * mwp * Dmuh_p & - 2 * ( nupa ( iv , imu , iz , is , is ) * mu ( imu ) ** 2 + nuD ( iv , imu , iz , is , is ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mu ( imu )) * mw ( iv , imu , iz , is ) * Dmuh ) * mu ( imu ) / ( dmu ( imu ) / 2. ) ) / ( mu ( imu ) + dmu ( imu ) / 2. ) ! add differential terms and gyro-diffusive term: Dh ( iv , imu ) = Dmuh2 + Dmuh1 - cfac * 0.5 * kperp2 ( iky , ikx , ia , iz ) * ( spec ( is )% smz / bmag ( ia , iz )) ** 2 & * ( nupa ( iv , imu , iz , is , is ) * bmag ( ia , iz ) * mu ( imu ) + nuD ( iv , imu , iz , is , is ) * ( vpa ( iv ) ** 2 + bmag ( ia , iz ) * mu ( imu ))) * h ( iv , imu ) do imu = 2 , nmu - 1 ! vpa-differential terms: if ( iv == 1 ) then ! AVB: first order accurate: Dvpah = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv , imu ) / mw ( iv , imu , iz , is )) / dvpa Dvpah_p = ( h ( iv + 1 , imu + 1 ) / mw ( iv + 1 , imu + 1 , iz , is ) - h ( iv , imu + 1 ) / mw ( iv , imu + 1 , iz , is )) / dvpa Dvpah_m = ( h ( iv + 1 , imu - 1 ) / mw ( iv + 1 , imu - 1 , iz , is ) - h ( iv , imu - 1 ) / mw ( iv , imu - 1 , iz , is )) / dvpa else if ( iv == nvpa ) then ! AVB: first order accurate: Dvpah = ( h ( iv , imu ) / mw ( iv , imu , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / dvpa Dvpah_p = ( h ( iv , imu + 1 ) / mw ( iv , imu + 1 , iz , is ) - h ( iv - 1 , imu + 1 ) / mw ( iv - 1 , imu + 1 , iz , is )) / dvpa Dvpah_m = ( h ( iv , imu - 1 ) / mw ( iv , imu - 1 , iz , is ) - h ( iv - 1 , imu - 1 ) / mw ( iv - 1 , imu - 1 , iz , is )) / dvpa else Dvpah = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / ( 2 * dvpa ) Dvpah_p = ( h ( iv + 1 , imu + 1 ) / mw ( iv + 1 , imu + 1 , iz , is ) - h ( iv - 1 , imu + 1 ) / mw ( iv - 1 , imu + 1 , iz , is )) / ( 2 * dvpa ) Dvpah_m = ( h ( iv + 1 , imu - 1 ) / mw ( iv + 1 , imu - 1 , iz , is ) - h ( iv - 1 , imu - 1 ) / mw ( iv - 1 , imu - 1 , iz , is )) / ( 2 * dvpa ) end if ! first mu-derivative of vpa-derivative term, at mu_{i}: if ( imu == nmu - 1 ) then ! to ensure conservation of density we assume mu*nux*F0*d(h/F0)/dvpa vanishes at nmu Dmuh1 = ( - vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , is ) * mw ( iv , imu - 1 , iz , is ) * Dvpah_m ) / ( dmu ( imu - 1 ) + dmu ( imu - 1 )) else Dmuh1 = ( - vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , is ) * mw ( iv , imu - 1 , iz , is ) * Dvpah_m & + vpa ( iv ) * mu ( imu + 1 ) * nux ( iv , imu + 1 , iz , is , is ) * mw ( iv , imu + 1 , iz , is ) * Dvpah_p ) / ( dmu ( imu - 1 ) + dmu ( imu - 1 )) end if ! first mu-derivatives of h, at mu_i, mu_{i+1/2} and mu_{i-1/2}: Dmuh = ( ( h ( iv , imu ) / mw ( iv , imu , iz , is ) - h ( iv , imu - 1 ) / mw ( iv , imu - 1 , iz , is )) * dmu ( imu ) / dmu ( imu - 1 ) + ( h ( iv , imu + 1 ) / mw ( iv , imu + 1 , iz , is ) - h ( iv , imu ) / mw ( iv , imu , iz , is ))& * dmu ( imu - 1 ) / dmu ( imu )) / ( dmu ( imu - 1 ) + dmu ( imu )) Dmuh_m = ( h ( iv , imu ) / mw ( iv , imu , iz , is ) - h ( iv , imu - 1 ) / mw ( iv , imu - 1 , iz , is )) / dmu ( imu - 1 ) Dmuh_p = ( h ( iv , imu + 1 ) / mw ( iv , imu + 1 , iz , is ) - h ( iv , imu ) / mw ( iv , imu , iz , is )) / dmu ( imu ) ! quantities at mu_{i+1/2} and mu_{i-1/2}: mup = 0.5 * ( mu ( imu ) + mu ( imu + 1 )) mum = 0.5 * ( mu ( imu ) + mu ( imu - 1 )) mwp = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mup ) mwm = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mum ) xp = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mup ) xm = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mum ) nuDp = spec ( is )% vnew ( is ) * ( erf ( xp ) - ( erf ( xp ) - xp * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 )) / ( 2 * xp ** 2 )) / xp ** 3 nuDm = spec ( is )% vnew ( is ) * ( erf ( xm ) - ( erf ( xm ) - xm * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 )) / ( 2 * xm ** 2 )) / xm ** 3 nupap = spec ( is )% vnew ( is ) * 2 * ( erf ( xp ) - xp * ( 2 / sqrt ( pi )) * exp ( - xp ** 2 )) / ( 2 * xp ** 2 ) / xp ** 3 nupam = spec ( is )% vnew ( is ) * 2 * ( erf ( xm ) - xm * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 )) / ( 2 * xm ** 2 ) / xm ** 3 ! second mu-derivative term at mu_{i}: Dmuh2 = ( ( 2 * ( nupa ( iv , imu , iz , is , is ) * mu ( imu ) ** 2 + nuD ( iv , imu , iz , is , is ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mu ( imu )) * mw ( iv , imu , iz , is ) * Dmuh & - 2 * ( nupam * mum ** 2 + nuDm * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mum ) * mwm * Dmuh_m ) * dmu ( imu ) / dmu ( imu - 1 ) & + ( 2 * ( nupap * mup ** 2 + nuDp * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mup ) * mwp * Dmuh_p & - 2 * ( nupa ( iv , imu , iz , is , is ) * mu ( imu ) ** 2 + nuD ( iv , imu , iz , is , is ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mu ( imu )) * mw ( iv , imu , iz , is ) * Dmuh ) * dmu ( imu - 1 ) / dmu ( imu ) ) * 2 / ( dmu ( imu - 1 ) + dmu ( imu )) ! add differential terms and gyro-diffusive term: Dh ( iv , imu ) = Dmuh2 + Dmuh1 - cfac * 0.5 * kperp2 ( iky , ikx , ia , iz ) * ( spec ( is )% smz / bmag ( ia , iz )) ** 2 * ( nupa ( iv , imu , iz , is , is ) * bmag ( ia , iz ) * mu ( imu ) & + nuD ( iv , imu , iz , is , is ) * ( vpa ( iv ) ** 2 + bmag ( ia , iz ) * mu ( imu ))) * h ( iv , imu ) end do imu = nmu ! vpa-differential terms: if ( iv == 1 ) then ! AVB: first order accurate: Dvpah = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv , imu ) / mw ( iv , imu , iz , is )) / dvpa Dvpah_m = ( h ( iv + 1 , imu - 1 ) / mw ( iv + 1 , imu - 1 , iz , is ) - h ( iv , imu - 1 ) / mw ( iv , imu - 1 , iz , is )) / dvpa else if ( iv == nvpa ) then ! AVB: first order accurate: Dvpah = ( h ( iv , imu ) / mw ( iv , imu , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / dvpa Dvpah_m = ( h ( iv , imu - 1 ) / mw ( iv , imu - 1 , iz , is ) - h ( iv - 1 , imu - 1 ) / mw ( iv - 1 , imu - 1 , iz , is )) / dvpa else Dvpah = ( h ( iv + 1 , imu ) / mw ( iv + 1 , imu , iz , is ) - h ( iv - 1 , imu ) / mw ( iv - 1 , imu , iz , is )) / ( 2 * dvpa ) Dvpah_m = ( h ( iv + 1 , imu - 1 ) / mw ( iv + 1 , imu - 1 , iz , is ) - h ( iv - 1 , imu - 1 ) / mw ( iv - 1 , imu - 1 , iz , is )) / ( 2 * dvpa ) end if ! first mu-derivative term at mu_{nmu}: ! to ensure conservation of density, assume that term is zero beyond nmu Dmuh1 = ( - vpa ( iv ) * mu ( imu - 1 ) * nux ( iv , imu - 1 , iz , is , is ) * mw ( iv , imu - 1 , iz , is ) * Dvpah_m ) / ( dmu ( imu - 1 ) + dmu ( imu - 1 )) ! first derivative of h, at mu_{nmu} and mu_{nmu-1/2}: Dmuh_m = ( h ( iv , imu ) / mw ( iv , imu , iz , is ) - h ( iv , imu - 1 ) / mw ( iv , imu - 1 , iz , is )) / dmu ( imu - 1 ) Dmuh = ( h ( iv , imu ) / mw ( iv , imu , iz , is ) - h ( iv , imu - 1 ) / mw ( iv , imu - 1 , iz , is )) / dmu ( imu - 1 ) ! first-order accurate ! for second-order accuracy: !a = dmu(nmu-1)/(dmu(nmu-2)*(dmu(nmu-2)+dmu(nmu-1))) !b = -(dmu(nmu-1)+dmu(nmu-2))/(dmu(nmu-2)*dmu(nmu-1)) !c = (2.*dmu(nmu-1)+dmu(nmu-2))/(dmu(nmu-1)*(dmu(nmu-1)+dmu(nmu-2))) !Dmuh = a*h(iv,imu-2)/mw(iv,imu-2,iz) + b*h(iv,imu-1)/mw(iv,imu-1,iz,is) + c*h(iv,imu)/mw(iv,imu,iz,is) ! quantities at mu_{nmu-1/2}: mum = 0.5 * ( mu ( imu ) + mu ( imu - 1 )) mwm = maxwell_vpa ( iv , is ) * exp ( - 2 * bmag ( ia , iz ) * mum ) xm = sqrt ( vpa ( iv ) ** 2 + 2 * bmag ( ia , iz ) * mum ) nuDm = spec ( is )% vnew ( is ) * ( erf ( xm ) - ( erf ( xm ) - xm * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 )) / ( 2 * xm ** 2 )) / xm ** 3 nupam = spec ( is )% vnew ( is ) * 2 * ( erf ( xm ) - xm * ( 2 / sqrt ( pi )) * exp ( - xm ** 2 )) / ( 2 * xm ** 2 ) / xm ** 3 ! second mu-derivative term at mu_{nmu}: ! to ensure density conservation ! use d/dmu[...]_{nmu} = ([...]_{nmu+1/2} - [...]_{nmu-1/2})/(dmu_{nmu-1}/2+dmu(nmu-1)/2), where [...]_{nmu+1/2} is a ghost cell at mu = mu_{nmu} + dmu(nmu-1)/2, with [...]_{nmu+1/2} = 0. Dmuh2 = ( ( 2 * ( nupa ( iv , imu , iz , is , is ) * mu ( imu ) ** 2 + nuD ( iv , imu , iz , is , is ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mu ( imu )) * mw ( iv , imu , iz , is ) * Dmuh & - 2 * ( nupam * mum ** 2 + nuDm * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mum ) * mwm * Dmuh_m ) * dmu ( imu - 1 ) / dmu ( imu - 1 ) & + ( - 2 * ( nupa ( iv , imu , iz , is , is ) * mu ( imu ) ** 2 + nuD ( iv , imu , iz , is , is ) * vpa ( iv ) ** 2 / ( 2 * bmag ( ia , iz )) * mu ( imu )) & * mw ( iv , imu , iz , is ) * Dmuh ) * dmu ( imu - 1 ) / dmu ( imu - 1 )) / ( dmu ( imu - 1 ) / 2. + dmu ( imu - 1 ) / 2. ) ! add differential terms and gyro-diffusive term: Dh ( iv , imu ) = Dmuh2 + Dmuh1 - cfac * 0.5 * kperp2 ( iky , ikx , ia , iz ) * ( spec ( is )% smz / bmag ( ia , iz )) ** 2 * ( nupa ( iv , imu , iz , is , is ) * bmag ( ia , iz ) * mu ( imu ) & + nuD ( iv , imu , iz , is , is ) * ( vpa ( iv ) ** 2 + bmag ( ia , iz ) * mu ( imu ))) * h ( iv , imu ) end subroutine mu_differential_operator_fp_conservative subroutine advance_collisions_fp_implicit ( phi , apar , bpar ) use zgrid , only : nzgrid use vpamu_grids , only : set_vpa_weights use dist_fn_arrays , only : gvmu implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in out ) :: phi , apar , bpar logical :: conservative_wgts if ( density_conservation ) then conservative_wgts = . true . call set_vpa_weights ( conservative_wgts ) end if if ( exact_conservation_tp ) then conservative_wgts = . false . call set_vpa_weights ( conservative_wgts ) end if call advance_implicit_fp ( phi , apar , bpar , gvmu ) end subroutine advance_collisions_fp_implicit subroutine advance_implicit_fp ( phi , apar , bpar , g ) use mp , only : sum_allreduce use finite_differences , only : tridag use linear_solve , only : lu_back_substitution use stella_time , only : code_dt use run_parameters , only : fphi use species , only : nspec , spec use zgrid , only : nzgrid , ntubes use vpamu_grids , only : nmu , nvpa , integrate_vmu use vpamu_grids , only : vpa use vpamu_grids , only : set_vpa_weights use kt_grids , only : naky , nakx use stella_layouts , only : kxkyz_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , is_idx , it_idx use g_tofrom_h , only : g_to_h use fields , only : get_fields use constants , only : pi use stella_time , only : code_dt implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in out ) :: phi , apar , bpar complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( in out ) :: g complex , dimension (:, :, :, :, :), allocatable :: flds complex , dimension (:, :, :), allocatable :: g_in complex , dimension (:, :), allocatable :: gvmutr complex , dimension (:), allocatable :: ghrs complex , dimension (:, :, :, :, :), allocatable :: field complex , dimension (:, :), allocatable :: g0spitzer integer :: ikxkyz , iky , ikx , iz , is , iv , it , ia integer :: idx1 , ij , il , im , jj , ll , mm , ll1 , mm1 , jj1 , isa , isb real :: clm real :: spitzer_i1 , spitzer_i2 , applied_Epar , gradpar_lnp0 , gradpar_lnT0 ! store input g for use later, as g will be overwritten below allocate ( g_in ( nvpa , nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) allocate ( g0spitzer ( nvpa , nmu )) ia = 1 if ( spitzer_problem ) then ! to solve the Spitzer problem, we add a source term associated with a constant ! applied electric field, and pressure and temperature gradients here ! all other non-collisional terms are disabled, and Delta t --> \\infty applied_Epar = 0.01 gradpar_lnp0 = 0 gradpar_lnT0 = 0.01 spitzer_i1 = ( applied_Epar - gradpar_lnp0 ) * i1fac spitzer_i2 = gradpar_lnT0 * i2fac do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) if ( is == 1 ) cycle g (:, :, ikxkyz ) = g (:, :, ikxkyz ) - 1. / sqrt ( spec ( is )% mass ) * code_dt * ( spread ( vpa , 2 , nmu ) * spitzer_i1 & + ( spread ( vpa , 2 , nmu ) * velvpamu (:, :, iz ) ** 2 - 5. / 2. * spread ( vpa , 2 , nmu )) * spitzer_i2 ) * mw (:, :, iz , is ) end do end if g_in = g allocate ( gvmutr ( nvpa , nmu )) allocate ( ghrs ( nmu * nvpa )) allocate ( field ( naky , nakx , - nzgrid : nzgrid , ntubes , nspec )) allocate ( flds ( naky , nakx , - nzgrid : nzgrid , ntubes , nresponse )) ! since backwards difference in time, (I-dt*D)h_inh&#94;{n+1} = g&#94;{***} ! invert above equation to get h_inh&#94;{n+1} do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) do iv = 1 , nvpa ghrs ( nmu * ( iv - 1 ) + 1 : nmu * iv ) = g ( iv , :, ikxkyz ) end do call zgbtrs ( 'No transpose' , nvpa * nmu , nmu + 1 , nmu + 1 , 1 , cdiffmat_band (:,:, iky , ikx , iz , is ), 3 * ( nmu + 1 ) + 1 , ipiv (:, iky , ikx , iz , is ), ghrs , nvpa * nmu , info ) do iv = 1 , nvpa g ( iv , :, ikxkyz ) = ghrs ( nmu * ( iv - 1 ) + 1 : nmu * iv ) end do end do ! obtain phi&#94;{n+1} and conservation terms using response matrix approach ! first get phi_inh&#94;{n+1} if ( advfield_coll ) then call get_fields ( g , phi , apar , bpar , dist = 'h' ) flds (:, :, :, :, 1 ) = phi end if ! next get the psi&#94;{s1s2,jlm}_inh&#94;{n+1} ! note g contains h_s1_inh, h_s2_inh, ... ie all species if ( fieldpart ) then ! layout of field(,,,,:) is phi; jlm0 psi_aa, jlm0 psi_ab, jlm0 psi_ba,  jlm0 psi_bb; jlm1 psi_aa, etc, because we want species to be contiguous do idx1 = 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 * nspec isa = 1 + int (( idx1 - 1 ) / (( jmax + 1 ) * ( lmax + 1 ) ** 2 )) !1 + mod(idx1-1,(jmax+1)*(lmax+1)**2) ij = 1 + mod ( 1 + mod ( idx1 - 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 ) - 1 , jmax + 1 ) il = 1 + int ( sqrt ( 1.0 * ( 1 + mod ( idx1 - 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 ) - ij ) / ( jmax + 1 ))) im = ( 1 + mod ( idx1 - 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 ) - ij ) / ( jmax + 1 ) - ( il - 1 ) ** 2 + 1 ll = il - 1 mm = - ll + im - 1 jj = ij - 1 if ( density_conservation_tp . and . ( jj == 0 ) . and . ( ll == 0 )) then ! get the density produced by the combined test particle operator C_{test,isa} = C_{test,isa,isa} + C_{test,isa,isb} + ... ! this is stored in field(:,:,:,:,isa), all other entries are zero field = 0. call get_testpart_density ( isa , 0 , g , field ) else ! get psi&#94;{isa[is1....isN],jlm}_inh&#94;{n+1} call get_psi ( g , field , isa , 0 , ll , mm , jj ) end if ! add to rhs vector flds (:, :, :, :, 2 + ( idx1 - 1 ) * nspec : 1 + idx1 * nspec ) = field (:, :, :, :, :) end do end if ! AVB: obtain phi&#94;{n+1} and psijlm&#94;{n+1} from response matrix do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) ! all is indices inside ikxkyz super-index have same info ! no need to compute multiple times is = is_idx ( kxkyz_lo , ikxkyz ); if ( is /= 1 ) cycle call lu_back_substitution ( fp_response (:, :, ikxkyz ), diff_idx (:, ikxkyz ), flds ( iky , ikx , iz , it , :)) end do if ( advfield_coll ) then phi (:, :, :, :) = flds (:, :, :, :, 1 ) call sum_allreduce ( phi ) end if g = g_in ! RHS is g&#94;{***} + Ze/T*<phi&#94;{n+1}>*F0 + sum_jlm psi_jlm&#94;{n+1}*delta_jl ! first two terms added via g_to_h subroutine if ( advfield_coll ) then call g_to_h ( g , phi , bpar , fphi ) end if ! add field particle contribution to RHS: if ( fieldpart ) then do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) do idx1 = 1 , ( jmax + 1 ) * ( lmax + 1 ) ** 2 ij = 1 + mod ( idx1 - 1 , jmax + 1 ) il = 1 + int ( sqrt ( 1.0 * ( idx1 - ij ) / ( jmax + 1 ))) im = ( idx1 - ij ) / ( jmax + 1 ) - ( il - 1 ) ** 2 + 1 ll1 = il - 1 mm1 = - ll1 + im - 1 jj1 = ij - 1 if ( density_conservation_tp . and . ( jj1 == 0 ) . and . ( ll1 == 0 )) then isb = is g (:,:, ikxkyz ) = g (:,:, ikxkyz ) - code_dt * flds ( iky , ikx , iz , it , 2 + ( is - 1 ) * (( jmax + 1 ) * ( lmax + 1 ) ** 2 * nspec ) + ( idx1 - 1 ) * nspec + ( isb - 1 ))& * modmw (:, :, iz , is ) / modmwnorm ( iz ) else clm = sqrt ((( 2 * ll1 + 1 ) * gamma ( ll1 - mm1 + 1. )) / ( 4 * pi * gamma ( ll1 + mm1 + 1. ))) do isb = 1 , nspec if ( mm1 == 0 ) then g (:,:, ikxkyz ) = g (:,:, ikxkyz ) + code_dt * spec ( is )% vnew ( isb ) * clm * legendre_vpamu ( ll1 , mm1 ,:,:, iz ) * spread ( jm (:, mm1 , iky , ikx , iz , is ), 1 , nvpa ) & * flds ( iky , ikx , iz , it , 2 + ( is - 1 ) * (( jmax + 1 ) * ( lmax + 1 ) ** 2 * nspec ) + ( idx1 - 1 ) * nspec + ( isb - 1 )) & * ( spec ( is )% mass / spec ( isb )% mass ) ** ( - 1.5 ) * deltaj ( ll1 , jj1 , is , isb , :, :, ia , iz ) else if ( mm1 > 0 ) then g (:,:, ikxkyz ) = g (:,:, ikxkyz ) + code_dt * spec ( is )% vnew ( isb ) * clm * legendre_vpamu ( ll1 , mm1 ,:,:, iz ) * spread ( jm (:, mm1 , iky , ikx , iz , is ), 1 , nvpa ) & * flds ( iky , ikx , iz , it , 2 + ( is - 1 ) * (( jmax + 1 ) * ( lmax + 1 ) ** 2 * nspec ) + ( idx1 - 1 ) * nspec + ( isb - 1 )) & * ( spec ( is )% mass / spec ( isb )% mass ) ** ( - 1.5 ) * deltaj ( ll1 , jj1 , is , isb , :, :, ia , iz ) else if ( mm1 < 0 ) then g (:,:, ikxkyz ) = g (:,:, ikxkyz ) + ( - 1 ) ** mm1 * code_dt * spec ( is )% vnew ( isb ) * clm * legendre_vpamu ( ll1 , mm1 ,:,:, iz ) * spread ( jm (:, abs ( mm1 ), iky , ikx , iz , is ), 1 , nvpa ) & * flds ( iky , ikx , iz , it , 2 + ( is - 1 ) * (( jmax + 1 ) * ( lmax + 1 ) ** 2 * nspec ) + ( idx1 - 1 ) * nspec + ( isb - 1 )) & * ( spec ( is )% mass / spec ( isb )% mass ) ** ( - 1.5 ) * deltaj ( ll1 , jj1 , is , isb , :, :, ia , iz ) end if end do end if end do end do end if deallocate ( flds ) ! invert system to get h&#94;{n+1} do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) do iv = 1 , nvpa ghrs ( nmu * ( iv - 1 ) + 1 : nmu * iv ) = g ( iv , :, ikxkyz ) end do call zgbtrs ( 'No transpose' , nvpa * nmu , nmu + 1 , nmu + 1 , 1 , cdiffmat_band (:,:, iky , ikx , iz , is ), 3 * ( nmu + 1 ) + 1 , ipiv (:, iky , ikx , iz , is ), ghrs , nvpa * nmu , info ) do iv = 1 , nvpa g ( iv , :, ikxkyz ) = ghrs ( nmu * ( iv - 1 ) + 1 : nmu * iv ) end do end do ! get g&#94;{n+1} from h&#94;{n+1} and phi&#94;{n+1} if ( advfield_coll ) then call g_to_h ( g , phi , bpar , - fphi ) end if !fields_updated = .false. deallocate ( g_in ) deallocate ( field ) deallocate ( gvmutr ) deallocate ( ghrs ) end subroutine advance_implicit_fp end module coll_fokkerplanck","tags":"","loc":"sourcefile/coll_fokkerplanck.f90.html"},{"title":"ezcdf_inqvar.f90 – stella","text":"Source Code MODULE ezcdf_inqvar IMPLICIT NONE integer , parameter :: fatal_error = 666 !DEC$ IF DEFINED (NETCDF) PUBLIC :: cdfInqVar , cdfgv , cdfInqV , cdf_inquire , alpha_numeric INTERFACE cdfInqVarDim MODULE PROCEDURE cdfInqV , cdfgv , cdf_inquire END INTERFACE PRIVATE INCLUDE \"netcdf.inc\" CHARACTER * ( nf_max_name ) :: varnam_noalpha PRIVATE varnam_noalpha CONTAINS subroutine cdfInqVar ( ncid , varnam , dimlens , eztype , ier ) ! Inquire a Variable and its dimensions ! 03/08/99 C. Ludescher ! C. Ludescher/A. Pletzer Tue Apr  4 10:11:33 EDT 2000 ! + support for complex type (ap) Wed May 16 15:18:05 EDT 2001 implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output integer , dimension (:), intent ( out ) :: dimlens character * ( * ), intent ( out ) :: eztype integer , optional , intent ( out ) :: ier ! Local integer :: ndims , varid , natts , xtype integer :: status , i integer , dimension ( 3 ) :: dimids character * ( nf_max_name ) :: name integer , parameter :: cmplx_len = 13 character ( cmplx_len ), parameter :: cmplx_name = '__CmPlx_Re_Im' character * 11 , parameter :: logical_name = '__logical__' logical :: is_complex , is_logical if ( PRESENT ( ier )) ier = 1 is_complex = . false . is_logical = . false . ! replace any non-alphanumeric characters with underscores varnam_noalpha = varnam CALL alpha_numeric ( varnam_noalpha ) status = nf_inq_varid ( ncid , varnam_noalpha , varid ) if ( status /= 0 ) then ! perhaps varnam is complex, try... status = nf_inq_varid ( ncid , trim ( varnam_noalpha ) // cmplx_name , varid ) if ( status == 0 ) then is_complex = . true . else status = nf_inq_varid ( ncid , trim ( varnam_noalpha ) // logical_name , varid ) if ( status == 0 ) is_logical = . true . end if end if if ( is_complex ) varnam_noalpha = trim ( varnam_noalpha ) // cmplx_name if ( is_logical ) varnam_noalpha = trim ( varnam_noalpha ) // logical_name ! call handle_err(status,varnam_noalpha,'cdfInqVar','nf_inq_varid') if ( status /= 0 ) return status = nf_inq_var ( ncid , varid , name , xtype , ndims , dimids , natts ) call handle_err ( status , varnam_noalpha , 'cdfInqVar' , 'nf_inq_var' ) if ( status /= 0 ) return if ( size ( dimlens ) < ndims ) return dimlens = 0 select case ( xtype ) case ( nf_double ) eztype = 'R8' if ( is_complex ) eztype = 'C16' case ( nf_int ) eztype = 'INT' if ( is_logical ) eztype = 'LOG' !  case (nf_byte) !     eztype = 'LOG' case ( nf_float ) eztype = 'R4' if ( is_complex ) eztype = 'C8' case ( nf_char ) eztype = 'CHAR' end select do i = 1 , ndims status = nf_inq_dim ( ncid , dimids ( i ), name , dimlens ( i )) call handle_err ( status , varnam , 'cdfInqVar' , 'nf_inq_dim' ) end do if ( is_complex ) then dimlens ( 1 ) = dimlens ( 1 ) / 2 end if if ( PRESENT ( ier )) ier = status end subroutine cdfInqVar ! automatic conversion to free f90 compatible form ! free.pl cdfgv.for ! linewidth: 72 ! file names: cdfgv.for ! SUBROUTINE cdfgv ( ncid , varnam , varid , dimlens , sizes , xtype , status ) ! !     Get Variable id, etc. !     02/11/99 C.Ludescher ! C. Ludescher/A. Pletzer Tue Apr  4 10:11:33 EDT 2000 ! implicit none !!$      include \"netcdf.inc\" ! Input integer :: ncid character * ( * ) :: varnam character * 1 :: xtype integer , dimension (:) :: sizes ! Output integer , dimension (:) :: dimlens integer :: varid , status ! Local integer :: i , vartyp , ndims , atts , rank integer , dimension ( 3 ) :: dimids character * ( nf_max_name ) :: name !   replace any non-alphanumeric characters with underscores varnam_noalpha = varnam CALL alpha_numeric ( varnam_noalpha ) status = nf_inq_varid ( ncid , varnam_noalpha , varid ) !   call handle_err(status,varnam,'cdfgv','nf_inq_varid') if ( status /= 0 ) return status = nf_inq_var ( ncid , varid , name , vartyp , ndims , dimids , atts ) call handle_err ( status , varnam , 'cdfgv' , 'nf_inq_var' ) if ( status /= 0 ) return ! Verify input dimension is correct rank = size ( sizes ) status = 1 if ( ndims == 3 . and . rank /= 3 ) then print \"('% cdfgv: --E-- The variable ',a,                      & &         ' is 3 dimensional')\" , varnam return else if ( ndims == 2 . and . rank /= 2 ) then print \"('% cdfgv: --E-- The variable ',a,                      & &         ' is 2 dimensional')\" , varnam return end if if ( ndims == 0 . and . sizes ( 1 ) /= 0 ) then print \"('% cdfgv: --E-- The variable ',a,                      & &           ' is a Scalar')\" , varnam return else if ( ndims == 1 . and . rank /= 1 ) then print \"('% cdfgv: --E-- The variable ',a,                      & &           ' is 1 dimensional')\" , & & varnam return end if ! Verify data type is matching select case ( xtype ) case ( 'i' ) if ( vartyp /= nf_int ) then print \"('% cdfgv: --E-- ',a,' is of type Integer !')\" , & & varnam return end if case ( 'l' ) if ( vartyp /= nf_byte ) then print \"('% cdfgv: --E-- ',a,' is of type logical !')\" , & & varnam return end if case ( 'd' ) if ( vartyp /= nf_double ) then print \"('% cdfgv: --E-- ',a,' is of type REAL*8 !')\" , & & varnam return end if case ( 'r' ) if ( vartyp /= nf_real ) then print \"('% cdfgv: --E-- ',a,' is of type default REAL !')\" , & & varnam return end if case ( 'c' ) if ( vartyp /= nf_char ) then print \"('% cdfgv: --E-- ',a,' is of type Character !')\" , & & varnam return end if end select status = 0 do i = 1 , ndims dimlens ( i ) = 0 status = nf_inq_dim ( ncid , dimids ( i ), name , dimlens ( i )) call handle_err ( status , varnam , 'cdfgv' , 'nf_inq_dim' ) end do ! Check array size is big enough select case ( ndims ) case ( 1 ) if ( dimlens ( 1 ) > sizes ( 1 )) then print \"('% cdfgv: --W-- Output array size =',I6,/           & &           '                is smaller than ',                    & &           a,' size =',I6/,                                       & &           '                output will be truncated !')\" , & & sizes ( 1 ), varnam , dimlens ( 1 ) end if case ( 2 ) if ( dimlens ( 1 ) > sizes ( 1 ) . or . dimlens ( 2 ) > sizes ( 2 )) then print \"('% cdfgv: --W-- Output array size =',I6,' *',I6,/      & &           '                is smaller than ',                    & &           a,' size =',I6,' *',I6/,                               & &           '                output will be truncated !')\" , & & sizes ( 1 ), sizes ( 2 ), varnam , dimlens ( 1 ), dimlens ( 2 ) end if case ( 3 ) if ( dimlens ( 1 ) > sizes ( 1 ) . or . dimlens ( 2 ) > sizes ( 2 ) & & . or . dimlens ( 3 ) > sizes ( 3 )) then print \"('% cdfgv: --W-- Output array size =',                  & &          I5,' *',I5,' *',I5/,                                    & &           '                is smaller than ',                    & &           a,' size =',I5,' *',I5,' *',I5/,                       & &           '                output will be truncated !')\" , & & sizes ( 1 ), sizes ( 2 ), sizes ( 3 ), varnam , & & dimlens ( 1 ), dimlens ( 2 ), dimlens ( 3 ) end if end select end SUBROUTINE cdfgv SUBROUTINE cdfInqV ( ncid , varnam , varid , dimlens , ndims , status ) ! Inquire variable-id and dimlens ! 03/09/99 C.Ludescher ! implicit none ! !!$      include \"netcdf.inc\" ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Returns !      integer, dimension(3)  ::  dimlens !      integer ::  ndims, varid !      integer ::  status integer , dimension (:), intent ( out ) :: dimlens integer , intent ( out ) :: ndims , varid integer , intent ( out ) :: status ! Local integer :: natts , xtype , i integer , dimension ( 3 ) :: dimids character * ( nf_max_name ) :: name !--------------------------------------------------------------------------- !   Initialize values SAL 07012014 varid = 0 ! SAL 07012014 xtype = 0 ; ndims = 0 ; dimids = 0 ; natts = 0 ; dimlens = 0 ! SAL 07012014 !   replace any non-alphanumeric characters with underscores varnam_noalpha = varnam CALL alpha_numeric ( varnam_noalpha ) status = nf_inq_varid ( ncid , varnam_noalpha , varid ) !    call handle_err(status,varnam,'cdfInqV','nf_inq_varid') if ( status /= 0 ) return status = nf_inq_var ( ncid , varid , name , xtype , ndims , dimids , natts ) call handle_err ( status , varnam , 'cdfInqV' , 'nf_inq_var' ) if ( ndims > size ( dimlens )) then print * , 'dimlens too small in cdfInqV' status = fatal_error return end if do i = 1 , ndims status = nf_inq_dimlen ( ncid , dimids ( i ), dimlens ( i )) call handle_err ( status , varnam , 'cdfInqV' , 'nf_inq_dimlen' ) end do END SUBROUTINE cdfInqV SUBROUTINE cdf_inquire ( ncid , varnam , dimlens , xtype , ier ) implicit none ! Input integer , intent ( in ) :: ncid character * ( * ), intent ( in ) :: varnam ! Output integer , dimension (:), intent ( out ) :: dimlens character * ( * ), optional , intent ( out ) :: xtype integer , optional , intent ( out ) :: ier integer :: ezerror character * 4 :: eztype CALL cdfInqVar ( ncid , varnam , dimlens , eztype , ezerror ) IF ( PRESENT ( xtype )) xtype = eztype IF ( PRESENT ( ier )) ier = ezerror END SUBROUTINE cdf_inquire SUBROUTINE alpha_numeric ( string ) IMPLICIT NONE CHARACTER * ( * ), INTENT ( INOUT ) :: string CHARACTER * ( LEN_TRIM ( string )) :: temp INTEGER :: iascii , i ! 04/03/03 S. Hirshman ! replaces any non-alphanumeric characters with underscores temp = adjustl ( string ) string = trim ( temp ) do i = 2 , len_trim ( string ) iascii = iachar ( string ( i : i )) if ((( iascii >= iachar ( '0' )) . and . ( iascii <= iachar ( '9' ))) & . or . (( iascii >= iachar ( 'A' )) . and . ( iascii <= iachar ( 'z' )))) cycle string ( i : i ) = '_' end do END SUBROUTINE alpha_numeric !DEC$ ENDIF END MODULE ezcdf_inqvar","tags":"","loc":"sourcefile/ezcdf_inqvar.f90.html"},{"title":"safe_open_mod.f – stella","text":"Source Code MODULE safe_open_mod ! !     Module for performing a \"safe\" open of a file for !     a Fortran read/write operation. Makes sure the requested file !     unit number is not in use, and increments it until an unused !     unit is found ! CONTAINS SUBROUTINE safe_open ( iunit , istat , filename , filestat , & & fileform , record_in , access_in , delim_in ) ! !     Module for performing a \"safe\" open of a file for !     a Fortran read/write operation. Makes sure the requested file !     unit number is not in use, and increments it until an unused !     unit is found ! !  Note that: ! 1)  the actual i/o unit number used is returned in the first argument. ! 2)  the status variable from the OPEN command is returned as the second !     argument. !  Here are some examples of usage: ! !   To open an existing namelist input file: !      CALL safe_open(iou,istat,nli_file_name,'old','formatted') ! !   To create a file, in order to write to it: !      CALL safe_open(iou,istat,my_output_file_name,'replace','formatted') ! !   To create an output file, with 'NONE' as delimiter for characters for !   list-directed output and Namelist output !      CALL safe_open(iou,istat,my_output_file_name,'replace', !     &   'formatted',delim_in='none') !  JDH 08-30-2004. !     Based on Steve Hirshman's original safe_open routine !     Rearranged comments, continuation lines, some statement ordering. !     Should be NO change in functionality. ! !  JDH 2010-06-09 !     Added coding for DELIM specification ! !  SAL 2012-11-29 !     Checked to make sure iunit > 10 so we don't write to screen. IMPLICIT NONE !----------------------------------------------- !   D u m m y   A r g u m e n t s !----------------------------------------------- INTEGER , INTENT ( inout ) :: iunit INTEGER , INTENT ( out ) :: istat CHARACTER ( LEN =* ), INTENT ( in ) :: filename , filestat , fileform INTEGER , INTENT ( in ), OPTIONAL :: record_in CHARACTER ( LEN =* ), INTENT ( in ), OPTIONAL :: access_in CHARACTER ( LEN =* ), INTENT ( in ), OPTIONAL :: delim_in !----------------------------------------------- !   L o c a l   V a r i a b l e s !----------------------------------------------- CHARACTER ( LEN =* ), PARAMETER :: cdelim = \"apostrophe\" , 1 cform = \"formatted\" , cunform = \"unformatted\" , 2 cscratch = \"scratch\" , cseq = \"sequential\" CHARACTER ( LEN = 10 ) :: acc_type CHARACTER ( LEN = 10 ) :: delim_type LOGICAL :: lopen , lexist , linvalid !----------------------------------------------- !  Start of Executable Code !----------------------------------------------- !----------------------------------------------- ! !     Check that unit is not already opened !     Increment iunit until find one that is not in use ! linvalid = . true . DO WHILE ( linvalid ) IF ( iunit > 10 ) THEN INQUIRE ( iunit , exist = lexist , opened = lopen , iostat = istat ) linvalid = ( istat . ne . 0 . or . . not . lexist ) . or . lopen IF (. not . linvalid ) EXIT END IF iunit = iunit + 1 END DO !  JDH 08-24-2004 This next IF(Present) clause seems to be duplicated below. !  I think one of the two should be eliminated, for clarity. IF ( PRESENT ( access_in )) THEN acc_type = TRIM ( access_in ) ELSE acc_type = cseq END IF !  Why not call this variable lscratch? lexist = ( filestat ( 1 : 1 ). eq . 's' ) . or . ( filestat ( 1 : 1 ). eq . 'S' ) !Scratch file !  JDH 08-24-2004 Below is nearly exact duplicate of IF(Present) clause !  from above IF ( PRESENT ( access_in )) THEN acc_type = TRIM ( access_in ) ELSE acc_type = 'SEQUENTIAL' END IF !  JDH 2010-06-09. Coding for DELIM IF ( PRESENT ( delim_in )) THEN SELECT CASE ( delim_in ( 1 : 1 )) CASE ( 'n' , 'N' ) delim_type = 'none' CASE ( 'q' , 'Q' ) delim_type = 'quote' CASE DEFAULT delim_type = cdelim END SELECT ELSE delim_type = cdelim ENDIF ! Here are the actual OPEN commands. Eight different cases. SELECT CASE ( fileform ( 1 : 1 )) CASE ( 'u' , 'U' ) IF ( PRESENT ( record_in )) THEN IF ( lexist ) THEN ! unformatted, record length specified, scratch OPEN ( unit = iunit , form = cunform , status = cscratch , & & recl = record_in , access = acc_type , iostat = istat ) ELSE ! unformatted, record length specified, non-scratch OPEN ( unit = iunit , file = TRIM ( filename ), form = cunform , & & status = TRIM ( filestat ), recl = record_in , & & access = acc_type , iostat = istat ) END IF ELSE IF ( lexist ) THEN ! unformatted, record length unspecified, scratch OPEN ( unit = iunit , form = cunform , status = cscratch , & & access = acc_type , iostat = istat ) ELSE ! unformatted, record length unspecified, non-scratch OPEN ( unit = iunit , file = TRIM ( filename ), form = cunform , & & status = TRIM ( filestat ), access = acc_type , iostat = istat ) END IF END IF CASE DEFAULT IF ( PRESENT ( record_in )) THEN IF ( lexist ) THEN ! formatted, record length specified, scratch OPEN ( unit = iunit , form = cform , status = cscratch , & & delim = TRIM ( delim_type ), recl = record_in , & & access = acc_type , iostat = istat ) ELSE ! formatted, record length specified, non-scratch OPEN ( unit = iunit , file = TRIM ( filename ), form = cform , & & status = TRIM ( filestat ), delim = TRIM ( delim_type ), & & recl = record_in , access = acc_type , iostat = istat ) END IF ELSE IF ( lexist ) THEN ! formatted, record length unspecified, scratch OPEN ( unit = iunit , form = cform , status = cscratch , & & delim = TRIM ( delim_type ), access = acc_type , & & iostat = istat ) ELSE ! formatted, record length unspecified, non-scratch OPEN ( unit = iunit , file = TRIM ( filename ), form = cform , & & status = TRIM ( filestat ), delim = TRIM ( delim_type ), & & access = acc_type , iostat = istat ) END IF END IF END SELECT END SUBROUTINE safe_open END MODULE safe_open_mod","tags":"","loc":"sourcefile/safe_open_mod.f.html"},{"title":"convert.f90 – stella","text":"Source Code module convert !------------------------------------------------------------------------------ !                              AstroGK, 2009 !------------------------------------------------------------------------------ ! <doc>Convert from complex variable a(d1,d2,d3, ...) to a ! real variable ar(2,d1,d2,d3,...) and back. ! This is necessary for saving complex variables in NetCDF format</doc> ! !     (c) Copyright 1991 to 1998 by Michael A. Beer, William D. Dorland, !     P. B. Snyder, Q. P. Liu, and Gregory W. Hammett. ALL RIGHTS RESERVED. ! implicit none private public :: c2r , r2c interface c2r module procedure x1c2r module procedure x2c2r module procedure x3c2r module procedure x4c2r module procedure x5c2r module procedure x6c2r end interface interface r2c module procedure x1r2c module procedure x2r2c module procedure x3r2c module procedure x4r2c module procedure x5r2c end interface contains !------------------------------------------------------------------------------ !                              AstroGK, 2009 !------------------------------------------------------------------------------ ! subroutine x5c2r ( a , a_ri ) complex , dimension (:, :, :, :, :), intent ( in ) :: a real , dimension (:, :, :, :, :, :), intent ( out ) :: a_ri if ( size ( a , 1 ) /= size ( a_ri , 2 )) call aborter ( 6 , 'x5c2r: size(a, 1) does not match size(a_ri, 2)' ) if ( size ( a , 2 ) /= size ( a_ri , 3 )) call aborter ( 6 , 'x5c2r: size(a, 2) does not match size(a_ri, 3)' ) if ( size ( a , 3 ) /= size ( a_ri , 4 )) call aborter ( 6 , 'x5c2r: size(a, 3) does not match size(a_ri, 4)' ) if ( size ( a , 4 ) /= size ( a_ri , 5 )) call aborter ( 6 , 'x5c2r: size(a, 4) does not match size(a_ri, 5)' ) if ( size ( a , 5 ) /= size ( a_ri , 6 )) call aborter ( 6 , 'x5c2r: size(a, 5) does not match size(a_ri, 6)' ) a_ri ( 1 , :, :, :, :, :) = real ( a (:, :, :, :, :)) a_ri ( 2 , :, :, :, :, :) = aimag ( a (:, :, :, :, :)) end subroutine x5c2r subroutine x6c2r ( a , a_ri ) complex , dimension (:, :, :, :, :, :), intent ( in ) :: a real , dimension (:, :, :, :, :, :, :), intent ( out ) :: a_ri if ( size ( a , 1 ) /= size ( a_ri , 2 )) call aborter ( 6 , 'x6c2r: size(a, 1) does not match size(a_ri, 2)' ) if ( size ( a , 2 ) /= size ( a_ri , 3 )) call aborter ( 6 , 'x6c2r: size(a, 2) does not match size(a_ri, 3)' ) if ( size ( a , 3 ) /= size ( a_ri , 4 )) call aborter ( 6 , 'x6c2r: size(a, 3) does not match size(a_ri, 4)' ) if ( size ( a , 4 ) /= size ( a_ri , 5 )) call aborter ( 6 , 'x6c2r: size(a, 4) does not match size(a_ri, 5)' ) if ( size ( a , 5 ) /= size ( a_ri , 6 )) call aborter ( 6 , 'x6c2r: size(a, 5) does not match size(a_ri, 6)' ) if ( size ( a , 6 ) /= size ( a_ri , 7 )) call aborter ( 6 , 'x6c2r: size(a, 6) does not match size(a_ri, 7)' ) a_ri ( 1 , :, :, :, :, :, :) = real ( a (:, :, :, :, :, :)) a_ri ( 2 , :, :, :, :, :, :) = aimag ( a (:, :, :, :, :, :)) end subroutine x6c2r !------------------------------------------------------------------------------ !                              AstroGK, 2009 !------------------------------------------------------------------------------ ! subroutine x5r2c ( a , a_ri ) real , dimension (:, :, :, :, :, :), intent ( in ) :: a_ri complex , dimension (:, :, :, :, :), intent ( out ) :: a if ( size ( a , 1 ) /= size ( a_ri , 2 )) call aborter ( 6 , 'x5r2c: size(a, 1) does not match size(a_ri, 2)' ) if ( size ( a , 2 ) /= size ( a_ri , 3 )) call aborter ( 6 , 'x5r2c: size(a, 2) does not match size(a_ri, 3)' ) if ( size ( a , 3 ) /= size ( a_ri , 4 )) call aborter ( 6 , 'x5r2c: size(a, 3) does not match size(a_ri, 4)' ) if ( size ( a , 4 ) /= size ( a_ri , 5 )) call aborter ( 6 , 'x5r2c: size(a, 4) does not match size(a_ri, 5)' ) if ( size ( a , 5 ) /= size ( a_ri , 6 )) call aborter ( 6 , 'x5r2c: size(a, 5) does not match size(a_ri, 6)' ) a (:, :, :, :, :) = cmplx ( a_ri ( 1 , :, :, :, :, :), a_ri ( 2 , :, :, :, :, :)) end subroutine x5r2c !------------------------------------------------------------------------------ !                              AstroGK, 2009 !------------------------------------------------------------------------------ ! subroutine x4c2r ( a , a_ri ) complex , dimension (:, :, :, :), intent ( in ) :: a real , dimension (:, :, :, :, :), intent ( out ) :: a_ri if ( size ( a , 1 ) /= size ( a_ri , 2 )) call aborter ( 6 , 'x4c2r: size(a, 1) does not match size(a_ri, 2)' ) if ( size ( a , 2 ) /= size ( a_ri , 3 )) call aborter ( 6 , 'x4c2r: size(a, 2) does not match size(a_ri, 3)' ) if ( size ( a , 3 ) /= size ( a_ri , 4 )) call aborter ( 6 , 'x4c2r: size(a, 3) does not match size(a_ri, 4)' ) if ( size ( a , 4 ) /= size ( a_ri , 5 )) call aborter ( 6 , 'x4c2r: size(a, 4) does not match size(a_ri, 5)' ) a_ri ( 1 , :, :, :, :) = real ( a (:, :, :, :)) a_ri ( 2 , :, :, :, :) = aimag ( a (:, :, :, :)) end subroutine x4c2r !------------------------------------------------------------------------------ !                              AstroGK, 2009 !------------------------------------------------------------------------------ ! subroutine x4r2c ( a , a_ri ) real , dimension (:, :, :, :, :), intent ( in ) :: a_ri complex , dimension (:, :, :, :), intent ( out ) :: a if ( size ( a , 1 ) /= size ( a_ri , 2 )) call aborter ( 6 , 'x4r2c: size(a, 1) does not match size(a_ri, 2)' ) if ( size ( a , 2 ) /= size ( a_ri , 3 )) call aborter ( 6 , 'x4r2c: size(a, 2) does not match size(a_ri, 3)' ) if ( size ( a , 3 ) /= size ( a_ri , 4 )) call aborter ( 6 , 'x4r2c: size(a, 3) does not match size(a_ri, 4)' ) if ( size ( a , 4 ) /= size ( a_ri , 5 )) call aborter ( 6 , 'x4r2c: size(a, 4) does not match size(a_ri, 5)' ) a (:, :, :, :) = cmplx ( a_ri ( 1 , :, :, :, :), a_ri ( 2 , :, :, :, :)) end subroutine x4r2c !------------------------------------------------------------------------------ !                              AstroGK, 2009 !------------------------------------------------------------------------------ ! subroutine x3c2r ( a , a_ri ) complex , dimension (:, :, :), intent ( in ) :: a real , dimension (:, :, :, :), intent ( out ) :: a_ri if ( size ( a , 1 ) /= size ( a_ri , 2 )) call aborter ( 6 , 'x3c2r: size(a, 1) does not match size(a_ri, 2)' ) if ( size ( a , 2 ) /= size ( a_ri , 3 )) call aborter ( 6 , 'x3c2r: size(a, 2) does not match size(a_ri, 3)' ) if ( size ( a , 3 ) /= size ( a_ri , 4 )) call aborter ( 6 , 'x3c2r: size(a, 3) does not match size(a_ri, 4)' ) a_ri ( 1 , :, :, :) = real ( a (:, :, :)) a_ri ( 2 , :, :, :) = aimag ( a (:, :, :)) end subroutine x3c2r !------------------------------------------------------------------------------ !                              AstroGK, 2009 !------------------------------------------------------------------------------ ! subroutine x3r2c ( a , a_ri ) real , dimension (:, :, :, :), intent ( in ) :: a_ri complex , dimension (:, :, :), intent ( out ) :: a if ( size ( a , 1 ) /= size ( a_ri , 2 )) call aborter ( 6 , 'x3r2c: size(a, 1) does not match size(a_ri, 2)' ) if ( size ( a , 2 ) /= size ( a_ri , 3 )) call aborter ( 6 , 'x3r2c: size(a, 2) does not match size(a_ri, 3)' ) if ( size ( a , 3 ) /= size ( a_ri , 4 )) call aborter ( 6 , 'x3r2c: size(a, 3) does not match size(a_ri, 4)' ) a (:, :, :) = cmplx ( a_ri ( 1 , :, :, :), a_ri ( 2 , :, :, :)) end subroutine x3r2c !------------------------------------------------------------------------------ !                              AstroGK, 2009 !------------------------------------------------------------------------------ ! subroutine x2c2r ( a , a_ri ) complex , dimension (:, :), intent ( in ) :: a real , dimension (:, :, :), intent ( out ) :: a_ri if ( size ( a , 1 ) /= size ( a_ri , 2 )) call aborter ( 6 , 'x2c2r: size(a, 1) does not match size(a_ri, 2)' ) if ( size ( a , 2 ) /= size ( a_ri , 3 )) call aborter ( 6 , 'x2c2r: size(a, 2) does not match size(a_ri, 3)' ) a_ri ( 1 , :, :) = real ( a (:, :)) a_ri ( 2 , :, :) = aimag ( a (:, :)) end subroutine x2c2r !------------------------------------------------------------------------------ !                              AstroGK, 2009 !------------------------------------------------------------------------------ ! subroutine x2r2c ( a , a_ri ) real , dimension (:, :, :), intent ( in ) :: a_ri complex , dimension (:, :), intent ( out ) :: a if ( size ( a , 1 ) /= size ( a_ri , 2 )) call aborter ( 6 , 'x2r2c: size(a, 1) does not match size(a_ri, 2)' ) if ( size ( a , 2 ) /= size ( a_ri , 3 )) call aborter ( 6 , 'x2r2c: size(a, 2) does not match size(a_ri, 3)' ) a (:, :) = cmplx ( a_ri ( 1 , :, :), a_ri ( 2 , :, :)) end subroutine x2r2c !------------------------------------------------------------------------------ !                              AstroGK, 2009 !------------------------------------------------------------------------------ ! subroutine x1c2r ( a , a_ri ) complex , dimension (:), intent ( in ) :: a real , dimension (:, :), intent ( out ) :: a_ri if ( size ( a , 1 ) /= size ( a_ri , 2 )) call aborter ( 6 , 'x2c2r: size(a, 1) does not match size(a_ri, 2)' ) a_ri ( 1 , :) = real ( a (:)) a_ri ( 2 , :) = aimag ( a (:)) end subroutine x1c2r !------------------------------------------------------------------------------ !                              AstroGK, 2009 !------------------------------------------------------------------------------ ! subroutine x1r2c ( a , a_ri ) real , dimension (:, :), intent ( in ) :: a_ri complex , dimension (:), intent ( out ) :: a if ( size ( a , 1 ) /= size ( a_ri , 2 )) call aborter ( 6 , 'x2r2c: size(a, 1) does not match size(a_ri, 2)' ) a (:) = cmplx ( a_ri ( 1 , :), a_ri ( 2 , :)) end subroutine x1r2c !------------------------------------------------------------------------------ !                              AstroGK, 2009 !------------------------------------------------------------------------------ ! Subroutine Aborter ( iunit , ierrmsg ) !---------------------------------------------------------------------- !  ABORT A PROGRAM AFTER A FATAL ERROR CONDITION IS DETECTED. ! ! ! input: iunit  Unit Number of the file to write error messages to. !        ierrmsg  An error message to write ilunerr ! !       The advantage of using this subroutine is that it will !       generate a traceback showing the chain of subroutines which !       eventually bombed, and it forces an arithmetic error which !       the job control system can detect as a fatal error. ! character ierrmsg * ( * ) real :: zz0 , zz1 integer :: iunit , ilunerr common / abortcmn / zz0 , zz1 ! ! zz0 is in a common block to prevent an optimizing compiler ! from evaluating 1.0/zz0 during compilation rather than during ! execution. ! write ( iunit , 1001 ) 1001 format ( // ' %ABORTER:  ** FATAL ERROR.  ABORT SUBROUTINE CALLED **' // ) write ( iunit , 1002 ) ierrmsg 1002 format ( 1 x , a , // ) ! on CRAY's and VAXes: ! generate a divide-by-zero error: zz1 = 1.0 / zz0 !&#94; ilunerr = 5 !&#94; ! on the DecStation: !&#94;      call exit(1) write ( ilunerr , 1010 ) zz0 1010 format ( ' ?ABORTER-- ZZ0= ' , 1 PE11 . 4 , ' AND STILL EXECUTING...' ) end subroutine aborter !------------------------------------------------------------------------------ end module convert","tags":"","loc":"sourcefile/convert.f90.html"},{"title":"handle_err.f90 – stella","text":"Source Code subroutine handle_err ( status , nam3 , nam1 , nam2 ) !DEC$ IF DEFINED (NETCDF) include \"netcdf.inc\" INTEGER , intent ( in ) :: status character * ( * ), intent ( in ) :: nam1 , nam2 , nam3 if ( status /= nf_noerr ) then WRITE ( * , 10 ) nam1 , nam2 , nam3 10 format ( '% ' , a , '--E-- A netCDF error has occurred in: ' , a / , 'while processing: ' , a ) print * , nf_strerror ( status ) end if !DEC$ ELSE return !DEC$ ENDIF end subroutine handle_err","tags":"","loc":"sourcefile/handle_err.f90.html"},{"title":"mirror_terms.f90 – stella","text":"Source Code module mirror_terms implicit none public :: mirror_initialized public :: init_mirror , finish_mirror public :: mirror public :: advance_mirror_explicit , advance_mirror_implicit public :: add_mirror_radial_variation public :: time_mirror private !  interface checksum !     module procedure checksum_field !     module procedure checksum_dist !  end interface logical :: mirror_initialized = . false . real , dimension ( 2 , 2 ) :: time_mirror = 0. integer , dimension (:, :), allocatable :: mirror_sign real , dimension (:, :, :, :), allocatable :: mirror real , dimension (:, :, :, :), allocatable :: mirror_rad_var real , dimension (:, :, :), allocatable :: mirror_tri_a , mirror_tri_b , mirror_tri_c real , dimension (:, :, :), allocatable :: mirror_int_fac real , dimension (:, :, :, :), allocatable :: mirror_interp_loc integer , dimension (:, :, :, :), allocatable :: mirror_interp_idx_shift complex , dimension (:, :, :, :), allocatable :: response_apar_denom contains subroutine init_mirror use stella_time , only : code_dt use species , only : spec , nspec use vpamu_grids , only : nmu use vpamu_grids , only : mu use zgrid , only : nzgrid , nztot use kt_grids , only : nalpha use stella_geometry , only : dbdzed , b_dot_grad_z , gfac use stella_geometry , only : d2Bdrdth , dgradpardrho use neoclassical_terms , only : include_neoclassical_terms use neoclassical_terms , only : dphineo_dzed use run_parameters , only : mirror_implicit , mirror_semi_lagrange use physics_flags , only : include_apar use physics_flags , only : include_mirror , radial_variation implicit none integer :: iz , ia , imu real , dimension (:, :), allocatable :: neoclassical_term if ( mirror_initialized ) return mirror_initialized = . true . if (. not . allocated ( mirror )) allocate ( mirror ( nalpha , - nzgrid : nzgrid , nmu , nspec )); mirror = 0. if (. not . allocated ( mirror_sign )) allocate ( mirror_sign ( nalpha , - nzgrid : nzgrid )); mirror_sign = 0 allocate ( neoclassical_term ( - nzgrid : nzgrid , nspec )) if ( include_neoclassical_terms ) then neoclassical_term = spread ( dphineo_dzed ( 1 , :), 2 , nspec ) * spread ( spec % zt_psi0 , 1 , nztot ) * 0.5 else neoclassical_term = 0. end if !> mirror has sign consistent with being on RHS of GKE; !> it is the factor multiplying dg/dvpa in the mirror term if ( include_mirror ) then do imu = 1 , nmu do ia = 1 , nalpha do iz = - nzgrid , nzgrid mirror ( ia , iz , imu , :) = code_dt * spec % stm_psi0 * b_dot_grad_z ( ia , iz ) & * ( mu ( imu ) * dbdzed ( ia , iz ) + neoclassical_term ( iz , :)) end do end do end do else mirror = 0. end if deallocate ( neoclassical_term ) if ( radial_variation ) then if (. not . allocated ( mirror_rad_var )) then allocate ( mirror_rad_var ( nalpha , - nzgrid : nzgrid , nmu , nspec )); mirror_rad_var = 0. end if !FLAG should include neoclassical corrections here? do imu = 1 , nmu do ia = 1 , nalpha do iz = - nzgrid , nzgrid mirror_rad_var ( ia , iz , imu , :) = code_dt * spec % stm_psi0 * mu ( imu ) * gfac & * ( dgradpardrho ( iz ) * dbdzed ( ia , iz ) & + b_dot_grad_z ( ia , iz ) * d2Bdrdth ( iz )) end do end do end do end if do ia = 1 , nalpha !> mirror_sign set to +/- 1 depending on the sign of the mirror term. !> NB: mirror_sign = -1 corresponds to positive advection velocity do iz = - nzgrid , nzgrid mirror_sign ( ia , iz ) = int ( sign ( 1.0 , mirror ( ia , iz , 1 , 1 ))) end do end do if ( mirror_implicit ) then if ( mirror_semi_lagrange ) then call init_mirror_semi_lagrange else !> set up the tridiagonal matrix that must be inverted !> for the implicit treatment of the mirror operator call init_invert_mirror_operator ! if advancing apar, need to get response of pdf to unit impulse in apar if ( include_apar ) call init_mirror_response end if end if end subroutine init_mirror subroutine init_mirror_semi_lagrange use zgrid , only : nzgrid use vpamu_grids , only : nmu , dvpa use species , only : nspec use kt_grids , only : nalpha implicit none if (. not . allocated ( mirror_interp_idx_shift )) & allocate ( mirror_interp_idx_shift ( nalpha , - nzgrid : nzgrid , nmu , nspec )) if (. not . allocated ( mirror_interp_loc )) & allocate ( mirror_interp_loc ( nalpha , - nzgrid : nzgrid , nmu , nspec )) mirror_interp_idx_shift = int ( mirror / dvpa ) mirror_interp_loc = abs ( mod ( mirror , dvpa )) / dvpa ! f at shifted vpa ! is f(iv+idx_shift)*(1-mirror_interp_loc) ! + f(iv+idx_shift + mirror_sign)*mirror_interp_loc end subroutine init_mirror_semi_lagrange subroutine init_invert_mirror_operator use mp , only : mp_abort use stella_layouts , only : kxkyz_lo , kxyz_lo , vmu_lo use stella_layouts , only : iz_idx , is_idx , imu_idx , iv_idx , iy_idx use zgrid , only : nzgrid use vpamu_grids , only : dvpa , vpa , mu use vpamu_grids , only : nvpa , nmu use physics_flags , only : full_flux_surface use species , only : spec use kt_grids , only : nalpha use stella_geometry , only : dbdzed use neoclassical_terms , only : include_neoclassical_terms use neoclassical_terms , only : dphineo_dzed use run_parameters , only : vpa_upwind , time_upwind use run_parameters , only : maxwellian_normalization implicit none integer :: sgn integer :: iy , iz , is , imu , iv integer :: ivmu , ikxkyz , ikxyz integer :: llim , ulim real :: tupwndfac , zero real , dimension (:, :), allocatable :: a , b , c zero = 10 0. * epsilon ( 0. ) !> mirror_int_fac = exp(vpa&#94;2 * (mu*dB/dz)/(mu*dB/dz + Z*e*dpihnc/dz)) !> is the integrating factor needed to turn the dg/dvpa part of the GKE advance !> into an advection equation if (. not . allocated ( mirror_int_fac )) then if ( include_neoclassical_terms ) then allocate ( mirror_int_fac ( nalpha , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) do iy = 1 , nalpha where ( abs ( mu ( imu ) * dbdzed ( iy , :)) > zero ) mirror_int_fac ( iy , :, ivmu ) = exp ( vpa ( iv ) ** 2 * mu ( imu ) * dbdzed ( iy , :) & / ( mu ( imu ) * dbdzed ( iy , :) + spec ( is )% zt_psi0 * dphineo_dzed ( 1 , :) * 0.5 )) elsewhere mirror_int_fac ( iy , :, ivmu ) = 1.0 end where end do end do else ! mirror_int_fac should never be used in this case allocate ( mirror_int_fac ( 1 , 1 , 1 )); mirror_int_fac = 0. end if end if !> a, b and c contain the sub-, main- and super-diagonal terms, respectively allocate ( a ( nvpa , - 1 : 1 )); a = 0. allocate ( b ( nvpa , - 1 : 1 )); b = 0. allocate ( c ( nvpa , - 1 : 1 )); c = 0. if (. not . allocated ( mirror_tri_a )) then !> if running in full-flux-surface mode, solve mirror advance !> in y-space rather than ky-space due to alpha-dependence of coefficients if ( full_flux_surface ) then llim = kxyz_lo % llim_proc ulim = kxyz_lo % ulim_alloc else llim = kxkyz_lo % llim_proc ulim = kxkyz_lo % ulim_alloc end if allocate ( mirror_tri_a ( nvpa , nmu , llim : ulim )); mirror_tri_a = 0. allocate ( mirror_tri_b ( nvpa , nmu , llim : ulim )); mirror_tri_b = 0. allocate ( mirror_tri_c ( nvpa , nmu , llim : ulim )); mirror_tri_c = 0. end if !> corresponds to sign of mirror term positive on RHS of equation a ( 2 :, 1 ) = - 0.5 * ( 1.0 - 2.0 * vpa_upwind ) / dvpa b ( 2 :, 1 ) = - 2.0 * vpa_upwind / dvpa c ( 2 : nvpa - 1 , 1 ) = 0.5 * ( 1.0 + 2.0 * vpa_upwind ) / dvpa !> must treat boundary carefully !> assumes fully upwinded at outgoing boundary b ( 1 , 1 ) = - 1.0 / dvpa c ( 1 , 1 ) = 1.0 / dvpa !> corresponds to sign of mirror term negative on RHS of equation a ( 2 : nvpa - 1 , - 1 ) = - 0.5 * ( 1.0 + 2.0 * vpa_upwind ) / dvpa b (: nvpa - 1 , - 1 ) = 2.0 * vpa_upwind / dvpa c (: nvpa - 1 , - 1 ) = 0.5 * ( 1.0 - 2.0 * vpa_upwind ) / dvpa !> must treat boundary carefully !> assumes fully upwinded at outgoing boundary a ( nvpa , - 1 ) = - 1.0 / dvpa b ( nvpa , - 1 ) = 1.0 / dvpa !> time_upwind = 0.0 corresponds to centered in time !> time_upwind = 1.0 corresponds to fully implicit (upwinded) tupwndfac = 0.5 * ( 1.0 + time_upwind ) a = a * tupwndfac c = c * tupwndfac if ( maxwellian_normalization ) then !> account for fact that we have expanded d(gnorm)/dvpa, where gnorm = g/exp(-v&#94;s); !> this gives rise to d(gnorm*exp(-vpa&#94;2))/dvpa + 2*vpa*gnorm*exp(-vpa&#94;2) term !> we solve for gnorm*exp(-vpa&#94;2) and later multiply by exp(vpa&#94;2) to get gnorm b = b + spread ( 2.0 * vpa , 2 , 3 ) end if if ( full_flux_surface ) then do ikxyz = kxyz_lo % llim_proc , kxyz_lo % ulim_proc iy = iy_idx ( kxyz_lo , ikxyz ) iz = iz_idx ( kxyz_lo , ikxyz ) is = is_idx ( kxyz_lo , ikxyz ) sgn = mirror_sign ( iy , iz ) do imu = 1 , nmu do iv = 1 , nvpa mirror_tri_a ( iv , imu , ikxyz ) = - a ( iv , sgn ) * mirror ( iy , iz , imu , is ) mirror_tri_b ( iv , imu , ikxyz ) = 1.0 - b ( iv , sgn ) * mirror ( iy , iz , imu , is ) * tupwndfac mirror_tri_c ( iv , imu , ikxyz ) = - c ( iv , sgn ) * mirror ( iy , iz , imu , is ) end do end do end do else !> multiply by mirror coefficient do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iy = 1 iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) sgn = mirror_sign ( iy , iz ) do imu = 1 , nmu do iv = 1 , nvpa mirror_tri_a ( iv , imu , ikxkyz ) = - a ( iv , sgn ) * mirror ( iy , iz , imu , is ) mirror_tri_b ( iv , imu , ikxkyz ) = 1.0 - b ( iv , sgn ) * mirror ( iy , iz , imu , is ) * tupwndfac mirror_tri_c ( iv , imu , ikxkyz ) = - c ( iv , sgn ) * mirror ( iy , iz , imu , is ) end do end do end do end if deallocate ( a , b , c ) end subroutine init_invert_mirror_operator subroutine init_mirror_response use stella_layouts , only : kxkyz_lo use zgrid , only : nzgrid , ntubes use vpamu_grids , only : nmu , nvpa use kt_grids , only : naky , nakx use fields , only : advance_apar implicit none complex :: apar integer :: ikxkyz , imu complex , dimension (:), allocatable :: rhs complex , dimension (:, :, :), allocatable :: mirror_response_g character ( 5 ) :: dist allocate ( rhs ( nvpa )) allocate ( mirror_response_g ( nvpa , nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) if (. not . allocated ( response_apar_denom )) then allocate ( response_apar_denom ( naky , nakx , - nzgrid : nzgrid , ntubes )) end if ! give unit impulse to apar and solve for g (stored in mirror_response_g) apar = 1.0 do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc do imu = 1 , nmu ! calculate the rhs of the 'homogeneous' mirror advance equation call get_mirror_rhs_apar_contribution ( rhs , apar , imu , ikxkyz ) ! invert the mirror operator and replace rhs with the solution call invert_mirror_operator ( imu , ikxkyz , rhs ) ! store the solution in mirror_response_g mirror_response_g (:, imu , ikxkyz ) = rhs end do end do ! calculate the contribution to apar from mirror_response_g dist = 'g' call advance_apar ( mirror_response_g , dist , response_apar_denom ) ! response_apar_denom is the thing that the inhomogeneous contribution to apar ! must be divided by to obtain the total apar; i.e., apar = apar_inh + apar_h, ! and apar_h is proportional to apar, so (1 - apar_h / apar) * apar = apar_inh response_apar_denom = 1.0 - response_apar_denom deallocate ( rhs , mirror_response_g ) end subroutine init_mirror_response !> advance_mirror_explicit calculates the contribution to the RHS of the gyrokinetic equation !> due to the mirror force term; it treats all terms explicitly in time subroutine advance_mirror_explicit ( g , gout ) use mp , only : proc0 use redistribute , only : gather , scatter use dist_fn_arrays , only : gvmu use job_manage , only : time_message use stella_layouts , only : kxyz_lo , kxkyz_lo , vmu_lo use stella_layouts , only : iv_idx , is_idx use stella_transforms , only : transform_ky2y use zgrid , only : nzgrid , ntubes use physics_flags , only : full_flux_surface use kt_grids , only : nakx , naky , naky_all , ny , ikx_max use kt_grids , only : swap_kxky use vpamu_grids , only : nvpa , nmu use vpamu_grids , only : vpa , maxwell_vpa use run_parameters , only : fields_kxkyz , maxwellian_normalization use dist_redistribute , only : kxkyz2vmu , kxyz2vmu implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: gout complex , dimension (:, :, :), allocatable :: g0v complex , dimension (:, :, :, :, :), allocatable :: g0x complex , dimension (:, :), allocatable :: dgdv , g_swap integer :: ikxyz , iz , it integer :: ivmu , iv , imu , is !> start the timer for this subroutine if ( proc0 ) call time_message (. false ., time_mirror (:, 1 ), ' Mirror advance' ) if ( full_flux_surface ) then !> assume we are simulating a single flux surface it = 1 allocate ( g0v ( nvpa , nmu , kxyz_lo % llim_proc : kxyz_lo % ulim_alloc )) allocate ( g0x ( ny , ikx_max , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) allocate ( dgdv ( nvpa , nmu )) allocate ( g_swap ( naky_all , ikx_max )) do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do iz = - nzgrid , nzgrid !> swap from ky >= 0 and all kx to kx >= 0 and all ky !> needed for ky2y transform below call swap_kxky ( g (:, :, iz , it , ivmu ), g_swap ) !> for upwinding of vpa, need to evaluate dg/dvpa in y-space !> this is necessary because the advection speed contains dB/dz, which depends on y !> first must take g(ky,kx) and transform to g(y,kx) call transform_ky2y ( g_swap , g0x (:, :, iz , it , ivmu )) end do end do !> remap g so velocities are local call scatter ( kxyz2vmu , g0x , g0v ) !> next, calculate dg/dvpa; !> we enforce a boundary condition on <f>, but with full_flux_surface = T, !> g = <f> / F, so we use the chain rule to get two terms: !> one with exp(vpa&#94;2)*d<f>/dvpa and another that is proportional to exp(vpa&#94;2) * <f>/F * d ln F /dvpa do ikxyz = kxyz_lo % llim_proc , kxyz_lo % ulim_proc is = is_idx ( kxyz_lo , ikxyz ) !> remove exp(-vpa&#94;2) normalisation from g before differentiating do imu = 1 , nmu dgdv (:, imu ) = g0v (:, imu , ikxyz ) * maxwell_vpa (:, is ) end do !> get d <f> / dvpa call get_dgdvpa_ffs ( dgdv , ikxyz ) do iv = 1 , nvpa g0v ( iv , :, ikxyz ) = dgdv ( iv , :) / maxwell_vpa ( iv , is ) + 2.0 * vpa ( iv ) * g0v ( iv , :, ikxyz ) end do end do !> then take the results and remap again so y,kx,z local. call gather ( kxyz2vmu , g0v , g0x ) !> finally add the mirror term to the RHS of the GK eqn call add_mirror_term_ffs ( g0x , gout ) deallocate ( dgdv , g_swap ) else allocate ( g0v ( nvpa , nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) allocate ( g0x ( naky , nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) if (. not . fields_kxkyz ) then if ( proc0 ) call time_message (. false ., time_mirror (:, 2 ), ' mirror_redist' ) call scatter ( kxkyz2vmu , g , gvmu ) if ( proc0 ) call time_message (. false ., time_mirror (:, 2 ), ' mirror_redist' ) end if ! incoming gvmu is g = <f> ! get dg/dvpa and store in g0v g0v = gvmu ! remove exp(-vpa&#94;2) normalization from pdf before differentiating if ( maxwellian_normalization ) then do iv = 1 , nvpa g0v ( iv , :, :) = g0v ( iv , :, :) * maxwell_vpa ( iv , 1 ) end do end if call get_dgdvpa_explicit ( g0v ) if ( maxwellian_normalization ) then do iv = 1 , nvpa g0v ( iv , :, :) = g0v ( iv , :, :) / maxwell_vpa ( iv , 1 ) + 2.0 * vpa ( iv ) * gvmu ( iv , :, :) end do end if ! swap layouts so that (z,kx,ky) are local if ( proc0 ) call time_message (. false ., time_mirror (:, 2 ), ' mirror_redist' ) call gather ( kxkyz2vmu , g0v , g0x ) if ( proc0 ) call time_message (. false ., time_mirror (:, 2 ), ' mirror_redist' ) ! get mirror term and add to source call add_mirror_term ( g0x , gout ) end if deallocate ( g0x , g0v ) if ( proc0 ) call time_message (. false ., time_mirror (:, 1 ), ' Mirror advance' ) end subroutine advance_mirror_explicit subroutine add_mirror_radial_variation ( g , gout ) use mp , only : proc0 use redistribute , only : gather , scatter use dist_fn_arrays , only : gvmu use job_manage , only : time_message use stella_layouts , only : kxkyz_lo , vmu_lo use stella_layouts , only : is_idx , imu_idx use zgrid , only : nzgrid , ntubes use physics_flags , only : full_flux_surface use vpamu_grids , only : nvpa , nmu use run_parameters , only : fields_kxkyz use dist_redistribute , only : kxkyz2vmu implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: gout complex , dimension (:, :, :), allocatable :: g0v integer :: iz , it , imu , is , ivmu , ia allocate ( g0v ( nvpa , nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) !if (proc0) call time_message(.false.,time_mirror(:,1),' Mirror global variation advance') ia = 1 ! the mirror term is most complicated of all when doing full flux surface if ( full_flux_surface ) then ! FLAG DSO - Someday one should be able to do full global else if (. not . fields_kxkyz ) then if ( proc0 ) call time_message (. false ., time_mirror (:, 2 ), ' mirror_redist' ) call scatter ( kxkyz2vmu , g , gvmu ) if ( proc0 ) call time_message (. false ., time_mirror (:, 2 ), ' mirror_redist' ) end if ! get dg/dvpa and store in g0v g0v = gvmu call get_dgdvpa_explicit ( g0v ) ! swap layouts so that (z,kx,ky) are local if ( proc0 ) call time_message (. false ., time_mirror (:, 2 ), ' mirror_redist' ) call gather ( kxkyz2vmu , g0v , gout ) if ( proc0 ) call time_message (. false ., time_mirror (:, 2 ), ' mirror_redist' ) ! get mirror term and add to source do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) do it = 1 , ntubes do iz = - nzgrid , nzgrid gout (:, :, iz , it , ivmu ) = gout (:, :, iz , it , ivmu ) & * mirror_rad_var ( ia , iz , imu , is ) end do end do end do end if deallocate ( g0v ) !if (proc0) call time_message(.false.,time_mirror(:,1),' Mirror global variation advance') end subroutine add_mirror_radial_variation subroutine get_dgdvpa_ffs ( g , ikxyz ) use finite_differences , only : third_order_upwind use stella_layouts , only : kxyz_lo , iz_idx , iy_idx , is_idx use vpamu_grids , only : nvpa , nmu , dvpa implicit none complex , dimension (:, :), intent ( in out ) :: g integer , intent ( in ) :: ikxyz integer :: imu , iz , iy , is complex , dimension (:), allocatable :: tmp allocate ( tmp ( nvpa )) iz = iz_idx ( kxyz_lo , ikxyz ) iy = iy_idx ( kxyz_lo , ikxyz ) is = is_idx ( kxyz_lo , ikxyz ) do imu = 1 , nmu ! tmp is dg/dvpa call third_order_upwind ( 1 , g (:, imu ), dvpa , mirror_sign ( iy , iz ), tmp ) g (:, imu ) = tmp end do deallocate ( tmp ) end subroutine get_dgdvpa_ffs subroutine get_dgdvpa_explicit ( g ) use finite_differences , only : third_order_upwind use stella_layouts , only : kxkyz_lo , iz_idx , is_idx use vpamu_grids , only : nvpa , nmu , dvpa implicit none complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( in out ) :: g integer :: ikxkyz , imu , iz , is complex , dimension (:), allocatable :: tmp allocate ( tmp ( nvpa )) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) do imu = 1 , nmu call third_order_upwind ( 1 , g (:, imu , ikxkyz ), dvpa , mirror_sign ( 1 , iz ), tmp ) g (:, imu , ikxkyz ) = tmp end do end do deallocate ( tmp ) end subroutine get_dgdvpa_explicit subroutine add_mirror_term ( g , src ) use stella_layouts , only : vmu_lo use stella_layouts , only : imu_idx , is_idx use zgrid , only : nzgrid , ntubes use kt_grids , only : nakx implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: src integer :: imu , is , ivmu integer :: it , iz , ikx do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) do it = 1 , ntubes do iz = - nzgrid , nzgrid do ikx = 1 , nakx src (:, ikx , iz , it , ivmu ) = src (:, ikx , iz , it , ivmu ) + mirror ( 1 , iz , imu , is ) * g (:, ikx , iz , it , ivmu ) end do end do end do end do end subroutine add_mirror_term subroutine add_mirror_term_ffs ( g , src ) use stella_layouts , only : vmu_lo use stella_layouts , only : imu_idx , is_idx use zgrid , only : nzgrid , ntubes use kt_grids , only : ikx_max implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: src integer :: imu , is , ivmu integer :: it , iz , ikx do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) do it = 1 , ntubes do iz = - nzgrid , nzgrid do ikx = 1 , ikx_max src (:, ikx , iz , it , ivmu ) = src (:, ikx , iz , it , ivmu ) + mirror (:, iz , imu , is ) * g (:, ikx , iz , it , ivmu ) end do end do end do end do end subroutine add_mirror_term_ffs ! advance mirror implicit solve dg/dt = mu/m * bhat . grad B (dg/dvpa + m*vpa/T * g) subroutine advance_mirror_implicit ( collisions_implicit , g , apar ) use constants , only : zi use mp , only : proc0 use job_manage , only : time_message use redistribute , only : gather , scatter use finite_differences , only : fd_variable_upwinding_vpa use stella_layouts , only : vmu_lo , kxyz_lo , kxkyz_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , it_idx , is_idx use stella_layouts , only : iv_idx , imu_idx use stella_transforms , only : transform_ky2y , transform_y2ky use zgrid , only : nzgrid , ntubes use dist_fn_arrays , only : gvmu use physics_flags , only : full_flux_surface use kt_grids , only : ny , nakx use vpamu_grids , only : nvpa , nmu use vpamu_grids , only : maxwell_vpa use neoclassical_terms , only : include_neoclassical_terms use run_parameters , only : vpa_upwind use run_parameters , only : mirror_semi_lagrange , maxwellian_normalization use physics_flags , only : include_apar use dist_redistribute , only : kxkyz2vmu , kxyz2vmu use fields , only : advance_apar , fields_updated use g_tofrom_h , only : gbar_to_g implicit none logical , intent ( in ) :: collisions_implicit complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( in out ) :: apar integer :: ikxyz , ikxkyz , ivmu integer :: iky , ikx , iz , it , is integer :: iv , imu character ( 5 ) :: dist complex , dimension (:), allocatable :: rhs complex , dimension (:, :, :), allocatable :: g0v complex , dimension (:, :, :, :, :), allocatable :: g0x if ( proc0 ) call time_message (. false ., time_mirror (:, 1 ), ' Mirror advance' ) ! incoming pdf is g = <f> dist = 'g' ! FLAG -- STILL NEED TO IMPLEMENT VARIABLE TIME UPWINDING ! FOR FULL_FLUX_SURFACE ! now that we have g&#94;{*}, need to solve ! g&#94;{n+1} = g&#94;{*} - dt*mu*bhat . grad B d((h&#94;{n+1}+h&#94;{*})/2)/dvpa ! define A_0&#94;{-1} = dt*mu*bhat.gradB/2 ! so that (A_0 + I)h&#94;{n+1} = (A_0-I)h&#94;{*} ! will need (I-A_0&#94;{-1})h&#94;{*} in Sherman-Morrison approach ! to invert and obtain h&#94;{n+1} if ( full_flux_surface ) then ! if implicit treatment of collisions, then already have updated gvmu in kxkyz_lo if (. not . collisions_implicit ) then ! get g&#94;{*} with v-space on processor if ( proc0 ) call time_message (. false ., time_mirror (:, 2 ), ' mirror_redist' ) call scatter ( kxkyz2vmu , g , gvmu ) if ( proc0 ) call time_message (. false ., time_mirror (:, 2 ), ' mirror_redist' ) end if allocate ( g0v ( nvpa , nmu , kxyz_lo % llim_proc : kxyz_lo % ulim_alloc )) allocate ( g0x ( ny , nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) ! for upwinding, need to evaluate dg&#94;{*}/dvpa in y-space ! first must take g&#94;{*}(ky) and transform to g&#94;{*}(y) call transform_ky2y ( g , g0x ) write ( * , * ) 'WARNING: full_flux_surface not working in implicit_mirror advance!' ! convert g to g*(integrating factor), as this is what is being advected ! integrating factor = exp(m*vpa&#94;2/2T * (mu*dB/dz) / (mu*dB/dz + Z*e*dphinc/dz)) ! if dphinc/dz=0, simplifies to exp(m*vpa&#94;2/2T) if ( include_neoclassical_terms ) then do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid do ikx = 1 , nakx g0x (:, ikx , iz , it , ivmu ) = g0x (:, ikx , iz , it , ivmu ) * mirror_int_fac (:, iz , ivmu ) end do end do end do end do else do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) g0x (:, :, :, :, ivmu ) = g0x (:, :, :, :, ivmu ) / maxwell_vpa ( iv , is ) end do end if ! second, remap g so velocities are local call scatter ( kxyz2vmu , g0x , g0v ) do ikxyz = kxyz_lo % llim_proc , kxyz_lo % ulim_proc do imu = 1 , nmu call invert_mirror_operator ( imu , ikxyz , g0v (:, imu , ikxyz )) end do end do ! then take the results and remap again so y,kx,z local. call gather ( kxyz2vmu , g0v , g0x ) ! convert back from g*(integrating factor) to g ! integrating factor = exp(m*vpa&#94;2/2T * (mu*dB/dz) / (mu*dB/dz + Z*e*dphinc/dz)) ! if dphinc/dz=0, simplifies to exp(m*vpa&#94;2/2T) if ( include_neoclassical_terms ) then do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid do ikx = 1 , nakx g0x (:, ikx , iz , it , ivmu ) = g0x (:, ikx , iz , it , ivmu ) / mirror_int_fac (:, iz , ivmu ) end do end do end do end do else do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) g0x (:, :, :, :, ivmu ) = g0x (:, :, :, :, ivmu ) * maxwell_vpa ( iv , is ) end do end if ! finally transform back from y to ky space call transform_y2ky ( g0x , g ) else ! if implicit treatment of collisions, then already have updated gvmu in kxkyz_lo if (. not . collisions_implicit ) then ! get g&#94;{*} with v-space on processor if ( proc0 ) call time_message (. false ., time_mirror (:, 2 ), ' mirror_redist' ) call scatter ( kxkyz2vmu , g , gvmu ) if ( proc0 ) call time_message (. false ., time_mirror (:, 2 ), ' mirror_redist' ) end if allocate ( g0v ( nvpa , nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) allocate ( g0x ( 1 , 1 , 1 , 1 , 1 )) if ( mirror_semi_lagrange ) then call vpa_interpolation ( gvmu , g0v ) else allocate ( rhs ( nvpa )) ! remove exp(-vpa&#94;2) normalization from pdf before differentiating if ( maxwellian_normalization ) then do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc is = is_idx ( kxkyz_lo , ikxkyz ) gvmu (:, :, ikxkyz ) = gvmu (:, :, ikxkyz ) * spread ( maxwell_vpa (:, is ), 2 , nmu ) end do end if ! if fields are not updated, then update apar before converting from g to gbar ! in get_mirror_rhs_g_contribution below if ( include_apar . and . . not . fields_updated ) call advance_apar ( gvmu , dist , apar ) do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) do imu = 1 , nmu ! calculate the contribution to the mirror advance due to source terms ! involving the particle distribution function call get_mirror_rhs_g_contribution ( gvmu (:, imu , ikxkyz ), apar ( iky , ikx , iz , it ), imu , ikxkyz , rhs ) ! invert_mirror_operator takes rhs of equation and ! returns g&#94;{n+1} call invert_mirror_operator ( imu , ikxkyz , rhs ) g0v (:, imu , ikxkyz ) = rhs end do end do ! if not advancing apar, g0v now contains the updated pdf, g. ! if advanceing apar, g0v contains the 'inhomogeneous' pdf, g_{inh} if ( include_apar ) then ! if advancing apar, need to calculate the contribution to apar from g0v, which is the solution to the 'inhomogenous' equation call advance_apar ( g0v , dist , apar ) ! the total apar is the above contribution from the 'inhomogeneous' apar / response_apar_denom, ! with the denominator pre-calculated using a response matrix approach; in this case, ! the response matrix is diagonal, so it is just a scalar divide apar = apar / response_apar_denom do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) do imu = 1 , nmu ! now that we have apar at the future time level, use it to solve for g; ! first get the rhs of the 'homogeneous' equation, which only has ! contributions from terms proportional to apar call get_mirror_rhs_apar_contribution ( rhs , apar ( iky , ikx , iz , it ), imu , ikxkyz ) ! invert the mirror operator to find the 'homogeneous' solution call invert_mirror_operator ( imu , ikxkyz , rhs ) ! add the 'homogeneous' solution to the 'inhomogeneous' one found above ! to get g = <f> at the future time step g0v (:, imu , ikxkyz ) = g0v (:, imu , ikxkyz ) + rhs end do end do end if ! re-insert maxwellian normalization if ( maxwellian_normalization ) then do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc is = is_idx ( kxkyz_lo , ikxkyz ) g0v (:, :, ikxkyz ) = g0v (:, :, ikxkyz ) / spread ( maxwell_vpa (:, is ), 2 , nmu ) end do end if deallocate ( rhs ) end if ! then take the results and remap again so ky,kx,z local. if ( proc0 ) call time_message (. false ., time_mirror (:, 2 ), ' mirror_redist' ) call gather ( kxkyz2vmu , g0v , g ) if ( proc0 ) call time_message (. false ., time_mirror (:, 2 ), ' mirror_redist' ) end if deallocate ( g0x , g0v ) if ( proc0 ) call time_message (. false ., time_mirror , ' Mirror advance' ) end subroutine advance_mirror_implicit subroutine get_mirror_rhs_g_contribution ( g_in , apar , imu , ikxkyz , rhs ) use physics_flags , only : include_apar use run_parameters , only : vpa_upwind , time_upwind_minus use run_parameters , only : maxwellian_normalization use g_tofrom_h , only : gbar_to_g use stella_layouts , only : kxkyz_lo , iz_idx , is_idx use finite_differences , only : fd_variable_upwinding_vpa use vpamu_grids , only : dvpa , vpa , nvpa use fields_arrays , only : phi implicit none complex , dimension (:), intent ( in ) :: g_in complex , intent ( in ) :: apar integer , intent ( in ) :: imu , ikxkyz complex , dimension (:), intent ( out ) :: rhs integer :: iz , is complex , dimension (:), allocatable :: dgdv iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) ! the incoming pdf is g = <f> rhs = g_in ! when advancing apar, need to compute g&#94;{n+1} = gbar&#94;{n} + dt * dg/dvpa * (...) ! the vpa derivative appearing on the RHS of the mirror equation ! should be operating on g, so need to have both gbar and g. ! NB: changes may need to be made to this call to gbar_to_g if using ! maxwellian_normalization; not worried aobut it too much yet, as not ! sure if it will ever be in use here if ( include_apar ) then ! rhs is converted from g to gbar call gbar_to_g ( rhs , apar , imu , ikxkyz , - 1.0 ) end if ! calculate dg/dvpa allocate ( dgdv ( nvpa )) call fd_variable_upwinding_vpa ( 1 , g_in , dvpa , & mirror_sign ( 1 , iz ), vpa_upwind , dgdv ) ! construct RHS of GK equation for mirror advance; ! i.e., (1-(1+alph)/2*dt*mu/m*b.gradB*(d/dv+m*vpa/T))*g&#94;{n+1} ! = RHS = (1+(1-alph)/2*dt*mu/m*b.gradB*(d/dv+m*vpa/T))*g&#94;{n} if ( maxwellian_normalization ) then rhs = rhs + time_upwind_minus * mirror ( 1 , iz , imu , is ) * ( dgdv + 2.0 * vpa * g_in ) else rhs = rhs + time_upwind_minus * mirror ( 1 , iz , imu , is ) * dgdv end if deallocate ( dgdv ) end subroutine get_mirror_rhs_g_contribution subroutine get_mirror_rhs_apar_contribution ( rhs , apar , imu , ikxkyz ) use species , only : spec use vpamu_grids , only : nvpa use vpamu_grids , only : maxwell_vpa , maxwell_mu , vpa use run_parameters , only : maxwellian_normalization use stella_layouts , only : kxkyz_lo , is_idx , iz_idx use gyro_averages , only : gyro_average implicit none complex , dimension (:), intent ( out ) :: rhs complex , intent ( in ) :: apar integer , intent ( in ) :: imu , ikxkyz integer :: ia , iz , is real :: pre_factor complex , dimension (:), allocatable :: vpa_scratch allocate ( vpa_scratch ( nvpa )) is = is_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) ia = 1 pre_factor = - 2.0 * spec ( is )% zt * spec ( is )% stm_psi0 call gyro_average ( pre_factor * vpa * apar , imu , ikxkyz , vpa_scratch ) if (. not . maxwellian_normalization ) then vpa_scratch = vpa_scratch * maxwell_vpa (:, is ) * maxwell_mu ( ia , iz , imu , is ) end if rhs = vpa_scratch deallocate ( vpa_scratch ) end subroutine get_mirror_rhs_apar_contribution subroutine vpa_interpolation ( grid , interp ) use vpamu_grids , only : nvpa , nmu use stella_layouts , only : kxkyz_lo use stella_layouts , only : iz_idx , is_idx use run_parameters , only : mirror_linear_interp implicit none complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( in ) :: grid complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( out ) :: interp integer :: ikxkyz , iz , is , iv , imu integer :: shift , sgn , llim , ulim real :: fac0 , fac1 , fac2 , fac3 real :: tmp0 , tmp1 , tmp2 , tmp3 if ( mirror_linear_interp ) then do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) do imu = 1 , nmu shift = mirror_interp_idx_shift ( 1 , iz , imu , is ) sgn = mirror_sign ( 1 , iz ) if ( sgn > 0 ) then llim = 1 ulim = nvpa - 1 - shift else llim = nvpa ulim = 2 - shift end if fac1 = 1.0 - mirror_interp_loc ( 1 , iz , imu , is ) fac2 = mirror_interp_loc ( 1 , iz , imu , is ) do iv = llim , ulim , sgn interp ( iv , imu , ikxkyz ) = grid ( iv + shift , imu , ikxkyz ) * fac1 & + grid ( iv + shift + sgn , imu , ikxkyz ) * fac2 end do ! either assume BC for g is zero beyond grid extrema ! or dg/dvpa is zero beyond grid extrema ! at boundary cell, use zero incoming BC for point just beyond boundary interp ( ulim + sgn , imu , ikxkyz ) = grid ( ulim + shift + sgn , imu , ikxkyz ) * fac1 ! use zero incoming BC for cells beyond +/- nvgrid if ( shift > 0 ) then !                   interp(nvpa-shift+1:,imu,ikxkyz) = 0. do iv = nvpa - shift , nvpa interp ( iv , imu , ikxkyz ) = grid ( nvpa , imu , ikxkyz ) * real ( nvpa - iv ) / real ( shift + 1 ) end do else if ( shift < 0 ) then !                   interp(:-shift,imu,ikxkyz) = 0. do iv = 1 , - shift interp ( iv , imu , ikxkyz ) = grid ( 1 , imu , ikxkyz ) * real ( iv - 1 ) / real ( - shift ) end do end if end do end do else do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) do imu = 1 , nmu tmp0 = mirror_interp_loc ( 1 , iz , imu , is ) tmp1 = tmp0 - 2.0 tmp2 = tmp0 - 1.0 tmp3 = tmp0 + 1.0 shift = mirror_interp_idx_shift ( 1 , iz , imu , is ) sgn = mirror_sign ( 1 , iz ) if ( shift == 0 ) then ! deal with boundary point near outgoing BC ! using 2-point (linear) interpolation ! could do 3-point to improve accuracy fac1 = 1.0 - tmp0 fac2 = tmp0 if ( sgn > 0 ) then llim = 2 ulim = nvpa - 2 - shift else llim = nvpa - 1 ulim = 3 - shift end if iv = llim - sgn interp ( iv , imu , ikxkyz ) = grid ( iv + shift , imu , ikxkyz ) * fac1 & + grid ( iv + shift + sgn , imu , ikxkyz ) * fac2 else if ( sgn > 0 ) then llim = 1 ulim = nvpa - 2 - shift else llim = nvpa ulim = 3 - shift end if end if ! if llim > ulim (for sgn > 0) or llim < ulim (for sgn < 0) ! then there are no elements to be interpolated if ( sgn * ulim < sgn * llim ) then interp (:, imu , ikxkyz ) = 0. else ! coefficient multiplying g_{iv-1} fac0 = - tmp0 * tmp1 * tmp2 ! coefficient multiplying g_{iv} fac1 = 3. * tmp1 * tmp2 * tmp3 ! coefficient multiplying g_{iv+1} fac2 = - 3. * tmp0 * tmp1 * tmp3 ! coefficient multiplying g_{iv+2} fac3 = tmp0 * tmp2 * tmp3 do iv = llim , ulim , sgn interp ( iv , imu , ikxkyz ) = ( grid ( iv + shift - sgn , imu , ikxkyz ) * fac0 & + grid ( iv + shift , imu , ikxkyz ) * fac1 & + grid ( iv + shift + sgn , imu , ikxkyz ) * fac2 & + grid ( iv + shift + 2 * sgn , imu , ikxkyz ) * fac3 ) / 6. end do ! at boundary cell, use zero incoming BC for point just beyond boundary interp ( ulim + sgn , imu , ikxkyz ) = ( grid ( ulim + shift , imu , ikxkyz ) * fac0 & + grid ( ulim + shift + sgn , imu , ikxkyz ) * fac1 & + grid ( ulim + shift + 2 * sgn , imu , ikxkyz ) * fac2 ) / 6. interp ( ulim + 2 * sgn , imu , ikxkyz ) = ( grid ( ulim + shift + sgn , imu , ikxkyz ) * fac0 & + grid ( ulim + shift + 2 * sgn , imu , ikxkyz ) * fac1 ) / 6. ! use zero incoming BC for cells beyond +/- nvgrid if ( shift > 0 ) then interp ( nvpa - shift + 1 :, imu , ikxkyz ) = 0. else if ( shift < 0 ) then interp (: - shift , imu , ikxkyz ) = 0. end if end if end do end do end if end subroutine vpa_interpolation subroutine invert_mirror_operator ( imu , ilo , g ) use finite_differences , only : tridag implicit none integer , intent ( in ) :: imu , ilo complex , dimension (:), intent ( in out ) :: g call tridag ( 1 , mirror_tri_a (:, imu , ilo ), mirror_tri_b (:, imu , ilo ), mirror_tri_c (:, imu , ilo ), g ) end subroutine invert_mirror_operator subroutine finish_mirror use run_parameters , only : mirror_implicit , mirror_semi_lagrange implicit none if ( allocated ( mirror )) deallocate ( mirror ) if ( allocated ( mirror_sign )) deallocate ( mirror_sign ) if ( allocated ( mirror_rad_var )) deallocate ( mirror_rad_var ) if ( mirror_implicit ) then if ( mirror_semi_lagrange ) then call finish_mirror_semi_lagrange else call finish_invert_mirror_operator call finish_mirror_response end if end if mirror_initialized = . false . end subroutine finish_mirror subroutine finish_mirror_semi_lagrange implicit none if ( allocated ( mirror_interp_loc )) deallocate ( mirror_interp_loc ) if ( allocated ( mirror_interp_idx_shift )) deallocate ( mirror_interp_idx_shift ) end subroutine finish_mirror_semi_lagrange subroutine finish_invert_mirror_operator implicit none if ( allocated ( mirror_tri_a )) then deallocate ( mirror_tri_a ) deallocate ( mirror_tri_b ) deallocate ( mirror_tri_c ) end if if ( allocated ( mirror_int_fac )) deallocate ( mirror_int_fac ) end subroutine finish_invert_mirror_operator subroutine finish_mirror_response implicit none if ( allocated ( response_apar_denom )) deallocate ( response_apar_denom ) end subroutine finish_mirror_response ! subroutine checksum_field (field, total) !   use zgrid, only: nzgrid, ntubes !   use kt_grids, only: naky !   use extended_zgrid, only: neigen, nsegments, ikxmod !   use extended_zgrid, only: iz_low, iz_up !   implicit none !   complex, dimension (:,:,-nzgrid:,:), intent (in) :: field !   real, intent (out) :: total !   integer :: it, iky, ie, iseg !   integer :: ikx !   total = 0. !   do iky = 1, naky !      do it = 1, ntubes !         do ie = 1, neigen(iky) !            iseg = 1 !            ikx = ikxmod(iseg,ie,iky) !            total = total + sum(cabs(field(iky,ikx,iz_low(iseg):iz_up(iseg),it))) !            if (nsegments(ie,iky) > 1) then !               do iseg = 2, nsegments(ie,iky) !                  ikx = ikxmod(iseg,ie,iky) !                  total = total + sum(cabs(field(iky,ikx,iz_low(iseg)+1:iz_up(iseg),it))) !               end do !            end if !         end do !      end do !   end do ! end subroutine checksum_field ! subroutine checksum_dist (dist, total, norm) !   use mp, only: sum_allreduce !   use zgrid, only: nzgrid, ntubes !   use stella_layouts, only: vmu_lo, iv_idx, imu_idx, is_idx !   use kt_grids, only: naky, nakx !   use vpamu_grids, only: maxwell_vpa, maxwell_mu !   implicit none !   complex, dimension (:,:,-nzgrid:,:,vmu_lo%llim_proc:), intent (in) :: dist !   real, intent (out) :: total !   logical, intent (in), optional :: norm !   integer :: ivmu, iv, imu, is !   integer :: iky, ikx, it !   real :: subtotal !   complex, dimension (:,:,:,:), allocatable :: dist_single !   total = 0. !   allocate (dist_single(naky,nakx,-nzgrid:nzgrid,ntubes)) !   do ivmu = vmu_lo%llim_proc, vmu_lo%ulim_proc !      dist_single = dist(:,:,:,:,ivmu) !      if (present(norm)) then !         if (norm) then !            iv = iv_idx(vmu_lo,ivmu) !            imu = imu_idx(vmu_lo,ivmu) !            is = is_idx(vmu_lo,ivmu) !            do it = 1, ntubes !               do ikx = 1, nakx !                  do iky = 1, naky !                     dist_single(iky,ikx,:,it) = dist_single(iky,ikx,:,it) * maxwell_vpa(iv,is) * maxwell_mu(1,:,imu,is) !                  end do !               end do !            end do !         else !         end if !      end if !      call checksum (dist_single, subtotal) !      total = total + subtotal !   end do !   deallocate (dist_single) !   call sum_allreduce (total) ! end subroutine checksum_dist end module mirror_terms","tags":"","loc":"sourcefile/mirror_terms.f90.html"},{"title":"stella.f90 – stella","text":"Source Code program stella use redistribute , only : scatter use job_manage , only : time_message , checkstop , job_fork use job_manage , only : checktime use run_parameters , only : nstep , tend use run_parameters , only : avail_cpu_time use stella_time , only : update_time , code_time , code_dt , checkcodedt use dist_redistribute , only : kxkyz2vmu use time_advance , only : advance_stella use stella_diagnostics , only : diagnose_stella , nsave use stella_save , only : stella_save_for_restart use dist_fn_arrays , only : gnew , gvmu use file_utils , only : error_unit , flush_output_file use git_version , only : get_git_version , get_git_date implicit none logical :: debug = . false . logical :: stop_stella = . false . logical :: mpi_initialized = . false . integer :: istep0 , istep , ierr integer :: istatus real , dimension ( 2 ) :: time_init = 0. real , dimension ( 2 ) :: time_diagnostics = 0. real , dimension ( 2 ) :: time_total = 0. call parse_command_line () !> Initialize stella call init_stella ( istep0 , get_git_version (), get_git_date ()) !> Diagnose stella if ( debug ) write ( * , * ) 'stella::diagnose_stella' if ( istep0 == 0 ) call diagnose_stella ( istep0 ) !> Advance stella until istep=nstep if ( debug ) write ( * , * ) 'stella::advance_stella' istep = istep0 + 1 do while (( code_time <= tend . AND . tend > 0 ) . OR . ( istep <= nstep . AND . nstep > 0 )) if ( debug ) write ( * , * ) 'istep = ' , istep if ( mod ( istep , 10 ) == 0 ) then call checkstop ( stop_stella ) call checktime ( avail_cpu_time , stop_stella ) call checkcodedt ( stop_stella ) end if if ( stop_stella ) exit call advance_stella ( istep , stop_stella ) if ( stop_stella ) exit call update_time if ( nsave > 0 . and . mod ( istep , nsave ) == 0 ) then call scatter ( kxkyz2vmu , gnew , gvmu ) call stella_save_for_restart ( gvmu , istep , code_time , code_dt , istatus ) end if call time_message (. false ., time_diagnostics , ' diagnostics' ) call diagnose_stella ( istep ) call time_message (. false ., time_diagnostics , ' diagnostics' ) ierr = error_unit () call flush_output_file ( ierr ) istep = istep + 1 end do !> Finish stella if ( debug ) write ( * , * ) 'stella::finish_stella' call finish_stella ( last_call = . true .) contains !> Initialise stella !> !> Calls the initialisation routines for all the geometry, physics, and !> diagnostic modules subroutine init_stella ( istep0 , VERNUM , VERDATE ) use mp , only : init_mp , broadcast , sum_allreduce use mp , only : proc0 , job use file_utils , only : init_file_utils use file_utils , only : runtype_option_switch , runtype_multibox use file_utils , only : run_name , init_job_name use file_utils , only : flush_output_file , error_unit use job_manage , only : checktime , time_message use physics_parameters , only : init_physics_parameters use physics_flags , only : init_physics_flags , radial_variation use run_parameters , only : init_run_parameters use run_parameters , only : avail_cpu_time , nstep , rng_seed , delt , delt_max , delt_min use run_parameters , only : stream_implicit , driftkinetic_implicit use run_parameters , only : delt_option_switch , delt_option_auto use run_parameters , only : mat_gen , mat_read use species , only : init_species , read_species_knobs use species , only : nspec use zgrid , only : init_zgrid use zgrid , only : nzgrid , ntubes use stella_geometry , only : init_geometry use stella_geometry , only : finish_init_geometry use stella_layouts , only : init_stella_layouts , init_dist_fn_layouts use response_matrix , only : init_response_matrix , read_response_matrix use init_g , only : ginit , init_init_g , phiinit , scale_to_phiinit use init_g , only : tstart use fields , only : init_fields , advance_fields , get_radial_correction , fields_updated use fields , only : rescale_fields use stella_time , only : init_tstart , init_delt use stella_diagnostics , only : read_stella_diagnostics_knobs , init_stella_diagnostics use fields_arrays , only : phi , apar , bpar use dist_fn_arrays , only : gnew use dist_fn , only : init_gxyz , init_dist_fn use dist_redistribute , only : init_redistribute use time_advance , only : init_time_advance use extended_zgrid , only : init_extended_zgrid use kt_grids , only : init_kt_grids , read_kt_grids_parameters use kt_grids , only : naky , nakx , ny , nx , nalpha use vpamu_grids , only : init_vpamu_grids , read_vpamu_grids_parameters use vpamu_grids , only : nvgrid , nmu use stella_transforms , only : init_transforms use stella_save , only : init_dt use multibox , only : read_multibox_parameters , init_multibox use multibox , only : use_dirichlet_BC , apply_radial_boundary_conditions use multibox , only : multibox_communicate use ran , only : get_rnd_seed_length , init_ranf use dissipation , only : init_dissipation use sources , only : init_sources use volume_averages , only : init_volume_averages , volume_average implicit none !> Starting timestep: zero unless the simulation has been restarted integer , intent ( out ) :: istep0 !> stella version number character ( len =* ), intent ( in ) :: VERNUM !> Release date character ( len = 10 ), intent ( in ) :: VERDATE logical :: exit , list , restarted , needs_transforms character ( 500 ), target :: cbuff integer , dimension (:), allocatable :: seed integer :: i , n , ierr real :: delt_saved !> initialize mpi message passing if (. not . mpi_initialized ) call init_mp mpi_initialized = . true . debug = debug . and . proc0 !> initialize timer if ( debug ) write ( * , * ) 'stella::init_stella::check_time' call checktime ( avail_cpu_time , exit ) if ( proc0 ) then !> write message to screen with useful info regarding start of simulation if ( debug ) write ( * , * ) 'stella::init_stella::write_start_message' call write_start_message ( VERNUM , VERDATE ) !> initialize file i/o if ( debug ) write ( * , * ) 'stella::init_stella::init_file_utils' call init_file_utils ( list ) end if call broadcast ( list ) call broadcast ( runtype_option_switch ) if ( list ) call job_fork !proc0 may have changed debug = debug . and . proc0 if ( proc0 ) then call time_message (. false ., time_total , ' Total' ) call time_message (. false ., time_init , ' Initialization' ) end if if ( proc0 ) cbuff = trim ( run_name ) call broadcast ( cbuff ) if (. not . proc0 ) call init_job_name ( cbuff ) !> read the physics_flags namelist from the input file if ( debug ) write ( 6 , * ) \"stella::init_stella::init_physics_flags\" call init_physics_flags !> read the physics_parameters namelist from the input file if ( debug ) write ( 6 , * ) \"stella::init_stella::init_physics_parameters\" call init_physics_parameters !> read the zgrid_parameters namelist from the input file and setup the z grid if ( debug ) write ( 6 , * ) \"stella::init_stella::init_zgrid\" call init_zgrid !> read the species_knobs namelist from the input file if ( debug ) write ( 6 , * ) \"stella::init_stella::read_species_knobs\" call read_species_knobs !> read the grid option from the kt_grids_knobs namelist in the input file; !> depending on the grid option chosen, read the corresponding kt_grids_XXXX_parameters !> namelist from the input file and allocate some kx and ky arrays if ( debug ) write ( 6 , * ) \"stella::init_stella::read_kt_grids_parameters\" call read_kt_grids_parameters !> read the vpamu_grids_parameters namelist from the input file if ( debug ) write ( 6 , * ) \"stella::init_stella::read_vpamu_grids_parameters\" call read_vpamu_grids_parameters if ( debug ) write ( 6 , * ) \"stella::init_stella::read_multibox_parameters\" call read_multibox_parameters if ( debug ) write ( 6 , * ) \"stella::init_stella::read_stella_diagnostics_knobs\" call read_stella_diagnostics_knobs !> setup the various data layouts for the distribution function; !> e.g., vmu_lo is the layout in which vpa, mu and species may be distributed !> amongst processors, depending on the number of phase space points and processors if ( debug ) write ( 6 , * ) \"stella::init_stella::init_dist_fn_layouts\" call init_dist_fn_layouts ( nzgrid , ntubes , naky , nakx , nvgrid , nmu , nspec , ny , nx , nalpha ) !> needs_transforms indicates whether or not FFTs will be needed in the simulation call check_transforms ( needs_transforms ) !> if FFTs are needed, init_transforms sets up the various FFTW plans !> and allocates the necessary arrays if ( needs_transforms ) then if ( debug ) write ( * , * ) \"stella::init_stella::init_transforms\" call init_transforms end if !> read in the geometry option and any necessary magnetic geometry info !> and use it to calculate all of the required geometric coefficients if ( debug ) write ( 6 , * ) \"stella::init_stella::init_geometry\" call init_geometry ( nalpha , naky ) !> read species_parameters from input file and use the info to, e.g., !> determine if a modified Boltzmann response is to be used if ( debug ) write ( 6 , * ) 'stella::init_stella::init_species' call init_species !> read init_g_knobs namelist from the input file !> and prepare for reading in from restart file if requested if ( debug ) write ( 6 , * ) \"stella::init_stella::init_init_g\" call init_init_g !> read knobs namelist from the input file !> and the info to determine the mixture of implicit and explicit time advance if ( debug ) write ( 6 , * ) \"stella::init_stella::init_run_parameters\" call init_run_parameters if ( debug ) write ( 6 , * ) \"stella::init_stella::init_ranf\" n = get_rnd_seed_length () allocate ( seed ( n )) if ( rng_seed < 0 ) then call init_ranf (. true ., seed , job + 2 ) else seed = rng_seed + 37 * ( / ( i - 1 , i = 1 , n ) / ) call init_ranf (. false ., seed , job + 2 ) end if deallocate ( seed ) !> read layouts_knobs namelist from the input file, !> which determines the order of parallelisation within the different layouts if ( debug ) write ( 6 , * ) 'stella::init_stella::init_stella_layouts' call init_stella_layouts !> setup the (kx,ky) grids and (x,y) grids, if applicable if ( debug ) write ( 6 , * ) 'stella::init_stella::init_kt_grids' call init_kt_grids if ( debug ) write ( 6 , * ) 'stella::init_stella::init_multibox_subcalls' call init_multibox_subcalls !> finish_init_geometry deallocates various geometric arrays that !> were defined locally within the millerlocal module when using Miller geometry if ( debug ) write ( 6 , * ) 'stella::init_stella::finish_init_geometry' call finish_init_geometry !> setup the (vpa,mu) grids and associated integration weights if ( debug ) write ( 6 , * ) 'stella::init_stella::init_vpamu_grids' call init_vpamu_grids !> set up all of the logic needed to do calculations on an extended grid in z. !> this extended grid could be due to use of a ballooning angle so that !> z goes from -N*pi to N*pi, or it could be due to the coupling of different !> kx modes arising from the twist-and-shift boundary condition if ( debug ) write ( 6 , * ) 'stella::init_stella::init_extended_zgrid' call init_extended_zgrid !> when doing a volume average using Fourier coefficients, the !> ky=0 mode gets a different weighting than finite ky modes, due !> to the reality condition being imposed; init_volume_averages accounts for this if ( debug ) write ( 6 , * ) 'stella::init_stella::init_volume_averages' call init_volume_averages !> allocates and initialises kperp2, vperp2 and arrays needed !> for gyro-averaging (j0 and j1 or equivalents) if ( debug ) write ( 6 , * ) \"stella::init_stella::init_dist_fn\" call init_dist_fn !> sets up the mappings between different layouts, needed !> to redistribute data when going from one layout to another if ( debug ) write ( 6 , * ) \"stella::init_stella::init_redistribute\" call init_redistribute !> read dissipation namelist from the input file and print information !> about chosen options to stdout if ( debug ) write ( 6 , * ) 'stella::init_stella::init_dissipation' call init_dissipation if ( debug ) write ( 6 , * ) 'stella::init_stella::init_sources' call init_sources !> allocate and initialise time-independent arrays needed to !> solve the field equations; e.g., sum_s (Z_s&#94;2 n_s / T_s)*(1-Gamma0_s) if ( debug ) write ( 6 , * ) 'stella::init_stella::init_fields' call init_fields !> initialise the distribution function in the kxkyz_lo and store in gvmu if ( debug ) write ( 6 , * ) \"stella::init_stella::ginit\" call ginit ( restarted , istep0 ) !> use mapping from kxkyz_lo to vmu_lo to get a copy of g that has ky, kx and z local to each core; !> stored in gnew and copied to gold if ( debug ) write ( 6 , * ) \"stella::init_stella::init_gxyz\" call init_gxyz ( restarted ) !> if initializing from restart file, set the initial time step size appropriately if ( restarted . and . delt_option_switch == delt_option_auto ) then delt_saved = delt if ( debug ) write ( 6 , * ) \"stella::init_stella::init_dt\" call init_dt ( delt_saved , istatus ) if ( istatus == 0 ) delt = delt_saved end if !> set the internal time step size variable code_dt from the input variable delt if ( debug ) write ( 6 , * ) \"stella::init_stella::init_delt\" call init_delt ( delt , delt_max , delt_min ) !> allocate and calculate arrays needed for the mirror, parallel streaming, !> magnetic drifts, gradient drive, etc. terms during time advance if ( debug ) write ( 6 , * ) 'stella::init_stella::init_time_advance' call init_time_advance if ( stream_implicit . or . driftkinetic_implicit ) then if ( mat_read ) then if ( debug ) write ( 6 , * ) \"stella::init_stella::read_response_matrix\" call read_response_matrix else if ( debug ) write ( 6 , * ) \"stella::init_stella::init_response_matrix\" call init_response_matrix end if end if !> get initial field from initial distribution function if ( debug ) write ( 6 , * ) 'stella::init_stella::advance_fields' call advance_fields ( gnew , phi , apar , bpar , dist = 'g' ) if ( radial_variation ) then if ( debug ) write ( 6 , * ) 'stella::init_stella::get_radial_correction' call get_radial_correction ( gnew , phi , dist = 'g' ) end if !> fill in the boundary regions using auxilliary simulations if using !> multibox, or zero it out if using Dirichlet boundary conditions if ( runtype_option_switch == runtype_multibox ) then if ( debug ) write ( 6 , * ) 'stella::init_stella:multibox_communicate' call multibox_communicate ( gnew ) if ( job == 1 ) then fields_updated = . false . call advance_fields ( gnew , phi , apar , bpar , dist = 'g' ) end if else if ( use_dirichlet_BC ) then if ( debug ) write ( 6 , * ) 'stella::init_stella:multibox_radial_BC' call apply_radial_boundary_conditions ( gnew ) fields_updated = . false . call advance_fields ( gnew , phi , apar , bpar , dist = 'g' ) end if !> rescale to phiinit if just beginning a new run if (. not . restarted . and . scale_to_phiinit ) call rescale_fields ( phiinit ) !> read stella_diagnostics_knob namelist from the input file, !> open ascii output files and initialise the neetcdf file with extension .out.nc if ( debug ) write ( 6 , * ) 'stella::init_stella::init_stella_diagnostics' call init_stella_diagnostics ( restarted , tstart ) !> initialise the code_time if ( debug ) write ( 6 , * ) 'stella::init_stella::init_tstart' call init_tstart ( tstart ) ierr = error_unit () if ( proc0 ) call flush_output_file ( ierr ) !> Add a header to the output file call print_header !> stop the timing of the initialization if ( proc0 ) call time_message (. false ., time_init , ' Initialization' ) end subroutine init_stella !> call all the multibox communication subroutines to make sure all the jobs have !> the appropriate information subroutine init_multibox_subcalls use mp , only : proc0 , job use species , only : communicate_species_multibox use stella_geometry , only : communicate_geo_multibox use kt_grids , only : communicate_ktgrids_multibox use file_utils , only : runtype_option_switch , runtype_multibox use physics_flags , only : radial_variation use multibox , only : init_multibox , rhoL , rhoR use multibox , only : communicate_multibox_parameters , multibox_communicate implicit none if ( debug ) write ( 6 , * ) 'stella::init_stella::init_multibox' call init_multibox if ( runtype_option_switch == runtype_multibox ) then if ( proc0 . and . ( job == 1 ) . and . radial_variation ) then if ( debug ) write ( 6 , * ) 'stella::init_stella::init_multibox_geo' call communicate_geo_multibox ( rhoL , rhoR ) if ( debug ) write ( 6 , * ) 'stella::init_stella::init_multibox_spec' call communicate_species_multibox ( rhoL , rhoR ) end if if ( job == 1 ) then call communicate_multibox_parameters end if if ( radial_variation ) then if ( debug ) write ( 6 , * ) 'stella::init_stella::init_multibox_ktgrid' call communicate_ktgrids_multibox end if end if end subroutine init_multibox_subcalls !> check_transforms checks the various physics flag choices !> to determine if FFTs are needed for the simulation subroutine check_transforms ( needs_transforms ) use file_utils , only : runtype_option_switch , runtype_multibox use physics_flags , only : nonlinear , include_parallel_nonlinearity use physics_flags , only : radial_variation , full_flux_surface use physics_flags , only : hammett_flow_shear use physics_parameters , only : g_exb , g_exbfac use stella_diagnostics , only : write_radial_fluxes , write_radial_moments implicit none logical , intent ( out ) :: needs_transforms needs_transforms = . false . !> if ExB or parallel nonlinearity included in the simulations, need FFTs if ( nonlinear . or . include_parallel_nonlinearity ) needs_transforms = . true . !> if 'global' in radial or bi-normal directions, need FFTs if ( radial_variation . or . full_flux_surface ) needs_transforms = . true . !> if running in multibox mode, need FFTs if ( runtype_option_switch == runtype_multibox ) needs_transforms = . true . !> if including flow shear using anything other than wavenumber re-mapping, need FFTs if ( abs ( g_exb * g_exbfac ) > epsilon ( 0. ) . and . . not . hammett_flow_shear ) & needs_transforms = . true . !> if printing out flux-surface-averaged radial fluxes or moments, need FFTs if ( write_radial_fluxes . or . write_radial_moments ) needs_transforms = . true . end subroutine check_transforms !> Write the start message to screen subroutine write_start_message ( VERNUM , VERDATE ) use mp , only : proc0 , nproc implicit none !> stella version number character ( len =* ), intent ( in ) :: VERNUM !> Release date character ( len = 10 ), intent ( in ) :: VERDATE character ( len = 23 ) :: str character ( len = 50 ) :: version_format integer :: version_text_length if ( proc0 ) then version_text_length = 60 - ( len ( \"Version \" ) + len_trim ( VERNUM ) + 1 ) write ( version_format , '(\"('' '', \", i2, \"x, ''Version '', a)\")' ) version_text_length / 2 write ( * , * ) ' ' write ( * , * ) ' ' write ( * , * ) \"            I8            ,dPYb, ,dPYb,            \" write ( * , * ) \"            I8            IP'`Yb IP'`Yb            \" write ( * , * ) \"         88888888         I8  8I I8  8I            \" write ( * , * ) \"            I8            I8  8' I8  8'            \" write ( * , * ) \"   ,g,      I8    ,ggg,   I8 dP  I8 dP    ,gggg,gg \" write ( * , * ) \"  ,8'8,     I8   i8' '8i  I8dP   I8dP    dP'  'Y8I \" write ( * , * ) \" ,8'  Yb   ,I8,  I8, ,8I  I8P    I8P    i8'    ,8I \" write ( * , * ) \",8'_   8) ,d88b, `YbadP' ,d8b,_ ,d8b,_ ,d8,   ,d8b,\" write ( * , * ) 'P` \"YY8P8P8P\"\"Y8888P\"Y8888P`\"Y888P`\"Y88P\"Y8888P\"`Y8' write ( * , * ) ' ' write ( * , * ) ' ' write ( * , version_format ) VERNUM write ( * , * ) '                        ' , VERDATE write ( * , * ) ' ' write ( * , * ) '                     The stella team' write ( * , * ) ' ' write ( * , * ) '                   University of Oxford' write ( * , * ) ' ' write ( * , * ) ' ' write ( * , '(A)' ) \"############################################################\" write ( * , '(A)' ) \"                     PARALLEL COMPUTING\" write ( * , '(A)' ) \"############################################################\" if ( nproc == 1 ) then write ( str , '(I10, A)' ) nproc , \" processor.\" write ( * , '(A,A,A)' ) \" Running on \" , adjustl ( trim ( str )) else write ( str , '(I10, A)' ) nproc , \" processors.\" write ( * , '(A,A,A)' ) \" Running on \" , adjustl ( trim ( str )) end if write ( * , * ) end if end subroutine write_start_message subroutine print_header use mp , only : proc0 implicit none if ( proc0 ) then write ( * , '(A)' ) \"############################################################\" write ( * , '(A)' ) \"                OVERVIEW OF THE SIMULATION\" write ( * , '(A)' ) \"############################################################\" write ( * , '(A)' ) \" \" write ( * , '(A)' ) \"    istep       time          dt          CFL ExB       |phi|&#94;2\" write ( * , '(A)' ) \"-----------------------------------------------------------------\" end if end subroutine print_header !> Parse some basic command line arguments. Currently just 'version' and 'help'. !> !> This should be called before anything else, but especially before initialising MPI. subroutine parse_command_line () use git_version , only : get_git_version integer :: arg_count , arg_n integer :: arg_length character ( len = :), allocatable :: argument character ( len =* ), parameter :: endl = new_line ( 'a' ) arg_count = command_argument_count () do arg_n = 0 , arg_count call get_command_argument ( 1 , length = arg_length ) if ( allocated ( argument )) deallocate ( argument ) allocate ( character ( len = arg_length ) :: argument ) call get_command_argument ( 1 , argument ) if (( argument == \"--version\" ) . or . ( argument == \"-v\" )) then write ( * , '(\"stella version \", a)' ) get_git_version () stop else if (( argument == \"--help\" ) . or . ( argument == \"-h\" )) then write ( * , '(a)' ) \"stella [--version|-v] [--help|-h] [input file]\" // endl // endl // & \"stella is a flux tube gyrokinetic code for micro-stability and turbulence \" // & \"simulations of strongly magnetised plasma\" // endl // & \"For more help, see the documentation at https://stellagk.github.io/stella/\" // endl // & \"or create an issue https://github.com/stellaGK/stella/issues/new\" // endl // & endl // & \"  -h, --help     Print this message\" // endl // & \"  -v, --version  Print the stella version\" stop end if end do end subroutine parse_command_line !> Finish a simulation, call the finialisation routines of all modules subroutine finish_stella ( last_call ) use mp , only : finish_mp use mp , only : proc0 use file_utils , only : finish_file_utils use job_manage , only : time_message use physics_parameters , only : finish_physics_parameters use physics_flags , only : finish_physics_flags use run_parameters , only : finish_run_parameters use zgrid , only : finish_zgrid use species , only : finish_species use time_advance , only : time_gke , time_parallel_nl use time_advance , only : finish_time_advance use parallel_streaming , only : time_parallel_streaming use mirror_terms , only : time_mirror use dissipation , only : time_collisions use sources , only : finish_sources , time_sources use init_g , only : finish_init_g use dist_fn , only : finish_dist_fn use dist_redistribute , only : finish_redistribute use fields , only : finish_fields use fields , only : time_field_solve use stella_diagnostics , only : finish_stella_diagnostics use response_matrix , only : finish_response_matrix use stella_geometry , only : finish_geometry use extended_zgrid , only : finish_extended_zgrid use vpamu_grids , only : finish_vpamu_grids use kt_grids , only : finish_kt_grids use volume_averages , only : finish_volume_averages use multibox , only : finish_multibox , time_multibox use run_parameters , only : stream_implicit , driftkinetic_implicit , drifts_implicit use implicit_solve , only : time_implicit_advance implicit none logical , intent ( in ), optional :: last_call if ( debug ) write ( * , * ) 'stella::finish_stella::finish_stella_diagnostics' call finish_stella_diagnostics ( istep ) if ( debug ) write ( * , * ) 'stella::finish_stella::finish_response_matrix' call finish_response_matrix if ( debug ) write ( * , * ) 'stella::finish_stella::finish_fields' call finish_fields if ( debug ) write ( * , * ) 'stella::finish_stella::finish_time_advance' call finish_time_advance if ( debug ) write ( * , * ) 'stella::finish_stella::finish_sources' call finish_sources if ( debug ) write ( * , * ) 'stella::finish_stella::finish_volume_averages' call finish_volume_averages if ( debug ) write ( * , * ) 'stella::finish_stella::finish_extended_zgrid' call finish_extended_zgrid if ( debug ) write ( * , * ) 'stella::finish_stella::finish_multibox' call finish_multibox if ( debug ) write ( * , * ) 'stella::finish_stella::finish_dist_fn' call finish_dist_fn if ( debug ) write ( * , * ) 'stella::finish_stella::finish_redistribute' call finish_redistribute if ( debug ) write ( * , * ) 'stella::finish_stella::finish_init_g' call finish_init_g if ( debug ) write ( * , * ) 'stella::finish_stella::finish_vpamu_grids' call finish_vpamu_grids if ( debug ) write ( * , * ) 'stella::finish_stella::finish_kt_grids' call finish_kt_grids if ( debug ) write ( * , * ) 'stella::finish_stella::finish_run_parameters' call finish_run_parameters if ( debug ) write ( * , * ) 'stella::finish_stella::finish_species' call finish_species if ( debug ) write ( * , * ) 'stella::finish_stella::finish_physics_flags' call finish_physics_flags if ( debug ) write ( * , * ) 'stella::finish_stella::finish_physics_parameters' call finish_physics_parameters if ( debug ) write ( * , * ) 'stella::finish_stella::finish_geometry' call finish_geometry if ( debug ) write ( * , * ) 'stella::finish_stella::finish_zgrid' call finish_zgrid if ( debug ) write ( * , * ) 'stella::finish_stella::finish_file_utils' if ( proc0 ) then call finish_file_utils call time_message (. false ., time_total , ' Total' ) write ( * , * ) write ( * , '(A)' ) \"############################################################\" write ( * , '(A)' ) \"                        ELAPSED TIME\" write ( * , '(A)' ) \"############################################################\" write ( * , fmt = 101 ) 'initialization:' , time_init ( 1 ) / 6 0. , 'min' write ( * , fmt = 101 ) 'diagnostics:' , time_diagnostics ( 1 ) / 6 0. , 'min' write ( * , fmt = 101 ) 'fields:' , time_field_solve ( 1 , 1 ) / 6 0. , 'min' write ( * , fmt = 101 ) '(redistribute):' , time_field_solve ( 1 , 2 ) / 6 0. , 'min' write ( * , fmt = 101 ) '(int_dv_g):' , time_field_solve ( 1 , 3 ) / 6 0. , 'min' write ( * , fmt = 101 ) '(get_phi):' , time_field_solve ( 1 , 4 ) / 6 0. , 'min' write ( * , fmt = 101 ) '(phi_adia_elec):' , time_field_solve ( 1 , 5 ) / 6 0. , 'min' write ( * , fmt = 101 ) 'mirror:' , time_mirror ( 1 , 1 ) / 6 0. , 'min' write ( * , fmt = 101 ) '(redistribute):' , time_mirror ( 1 , 2 ) / 6 0. , 'min' if ( stream_implicit ) then write ( * , fmt = 101 ) 'implicit advance: ' , time_implicit_advance ( 1 , 1 ) / 6 0. , 'min' write ( * , fmt = 101 ) '(bidiagonal)' , time_parallel_streaming ( 1 , 2 ) / 6 0. , 'min' write ( * , fmt = 101 ) '(backwards sub)' , time_parallel_streaming ( 1 , 3 ) / 6 0. , 'min' else write ( * , fmt = 101 ) 'stream:' , time_parallel_streaming ( 1 , 1 ) / 6 0. , 'min' end if if (. not . drifts_implicit ) then write ( * , fmt = 101 ) 'dgdx:' , time_gke ( 1 , 5 ) / 6 0. , 'min' write ( * , fmt = 101 ) 'dgdy:' , time_gke ( 1 , 4 ) / 6 0. , 'min' write ( * , fmt = 101 ) 'wstar:' , time_gke ( 1 , 6 ) / 6 0. , 'min' end if write ( * , fmt = 101 ) 'collisions:' , time_collisions ( 1 , 1 ) / 6 0. , 'min' write ( * , fmt = 101 ) '(redistribute):' , time_collisions ( 1 , 2 ) / 6 0. , 'min' write ( * , fmt = 101 ) 'sources:' , time_sources ( 1 , 1 ) / 6 0. , 'min' write ( * , fmt = 101 ) '(redistribute):' , time_sources ( 1 , 2 ) / 6 0. , 'min' write ( * , fmt = 101 ) 'ExB nonlin:' , time_gke ( 1 , 7 ) / 6 0. , 'min' write ( * , fmt = 101 ) 'parallel nonlin:' , time_parallel_nl ( 1 , 1 ) / 6 0. , 'min' write ( * , fmt = 101 ) '(redistribute):' , time_parallel_nl ( 1 , 2 ) / 6 0. , 'min' write ( * , fmt = 101 ) 'radial var:' , time_gke ( 1 , 10 ) / 6 0. , 'min' write ( * , fmt = 101 ) 'multibox comm:' , time_multibox ( 1 , 1 ) / 6 0. , 'min' write ( * , fmt = 101 ) 'multibox krook:' , time_multibox ( 1 , 2 ) / 6 0. , 'min' write ( * , fmt = 101 ) 'total implicit:' , time_gke ( 1 , 9 ) / 6 0. , 'min' write ( * , fmt = 101 ) 'total explicit:' , time_gke ( 1 , 8 ) / 6 0. , 'min' write ( * , fmt = 101 ) 'total:' , time_total ( 1 ) / 6 0. , 'min' write ( * , * ) end if 101 format ( a17 , 0 pf8 . 2 , a4 ) if ( debug ) write ( * , * ) 'stella::finish_stella::finish_mp' ! finish (clean up) mpi message passing if ( present ( last_call )) then call finish_mp mpi_initialized = . false . end if end subroutine finish_stella ! subroutine test_redistribute !   use stella_layouts, only: kxyz_lo, vmu_lo !   use zgrid, only: nzgrid, ntubes !   use vpamu_grids, only: nvpa, nmu !   use kt_grids, only: ny, ikx_max !   use dist_redistribute, only: kxyz2vmu !   use redistribute, only: scatter !   implicit none !   complex, dimension (:,:,:), allocatable :: g_kxyz_lo !   complex, dimension (:,:,:,:,:), allocatable :: g_vmu_lo !   allocate (g_kxyz_lo(nvpa,nmu,kxyz_lo%llim_proc:kxyz_lo%ulim_alloc)) !   allocate (g_vmu_lo(ny,ikx_max,-nzgrid:nzgrid,ntubes,vmu_lo%llim_proc:vmu_lo%ulim_alloc)) !   g_kxyz_lo = 1.0 !   g_vmu_lo = 2.0 !   call scatter (kxyz2vmu, g_vmu_lo, g_kxyz_lo) !   write (*,*) 'g_vmu_lo', maxval(cabs(g_vmu_lo)), minval(cabs(g_vmu_lo)) !   write (*,*) 'g_kxyz_lo', maxval(cabs(g_kxyz_lo)), minval(cabs(g_kxyz_lo)) !   deallocate (g_vmu_lo, g_kxyz_lo) ! end subroutine test_redistribute end program stella","tags":"","loc":"sourcefile/stella.f90.html"},{"title":"stella_diagnostics.f90 – stella","text":"Source Code !> Routines for calculating and writing various physical diagnostics module stella_diagnostics implicit none public :: init_stella_diagnostics , finish_stella_diagnostics public :: diagnose_stella , read_stella_diagnostics_knobs public :: write_radial_fluxes , write_radial_moments public :: nsave private integer :: ntg_out integer :: nwrite , nsave , navg , nc_mult integer :: stdout_unit , fluxes_unit , omega_unit logical :: save_for_restart logical :: write_omega logical :: write_moments logical :: write_phi_vs_time logical :: write_apar_vs_time logical :: write_bpar_vs_time logical :: write_gvmus logical :: write_gzvs logical :: write_kspectra logical :: write_radial_fluxes logical :: write_radial_moments logical :: write_fluxes_kxkyz logical :: flux_norm !> Arrays needed for averaging in x,y,z real , dimension (:), allocatable :: pflux_avg , vflux_avg , qflux_avg , heat_avg real , dimension (:, :, :), allocatable :: pflux , vflux , qflux , exchange !> Needed for calculating growth rates and frequencies complex , dimension (:, :, :), allocatable :: omega_vs_time !> Current maximum index of the time dimension in the netCDF file integer :: nout = 1 !> Has this module been initialised? logical :: diagnostics_initialized = . false . !> Debugging logical :: debug = . false . interface get_one_flux_vmulo module procedure get_one_flux_vmulo_int module procedure get_one_flux_vmulo_kxkyz end interface contains !> Read-in the parameters for the [[stella_diagnostics]] module !> !> Broadcast the parameters from the namelist \"stella_diagnostics_knobs\" subroutine read_stella_diagnostics_knobs use mp , only : broadcast implicit none !> Read the namelist \"stella_diagnostics_knobs\" in the input file call read_parameters !> Broadcast the variables to all processors call broadcast ( nwrite ) call broadcast ( navg ) call broadcast ( nsave ) call broadcast ( nc_mult ) call broadcast ( save_for_restart ) call broadcast ( write_omega ) call broadcast ( write_kspectra ) call broadcast ( write_moments ) call broadcast ( write_phi_vs_time ) call broadcast ( write_apar_vs_time ) call broadcast ( write_bpar_vs_time ) call broadcast ( write_gvmus ) call broadcast ( write_gzvs ) call broadcast ( write_radial_fluxes ) call broadcast ( write_radial_moments ) call broadcast ( write_fluxes_kxkyz ) call broadcast ( flux_norm ) end subroutine read_stella_diagnostics_knobs !> Initialise the [[stella_diagnostics]] module !> !> Broadcast the parameters from the namelist \"stella_diagnostics_knobs\" !> and open/append the netcdf file and the ascii files. subroutine init_stella_diagnostics ( restart , tstart ) use zgrid , only : init_zgrid , nperiod , nzed use kt_grids , only : init_kt_grids use physics_parameters , only : init_physics_parameters use run_parameters , only : init_run_parameters use species , only : init_species use dist_fn , only : init_dist_fn use init_g , only : init_init_g use stella_io , only : init_stella_io , get_nout use mp , only : broadcast , proc0 implicit none !> Has this simulation been restarted? logical , intent ( in ) :: restart !> Current simulation time real , intent ( in ) :: tstart ! Only initialize the diagnostics once if ( diagnostics_initialized ) return diagnostics_initialized = . true . ! Only debug on the first processor debug = debug . and . proc0 !> Make sure the other routines are intialized call init_zgrid call init_physics_parameters call init_kt_grids call init_run_parameters call init_species call init_init_g call init_dist_fn !> Allocate the necessary arrays call allocate_arrays ntg_out = nzed / 2 + ( nperiod - 1 ) * nzed !> Initiate the netcdf file with extension '.out.nc' call init_stella_io ( restart ) !> Open the '.out', '.fluxes' and '.omega' file if ( proc0 ) call open_loop_ascii_files ( restart ) !> Get the final position [[nout]] of the time axis in the netcdf file if ( proc0 ) call get_nout ( tstart , nout ) call broadcast ( nout ) end subroutine init_stella_diagnostics !> Read the diagnostic input parameters from the input file !> !> Namelist: `stella_diagnostics_knobs` subroutine read_parameters use mp , only : proc0 use file_utils , only : input_unit_exist use physics_flags , only : radial_variation implicit none logical :: exist integer :: in_file namelist / stella_diagnostics_knobs / nwrite , navg , nsave , & save_for_restart , write_phi_vs_time , write_apar_vs_time , & write_bpar_vs_time , write_gvmus , write_gzvs , & write_omega , write_kspectra , write_moments , write_radial_fluxes , & write_radial_moments , write_fluxes_kxkyz , flux_norm , nc_mult if ( proc0 ) then nwrite = 50 navg = 50 nsave = - 1 save_for_restart = . false . write_omega = . false . write_phi_vs_time = . false . write_apar_vs_time = . false . write_bpar_vs_time = . false . write_gvmus = . false . write_gzvs = . false . write_kspectra = . false . write_moments = . false . write_radial_fluxes = radial_variation write_radial_moments = radial_variation write_fluxes_kxkyz = . false . nc_mult = 1 flux_norm = . true . in_file = input_unit_exist ( \"stella_diagnostics_knobs\" , exist ) if ( exist ) read ( unit = in_file , nml = stella_diagnostics_knobs ) if (. not . save_for_restart ) nsave = - 1 end if end subroutine read_parameters !> Allocate the module-level arrays subroutine allocate_arrays use species , only : nspec use kt_grids , only : nakx , naky implicit none if (. not . allocated ( pflux )) allocate ( pflux ( nakx , naky , nspec )); pflux = 0. if (. not . allocated ( qflux )) allocate ( qflux ( nakx , naky , nspec )); qflux = 0. if (. not . allocated ( vflux )) allocate ( vflux ( nakx , naky , nspec )); vflux = 0. if (. not . allocated ( exchange )) allocate ( exchange ( nakx , naky , nspec )); exchange = 0. if (. not . allocated ( pflux_avg )) allocate ( pflux_avg ( nspec )); pflux_avg = 0. if (. not . allocated ( qflux_avg )) allocate ( qflux_avg ( nspec )); qflux_avg = 0. if (. not . allocated ( vflux_avg )) allocate ( vflux_avg ( nspec )); vflux_avg = 0. if (. not . allocated ( heat_avg )) allocate ( heat_avg ( nspec )); heat_avg = 0. if (. not . allocated ( omega_vs_time )) then if ( write_omega ) then allocate ( omega_vs_time ( navg , naky , nakx )) omega_vs_time = 0. else allocate ( omega_vs_time ( 1 , 1 , 1 )) navg = 1 end if end if end subroutine allocate_arrays !> Open the '.out' and the '.fluxes' file. !> !> When running a new simulation, create a new file or replace an old file. !> When restarting a simulation, append the old files. subroutine open_loop_ascii_files ( restart ) use file_utils , only : open_output_file use species , only : nspec implicit none logical , intent ( in ) :: restart character ( 3 ) :: nspec_str character ( 100 ) :: str logical :: overwrite ! Do not overwrite, but append files, when we restart the simulation. overwrite = . not . restart ! Open the '.out' and the '.fluxes' files. call open_output_file ( stdout_unit , '.out' , overwrite ) call open_output_file ( fluxes_unit , '.fluxes' , overwrite ) ! Create the header for the .fluxes file. ! Every column is made up of 12 spaces, so make sure the headers ! are placed correctly since we have the following columns for nspec=3: ! #time pflx1 pflx2 pflx3 vflx1 vflx2 vflx32 qflx1 qflx2 qflx3 if (. not . restart ) then write ( nspec_str , '(i3)' ) nspec * 12 str = trim ( '(2a12,2a' // trim ( nspec_str ) // ')' ) write ( fluxes_unit , str ) '#time' , 'pflx' , 'vflx' , 'qflx' end if ! Open the '.omega' file and create its header. if ( write_omega ) then call open_output_file ( omega_unit , '.omega' , overwrite ) if (. not . restart ) then write ( omega_unit , '(7a12)' ) '#time' , 'ky' , 'kx' , & 'Re[om]' , 'Im[om]' , 'Re[omavg]' , 'Im[omavg]' end if end if end subroutine open_loop_ascii_files !> Close the text files opened by [[open_loop_ascii_files]] subroutine close_loop_ascii_files use file_utils , only : close_output_file implicit none call close_output_file ( stdout_unit ) call close_output_file ( fluxes_unit ) if ( write_omega ) call close_output_file ( omega_unit ) end subroutine close_loop_ascii_files !> Calculate and write diagnostics subroutine diagnose_stella ( istep ) use mp , only : proc0 use constants , only : zi use redistribute , only : scatter use fields_arrays , only : phi , apar , bpar use fields_arrays , only : phi_old , phi_corr_QN , apar_old use fields , only : fields_updated , advance_fields use dist_fn_arrays , only : gvmu , gnew use g_tofrom_h , only : g_to_h use stella_io , only : write_time_nc use stella_io , only : write_phi2_nc , write_apar2_nc , write_bpar2_nc use stella_io , only : write_phi_nc , write_apar_nc , write_bpar_nc use stella_io , only : write_gvmus_nc use stella_io , only : write_gzvs_nc use stella_io , only : write_kspectra_nc , write_kspectra_species_nc use stella_io , only : write_moments_nc use stella_io , only : write_omega_nc use stella_io , only : write_fluxes_nc use stella_io , only : write_radial_fluxes_nc use stella_io , only : write_radial_moments_nc use stella_io , only : write_fluxes_kxkyz_nc use stella_io , only : sync_nc use stella_time , only : code_time , code_dt , cfl_dt_ExB use zgrid , only : nztot , nzgrid , ntubes use vpamu_grids , only : nmu , nvpa use species , only : nspec use kt_grids , only : naky , nakx , ikx_max , ny use dist_redistribute , only : kxkyz2vmu use physics_flags , only : radial_variation , full_flux_surface use physics_flags , only : include_apar , include_bpar use volume_averages , only : volume_average , fieldline_average use run_parameters , only : fphi implicit none !> The current timestep integer , intent ( in ) :: istep integer :: is real :: phi2 , apar2 , bpar2 real :: zero real , dimension (:, :, :), allocatable :: gvmus real , dimension (:, :, :, :), allocatable :: gzvs !    real, dimension (:,:,:), allocatable :: pflx_zvpa, vflx_zvpa, qflx_zvpa real , dimension (:), allocatable :: part_flux , mom_flux , heat_flux real , dimension (:, :), allocatable :: part_flux_x , mom_flux_x , heat_flux_x real , dimension (:, :), allocatable :: dens_x , upar_x , temp_x real , dimension (:, :), allocatable :: phi2_vs_kxky , apar2_vs_kxky , bpar2_vs_kxky real , dimension (:, :, :), allocatable :: pflx_vs_kxky , vflx_vs_kxky , qflx_vs_kxky real , dimension (:, :, :, :, :), allocatable :: pflx_kxkyz , vflx_kxkyz , qflx_kxkyz complex , dimension (:, :, :, :, :), allocatable :: density , upar , temperature , spitzer2 complex , dimension (:, :), allocatable :: omega_avg complex , dimension (:, :), allocatable :: phiavg , phioldavg , aparavg , aparoldavg complex , dimension (:, :, :, :), allocatable :: phi_out , apar_out , bpar_out !> needed when simulating a full flux surface complex , dimension (:, :, :, :), allocatable :: dens_ffs , upar_ffs , pres_ffs ! calculation of omega requires computation of omega more ! frequently than every nwrite time steps if ( write_omega . and . proc0 ) then zero = 10 0. * epsilon ( 0. ) if ( istep > 0 ) then allocate ( phiavg ( naky , nakx )) allocate ( phioldavg ( naky , nakx )) allocate ( aparavg ( naky , nakx )) allocate ( aparoldavg ( naky , nakx )) call fieldline_average ( phi , phiavg ) call fieldline_average ( phi_old , phioldavg ) if ( include_apar ) then call fieldline_average ( apar , aparavg ) call fieldline_average ( apar_old , aparoldavg ) ! add <apar> to <phi> in the case <phi> = 0 because the mode has tearing parity ! if the mode is a purely growing mode then ! (<phi&#94;n+1> + <apar&#94;n+1> )/(<phi&#94;n> + <apar&#94;n>) = exp (-i delta t omega) phiavg = phiavg + aparavg phioldavg = phioldavg + aparoldavg end if where ( abs ( phiavg ) < zero . or . abs ( phioldavg ) < zero ) omega_vs_time ( mod ( istep , navg ) + 1 , :, :) = 0.0 elsewhere omega_vs_time ( mod ( istep , navg ) + 1 , :, :) = log ( phiavg / phioldavg ) * zi / code_dt end where deallocate ( phiavg , phioldavg ) deallocate ( aparavg , aparoldavg ) end if end if !> only write data to file every nwrite time steps if ( mod ( istep , nwrite ) /= 0 ) return if ( radial_variation ) fields_updated = . false . !> get the updated fields corresponding to gnew call advance_fields ( gnew , phi , apar , bpar , dist = 'g' ) allocate ( phi_out ( naky , nakx , - nzgrid : nzgrid , ntubes )) allocate ( apar_out ( naky , nakx , - nzgrid : nzgrid , ntubes )) allocate ( bpar_out ( naky , nakx , - nzgrid : nzgrid , ntubes )) phi_out = phi if ( radial_variation ) then phi_out = phi_out + phi_corr_QN end if apar_out = apar bpar_out = bpar allocate ( part_flux ( nspec )) allocate ( mom_flux ( nspec )) allocate ( heat_flux ( nspec )) allocate ( pflx_kxkyz ( naky , nakx , nztot , ntubes , nspec )) allocate ( vflx_kxkyz ( naky , nakx , nztot , ntubes , nspec )) allocate ( qflx_kxkyz ( naky , nakx , nztot , ntubes , nspec )) if ( write_radial_fluxes ) then allocate ( part_flux_x ( nakx , nspec )) allocate ( mom_flux_x ( nakx , nspec )) allocate ( heat_flux_x ( nakx , nspec )) end if if ( full_flux_surface ) then allocate ( dens_ffs ( ny , ikx_max , - nzgrid : nzgrid , nspec )) allocate ( upar_ffs ( ny , ikx_max , - nzgrid : nzgrid , nspec )) allocate ( pres_ffs ( ny , ikx_max , - nzgrid : nzgrid , nspec )) end if !> obtain turbulent fluxes if ( radial_variation . or . write_radial_fluxes ) then !     handle g_to_h in get_fluxes_vmulo to eliminate x&#94;2 terms !     call g_to_h (gnew, phi, fphi, phi_corr_QN) if ( debug ) write ( * , * ) 'stella_diagnostics::write_fluxes_vmulo' call get_fluxes_vmulo ( gnew , phi_out , part_flux , mom_flux , heat_flux , & part_flux_x , mom_flux_x , heat_flux_x , & pflx_kxkyz , vflx_kxkyz , qflx_kxkyz ) !     call g_to_h (gnew, phi, -fphi, phi_corr_QN) else if ( full_flux_surface ) then !> calculate the particle density, parallel flow and pressure in (y,kx,z) space !> for all species if ( debug ) write ( * , * ) 'stella_diagnostics::write_fluxes_ffs' call get_moments_ffs ( gnew , dens_ffs , upar_ffs , pres_ffs ) !> calculate the (ky,kx) contributions to the particle, parallel momentum and energy fluxes call get_fluxes_ffs ( dens_ffs , upar_ffs , pres_ffs , part_flux , mom_flux , heat_flux , & pflx_kxkyz , vflx_kxkyz , qflx_kxkyz ) else if ( debug ) write ( * , * ) 'stella_diagnostics::write_fluxes' !> redistribute data so that data for each vpa and mu are guaranteed to be on each processor call scatter ( kxkyz2vmu , gnew , gvmu ) !> get_fluxes assumes the non-Boltzmann part of the distribution, h, is passed in; !> convert from <delta f> = g to h call g_to_h ( gvmu , phi , bpar , fphi ) !> compute the fluxes call get_fluxes ( gvmu , part_flux , mom_flux , heat_flux , & pflx_kxkyz , vflx_kxkyz , qflx_kxkyz ) !> convert back from h to g call g_to_h ( gvmu , phi , bpar , - fphi ) end if if ( proc0 ) then if ( write_omega ) then allocate ( omega_avg ( naky , nakx )) omega_avg = sum ( omega_vs_time , dim = 1 ) / real ( navg ) else allocate ( omega_avg ( 1 , 1 )) end if call volume_average ( phi_out , phi2 ) call volume_average ( apar_out , apar2 ) call volume_average ( bpar_out , bpar2 ) ! Print information to stella.out, the header is printed in stella.f90 write ( * , '(A2,I7,A2,ES12.4,A2,ES12.4,A2,ES12.4,A2,ES12.4)' ) & \" \" , istep , \" \" , code_time , \" \" , code_dt , \" \" , cfl_dt_ExB , \" \" , phi2 call write_loop_ascii_files ( istep , phi2 , apar2 , bpar2 , part_flux , mom_flux , heat_flux , & omega_vs_time ( mod ( istep , navg ) + 1 , :, :), omega_avg ) ! do not need omega_avg again this time step deallocate ( omega_avg ) end if if ( mod ( istep , nwrite * nc_mult ) == 0 ) then if ( proc0 ) then if ( debug ) write ( * , * ) 'stella_diagnostics::write_time_nc' call write_time_nc ( nout , code_time ) if ( write_omega ) call write_omega_nc ( nout , omega_vs_time ( mod ( istep , navg ) + 1 , :, :)) call write_phi2_nc ( nout , phi2 ) call write_apar2_nc ( nout , apar2 ) call write_bpar2_nc ( nout , bpar2 ) call write_fluxes_nc ( nout , part_flux , mom_flux , heat_flux ) if ( write_phi_vs_time ) then if ( debug ) write ( * , * ) 'stella_diagnostics::diagnose_stella::write_phi_nc' call write_phi_nc ( nout , phi_out ) end if if ( write_apar_vs_time ) then if ( debug ) write ( * , * ) 'stella_diagnostics::diagnose_stella::write_apar_nc' call write_apar_nc ( nout , apar_out ) end if if ( write_bpar_vs_time ) then if ( debug ) write ( * , * ) 'stella_diagnostics::diagnose_stella::write_bpar_nc' call write_bpar_nc ( nout , bpar_out ) end if if ( write_kspectra ) then if ( debug ) write ( * , * ) 'stella_diagnostics::diagnose_stella::write_kspectra' allocate ( phi2_vs_kxky ( naky , nakx )) call fieldline_average ( real ( phi_out * conjg ( phi_out )), phi2_vs_kxky ) call write_kspectra_nc ( nout , phi2_vs_kxky , \"phi2_vs_kxky\" , \"electrostatic potential\" ) deallocate ( phi2_vs_kxky ) if ( include_apar ) then allocate ( apar2_vs_kxky ( naky , nakx )) call fieldline_average ( real ( apar_out * conjg ( apar_out )), apar2_vs_kxky ) call write_kspectra_nc ( nout , apar2_vs_kxky , \"apar2_vs_kxky\" , \"parallel vector potential\" ) deallocate ( apar2_vs_kxky ) end if if ( include_bpar ) then allocate ( bpar2_vs_kxky ( naky , nakx )) call fieldline_average ( real ( bpar_out * conjg ( bpar_out )), bpar2_vs_kxky ) call write_kspectra_nc ( nout , bpar2_vs_kxky , \"bpar2_vs_kxky\" , \"parallel magnetic field fluctuation\" ) deallocate ( bpar2_vs_kxky ) end if !> here write out the spectrum of contributions to the fluxes, after averaging over zed allocate ( pflx_vs_kxky ( naky , nakx , nspec )) do is = 1 , nspec !call fieldline_average(pflx_kxkyz(:,:,:,:,is), pflx_vs_kxky(:,:,is)) pflx_vs_kxky (:,:, is ) = sum ( sum ( pflx_kxkyz (:,:,:,:, is ), dim = 4 ), dim = 3 ) end do call write_kspectra_species_nc ( nout , pflx_vs_kxky , \"pflx_vs_kxky\" , \"particle flux contributions by (kx,ky)\" ) deallocate ( pflx_vs_kxky ) allocate ( vflx_vs_kxky ( naky , nakx , nspec )) do is = 1 , nspec !call fieldline_average(vflx_kxkyz(:,:,:,:,is), vflx_vs_kxky(:,:,is)) vflx_vs_kxky (:,:, is ) = sum ( sum ( vflx_kxkyz (:,:,:,:, is ), dim = 4 ), dim = 3 ) end do call write_kspectra_species_nc ( nout , vflx_vs_kxky , \"vflx_vs_kxky\" , \"momentum flux contributions by (kx,ky)\" ) deallocate ( vflx_vs_kxky ) allocate ( qflx_vs_kxky ( naky , nakx , nspec )) do is = 1 , nspec !call fieldline_average(qflx_kxkyz(:,:,:,:,is), qflx_vs_kxky(:,:,is)) qflx_vs_kxky (:,:, is ) = sum ( sum ( qflx_kxkyz (:,:,:,:, is ), dim = 4 ), dim = 3 ) end do call write_kspectra_species_nc ( nout , qflx_vs_kxky , \"qflx_vs_kxky\" , \"heat flux contributions by (kx,ky)\" ) deallocate ( qflx_vs_kxky ) end if if ( write_radial_fluxes ) then call write_radial_fluxes_nc ( nout , part_flux_x , mom_flux_x , heat_flux_x ) end if end if if ( write_moments . or . write_radial_moments ) then if ( debug ) write ( * , * ) 'stella_diagnostics::diagnose_stella::write_moments' allocate ( density ( naky , nakx , nztot , ntubes , nspec )) allocate ( upar ( naky , nakx , nztot , ntubes , nspec )) allocate ( temperature ( naky , nakx , nztot , ntubes , nspec )) allocate ( spitzer2 ( naky , nakx , nztot , ntubes , nspec )) if ( write_radial_moments ) then allocate ( dens_x ( nakx , nspec )) allocate ( upar_x ( nakx , nspec )) allocate ( temp_x ( nakx , nspec )) end if call get_moments ( gnew , density , upar , temperature , dens_x , upar_x , temp_x , spitzer2 ) if ( proc0 . and . write_moments ) call write_moments_nc ( nout , density , upar , temperature , spitzer2 ) if ( proc0 . and . write_radial_moments ) call write_radial_moments_nc ( nout , dens_x , upar_x , temp_x ) deallocate ( density , upar , temperature , spitzer2 ) if ( allocated ( dens_x )) deallocate ( dens_x ) if ( allocated ( upar_x )) deallocate ( upar_x ) if ( allocated ( temp_x )) deallocate ( temp_x ) end if if ( write_fluxes_kxkyz ) then if ( debug ) write ( * , * ) 'stella_diagnostics::diagnose_stella::write_fluxes_kxkyz' if ( proc0 ) call write_fluxes_kxkyz_nc ( nout , pflx_kxkyz , vflx_kxkyz , qflx_kxkyz ) end if if ( write_gvmus ) then allocate ( gvmus ( nvpa , nmu , nspec )) if ( debug ) write ( * , * ) 'stella_diagnostics::diagnose_stella::get_gvmus' ! note that gvmus is h at this point call get_gvmus ( gvmu , gvmus ) if ( debug ) write ( * , * ) 'stella_diagnostics::diagnose_stella::write_gvmus_nc' if ( proc0 ) call write_gvmus_nc ( nout , gvmus ) deallocate ( gvmus ) end if if ( write_gzvs ) then allocate ( gzvs ( ntubes , nztot , nvpa , nspec )) if ( debug ) write ( * , * ) 'stella_diagnostics::diagnose_stella::get_gzvs' call get_gzvs ( gnew , gzvs ) if ( debug ) write ( * , * ) 'stella_diagnostics::diagnose_stella::write_gzvs_nc' if ( proc0 ) call write_gzvs_nc ( nout , gzvs ) deallocate ( gzvs ) end if if ( proc0 ) call sync_nc nout = nout + 1 end if deallocate ( part_flux , mom_flux , heat_flux ) deallocate ( pflx_kxkyz , vflx_kxkyz , qflx_kxkyz ) deallocate ( phi_out ) deallocate ( apar_out ) deallocate ( bpar_out ) if ( allocated ( part_flux_x )) deallocate ( part_flux_x ) if ( allocated ( mom_flux_x )) deallocate ( mom_flux_x ) if ( allocated ( heat_flux_x )) deallocate ( heat_flux_x ) if ( allocated ( dens_ffs )) deallocate ( dens_ffs ) if ( allocated ( upar_ffs )) deallocate ( upar_ffs ) if ( allocated ( pres_ffs )) deallocate ( pres_ffs ) !    nout = nout + 1 end subroutine diagnose_stella !> Calculate fluxes !> !> Assumes that the non-Boltzmann part of df is passed in (aka h) subroutine get_fluxes ( g , pflx , vflx , qflx , & pflx_vs_kxkyz , vflx_vs_kxkyz , qflx_vs_kxkyz ) use mp , only : sum_reduce use constants , only : zi use fields_arrays , only : phi , apar , bpar use stella_layouts , only : kxkyz_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , it_idx , is_idx use species , only : spec , nspec use stella_geometry , only : jacob , grho , bmag , btor use stella_geometry , only : gds21 , gds22 use stella_geometry , only : geo_surf use zgrid , only : delzed , nzgrid , ntubes use vpamu_grids , only : nvpa , nmu use vpamu_grids , only : vperp2 , vpa , mu use physics_flags , only : include_apar , include_bpar use run_parameters , only : fphi use kt_grids , only : aky , theta0 use gyro_averages , only : gyro_average , gyro_average_j1 implicit none complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( in ) :: g real , dimension (:), intent ( out ) :: pflx , vflx , qflx real , dimension (:, :, - nzgrid :, :, :), intent ( out ) :: pflx_vs_kxkyz , vflx_vs_kxkyz , qflx_vs_kxkyz integer :: ikxkyz , iky , ikx , iz , it , is , ia real , dimension (:), allocatable :: flx_norm real :: flx_norm_partial complex , dimension (:, :), allocatable :: gtmp1 , gtmp2 , gtmp3 allocate ( flx_norm ( - nzgrid : nzgrid )) allocate ( gtmp1 ( nvpa , nmu ), gtmp2 ( nvpa , nmu ), gtmp3 ( nvpa , nmu )) pflx = 0. ; vflx = 0. ; qflx = 0. pflx_vs_kxkyz = 0. ; vflx_vs_kxkyz = 0. ; qflx_vs_kxkyz = 0. flx_norm = jacob ( 1 , :) * delzed flx_norm ( - nzgrid ) = 0.5 * flx_norm ( - nzgrid ) flx_norm ( nzgrid ) = 0.5 * flx_norm ( nzgrid ) if ( flux_norm ) then ! Flux definition with an extra factor 1/<\\nabla\\rho> in front. flx_norm_partial = sum ( flx_norm ) / sum ( flx_norm * grho ( 1 , :)) flx_norm = flx_norm / sum ( flx_norm * grho ( 1 , :)) else ! Flux definition without the extra factor. flx_norm_partial = 1.0 flx_norm = flx_norm / sum ( flx_norm ) end if ia = 1 ! get electrostatic contributions to fluxes if ( fphi > epsilon ( 0.0 )) then do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) ! get particle flux call gyro_average ( g (:, :, ikxkyz ), ikxkyz , gtmp1 ) call get_one_flux ( iky , iz , flx_norm ( iz ), gtmp1 , phi ( iky , ikx , iz , it ), pflx ( is )) call get_one_flux ( iky , iz , flx_norm ( iz ), gtmp1 , phi ( iky , ikx , iz , it ), pflx_vs_kxkyz ( iky , ikx , iz , it , is )) ! get heat flux ! NEEDS TO BE MODIFIED TO TREAT ENERGY = ENERGY(ALPHA) gtmp1 = gtmp1 * ( spread ( vpa ** 2 , 2 , nmu ) + spread ( vperp2 ( 1 , iz , :), 1 , nvpa )) call get_one_flux ( iky , iz , flx_norm ( iz ), gtmp1 , phi ( iky , ikx , iz , it ), qflx ( is )) call get_one_flux ( iky , iz , flx_norm ( iz ), gtmp1 , phi ( iky , ikx , iz , it ), qflx_vs_kxkyz ( iky , ikx , iz , it , is )) ! get momentum flux ! parallel component gtmp1 = g (:, :, ikxkyz ) * spread ( vpa , 2 , nmu ) * geo_surf % rmaj * btor ( iz ) / bmag ( ia , iz ) call gyro_average ( gtmp1 , ikxkyz , gtmp2 ) gtmp1 = - g (:, :, ikxkyz ) * zi * aky ( iky ) * spread ( vperp2 ( ia , iz , :), 1 , nvpa ) * geo_surf % rhoc & * ( gds21 ( ia , iz ) + theta0 ( iky , ikx ) * gds22 ( ia , iz )) * spec ( is )% smz & / ( geo_surf % qinp * geo_surf % shat * bmag ( ia , iz ) ** 2 ) call gyro_average_j1 ( gtmp1 , ikxkyz , gtmp3 ) gtmp1 = gtmp2 + gtmp3 call get_one_flux ( iky , iz , flx_norm ( iz ), gtmp1 , phi ( iky , ikx , iz , it ), vflx ( is )) call get_one_flux ( iky , iz , flx_norm ( iz ), gtmp1 , phi ( iky , ikx , iz , it ), vflx_vs_kxkyz ( iky , ikx , iz , it , is )) end do end if if ( include_apar ) then ! particle flux do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) ! Apar contribution to particle flux gtmp1 = - 2.0 * g (:, :, ikxkyz ) * spec ( is )% stm * spread ( vpa , 2 , nmu ) call gyro_average ( gtmp1 , ikxkyz , gtmp2 ) call get_one_flux ( iky , iz , flx_norm ( iz ), gtmp2 , apar ( iky , ikx , iz , it ), pflx ( is )) call get_one_flux ( iky , iz , flx_norm ( iz ), gtmp2 , apar ( iky , ikx , iz , it ), pflx_vs_kxkyz ( iky , ikx , iz , it , is )) ! Apar contribution to heat flux gtmp2 = gtmp2 * ( spread ( vpa ** 2 , 2 , nmu ) + spread ( vperp2 ( ia , iz , :), 1 , nvpa )) call get_one_flux ( iky , iz , flx_norm ( iz ), gtmp2 , apar ( iky , ikx , iz , it ), qflx ( is )) call get_one_flux ( iky , iz , flx_norm ( iz ), gtmp2 , apar ( iky , ikx , iz , it ), qflx_vs_kxkyz ( iky , ikx , iz , it , is )) ! Apar contribution to momentum flux ! parallel component gtmp1 = - 2.0 * spread ( vpa ** 2 , 2 , nmu ) * spec ( is )% stm * g (:, :, ikxkyz ) & * geo_surf % rmaj * btor ( iz ) / bmag ( 1 , iz ) call gyro_average ( gtmp1 , ikxkyz , gtmp2 ) ! perp component gtmp1 = 2.0 * spread ( vpa , 2 , nmu ) * spec ( is )% stm * g (:, :, ikxkyz ) & * zi * aky ( iky ) * spread ( vperp2 ( ia , iz , :), 1 , nvpa ) * geo_surf % rhoc & * ( gds21 ( ia , iz ) + theta0 ( iky , ikx ) * gds22 ( ia , iz )) * spec ( is )% smz & / ( geo_surf % qinp * geo_surf % shat * bmag ( ia , iz ) ** 2 ) call gyro_average_j1 ( gtmp1 , ikxkyz , gtmp3 ) ! FLAG -- NEED TO ADD IN CONTRIBUTION FROM BOLTZMANN PIECE !! gtmp1 = gtmp2 + gtmp3 call get_one_flux ( iky , iz , flx_norm ( iz ), gtmp1 , apar ( iky , ikx , iz , it ), vflx ( is )) call get_one_flux ( iky , iz , flx_norm ( iz ), gtmp1 , apar ( iky , ikx , iz , it ), vflx_vs_kxkyz ( iky , ikx , iz , it , is )) end do end if if ( include_bpar ) then ! particle flux do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) ! Bpar contribution to particle flux gtmp1 = 4.0 * g (:, :, ikxkyz ) * spec ( is )% tz * spread ( mu , 1 , nvpa ) call gyro_average_j1 ( gtmp1 , ikxkyz , gtmp2 ) call get_one_flux ( iky , iz , flx_norm ( iz ), gtmp2 , bpar ( iky , ikx , iz , it ), pflx ( is )) call get_one_flux ( iky , iz , flx_norm ( iz ), gtmp2 , bpar ( iky , ikx , iz , it ), pflx_vs_kxkyz ( iky , ikx , iz , it , is )) ! Bpar contribution to heat flux gtmp2 = gtmp2 * ( spread ( vpa ** 2 , 2 , nmu ) + spread ( vperp2 ( ia , iz , :), 1 , nvpa )) call get_one_flux ( iky , iz , flx_norm ( iz ), gtmp2 , bpar ( iky , ikx , iz , it ), qflx ( is )) call get_one_flux ( iky , iz , flx_norm ( iz ), gtmp2 , bpar ( iky , ikx , iz , it ), qflx_vs_kxkyz ( iky , ikx , iz , it , is )) ! Bpar contribution to momentum flux ! parallel component gtmp1 = 4.0 * spec ( is )% tz * spread ( mu , 1 , nvpa ) * g (:, :, ikxkyz ) & * spread ( vpa , 2 , nmu ) * geo_surf % rmaj * btor ( iz ) / bmag ( ia , iz ) call gyro_average_j1 ( gtmp1 , ikxkyz , gtmp2 ) ! perp component gtmp3 = 0.0 ! NOT SUPPORTED, REQUIRES d J1(x)/ d x gtmp1 = gtmp2 + gtmp3 call get_one_flux ( iky , iz , flx_norm ( iz ), gtmp1 , bpar ( iky , ikx , iz , it ), vflx ( is )) call get_one_flux ( iky , iz , flx_norm ( iz ), gtmp1 , bpar ( iky , ikx , iz , it ), vflx_vs_kxkyz ( iky , ikx , iz , it , is )) end do end if call sum_reduce ( pflx , 0 ); pflx = pflx * spec % dens_psi0 call sum_reduce ( qflx , 0 ); qflx = qflx * spec % dens_psi0 * spec % temp_psi0 call sum_reduce ( vflx , 0 ); vflx = vflx * spec % dens_psi0 * sqrt ( spec % mass * spec % temp_psi0 ) ! normalise to account for contributions from multiple flux tubes ! in flux tube train pflx = pflx / real ( ntubes ) qflx = qflx / real ( ntubes ) vflx = vflx / real ( ntubes ) call sum_reduce ( pflx_vs_kxkyz , 0 ) call sum_reduce ( qflx_vs_kxkyz , 0 ) call sum_reduce ( vflx_vs_kxkyz , 0 ) do is = 1 , nspec pflx_vs_kxkyz (:, :, :, :, is ) = pflx_vs_kxkyz (:, :, :, :, is ) * spec ( is )% dens_psi0 qflx_vs_kxkyz (:, :, :, :, is ) = qflx_vs_kxkyz (:, :, :, :, is ) * spec ( is )% dens_psi0 * spec ( is )% temp_psi0 vflx_vs_kxkyz (:, :, :, :, is ) = vflx_vs_kxkyz (:, :, :, :, is ) * spec ( is )% dens_psi0 * sqrt ( spec ( is )% mass * spec ( is )% temp_psi0 ) end do deallocate ( gtmp1 , gtmp2 , gtmp3 ) deallocate ( flx_norm ) end subroutine get_fluxes !============================================== !============ GET FLUXES VMULO ================ !============================================== subroutine get_fluxes_vmulo ( g , phi , pflx , vflx , qflx , & pflx_x , vflx_x , qflx_x , & pflx_vs_kxkyz , vflx_vs_kxkyz , qflx_vs_kxkyz ) use mp , only : sum_reduce use constants , only : zi use dist_fn_arrays , only : g1 , g2 , kperp2 , dkperp2dr use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx , imu_idx , is_idx use species , only : spec use stella_geometry , only : grho_norm , bmag , btor use stella_geometry , only : drhodpsi use stella_geometry , only : gds21 , gds22 use stella_geometry , only : dgds21dr , dgds22dr use stella_geometry , only : geo_surf use stella_geometry , only : dBdrho , dIdrho use zgrid , only : nzgrid , ntubes use vpamu_grids , only : vperp2 , vpa , mu use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use run_parameters , only : fphi use run_parameters , only : maxwellian_normalization use kt_grids , only : aky , theta0 , naky , nakx , multiply_by_rho use physics_flags , only : radial_variation use gyro_averages , only : gyro_average , gyro_average_j1 , aj0x , aj1x implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: phi real , dimension (:), intent ( out ) :: pflx , vflx , qflx real , dimension (:, :), intent ( out ) :: pflx_x , vflx_x , qflx_x real , dimension (:, :, - nzgrid :, :, :), intent ( out ) :: pflx_vs_kxkyz , vflx_vs_kxkyz , qflx_vs_kxkyz integer :: ivmu , imu , iv , iz , it , is , ia real :: flx_norm complex , dimension (:, :), allocatable :: g0k , g1k pflx = 0. ; vflx = 0. ; qflx = 0. pflx_x = 0. ; vflx_x = 0. ; qflx_x = 0. pflx_vs_kxkyz = 0. ; vflx_vs_kxkyz = 0. ; qflx_vs_kxkyz = 0. ia = 1 if ( flux_norm ) then flx_norm = 1. / grho_norm else flx_norm = 1. end if allocate ( g0k ( naky , nakx )) allocate ( g1k ( naky , nakx )) ! FLAG - electrostatic for now ! get electrostatic contributions to fluxes if ( fphi > epsilon ( 0.0 )) then ia = 1 !get particle flux do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) call gyro_average ( g (:, :, :, :, ivmu ), ivmu , g1 (:, :, :, :, ivmu )) do it = 1 , ntubes do iz = - nzgrid , nzgrid if ( radial_variation ) then g0k = g1 (:, :, iz , it , ivmu ) & * ( - 0.5 * aj1x (:, :, iz , ivmu ) / aj0x (:, :, iz , ivmu ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 (:, :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) & + dBdrho ( iz ) / bmag ( ia , iz )) call multiply_by_rho ( g0k ) g1 (:, :, iz , it , ivmu ) = g1 (:, :, iz , it , ivmu ) + g0k end if !subtract adiabatic contribution part of g g0k = spec ( is )% zt * fphi * phi (:, :, iz , it ) * aj0x (:, :, iz , ivmu ) ** 2 if (. not . maxwellian_normalization ) then g0k = g0k * maxwell_vpa ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) * maxwell_fac ( is ) end if if ( radial_variation ) then g1k = g0k * ( - spec ( is )% tprim * ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu ) - 2.5 ) & - spec ( is )% fprim - 2.0 * dBdrho ( iz ) * mu ( imu ) & - aj1x (:, :, iz , ivmu ) / aj0x (:, :, iz , ivmu ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 (:, :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) & + dBdrho ( iz ) / bmag ( ia , iz )) call multiply_by_rho ( g1k ) g0k = g0k + g1k end if g1 (:, :, iz , it , ivmu ) = g1 (:, :, iz , it , ivmu ) + g0k end do end do end do call get_one_flux_vmulo ( flx_norm * spec % dens_psi0 , g1 , phi , pflx ) call get_one_flux_vmulo ( flx_norm * spec % dens_psi0 , g1 , phi , pflx_vs_kxkyz ) if ( write_radial_fluxes ) then call get_one_flux_radial ( flx_norm * spec % dens_psi0 , g1 , phi , pflx_x ) end if !get heat flux do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) call gyro_average ( g (:, :, :, :, ivmu ), ivmu , g1 (:, :, :, :, ivmu )) do it = 1 , ntubes do iz = - nzgrid , nzgrid g1 (:, :, iz , it , ivmu ) = g1 (:, :, iz , it , ivmu ) * ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu )) if ( radial_variation ) then g0k = g1 (:, :, iz , it , ivmu ) & * ( - 0.5 * aj1x (:, :, iz , ivmu ) / aj0x (:, :, iz , ivmu ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 (:, :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) & + dBdrho ( iz ) / bmag ( ia , iz ) & + 2.0 * mu ( imu ) * dBdrho ( iz ) / ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu ))) call multiply_by_rho ( g0k ) g1 (:, :, iz , it , ivmu ) = g1 (:, :, iz , it , ivmu ) + g0k end if !subtract adiabatic contribution part of g g0k = spec ( is )% zt * fphi * phi (:, :, iz , it ) * aj0x (:, :, iz , ivmu ) ** 2 & * ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu )) if (. not . maxwellian_normalization ) then g0k = g0k * maxwell_vpa ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) * maxwell_fac ( is ) end if if ( radial_variation ) then g1k = g0k * ( - spec ( is )% tprim * ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu ) - 2.5 ) & - spec ( is )% fprim - 2.0 * dBdrho ( iz ) * mu ( imu ) & - aj1x (:, :, iz , ivmu ) / aj0x (:, :, iz , ivmu ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 (:, :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) & + dBdrho ( iz ) / bmag ( ia , iz ) & + 2.0 * mu ( imu ) * dBdrho ( iz ) / ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu ))) call multiply_by_rho ( g1k ) g0k = g0k + g1k end if g1 (:, :, iz , it , ivmu ) = g1 (:, :, iz , it , ivmu ) + g0k end do end do end do call get_one_flux_vmulo ( flx_norm * spec % dens_psi0 * spec % temp_psi0 , g1 , phi , qflx ) call get_one_flux_vmulo ( flx_norm * spec % dens_psi0 * spec % temp_psi0 , g1 , phi , qflx_vs_kxkyz ) if ( write_radial_fluxes ) then call get_one_flux_radial ( flx_norm * spec % dens_psi0 * spec % temp_psi0 , g1 , phi , qflx_x ) end if ! get momentum flux do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) do it = 1 , ntubes do iz = - nzgrid , nzgrid ! parallel component g0k = g (:, :, iz , it , ivmu ) * vpa ( iv ) * geo_surf % rmaj * btor ( iz ) / bmag ( ia , iz ) call gyro_average ( g0k , iz , ivmu , g1 (:, :, iz , it , ivmu )) if ( radial_variation ) then g0k = g1 (:, :, iz , it , ivmu ) & * ( - 0.5 * aj1x (:, :, iz , ivmu ) / aj0x (:, :, iz , ivmu ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 (:, :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) & + dIdrho / ( geo_surf % rmaj * btor ( iz ))) call multiply_by_rho ( g0k ) g1 (:, :, iz , it , ivmu ) = g1 (:, :, iz , it , ivmu ) + g0k end if !subtract adiabatic contribution part of g g0k = spec ( is )% zt * fphi * phi (:, :, iz , it ) * aj0x (:, :, iz , ivmu ) ** 2 & * vpa ( iv ) * geo_surf % rmaj * btor ( iz ) / bmag ( ia , iz ) if (. not . maxwellian_normalization ) then g0k = g0k * maxwell_vpa ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) * maxwell_fac ( is ) end if if ( radial_variation ) then g1k = g0k * ( - spec ( is )% tprim * ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu ) - 2.5 ) & - spec ( is )% fprim - 2.0 * dBdrho ( iz ) * mu ( imu ) & - aj1x (:, :, iz , ivmu ) / aj0x (:, :, iz , ivmu ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 (:, :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) & + dIdrho / ( geo_surf % rmaj * btor ( iz ))) call multiply_by_rho ( g1k ) g0k = g0k + g1k end if g1 (:, :, iz , it , ivmu ) = g1 (:, :, iz , it , ivmu ) + g0k ! perpendicular component g0k = - g (:, :, iz , it , ivmu ) * zi * spread ( aky , 2 , nakx ) * vperp2 ( ia , iz , imu ) * geo_surf % rhoc & * ( gds21 ( ia , iz ) + theta0 * gds22 ( ia , iz )) * spec ( is )% smz & / ( geo_surf % qinp * geo_surf % shat * bmag ( ia , iz ) ** 2 ) call gyro_average_j1 ( g0k , iz , ivmu , g2 (:, :, iz , it , ivmu )) if ( radial_variation ) then g0k = - g (:, :, iz , it , ivmu ) * zi * spread ( aky , 2 , nakx ) * vperp2 ( ia , iz , imu ) * geo_surf % rhoc & * ( dgds21dr ( ia , iz ) + theta0 * dgds22dr ( ia , iz )) * aj1x (:, :, iz , ivmu ) * spec ( is )% smz & / ( geo_surf % qinp * geo_surf % shat * bmag ( ia , iz ) ** 2 ) g0k = g0k - g (:, :, iz , it , ivmu ) * zi * spread ( aky , 2 , nakx ) * vperp2 ( ia , iz , imu ) * geo_surf % rhoc & * ( gds21 ( ia , iz ) + theta0 * gds22 ( ia , iz )) * spec ( is )% smz & / ( geo_surf % qinp * geo_surf % shat * bmag ( ia , iz ) ** 2 ) & * ( 0.5 * aj0x (:, :, iz , ivmu ) - aj1x (:, :, iz , ivmu )) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) g0k = g0k + g2 (:, :, iz , it , ivmu ) & * ( - geo_surf % d2qdr2 * geo_surf % rhoc / ( geo_surf % shat * geo_surf % qinp ) & - geo_surf % d2psidr2 * drhodpsi ) call multiply_by_rho ( g0k ) g2 (:, :, iz , it , ivmu ) = g2 (:, :, iz , it , ivmu ) + g0k end if !subtract adiabatic contribution part of g g0k = - spec ( is )% zt * fphi * phi (:, :, iz , it ) * aj0x (:, :, iz , ivmu ) * aj1x (:, :, iz , ivmu ) & * zi * spread ( aky , 2 , nakx ) * vperp2 ( ia , iz , imu ) * geo_surf % rhoc & * ( gds21 ( ia , iz ) + theta0 * gds22 ( ia , iz )) * spec ( is )% smz & / ( geo_surf % qinp * geo_surf % shat * bmag ( ia , iz ) ** 2 ) if (. not . maxwellian_normalization ) then g0k = g0k * maxwell_vpa ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) * maxwell_fac ( is ) end if if ( radial_variation ) then g1k = - spec ( is )% zt * fphi * phi (:, :, iz , it ) * aj0x (:, :, iz , ivmu ) * aj1x (:, :, iz , ivmu ) & * maxwell_vpa ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) * maxwell_fac ( is ) & * zi * spread ( aky , 2 , nakx ) * vperp2 ( ia , iz , imu ) * geo_surf % rhoc & * ( dgds21dr ( ia , iz ) + theta0 * dgds22dr ( ia , iz )) * spec ( is )% smz & / ( geo_surf % qinp * geo_surf % shat * bmag ( ia , iz ) ** 2 ) g1k = g1k - spec ( is )% zt * fphi * phi (:, :, iz , it ) * aj0x (:, :, iz , ivmu ) & * maxwell_vpa ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) * maxwell_fac ( is ) & * zi * spread ( aky , 2 , nakx ) * vperp2 ( ia , iz , imu ) * geo_surf % rhoc & * ( gds21 ( ia , iz ) + theta0 * gds22 ( ia , iz )) * spec ( is )% smz & / ( geo_surf % qinp * geo_surf % shat * bmag ( ia , iz ) ** 2 ) & * ( 0.5 * aj0x (:, :, iz , ivmu ) - aj1x (:, :, iz , ivmu )) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) g1k = g1k + & g0k * ( - spec ( is )% tprim * ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu ) - 2.5 ) & - spec ( is )% fprim - 2.0 * dBdrho ( iz ) * mu ( imu ) & - 0.5 * aj1x (:, :, iz , ivmu ) / aj0x (:, :, iz , ivmu ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 (:, :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) & - geo_surf % d2qdr2 * geo_surf % rhoc / ( geo_surf % shat * geo_surf % qinp ) & - geo_surf % d2psidr2 * drhodpsi ) call multiply_by_rho ( g1k ) g0k = g0k + g1k end if g2 (:, :, iz , it , ivmu ) = g2 (:, :, iz , it , ivmu ) + g0k end do end do end do g1 = g1 + g2 call get_one_flux_vmulo ( flx_norm * spec % dens_psi0 * sqrt ( spec % mass * spec % temp_psi0 ), g1 , phi , vflx ) call get_one_flux_vmulo ( flx_norm * spec % dens_psi0 * sqrt ( spec % mass * spec % temp_psi0 ), g1 , phi , vflx_vs_kxkyz ) if ( write_radial_fluxes ) then call get_one_flux_radial ( flx_norm * spec % dens_psi0 * sqrt ( spec % mass * spec % temp_psi0 ), g1 , phi , vflx_x ) end if end if if ( allocated ( g0k )) deallocate ( g0k ) if ( allocated ( g1k )) deallocate ( g1k ) end subroutine get_fluxes_vmulo !> Calculate the total particle, momentum and heat fluxes (pflx, vflx, qflx) !> and the contributions from a given (kx,ky,z) location (pflx_kxkyz, vflx_kxkyz, qflx_kxkyz) !> inputs are the particle density (dens), parallel flow (upar) and pressure (pres) subroutine get_fluxes_ffs ( dens , upar , pres , pflx , vflx , qflx , & pflx_vs_kxkyz , vflx_vs_kxkyz , qflx_vs_kxkyz ) use constants , only : zi use zgrid , only : nzgrid , delzed use kt_grids , only : naky , nakx , ny use kt_grids , only : aky , dy use fields_arrays , only : phi use stella_geometry , only : grad_x , jacob implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: dens , upar , pres real , dimension (:), intent ( out ) :: pflx , vflx , qflx real , dimension (:, :, - nzgrid :, :, :), intent ( out ) :: pflx_vs_kxkyz , vflx_vs_kxkyz , qflx_vs_kxkyz integer :: iky , it real :: flux_surface_area , gradx_fsa real :: flxfac complex , dimension (:, :, :), allocatable :: dphidy !> assume a single flux annulus it = 1 allocate ( dphidy ( naky , nakx , - nzgrid : nzgrid )) !> obtain the y-component of the electric field that appears as a factor !> in the flux expression due to the radial component of the ExB velocity do iky = 1 , naky dphidy ( iky , :, :) = zi * aky ( iky ) * conjg ( phi ( iky , :, :, it )) end do !> compute the flux surface area = int dy dz (dalpha/dy)*(dpsi/dx)  / (B . grad z) flux_surface_area = sum ( spread ( delzed * dy , 1 , ny ) * jacob ) !> compute the flux surface average of |grad x| gradx_fsa = sum ( grad_x * jacob * spread ( delzed * dy , 1 , ny )) / flux_surface_area !> flxfac is pre-factor in front of fluxes flxfac = 0.5 / ( flux_surface_area * gradx_fsa ) call get_one_flux_ffs ( dens , dphidy , flxfac , pflx , pflx_vs_kxkyz (:, :, :, it , :)) call get_one_flux_ffs ( pres , dphidy , flxfac , qflx , qflx_vs_kxkyz (:, :, :, it , :)) call get_one_flux_ffs ( upar , dphidy , flxfac , vflx , vflx_vs_kxkyz (:, :, :, it , :)) deallocate ( dphidy ) end subroutine get_fluxes_ffs subroutine get_one_flux_ffs ( mom , dphidy , flxfac , flx , flx_vs_kxkyz ) use species , only : nspec use zgrid , only : nzgrid , delzed use kt_grids , only : naky , nakx use volume_averages , only : mode_fac implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: mom complex , dimension (:, :, - nzgrid :), intent ( in ) :: dphidy real , intent ( in ) :: flxfac real , dimension (:), intent ( out ) :: flx real , dimension (:, :, - nzgrid :, :), intent ( out ) :: flx_vs_kxkyz integer :: iky , ikx , iz , is complex , dimension (:, :, :, :), allocatable :: mom_ky allocate ( mom_ky ( naky , nakx , - nzgrid : nzgrid , nspec )) flx = 0.0 !> divide the input density by the magnetic field strength (due to Jacobian in flux-surfacee avg) !> and Fourier transform in y to get mom_ky = (density/B)(ky,kx,z,spec) call get_modified_fourier_coefficient ( mom , mom_ky ) do is = 1 , nspec !> pflx_vs_kxkyz is the particle flux before summing over (kx,ky) and integrating over z flx_vs_kxkyz (:, :, :, is ) = flxfac * aimag ( mom_ky (:, :, :, is ) * dphidy ) !> calculate the volume average of the particle flux !> note that the factor of 1/B that appears in the Jacobian has already been taken into account !> in the numerator of the flux surface average do iz = - nzgrid , nzgrid do ikx = 1 , nakx do iky = 1 , naky flx ( is ) = flx ( is ) + mode_fac ( iky ) * flx_vs_kxkyz ( iky , ikx , iz , is ) * delzed ( iz ) end do end do end do end do deallocate ( mom_ky ) end subroutine get_one_flux_ffs subroutine get_modified_fourier_coefficient ( moment , moment_ky ) use species , only : nspec use zgrid , only : nzgrid use kt_grids , only : ikx_max , naky_all , ny use kt_grids , only : swap_kxky_back use stella_geometry , only : bmag use stella_transforms , only : transform_y2ky implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: moment complex , dimension (:, :, - nzgrid :, :), intent ( out ) :: moment_ky integer :: ikx , iz , is complex , dimension (:, :), allocatable :: tmp_kykx complex , dimension (:, :), allocatable :: tmp_ykx allocate ( tmp_kykx ( naky_all , ikx_max )) allocate ( tmp_ykx ( ny , ikx_max )) do is = 1 , nspec do iz = - nzgrid , nzgrid do ikx = 1 , ikx_max !> divide the input moment by the magnetic field strength !> to account for Jacobian in flux-surface average tmp_ykx (:, ikx ) = moment (:, ikx , iz , is ) / bmag (:, iz ) end do !> transform the B-modified input moment from y to ky space call transform_y2ky ( tmp_ykx , tmp_kykx ) !> swap from all ky and kx >= 0 to all kx and ky >= 0 call swap_kxky_back ( tmp_kykx , moment_ky (:, :, iz , is )) end do end do deallocate ( tmp_kykx , tmp_ykx ) end subroutine get_modified_fourier_coefficient !============================================================================ !======================== CALCULATE ONE FLUX(IKY,IZ) ======================== !============================================================================ ! For example the particle flux is defined as, !      Re[Γ̃_{s,k}] = FAC*int(Im[conj(phi)*VELOCITY_INTEGRAL]*J*dz)/int(J*dz) ! With FAC = -sgn(psi_t)*(ñ_s/2)*(k̃_y/<|\\tilde{∇}ρ>_ζ) ! With VELOCITY_INTEGRAL = (2B̃/√π) int(int(g̃*J_0) dṽparallel) dμ̃) ! With <norm>(iz) = J(iz)*dz / <|\\tilde{∇}ρ>_ζ and <|\\tilde{∇}ρ0>_ζ = sum(<grho>(iz)*J(iz)*dz) ! With <grho> = a|∇ρ0| = a (dρ0/dψ) ∇ψ = 1/ρ0 * ∇ψ/(a*Bref) = sqrt(|grad_psi_grad_psi|)/ρ0 subroutine get_one_flux ( iky , iz , norm , gin , fld , flxout ) use vpamu_grids , only : integrate_vmu use volume_averages , only : mode_fac use stella_geometry , only : sign_torflux use kt_grids , only : aky implicit none integer , intent ( in ) :: iky , iz real , intent ( in ) :: norm complex , dimension (:, :), intent ( in ) :: gin complex , intent ( in ) :: fld real , intent ( in out ) :: flxout complex :: flx call integrate_vmu ( gin , iz , flx ) flxout = flxout - sign_torflux * 0.5 * mode_fac ( iky ) * aky ( iky ) * aimag ( flx * conjg ( fld )) * norm end subroutine get_one_flux !============================================== !============ GET ONE FLUX VMULO ============== !============================================== subroutine get_one_flux_vmulo_int ( weights , gin , fld , flxout ) use vpamu_grids , only : integrate_vmu use stella_layouts , only : vmu_lo use kt_grids , only : aky , nakx , naky , boundary_size use zgrid , only : nzgrid , ntubes use species , only : nspec use volume_averages , only : mode_fac use stella_geometry , only : dVolume , sign_torflux use stella_transforms , only : transform_kx2x_unpadded use physics_flags , only : radial_variation implicit none real , dimension (:), intent ( in ) :: weights complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: gin complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: fld real , dimension (:), intent ( in out ) :: flxout complex , dimension (:, :, :, :, :), allocatable :: totals complex , dimension (:, :), allocatable :: g0x , g1x integer :: ia , is , it , iz , ikx real , dimension ( nspec ) :: flux_sum real :: volume , factor allocate ( totals ( naky , nakx , - nzgrid : nzgrid , ntubes , nspec )) ia = 1 flux_sum = 0. ! The factor in front of all the flux definitions is <factor> = -sgn(psi_t)/2 ! The constants which differ for each flux are gathered in <weights> and added in <integrate_vmu()> ! For the particle flux <weights> = ñ_s/<|\\tilde{∇}ρ>_ζ = <flx_norm> * <spec%dens_psi0> ! For the heat flux <weights> = ñ_s*T̃_s/<|\\tilde{∇}ρ>_ζ = <flx_norm> * <spec%dens_psi0> * <spec%temp_psi0> ! For the momentum flux <weights> = ñ_s*sqrt(m̃*T̃_s)/<|\\tilde{∇}ρ>_ζ = <flx_norm> * <spec%dens_psi0> * sqrt(<spec%mass> * <spec%temp_psi0>) factor = - sign_torflux * 0.5 call integrate_vmu ( gin , weights , totals ) if ( radial_variation ) then !do it in real-space allocate ( g0x ( naky , nakx )) allocate ( g1x ( naky , nakx )) do is = 1 , nspec volume = 0. do it = 1 , ntubes do iz = - nzgrid , nzgrid call transform_kx2x_unpadded ( totals (:, :, iz , it , is ), g0x ) call transform_kx2x_unpadded ( fld (:, :, iz , it ), g1x ) do ikx = boundary_size + 1 , nakx - boundary_size flux_sum ( is ) = flux_sum ( is ) + & sum ( factor * mode_fac * aky * aimag ( g0x (:, ikx ) * conjg ( g1x (:, ikx ))) * dVolume ( ia , ikx , iz )) volume = volume + dVolume ( ia , ikx , iz ) end do end do end do end do deallocate ( g0x , g1x ) else do is = 1 , nspec volume = 0. do it = 1 , ntubes do iz = - nzgrid , nzgrid do ikx = 1 , nakx flux_sum ( is ) = flux_sum ( is ) + & sum ( factor * mode_fac * aky * aimag ( totals (:, ikx , iz , it , is ) * conjg ( fld (:, ikx , iz , it ))) * dVolume ( ia , 1 , iz )) end do volume = volume + dVolume ( ia , 1 , iz ) end do end do end do end if flxout = flxout + flux_sum / volume deallocate ( totals ) end subroutine get_one_flux_vmulo_int subroutine get_one_flux_vmulo_kxkyz ( weights , gin , fld , flxout ) use vpamu_grids , only : integrate_vmu use stella_layouts , only : vmu_lo use kt_grids , only : aky , nakx , naky use zgrid , only : nzgrid , ntubes use species , only : nspec use volume_averages , only : mode_fac use stella_geometry , only : sign_torflux implicit none real , dimension (:), intent ( in ) :: weights complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: gin complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: fld real , dimension (:, :, - nzgrid :, :, :), intent ( in out ) :: flxout complex , dimension (:, :, :, :, :), allocatable :: totals integer :: ia , is , it , iz , ikx real :: factor allocate ( totals ( naky , nakx , - nzgrid : nzgrid , ntubes , nspec )) ia = 1 factor = - sign_torflux * 0.5 call integrate_vmu ( gin , weights , totals ) do is = 1 , nspec do it = 1 , ntubes do iz = - nzgrid , nzgrid do ikx = 1 , nakx flxout (:, ikx , iz , it , is ) = factor * mode_fac * aky & * aimag ( totals (:, ikx , iz , it , is ) * conjg ( fld (:, ikx , iz , it ))) end do end do end do end do deallocate ( totals ) end subroutine get_one_flux_vmulo_kxkyz !============================================== !=========== GET ONE FLUX RADIAL ============== !============================================== subroutine get_one_flux_radial ( weights , gin , fld , flxout ) use vpamu_grids , only : integrate_vmu use stella_geometry , only : dVolume use stella_layouts , only : vmu_lo use kt_grids , only : aky , nakx , naky use zgrid , only : nzgrid , ntubes use species , only : nspec use volume_averages , only : mode_fac use stella_transforms , only : transform_kx2x_unpadded use stella_geometry , only : sign_torflux implicit none real , dimension (:), intent ( in ) :: weights complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: gin complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: fld real , dimension (:, :), intent ( in out ) :: flxout real , dimension (:), allocatable :: dV_rad complex , dimension (:, :, :, :, :), allocatable :: totals complex , dimension (:, :), allocatable :: g0x , g1x integer :: ia , is , it , iz , ikx real :: factor allocate ( dV_rad ( nakx )) allocate ( g0x ( naky , nakx )) allocate ( g1x ( naky , nakx )) allocate ( totals ( naky , nakx , - nzgrid : nzgrid , ntubes , nspec )) ia = 1 dV_rad = sum ( sum ( dVolume , 3 ), 1 ) * ntubes ! NB: this returns the flux-surface-averaged radial fluxes. Keep in mind that the !     volume element in a flux-surface, dV, may not be uniform across surfaces, so !     one cannot simply sum across the radius here to get the total flux; rather, one !     would have to multiply by dV/V across the radius first call integrate_vmu ( gin , weights , totals ) factor = - sign_torflux * 0.5 do is = 1 , nspec do it = 1 , ntubes do iz = - nzgrid , nzgrid call transform_kx2x_unpadded ( totals (:, :, iz , it , is ), g0x ) call transform_kx2x_unpadded ( fld (:, :, iz , it ), g1x ) do ikx = 1 , nakx flxout ( ikx , is ) = flxout ( ikx , is ) & + sum ( factor * mode_fac * aky * aimag ( g0x (:, ikx ) * conjg ( g1x (:, ikx ))) * dVolume ( ia , ikx , iz ) / dV_rad ( ikx )) end do end do end do end do deallocate ( dV_rad , g0x , g1x , totals ) end subroutine get_one_flux_radial !============================================== !=============== GET MOMENTS ================== !============================================== subroutine get_moments ( g , dens , upar , temp , dens_x , upar_x , temp_x , spitzer2 ) use zgrid , only : nzgrid , ntubes use species , only : spec , nspec use vpamu_grids , only : integrate_vmu use vpamu_grids , only : vpa , vperp2 , mu use vpamu_grids , only : maxwell_mu , ztmax , maxwell_fac , maxwell_vpa use kt_grids , only : ny , naky , nakx , multiply_by_rho , rho_d_clamped use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx , imu_idx , is_idx use dist_fn_arrays , only : g1 , g2 , kperp2 , dkperp2dr use stella_geometry , only : bmag , dBdrho use stella_geometry , only : dl_over_b , d_dl_over_b_drho use gyro_averages , only : aj0x , aj1x , gyro_average use fields_arrays , only : phi , phi_corr_QN , phi_proj use run_parameters , only : fphi use run_parameters , only : maxwellian_normalization use physics_flags , only : radial_variation use stella_transforms , only : transform_kx2x_unpadded implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :, :), intent ( out ) :: dens , upar , temp , spitzer2 real , dimension (:, :), intent ( out ) :: dens_x , upar_x , temp_x complex , dimension (:, :), allocatable :: g0k , g1k , g1x real :: zero integer :: ivmu , iv , imu , is , ia integer :: iz , it if ( radial_variation ) then allocate ( g0k ( naky , nakx )) end if if ( write_radial_moments ) then allocate ( g1k ( 1 , nakx )) allocate ( g1x ( 1 , nakx )) end if ! Hack below. Works since J0&#94;2 - 1 and its derivative are zero at the origin zero = 10 0. * epsilon ( 0. ) ! h is gyrophase independent, but is in gyrocenter coordinates, ! so requires a J_0 to get to particle coordinates ! <f>_r = h J_0 - Ze*phi/T * F0 ! g     = h     - Ze*<phi>_R/T * F0 ! <f>_r = g J_0 + Ze*(J_0<phi>_R-phi)/T * F0 ! calculate the integrand appearing in the integral for the density ia = 1 do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) ! obtain the gyro-average of g that appears in the density integral call gyro_average ( g (:, :, :, :, ivmu ), ivmu , g1 (:, :, :, :, ivmu )) ! FLAG -- AJ0X NEEDS DEALING WITH BELOW g2 (:, :, :, :, ivmu ) = spread ( aj0x (:, :, :, ivmu ) ** 2 - 1.0 , 4 , ntubes ) * spec ( is )% zt * fphi * phi if (. not . maxwellian_normalization ) then g2 (:, :, :, :, ivmu ) = g2 (:, :, :, :, ivmu ) * maxwell_vpa ( iv , is ) * & spread ( spread ( spread ( maxwell_mu ( ia , :, imu , is ), 1 , naky ), 2 , nakx ) * maxwell_fac ( is ), 4 , ntubes ) end if g2 (:, :, :, :, ivmu ) = g2 (:, :, :, :, ivmu ) + g1 (:, :, :, :, ivmu ) ! g2(:, :, :, :, ivmu) = g1(:, :, :, :, ivmu) + ztmax(iv, is) & !                        * spread(spread(spread(maxwell_mu(ia, :, imu, is), 1, naky), 2, nakx) & !                                 * maxwell_fac(is) * (aj0x(:, :, :, ivmu)**2 - 1.0), 4, ntubes) * fphi * phi if ( radial_variation ) then do it = 1 , ntubes do iz = - nzgrid , nzgrid !phi g0k = ztmax ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) & * maxwell_fac ( is ) * ( aj0x (:, :, iz , ivmu ) ** 2 - 1.0 ) * fphi * phi (:, :, iz , it ) & * ( - spec ( is )% tprim * ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu ) - 2.5 ) & - spec ( is )% fprim + ( dBdrho ( iz ) / bmag ( ia , iz )) * ( 1.0 - 2.0 * mu ( imu ) * bmag ( ia , iz )) & - aj1x (:, :, iz , ivmu ) * aj0x (:, :, iz , ivmu ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 (:, :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) & / ( aj0x (:, :, iz , ivmu ) ** 2 - 1.0 + zero )) !g g0k = g0k + g1 (:, :, iz , it , ivmu ) & * ( - 0.5 * aj1x (:, :, iz , ivmu ) / aj0x (:, :, iz , ivmu ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 (:, :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) & + dBdrho ( iz ) / bmag ( ia , iz )) call multiply_by_rho ( g0k ) ! g0k(1,1) = 0.0 !phi QN g0k = g0k + ztmax ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) * fphi & * maxwell_fac ( is ) * ( aj0x (:, :, iz , ivmu ) ** 2 - 1.0 ) * phi_corr_QN (:, :, iz , it ) g2 (:, :, iz , it , ivmu ) = g2 (:, :, iz , it , ivmu ) + g0k end do end do end if end do call integrate_vmu ( g2 , spec % dens_psi0 , dens ) if ( write_radial_moments ) then dens_x = 0.0 do is = 1 , nspec do it = 1 , ntubes do iz = - nzgrid , nzgrid g1k ( 1 , :) = dens ( 1 , :, iz , it , is ) - phi_proj (:, 1 , it ) call transform_kx2x_unpadded ( g1k , g1x ) dens_x (:, is ) = dens_x (:, is ) & + real ( g1x ( 1 , :) * ( dl_over_b ( ia , iz ) + rho_d_clamped * d_dl_over_b_drho ( ia , iz ))) end do end do end do dens_x = dens_x / ntubes end if do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) if ( maxwellian_normalization ) then g2 (:, :, :, :, ivmu ) = ( g1 (:, :, :, :, ivmu ) + spec ( is )% zt & * spread ( aj0x (:, :, :, ivmu ) ** 2 - 1.0 , 4 , ntubes ) * phi * fphi ) & * ( vpa ( iv ) ** 2 + spread ( spread ( spread ( vperp2 ( 1 , :, imu ), 1 , naky ), 2 , nakx ), 4 , ntubes ) - 1.5 ) / 1.5 else g2 (:, :, :, :, ivmu ) = ( g1 (:, :, :, :, ivmu ) + ztmax ( iv , is ) & * spread ( spread ( spread ( maxwell_mu ( ia , :, imu , is ), 1 , naky ), 2 , nakx ) & * maxwell_fac ( is ) * ( aj0x (:, :, :, ivmu ) ** 2 - 1.0 ), 4 , ntubes ) * phi * fphi ) & * ( vpa ( iv ) ** 2 + spread ( spread ( spread ( vperp2 ( 1 , :, imu ), 1 , naky ), 2 , nakx ), 4 , ntubes ) - 1.5 ) / 1.5 end if if ( radial_variation ) then do it = 1 , ntubes do iz = - nzgrid , nzgrid !phi g0k = ztmax ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) * maxwell_fac ( is ) & * ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu ) - 1.5 ) / 1.5 & * ( aj0x (:, :, iz , ivmu ) ** 2 - 1.0 ) * phi (:, :, iz , it ) * fphi & * ( - spec ( is )% tprim * ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu ) - 2.5 ) & - spec ( is )% fprim + ( dBdrho ( iz ) / bmag ( ia , iz )) * ( 1.0 - 2.0 * mu ( imu ) * bmag ( ia , iz )) & - aj1x (:, :, iz , ivmu ) * aj0x (:, :, iz , ivmu ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 (:, :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) & / ( aj0x (:, :, iz , ivmu ) ** 2 - 1.0 + zero ) & + 2.0 * mu ( imu ) * dBdrho ( iz ) / ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu ) - 1.5 )) !g g0k = g0k + g1 (:, :, iz , it , ivmu ) * ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu ) - 1.5 ) / 1.5 & * ( - 0.5 * aj1x (:, :, iz , ivmu ) / aj0x (:, :, iz , ivmu ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 (:, :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) & + dBdrho ( iz ) / bmag ( ia , iz ) & + 2.0 * mu ( imu ) * dBdrho ( iz ) / ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu ) - 1.5 )) call multiply_by_rho ( g0k ) !phi QN g0k = g0k + fphi * ztmax ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) & * ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu ) - 1.5 ) / 1.5 & * maxwell_fac ( is ) * ( aj0x (:, :, iz , ivmu ) ** 2 - 1.0 ) * phi_corr_QN (:, :, iz , it ) g2 (:, :, iz , it , ivmu ) = g2 (:, :, iz , it , ivmu ) + g0k end do end do end if end do ! integrate to get dTs/Tr !    call integrate_vmu (g2, spec%temp, temp) call integrate_vmu ( g2 , spec % temp_psi0 * spec % dens_psi0 , temp ) if ( write_radial_moments ) then temp_x = 0.0 do is = 1 , nspec do it = 1 , ntubes do iz = - nzgrid , nzgrid g1k ( 1 , :) = temp ( 1 , :, iz , it , is ) call transform_kx2x_unpadded ( g1k , g1x ) temp_x (:, is ) = temp_x (:, is ) & + real ( g1x ( 1 , :) * ( dl_over_b ( ia , iz ) + rho_d_clamped * d_dl_over_b_drho ( ia , iz ))) end do end do end do temp_x = temp_x / ntubes end if ! for Spitzer problem tests of the collision operator do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) g2 (:,:,:,:, ivmu ) = g (:,:,:,:, ivmu ) * ( vpa ( iv ) * ( vpa ( iv ) ** 2 + spread ( spread ( spread ( vperp2 ( 1 ,:, imu ), 1 , naky ), 2 , nakx ), 4 , ntubes )) - 5. / 2. * vpa ( iv ) ) end do call integrate_vmu ( g2 , spec % stm , spitzer2 ) ! AVB: stm is the thermal speed do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) g2 (:, :, :, :, ivmu ) = vpa ( iv ) * g1 (:, :, :, :, ivmu ) if ( radial_variation ) then do it = 1 , ntubes do iz = - nzgrid , nzgrid !g g0k = vpa ( iv ) * g1 (:, :, iz , it , ivmu ) & * ( - 0.5 * aj1x (:, :, iz , ivmu ) / aj0x (:, :, iz , ivmu ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 (:, :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz )) & + dBdrho ( iz ) / bmag ( ia , iz )) call multiply_by_rho ( g0k ) g2 (:, :, iz , it , ivmu ) = g2 (:, :, iz , it , ivmu ) + g0k end do end do end if end do call integrate_vmu ( g2 , spec % stm_psi0 , upar ) if ( write_radial_moments ) then upar_x = 0.0 do is = 1 , nspec do it = 1 , ntubes do iz = - nzgrid , nzgrid g1k ( 1 , :) = upar ( 1 , :, iz , it , is ) call transform_kx2x_unpadded ( g1k , g1x ) upar_x (:, is ) = upar_x (:, is ) & + real ( g1x ( 1 , :) * ( dl_over_b ( ia , iz ) + rho_d_clamped * d_dl_over_b_drho ( ia , iz ))) end do end do end do upar_x = upar_x / ntubes end if if ( allocated ( g0k )) deallocate ( g0k ) if ( allocated ( g1k )) deallocate ( g1k ) if ( allocated ( g1x )) deallocate ( g1x ) end subroutine get_moments subroutine get_moments_ffs ( g , dens , upar , pres ) use stella_layouts , only : vmu_lo , iv_idx , imu_idx use species , only : spec , nspec use zgrid , only : nzgrid use vpamu_grids , only : integrate_vmu_ffs use vpamu_grids , only : vpa , vperp2 use kt_grids , only : naky_all , ikx_max , ny use kt_grids , only : swap_kxky use dist_fn_arrays , only : g0 , g1 use gyro_averages , only : gyro_average , j0_ffs use fields_arrays , only : phi use stella_transforms , only : transform_ky2y implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( out ) :: dens , upar , pres real , dimension (:), allocatable :: dens_wgts , upar_wgts , pres_wgts !> f_swap will contain delta f(ky,kx) on a grid with all kys and kx >= 0 complex , dimension (:, :), allocatable :: f_swap !> fy will contain delta f(y,kx) on a grid with kx >= 0 complex , dimension (:, :, :), allocatable :: fy !> integrand will contain the integrand in the velocity moment integrals complex , dimension (:), allocatable :: integrand integer :: iy , ikx , iz , it integer :: ivmu , iv , imu !> species-dependent factor by which velocity moments must be multiplied !> to get density, pressure, etc. allocate ( dens_wgts ( nspec )) allocate ( upar_wgts ( nspec )) allocate ( pres_wgts ( nspec )) !> the guiding centre distribution function, normalized by !> the equilibrium Maxwellian, is passed in as g. !> to obtain moments such as density, flow and pressure, !> we need to take moments of the distribution function, f, !> which is related to g via !> f/F0 = g + (Ze/T)*(<phi>_R - phi) !> obtain g0=f/F0 in Fourier space call g_to_f ( g , phi , g0 ) !> calculate the Fourier components of the gyro-average f at fixed particle position !> g0=f/F0 is passed in, along with j0_ffs = the Fourier coefficients of J0 !> g1=<f/F0>_r is returned call gyro_average ( g0 , g1 , j0_ffs ) allocate ( f_swap ( naky_all , ikx_max )) allocate ( fy ( ny , ikx_max , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) allocate ( integrand ( vmu_lo % llim_proc : vmu_lo % ulim_alloc )) !> assume only a single flux annulus it = 1 do iz = - nzgrid , nzgrid do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc !> for every (z,vpa,mu,spec) point !> switch from ky >= 0 and kx = [-kxmax, kxmax] !> to ky = [-kymax, kymax] and kx >= 0 call swap_kxky ( g1 (:, :, iz , it , ivmu ), f_swap ) !> for every (z,vpa,mu,spec) point, Fourier tranform from ky to y space to get !> the kx component of <f(y,x)>_r call transform_ky2y ( f_swap , fy (:, :, ivmu )) end do !> set species-dependent factors needed for density, parallel flow and pressure dens_wgts = spec % dens upar_wgts = spec % stm pres_wgts = spec % dens * spec % temp do ikx = 1 , ikx_max do iy = 1 , ny !> the integrand for the density moment is the distribution function integrand = fy ( iy , ikx , :) !> integrate over v-space to get the density, normalised by the reference density. call integrate_vmu_ffs ( integrand , dens_wgts , iy , iz , dens ( iy , ikx , iz , :)) !> the integrand for the pressure moment is the energy-weighted distribution function do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) integrand ( ivmu ) = fy ( iy , ikx , ivmu ) * ( vpa ( iv ) ** 2 + vperp2 ( iy , iz , imu )) end do !> integrate over v-space to get the pressure, normalised by the reference pressure. call integrate_vmu_ffs ( integrand , pres_wgts , iy , iz , pres ( iy , ikx , iz , :)) !> the integrand for the parallel flow moment is the parallel velocity do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) integrand ( ivmu ) = fy ( iy , ikx , ivmu ) * vpa ( iv ) end do !> integrate over v-space to get the parallel flow, normalised by the reference thermal speed. call integrate_vmu_ffs ( integrand , upar_wgts , iy , iz , upar ( iy , ikx , iz , :)) end do end do end do deallocate ( dens_wgts , upar_wgts , pres_wgts ) deallocate ( f_swap , fy ) deallocate ( integrand ) end subroutine get_moments_ffs !> the Fourier components of the guiding centre distribution function !> normalized by the equilibrium Maxwellian is passed in as g, !> along with the Fourier components of the electrostatic potential, phi. !> g_to_f calculates the Maxwellian-normalized distribution function f, !> which is related to g via !> f = g + (Ze/T)*(<phi>_R - phi) subroutine g_to_f ( g , phi , f ) use stella_layouts , only : vmu_lo , is_idx use species , only : spec use zgrid , only : nzgrid use gyro_averages , only : gyro_average , j0_ffs implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: phi complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( out ) :: f integer :: ivmu , is do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc !> compute <phi>_R and store in f !> j0_ffs are the fourier coefficients of J0(k_perp(y)) call gyro_average ( phi , f (:, :, :, :, ivmu ), j0_ffs (:, :, :, ivmu )) !> calculate the normalized f, given phi and <phi>_R (temporarily stored in f) is = is_idx ( vmu_lo , ivmu ) f (:, :, :, :, ivmu ) = g (:, :, :, :, ivmu ) + spec ( is )% zt * ( f (:, :, :, :, ivmu ) - phi ) end do end subroutine g_to_f !============================================== !================ GET GVMUS =================== !============================================== ! get_gvmus takes g(kx,ky,z) and returns average over z of int dxdy g(x,y,z)&#94;2 ! SHOULD MODIFY TO TAKE ADVANTAGE OF FACT THAT G(KY,KX,Z) LOCAL IS AVAILABLE subroutine get_gvmus ( g , gv ) use mp , only : nproc , sum_reduce use stella_layouts , only : kxkyz_lo use stella_layouts , only : is_idx , iky_idx , iz_idx use zgrid , only : ntubes use vpamu_grids , only : nvpa , nmu use stella_geometry , only : dl_over_b use volume_averages , only : mode_fac implicit none complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( in ) :: g real , dimension (:, :, :), intent ( out ) :: gv integer :: ikxkyz , iv , is , imu , iz , iky , ia !, ivp ia = 1 ! when doing volume averages, note the following: ! int dxdy g(x,y)&#94;2 = sum_ky |g(ky=0,kx)|&#94;2 + 2 * sum_{kx,ky} |g(ky>0,kx)|&#94;2 ! factor of 2 accounted for in fac gv = 0. do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc is = is_idx ( kxkyz_lo , ikxkyz ) iky = iky_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) do imu = 1 , nmu do iv = 1 , nvpa gv ( iv , imu , is ) = gv ( iv , imu , is ) + real ( g ( iv , imu , ikxkyz ) * conjg ( g ( iv , imu , ikxkyz ))) * mode_fac ( iky ) * dl_over_b ( ia , iz ) end do end do end do gv = gv / real ( ntubes ) if ( nproc > 1 ) call sum_reduce ( gv , 0 ) end subroutine get_gvmus !============================================== !================= GET GVZS =================== !============================================== ! get_gzvs takes g(kx,ky,z,vpa,mu,s) and returns int dmudxdy g(x,y,z,vpa,mu,s)&#94;2 subroutine get_gzvs ( g , gz ) use stella_layouts , only : vmu_lo use zgrid , only : nzgrid , ntubes use vpamu_grids , only : integrate_mu use kt_grids , only : nakx , naky use volume_averages , only : mode_fac implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g real , dimension (:, :, :, :), intent ( out ) :: gz integer :: ivmu , iz , it , ikx , iky , izp real , dimension (:, :, :), allocatable :: gtmp allocate ( gtmp ( - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) ! when doing volume averages, note the following: ! int dxdy g(x,y)&#94;2 = sum_kx |g(kx,ky=0)|&#94;2 + 2 * sum_{kx,ky} |g(kx,ky>0)|&#94;2 ! factor of 2 accounted for in mode_fac gtmp = 0. do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do ikx = 1 , nakx do iky = 1 , naky gtmp (:, :, ivmu ) = gtmp (:, :, ivmu ) + real ( g ( iky , ikx , :, :, ivmu ) * conjg ( g ( iky , ikx , :, :, ivmu ))) * mode_fac ( iky ) end do end do end do do it = 1 , ntubes do iz = - nzgrid , nzgrid izp = iz + nzgrid + 1 call integrate_mu ( iz , gtmp ( iz , it , :), gz ( it , izp , :, :)) end do end do deallocate ( gtmp ) end subroutine get_gzvs !============================================== !======== FINISH STELLA DIAGNOSTIC ============ !============================================== subroutine finish_stella_diagnostics ( istep ) use mp , only : proc0 use redistribute , only : scatter use stella_io , only : finish_stella_io use stella_time , only : code_dt , code_time use stella_save , only : stella_save_for_restart use dist_redistribute , only : kxkyz2vmu use dist_fn_arrays , only : gnew , gvmu implicit none integer :: istatus integer , intent ( in ) :: istep if ( proc0 ) then call write_final_ascii_files call close_loop_ascii_files end if if ( save_for_restart ) then call scatter ( kxkyz2vmu , gnew , gvmu ) call stella_save_for_restart ( gvmu , istep , code_time , code_dt , istatus , . true .) end if call finish_stella_io call deallocate_arrays nout = 1 diagnostics_initialized = . false . end subroutine finish_stella_diagnostics !============================================== !========= WRITE LOOP ASCII FILES ============= !============================================== subroutine write_loop_ascii_files ( istep , phi2 , apar2 , bpar2 , pflx , vflx , qflx , om , om_avg ) use stella_time , only : code_time use species , only : nspec use kt_grids , only : naky , nakx use kt_grids , only : aky , akx implicit none integer , intent ( in ) :: istep real , intent ( in ) :: phi2 , apar2 , bpar2 real , dimension (:), intent ( in ) :: pflx , vflx , qflx complex , dimension (:, :), intent ( in ) :: om , om_avg character ( 3 ) :: nspec_str character ( 100 ) :: str integer :: ikx , iky write ( stdout_unit , '(a7,i7,a6,e12.4,a10,e12.4,a11,e12.4,a12,e12.4)' ) 'istep=' , istep , & 'time=' , code_time , '|phi|&#94;2=' , phi2 , '|apar|&#94;2= ' , apar2 , '|bpar|&#94;2= ' , bpar2 call flush ( stdout_unit ) write ( nspec_str , '(i3)' ) 3 * nspec + 1 str = trim ( '(' // trim ( nspec_str ) // 'es15.4e3)' ) write ( fluxes_unit , str ) code_time , pflx , vflx , qflx call flush ( stdout_unit ) call flush ( fluxes_unit ) if ( write_omega . and . istep > 0 ) then do iky = 1 , naky do ikx = 1 , nakx write ( omega_unit , '(7e16.8)' ) code_time , aky ( iky ), akx ( ikx ), & real ( om ( iky , ikx )), aimag ( om ( iky , ikx )), & real ( om_avg ( iky , ikx )), aimag ( om_avg ( iky , ikx )) end do if ( nakx > 1 ) write ( omega_unit , * ) end do if ( naky > 1 ) write ( omega_unit , * ) call flush ( omega_unit ) end if end subroutine write_loop_ascii_files !============================================== !========= WRITE FINAL ASCII FILES ============ !============================================== subroutine write_final_ascii_files use file_utils , only : open_output_file , close_output_file use fields_arrays , only : phi , apar , bpar use zgrid , only : nzgrid , ntubes use zgrid , only : zed use kt_grids , only : naky , nakx use kt_grids , only : aky , akx , zed0 use stella_geometry , only : zed_eqarc USE dist_fn_arrays , ONLY : kperp2 implicit none integer :: tmpunit integer :: iky , ikx , iz , it call open_output_file ( tmpunit , '.final_fields' ) write ( tmpunit , '(10a14)' ) '# z' , 'z-zed0' , 'aky' , 'akx' , & 'real(phi)' , 'imag(phi)' , 'real(apar)' , 'imag(apar)' , & 'real(bpar)' , 'imag(bpar)' , 'z_eqarc-zed0' , 'kperp2' do iky = 1 , naky do ikx = 1 , nakx do it = 1 , ntubes do iz = - nzgrid , nzgrid write ( tmpunit , '(12es15.4e3,i3)' ) zed ( iz ), zed ( iz ) - zed0 ( iky , ikx ), aky ( iky ), akx ( ikx ), & real ( phi ( iky , ikx , iz , it )), aimag ( phi ( iky , ikx , iz , it )), & real ( apar ( iky , ikx , iz , it )), aimag ( apar ( iky , ikx , iz , it )), & real ( bpar ( iky , ikx , iz , it )), aimag ( bpar ( iky , ikx , iz , it )), & zed_eqarc ( iz ) - zed0 ( iky , ikx ), kperp2 ( iky , ikx , it , iz ), it end do write ( tmpunit , * ) end do end do end do call close_output_file ( tmpunit ) end subroutine write_final_ascii_files !============================================== !============ DEALLCOATE ARRAYS =============== !============================================== subroutine deallocate_arrays implicit none if ( allocated ( pflux )) deallocate ( pflux ) if ( allocated ( qflux )) deallocate ( qflux ) if ( allocated ( vflux )) deallocate ( vflux ) if ( allocated ( exchange )) deallocate ( exchange ) if ( allocated ( pflux_avg )) deallocate ( pflux_avg ) if ( allocated ( qflux_avg )) deallocate ( qflux_avg ) if ( allocated ( vflux_avg )) deallocate ( vflux_avg ) if ( allocated ( heat_avg )) deallocate ( heat_avg ) if ( allocated ( omega_vs_time )) deallocate ( omega_vs_time ) end subroutine deallocate_arrays end module stella_diagnostics","tags":"","loc":"sourcefile/stella_diagnostics.f90.html"},{"title":"stella_transforms.f90 – stella","text":"Source Code module stella_transforms use fft_work , only : fft_type implicit none public :: init_transforms , finish_transforms public :: transform_ky2y , transform_y2ky public :: transform_kx2x , transform_x2kx public :: transform_ky2y_unpadded , transform_y2ky_unpadded public :: transform_kx2x_unpadded , transform_x2kx_unpadded public :: transform_kx2x_xfirst , transform_x2kx_xfirst public :: transform_ky2y_xfirst , transform_y2ky_xfirst public :: transform_kalpha2alpha , transform_alpha2kalpha interface transform_ky2y module procedure transform_ky2y_5d module procedure transform_ky2y_2d end interface interface transform_y2ky module procedure transform_y2ky_5d module procedure transform_y2ky_2d end interface private type ( fft_type ) :: yf_fft , yb_fft type ( fft_type ) :: xf_fft , xb_fft type ( fft_type ) :: yfnp_fft , ybnp_fft type ( fft_type ) :: xfnp_fft , xbnp_fft type ( fft_type ) :: xsf_fft , xsb_fft type ( fft_type ) :: ysf_fft , ysb_fft type ( fft_type ) :: alpha_f_fft , alpha_b_fft logical :: transforms_initialized = . false . complex , dimension (:), allocatable :: fft_y_in , fft_y_out , fft_x_k real , dimension (:), allocatable :: fft_x_x complex , dimension (:), allocatable :: fft_xs_k , fft_xs_x , fft_ys_k real , dimension (:), allocatable :: fft_ys_y complex , dimension (:), allocatable :: fftnp_x_k , fftnp_x_x complex , dimension (:), allocatable :: fftnp_y_k real , dimension (:), allocatable :: fftnp_y_y !> arrays for transforming from alpha-space to k-alpha space real , dimension (:), allocatable :: fft_alpha_alpha complex , dimension (:), allocatable :: fft_alpha_kalpha contains subroutine init_transforms use physics_flags , only : full_flux_surface use stella_layouts , only : init_stella_layouts implicit none if ( transforms_initialized ) return transforms_initialized = . true . call init_stella_layouts call init_y_fft call init_x_fft call init_x_xfirst_fft call init_y_xfirst_fft call init_unpadded_x_fft call init_unpadded_y_fft if ( full_flux_surface ) call init_alpha_fft end subroutine init_transforms subroutine init_y_fft use stella_layouts , only : vmu_lo use fft_work , only : init_ccfftw implicit none logical :: initialized = . false . if ( initialized ) return initialized = . true . if (. not . allocated ( fft_y_in )) allocate ( fft_y_in ( vmu_lo % ny )) if (. not . allocated ( fft_y_out )) allocate ( fft_y_out ( vmu_lo % ny )) call init_ccfftw ( yf_fft , 1 , vmu_lo % ny , fft_y_in , fft_y_out ) call init_ccfftw ( yb_fft , - 1 , vmu_lo % ny , fft_y_in , fft_y_out ) end subroutine init_y_fft subroutine init_x_fft use stella_layouts , only : vmu_lo use fft_work , only : init_crfftw , init_rcfftw implicit none logical :: initialized = . false . if ( initialized ) return initialized = . true . if (. not . allocated ( fft_x_k )) allocate ( fft_x_k ( vmu_lo % nx / 2 + 1 )) if (. not . allocated ( fft_x_x )) allocate ( fft_x_x ( vmu_lo % nx )) call init_crfftw ( xf_fft , 1 , vmu_lo % nx , fft_x_k , fft_x_x ) call init_rcfftw ( xb_fft , - 1 , vmu_lo % nx , fft_x_x , fft_x_k ) end subroutine init_x_fft subroutine init_x_xfirst_fft use stella_layouts , only : vmu_lo use fft_work , only : init_ccfftw implicit none logical :: initialized = . false . if ( initialized ) return initialized = . true . if (. not . allocated ( fft_xs_k )) allocate ( fft_xs_k ( vmu_lo % nx )) if (. not . allocated ( fft_xs_x )) allocate ( fft_xs_x ( vmu_lo % nx )) call init_ccfftw ( xsf_fft , 1 , vmu_lo % nx , fft_xs_k , fft_xs_x ) call init_ccfftw ( xsb_fft , - 1 , vmu_lo % nx , fft_xs_x , fft_xs_k ) end subroutine init_x_xfirst_fft subroutine init_y_xfirst_fft use stella_layouts , only : vmu_lo use fft_work , only : init_crfftw , init_rcfftw implicit none logical :: initialized = . false . if ( initialized ) return initialized = . true . if (. not . allocated ( fft_ys_k )) allocate ( fft_ys_k ( vmu_lo % ny / 2 + 1 )) if (. not . allocated ( fft_ys_y )) allocate ( fft_ys_y ( vmu_lo % ny )) call init_crfftw ( ysf_fft , 1 , vmu_lo % ny , fft_ys_k , fft_ys_y ) call init_rcfftw ( ysb_fft , - 1 , vmu_lo % ny , fft_ys_y , fft_ys_k ) end subroutine init_y_xfirst_fft subroutine init_unpadded_x_fft use stella_layouts , only : vmu_lo use fft_work , only : init_ccfftw , FFT_BACKWARD , FFT_FORWARD implicit none if (. not . allocated ( fftnp_x_k )) allocate ( fftnp_x_k ( vmu_lo % nakx )) if (. not . allocated ( fftnp_x_x )) allocate ( fftnp_x_x ( vmu_lo % nakx )) call init_ccfftw ( xfnp_fft , FFT_BACKWARD , vmu_lo % nakx , fftnp_x_k , fftnp_x_x ) call init_ccfftw ( xbnp_fft , FFT_FORWARD , vmu_lo % nakx , fftnp_x_x , fftnp_x_k ) end subroutine init_unpadded_x_fft subroutine init_unpadded_y_fft use stella_layouts , only : vmu_lo use fft_work , only : init_crfftw , init_rcfftw , FFT_BACKWARD , FFT_FORWARD implicit none if (. not . allocated ( fftnp_y_k )) allocate ( fftnp_y_k ( vmu_lo % naky )) if (. not . allocated ( fftnp_y_y )) allocate ( fftnp_y_y ( 2 * vmu_lo % naky - 1 )) call init_crfftw ( yfnp_fft , FFT_BACKWARD , 2 * vmu_lo % naky - 1 , fftnp_y_k , fftnp_y_y ) call init_rcfftw ( ybnp_fft , FFT_FORWARD , 2 * vmu_lo % naky - 1 , fftnp_y_y , fftnp_y_k ) end subroutine init_unpadded_y_fft subroutine init_alpha_fft use fft_work , only : init_rcfftw , init_crfftw use fft_work , only : fft_backward , fft_forward use stella_layouts , only : vmu_lo implicit none logical :: initialized = . false . if ( initialized ) return initialized = . true . if (. not . allocated ( fft_alpha_kalpha )) allocate ( fft_alpha_kalpha ( vmu_lo % nalpha / 2 + 1 )) if (. not . allocated ( fft_alpha_alpha )) allocate ( fft_alpha_alpha ( vmu_lo % nalpha )) call init_crfftw ( alpha_f_fft , fft_backward , vmu_lo % nalpha , fft_alpha_kalpha , fft_alpha_alpha ) call init_rcfftw ( alpha_b_fft , fft_forward , vmu_lo % nalpha , fft_alpha_alpha , fft_alpha_kalpha ) end subroutine init_alpha_fft subroutine transform_ky2y_5d ( gky_unpad , gy ) use stella_layouts , only : vmu_lo implicit none complex , dimension (:, :, - vmu_lo % nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: gky_unpad complex , dimension (:, :, - vmu_lo % nzgrid :, :, vmu_lo % llim_proc :), intent ( out ) :: gy integer :: iky_max , ipad_up integer :: ikx , iz , it , ivmu ! first need to pad input array with zeros iky_max = vmu_lo % naky ipad_up = iky_max + vmu_lo % ny - ( 2 * vmu_lo % naky - 1 ) ! now fill in non-zero elements of array do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , vmu_lo % ntubes do iz = - vmu_lo % nzgrid , vmu_lo % nzgrid do ikx = 1 , vmu_lo % nakx / 2 + 1 fft_y_in ( iky_max + 1 : ipad_up ) = 0. fft_y_in (: iky_max ) = gky_unpad (: iky_max , ikx , iz , it , ivmu ) fft_y_in ( ipad_up + 1 :) = gky_unpad ( iky_max + 1 :, ikx , iz , it , ivmu ) call dfftw_execute_dft ( yf_fft % plan , fft_y_in , fft_y_out ) fft_y_out = fft_y_out * yf_fft % scale gy (:, ikx , iz , it , ivmu ) = fft_y_out end do end do end do end do end subroutine transform_ky2y_5d subroutine transform_ky2y_2d ( gky_unpad , gy ) use stella_layouts , only : vmu_lo implicit none complex , dimension (:, :), intent ( in ) :: gky_unpad complex , dimension (:, :), intent ( out ) :: gy integer :: iky_max , ipad_up integer :: ikx ! first need to pad input array with zeros iky_max = vmu_lo % naky ipad_up = iky_max + vmu_lo % ny - ( 2 * vmu_lo % naky - 1 ) ! now fill in non-zero elements of array do ikx = 1 , vmu_lo % nakx / 2 + 1 fft_y_in ( iky_max + 1 : ipad_up ) = 0. fft_y_in (: iky_max ) = gky_unpad (: iky_max , ikx ) fft_y_in ( ipad_up + 1 :) = gky_unpad ( iky_max + 1 :, ikx ) call dfftw_execute_dft ( yf_fft % plan , fft_y_in , fft_y_out ) fft_y_out = fft_y_out * yf_fft % scale gy (:, ikx ) = fft_y_out end do end subroutine transform_ky2y_2d subroutine transform_y2ky_5d ( gy , gky ) use stella_layouts , only : vmu_lo implicit none complex , dimension (:, :, - vmu_lo % nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: gy complex , dimension (:, :, - vmu_lo % nzgrid :, :, vmu_lo % llim_proc :), intent ( out ) :: gky integer :: iky_max , ipad_up integer :: ikx , iz , it , ivmu iky_max = vmu_lo % naky ipad_up = iky_max + vmu_lo % ny - ( 2 * vmu_lo % naky - 1 ) ! now fill in non-zero elements of array do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , vmu_lo % ntubes do iz = - vmu_lo % nzgrid , vmu_lo % nzgrid do ikx = 1 , vmu_lo % nakx / 2 + 1 fft_y_in = gy (:, ikx , iz , it , ivmu ) call dfftw_execute_dft ( yb_fft % plan , fft_y_in , fft_y_out ) fft_y_out = fft_y_out * yb_fft % scale gky (: iky_max , ikx , iz , it , ivmu ) = fft_y_out (: iky_max ) gky ( iky_max + 1 :, ikx , iz , it , ivmu ) = fft_y_out ( ipad_up + 1 :) end do end do end do end do end subroutine transform_y2ky_5d subroutine transform_y2ky_2d ( gy , gky ) use stella_layouts , only : vmu_lo implicit none complex , dimension (:, :), intent ( in out ) :: gy complex , dimension (:, :), intent ( out ) :: gky integer :: iky_max , ipad_up integer :: ikx iky_max = vmu_lo % naky ipad_up = iky_max + vmu_lo % ny - ( 2 * vmu_lo % naky - 1 ) ! now fill in non-zero elements of array do ikx = 1 , vmu_lo % nakx / 2 + 1 fft_y_in = gy (:, ikx ) call dfftw_execute_dft ( yb_fft % plan , fft_y_in , fft_y_out ) fft_y_out = fft_y_out * yb_fft % scale gky (: iky_max , ikx ) = fft_y_out (: iky_max ) gky ( iky_max + 1 :, ikx ) = fft_y_out ( ipad_up + 1 :) end do end subroutine transform_y2ky_2d subroutine transform_kx2x ( gkx , gx ) use stella_layouts , only : vmu_lo implicit none complex , dimension (:, :), intent ( in ) :: gkx real , dimension (:, :), intent ( out ) :: gx integer :: iy ! now fill in non-zero elements of array do iy = 1 , vmu_lo % ny ! first need to pad input array with zeros fft_x_k ( vmu_lo % nakx / 2 + 2 :) = 0. fft_x_k (: vmu_lo % nakx / 2 + 1 ) = gkx ( iy , :) call dfftw_execute_dft_c2r ( xf_fft % plan , fft_x_k , fft_x_x ) fft_x_x = fft_x_x * xf_fft % scale gx ( iy , :) = fft_x_x end do end subroutine transform_kx2x subroutine transform_x2kx ( gx , gkx ) use stella_layouts , only : vmu_lo implicit none real , dimension (:, :), intent ( in ) :: gx complex , dimension (:, :), intent ( out ) :: gkx integer :: iy do iy = 1 , vmu_lo % ny fft_x_x = gx ( iy , :) call dfftw_execute_dft_r2c ( xb_fft % plan , fft_x_x , fft_x_k ) fft_x_k = fft_x_k * xb_fft % scale gkx ( iy , :) = fft_x_k (: vmu_lo % nakx / 2 + 1 ) end do end subroutine transform_x2kx subroutine transform_kx2x_xfirst ( gkx , gx ) use stella_layouts , only : vmu_lo implicit none complex , dimension (:, :), intent ( in ) :: gkx complex , dimension (:, :), intent ( out ) :: gx integer :: iky , ikx_max , ipad_up ikx_max = vmu_lo % nakx / 2 + 1 ipad_up = ikx_max + vmu_lo % nx - vmu_lo % nakx ! now fill in non-zero elements of array do iky = 1 , vmu_lo % naky ! first need to pad input array with zeros fft_xs_k ( ikx_max + 1 : ipad_up ) = 0. fft_xs_k (: ikx_max ) = gkx ( iky , : ikx_max ) fft_xs_k ( ipad_up + 1 :) = gkx ( iky , ikx_max + 1 :) call dfftw_execute_dft ( xsf_fft % plan , fft_xs_k , fft_xs_x ) fft_xs_x = fft_xs_x * xsf_fft % scale gx ( iky , :) = fft_xs_x end do end subroutine transform_kx2x_xfirst subroutine transform_x2kx_xfirst ( gx , gkx ) use stella_layouts , only : vmu_lo implicit none complex , dimension (:, :), intent ( in ) :: gx complex , dimension (:, :), intent ( out ) :: gkx integer :: iky , ikx_max , ipad_up ikx_max = vmu_lo % nakx / 2 + 1 ipad_up = ikx_max + vmu_lo % nx - vmu_lo % nakx do iky = 1 , vmu_lo % naky fft_xs_x = gx ( iky , :) call dfftw_execute_dft ( xsb_fft % plan , fft_xs_x , fft_xs_k ) fft_xs_k = fft_xs_k * xsb_fft % scale gkx ( iky , : ikx_max ) = fft_xs_k (: ikx_max ) gkx ( iky , ikx_max + 1 :) = fft_xs_k ( ipad_up + 1 :) end do end subroutine transform_x2kx_xfirst subroutine transform_ky2y_xfirst ( gky , gy ) use stella_layouts , only : vmu_lo implicit none complex , dimension (:, :), intent ( in ) :: gky real , dimension (:, :), intent ( out ) :: gy integer :: ix ! now fill in non-zero elements of array do ix = 1 , vmu_lo % nx ! first need to pad input array with zeros fft_ys_k ( vmu_lo % naky + 1 :) = 0. fft_ys_k (: vmu_lo % naky ) = gky (:, ix ) call dfftw_execute_dft_c2r ( ysf_fft % plan , fft_ys_k , fft_ys_y ) fft_ys_y = fft_ys_y * ysf_fft % scale gy (:, ix ) = fft_ys_y end do end subroutine transform_ky2y_xfirst subroutine transform_y2ky_xfirst ( gy , gky ) use stella_layouts , only : vmu_lo implicit none real , dimension (:, :), intent ( in ) :: gy complex , dimension (:, :), intent ( out ) :: gky integer :: ix do ix = 1 , vmu_lo % nx fft_ys_y = gy (:, ix ) call dfftw_execute_dft_r2c ( ysb_fft % plan , fft_ys_y , fft_ys_k ) fft_ys_k = fft_ys_k * ysb_fft % scale gky (:, ix ) = fft_ys_k (: vmu_lo % naky ) end do end subroutine transform_y2ky_xfirst subroutine transform_kx2x_unpadded ( gkx , gx ) implicit none complex , dimension (:, :), intent ( in ) :: gkx complex , dimension (:, :), intent ( out ) :: gx integer :: iy do iy = 1 , size ( gkx , 1 ) fftnp_x_k = gkx ( iy , :) call dfftw_execute_dft ( xfnp_fft % plan , fftnp_x_k , fftnp_x_x ) gx ( iy , :) = fftnp_x_x * xfnp_fft % scale end do end subroutine transform_kx2x_unpadded subroutine transform_x2kx_unpadded ( gx , gkx ) implicit none complex , dimension (:, :), intent ( in ) :: gx complex , dimension (:, :), intent ( out ) :: gkx integer :: iy do iy = 1 , size ( gx , 1 ) fftnp_x_x = gx ( iy , :) call dfftw_execute_dft ( xbnp_fft % plan , fftnp_x_x , fftnp_x_k ) gkx ( iy , :) = fftnp_x_k * xbnp_fft % scale end do end subroutine transform_x2kx_unpadded subroutine transform_ky2y_unpadded ( gky , gy ) implicit none complex , dimension (:, :), intent ( in ) :: gky real , dimension (:, :), intent ( out ) :: gy integer :: ikx do ikx = 1 , size ( gky , 1 ) fftnp_y_k = gky (:, ikx ) call dfftw_execute_dft_c2r ( yfnp_fft % plan , fftnp_y_k , fftnp_y_y ) gy (:, ikx ) = fftnp_y_y * yfnp_fft % scale end do end subroutine transform_ky2y_unpadded subroutine transform_y2ky_unpadded ( gy , gky ) implicit none real , dimension (:, :), intent ( in out ) :: gy complex , dimension (:, :), intent ( out ) :: gky integer :: ikx do ikx = 1 , size ( gy , 2 ) fftnp_y_k = gy (:, ikx ) call dfftw_execute_dft_r2c ( ybnp_fft % plan , fftnp_y_y , fftnp_y_k ) gky (:, ikx ) = fftnp_y_y * ybnp_fft % scale end do end subroutine transform_y2ky_unpadded subroutine transform_kalpha2alpha ( gkalph , galph ) use stella_layouts , only : vmu_lo implicit none complex , dimension (:), intent ( in ) :: gkalph real , dimension (:), intent ( out ) :: galph ! first need to pad input array with zeros fft_alpha_kalpha ( vmu_lo % naky + 1 :) = 0. ! then fill in non-zero elements of array fft_alpha_kalpha (: vmu_lo % naky ) = gkalph call dfftw_execute_dft_c2r ( alpha_f_fft % plan , fft_alpha_kalpha , fft_alpha_alpha ) fft_alpha_alpha = fft_alpha_alpha * alpha_f_fft % scale galph = fft_alpha_alpha end subroutine transform_kalpha2alpha !> input galph array is real and contains values on the padded alpha grid !> gkalph is output array; it contains the Fourier coefficients of galph !> for positive ky values only (reality can be used to obtain the negative ky coefs) !> the highest 1/3 of the ky modes from the FFT have been discarded to avoid de-aliasing subroutine transform_alpha2kalpha ( galph , gkalph ) use stella_layouts , only : vmu_lo implicit none real , dimension (:), intent ( in ) :: galph complex , dimension (:), intent ( out ) :: gkalph fft_alpha_alpha = galph call dfftw_execute_dft_r2c ( alpha_b_fft % plan , fft_alpha_alpha , fft_alpha_kalpha ) fft_alpha_kalpha = fft_alpha_kalpha * alpha_b_fft % scale ! filter out highest k-alpha modes to avoid aliasing gkalph = fft_alpha_kalpha (: vmu_lo % naky ) end subroutine transform_alpha2kalpha subroutine finish_transforms use physics_flags , only : full_flux_surface implicit none call dfftw_destroy_plan ( yf_fft % plan ) call dfftw_destroy_plan ( yb_fft % plan ) call dfftw_destroy_plan ( xf_fft % plan ) call dfftw_destroy_plan ( xb_fft % plan ) call dfftw_destroy_plan ( xsf_fft % plan ) call dfftw_destroy_plan ( xsb_fft % plan ) call dfftw_destroy_plan ( ysf_fft % plan ) call dfftw_destroy_plan ( ysb_fft % plan ) call dfftw_destroy_plan ( yfnp_fft % plan ) call dfftw_destroy_plan ( ybnp_fft % plan ) call dfftw_destroy_plan ( xfnp_fft % plan ) call dfftw_destroy_plan ( xbnp_fft % plan ) if ( full_flux_surface ) then call dfftw_destroy_plan ( alpha_f_fft % plan ) call dfftw_destroy_plan ( alpha_b_fft % plan ) end if if ( allocated ( fft_y_in )) deallocate ( fft_y_in ) if ( allocated ( fft_y_out )) deallocate ( fft_y_out ) if ( allocated ( fft_x_k )) deallocate ( fft_x_k ) if ( allocated ( fft_x_x )) deallocate ( fft_x_x ) if ( allocated ( fft_xs_k )) deallocate ( fft_xs_k ) if ( allocated ( fft_xs_x )) deallocate ( fft_xs_x ) if ( allocated ( fft_ys_k )) deallocate ( fft_ys_k ) if ( allocated ( fft_ys_y )) deallocate ( fft_ys_y ) if ( allocated ( fft_alpha_alpha )) deallocate ( fft_alpha_alpha ) if ( allocated ( fft_alpha_kalpha )) deallocate ( fft_alpha_kalpha ) if ( allocated ( fftnp_y_k )) deallocate ( fftnp_y_k ) if ( allocated ( fftnp_y_y )) deallocate ( fftnp_y_y ) if ( allocated ( fftnp_x_k )) deallocate ( fftnp_x_k ) if ( allocated ( fftnp_x_x )) deallocate ( fftnp_x_x ) transforms_initialized = . false . end subroutine finish_transforms end module stella_transforms","tags":"","loc":"sourcefile/stella_transforms.f90.html"},{"title":"hyper.f90 – stella","text":"Source Code module hyper implicit none public :: read_parameters_hyper public :: init_hyper public :: advance_hyper_dissipation private logical :: use_physical_ksqr , scale_to_outboard real :: D_hyper real :: tfac real :: k2max contains subroutine read_parameters_hyper use file_utils , only : input_unit_exist use physics_flags , only : full_flux_surface , radial_variation use mp , only : proc0 , broadcast implicit none namelist / hyper / D_hyper , use_physical_ksqr , scale_to_outboard integer :: in_file logical :: dexist if ( proc0 ) then use_physical_ksqr = . not . ( full_flux_surface . or . radial_variation ) ! use kperp2, instead of akx&#94;2 + aky&#94;2 scale_to_outboard = . false . ! scales hyperdissipation to zed = 0 D_hyper = 0.05 in_file = input_unit_exist ( \"hyper\" , dexist ) if ( dexist ) read ( unit = in_file , nml = hyper ) end if call broadcast ( use_physical_ksqr ) call broadcast ( scale_to_outboard ) call broadcast ( D_hyper ) end subroutine read_parameters_hyper subroutine init_hyper use kt_grids , only : ikx_max , nakx , naky use kt_grids , only : aky , akx , theta0 use zgrid , only : nzgrid , zed use stella_geometry , only : geo_surf , q_as_x use dist_fn_arrays , only : kperp2 implicit none integer :: iky , ikx , iz , ia real :: temp ia = 1 if (. not . use_physical_ksqr ) then !> avoid spatially dependent kperp (through the geometric coefficients) !> still allowed to vary along zed with global magnetic shear !> useful for full_flux_surface and radial_variation runs tfac = geo_surf % shat ** 2 !> q_as_x uses a different definition of theta0 if ( q_as_x ) tfac = 1.0 if ( scale_to_outboard ) then !get k2max at outboard midplane k2max = akx ( ikx_max ) ** 2 + aky ( naky ) ** 2 else k2max = - 1.0 do iz = - nzgrid , nzgrid do ikx = 1 , nakx do iky = 1 , naky temp = aky ( iky ) ** 2 * ( 1.0 + tfac * ( zed ( iz ) - theta0 ( iky , ikx )) ** 2 ) if ( temp > k2max ) k2max = temp end do end do end do end if else if ( scale_to_outboard ) then !> get k2max at outboard midplane k2max = maxval ( kperp2 (:, :, ia , 0 )) else k2max = maxval ( kperp2 ) end if end if if ( k2max < epsilon ( 0.0 )) k2max = 1.0 end subroutine init_hyper subroutine advance_hyper_dissipation ( g ) use stella_time , only : code_dt use zgrid , only : nzgrid , ntubes , zed use stella_layouts , only : vmu_lo use dist_fn_arrays , only : kperp2 use kt_grids , only : naky use kt_grids , only : aky , akx , theta0 , zonal_mode implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: g integer :: ia , ivmu , iz , it , iky ia = 1 if (. not . use_physical_ksqr ) then !> avoid spatially dependent kperp !> add in hyper-dissipation of form dg/dt = -D*(k/kmax)&#94;4*g do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid do iky = 1 , naky if ( zonal_mode ( iky )) then g ( iky , :, iz , it , ivmu ) = g ( iky , :, iz , it , ivmu ) / ( 1. + code_dt * ( akx (:) ** 2 / k2max ) ** 2 * D_hyper ) else g ( iky , :, iz , it , ivmu ) = g ( iky , :, iz , it , ivmu ) / ( 1. + code_dt * ( aky ( iky ) ** 2 & * ( 1.0 + tfac * ( zed ( iz ) - theta0 ( iky , :)) ** 2 ) / k2max ) ** 2 * D_hyper ) end if end do end do end do end do else !> add in hyper-dissipation of form dg/dt = -D*(k/kmax)&#94;4*g do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc g (:, :, :, :, ivmu ) = g (:, :, :, :, ivmu ) / ( 1. + code_dt * ( spread ( kperp2 (:, :, ia , :), 4 , ntubes ) / k2max ) ** 2 * D_hyper ) end do end if end subroutine advance_hyper_dissipation end module hyper","tags":"","loc":"sourcefile/hyper.f90.html"},{"title":"fzero.f90 – stella","text":"Source Code module fzero_mod contains SUBROUTINE FZERO ( F , B , C , R , RE , AE , IFLAG ) !***BEGIN PROLOGUE  FZERO !***PURPOSE  Search for a zero of a function F(X) in a given interval !            (B,C).  It is designed primarily for problems where F(B) !            and F(C) have opposite signs. !***LIBRARY   SLATEC !***CATEGORY  F1B !***TYPE      SINGLE PRECISION (FZERO-S, DFZERO-D) !***KEYWORDS  BISECTION, NONLINEAR EQUATIONS, ROOTS, ZEROS !***AUTHOR  Shampine, L. F., (SNLA) !           Watts, H. A., (SNLA) !***DESCRIPTION ! !     FZERO searches for a zero of a REAL function F(X) between the !     given REAL values B and C until the width of the interval (B,C) !     has collapsed to within a tolerance specified by the stopping !     criterion, !        ABS(B-C) .LE. 2.*(RW*ABS(B)+AE). !     The method used is an efficient combination of bisection and the !     secant rule and is due to T. J. Dekker. ! !     Description Of Arguments ! !   F     :EXT   - Name of the REAL external function.  This name must !                  be in an EXTERNAL statement in the calling program. !                  F must be a function of one REAL argument. ! !   B     :INOUT - One end of the REAL interval (B,C).  The value !                  returned for B usually is the better approximation !                  to a zero of F. ! !   C     :INOUT - The other end of the REAL interval (B,C) ! !   R     :IN    - A (better) REAL guess of a zero of F which could help !                  in speeding up convergence.  If F(B) and F(R) have !                  opposite signs, a root will be found in the interval !                  (B,R); if not, but F(R) and F(C) have opposite signs, !                  a root will be found in the interval (R,C); !                  otherwise, the interval (B,C) will be searched for a !                  possible root.  When no better guess is known, it is !                  recommended that r be set to B or C, since if R is !                  not interior to the interval (B,C), it will be !                  ignored. ! !   RE    :IN    - Relative error used for RW in the stopping criterion. !                  If the requested RE is less than machine precision, !                  then RW is set to approximately machine precision. ! !   AE    :IN    - Absolute error used in the stopping criterion.  If !                  the given interval (B,C) contains the origin, then a !                  nonzero value should be chosen for AE. ! !   IFLAG :OUT   - A status code.  User must check IFLAG after each !                  call.  Control returns to the user from FZERO in all !                  cases. ! !                1  B is within the requested tolerance of a zero. !                   The interval (B,C) collapsed to the requested !                   tolerance, the function changes sign in (B,C), and !                   F(X) decreased in magnitude as (B,C) collapsed. ! !                2  F(B) = 0.  However, the interval (B,C) may not have !                   collapsed to the requested tolerance. ! !                3  B may be near a singular point of F(X). !                   The interval (B,C) collapsed to the requested tol- !                   erance and the function changes sign in (B,C), but !                   F(X) increased in magnitude as (B,C) collapsed, i.e. !                     ABS(F(B out)) .GT. MAX(ABS(F(B in)),ABS(F(C in))) ! !                4  No change in sign of F(X) was found although the !                   interval (B,C) collapsed to the requested tolerance. !                   The user must examine this case and decide whether !                   B is near a local minimum of F(X), or B is near a !                   zero of even multiplicity, or neither of these. ! !                5  Too many (.GT. 500) function evaluations used. ! !***REFERENCES  L. F. Shampine and H. A. Watts, FZERO, a root-solving !                 code, Report SC-TM-70-631, Sandia Laboratories, !                 September 1970. !               T. J. Dekker, Finding a zero by means of successive !                 linear interpolation, Constructive Aspects of the !                 Fundamental Theorem of Algebra, edited by B. Dejon !                 and P. Henrici, Wiley-Interscience, 1969. !***ROUTINES CALLED  R1MACH !***REVISION HISTORY  (YYMMDD) !   700901  DATE WRITTEN !   890531  Changed all specific intrinsics to generic.  (WRB) !   890531  REVISION DATE from Version 3.2 !   891214  Prologue converted to Version 4.0 format.  (BAB) !   920501  Reformatted the REFERENCES section.  (WRB) !***END PROLOGUE  FZERO !      USE stel_kinds IMPLICIT NONE !      REAL(RPREC), PARAMETER :: ZERO = 0, ONE = 1 !      REAL(RPREC) :: A,ACBS,ACMB,AE,AW,B,C,CMB,ER,FA,FB,FC,FX,FZ,P,Q,R, !     +     RE,RW,T,TOL,Z,F REAL , PARAMETER :: ZERO = 0 , ONE = 1 REAL :: A , ACBS , ACMB , AE , AW , B , C , CMB , ER , FA , FB , FC , FX , FZ , P , Q , R , & RE , RW , T , TOL , Z , F INTEGER :: IC , IFLAG , KOUNT EXTERNAL F !***FIRST EXECUTABLE STATEMENT  FZERO ! !   ER is two times the computer unit roundoff value which is defined !   here by the function EPSILON. ! ER = 2 * EPSILON ( ER ) ! !   Initialize. ! Z = R IF ( R <= MIN ( B , C ) . OR . R >= MAX ( B , C )) Z = C RW = MAX ( RE , ER ) AW = MAX ( AE , ZERO ) IC = 0 T = Z FZ = F ( T ) FC = FZ T = B FB = F ( T ) KOUNT = 2 IF ( SIGN ( ONE , FZ ) == SIGN ( ONE , FB )) GO TO 1 C = Z GO TO 2 1 IF ( Z == C ) GO TO 2 T = C FC = F ( T ) KOUNT = 3 IF ( SIGN ( ONE , FZ ) == SIGN ( ONE , FC )) GO TO 2 B = Z FB = FZ 2 A = C FA = FC ACBS = ABS ( B - C ) FX = MAX ( ABS ( FB ), ABS ( FC )) ! 3 IF ( ABS ( FC ) >= ABS ( FB )) GO TO 4 ! !   Perform interchange. ! A = B FA = FB B = C FB = FC C = A FC = FA ! !    4 CMB = 0.5_DP*(C-B) 4 CMB = 0.5d+0 * ( C - B ) ACMB = ABS ( CMB ) TOL = RW * ABS ( B ) + AW ! !   Test stopping criterion and function count. ! IF ( ACMB <= TOL ) GO TO 10 IF ( FB == ZERO ) GO TO 11 IF ( KOUNT >= 500 ) GO TO 14 ! !   Calculate new iterate implicitly as B+P/Q, where we arrange !   P .GE. 0.  The implicit form is used to prevent overflow. ! P = ( B - A ) * FB Q = FA - FB IF ( P >= ZERO ) GO TO 5 P = - P Q = - Q ! !   Update A and check for satisfactory reduction in the size of the !   bracketing interval.  If not, perform bisection. ! 5 A = B FA = FB IC = IC + 1 IF ( IC < 4 ) GO TO 6 IF ( 8 * ACMB >= ACBS ) GO TO 8 IC = 0 ACBS = ACMB ! !   Test for too small a change. ! 6 IF ( P > ABS ( Q ) * TOL ) GO TO 7 ! !   Increment by TOLerance. ! B = B + SIGN ( TOL , CMB ) GO TO 9 ! !   Root ought to be between B and (C+B)/2. ! 7 IF ( P >= CMB * Q ) GO TO 8 ! !   Use secant rule. ! B = B + P / Q GO TO 9 ! !   Use bisection (C+B)/2. ! 8 B = B + CMB ! !   Have completed computation for new iterate B. ! 9 T = B FB = F ( T ) KOUNT = KOUNT + 1 ! !   Decide whether next step is interpolation or extrapolation. ! IF ( SIGN ( ONE , FB ) /= SIGN ( ONE , FC )) GO TO 3 C = A FC = FA GO TO 3 ! !   Finished.  Process results for proper setting of IFLAG. ! 10 IF ( SIGN ( ONE , FB ) == SIGN ( ONE , FC )) GO TO 13 IF ( ABS ( FB ) > FX ) GO TO 12 IFLAG = 1 RETURN 11 IFLAG = 2 RETURN 12 IFLAG = 3 RETURN 13 IFLAG = 4 RETURN 14 IFLAG = 5 END SUBROUTINE FZERO end module fzero_mod","tags":"","loc":"sourcefile/fzero.f90.html"},{"title":"g_tofrom_h.f90 – stella","text":"Source Code module g_tofrom_h public :: gbar_to_g !  public :: gbar_to_h !  public :: gstar_to_g public :: g_to_h private interface gbar_to_g module procedure gbar_to_g_kxkyz module procedure gbar_to_g_1d_vpa module procedure gbar_to_g_vmu module procedure gbar_to_g_vmu_single end interface !  interface gbar_to_h !     module procedure gbar_to_h_kxkyz !     module procedure gbar_to_h_vmu !  end interface interface g_to_h module procedure g_to_h_kxkyz module procedure g_to_h_vmu module procedure g_to_h_vmu_single !     module procedure g_to_h_vmu_zext end interface contains !   subroutine gbar_to_h_vmu (g, phi, apar, facphi, facapar) !     use species, only: spec !     use zgrid, only: nzgrid !     use vpamu_grids, only: maxwell_vpa, maxwell_mu, vpa !     use stella_layouts, only: vmu_lo !     use stella_layouts, only: iv_idx, imu_idx, is_idx !     use kt_grids, only: naky, nakx !     use gyro_averages, only: aj0x !     implicit none !     complex, dimension (:,:,-nzgrid:,vmu_lo%llim_proc:), intent (in out) :: g !     complex, dimension (:,:,-nzgrid:), intent (in) :: phi, apar !     real, intent (in) :: facphi, facapar !     integer :: ivmu, iz, iky, ikx, is, imu, iv !     complex :: adj !     do ivmu = vmu_lo%llim_proc, vmu_lo%ulim_proc !        iv = iv_idx(vmu_lo,ivmu) !        imu = imu_idx(vmu_lo,ivmu) !        is = is_idx(vmu_lo,ivmu) !        do iz = -nzgrid, nzgrid !           do ikx = 1, nakx !              do iky = 1, naky !                 adj = aj0x(iky,ikx,iz,ivmu)*spec(is)%zt*maxwell_vpa(iv)*maxwell_mu(1,iz,imu) & !                      * ( facphi*phi(iky,ikx,iz) - facapar*vpa(iv)*spec(is)%stm*apar(iky,ikx,iz) ) !                 g(iky,ikx,iz,ivmu) = g(iky,ikx,iz,ivmu) + adj !              end do !           end do !        end do !     end do !   end subroutine gbar_to_h_vmu !   subroutine gbar_to_h_kxkyz (g, phi, apar, facphi, facapar) !     use species, only: spec !     use zgrid, only: nzgrid !     use vpamu_grids, only: maxwell_vpa, maxwell_mu, vpa !     use vpamu_grids, only: nvpa, nmu !     use stella_layouts, only: kxkyz_lo !     use stella_layouts, only: iky_idx, ikx_idx, iz_idx, is_idx !     use gyro_averages, only: aj0v !     implicit none !     complex, dimension (:,:,kxkyz_lo%llim_proc:), intent (in out) :: g !     complex, dimension (:,:,-nzgrid:), intent (in) :: phi, apar !     real, intent (in) :: facphi, facapar !     integer :: ikxkyz, iz, iky, ikx, is, imu, iv !     complex :: adj !     do ikxkyz = kxkyz_lo%llim_proc, kxkyz_lo%ulim_proc !        iz = iz_idx(kxkyz_lo,ikxkyz) !        ikx = ikx_idx(kxkyz_lo,ikxkyz) !        iky = iky_idx(kxkyz_lo,ikxkyz) !        is = is_idx(kxkyz_lo,ikxkyz) !        do imu = 1, nmu !           do iv = 1, nvpa !              adj = aj0v(imu,ikxkyz)*spec(is)%zt*maxwell_vpa(iv)*maxwell_mu(1,iz,imu) & !                   * ( facphi*phi(iky,ikx,iz) - facapar*vpa(iv)*spec(is)%stm*apar(iky,ikx,iz) ) !              g(iv,imu,ikxkyz) = g(iv,imu,ikxkyz) + adj !           end do !        end do !     end do !   end subroutine gbar_to_h_kxkyz subroutine gbar_to_g_kxkyz ( g , apar , facapar ) use species , only : spec use zgrid , only : nzgrid use vpamu_grids , only : maxwell_vpa , maxwell_mu , vpa use vpamu_grids , only : nvpa , nmu use stella_layouts , only : kxkyz_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , it_idx , is_idx use gyro_averages , only : gyro_average use run_parameters , only : maxwellian_normalization implicit none complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( in out ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: apar real , intent ( in ) :: facapar integer :: ikxkyz , iz , it , iky , ikx , is , ia complex , dimension (:, :), allocatable :: field , adjust allocate ( field ( nvpa , nmu )) allocate ( adjust ( nvpa , nmu )) ia = 1 do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iky = iky_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) !> adjust apar part of Zs <chi> / Ts field = 2.0 * facapar * apar ( iky , ikx , iz , it ) * spec ( is )% zt * spec ( is )% stm_psi0 * spread ( vpa , 2 , nmu ) if (. not . maxwellian_normalization ) then field = field * spread ( maxwell_vpa (:, is ), 2 , nmu ) * spread ( maxwell_mu ( ia , iz , :, is ), 1 , nvpa ) end if call gyro_average ( field , ikxkyz , adjust ) g (:, :, ikxkyz ) = g (:, :, ikxkyz ) - adjust end do end subroutine gbar_to_g_kxkyz subroutine gbar_to_g_1d_vpa ( g , apar , imu , ikxkyz , facapar ) use species , only : spec use vpamu_grids , only : maxwell_vpa , maxwell_mu , vpa use vpamu_grids , only : nvpa use stella_layouts , only : kxkyz_lo use stella_layouts , only : iz_idx , is_idx use gyro_averages , only : gyro_average use run_parameters , only : maxwellian_normalization implicit none complex , dimension (:), intent ( in out ) :: g complex , intent ( in ) :: apar integer , intent ( in ) :: imu , ikxkyz real , intent ( in ) :: facapar integer :: iz , is , ia complex , dimension (:), allocatable :: field , adjust allocate ( field ( nvpa )) allocate ( adjust ( nvpa )) ia = 1 iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) !> adjust apar part of Zs <chi> / Ts field = 2.0 * facapar * apar * spec ( is )% zt * spec ( is )% stm_psi0 * vpa if (. not . maxwellian_normalization ) then field = field * maxwell_vpa (:, is ) * maxwell_mu ( ia , iz , imu , is ) end if call gyro_average ( field , imu , ikxkyz , adjust ) g = g - adjust end subroutine gbar_to_g_1d_vpa subroutine gbar_to_g_vmu ( g , apar , facapar ) use zgrid , only : nzgrid use stella_layouts , only : vmu_lo implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: apar real , intent ( in ) :: facapar integer :: ivmu do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc call gbar_to_g_vmu_single ( ivmu , g (:, :, :, :, ivmu ), apar , facapar ) end do end subroutine gbar_to_g_vmu subroutine gbar_to_g_vmu_single ( ivmu , g0 , apar , facapar ) use species , only : spec use zgrid , only : nzgrid , ntubes use stella_layouts , only : vmu_lo , iv_idx , imu_idx , is_idx use kt_grids , only : naky , nakx use kt_grids , only : multiply_by_rho use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use vpamu_grids , only : vpa use gyro_averages , only : gyro_average use run_parameters , only : maxwellian_normalization implicit none integer , intent ( in ) :: ivmu complex , dimension (:, :, - nzgrid :, :), intent ( in out ) :: g0 complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: apar real , intent ( in ) :: facapar integer :: iv , imu , is integer :: it , iz , ia complex , dimension (:, :), allocatable :: field , adjust iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) allocate ( field ( naky , nakx )) allocate ( adjust ( naky , nakx )) ia = 1 do it = 1 , ntubes do iz = - nzgrid , nzgrid !> adjust apar part of <chi> field = 2.0 * spec ( is )% zt * spec ( is )% stm_psi0 * vpa ( iv ) * facapar * apar (:, :, iz , it ) if (. not . maxwellian_normalization ) then field = field * maxwell_vpa ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) * maxwell_fac ( is ) end if call gyro_average ( field , iz , ivmu , adjust ) g0 (:, :, iz , it ) = g0 (:, :, iz , it ) - adjust end do end do deallocate ( field , adjust ) end subroutine gbar_to_g_vmu_single subroutine g_to_h_vmu ( g , phi , bpar , facphi , phi_corr ) use zgrid , only : nzgrid use stella_layouts , only : vmu_lo implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: phi , bpar complex , dimension (:, :, - nzgrid :, :), optional , intent ( in ) :: phi_corr real , intent ( in ) :: facphi integer :: ivmu do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc call g_to_h_vmu_single ( ivmu , g (:, :, :, :, ivmu ), phi , bpar , facphi , phi_corr ) end do end subroutine g_to_h_vmu subroutine g_to_h_vmu_single ( ivmu , g0 , phi , bpar , facphi , phi_corr ) use species , only : spec use zgrid , only : nzgrid , ntubes use stella_layouts , only : vmu_lo , iv_idx , imu_idx , is_idx use stella_geometry , only : bmag , dBdrho use dist_fn_arrays , only : kperp2 , dkperp2dr use kt_grids , only : naky , nakx use kt_grids , only : multiply_by_rho use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use vpamu_grids , only : vpa , vperp2 , mu use gyro_averages , only : gyro_average , gyro_average_j1 , aj0x , aj1x use physics_flags , only : radial_variation , include_bpar use run_parameters , only : maxwellian_normalization implicit none integer , intent ( in ) :: ivmu complex , dimension (:, :, - nzgrid :, :), intent ( in out ) :: g0 complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: phi , bpar real , intent ( in ) :: facphi complex , dimension (:, :, - nzgrid :, :), optional , intent ( in ) :: phi_corr real :: facbpar integer :: iv , imu , is integer :: it , iz , ia complex , dimension (:, :), allocatable :: field , adjust , g0k iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) allocate ( field ( naky , nakx )) allocate ( adjust ( naky , nakx )) if ( radial_variation ) then allocate ( g0k ( naky , nakx )) end if ia = 1 do it = 1 , ntubes do iz = - nzgrid , nzgrid field = spec ( is )% zt * facphi * phi (:, :, iz , it ) if (. not . maxwellian_normalization ) then field = field * maxwell_vpa ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) * maxwell_fac ( is ) end if if ( radial_variation . and . present ( phi_corr )) then g0k = field * ( - spec ( is )% tprim * ( vpa ( iv ) ** 2 + vperp2 ( ia , iz , imu ) - 2.5 ) & - spec ( is )% fprim - 2.0 * dBdrho ( iz ) * mu ( imu ) & - 0.5 * aj1x (:, :, iz , ivmu ) / aj0x (:, :, iz , ivmu ) * ( spec ( is )% smz ) ** 2 & * ( kperp2 (:, :, ia , iz ) * vperp2 ( ia , iz , imu ) / bmag ( ia , iz ) ** 2 ) & * ( dkperp2dr (:, :, ia , iz ) - dBdrho ( iz ) / bmag ( ia , iz ))) call multiply_by_rho ( g0k ) field = field + g0k & + phi_corr (:, :, iz , it ) * spec ( is )% zt * facphi & * maxwell_vpa ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) * maxwell_fac ( is ) end if call gyro_average ( field , iz , ivmu , adjust ) g0 (:, :, iz , it ) = g0 (:, :, iz , it ) + adjust end do end do if ( include_bpar ) then facbpar = facphi do it = 1 , ntubes do iz = - nzgrid , nzgrid !> adjust bpar part of Zs <chi> / Ts field = 4.0 * mu ( imu ) * facbpar * bpar (:,:, iz , it ) if (. not . maxwellian_normalization ) then field = field * maxwell_vpa ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) * maxwell_fac ( is ) end if call gyro_average_j1 ( field , iz , ivmu , adjust ) g0 (:, :, iz , it ) = g0 (:, :, iz , it ) + adjust end do end do end if deallocate ( field , adjust ) if ( allocated ( g0k )) deallocate ( g0k ) end subroutine g_to_h_vmu_single !   subroutine g_to_h_vmu_zext (gext, phiext, facphi, iky, ie) !     use species, only: spec !     use extended_zgrid, only: ikxmod !     use extended_zgrid, only: iz_low, iz_up !     use extended_zgrid, only: nsegments !     use vpamu_grids, only: maxwell_vpa, maxwell_mu !     use stella_layouts, only: vmu_lo !     use stella_layouts, only: iv_idx, imu_idx, is_idx !     use gyro_averages, only: aj0x !     implicit none !     complex, dimension (:,vmu_lo%llim_proc:), intent (in out) :: gext !     complex, dimension (:), intent (in) :: phiext !     real, intent (in) :: facphi !     integer, intent (in) :: iky, ie !     integer :: ivmu, iseg, iz, ikx, is, imu, iv !     integer :: idx !     complex :: adj !     do ivmu = vmu_lo%llim_proc, vmu_lo%ulim_proc !        iv = iv_idx(vmu_lo,ivmu) !        imu = imu_idx(vmu_lo,ivmu) !        is = is_idx(vmu_lo,ivmu) !        idx = 0 !        iseg = 1 !        ikx = ikxmod(iseg,ie,iky) !        do iz = iz_low(iseg), iz_up(iseg) !           idx = idx + 1 !           adj = aj0x(iky,ikx,iz,ivmu)*spec(is)%zt*maxwell_vpa(iv)*maxwell_mu(1,iz,imu) & !                * facphi*phiext(idx) !           gext(idx,ivmu) = gext(idx,ivmu) + adj !        end do !        if (nsegments(ie,iky) > 1) then !           do iseg = 2, nsegments(ie,iky) !              do iz = iz_low(iseg)+1, iz_up(iseg) !                 adj = aj0x(iky,ikx,iz,ivmu)*spec(is)%zt*maxwell_vpa(iv)*maxwell_mu(1,iz,imu) & !                      * facphi*phiext(idx) !                 gext(idx,ivmu) = gext(idx,ivmu) + adj !                 idx = idx + 1 !              end do !           end do !        end if !     end do !   end subroutine g_to_h_vmu_zext subroutine g_to_h_kxkyz ( g , phi , bpar , facphi ) use species , only : spec use zgrid , only : nzgrid use vpamu_grids , only : nvpa , nmu , mu use vpamu_grids , only : maxwell_vpa , maxwell_mu use stella_layouts , only : kxkyz_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , it_idx , is_idx use gyro_averages , only : gyro_average , gyro_average_j1 use run_parameters , only : maxwellian_normalization use physics_flags , only : include_bpar implicit none complex , dimension (:, :, kxkyz_lo % llim_proc :), intent ( in out ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: phi , bpar real , intent ( in ) :: facphi integer :: ikxkyz , iz , it , iky , ikx , is , ia complex , dimension (:, :), allocatable :: field , adjust real :: facbpar allocate ( field ( nvpa , nmu )) allocate ( adjust ( nvpa , nmu )) ia = 1 do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iky = iky_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) field = facphi * phi ( iky , ikx , iz , it ) * spec ( is )% zt if (. not . maxwellian_normalization ) then field = field * spread ( maxwell_vpa (:, is ), 2 , nmu ) * spread ( maxwell_mu ( ia , iz , :, is ), 1 , nvpa ) end if call gyro_average ( field , ikxkyz , adjust ) g (:, :, ikxkyz ) = g (:, :, ikxkyz ) + adjust end do if ( include_bpar ) then facbpar = facphi do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iky = iky_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) !> adjust bpar part of Zs <chi>/ Ts field = 4.0 * facbpar * spread ( mu , 1 , nvpa ) * bpar ( iky , ikx , iz , it ) if (. not . maxwellian_normalization ) then field = field * spread ( maxwell_vpa (:, is ), 2 , nmu ) * spread ( maxwell_mu ( ia , iz , :, is ), 1 , nvpa ) end if call gyro_average_j1 ( field , ikxkyz , adjust ) g (:, :, ikxkyz ) = g (:, :, ikxkyz ) + adjust end do end if deallocate ( field , adjust ) end subroutine g_to_h_kxkyz !   subroutine gstar_to_g (g, phi, apar, facphi, facapar) !     use constants, only: zi !     use species, only: spec !     use zgrid, only: nzgrid !     use vpamu_grids, only: vpa !     use stella_layouts, only: vmu_lo !     use stella_layouts, only: iv_idx, is_idx !     use kt_grids, only: naky, nakx !     use kt_grids, only: aky !     use gyro_averages, only: aj0x !     implicit none !     complex, dimension (:,:,-nzgrid:,vmu_lo%llim_proc:), intent (in out) :: g !     complex, dimension (:,:,-nzgrid:), intent (in) :: phi, apar !     real, intent (in) :: facphi, facapar !     integer :: ivmu, iz, iky, ikx, is, iv !     complex :: adj !     do ivmu = vmu_lo%llim_proc, vmu_lo%ulim_proc !        iv = iv_idx(vmu_lo,ivmu) !        is = is_idx(vmu_lo,ivmu) !        do iz = -nzgrid, nzgrid !           do ikx = 1, nakx !              do iky = 1, naky !                 ! BACKWARDS DIFFERENCE FLAG ! !                adj = zi*aj0x(iky,ikx,iz,ivmu)*aky(iky)*wstar(iz,ivmu) & !                 adj = zi*aj0x(iky,ikx,iz,ivmu)*aky(iky)*2.0*wstar(1,iz,ivmu) & !                      * ( facphi*phi(iky,ikx,iz) - facapar*vpa(iv)*spec(is)%stm*apar(iky,ikx,iz) ) !                 g(iky,ikx,iz,ivmu) = g(iky,ikx,iz,ivmu) + adj !              end do !           end do !        end do !     end do !   end subroutine gstar_to_g end module g_tofrom_h","tags":"","loc":"sourcefile/g_tofrom_h.f90.html"},{"title":"kt_grids.f90 – stella","text":"Source Code ! Set up the perpendicular wavenumbers by calling the appropriate sub-modules. module kt_grids implicit none public :: init_kt_grids , finish_kt_grids public :: read_kt_grids_parameters , box public :: aky , theta0 , akx , zed0 public :: aky_all , aky_all_ordered public :: naky , nakx , nx , ny , reality public :: dx , dy , dkx , dky , dx_d public :: jtwist , jtwistfac , ikx_twist_shift , x0 , y0 public :: x , x_d , y public :: rho , rho_d , rho_clamped , rho_d_clamped public :: nalpha public :: ikx_max , naky_all public :: phase_shift_angle public :: zonal_mode public :: swap_kxky , swap_kxky_back public :: swap_kxky_ordered , swap_kxky_back_ordered public :: multiply_by_rho , centered_in_rho public :: periodic_variation public :: communicate_ktgrids_multibox public :: boundary_size , copy_size , krook_size private interface swap_kxky module procedure swap_kxky_real module procedure swap_kxky_complex end interface interface swap_kxky_ordered module procedure swap_kxky_ordered_real module procedure swap_kxky_ordered_complex end interface real , dimension (:, :), allocatable :: theta0 , zed0 real , dimension (:), allocatable :: aky , akx , aky_all , aky_all_ordered real , dimension (:), allocatable :: x , x_d , y real , dimension (:), allocatable :: rho , rho_d , rho_clamped , rho_d_clamped complex , dimension (:, :), allocatable :: g0x real :: dx , dy , dkx , dky , dx_d real :: jtwistfac , phase_shift_angle integer :: naky , nakx , nx , ny , nalpha integer :: jtwist , ikx_twist_shift integer :: ikx_max , naky_all integer :: boundary_size , copy_size , krook_size logical :: reality = . false . logical :: centered_in_rho , periodic_variation , randomize_phase_shift character ( 20 ) :: grid_option logical , dimension (:), allocatable :: zonal_mode namelist / kt_grids_knobs / grid_option ! internal variables integer :: gridopt_switch integer , parameter :: gridopt_range = 1 , gridopt_box = 2 integer :: kyspacing_option_switch integer , parameter :: kyspacing_linear = 1 , kyspacing_exponential = 2 real :: aky_min , aky_max real :: akx_min , akx_max real :: theta0_min , theta0_max real :: x0 , y0 logical :: read_kt_grids_initialized = . false . logical :: init_kt_grids_initialized = . false . logical :: box contains subroutine read_kt_grids_parameters use mp , only : proc0 implicit none if ( read_kt_grids_initialized ) return read_kt_grids_initialized = . true . if ( proc0 ) then call read_grid_option select case ( gridopt_switch ) case ( gridopt_range ) call read_kt_grids_range case ( gridopt_box ) call read_kt_grids_box end select end if call broadcast_input call allocate_arrays end subroutine read_kt_grids_parameters subroutine read_grid_option use file_utils , only : input_unit , error_unit , input_unit_exist use text_options , only : text_option , get_option_value implicit none type ( text_option ), dimension ( 5 ), parameter :: gridopts = & ( / text_option ( 'default' , gridopt_range ), & text_option ( 'range' , gridopt_range ), & text_option ( 'box' , gridopt_box ), & text_option ( 'annulus' , gridopt_box ), & text_option ( 'nonlinear' , gridopt_box ) / ) integer :: ierr , in_file logical :: nml_exist grid_option = 'default' in_file = input_unit_exist ( \"kt_grids_knobs\" , nml_exist ) if ( nml_exist ) read ( unit = in_file , nml = kt_grids_knobs ) ierr = error_unit () call get_option_value ( grid_option , gridopts , gridopt_switch , & ierr , \"grid_option in kt_grids_knobs\" ) end subroutine read_grid_option subroutine read_kt_grids_box use file_utils , only : input_unit_exist use physics_flags , only : full_flux_surface implicit none integer :: in_file logical :: exist namelist / kt_grids_box_parameters / nx , ny , jtwist , jtwistfac , x0 , y0 , & centered_in_rho , periodic_variation , & randomize_phase_shift , phase_shift_angle ! note that jtwist and y0 will possibly be modified ! later in init_kt_grids_box if they make it out ! of this subroutine with negative values ! it is necessary to wait until later to do this check ! because the values to which they may be set will ! depend on information from the geometry module, ! which itself may rely on ny from here (number of alphas) nx = 1 ny = 1 jtwist = - 1 jtwistfac = 1. phase_shift_angle = 0. x0 = - 1.0 y0 = - 1.0 nalpha = 1 centered_in_rho = . true . randomize_phase_shift = . false . periodic_variation = . false . in_file = input_unit_exist ( \"kt_grids_box_parameters\" , exist ) if ( exist ) read ( in_file , nml = kt_grids_box_parameters ) ! get the number of de-aliased modes in y and x, using reality to halve the number of ky modes naky = ( ny - 1 ) / 3 + 1 nakx = 2 * (( nx - 1 ) / 3 ) + 1 ! get the total number of ky values, including negative ky; ! this is approximately 2/3 ny because ny includes padding to avoid aliasing naky_all = 2 * naky - 1 reality = . true . if ( full_flux_surface ) nalpha = ny end subroutine read_kt_grids_box subroutine read_kt_grids_range use mp , only : mp_abort , proc0 use file_utils , only : input_unit , error_unit , input_unit_exist use physics_flags , only : full_flux_surface use text_options , only : text_option , get_option_value implicit none type ( text_option ), dimension ( 3 ), parameter :: kyspacingopts = & ( / text_option ( 'default' , kyspacing_linear ), & text_option ( 'linear' , kyspacing_linear ), & text_option ( 'exponential' , kyspacing_exponential ) / ) character ( 20 ) :: kyspacing_option = 'default' integer :: ierr , in_file logical :: exist namelist / kt_grids_range_parameters / naky , nakx , & aky_min , aky_max , theta0_min , theta0_max , akx_min , akx_max , kyspacing_option nalpha = 1 naky = 1 nakx = 1 aky_min = 0.0 aky_max = 0.0 ! set these to be nonsense values ! so can check later if they've been set akx_min = 0.0 akx_max = - 1.0 theta0_min = 0.0 theta0_max = - 1.0 phase_shift_angle = 0. in_file = input_unit_exist ( \"kt_grids_range_parameters\" , exist ) if ( exist ) read ( in_file , nml = kt_grids_range_parameters ) if ( full_flux_surface ) then if ( proc0 ) then write ( * , * ) '!!! ERROR !!!' write ( * , * ) 'kt_grids \"range\" option is not supported for full_flux_surface = T. aborting' write ( * , * ) '!!! ERROR !!!' end if call mp_abort ( 'kt_grids \"range\" option is not supported for full_flux_surface = T. aborting' ) end if naky_all = naky ierr = error_unit () call get_option_value ( kyspacing_option , kyspacingopts , kyspacing_option_switch , & ierr , \"kyspacing_option in kt_grids_range_parameters\" , . true .) end subroutine read_kt_grids_range subroutine init_kt_grids use common_types , only : flux_surface_type use zgrid , only : init_zgrid implicit none if ( init_kt_grids_initialized ) return init_kt_grids_initialized = . true . call init_zgrid select case ( gridopt_switch ) case ( gridopt_range ) call init_kt_grids_range case ( gridopt_box ) call init_kt_grids_box end select !> determine if iky corresponds to zonal mode if (. not . allocated ( zonal_mode )) allocate ( zonal_mode ( naky )) zonal_mode = . false . if ( abs ( aky ( 1 )) < epsilon ( 0. )) zonal_mode ( 1 ) = . true . end subroutine init_kt_grids subroutine init_kt_grids_box use mp , only : mp_abort , proc0 , broadcast use common_types , only : flux_surface_type use constants , only : pi , zi use stella_geometry , only : geo_surf , twist_and_shift_geo_fac , dydalpha use stella_geometry , only : q_as_x , get_x_to_rho , dxdXcoord , drhodpsi use physics_parameters , only : rhostar use physics_flags , only : full_flux_surface , radial_variation use file_utils , only : runtype_option_switch , runtype_multibox use zgrid , only : nperiod use zgrid , only : boundary_option_switch , boundary_option_linked use zgrid , only : boundary_option_linked_stellarator use ran , only : ranf implicit none integer :: ikx , iky integer :: ikyneg real :: x_shift , dqdrho , pfac , norm box = . true . !> set jtwist and y0 for cases where they have not been specified !> and for which it makes sense to set them automatically if ( jtwist < 1 ) then jtwist = max ( 1 , int ( abs ( twist_and_shift_geo_fac ) + 0.5 )) jtwist = max ( 1 , int ( jtwistfac * jtwist + 0.5 )) end if !> signed version of jtwist, with sign determined by, e.g., magnetic shear ikx_twist_shift = - jtwist * int ( sign ( 1.0 , twist_and_shift_geo_fac )) if ( y0 < 0. ) then if ( full_flux_surface ) then !> if simulating a flux annulus, then !> y0 determined by the physical !> extent of the device if ( rhostar > 0. ) then !y0 = 1./(rhostar*geo_surf%rhotor) y0 = geo_surf % rhotor / rhostar else call mp_abort ( 'must set rhostar if simulating a full flux surface. aborting.' ) end if else !> if simulating a flux tube !> makes no sense to have y0 < 0.0 !> so abort call mp_abort ( 'y0 negative only makes sense when simulating a flux annulus.  aborting.' ) end if end if !> get the grid spacing in ky and then in kx using twist-and-shift BC dky = 1. / y0 ! kx = ky * twist_shift_geo_fac / jtwist for every linked boundary condition ! except for the periodic ones select case ( boundary_option_switch ) case ( boundary_option_linked ) dkx = ( 2 * nperiod - 1 ) * dky * abs ( twist_and_shift_geo_fac ) / real ( jtwist ) case ( boundary_option_linked_stellarator ) dkx = dky * abs ( twist_and_shift_geo_fac ) / real ( jtwist ) case default if ( x0 < epsilon ( 0.0 )) then dkx = dky else dkx = 1. / x0 end if end select x0 = 1. / dkx !> ky goes from zero to ky_max do iky = 1 , naky aky ( iky ) = real ( iky - 1 ) * dky end do !> get the ikx index corresponding to kx_max ikx_max = nakx / 2 + 1 !> aky_all contains all ky values (positive and negative), !> stored in the same order as akx (0 -> ky_max, -ky_max -> -dky) !> first set arrays equal for ky >= 0 aky_all (: naky ) = aky !> aky_all_ordered contains all ky values, stored from !> most negative to most positive (-ky_max -> ky_max) aky_all_ordered ( naky : naky_all ) = aky !> next fill in ky < 0 do iky = naky + 1 , naky_all !> this is the ky index corresponding to +ky in original array ikyneg = naky_all - iky + 2 aky_all ( iky ) = - aky ( ikyneg ) end do aky_all_ordered (: naky - 1 ) = aky_all ( naky + 1 :) !> kx goes from zero to kx_max down to zero... do ikx = 1 , ikx_max akx ( ikx ) = real ( ikx - 1 ) * dkx end do !> and then from -kx_max to -|kx_min| do ikx = ikx_max + 1 , nakx akx ( ikx ) = real ( ikx - nakx - 1 ) * dkx end do !> set theta0=0 for ky=0 theta0 ( 1 , :) = 0.0 if ( q_as_x ) then do ikx = 1 , nakx !> theta0 = kx/ky theta0 ( 2 :, ikx ) = akx ( ikx ) / aky ( 2 :) end do else do ikx = 1 , nakx !> theta0 = kx/ky/shat theta0 ( 2 :, ikx ) = akx ( ikx ) / ( aky ( 2 :) * geo_surf % shat ) end do end if norm = 1. if ( naky > 1 ) norm = aky ( 2 ) if ( rhostar > 0. ) then phase_shift_angle = - 2. * pi * ( 2 * nperiod - 1 ) * geo_surf % qinp_psi0 * dydalpha / rhostar else if ( randomize_phase_shift ) then if ( proc0 ) phase_shift_angle = 2. * pi * ranf () / norm call broadcast ( phase_shift_angle ) else phase_shift_angle = 2. * pi * phase_shift_angle / norm end if !> MAB: a lot of the radial variation coding below should probably be tidied away !> into one or more separate subroutines !> for radial variation if (. not . allocated ( x_d )) allocate ( x_d ( nakx )) if (. not . allocated ( rho )) allocate ( rho ( nx )) if (. not . allocated ( rho_d )) allocate ( rho_d ( nakx )) if (. not . allocated ( rho_clamped )) allocate ( rho_clamped ( nx )) if (. not . allocated ( rho_d_clamped )) allocate ( rho_d_clamped ( nakx )) if (. not . allocated ( x )) allocate ( x ( nx )) if (. not . allocated ( y )) allocate ( y ( ny )) dx = ( 2 * pi * x0 ) / nx dy = ( 2 * pi * y0 ) / ny x_shift = pi * x0 pfac = 1.0 if ( periodic_variation ) pfac = 0.5 if ( centered_in_rho ) then if ( q_as_x ) then dqdrho = geo_surf % shat * geo_surf % qinp / geo_surf % rhoc x_shift = pi * x0 * ( 1.0 & - 0.5 * pfac * rhostar * pi * x0 * geo_surf % d2qdr2 / ( dqdrho ** 2 * dxdXcoord )) else x_shift = pi * x0 * ( 1.0 & - 0.5 * pfac * rhostar * pi * x0 * geo_surf % d2psidr2 * drhodpsi ** 2 / dxdXcoord ) end if end if do ikx = 1 , nx if ( radial_variation . or . runtype_option_switch == runtype_multibox ) then if ( periodic_variation ) then if ( ikx <= nx / 2 ) then x ( ikx ) = ( ikx - 1 ) * dx - 0.5 * x_shift else x ( ikx ) = x ( nx - ikx + 1 ) end if else x ( ikx ) = ( ikx - 0.5 ) * dx - x_shift end if else x ( ikx ) = ( ikx - 1 ) * dx end if end do dx_d = ( 2 * pi * x0 ) / nakx do ikx = 1 , nakx if ( radial_variation . or . runtype_option_switch == runtype_multibox ) then if ( periodic_variation ) then if ( ikx <= ( nakx + 1 ) / 2 ) then x_d ( ikx ) = ( ikx - 1 ) * dx_d - 0.5 * x_shift else x_d ( ikx ) = x_d ( nakx - ikx + 1 ) end if else x_d ( ikx ) = ( ikx - 0.5 ) * dx_d - x_shift end if else x_d ( ikx ) = ( ikx - 1 ) * dx_d end if end do call get_x_to_rho ( 1 , x , rho ) call get_x_to_rho ( 1 , x_d , rho_d ) if (. not . allocated ( rho_clamped )) allocate ( rho_clamped ( nx )); rho_clamped = rho if (. not . allocated ( rho_d_clamped )) allocate ( rho_d_clamped ( nakx )); rho_d_clamped = rho_d zed0 = theta0 * geo_surf % zed0_fac if ( radial_variation ) call dump_radial_grid if ( radial_variation . and . ( any (( rho + geo_surf % rhoc ) < 0.0 ) & . or . any (( rho + geo_surf % rhoc ) > 1.0 ))) then call mp_abort ( 'rho(x) is beyond range [0,1]. Try changing rhostar or q/psi profiles' ) end if do iky = 1 , ny y ( iky ) = ( iky - 1 ) * dy end do end subroutine init_kt_grids_box subroutine init_kt_grids_range use mp , only : mp_abort use common_types , only : flux_surface_type use stella_geometry , only : geo_surf , q_as_x use zgrid , only : shat_zero implicit none integer :: i , j real :: dkx , dky , dtheta0 , tfac real :: zero box = . false . ! NB: we are assuming here that all ky are positive ! when running in range mode dky = 0.0 if ( naky > 1 ) then select case ( kyspacing_option_switch ) case ( kyspacing_linear ) dky = ( aky_max - aky_min ) / real ( naky - 1 ) aky = ( / ( aky_min + dky * real ( i ), i = 0 , naky - 1 ) / ) case ( kyspacing_exponential ) dky = ( log ( aky_max ) - log ( aky_min )) / real ( naky - 1 ) aky = ( / ( exp ( log ( aky_min ) + dky * real ( i )), i = 0 , naky - 1 ) / ) end select else aky = ( / ( aky_min , i = 0 , naky - 1 ) / ) end if ! set default akx and theta0 to 0 akx = 0.0 ; theta0 = 0.0 if ( q_as_x ) then tfac = 1.0 else tfac = geo_surf % shat end if zero = 10 0. * epsilon ( 0. ) ! if theta0_min and theta0_max have been specified, ! use them to determine akx_min and akx_max if ( theta0_max > theta0_min - zero ) then if ( geo_surf % shat > epsilon ( 0. )) then akx_min = theta0_min * tfac * aky ( 1 ) akx_max = theta0_max * tfac * aky ( 1 ) else akx_min = theta0_max * tfac * aky ( 1 ) akx_max = theta0_min * tfac * aky ( 1 ) end if end if ! shat_zero is minimum shat value below which periodic BC is enforced if ( abs ( geo_surf % shat ) > shat_zero ) then ! ie assumes boundary_option .eq. 'linked' ! if akx_min and akx_max specified in input ! instead of theta0_min and theta0_max, ! use them to get theta0_min and theta0_max if ( theta0_min > theta0_max + zero . and . abs ( aky ( 1 )) > zero ) then theta0_min = akx_min / ( tfac * aky ( 1 )) theta0_max = akx_max / ( tfac * aky ( 1 )) dtheta0 = 0.0 if ( nakx > 1 ) dtheta0 = ( theta0_max - theta0_min ) / real ( nakx - 1 ) do j = 1 , naky theta0 ( j , :) & = ( / ( theta0_min + dtheta0 * real ( i ), i = 0 , nakx - 1 ) / ) end do akx = theta0 ( 1 , :) * tfac * aky ( 1 ) else if ( akx_max > akx_min - zero . or . nakx == 1 ) then dkx = 0.0 if ( nakx > 1 ) dkx = ( akx_max - akx_min ) / real ( nakx - 1 ) akx = ( / ( akx_min + dkx * real ( i ), i = 0 , nakx - 1 ) / ) dtheta0 = 0.0 if ( nakx > 1 ) dtheta0 = ( theta0_max - theta0_min ) / real ( nakx - 1 ) if ( geo_surf % shat > epsilon ( 0. )) then do j = 1 , naky theta0 ( j , :) & = ( / ( theta0_min + dtheta0 * real ( i ), i = 0 , nakx - 1 ) / ) end do else do j = 1 , naky theta0 ( j , :) & = ( / ( theta0_min + dtheta0 * real ( i ), i = nakx - 1 , 0 , - 1 ) / ) end do end if else call mp_abort ( 'ky=0 is inconsistent with kx_min different from kx_max. aborting.' ) end if else ! here assume boundary_option .eq. 'periodic' ! used for periodic finite kx ballooning space runs with shat=0 dkx = 0.0 if ( nakx > 1 ) dkx = ( akx_max - akx_min ) / real ( nakx - 1 ) akx = ( / ( akx_min + dkx * real ( i ), i = 0 , nakx - 1 ) / ) end if zed0 = theta0 * geo_surf % zed0_fac ikx_max = nakx naky_all = naky end subroutine init_kt_grids_range subroutine broadcast_input use mp , only : broadcast implicit none call broadcast ( gridopt_switch ) call broadcast ( centered_in_rho ) call broadcast ( periodic_variation ) call broadcast ( naky ) call broadcast ( naky_all ) call broadcast ( nakx ) call broadcast ( ny ) call broadcast ( nx ) call broadcast ( nalpha ) call broadcast ( reality ) call broadcast ( jtwist ) call broadcast ( jtwistfac ) call broadcast ( x0 ) call broadcast ( y0 ) call broadcast ( aky_min ) call broadcast ( aky_max ) call broadcast ( akx_min ) call broadcast ( akx_max ) call broadcast ( theta0_min ) call broadcast ( theta0_max ) call broadcast ( randomize_phase_shift ) call broadcast ( phase_shift_angle ) call broadcast ( kyspacing_option_switch ) end subroutine broadcast_input subroutine dump_radial_grid use file_utils , only : run_name use physics_parameters , only : rhostar use stella_geometry , only : q_as_x , geo_surf , dxdXcoord , drhodpsi implicit none integer :: ix character ( 300 ) :: filename filename = trim ( trim ( run_name ) // '.radial_grid' ) open ( 1047 , file = filename , status = 'unknown' ) if ( q_as_x ) then write ( 1047 , '(1a12,1e12.4,1a12,1e12.4,1a12,1e12.4,1a12,1e12.4)' ) & '#dxdXcoord = ' , dxdXcoord , & ' q    = ' , geo_surf % qinp , & ' dqdr = ' , geo_surf % shat * geo_surf % qinp / geo_surf % rhoc , & ' d2qdr2 = ' , geo_surf % d2qdr2 write ( 1047 , '(3a12)' ) '#1.x' , '2.q' , '3.rho' do ix = 1 , nx write ( 1047 , '(3e12.4,i9)' ) & x ( ix ), & rhostar * x ( ix ) / dxdXcoord + geo_surf % qinp , & rho ( ix ) + geo_surf % rhoc end do else write ( 1047 , '(1a12,1e12.4,1a12,1e12.4,1a12,1e12.4,1a12,1e12.4)' ) & '#dxdXcoord = ' , dxdXcoord , & ' dpsidr    = ' , 1.0 / drhodpsi , & ' d2psidr2 = ' , geo_surf % d2psidr2 write ( 1047 , '(3a12,a9)' ) '#1.x' , '2.psi-psi0' , '3.rho' do ix = 1 , nx write ( 1047 , '(3e12.4,i9)' ) & x ( ix ), & rhostar * x ( ix ) / dxdXcoord , & rho ( ix ) + geo_surf % rhoc end do end if close ( 1047 ) end subroutine dump_radial_grid subroutine allocate_arrays implicit none allocate ( akx ( nakx )) allocate ( aky ( naky )) allocate ( aky_all ( naky_all )) allocate ( aky_all_ordered ( naky_all )) allocate ( theta0 ( naky , nakx )) allocate ( zed0 ( naky , nakx )) end subroutine allocate_arrays ! take an array with ky >= 0 and all kx (ordered like 0, ..., kxmax, -kxmax, ..., -dkx) ! and uses reality condition to return array ! with kx >= 0 and all ky (ordered like 0, ..., kymax, -kymax, ..., -dky) subroutine swap_kxky_complex ( gin , gout ) implicit none complex , dimension (:, :), intent ( in ) :: gin complex , dimension (:, :), intent ( out ) :: gout integer :: ikx , ikxneg integer :: iky , ikyneg ! first set arrays equal for ky >= 0 and kx >= 0 gout (: naky , :) = gin (:, : ikx_max ) ! next fill in ky < 0, kx >= 0 elements of array using reality ikx = 1 ikxneg = ikx do iky = naky + 1 , naky_all ! this is the ky index corresponding to +ky in original array ikyneg = naky_all - iky + 2 gout ( iky , ikx ) = conjg ( gin ( ikyneg , ikxneg )) end do do ikx = 2 , ikx_max ikxneg = nakx - ikx + 2 do iky = naky + 1 , naky_all ! this is the ky index corresponding to +ky in original array ikyneg = naky_all - iky + 2 gout ( iky , ikx ) = conjg ( gin ( ikyneg , ikxneg )) end do end do end subroutine swap_kxky_complex ! take an array with ky >= 0 and all kx (ordered like 0, ..., kxmax, -kxmax, ..., -dkx) ! and uses reality condition to return array ! with kx >= 0 and all ky (ordered like 0, ..., kymax, -kymax, ..., -dky) subroutine swap_kxky_real ( gin , gout ) implicit none real , dimension (:, :), intent ( in ) :: gin real , dimension (:, :), intent ( out ) :: gout integer :: ikx , ikxneg integer :: iky , ikyneg ! first set arrays equal for ky >= 0 and kx >= 0 gout (: naky , :) = gin (:, : ikx_max ) ! next fill in ky < 0, kx >= 0 elements of array using reality ikx = 1 ikxneg = ikx do iky = naky + 1 , naky_all ! this is the ky index corresponding to +ky in original array ikyneg = naky_all - iky + 2 gout ( iky , ikx ) = gin ( ikyneg , ikxneg ) end do do ikx = 2 , ikx_max ikxneg = nakx - ikx + 2 do iky = naky + 1 , naky_all ! this is the ky index corresponding to +ky in original array ikyneg = naky_all - iky + 2 gout ( iky , ikx ) = gin ( ikyneg , ikxneg ) end do end do end subroutine swap_kxky_real ! take an array with ky >= 0 and all kx (ordered like 0, ..., kxmax, -kxmax, ..., -dkx) ! and uses reality condition to return array ! with kx >= 0 and all ky (ordered like -kymax, ..., 0, ..., kymax) subroutine swap_kxky_ordered_real ( gin , gout ) implicit none real , dimension (:, :), intent ( in ) :: gin real , dimension (:, :), intent ( out ) :: gout integer :: ikx , ikxneg integer :: iky , ikyneg ! first set arrays equal for ky >= 0 and kx >= 0 gout ( naky :, :) = gin (:, : ikx_max ) ! next fill in ky < 0, kx >= 0 elements of array using reality ikx = 1 ikxneg = ikx do iky = 1 , naky - 1 ! this is the ky index corresponding to +ky in original array ikyneg = naky - iky + 1 gout ( iky , ikx ) = gin ( ikyneg , ikxneg ) end do do ikx = 2 , ikx_max ikxneg = nakx - ikx + 2 do iky = 1 , naky - 1 ! this is the ky index corresponding to +ky in original array ikyneg = naky - iky + 1 gout ( iky , ikx ) = gin ( ikyneg , ikxneg ) end do end do end subroutine swap_kxky_ordered_real ! take an array with ky >= 0 and all kx (ordered like 0, ..., kxmax, -kxmax, ..., -dkx) ! and uses reality condition to return array ! with kx >= 0 and all ky (ordered like -kymax, ..., 0, ..., kymax) subroutine swap_kxky_ordered_complex ( gin , gout ) implicit none complex , dimension (:, :), intent ( in ) :: gin complex , dimension (:, :), intent ( out ) :: gout integer :: ikx , ikxneg integer :: iky , ikyneg ! first set arrays equal for ky >= 0 and kx >= 0 gout ( naky :, :) = gin (:, : ikx_max ) ! next fill in ky < 0, kx >= 0 elements of array using reality ikx = 1 ikxneg = ikx do iky = 1 , naky - 1 ! this is the ky index corresponding to +ky in original array ikyneg = naky - iky + 1 gout ( iky , ikx ) = conjg ( gin ( ikyneg , ikxneg )) end do do ikx = 2 , ikx_max ikxneg = nakx - ikx + 2 do iky = 1 , naky - 1 ! this is the ky index corresponding to +ky in original array ikyneg = naky - iky + 1 gout ( iky , ikx ) = conjg ( gin ( ikyneg , ikxneg )) end do end do end subroutine swap_kxky_ordered_complex ! take an array with kx >= 0 and all ky (ordered like 0, ..., kymax, -kymax, ..., -dky) ! and uses reality condition to return array ! with ky >= 0 and all kx (ordered like 0, ..., kxmax, -kxmax, ..., -dkx) subroutine swap_kxky_back ( gin , gout ) implicit none complex , dimension (:, :), intent ( in ) :: gin complex , dimension (:, :), intent ( out ) :: gout integer :: ikx , ikxneg integer :: iky , ikyneg ! first set arrays equal for ky >= 0 and kx >= 0 gout (:, : ikx_max ) = gin (: naky , :) ! next fill in kx < 0, ky >= 0 elements of array using reality do ikx = ikx_max + 1 , nakx ikxneg = nakx - ikx + 2 iky = 1 ikyneg = iky gout ( iky , ikx ) = conjg ( gin ( ikyneg , ikxneg )) do iky = 2 , naky ikyneg = naky_all - iky + 2 gout ( iky , ikx ) = conjg ( gin ( ikyneg , ikxneg )) end do end do end subroutine swap_kxky_back ! take an array with kx >= 0 and all ky (ordered like -kymax, ..., 0, ..., kymax) ! and uses reality condition to return array ! with ky >= 0 and all kx (ordered like 0, ..., kxmax, -kxmax, ..., -dkx) subroutine swap_kxky_back_ordered ( gin , gout ) implicit none complex , dimension (:, :), intent ( in ) :: gin complex , dimension (:, :), intent ( out ) :: gout integer :: ikx , ikxneg integer :: iky , ikyneg ! first set arrays equal for ky >= 0 and kx >= 0 gout (:, : ikx_max ) = gin ( naky :, :) ! next fill in kx < 0, ky >= 0 elements of array using reality do ikx = ikx_max + 1 , nakx ikxneg = nakx - ikx + 2 do iky = 1 , naky ikyneg = naky - iky + 1 gout ( iky , ikx ) = conjg ( gin ( ikyneg , ikxneg )) end do end do end subroutine swap_kxky_back_ordered subroutine communicate_ktgrids_multibox use job_manage , only : njobs use mp , only : job , scope , & crossdomprocs , subprocs , & send , receive implicit none call scope ( crossdomprocs ) if ( job == 1 ) then call send ( phase_shift_angle , 0 , 120 ) call send ( phase_shift_angle , njobs - 1 , 130 ) elseif ( job == 0 ) then call receive ( phase_shift_angle , 1 , 120 ) elseif ( job == njobs - 1 ) then call receive ( phase_shift_angle , 1 , 130 ) end if call scope ( subprocs ) end subroutine communicate_ktgrids_multibox subroutine finish_kt_grids implicit none if ( allocated ( aky )) deallocate ( aky ) if ( allocated ( aky_all )) deallocate ( aky_all ) if ( allocated ( aky_all_ordered )) deallocate ( aky_all_ordered ) if ( allocated ( akx )) deallocate ( akx ) if ( allocated ( theta0 )) deallocate ( theta0 ) if ( allocated ( zed0 )) deallocate ( zed0 ) if ( allocated ( x )) deallocate ( x ) if ( allocated ( y )) deallocate ( y ) if ( allocated ( x_d )) deallocate ( x_d ) if ( allocated ( rho )) deallocate ( rho ) if ( allocated ( rho_d )) deallocate ( rho_d ) if ( allocated ( rho_clamped )) deallocate ( rho_clamped ) if ( allocated ( rho_d_clamped )) deallocate ( rho_d_clamped ) if ( allocated ( g0x )) deallocate ( g0x ) reality = . false . read_kt_grids_initialized = . false . init_kt_grids_initialized = . false . end subroutine finish_kt_grids subroutine multiply_by_rho ( gin ) use stella_transforms , only : transform_kx2x_unpadded , transform_x2kx_unpadded !   use stella_transforms, only: transform_kx2x_xfirst, transform_x2kx_xfirst implicit none complex , dimension (:, :), intent ( inout ) :: gin if (. not . allocated ( g0x )) allocate ( g0x ( naky , nakx )) call transform_kx2x_unpadded ( gin , g0x ) g0x = spread ( rho_d_clamped , 1 , naky ) * g0x if ( zonal_mode ( 1 )) g0x ( 1 , :) = real ( g0x ( 1 , :)) call transform_x2kx_unpadded ( g0x , gin ) !   if(.not.allocated(g0x)) allocate(g0x(naky,nx)) !   call transform_kx2x_xfirst(gin,g0x) !   g0x = spread(rho_clamped,1,naky)*g0x !   if(zonal_mode(1)) g0x(1,:) = real(g0x(1,:)) !   call transform_x2kx_xfirst(g0x,gin) end subroutine multiply_by_rho end module kt_grids","tags":"","loc":"sourcefile/kt_grids.f90.html"},{"title":"time_advance.f90 – stella","text":"Source Code module time_advance public :: init_time_advance , finish_time_advance public :: advance_stella public :: time_gke , time_parallel_nl public :: checksum private interface get_dgdy module procedure get_dgdy_2d module procedure get_dgdy_3d module procedure get_dgdy_4d end interface interface get_dgdx module procedure get_dgdx_2d module procedure get_dgdx_3d module procedure get_dgdx_4d end interface interface checksum module procedure checksum_field module procedure checksum_dist end interface logical :: time_advance_initialized = . false . logical :: wdriftinit = . false . logical :: wstarinit = . false . logical :: parnlinit = . false . logical :: readinit = . false . logical :: radialinit = . false . logical :: driftimpinit = . false . ! if .true., dist fn is represented on alpha grid ! if .false., dist fn is given on k-alpha grid ! default is .false.; will only ever be set to ! .true. during full_flux_surface simulations !  logical :: alpha_space = .false. integer :: explicit_option_switch integer , parameter :: explicit_option_rk3 = 1 , & explicit_option_rk2 = 2 , & explicit_option_rk4 = 3 , & explicit_option_euler = 4 real :: xdriftknob , ydriftknob , wstarknob logical :: flip_flop ! factor multiplying parallel nonlinearity real , dimension (:, :), allocatable :: par_nl_fac , d_par_nl_fac_dr ! factor multiplying higher order linear term in parallel acceleration real , dimension (:, :), allocatable :: par_nl_curv , d_par_nl_curv_dr real , dimension (:), allocatable :: par_nl_driftx , par_nl_drifty real , dimension (:), allocatable :: d_par_nl_driftx_dr , d_par_nl_drifty_dr ! needed for timing various pieces of gke solve real , dimension ( 2 , 10 ) :: time_gke = 0. real , dimension ( 2 , 2 ) :: time_parallel_nl = 0. logical :: debug = . false . contains subroutine init_time_advance use mp , only : proc0 use physics_flags , only : radial_variation use physics_flags , only : include_parallel_nonlinearity use neoclassical_terms , only : init_neoclassical_terms use dissipation , only : init_collisions , include_collisions use parallel_streaming , only : init_parallel_streaming use mirror_terms , only : init_mirror use flow_shear , only : init_flow_shear use sources , only : init_quasineutrality_source , init_source_timeaverage implicit none if ( time_advance_initialized ) return time_advance_initialized = . true . debug = debug . and . proc0 !> read time_advance_knobs namelist from the input file; !> sets the explicit time advance option, as well as allows for scaling of !> the x and y components of the magnetic drifts and of the drive term if ( debug ) write ( 6 , * ) 'time_advance::init_time_advance::read_parameters' call read_parameters !> allocate distribution function sized arrays needed, e.g., for Runge-Kutta time advance if ( debug ) write ( 6 , * ) 'time_advance::init_time_advance::allocate_arrays' call allocate_arrays !> set up neoclassical corrections to the equilibrium Maxwellian; !> only calculated/needed when simulating higher order terms in rhostar for intrinsic rotation if ( debug ) write ( 6 , * ) 'time_advance::init_time_advance::init_neoclassical_terms' call init_neoclassical_terms !> calculate the term multiplying dg/dvpa in the mirror term !> and set up either the semi-Lagrange machinery or the tridiagonal matrix to be inverted !> if solving implicitly if ( debug ) write ( 6 , * ) 'time_advance::init_time_advance::init_mirror' call init_mirror !> calculate the term multiplying dg/dz in the parallel streaming term !> and set up the tridiagonal matrix to be inverted if solving implicitly if ( debug ) write ( 6 , * ) 'time_advance::init_time_advance::init_parstream' call init_parallel_streaming !> allocate and calculate the factors multiplying dg/dx, dg/dy, dphi/dx and dphi/dy !> in the magnetic drift terms if ( debug ) write ( 6 , * ) 'time_advance::init_time_advance::init_wdrift' call init_wdrift !> allocate and calculate the factor multiplying dphi/dy in the gradient drive term if ( debug ) write ( 6 , * ) 'time_advance::init_time_advance::init_wstar' call init_wstar if ( debug ) write ( 6 , * ) 'time_advance::init_time_advance::init_flow_shear' call init_flow_shear if ( debug ) write ( 6 , * ) 'time_advance::init_time_advance::init_parallel_nonlinearity' if ( include_parallel_nonlinearity ) call init_parallel_nonlinearity if ( debug ) write ( 6 , * ) 'time_advance::init_time_advance::init_radial_variation' if ( radial_variation ) call init_radial_variation if ( include_collisions ) then if ( debug ) write ( 6 , * ) 'time_advance::init_time_advance::init_collisions' call init_collisions end if if ( debug ) write ( 6 , * ) 'time_advance::init_time_advance::init_cfl' call init_cfl if ( debug ) write ( 6 , * ) 'time_advance::init_time_advance::init_source_timeaverage' call init_source_timeaverage if ( debug ) write ( 6 , * ) 'time_advance::init_time_advance::init_quasineutrality_source' call init_quasineutrality_source end subroutine init_time_advance subroutine read_parameters use file_utils , only : error_unit , input_unit_exist use text_options , only : text_option , get_option_value use mp , only : proc0 , broadcast use run_parameters , only : fully_explicit implicit none logical :: taexist type ( text_option ), dimension ( 5 ), parameter :: explicitopts = & ( / text_option ( 'default' , explicit_option_rk3 ), & text_option ( 'rk3' , explicit_option_rk3 ), & text_option ( 'rk2' , explicit_option_rk2 ), & text_option ( 'rk4' , explicit_option_rk4 ), & text_option ( 'euler' , explicit_option_euler ) / ) character ( 10 ) :: explicit_option namelist / time_advance_knobs / xdriftknob , ydriftknob , wstarknob , explicit_option , flip_flop integer :: ierr , in_file if ( readinit ) return readinit = . true . if ( proc0 ) then explicit_option = 'default' xdriftknob = 1.0 ydriftknob = 1.0 wstarknob = 1.0 flip_flop = . false . in_file = input_unit_exist ( \"time_advance_knobs\" , taexist ) if ( taexist ) read ( unit = in_file , nml = time_advance_knobs ) ierr = error_unit () call get_option_value & ( explicit_option , explicitopts , explicit_option_switch , & ierr , \"explicit_option in time_advance_knobs\" ) end if call broadcast ( explicit_option_switch ) call broadcast ( xdriftknob ) call broadcast ( ydriftknob ) call broadcast ( wstarknob ) call broadcast ( flip_flop ) if ( fully_explicit ) flip_flop = . false . end subroutine read_parameters subroutine init_wdrift use mp , only : mp_abort use dist_fn_arrays , only : wdriftx_g , wdrifty_g use dist_fn_arrays , only : wdriftx_phi , wdrifty_phi use dist_fn_arrays , only : wdriftx_bpar , wdrifty_bpar use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx , imu_idx , is_idx use stella_time , only : code_dt use species , only : spec use zgrid , only : nzgrid use kt_grids , only : nalpha use stella_geometry , only : cvdrift , gbdrift use stella_geometry , only : cvdrift0 , gbdrift0 use stella_geometry , only : gds23 , gds24 use stella_geometry , only : geo_surf , q_as_x use stella_geometry , only : dxdXcoord , drhodpsi , dydalpha use vpamu_grids , only : vpa , vperp2 , mu use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use neoclassical_terms , only : include_neoclassical_terms use neoclassical_terms , only : dphineo_dzed , dphineo_drho , dphineo_dalpha use neoclassical_terms , only : dfneo_dvpa , dfneo_dzed , dfneo_dalpha use run_parameters , only : maxwellian_normalization implicit none integer :: ivmu , iv , imu , is real :: fac real , dimension (:, :), allocatable :: wcvdrifty , wgbdrifty real , dimension (:, :), allocatable :: wcvdriftx , wgbdriftx if ( wdriftinit ) return wdriftinit = . true . !> allocate wdriftx_phi, the factor multiplying dphi/dx in the magnetic drift term if (. not . allocated ( wdriftx_phi )) then allocate ( wdriftx_phi ( nalpha , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) wdriftx_phi = 0.0 end if !> allocate wdrifty_phi, the factor multiplying dphi/dy in the magnetic drift term if (. not . allocated ( wdrifty_phi )) then allocate ( wdrifty_phi ( nalpha , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) wdrifty_phi = 0.0 end if !> allocate wdriftx_bpar, the factor multiplying dbpar/dx in the magnetic drift term if (. not . allocated ( wdriftx_bpar )) then allocate ( wdriftx_bpar ( nalpha , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) wdriftx_bpar = 0.0 end if !> allocate wdrifty_bpar, the factor multiplying dbpar/dy in the magnetic drift term if (. not . allocated ( wdrifty_bpar )) then allocate ( wdrifty_bpar ( nalpha , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) wdrifty_bpar = 0.0 end if !> allocate wdriftx_g, the factor multiplying dg/dx in the magnetic drift term if (. not . allocated ( wdriftx_g )) then allocate ( wdriftx_g ( nalpha , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) wdriftx_g = 0.0 end if !> allocate wdrifty_g, the factor multiplying dg/dy in the magnetic drift term if (. not . allocated ( wdrifty_g )) then allocate ( wdrifty_g ( nalpha , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) wdrifty_g = 0.0 end if allocate ( wcvdrifty ( nalpha , - nzgrid : nzgrid )) allocate ( wgbdrifty ( nalpha , - nzgrid : nzgrid )) allocate ( wcvdriftx ( nalpha , - nzgrid : nzgrid )) allocate ( wgbdriftx ( nalpha , - nzgrid : nzgrid )) ! FLAG -- need to deal with shat=0 case.  ideally move away from q as x-coordinate do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) fac = - ydriftknob * 0.5 * code_dt * spec ( is )% tz_psi0 !> this is the curvature drift piece of wdrifty with missing factor of vpa !> vpa factor is missing to avoid singularity when including !> non-Maxwellian corrections to equilibrium wcvdrifty = fac * cvdrift * vpa ( iv ) !> this is the grad-B drift piece of wdrifty wgbdrifty = fac * gbdrift * 0.5 * vperp2 (:, :, imu ) wdrifty_g (:, :, ivmu ) = wcvdrifty * vpa ( iv ) + wgbdrifty !> if including neoclassical correction to equilibrium Maxwellian, !> then add in v_E&#94;{nc} . grad y dg/dy coefficient here if ( include_neoclassical_terms ) then wdrifty_g (:, :, ivmu ) = wdrifty_g (:, :, ivmu ) + code_dt * 0.5 * ( gds23 * dphineo_dzed & + drhodpsi * dydalpha * dphineo_drho ) end if wdrifty_phi (:, :, ivmu ) = spec ( is )% zt * ( wgbdrifty + wcvdrifty * vpa ( iv )) !> if maxwwellian_normalization = .true., evolved distribution function is normalised by a Maxwellian !> otherwise, it is not; a Maxwellian weighting factor must thus be included if (. not . maxwellian_normalization ) then wdrifty_phi (:, :, ivmu ) = wdrifty_phi (:, :, ivmu ) * maxwell_vpa ( iv , is ) * maxwell_mu (:, :, imu , is ) * maxwell_fac ( is ) end if !> assign wdrifty_bpar, neoclassical terms not supported wdrifty_bpar (:,:, ivmu ) = 4.0 * mu ( imu ) * wdrifty_phi (:, :, ivmu ) * spec ( is )% tz !> if including neoclassical corrections to equilibrium, !> add in -(Ze/m) * v_curv/vpa . grad y d<phi>/dy * dF&#94;{nc}/dvpa term !> and v_E . grad z dF&#94;{nc}/dz (here get the dphi/dy part of v_E) if ( include_neoclassical_terms ) then !> NB: the below neoclassical correction needs to be divided by an equilibrium Maxwellian !> if maxwellian_normalization = .true. if ( maxwellian_normalization ) then call mp_abort ( \"include_neoclassical_terms=T not currently supported for maxwellian_normalization=T.  aborting\" ) end if wdrifty_phi (:, :, ivmu ) = wdrifty_phi (:, :, ivmu ) & - 0.5 * spec ( is )% zt * dfneo_dvpa (:, :, ivmu ) * wcvdrifty & - code_dt * 0.5 * dfneo_dzed (:, :, ivmu ) * gds23 end if if ( q_as_x ) then fac = - xdriftknob * 0.5 * code_dt * spec ( is )% tz_psi0 else fac = - xdriftknob * 0.5 * code_dt * spec ( is )% tz_psi0 / geo_surf % shat end if !> this is the curvature drift piece of wdriftx with missing factor of vpa !> vpa factor is missing to avoid singularity when including !> non-Maxwellian corrections to equilibrium wcvdriftx = fac * cvdrift0 * vpa ( iv ) !> this is the grad-B drift piece of wdriftx wgbdriftx = fac * gbdrift0 * 0.5 * vperp2 (:, :, imu ) wdriftx_g (:, :, ivmu ) = wcvdriftx * vpa ( iv ) + wgbdriftx !> if including neoclassical correction to equilibrium Maxwellian, !> then add in v_E&#94;{nc} . grad x dg/dx coefficient here if ( include_neoclassical_terms ) then wdriftx_g (:, :, ivmu ) = wdriftx_g (:, :, ivmu ) + code_dt * 0.5 * ( gds24 * dphineo_dzed & - dxdXcoord * dphineo_dalpha ) end if wdriftx_phi (:, :, ivmu ) = spec ( is )% zt * ( wgbdriftx + wcvdriftx * vpa ( iv )) !> if maxwellian_normalizatiion = .true., evolved distribution function is normalised by a Maxwellian !> otherwise, it is not; a Maxwellian weighting factor must thus be included if (. not . maxwellian_normalization ) then wdriftx_phi (:, :, ivmu ) = wdriftx_phi (:, :, ivmu ) * maxwell_vpa ( iv , is ) * maxwell_mu (:, :, imu , is ) * maxwell_fac ( is ) end if !> assign wdriftx_bpar, neoclassical terms not supported wdriftx_bpar (:,:, ivmu ) = 4.0 * mu ( imu ) * wdriftx_phi (:, :, ivmu ) * spec ( is )% tz !> if including neoclassical corrections to equilibrium, !> add in (Ze/m) * v_curv/vpa . grad x d<phi>/dx * dF&#94;{nc}/dvpa term !> and v_E . grad z dF&#94;{nc}/dz (here get the dphi/dx part of v_E) !> and v_E . grad alpha dF&#94;{nc}/dalpha (dphi/dx part of v_E) if ( include_neoclassical_terms ) then !> NB: the below neoclassical correction needs to be divided by an equilibrium Maxwellian !> if running with maxwellian_normalzation = .true. if ( maxwellian_normalization ) then call mp_abort ( \"include_neoclassical_terms=T not currently supported for maxwellian_normalization=T.  aborting\" ) end if wdriftx_phi (:, :, ivmu ) = wdriftx_phi (:, :, ivmu ) & - 0.5 * spec ( is )% zt * dfneo_dvpa (:, :, ivmu ) * wcvdriftx & + code_dt * 0.5 * ( dfneo_dalpha (:, :, ivmu ) * dxdXcoord - dfneo_dzed (:, :, ivmu ) * gds24 ) end if end do deallocate ( wcvdriftx , wgbdriftx , wcvdrifty , wgbdrifty ) end subroutine init_wdrift subroutine init_wstar use mp , only : mp_abort use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx , imu_idx , is_idx use stella_time , only : code_dt use species , only : spec use zgrid , only : nzgrid use kt_grids , only : nalpha use stella_geometry , only : dydalpha , drhodpsi , sign_torflux use vpamu_grids , only : vperp2 , vpa use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use dist_fn_arrays , only : wstar use neoclassical_terms , only : include_neoclassical_terms use neoclassical_terms , only : dfneo_drho use run_parameters , only : maxwellian_normalization implicit none integer :: is , imu , iv , ivmu real , dimension (:, :), allocatable :: energy if ( wstarinit ) return wstarinit = . true . if (. not . allocated ( wstar )) & allocate ( wstar ( nalpha , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )); wstar = 0.0 allocate ( energy ( nalpha , - nzgrid : nzgrid )) do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) iv = iv_idx ( vmu_lo , ivmu ) energy = ( vpa ( iv ) ** 2 + vperp2 (:, :, imu )) * ( spec ( is )% temp_psi0 / spec ( is )% temp ) if ( include_neoclassical_terms ) then if ( maxwellian_normalization ) then call mp_abort ( \"include_neoclassical_terms = T not yet supported for maxwellian_normalization = T. Aborting.\" ) else wstar (:, :, ivmu ) = - sign_torflux * dydalpha * drhodpsi * wstarknob * 0.5 * code_dt & * ( maxwell_vpa ( iv , is ) * maxwell_mu (:, :, imu , is ) * maxwell_fac ( is ) & * ( spec ( is )% fprim + spec ( is )% tprim * ( energy - 1.5 )) & - dfneo_drho (:, :, ivmu )) end if else wstar (:, :, ivmu ) = - sign_torflux * dydalpha * drhodpsi * wstarknob * 0.5 * code_dt & * ( spec ( is )% fprim + spec ( is )% tprim * ( energy - 1.5 )) end if if (. not . maxwellian_normalization ) then wstar (:, :, ivmu ) = wstar (:, :, ivmu ) * maxwell_vpa ( iv , is ) * maxwell_mu (:, :, imu , is ) * maxwell_fac ( is ) end if end do deallocate ( energy ) end subroutine init_wstar subroutine init_parallel_nonlinearity use physics_parameters , only : rhostar use species , only : spec , nspec use zgrid , only : nztot , nzgrid use stella_geometry , only : geo_surf , drhodpsi , q_as_x use stella_geometry , only : gradpar , dbdzed , bmag use stella_geometry , only : cvdrift , cvdrift0 use stella_geometry , only : dIdrho , dgradpardrho , dBdrho , d2Bdrdth use stella_geometry , only : dcvdriftdrho , dcvdrift0drho use physics_flags , only : radial_variation implicit none if (. not . allocated ( par_nl_fac )) allocate ( par_nl_fac ( - nzgrid : nzgrid , nspec )) ! this is the factor multiplying -dphi/dz * dg/dvpa in the parallel nonlinearity par_nl_fac = 0.5 * rhostar * spread ( spec % stm_psi0 * spec % zt_psi0 , 1 , nztot ) * spread ( gradpar , 2 , nspec ) if (. not . allocated ( par_nl_curv )) allocate ( par_nl_curv ( - nzgrid : nzgrid , nspec )) ! ydriftknob is here because this term comes from bhat x curvature . grad B par_nl_curv = - ydriftknob * rhostar * geo_surf % rgeo * geo_surf % betaprim * drhodpsi & * spread ( dbdzed ( 1 , :) * gradpar / bmag ( 1 , :), 2 , nspec ) / spread ( spec % zt_psi0 , 1 , nztot ) if (. not . allocated ( par_nl_drifty )) allocate ( par_nl_drifty ( - nzgrid : nzgrid )) par_nl_drifty = 0.25 * rhostar * cvdrift ( 1 , :) if (. not . allocated ( par_nl_driftx )) allocate ( par_nl_driftx ( - nzgrid : nzgrid )) if ( q_as_x ) then par_nl_driftx = 0.25 * rhostar * cvdrift0 ( 1 , :) else par_nl_driftx = 0.25 * rhostar * cvdrift0 ( 1 , :) / geo_surf % shat end if if ( radial_variation ) then if (. not . allocated ( d_par_nl_fac_dr )) allocate ( d_par_nl_fac_dr ( - nzgrid : nzgrid , nspec )) ! this is the factor multiplying -dphi/dz * dg/dvpa in the parallel nonlinearity d_par_nl_fac_dr = 0.5 * rhostar * spread ( spec % stm_psi0 * spec % zt_psi0 , 1 , nztot ) * spread ( dgradpardrho , 2 , nspec ) if (. not . allocated ( d_par_nl_curv_dr )) allocate ( d_par_nl_curv_dr ( - nzgrid : nzgrid , nspec )) ! ydriftknob is here because this term comes from bhat x curvature . grad B ! handle terms with no zeroes d_par_nl_curv_dr = par_nl_curv * ( dIdrho / geo_surf % rgeo - drhodpsi * geo_surf % d2psidr2 & - spread ( dBdrho / bmag ( 1 , :) + dgradpardrho / gradpar , 2 , nspec )) ! handle terms with possible zeroes d_par_nl_curv_dr = d_par_nl_curv_dr & - (( ydriftknob * rhostar * geo_surf % rgeo * drhodpsi * spread ( gradpar / bmag ( 1 , :), 2 , nspec )) & / spread ( spec % zt_psi0 , 1 , nztot )) & * ( geo_surf % betadbprim * spread ( dbdzed ( 1 , :), 2 , nspec ) & + geo_surf % betaprim * spread ( d2Bdrdth , 2 , nspec )) if (. not . allocated ( d_par_nl_drifty_dr )) allocate ( d_par_nl_drifty_dr ( - nzgrid : nzgrid )) d_par_nl_drifty_dr = 0.25 * rhostar * dcvdriftdrho ( 1 , :) if (. not . allocated ( d_par_nl_drifty_dr )) allocate ( d_par_nl_driftx_dr ( - nzgrid : nzgrid )) if ( q_as_x ) then d_par_nl_driftx_dr = 0.25 * rhostar * dcvdrift0drho ( 1 , :) else d_par_nl_driftx_dr = 0.25 * rhostar * dcvdrift0drho ( 1 , :) / geo_surf % shat end if end if parnlinit = . true . end subroutine init_parallel_nonlinearity subroutine init_radial_variation use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx , imu_idx , is_idx use stella_time , only : code_dt use species , only : spec , pfac use zgrid , only : nzgrid use kt_grids , only : nalpha use stella_geometry , only : drhodpsi , dydalpha , gfac use stella_geometry , only : dBdrho , geo_surf , q_as_x use stella_geometry , only : dcvdriftdrho , dcvdrift0drho use stella_geometry , only : dgbdriftdrho , dgbdrift0drho use vpamu_grids , only : vperp2 , vpa , mu use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use dist_fn_arrays , only : wstarp use dist_fn_arrays , only : wdriftx_phi , wdrifty_phi use dist_fn_arrays , only : wdriftpx_g , wdriftpy_g use dist_fn_arrays , only : wdriftpx_phi , wdriftpy_phi !, adiabatic_phi !   use neoclassical_terms, only: include_neoclassical_terms implicit none integer :: is , imu , iv , ivmu real :: fac real , dimension (:, :), allocatable :: energy real , dimension (:, :), allocatable :: wcvdrifty , wgbdrifty real , dimension (:, :), allocatable :: wcvdriftx , wgbdriftx !wstar if ( radialinit ) return radialinit = . true . allocate ( wcvdrifty ( nalpha , - nzgrid : nzgrid )) allocate ( wgbdrifty ( nalpha , - nzgrid : nzgrid )) allocate ( wcvdriftx ( nalpha , - nzgrid : nzgrid )) allocate ( wgbdriftx ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( wstarp )) & allocate ( wstarp ( nalpha , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )); wstarp = 0.0 if (. not . allocated ( wdriftpx_phi )) & allocate ( wdriftpx_phi ( nalpha , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) !   if (.not.allocated(adiabatic_phi)) & !      allocate (adiabatic_phi(nalpha,-nzgrid:nzgrid,vmu_lo%llim_proc:vmu_lo%ulim_alloc)) if (. not . allocated ( wdriftpy_phi )) & allocate ( wdriftpy_phi ( nalpha , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) if (. not . allocated ( wdriftpx_g )) & allocate ( wdriftpx_g ( nalpha , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) if (. not . allocated ( wdriftpy_g )) & allocate ( wdriftpy_g ( nalpha , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) allocate ( energy ( nalpha , - nzgrid : nzgrid )) do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) iv = iv_idx ( vmu_lo , ivmu ) energy = ( vpa ( iv ) ** 2 + vperp2 (:, :, imu )) * ( spec ( is )% temp_psi0 / spec ( is )% temp ) !FLAG DSO - THIS NEEDS TO BE ADDED SOMEDAY! !if (include_neoclassical_terms) then !   wstarp(:,:,ivmu) = dydalpha*drhodpsi*wstarknob*0.5*code_dt & !        * (maxwell_vpa(iv)*maxwell_mu(:,:,imu) & !        * (spec(is)%fprim+spec(is)%tprim*(energy-1.5)) & !        - dfneo_drho(:,:,ivmu)) !else !recall that fprim = -dn/dr and trpim = -dt/dr wstarp (:, :, ivmu ) = - wstarknob * 0.5 * code_dt & * dydalpha * drhodpsi * maxwell_vpa ( iv , is ) * maxwell_mu (:, :, imu , is ) * maxwell_fac ( is ) & * ( pfac * ( spec ( is )% d2ndr2 - ( spec ( is )% fprim ) ** 2 - ( spec ( is )% tprim ) ** 2 * energy ) & + pfac * ( spec ( is )% d2Tdr2 - ( spec ( is )% tprim ) ** 2 ) * ( energy - 1.5 ) & - gfac * 2 * spec ( is )% tprim * mu ( imu ) * spread ( dBdrho , 1 , nalpha ) & + ( spec ( is )% fprim + spec ( is )% tprim * ( energy - 1.5 )) & * ( pfac * ( spec ( is )% fprim + spec ( is )% tprim * ( energy - 1.5 )) & + gfac * 2 * mu ( imu ) * spread ( dBdrho , 1 , nalpha ) & + gfac * drhodpsi * geo_surf % d2psidr2 )) !end if !wdrift fac = - ydriftknob * 0.5 * code_dt * spec ( is )% tz_psi0 ! this is the curvature drift piece of wdrifty with missing factor of vpa ! vpa factor is missing to avoid singularity when including ! non-Maxwellian corrections to equilibrium wcvdrifty = gfac * fac * dcvdriftdrho * vpa ( iv ) ! this is the grad-B drift piece of wdrifty wgbdrifty = gfac * fac * dgbdriftdrho * 0.5 * vperp2 (:, :, imu ) wdriftpy_g (:, :, ivmu ) = wcvdrifty * vpa ( iv ) + wgbdrifty wdriftpy_phi (:, :, ivmu ) = spec ( is )% zt * ( wgbdrifty + wcvdrifty * vpa ( iv )) & * maxwell_vpa ( iv , is ) * maxwell_mu (:, :, imu , is ) * maxwell_fac ( is ) & - wdrifty_phi (:, :, ivmu ) * ( pfac * ( spec ( is )% fprim + spec ( is )% tprim * ( energy - 2.5 )) & + gfac * 2. * mu ( imu ) * spread ( dBdrho , 1 , nalpha )) if ( q_as_x ) then fac = - xdriftknob * 0.5 * code_dt * spec ( is )% tz_psi0 else fac = - xdriftknob * 0.5 * code_dt * spec ( is )% tz_psi0 / geo_surf % shat end if ! this is the curvature drift piece of wdriftx with missing factor of vpa ! vpa factor is missing to avoid singularity when including ! non-Maxwellian corrections to equilibrium wcvdriftx = gfac * fac * dcvdrift0drho * vpa ( iv ) ! this is the grad-B drift piece of wdriftx wgbdriftx = gfac * fac * dgbdrift0drho * 0.5 * vperp2 (:, :, imu ) wdriftpx_g (:, :, ivmu ) = wgbdriftx + wcvdriftx * vpa ( iv ) wdriftpx_phi (:, :, ivmu ) = spec ( is )% zt * ( wgbdriftx + wcvdriftx * vpa ( iv )) & * maxwell_vpa ( iv , is ) * maxwell_mu (:, :, imu , is ) * maxwell_fac ( is ) & - wdriftx_phi (:, :, ivmu ) * ( pfac * ( spec ( is )% fprim + spec ( is )% tprim * ( energy - 2.5 )) & + gfac * 2. * mu ( imu ) * spread ( dBdrho , 1 , nalpha )) !      !the next piece is everything under the x derivative, as this needs to be !      !transformed separately !      wdriftpx_phi(:,:,ivmu) = spec(is)%zt*(wgbdriftx + wcvdriftx*vpa(iv))  & !           * maxwell_vpa(iv,is)*maxwell_mu(:,:,imu,is)*maxwell_fac(is) !      !this is variation in the Maxwellian part of the adiabatic response of phi, !      !which needs to be transformed separately before differentiation wrt x !      !the gyroaveraging and quasineutrality is already done in fields !      adiabatic_phi(:,:,ivmu) = -(pfac*(spec(is)%fprim+spec(is)%tprim*(energy-2.5)) & !                                 +gfac*2.*mu(imu)*spread(dBdrho,1,nalpha)) end do deallocate ( energy , wcvdriftx , wgbdriftx , wcvdrifty , wgbdrifty ) end subroutine init_radial_variation subroutine allocate_arrays use stella_layouts , only : vmu_lo use zgrid , only : nzgrid , ntubes use kt_grids , only : naky , nakx use dist_fn_arrays , only : g0 , g1 , g2 , g3 implicit none if (. not . allocated ( g0 )) & allocate ( g0 ( naky , nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) g0 = 0. if (. not . allocated ( g1 )) & allocate ( g1 ( naky , nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) g1 = 0. if (. not . allocated ( g2 )) & allocate ( g2 ( naky , nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) g2 = 0. if (. not . allocated ( g3 ) . and . explicit_option_switch == explicit_option_rk4 ) then allocate ( g3 ( naky , nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) g3 = 0. else allocate ( g3 ( 1 , 1 , 1 , 1 , 1 )) end if end subroutine allocate_arrays subroutine init_cfl use mp , only : proc0 , nproc , max_allreduce , min_allreduce use mp , only : scope , allprocs , subprocs use dist_fn_arrays , only : wdriftx_g , wdrifty_g use stella_time , only : code_dt , write_dt , cfl_dt_linear use run_parameters , only : cfl_cushion_upper , cfl_cushion_middle , cfl_cushion_lower use physics_flags , only : radial_variation , prp_shear_enabled use zgrid , only : delzed use vpamu_grids , only : dvpa use kt_grids , only : akx , aky , nx , rho use run_parameters , only : stream_implicit , mirror_implicit , drifts_implicit use parallel_streaming , only : stream use parallel_streaming , only : stream_rad_var1 , stream_rad_var2 use mirror_terms , only : mirror use flow_shear , only : prl_shear , shift_times use file_utils , only : runtype_option_switch , runtype_multibox use dissipation , only : include_collisions , collisions_implicit use dissipation , only : cfl_dt_vpadiff , cfl_dt_mudiff implicit none real :: cfl_dt_mirror , cfl_dt_stream , cfl_dt_shear real :: cfl_dt_wdriftx , cfl_dt_wdrifty real :: zero real :: wdriftx_max , wdrifty_max ! avoid divide by zero in cfl_dt terms below zero = 10 0. * epsilon ( 0. ) ! FLAG -- assuming equal spacing in zed! if ( cfl_dt_linear < 0 ) cfl_dt_linear = code_dt / cfl_cushion_upper if (. not . drifts_implicit ) then ! get the local max value of wdriftx on each processor wdriftx_max = maxval ( abs ( wdriftx_g )) ! compare these max values across processors to get global max if ( nproc > 1 ) then call max_allreduce ( wdriftx_max ) end if ! NB: wdriftx_g has code_dt built-in, which accounts for code_dt factor here cfl_dt_wdriftx = abs ( code_dt ) / max ( maxval ( abs ( akx )) * wdriftx_max , zero ) cfl_dt_linear = cfl_dt_wdriftx end if cfl_dt_shear = abs ( code_dt ) / max ( maxval ( abs ( aky )) * maxval ( abs ( prl_shear )), zero ) cfl_dt_linear = min ( cfl_dt_linear , cfl_dt_shear ) if ( prp_shear_enabled ) then cfl_dt_shear = minval ( shift_times ) cfl_dt_linear = min ( cfl_dt_linear , cfl_dt_shear ) end if if (. not . stream_implicit ) then ! NB: stream has code_dt built-in, which accounts for code_dt factor here cfl_dt_stream = abs ( code_dt ) * delzed ( 0 ) / max ( maxval ( abs ( stream )), zero ) cfl_dt_linear = min ( cfl_dt_linear , cfl_dt_stream ) end if if (. not . mirror_implicit ) then ! NB: mirror has code_dt built-in, which accounts for code_dt factor here cfl_dt_mirror = abs ( code_dt ) * dvpa / max ( maxval ( abs ( mirror )), zero ) cfl_dt_linear = min ( cfl_dt_linear , cfl_dt_mirror ) end if if ( radial_variation ) then !while other quantities should go here, parallel streaming with electrons !is what will limit us cfl_dt_stream = abs ( code_dt ) * delzed ( 0 ) / max ( maxval ( abs ( stream_rad_var1 )), zero ) cfl_dt_stream = cfl_dt_stream / abs ( rho ( nx ) + zero ) cfl_dt_linear = min ( cfl_dt_linear , cfl_dt_stream ) cfl_dt_stream = abs ( code_dt ) * delzed ( 0 ) / max ( maxval ( abs ( stream_rad_var2 )), zero ) cfl_dt_stream = cfl_dt_stream / abs ( rho ( nx ) + zero ) cfl_dt_linear = min ( cfl_dt_linear , cfl_dt_stream ) end if if ( include_collisions . and . . not . collisions_implicit ) then cfl_dt_linear = min ( cfl_dt_linear , cfl_dt_vpadiff ) cfl_dt_linear = min ( cfl_dt_linear , cfl_dt_mudiff ) end if if (. not . drifts_implicit ) then ! get the local max value of wdrifty on each processor wdrifty_max = maxval ( abs ( wdrifty_g )) ! compare these max values across processors to get global max if ( nproc > 1 ) then call max_allreduce ( wdrifty_max ) end if ! NB: wdrifty_g has code_dt built-in, which accounts for code_dt factor here cfl_dt_wdrifty = abs ( code_dt ) / max ( maxval ( abs ( aky )) * wdrifty_max , zero ) cfl_dt_linear = min ( cfl_dt_linear , cfl_dt_wdrifty ) end if if ( runtype_option_switch == runtype_multibox ) call scope ( allprocs ) call min_allreduce ( cfl_dt_linear ) if ( runtype_option_switch == runtype_multibox ) call scope ( subprocs ) if ( proc0 ) then write ( * , '(A)' ) \"############################################################\" write ( * , '(A)' ) \"                        CFL CONDITION\" write ( * , '(A)' ) \"############################################################\" write ( * , '(A16)' ) 'LINEAR CFL_DT: ' if (. not . drifts_implicit ) write ( * , '(A12,ES12.4)' ) '   wdriftx: ' , cfl_dt_wdriftx if (. not . drifts_implicit ) write ( * , '(A12,ES12.4)' ) '   wdrifty: ' , cfl_dt_wdrifty if (. not . stream_implicit ) write ( * , '(A12,ES12.4)' ) '   stream: ' , cfl_dt_stream if (. not . mirror_implicit ) write ( * , '(A12,ES12.4)' ) '   mirror: ' , cfl_dt_mirror write ( * , '(A12,ES12.4)' ) '   total: ' , cfl_dt_linear write ( * , * ) end if if ( abs ( code_dt ) > cfl_dt_linear * cfl_cushion_upper ) then if ( proc0 ) then write ( * , * ) 'CHANGING TIME STEP:' write ( * , '(A22, ES10.2E2)' ) \"   code_dt:\" // REPEAT ( ' ' , 50 ), code_dt write ( * , '(A22, ES10.2E2)' ) \"   cfl_dt_linear:\" // REPEAT ( ' ' , 50 ), cfl_dt_linear write ( * , '(A22, ES10.2E2)' ) \"   cfl_cushion_upper:\" // REPEAT ( ' ' , 50 ), cfl_cushion_upper write ( * , '(A22, ES10.2E2)' ) \"   cfl_cushion_middle:\" // REPEAT ( ' ' , 50 ), cfl_cushion_middle write ( * , '(A22, ES10.2E2)' ) \"   cfl_cushion_lower:\" // REPEAT ( ' ' , 50 ), cfl_cushion_lower write ( * , '(A70)' ) '     ==> User-specified delt is larger than cfl_dt*cfl_cushion_upper.' // REPEAT ( ' ' , 50 ) write ( * , '(A55,ES12.4)' ) '     ==> Changing code_dt to cfl_dt*cfl_cushion_upper =' // REPEAT ( ' ' , 50 ), cfl_dt_linear * cfl_cushion_upper write ( * , * ) end if code_dt = sign ( 1.0 , code_dt ) * cfl_dt_linear * cfl_cushion_upper call reset_dt else if ( proc0 ) then call write_dt write ( * , * ) end if end subroutine init_cfl subroutine reset_dt use parallel_streaming , only : parallel_streaming_initialized use parallel_streaming , only : init_parallel_streaming use dissipation , only : init_collisions , collisions_initialized , include_collisions use run_parameters , only : stream_implicit , driftkinetic_implicit use response_matrix , only : response_matrix_initialized use response_matrix , only : init_response_matrix use mirror_terms , only : mirror_initialized use mirror_terms , only : init_mirror use flow_shear , only : flow_shear_initialized use flow_shear , only : init_flow_shear use physics_flags , only : radial_variation use sources , only : init_source_timeaverage use sources , only : init_quasineutrality_source , qn_source_initialized implicit none ! need to recompute mirror and streaming terms ! to account for updated code_dt wdriftinit = . false . wstarinit = . false . radialinit = . false . driftimpinit = . false . flow_shear_initialized = . false . mirror_initialized = . false . parallel_streaming_initialized = . false . qn_source_initialized = . false . if ( debug ) write ( 6 , * ) 'time_advance::reset_dt::init_wstar' call init_wstar if ( debug ) write ( 6 , * ) 'time_advance::reset_dt::init_wdrift' call init_wdrift if ( debug ) write ( 6 , * ) 'time_advance::reset_dt::init_mirror' call init_mirror if ( debug ) write ( 6 , * ) 'time_advance::reset_dt::init_parallel_streaming' call init_parallel_streaming if ( debug ) write ( 6 , * ) 'time_advance::reset_dt::init_flow_shear' call init_flow_shear if ( debug ) write ( 6 , * ) 'time_advance::reset_dt::init_source_timeaverage' call init_source_timeaverage if ( debug ) write ( 6 , * ) 'time_advance::reset_dt::init_quasineutrality_source' call init_quasineutrality_source if ( radial_variation ) then if ( debug ) write ( 6 , * ) 'time_advance::reset_dt::init_radial_variation' call init_radial_variation end if if ( include_collisions ) then if ( debug ) write ( 6 , * ) 'time_advance::reset_dt::init_collisions' collisions_initialized = . false . call init_collisions end if ! do not try to re-init response matrix ! before it has been initialized the first time if (( stream_implicit . or . driftkinetic_implicit ) . and . response_matrix_initialized ) then response_matrix_initialized = . false . if ( debug ) write ( 6 , * ) 'time_advance::reset_dt::init_response_matrix' call init_response_matrix end if end subroutine reset_dt subroutine advance_stella ( istep , stop_stella ) use dist_fn_arrays , only : gold , gnew use fields_arrays , only : phi , apar , bpar use fields_arrays , only : phi_old , apar_old use fields , only : advance_fields , fields_updated use run_parameters , only : fully_explicit , fully_implicit use multibox , only : RK_step use sources , only : include_qn_source , update_quasineutrality_source use sources , only : source_option_switch , source_option_projection use sources , only : source_option_krook use sources , only : update_tcorr_krook , project_out_zero use mp , only : proc0 , broadcast implicit none integer , intent ( in ) :: istep logical , intent ( in out ) :: stop_stella logical :: restart_time_step , time_advance_successful integer :: count_restarts !> unless running in multibox mode, no need to worry about !> mb_communicate calls as the subroutine is immediately exited !> if not in multibox mode. if (. not . RK_step ) then if ( debug ) write ( * , * ) 'time_advance::multibox' call mb_communicate ( gnew ) end if !> save value of phi & apar !> for use in diagnostics (to obtain frequency) phi_old = phi apar_old = apar ! Flag which is set to true once we've taken a step without needing to ! reset dt (which can be done by the nonlinear term(s)) time_advance_successful = . false . ! If cfl_cushion_lower is chosen too close to cfl_cushion_upper, then ! we might get stuck restarting the time step over and over, so exit stella count_restarts = 1 ! Attempt the Lie or flip-flop time advance until we've done it without the ! timestep changing. do while (. not . time_advance_successful ) ! If we've already attempted a time advance then we've updated gnew, so reset it. gnew = gold ! Ensure fields are consistent with gnew. call advance_fields ( gnew , phi , apar , bpar , dist = 'g' ) ! Keep track whether any routine wants to modify the time step restart_time_step = . false . !> reverse the order of operations every time step !> as part of alternating direction operator splitting !> this is needed to ensure 2nd order accuracy in time if ( mod ( istep , 2 ) == 1 . or . . not . flip_flop ) then !> Advance the explicit parts of the GKE if ( debug ) write ( * , * ) 'time_advance::advance_explicit' if (. not . fully_implicit ) call advance_explicit ( gnew , restart_time_step , istep ) !> Use operator splitting to separately evolve all terms treated implicitly if (. not . restart_time_step . and . . not . fully_explicit ) call advance_implicit ( istep , phi , apar , bpar , gnew ) else if (. not . fully_explicit ) call advance_implicit ( istep , phi , apar , bpar , gnew ) if (. not . fully_implicit ) call advance_explicit ( gnew , restart_time_step , istep ) end if ! If the time step has not been restarted, the time advance was succesfull ! Otherwise, discard changes to gnew and start the time step again, fields ! will have to be recalculated if (. not . restart_time_step ) then time_advance_successful = . true . else count_restarts = count_restarts + 1 fields_updated = . false . end if ! At some point, give up on restarting the time step if ( count_restarts > 5 ) then stop_stella = . true . call broadcast ( stop_stella ) gnew = gold fields_updated = . false . if ( proc0 ) then write ( * , * ) write ( * , * ) 'EXITING STELLA BECAUSE WE ALREADY RESTARTED THE TIME STEP 5 TIMES.' write ( * , * ) 'CHANGE CFL_CUSHION_UPPER AND CFL_CUSHION_LOWER AND RESTART THE SIMULATION.' write ( * , * ) end if exit end if end do ! presumably this is to do with the radially global version of the code? ! perhaps it could be packaged together with thee update_delay_krook code ! below and made into a single call where all of this happens so that ! users of the flux tube version of the code need not worry about it. if ( source_option_switch == source_option_projection ) then call project_out_zero ( gold , gnew ) fields_updated = . false . end if gold = gnew !> Ensure fields are updated so that omega calculation is correct. call advance_fields ( gnew , phi , apar , bpar , dist = 'g' ) !update the delay parameters for the Krook operator if ( source_option_switch == source_option_krook ) call update_tcorr_krook ( gnew ) if ( include_qn_source ) call update_quasineutrality_source end subroutine advance_stella !> advance_explicit takes as input the guiding centre distribution function !> in k-space and updates it to account for all of the terms in the GKE that !> are advanced explicitly in time subroutine advance_explicit ( g , restart_time_step , istep ) use mp , only : proc0 use job_manage , only : time_message use zgrid , only : nzgrid use extended_zgrid , only : periodic , phase_shift use kt_grids , only : naky use stella_layouts , only : vmu_lo , iv_idx use physics_flags , only : include_apar use parallel_streaming , only : stream_sign use fields_arrays , only : phi , apar , bpar use fields , only : advance_fields use g_tofrom_h , only : gbar_to_g implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: g logical , intent ( in out ) :: restart_time_step integer , intent ( in ) :: istep integer :: ivmu , iv , sgn , iky !> start the timer for the explicit part of the solve if ( proc0 ) call time_message (. false ., time_gke (:, 8 ), ' explicit' ) ! incoming pdf is g = h - (Z F0/T) (J0 phi + 4 mu (T/Z) (J1/gamma) bpar) ! if include_apar = T, convert from g to gbar = g + Z F0/T (2J0 vpa vth apar), ! as gbar appears in time derivative if ( include_apar ) then ! if the fields are not already updated, then update them call advance_fields ( g , phi , apar , bpar , dist = 'g' ) call gbar_to_g ( g , apar , - 1.0 ) end if select case ( explicit_option_switch ) case ( explicit_option_euler ) !> forward Euler call advance_explicit_euler ( g , restart_time_step , istep ) case ( explicit_option_rk2 ) !> SSP RK2 call advance_explicit_rk2 ( g , restart_time_step , istep ) case ( explicit_option_rk3 ) !> default is SSP RK3 call advance_explicit_rk3 ( g , restart_time_step , istep ) case ( explicit_option_rk4 ) !> RK4 call advance_explicit_rk4 ( g , restart_time_step , istep ) end select if ( include_apar ) then ! if the fields are not already updated, then update them call advance_fields ( g , phi , apar , bpar , dist = 'gbar' ) ! implicit solve will use g rather than gbar for advance, ! so convert from gbar to g call gbar_to_g ( g , apar , 1.0 ) end if !> enforce periodicity for periodic (including zonal) modes do iky = 1 , naky if ( periodic ( iky )) then do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) !> stream_sign > 0 corresponds to dz/dt < 0 sgn = stream_sign ( iv ) g ( iky , :, sgn * nzgrid , :, ivmu ) = & g ( iky , :, - sgn * nzgrid , :, ivmu ) * phase_shift ( iky ) ** ( - sgn ) end do end if end do !> stop the timer for the explicit part of the solve if ( proc0 ) call time_message (. false ., time_gke (:, 8 ), ' explicit' ) end subroutine advance_explicit !> advance_explicit_euler uses forward Euler to advance one time step subroutine advance_explicit_euler ( g , restart_time_step , istep ) use dist_fn_arrays , only : g0 use zgrid , only : nzgrid use stella_layouts , only : vmu_lo use multibox , only : RK_step implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: g logical , intent ( in out ) :: restart_time_step integer , intent ( in ) :: istep !> RK_step only true if running in multibox mode if ( RK_step ) call mb_communicate ( g ) g0 = g call solve_gke ( g0 , g , restart_time_step , istep ) g = g0 + g end subroutine advance_explicit_euler !> advance_expliciit_rk2 uses strong stability-preserving RK2 to advance one time step subroutine advance_explicit_rk2 ( g , restart_time_step , istep ) use dist_fn_arrays , only : g0 , g1 use zgrid , only : nzgrid use stella_layouts , only : vmu_lo use multibox , only : RK_step implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: g logical , intent ( in out ) :: restart_time_step integer , intent ( in ) :: istep integer :: icnt !> RK_step only true if running in multibox mode if ( RK_step ) call mb_communicate ( g ) g0 = g icnt = 1 !> SSP rk2 algorithm to advance explicit part of code !> if GK equation written as dg/dt = rhs - vpar . grad h, !> solve_gke returns rhs*dt do while ( icnt <= 2 ) select case ( icnt ) case ( 1 ) call solve_gke ( g0 , g1 , restart_time_step , istep ) case ( 2 ) g1 = g0 + g1 if ( RK_step ) call mb_communicate ( g1 ) call solve_gke ( g1 , g , restart_time_step , istep ) end select if ( restart_time_step ) then ! If the code_dt is reset, we need to quit this loop and restart the timestep again icnt = 10 else icnt = icnt + 1 end if end do !> this is g at intermediate time level g = 0.5 * g0 + 0.5 * ( g1 + g ) end subroutine advance_explicit_rk2 !> strong stability-preserving RK3 subroutine advance_explicit_rk3 ( g , restart_time_step , istep ) use dist_fn_arrays , only : g0 , g1 , g2 use zgrid , only : nzgrid use stella_layouts , only : vmu_lo use multibox , only : RK_step implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: g logical , intent ( in out ) :: restart_time_step integer , intent ( in ) :: istep integer :: icnt !> RK_STEP = false unless in multibox mode if ( RK_step ) call mb_communicate ( g ) g0 = g icnt = 1 !> SSP rk3 algorithm to advance explicit part of code !> if GK equation written as dg/dt = rhs - vpar . grad h, !> solve_gke returns rhs*dt do while ( icnt <= 3 ) select case ( icnt ) case ( 1 ) call solve_gke ( g0 , g1 , restart_time_step , istep ) case ( 2 ) g1 = g0 + g1 if ( RK_step ) call mb_communicate ( g1 ) call solve_gke ( g1 , g2 , restart_time_step , istep ) case ( 3 ) g2 = g1 + g2 if ( RK_step ) call mb_communicate ( g2 ) call solve_gke ( g2 , g , restart_time_step , istep ) end select if ( restart_time_step ) then ! If the code_dt is reset, we need to quit this loop and restart the timestep again icnt = 10 else icnt = icnt + 1 end if end do !> this is g at intermediate time level g = g0 / 3. + 0.5 * g1 + ( g2 + g ) / 6. end subroutine advance_explicit_rk3 !> standard RK4 subroutine advance_explicit_rk4 ( g , restart_time_step , istep ) use dist_fn_arrays , only : g0 , g1 , g2 , g3 use zgrid , only : nzgrid use stella_layouts , only : vmu_lo use multibox , only : RK_step implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: g logical , intent ( in out ) :: restart_time_step integer , intent ( in ) :: istep integer :: icnt !> RK_step is false unless in multibox mode if ( RK_step ) call mb_communicate ( g ) g0 = g icnt = 1 !> RK4 algorithm to advance explicit part of code !> if GK equation written as dg/dt = rhs - vpar . grad h, !> solve_gke returns rhs*dt do while ( icnt <= 4 ) select case ( icnt ) case ( 1 ) call solve_gke ( g0 , g1 , restart_time_step , istep ) case ( 2 ) ! g1 is h*k1 g3 = g0 + 0.5 * g1 if ( RK_step ) call mb_communicate ( g3 ) call solve_gke ( g3 , g2 , restart_time_step , istep ) g1 = g1 + 2. * g2 case ( 3 ) ! g2 is h*k2 g2 = g0 + 0.5 * g2 if ( RK_step ) call mb_communicate ( g2 ) call solve_gke ( g2 , g3 , restart_time_step , istep ) g1 = g1 + 2. * g3 case ( 4 ) ! g3 is h*k3 g3 = g0 + g3 if ( RK_step ) call mb_communicate ( g3 ) call solve_gke ( g3 , g , restart_time_step , istep ) g1 = g1 + g end select if ( restart_time_step ) then ! If the code_dt is reset, we need to quit this loop and restart the timestep again icnt = 10 else icnt = icnt + 1 end if end do !> this is g at intermediate time level g = g0 + g1 / 6. end subroutine advance_explicit_rk4 !> solve_gke accepts as argument pdf, the guiding centre distribution function in k-space, !> and returns rhs_ky, the right-hand side of the gyrokinetic equation in k-space; !> i.e., if dg/dt = r, then rhs_ky = r*dt; !> note that if include_apar = T, then the input pdf is actually gbar = g + (Ze/T)*(vpa/c)*<Apar>*F0 subroutine solve_gke ( pdf , rhs_ky , restart_time_step , istep ) use job_manage , only : time_message use fields_arrays , only : phi , apar , bpar use stella_layouts , only : vmu_lo use stella_transforms , only : transform_y2ky use redistribute , only : gather , scatter use physics_flags , only : include_parallel_nonlinearity use physics_flags , only : include_parallel_streaming use physics_flags , only : include_mirror , include_apar use physics_flags , only : nonlinear , include_bpar use physics_flags , only : full_flux_surface , radial_variation use physics_parameters , only : g_exb use zgrid , only : nzgrid , ntubes use kt_grids , only : ikx_max , ny , naky_all use kt_grids , only : swap_kxky_back use run_parameters , only : stream_implicit , mirror_implicit , drifts_implicit use dissipation , only : include_collisions , advance_collisions_explicit , collisions_implicit use sources , only : source_option_switch , source_option_krook use sources , only : add_krook_operator use parallel_streaming , only : advance_parallel_streaming_explicit use fields , only : advance_fields , fields_updated , get_radial_correction use mirror_terms , only : advance_mirror_explicit use flow_shear , only : advance_parallel_flow_shear use multibox , only : include_multibox_krook , add_multibox_krook use g_tofrom_h , only : gbar_to_g ! TMP FOR TESTING -- MAB use fields , only : fields_updated implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: pdf complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( out ), target :: rhs_ky logical , intent ( out ) :: restart_time_step integer , intent ( in ) :: istep complex , dimension (:, :, :, :, :), allocatable , target :: rhs_y complex , dimension (:, :, :, :, :), pointer :: rhs complex , dimension (:, :), allocatable :: rhs_ky_swap integer :: iz , it , ivmu rhs_ky = 0. !> if full_flux_surface = .true., then initially obtain the RHS of the GKE in alpha-space; !> will later inverse Fourier transform to get RHS in k_alpha-space if ( full_flux_surface ) then !> rhs_ky will always be needed as the array returned by the subroutine, !> but intermediate array rhs_y (RHS of gke in alpha-space) only needed for full_flux_surface = .true. allocate ( rhs_y ( ny , ikx_max , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) rhs_y = 0. !> rhs is array referred to for both flux tube and full-flux-surface simulations; !> for full-flux-surface it should point to rhs_y rhs => rhs_y else !> rhs is array referred to for both flux tube and full-flux-surface simulations; !> for flux tube it should point to rhs_ky rhs => rhs_ky end if !> start with g in k-space and (ky,kx,z) local !> obtain fields corresponding to g if ( debug ) write ( * , * ) 'time_advance::advance_stella::advance_explicit::solve_gke::advance_fields' ! if advancing apar, then gbar is evolved in time rather than g if ( include_apar ) then call advance_fields ( pdf , phi , apar , bpar , dist = 'gbar' ) ! convert from gbar to g = h - (Z F0/T)( J0 phi + 4 mu (T/Z) (J1/gamma) bpar), ! as all terms on RHS of GKE use g rather than gbar call gbar_to_g ( pdf , apar , 1.0 ) else call advance_fields ( pdf , phi , apar , bpar , dist = 'g' ) end if if ( radial_variation ) call get_radial_correction ( pdf , phi , dist = 'g' ) !> default is to continue with same time step size. !> if estimated CFL condition for nonlinear terms is violated !> then restart_time_step will be set to .true. restart_time_step = . false . !> calculate and add ExB nonlinearity to RHS of GK eqn !> do this first, as the CFL condition may require a change in time step !> and thus recomputation of mirror, wdrift, wstar, and parstream if ( debug ) write ( * , * ) 'time_advance::advance_stella::advance_explicit::solve_gke::advance_ExB_nonlinearity' if ( nonlinear ) call advance_ExB_nonlinearity ( pdf , rhs , restart_time_step , istep ) !> include contribution from the parallel nonlinearity (aka turbulent acceleration) if ( include_parallel_nonlinearity . and . . not . restart_time_step ) & call advance_parallel_nonlinearity ( pdf , rhs , restart_time_step ) if (. not . restart_time_step ) then !> include contribution from perp flow shear in the parallel component of the toroidal flow if (( g_exb ** 2 ) > epsilon ( 0.0 )) call advance_parallel_flow_shear ( rhs ) !> calculate and add mirror term to RHS of GK eqn if ( include_mirror . and . . not . mirror_implicit ) then if ( debug ) write ( * , * ) 'time_advance::advance_stella::advance_explicit::solve_gke::advance_mirror_explicit' call advance_mirror_explicit ( pdf , rhs ) end if if (. not . drifts_implicit ) then !> calculate and add alpha-component of magnetic drift term to RHS of GK eqn if ( debug ) write ( * , * ) 'time_advance::advance_stella::advance_explicit::solve_gke::advance_wdrifty_explicit' call advance_wdrifty_explicit ( pdf , phi , bpar , rhs ) !> calculate and add psi-component of magnetic drift term to RHS of GK eqn if ( debug ) write ( * , * ) 'time_advance::advance_stella::advance_explicit::solve_gke::advance_wdriftx_explicit' call advance_wdriftx_explicit ( pdf , phi , bpar , rhs ) !> calculate and add omega_* term to RHS of GK eqn if ( debug ) write ( * , * ) 'time_advance::advance_stella::advance_explicit::solve_gke::advance_wstar_explicit' call advance_wstar_explicit ( phi , rhs ) end if !> calculate and add contribution from collisions to RHS of GK eqn if ( include_collisions . and . . not . collisions_implicit ) call advance_collisions_explicit ( pdf , phi , bpar , rhs ) !> calculate and add parallel streaming term to RHS of GK eqn if ( include_parallel_streaming . and . (. not . stream_implicit )) then if ( debug ) write ( * , * ) 'time_advance::advance_stella::advance_explicit::solve_gke::advance_parallel_streaming_explicit' call advance_parallel_streaming_explicit ( pdf , phi , bpar , rhs ) end if !> if simulating a full flux surface (flux annulus), all terms to this point have been calculated !> in real-space in alpha (y); transform to kalpha (ky) space before adding to RHS of GKE. !> NB: it may be that for fully explicit calculation, this transform can be eliminated with additional code changes if ( full_flux_surface ) then if ( debug ) write ( * , * ) 'time_advance::advance_stella::advance_explicit::solve_gke::transform_y2ky' allocate ( rhs_ky_swap ( naky_all , ikx_max )) it = 1 do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do iz = - nzgrid , nzgrid call transform_y2ky ( rhs_y (:, :, iz , it , ivmu ), rhs_ky_swap ) call swap_kxky_back ( rhs_ky_swap , rhs_ky (:, :, iz , it , ivmu )) end do end do deallocate ( rhs_ky_swap ) end if if ( radial_variation ) call advance_radial_variation ( pdf , rhs ) if ( source_option_switch == source_option_krook ) call add_krook_operator ( pdf , rhs ) if ( include_multibox_krook ) call add_multibox_krook ( pdf , rhs ) end if ! if advancing apar, need to convert input pdf back from g to gbar if ( include_apar ) call gbar_to_g ( pdf , apar , - 1.0 ) fields_updated = . false . if ( allocated ( rhs_y )) deallocate ( rhs_y ) nullify ( rhs ) end subroutine solve_gke subroutine advance_wstar_explicit ( phi , gout ) use mp , only : proc0 , mp_abort use job_manage , only : time_message use fields , only : get_dchidy use fields_arrays , only : apar , bpar use stella_layouts , only : vmu_lo use stella_transforms , only : transform_ky2y use zgrid , only : nzgrid , ntubes use kt_grids , only : naky , naky_all , nakx , ikx_max , ny use kt_grids , only : swap_kxky use physics_flags , only : full_flux_surface use dist_fn_arrays , only : wstar implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: phi complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: gout complex , dimension (:, :, :, :, :), allocatable :: g0 , g0y complex , dimension (:, :), allocatable :: g0_swap integer :: iz , it , ivmu !> start timing the time advance due to the driving gradients if ( proc0 ) call time_message (. false ., time_gke (:, 6 ), ' wstar advance' ) allocate ( g0 ( naky , nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) if ( debug ) write ( * , * ) 'time_advance::solve_gke::get_dchidy' !> get d<chi>/dy in k-space call get_dchidy ( phi , apar , bpar , g0 ) if ( full_flux_surface ) then !> assume only a single flux surface simulated it = 1 allocate ( g0y ( ny , ikx_max , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) allocate ( g0_swap ( naky_all , ikx_max )) !> transform d<chi>/dy from k-space to y-space do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do iz = - nzgrid , nzgrid call swap_kxky ( g0 (:, :, iz , it , ivmu ), g0_swap ) call transform_ky2y ( g0_swap , g0y (:, :, iz , it , ivmu )) end do end do !> multiply d<chi>/dy with omega_* coefficient and add to source (RHS of GK eqn) !       call add_wstar_term_ffs (g0y, gout) call add_explicit_term_ffs ( g0y , wstar , gout ) deallocate ( g0y , g0_swap ) else !> omega_* stays in ky,kx,z space with ky,kx,z local !> multiply d<chi>/dy with omega_* coefficient and add to source (RHS of GK eqn) if ( debug ) write ( * , * ) 'time_advance::solve_gke::add_wstar_term' !       call add_wstar_term (g0, gout) call add_explicit_term ( g0 , wstar ( 1 , :, :), gout ) end if deallocate ( g0 ) !> stop timing the time advance due to the driving gradients if ( proc0 ) call time_message (. false ., time_gke (:, 6 ), ' wstar advance' ) end subroutine advance_wstar_explicit !> advance_wdrifty_explicit subroutine calculates and adds the y-component of the !> magnetic drift term to the RHS of the GK equation subroutine advance_wdrifty_explicit ( g , phi , bpar , gout ) use mp , only : proc0 use stella_layouts , only : vmu_lo use job_manage , only : time_message use stella_transforms , only : transform_ky2y use zgrid , only : nzgrid , ntubes use kt_grids , only : nakx , ikx_max , naky , naky_all , ny use kt_grids , only : swap_kxky use physics_flags , only : full_flux_surface , include_bpar use gyro_averages , only : gyro_average , gyro_average_j1 use dist_fn_arrays , only : wdrifty_g , wdrifty_phi , wdrifty_bpar implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: phi , bpar complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: gout integer :: ivmu , iz , it complex , dimension (:, :, :, :), allocatable :: dphidy , dbpardy complex , dimension (:, :, :, :, :), allocatable :: g0k , g0y complex , dimension (:, :), allocatable :: g0k_swap !> start the timing of the y component of the magnetic drift advance if ( proc0 ) call time_message (. false ., time_gke (:, 4 ), ' dgdy advance' ) allocate ( dphidy ( naky , nakx , - nzgrid : nzgrid , ntubes )) allocate ( dbpardy ( naky , nakx , - nzgrid : nzgrid , ntubes )) allocate ( g0k ( naky , nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) if ( debug ) write ( * , * ) 'time_advance::advance_stella::advance_explicit::solve_gke::advance_wdrifty_explicit::get_dgdy' !> calculate dg/dy in (ky,kx) space call get_dgdy ( g , g0k ) !> calculate dphi/dy in (ky,kx) space call get_dgdy ( phi , dphidy ) !> calculate dbpar/dy in (ky,kx) space if ( include_bpar ) call get_dgdy ( bpar , dbpardy ) if ( full_flux_surface ) then !> assume only a single flux surface simulated it = 1 allocate ( g0y ( ny , ikx_max , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) allocate ( g0k_swap ( naky_all , ikx_max )) !> transform dg/dy from k-space to y-space do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do iz = - nzgrid , nzgrid call swap_kxky ( g0k (:, :, iz , it , ivmu ), g0k_swap ) call transform_ky2y ( g0k_swap , g0y (:, :, iz , it , ivmu )) end do end do !> add vM . grad y dg/dy term to equation call add_explicit_term_ffs ( g0y , wdrifty_g , gout ) !> get <dphi/dy> in k-space do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc call gyro_average ( dphidy , ivmu , g0k (:, :, :, :, ivmu )) end do !> transform d<phi>/dy from k-space to y-space do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do iz = - nzgrid , nzgrid call swap_kxky ( g0k (:, :, iz , it , ivmu ), g0k_swap ) call transform_ky2y ( g0k_swap , g0y (:, :, iz , it , ivmu )) end do end do !> add vM . grad y d<phi>/dy term to equation call add_explicit_term_ffs ( g0y , wdrifty_phi , gout ) deallocate ( g0y , g0k_swap ) else if ( debug ) write ( * , * ) 'time_advance::solve_gke::add_dgdy_term' ! add vM . grad y dg/dy term to equation call add_explicit_term ( g0k , wdrifty_g ( 1 , :, :), gout ) ! get <dphi/dy> in k-space do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc call gyro_average ( dphidy , ivmu , g0k (:, :, :, :, ivmu )) end do ! add vM . grad y d<phi>/dy term to equation call add_explicit_term ( g0k , wdrifty_phi ( 1 , :, :), gout ) if ( include_bpar ) then ! get <dbpar/dy> in k-space do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc call gyro_average_j1 ( dbpardy , ivmu , g0k (:, :, :, :, ivmu )) end do ! add vM . grad y (4 mu d<bpar>/dy) term to equation call add_explicit_term ( g0k , wdrifty_bpar ( 1 , :, :), gout ) end if end if deallocate ( g0k , dphidy , dbpardy ) !> stop the timing of the y component of the magnetic drift advance if ( proc0 ) call time_message (. false ., time_gke (:, 4 ), ' dgdy advance' ) end subroutine advance_wdrifty_explicit !> advance_wdriftx_explicit subroutine calculates and adds the x-component of the !> magnetic drift term to the RHS of the GK equation subroutine advance_wdriftx_explicit ( g , phi , bpar , gout ) use mp , only : proc0 use stella_layouts , only : vmu_lo use job_manage , only : time_message use stella_transforms , only : transform_ky2y use zgrid , only : nzgrid , ntubes use kt_grids , only : nakx , ikx_max , naky , naky_all , ny , akx use kt_grids , only : swap_kxky use physics_flags , only : full_flux_surface , include_bpar use gyro_averages , only : gyro_average use dist_fn_arrays , only : wdriftx_g , wdriftx_phi , wdriftx_bpar implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: phi , bpar complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: gout integer :: ivmu , iz , it complex , dimension (:, :, :, :), allocatable :: dphidx , dbpardx complex , dimension (:, :, :, :, :), allocatable :: g0k , g0y complex , dimension (:, :), allocatable :: g0k_swap !> start the timing of the x component of the magnetic drift advance if ( proc0 ) call time_message (. false ., time_gke (:, 5 ), ' dgdx advance' ) !> do not calculate if wdriftx terms are all zero if ( maxval ( abs ( akx )) < epsilon ( 0. )) then if ( proc0 ) call time_message (. false ., time_gke (:, 5 ), ' dgdx advance' ) return end if allocate ( dphidx ( naky , nakx , - nzgrid : nzgrid , ntubes )) allocate ( dbpardx ( naky , nakx , - nzgrid : nzgrid , ntubes )) allocate ( g0k ( naky , nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) if ( debug ) write ( * , * ) 'time_advance::solve_gke::get_dgdx' !> calculate dg/dx in (ky,kx) space call get_dgdx ( g , g0k ) !> calculate dphi/dx in (ky,kx) space call get_dgdx ( phi , dphidx ) !> calculate dbpar/dx in (ky,kx) space if ( include_bpar ) call get_dgdx ( bpar , dbpardx ) if ( full_flux_surface ) then !> assume a single flux surface is simulated it = 1 allocate ( g0y ( ny , ikx_max , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) allocate ( g0k_swap ( naky_all , ikx_max )) !> transform dg/dx from k-space to y-space do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do iz = - nzgrid , nzgrid call swap_kxky ( g0k (:, :, iz , it , ivmu ), g0k_swap ) call transform_ky2y ( g0k_swap , g0y (:, :, iz , it , ivmu )) end do end do !> add vM . grad x dg/dx term to equation call add_explicit_term_ffs ( g0y , wdriftx_g , gout ) !> get <dphi/dx> in k-space do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc call gyro_average ( dphidx , ivmu , g0k (:, :, :, :, ivmu )) end do !> transform d<phi>/dx from k-space to y-space do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do iz = - nzgrid , nzgrid call swap_kxky ( g0k (:, :, iz , it , ivmu ), g0k_swap ) call transform_ky2y ( g0k_swap , g0y (:, :, iz , it , ivmu )) end do end do !> add vM . grad x d<phi>/dx term to equation call add_explicit_term_ffs ( g0y , wdriftx_phi , gout ) deallocate ( g0y , g0k_swap ) else if ( debug ) write ( * , * ) 'time_advance::solve_gke::add_dgdx_term' !> add vM . grad x dg/dx term to equation call add_explicit_term ( g0k , wdriftx_g ( 1 , :, :), gout ) !> get <dphi/dx> in k-space do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc call gyro_average ( dphidx , ivmu , g0k (:, :, :, :, ivmu )) end do !> add vM . grad x d<phi>/dx term to equation call add_explicit_term ( g0k , wdriftx_phi ( 1 , :, :), gout ) if ( include_bpar ) then !> get <dbpar/dx> in k-space do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc call gyro_average ( dbpardx , ivmu , g0k (:, :, :, :, ivmu )) end do !> add vM . grad x ( 4 mu d<bpar>/dx ) term to equation call add_explicit_term ( g0k , wdriftx_bpar ( 1 , :, :), gout ) end if end if deallocate ( g0k , dphidx , dbpardx ) !> stop the timing of the x component of the magnetic drift advance if ( proc0 ) call time_message (. false ., time_gke (:, 5 ), ' dgdx advance' ) end subroutine advance_wdriftx_explicit subroutine advance_ExB_nonlinearity ( g , gout , restart_time_step , istep ) use mp , only : proc0 , min_allreduce use mp , only : scope , allprocs , subprocs use stella_layouts , only : vmu_lo , imu_idx , is_idx use job_manage , only : time_message use gyro_averages , only : gyro_average use fields , only : get_dchidx , get_dchidy use fields_arrays , only : phi , apar , bpar , shift_state use fields_arrays , only : phi_corr_QN , phi_corr_GA !   use fields_arrays, only: apar_corr_QN, apar_corr_GA use stella_transforms , only : transform_y2ky , transform_x2kx use stella_transforms , only : transform_y2ky_xfirst , transform_x2kx_xfirst use stella_time , only : cfl_dt_ExB , cfl_dt_linear , code_dt , code_dt_max use run_parameters , only : cfl_cushion_upper , cfl_cushion_middle , cfl_cushion_lower , fphi use physics_parameters , only : g_exb , g_exbfac use zgrid , only : nzgrid , ntubes use stella_geometry , only : exb_nonlin_fac , exb_nonlin_fac_p , gfac use kt_grids , only : nakx , ikx_max , naky , naky_all , nx , ny use kt_grids , only : akx , aky , rho_clamped use physics_flags , only : full_flux_surface , radial_variation use physics_flags , only : prp_shear_enabled , hammett_flow_shear use physics_flags , only : include_apar , include_bpar use kt_grids , only : x , swap_kxky , swap_kxky_back use constants , only : pi , zi use file_utils , only : runtype_option_switch , runtype_multibox use g_tofrom_h , only : g_to_h implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: g complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: gout logical , intent ( out ) :: restart_time_step integer , intent ( in ) :: istep complex , dimension (:, :), allocatable :: g0k , g0a , g0k_swap complex , dimension (:, :), allocatable :: g0kxy , g0xky , prefac real , dimension (:, :), allocatable :: g0xy , g1xy , bracket real :: zero , cfl_dt integer :: ivmu , iz , it , imu , is logical :: yfirst ! alpha-component of magnetic drift (requires ky -> y) if ( proc0 ) call time_message (. false ., time_gke (:, 7 ), ' ExB nonlinear advance' ) if ( debug ) write ( * , * ) 'time_advance::solve_gke::advance_ExB_nonlinearity::get_dgdy' ! avoid divide by zero in cfl_dt terms below zero = 10 0. * epsilon ( 0. ) ! Initialize cfl_dt_ExB cfl_dt_ExB = 1000000 0. restart_time_step = . false . ! this statement seems to imply that flow shear is not compatible with FFS ! need to check yfirst = . not . prp_shear_enabled allocate ( g0k ( naky , nakx )) allocate ( g0a ( naky , nakx )) allocate ( g0xy ( ny , nx )) allocate ( g1xy ( ny , nx )) allocate ( bracket ( ny , nx )) allocate ( prefac ( naky , nx )) if ( yfirst ) then allocate ( g0k_swap ( naky_all , ikx_max )) allocate ( g0kxy ( ny , ikx_max )) else allocate ( g0xky ( naky , nx )) end if !> compute phase factor needed when running with equilibrium flow shear prefac = 1.0 if ( prp_shear_enabled . and . hammett_flow_shear ) then prefac = exp ( - zi * g_exb * g_exbfac * spread ( x , 1 , naky ) * spread ( aky * shift_state , 2 , nx )) end if ! incoming pdf is g = <f> ! for EM simulations, the pdf entering the ExB nonlinearity needs to be ! the non-Boltzmann part of f (h = f + (Ze/T)*phi*F0) if ( include_apar . or . include_bpar ) call g_to_h ( g , phi , bpar , fphi ) do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) do it = 1 , ntubes do iz = - nzgrid , nzgrid !> compute i*ky*g call get_dgdy ( g (:, :, iz , it , ivmu ), g0k ) !> FFT to get dg/dy in (y,x) space call forward_transform ( g0k , g0xy ) !> compute i*kx*<chi> call get_dchidx ( iz , ivmu , phi (:, :, iz , it ), apar (:, :, iz , it ), bpar (:, :, iz , it ), g0k ) !> if running with equilibrium flow shear, make adjustment to !> the term multiplying dg/dy if ( prp_shear_enabled . and . hammett_flow_shear ) then call get_dchidy ( iz , ivmu , phi (:, :, iz , it ), apar (:, :, iz , it ), bpar (:, :, iz , it ), g0a ) g0k = g0k - g_exb * g_exbfac * spread ( shift_state , 2 , nakx ) * g0a end if !> FFT to get d<chi>/dx in (y,x) space call forward_transform ( g0k , g1xy ) !> multiply by the geometric factor appearing in the Poisson bracket; !> i.e., (dx/dpsi*dy/dalpha)*0.5 g1xy = g1xy * exb_nonlin_fac !> compute the contribution to the Poisson bracket from dg/dy*d<chi>/dx bracket = g0xy * g1xy !> estimate the CFL dt due to the above contribution cfl_dt_ExB = min ( cfl_dt_ExB , 2. * pi / max ( maxval ( abs ( g1xy )) * aky ( naky ), zero )) if ( radial_variation ) then bracket = bracket + gfac * g0xy * g1xy * exb_nonlin_fac_p * spread ( rho_clamped , 1 , ny ) call gyro_average ( phi_corr_QN (:, :, iz , it ), iz , ivmu , g0a ) g0a = fphi * ( g0a + phi_corr_GA (:, :, iz , it , ivmu )) call get_dgdx ( g0a , g0k ) call forward_transform ( g0k , g1xy ) g1xy = g1xy * exb_nonlin_fac bracket = bracket + g0xy * g1xy !> estimate the CFL dt due to the above contribution cfl_dt_ExB = min ( cfl_dt_ExB , 2. * pi / max ( maxval ( abs ( g1xy )) * aky ( naky ), zero )) end if !> compute dg/dx in k-space (= i*kx*g) call get_dgdx ( g (:, :, iz , it , ivmu ), g0k ) !> if running with equilibrium flow shear, correct dg/dx term if ( prp_shear_enabled . and . hammett_flow_shear ) then call get_dgdy ( g (:, :, iz , it , ivmu ), g0a ) g0k = g0k - g_exb * g_exbfac * spread ( shift_state , 2 , nakx ) * g0a end if !> FFT to get dg/dx in (y,x) space call forward_transform ( g0k , g0xy ) !> compute d<chi>/dy in k-space call get_dchidy ( iz , ivmu , phi (:, :, iz , it ), apar (:, :, iz , it ), bpar (:, :, iz , it ), g0k ) !> FFT to get d<chi>/dy in (y,x) space call forward_transform ( g0k , g1xy ) !> multiply by the geometric factor appearing in the Poisson bracket; !> i.e., (dx/dpsi*dy/dalpha)*0.5 g1xy = g1xy * exb_nonlin_fac !> compute the contribution to the Poisson bracket from dg/dy*d<chi>/dx bracket = bracket - g0xy * g1xy !> estimate the CFL dt due to the above contribution cfl_dt_ExB = min ( cfl_dt_ExB , 2. * pi / max ( maxval ( abs ( g1xy )) * akx ( ikx_max ), zero )) if ( radial_variation ) then bracket = bracket - gfac * g0xy * g1xy * exb_nonlin_fac_p * spread ( rho_clamped , 1 , ny ) call gyro_average ( phi_corr_QN (:, :, iz , it ), iz , ivmu , g0a ) g0a = fphi * ( g0a + phi_corr_GA (:, :, iz , it , ivmu )) call get_dgdy ( g0a , g0k ) call forward_transform ( g0k , g1xy ) g1xy = g1xy * exb_nonlin_fac bracket = bracket - g0xy * g1xy !> estimate the CFL dt due to the above contribution cfl_dt_ExB = min ( cfl_dt_ExB , 2. * pi / max ( maxval ( abs ( g1xy )) * akx ( ikx_max ), zero )) end if if ( yfirst ) then call transform_x2kx ( bracket , g0kxy ) if ( full_flux_surface ) then gout (:, :, iz , it , ivmu ) = g0kxy else call transform_y2ky ( g0kxy , g0k_swap ) call swap_kxky_back ( g0k_swap , gout (:, :, iz , it , ivmu )) end if else call transform_y2ky_xfirst ( bracket , g0xky ) g0xky = g0xky / prefac call transform_x2kx_xfirst ( g0xky , gout (:, :, iz , it , ivmu )) end if end do end do end do ! convert back from h to g = <f> (only needed for EM sims) if ( include_apar . or . include_bpar ) call g_to_h ( g , phi , bpar , - fphi ) deallocate ( g0k , g0a , g0xy , g1xy , bracket ) if ( allocated ( g0k_swap )) deallocate ( g0k_swap ) if ( allocated ( g0xky )) deallocate ( g0xky ) if ( allocated ( g0kxy )) deallocate ( g0kxy ) if ( runtype_option_switch == runtype_multibox ) call scope ( allprocs ) call min_allreduce ( cfl_dt_ExB ) if ( runtype_option_switch == runtype_multibox ) call scope ( subprocs ) !> check estimated cfl_dt to see if the time step size needs to be changed cfl_dt = min ( cfl_dt_ExB , cfl_dt_linear ) if ( code_dt > cfl_dt * cfl_cushion_upper ) then if ( proc0 ) then write ( * , * ) ' ' write ( * , '(A30,I0,A1)' ) 'CHANGING TIME STEP: (istep = ' , istep , ')' write ( * , '(A22, ES10.2E2)' ) \"   code_dt:\" // REPEAT ( ' ' , 50 ), code_dt write ( * , '(A22, ES10.2E2)' ) \"   cfl_dt_ExB:\" // REPEAT ( ' ' , 50 ), cfl_dt_ExB write ( * , '(A22, ES10.2E2)' ) \"   cfl_dt_linear:\" // REPEAT ( ' ' , 50 ), cfl_dt_linear write ( * , '(A22, ES10.2E2)' ) \"   cfl_cushion_upper:\" // REPEAT ( ' ' , 50 ), cfl_cushion_upper write ( * , '(A22, ES10.2E2)' ) \"   cfl_cushion_middle:\" // REPEAT ( ' ' , 50 ), cfl_cushion_middle write ( * , '(A22, ES10.2E2)' ) \"   cfl_cushion_lower:\" // REPEAT ( ' ' , 50 ), cfl_cushion_lower write ( * , '(A62)' ) '     ==> The code_dt is larger than cfl_dt*cfl_cushion_upper.' write ( * , '(A59,ES11.4)' ) '      ==> Decreasing code_dt to cfl_dt*cfl_cushion_middle =' , cfl_dt * cfl_cushion_middle write ( * , * ) ' ' end if code_dt = cfl_dt * cfl_cushion_middle call reset_dt restart_time_step = . true . else if ( code_dt < min ( cfl_dt * cfl_cushion_lower , code_dt_max )) then if ( proc0 ) then write ( * , * ) ' ' write ( * , '(A30,I0,A1)' ) 'CHANGING TIME STEP: (istep = ' , istep , ')' write ( * , '(A22, ES10.2E2)' ) \"   code_dt:\" // REPEAT ( ' ' , 50 ), code_dt write ( * , '(A22, ES10.2E2)' ) \"   cfl_dt_ExB:\" // REPEAT ( ' ' , 50 ), cfl_dt_ExB write ( * , '(A22, ES10.2E2)' ) \"   cfl_dt_linear:\" // REPEAT ( ' ' , 50 ), cfl_dt_linear write ( * , '(A22, ES10.2E2)' ) \"   cfl_cushion_upper:\" // REPEAT ( ' ' , 50 ), cfl_cushion_upper write ( * , '(A22, ES10.2E2)' ) \"   cfl_cushion_middle:\" // REPEAT ( ' ' , 50 ), cfl_cushion_middle write ( * , '(A22, ES10.2E2)' ) \"   cfl_cushion_lower:\" // REPEAT ( ' ' , 50 ), cfl_cushion_lower write ( * , '(A63)' ) '     ==> The code_dt is smaller than cfl_dt*cfl_cushion_lower.' write ( * , '(A59,ES11.4)' ) '      ==> Increasing code_dt to cfl_dt*cfl_cushion_middle =' , cfl_dt * cfl_cushion_middle write ( * , * ) ' ' end if code_dt = min ( cfl_dt * cfl_cushion_middle , code_dt_max ) call reset_dt restart_time_step = . true . else gout = code_dt * gout end if if ( proc0 ) call time_message (. false ., time_gke (:, 7 ), ' ExB nonlinear advance' ) contains subroutine forward_transform ( gk , gx ) use stella_transforms , only : transform_ky2y , transform_kx2x use stella_transforms , only : transform_ky2y_xfirst , transform_kx2x_xfirst implicit none complex , dimension (:, :), intent ( in ) :: gk real , dimension (:, :), intent ( out ) :: gx if ( yfirst ) then ! we have i*ky*g(kx,ky) for ky >= 0 and all kx ! want to do 1D complex to complex transform in y ! which requires i*ky*g(kx,ky) for all ky and kx >= 0 ! use g(kx,-ky) = conjg(g(-kx,ky)) ! so i*(-ky)*g(kx,-ky) = -i*ky*conjg(g(-kx,ky)) = conjg(i*ky*g(-kx,ky)) ! and i*kx*g(kx,-ky) = i*kx*conjg(g(-kx,ky)) = conjg(i*(-kx)*g(-kx,ky)) ! and i*(-ky)*J0(kx,-ky)*phi(kx,-ky) = conjg(i*ky*J0(-kx,ky)*phi(-kx,ky)) ! and i*kx*J0(kx,-ky)*phi(kx,-ky) = conjg(i*(-kx)*J0(-kx,ky)*phi(-kx,ky)) ! i.e., can calculate dg/dx, dg/dy, d<phi>/dx and d<phi>/dy ! on stella (kx,ky) grid, then conjugate and flip sign of (kx,ky) ! NB: J0(kx,ky) = J0(-kx,-ky) ! TODO DSO: coordinate change for shearing call swap_kxky ( gk , g0k_swap ) call transform_ky2y ( g0k_swap , g0kxy ) call transform_kx2x ( g0kxy , gx ) else call transform_kx2x_xfirst ( gk , g0xky ) g0xky = g0xky * prefac call transform_ky2y_xfirst ( g0xky , gx ) end if end subroutine forward_transform end subroutine advance_ExB_nonlinearity subroutine advance_parallel_nonlinearity ( g , gout , restart_time_step ) use constants , only : zi use mp , only : proc0 , min_allreduce , mp_abort use mp , only : scope , allprocs , subprocs use stella_layouts , only : vmu_lo , xyz_lo use stella_layouts , only : iv_idx , imu_idx , is_idx use job_manage , only : time_message use finite_differences , only : second_order_centered_zed use finite_differences , only : third_order_upwind use redistribute , only : gather , scatter use fields_arrays , only : phi , phi_corr_QN , phi_corr_GA use stella_transforms , only : transform_ky2y , transform_y2ky use stella_transforms , only : transform_kx2x , transform_x2kx use stella_time , only : cfl_dt_parallel , cfl_dt_linear , code_dt , code_dt_max use run_parameters , only : cfl_cushion_upper , cfl_cushion_middle , cfl_cushion_lower use zgrid , only : nzgrid , delzed , ntubes use extended_zgrid , only : neigen , nsegments , ikxmod use extended_zgrid , only : iz_low , iz_up use extended_zgrid , only : periodic use physics_flags , only : full_flux_surface , radial_variation use kt_grids , only : akx , aky , nakx , naky , nx , ny , ikx_max use kt_grids , only : swap_kxky , swap_kxky_back , rho_clamped use vpamu_grids , only : nvpa , nmu use vpamu_grids , only : dvpa , vpa , mu use gyro_averages , only : gyro_average use parallel_streaming , only : stream_sign use dist_redistribute , only : xyz2vmu use file_utils , only : runtype_option_switch , runtype_multibox use extended_zgrid , only : fill_zed_ghost_zones implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: gout logical , intent ( out ) :: restart_time_step integer :: ivmu , ixyz integer :: iz , it , iv , imu , is integer :: iky , ie , iseg integer :: advect_sign real :: cfl_dt real , dimension (:), allocatable :: dgdv real , dimension (:, :, :, :, :), allocatable :: g0xy real , dimension (:, :, :), allocatable :: gxy_vmulocal real , dimension (:, :), allocatable :: g1xy , advect_speed complex , dimension ( 2 ) :: gleft , gright complex , dimension (:, :, :, :), allocatable :: phi_gyro , dphidz complex , dimension (:, :), allocatable :: g0k , g0kxy , g0k_swap complex , dimension (:, :), allocatable :: tmp ! alpha-component of magnetic drift (requires ky -> y) if ( proc0 ) call time_message (. false ., time_parallel_nl (:, 1 ), ' parallel nonlinearity advance' ) ! Initialize cfl_dt_parallel cfl_dt_parallel = 1000000 0. restart_time_step = . false . ! overview: ! need g and d<phi>/dz in (x,y) space in ! order to upwind dg/dvpa ! 1) transform d<phi>/dz from (kx,ky) to (x,y). layout: vmu_lo ! 2) need sign of parnl advection in xyz_lo (since dg/dvpa !    requires vpa local), so d<phi>/dz(vmu_lo) --> d<phi>/dz(xyz_lo) ! 3) transform g from (kx,ky) to (x,y). layout: vmu_lo ! 4) dg/dvpa requires vpa local, so g(vmu_lo) --> g(xyz_lo) ! 5) calculate dg/dvpa ! 6) multiply dg/dvpa with d<phi>/dz ! 7) product(xyz_lo) --> product(vmu_lo) ! 8) inverse transform product(vmu_lo) allocate ( g0k ( naky , nakx )) allocate ( g0xy ( ny , nx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) allocate ( g0kxy ( ny , ikx_max )) if ( radial_variation ) allocate ( g1xy ( ny , nx )) allocate ( phi_gyro ( naky , nakx , - nzgrid : nzgrid , ntubes )) allocate ( dphidz ( naky , nakx , - nzgrid : nzgrid , ntubes )) allocate ( g0k_swap ( 2 * naky - 1 , ikx_max )) allocate ( tmp ( size ( gout , 1 ), size ( gout , 2 ))) ! get d<phi>/dz in vmu_lo ! we will need to transform it to real-space ! as its sign is needed for upwinding of dg/dvpa do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) ! construct <phi> dphidz = phi if ( radial_variation ) dphidz = dphidz + phi_corr_QN call gyro_average ( dphidz , ivmu , phi_gyro ) if ( radial_variation ) phi_gyro = phi_gyro + phi_corr_GA (:, :, :, :, ivmu ) do iky = 1 , naky do it = 1 , ntubes do ie = 1 , neigen ( iky ) do iseg = 1 , nsegments ( ie , iky ) ! first fill in ghost zones at boundaries in g(z) call fill_zed_ghost_zones ( it , iseg , ie , iky , phi_gyro , gleft , gright ) ! now get d<phi>/dz call second_order_centered_zed ( iz_low ( iseg ), iseg , nsegments ( ie , iky ), & phi_gyro ( iky , ikxmod ( iseg , ie , iky ), iz_low ( iseg ): iz_up ( iseg ), it ), & delzed ( 0 ), stream_sign ( iv ), gleft , gright , periodic ( iky ), & dphidz ( iky , ikxmod ( iseg , ie , iky ), iz_low ( iseg ): iz_up ( iseg ), it )) end do end do end do end do if ( radial_variation ) then do it = 1 , ntubes do iz = - nzgrid , nzgrid ! use reality to swap from ky >= 0, all kx to kx >= 0 , all ky call swap_kxky ( dphidz (:, :, iz , it ), g0k_swap ) ! transform in y call transform_ky2y ( g0k_swap , g0kxy ) ! transform in x call transform_kx2x ( g0kxy , g1xy ) g0xy (:, :, iz , it , ivmu ) = g1xy * ( par_nl_fac ( iz , is ) + d_par_nl_fac_dr ( iz , is ) * spread ( rho_clamped , 1 , ny )) g0k = zi * spread ( aky , 2 , nakx ) * phi_gyro (:, :, iz , it ) call swap_kxky ( g0k , g0k_swap ) call transform_ky2y ( g0k_swap , g0kxy ) call transform_kx2x ( g0kxy , g1xy ) g0xy (:, :, iz , it , ivmu ) = g0xy (:, :, iz , it , ivmu ) & + vpa ( iv ) * g1xy * ( par_nl_drifty ( iz ) + d_par_nl_drifty_dr ( iz ) * spread ( rho_clamped , 1 , ny )) g0k = zi * spread ( akx , 1 , naky ) * phi_gyro (:, :, iz , it ) call swap_kxky ( g0k , g0k_swap ) call transform_ky2y ( g0k_swap , g0kxy ) call transform_kx2x ( g0kxy , g1xy ) g0xy (:, :, iz , it , ivmu ) = g0xy (:, :, iz , it , ivmu ) & + vpa ( iv ) * g1xy * ( par_nl_driftx ( iz ) + d_par_nl_driftx_dr ( iz ) * spread ( rho_clamped , 1 , ny )) g0xy (:, :, iz , it , ivmu ) = g0xy (:, :, iz , it , ivmu ) & + vpa ( iv ) * mu ( imu ) * ( par_nl_curv ( iz , is ) + d_par_nl_curv_dr ( iz , is ) * spread ( rho_clamped , 1 , ny )) end do end do else do it = 1 , ntubes do iz = - nzgrid , nzgrid g0k = dphidz (:, :, iz , it ) * par_nl_fac ( iz , is ) + vpa ( iv ) * mu ( imu ) * par_nl_curv ( iz , is ) & + zi * vpa ( iv ) * phi_gyro (:, :, iz , it ) * ( spread ( akx , 1 , naky ) * par_nl_driftx ( iz ) & + spread ( aky , 2 , nakx ) * par_nl_drifty ( iz )) ! use reality to swap from ky >= 0, all kx to kx >= 0 , all ky call swap_kxky ( g0k , g0k_swap ) ! transform in y call transform_ky2y ( g0k_swap , g0kxy ) ! transform in x call transform_kx2x ( g0kxy , g0xy (:, :, iz , it , ivmu )) end do end do end if end do ! do not need phi_gyro or dphidz  again so deallocate deallocate ( phi_gyro , dphidz ) deallocate ( g0k ) if ( allocated ( g1xy )) deallocate ( g1xy ) allocate ( gxy_vmulocal ( nvpa , nmu , xyz_lo % llim_proc : xyz_lo % ulim_alloc )) allocate ( advect_speed ( nmu , xyz_lo % llim_proc : xyz_lo % ulim_alloc )) ! we now have the advection velocity in vpa in (x,y) space ! next redistribute it so that (vpa,mu) are local if ( proc0 ) call time_message (. false ., time_parallel_nl (:, 2 ), ' parallel nonlinearity redist' ) call scatter ( xyz2vmu , g0xy , gxy_vmulocal ) if ( proc0 ) call time_message (. false ., time_parallel_nl (:, 2 ), ' parallel nonlinearity redist' ) ! advect_speed does not depend on vpa advect_speed = gxy_vmulocal ( 1 , :, :) ! transform g from (kx,ky) to (x,y) do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid call swap_kxky ( g (:, :, iz , it , ivmu ), g0k_swap ) ! transform in y call transform_ky2y ( g0k_swap , g0kxy ) ! transform in x call transform_kx2x ( g0kxy , g0xy (:, :, iz , it , ivmu )) end do end do end do ! redistribute so that (vpa,mu) local if ( proc0 ) call time_message (. false ., time_parallel_nl (:, 2 ), ' parallel nonlinearity redist' ) call scatter ( xyz2vmu , g0xy , gxy_vmulocal ) if ( proc0 ) call time_message (. false ., time_parallel_nl (:, 2 ), ' parallel nonlinearity redist' ) allocate ( dgdv ( nvpa )) ! we now need to form dg/dvpa and obtain product of dg/dvpa with advection speed do ixyz = xyz_lo % llim_proc , xyz_lo % ulim_proc do imu = 1 , nmu ! advect_sign set to +/- 1 depending on sign of the parallel nonlinearity ! advection velocity ! NB: advect_sign = -1 corresponds to positive advection velocity advect_sign = int ( sign ( 1.0 , advect_speed ( imu , ixyz ))) call third_order_upwind ( 1 , gxy_vmulocal (:, imu , ixyz ), dvpa , advect_sign , dgdv ) gxy_vmulocal (:, imu , ixyz ) = dgdv * advect_speed ( imu , ixyz ) cfl_dt_parallel = min ( cfl_dt_parallel , dvpa / abs ( advect_speed ( imu , ixyz ))) end do end do ! finished with dgdv and advect_speed deallocate ( dgdv , advect_speed ) ! now that we have the full parallel nonlinearity in (x,y)-space ! need to redistribute so that (x,y) local for transforms if ( proc0 ) call time_message (. false ., time_parallel_nl (:, 2 ), ' parallel nonlinearity redist' ) call gather ( xyz2vmu , gxy_vmulocal , g0xy ) if ( proc0 ) call time_message (. false ., time_parallel_nl (:, 2 ), ' parallel nonlinearity redist' ) ! finished with gxy_vmulocal deallocate ( gxy_vmulocal ) ! g0xy is parallel nonlinearity term with (x,y) on processor ! need to inverse Fourier transform do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid call transform_x2kx ( g0xy (:, :, iz , it , ivmu ), g0kxy ) if ( full_flux_surface ) then gout (:, :, iz , it , ivmu ) = gout (:, :, iz , it , ivmu ) + code_dt * g0kxy else call transform_y2ky ( g0kxy , g0k_swap ) call swap_kxky_back ( g0k_swap , tmp ) gout (:, :, iz , it , ivmu ) = gout (:, :, iz , it , ivmu ) + code_dt * tmp end if end do end do end do deallocate ( g0k_swap , g0kxy , g0xy ) if ( runtype_option_switch == runtype_multibox ) call scope ( allprocs ) call min_allreduce ( cfl_dt_parallel ) if ( runtype_option_switch == runtype_multibox ) call scope ( subprocs ) !> check estimated cfl_dt to see if the time step size needs to be changed cfl_dt = min ( cfl_dt_parallel , cfl_dt_linear ) if ( code_dt > cfl_dt * cfl_cushion_upper ) then if ( proc0 ) then write ( * , * ) ' ' write ( * , * ) 'CHANGING TIME STEP:' write ( * , '(A22, ES10.2E2)' ) \"   code_dt:\" // REPEAT ( ' ' , 50 ), code_dt write ( * , '(A22, ES10.2E2)' ) \"   cfl_dt_parallel:\" // REPEAT ( ' ' , 50 ), cfl_dt_parallel write ( * , '(A22, ES10.2E2)' ) \"   cfl_dt_linear:\" // REPEAT ( ' ' , 50 ), cfl_dt_linear write ( * , '(A22, ES10.2E2)' ) \"   cfl_cushion_upper:\" // REPEAT ( ' ' , 50 ), cfl_cushion_upper write ( * , '(A22, ES10.2E2)' ) \"   cfl_cushion_middle:\" // REPEAT ( ' ' , 50 ), cfl_cushion_middle write ( * , '(A22, ES10.2E2)' ) \"   cfl_cushion_lower:\" // REPEAT ( ' ' , 50 ), cfl_cushion_lower write ( * , '(A62)' ) '     ==> The code_dt is larger than cfl_dt*cfl_cushion_upper.' write ( * , '(A59,ES11.4)' ) '      ==> Decreasing code_dt to cfl_dt*cfl_cushion_middle =' , cfl_dt * cfl_cushion_middle write ( * , * ) ' ' end if code_dt = cfl_dt * cfl_cushion_middle call reset_dt restart_time_step = . true . else if ( code_dt < min ( cfl_dt * cfl_cushion_lower , code_dt_max )) then if ( proc0 ) then write ( * , * ) ' ' write ( * , * ) 'CHANGING TIME STEP:' write ( * , '(A22, ES10.2E2)' ) \"   code_dt:\" // REPEAT ( ' ' , 50 ), code_dt write ( * , '(A22, ES10.2E2)' ) \"   cfl_dt_parallel:\" // REPEAT ( ' ' , 50 ), cfl_dt_parallel write ( * , '(A22, ES10.2E2)' ) \"   cfl_dt_linear:\" // REPEAT ( ' ' , 50 ), cfl_dt_linear write ( * , '(A22, ES10.2E2)' ) \"   cfl_cushion_upper:\" // REPEAT ( ' ' , 50 ), cfl_cushion_upper write ( * , '(A22, ES10.2E2)' ) \"   cfl_cushion_middle:\" // REPEAT ( ' ' , 50 ), cfl_cushion_middle write ( * , '(A22, ES10.2E2)' ) \"   cfl_cushion_lower:\" // REPEAT ( ' ' , 50 ), cfl_cushion_lower write ( * , '(A63)' ) '     ==> The code_dt is smaller than cfl_dt*cfl_cushion_lower.' write ( * , '(A59,ES11.4)' ) '      ==> Increasing code_dt to cfl_dt*cfl_cushion_middle =' , cfl_dt * cfl_cushion_middle write ( * , * ) ' ' end if code_dt = min ( cfl_dt * cfl_cushion_middle , code_dt_max ) call reset_dt restart_time_step = . true . !    else !       gout = code_dt*gout end if if ( proc0 ) call time_message (. false ., time_parallel_nl (:, 1 ), ' parallel nonlinearity advance' ) end subroutine advance_parallel_nonlinearity subroutine advance_radial_variation ( g , gout ) use mp , only : mp_abort , proc0 use job_manage , only : time_message use fields , only : get_dchidy use fields_arrays , only : phi , apar , bpar use fields_arrays , only : phi_corr_QN , phi_corr_GA !   use fields_arrays, only: apar_corr_QN, apar_corr_GA use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx , imu_idx , is_idx use stella_transforms , only : transform_kx2x_xfirst , transform_x2kx_xfirst use zgrid , only : nzgrid , ntubes use kt_grids , only : nakx , naky , multiply_by_rho use gyro_averages , only : gyro_average , gyro_average_j1 use run_parameters , only : fphi use physics_flags , only : full_flux_surface use physics_flags , only : include_parallel_streaming , include_mirror use dist_fn_arrays , only : wdriftx_phi , wdrifty_phi use dist_fn_arrays , only : wdriftpx_g , wdriftpy_g use dist_fn_arrays , only : wdriftpx_phi , wdriftpy_phi !, adiabatic_phi use dist_fn_arrays , only : wstar , wstarp use mirror_terms , only : add_mirror_radial_variation use flow_shear , only : prl_shear , prl_shear_p use parallel_streaming , only : add_parallel_streaming_radial_variation implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: gout integer :: ia , ivmu , iv , imu , is , iz , it complex , dimension (:, :), allocatable :: g0k , g1k , g0a complex , dimension (:, :, :, :, :), allocatable :: g_corr allocate ( g0k ( naky , nakx )) allocate ( g1k ( naky , nakx )) allocate ( g0a ( naky , nakx )) if ( debug ) write ( * , * ) 'time_advance::solve_gke::advance_radial_variation' if ( proc0 ) call time_message (. false ., time_gke (:, 10 ), ' radial variation advance' ) if ( include_mirror . or . include_parallel_streaming ) then allocate ( g_corr ( naky , nakx , - nzgrid : nzgrid , ntubes , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) g_corr = 0. end if !grab the mirror and parallel streaming corrections here to save on FFTs if ( include_mirror ) then call add_mirror_radial_variation ( g , g_corr ) end if if ( include_parallel_streaming ) then call add_parallel_streaming_radial_variation ( g , g_corr , gout ) end if if ( full_flux_surface ) then ! FLAG -- ADD SOMETHING HERE call mp_abort ( 'wstarp term not yet setup for full_flux_surface = .true. aborting.' ) end if ia = 1 do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) do it = 1 , ntubes do iz = - nzgrid , nzgrid g0k = 0. !wstar variation call get_dchidy ( iz , ivmu , phi (:, :, iz , it ), apar (:, :, iz , it ), bpar (:, :, iz , it ), g0a ) g0k = g0k + g0a * wstarp ( ia , iz , ivmu ) !radial variation in ExB nonlinearity is handled in advance_ExB_nonlinearity !wdrift(x/y) - g call get_dgdx ( g (:, :, iz , it , ivmu ), g0a ) g0k = g0k + g0a * wdriftpx_g ( ia , iz , ivmu ) call get_dgdy ( g (:, :, iz , it , ivmu ), g0a ) g0k = g0k + g0a * wdriftpy_g ( ia , iz , ivmu ) !wdrift - phi call get_dgdx ( phi (:, :, iz , it ), g1k ) !wdriftx variation call gyro_average ( g1k , iz , ivmu , g0a ) g0k = g0k + g0a * wdriftpx_phi ( ia , iz , ivmu ) call get_dgdy ( phi (:, :, iz , it ), g1k ) !wdrifty variation call gyro_average ( g1k , iz , ivmu , g0a ) g0k = g0k + g0a * wdriftpy_phi ( ia , iz , ivmu ) !prl_shear variation g0k = g0k + g0a * prl_shear_p ( ia , iz , ivmu ) !mirror term and/or parallel streaming if ( include_mirror . or . include_parallel_streaming ) then g0k = g0k + g_corr (:, :, iz , it , ivmu ) end if !inverse and forward transforms call multiply_by_rho ( g0k ) ! !quasineutrality/gyroaveraging ! call gyro_average ( phi_corr_QN (:, :, iz , it ), iz , ivmu , g0a ) g0a = fphi * ( g0a + phi_corr_GA (:, :, iz , it , ivmu )) !wstar - gyroaverage/quasineutrality variation call get_dgdy ( g0a , g1k ) g0k = g0k + g1k * wstar ( ia , iz , ivmu ) !wdrifty gyroaverage/quasineutrality variation g0k = g0k + g1k * wdrifty_phi ( ia , iz , ivmu ) !prl_shear gyroaverage/quasineutrality variation g0k = g0k + g1k * prl_shear ( ia , iz , ivmu ) !wdriftx gyroaverage/quasineutrality variation call get_dgdx ( g0a , g1k ) g0k = g0k + g1k * wdriftx_phi ( ia , iz , ivmu ) !              !wdriftx F_M/T_s variation !              call gyro_average (phi(:, :, iz, it), iz, ivmu, g0a) !              g0a = adiabatic_phi(ia, iz, ivmu) * g0a !              call multiply_by_rho(g0a) !              call get_dgdx(g0a, g1k) !              g0k = g0k + g1k * wdriftx_phi(ia, iz, ivmu) gout (:, :, iz , it , ivmu ) = gout (:, :, iz , it , ivmu ) + g0k end do end do end do deallocate ( g0k , g1k , g0a ) if ( allocated ( g_corr )) deallocate ( g_corr ) if ( proc0 ) call time_message (. false ., time_gke (:, 10 ), ' radial variation advance' ) end subroutine advance_radial_variation !> compute dg/dy in k-space !> accepts g(ky,kx) subroutine get_dgdy_2d ( g , dgdy ) use constants , only : zi use kt_grids , only : nakx , aky implicit none complex , dimension (:, :), intent ( in ) :: g complex , dimension (:, :), intent ( out ) :: dgdy dgdy = zi * spread ( aky , 2 , nakx ) * g end subroutine get_dgdy_2d !> compute dg/dy in k-space !> accepts g(ky,kx,z,tube) subroutine get_dgdy_3d ( g , dgdy ) use constants , only : zi use zgrid , only : nzgrid , ntubes use kt_grids , only : nakx , aky implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( out ) :: dgdy integer :: it , iz , ikx do it = 1 , ntubes do iz = - nzgrid , nzgrid do ikx = 1 , nakx dgdy (:, ikx , iz , it ) = zi * aky (:) * g (:, ikx , iz , it ) end do end do end do end subroutine get_dgdy_3d !> compute dg/dy in k-space !> accepts g(ky,kx,z,tube,(vpa,mu,spec)) subroutine get_dgdy_4d ( g , dgdy ) use constants , only : zi use stella_layouts , only : vmu_lo use zgrid , only : nzgrid , ntubes use kt_grids , only : nakx , aky implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( out ) :: dgdy integer :: ivmu , ikx , iz , it do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid do ikx = 1 , nakx dgdy (:, ikx , iz , it , ivmu ) = zi * aky (:) * g (:, ikx , iz , it , ivmu ) end do end do end do end do end subroutine get_dgdy_4d !> compute dg/dx in k-space !> accepts g(ky,kx) subroutine get_dgdx_2d ( g , dgdx ) use constants , only : zi use kt_grids , only : naky , akx implicit none complex , dimension (:, :), intent ( in ) :: g complex , dimension (:, :), intent ( out ) :: dgdx dgdx = zi * spread ( akx , 1 , naky ) * g end subroutine get_dgdx_2d !> compute dg/dx in k-space !> accepts g(ky,kx,z,tube) subroutine get_dgdx_3d ( g , dgdx ) use constants , only : zi use zgrid , only : nzgrid , ntubes use kt_grids , only : akx , nakx implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( out ) :: dgdx integer :: ikx , iz , it do it = 1 , ntubes do iz = - nzgrid , nzgrid do ikx = 1 , nakx dgdx (:, ikx , iz , it ) = zi * akx ( ikx ) * g (:, ikx , iz , it ) end do end do end do end subroutine get_dgdx_3d !> compute dg/dx in k-space !> accepts g(ky,kx,z,tube,(vpa,mu,spec)) subroutine get_dgdx_4d ( g , dgdx ) use constants , only : zi use stella_layouts , only : vmu_lo use zgrid , only : nzgrid , ntubes use kt_grids , only : akx , nakx implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( out ) :: dgdx integer :: ivmu , ikx , iz , it do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid do ikx = 1 , nakx dgdx (:, ikx , iz , it , ivmu ) = zi * akx ( ikx ) * g (:, ikx , iz , it , ivmu ) end do end do end do end do end subroutine get_dgdx_4d subroutine add_explicit_term ( g , pre_factor , src ) use stella_layouts , only : vmu_lo use zgrid , only : nzgrid , ntubes use kt_grids , only : naky , nakx implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g real , dimension ( - nzgrid :, vmu_lo % llim_proc :), intent ( in ) :: pre_factor complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: src integer :: ivmu integer :: iky , ikx , iz , it do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid do ikx = 1 , nakx do iky = 1 , naky src ( iky , ikx , iz , it , ivmu ) = src ( iky , ikx , iz , it , ivmu ) + pre_factor ( iz , ivmu ) * g ( iky , ikx , iz , it , ivmu ) end do end do end do end do end do end subroutine add_explicit_term !> add vM . grad y d<phi>/dy or vM . grad x d<phi>/dx (or equivalents with g) or omega_* * d<phi>/dy term to RHS of GK equation subroutine add_explicit_term_ffs ( g , pre_factor , src ) use stella_layouts , only : vmu_lo use zgrid , only : nzgrid , ntubes use kt_grids , only : ikx_max , nalpha implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g real , dimension (:, - nzgrid :, vmu_lo % llim_proc :), intent ( in ) :: pre_factor complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: src integer :: ivmu integer :: ia , ikx , iz , it do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid do ikx = 1 , ikx_max do ia = 1 , nalpha src ( ia , ikx , iz , it , ivmu ) = src ( ia , ikx , iz , it , ivmu ) + pre_factor ( ia , iz , ivmu ) * g ( ia , ikx , iz , it , ivmu ) end do end do end do end do end do end subroutine add_explicit_term_ffs subroutine advance_implicit ( istep , phi , apar , bpar , g ) use mp , only : proc0 use job_manage , only : time_message use stella_layouts , only : vmu_lo use zgrid , only : nzgrid use dissipation , only : hyper_dissipation use hyper , only : advance_hyper_dissipation use physics_flags , only : include_parallel_streaming use physics_flags , only : radial_variation , full_flux_surface use physics_flags , only : include_mirror , prp_shear_enabled use run_parameters , only : stream_implicit , mirror_implicit , drifts_implicit use implicit_solve , only : advance_implicit_terms use fields , only : advance_fields , fields_updated use mirror_terms , only : advance_mirror_implicit use dissipation , only : collisions_implicit , include_collisions use dissipation , only : advance_collisions_implicit use run_parameters , only : driftkinetic_implicit use flow_shear , only : advance_perp_flow_shear use multibox , only : RK_step implicit none integer , intent ( in ) :: istep complex , dimension (:, :, - nzgrid :, :), intent ( in out ) :: phi , apar , bpar complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: g !    complex, dimension (:,:,-nzgrid:,:,vmu_lo%llim_proc:), intent (in out), target :: g !    complex, dimension (:,:,:,:,:), pointer :: gk, gy !    complex, dimension (:,:,:,:,:), allocatable, target :: g_dual !    ! the 'g' that enters this subroutine may be in alpha-space or kalpha-space !    ! figure out which it is !    if (size(g,1) == naky) then !       alpha_space = .false. !       gk => g !       if (full_flux_surface) then !          allocate (g_dual(nalpha,nakx,-nzgrid:nzgrid,vmu_lo%llim_proc:vmu_lo%ulim_alloc)) !          gy => g_dual !       end if !    else !       alpha_space = .true. !       allocate (g_dual(naky,nakx,-nzgrid:nzgrid,vmu_lo%llim_proc:vmu_lo%ulim_alloc)) !       gy => g !       gk => g_dual !    end if ! start the timer for the implicit part of the solve if ( proc0 ) call time_message (. false ., time_gke (:, 9 ), ' implicit' ) ! reverse the order of operations every time step ! as part of alternating direction operator splitting ! this is needed to ensure 2nd order accuracy in time !    if (mod(istep,2)==0) then ! g&#94;{*} (coming from explicit solve) is input ! get g&#94;{**}, with g&#94;{**}-g&#94;{*} due to mirror term if ( RK_step ) call mb_communicate ( g ) if ( mod ( istep , 2 ) == 1 . or . . not . flip_flop ) then if ( prp_shear_enabled ) then call advance_perp_flow_shear ( g ) fields_updated = . false . end if if ( hyper_dissipation ) then !          ! for hyper-dissipation, need to be in k-alpha space !          if (alpha_space) call transform_y2ky (gy, gk) call advance_hyper_dissipation ( g ) fields_updated = . false . end if if ( collisions_implicit . and . include_collisions ) then call advance_fields ( g , phi , apar , bpar , dist = 'g' ) call advance_collisions_implicit ( mirror_implicit , phi , apar , bpar , g ) fields_updated = . false . end if if ( mirror_implicit . and . include_mirror ) then !          if (full_flux_surface) then !             allocate (gy(ny,nakx,-nzgrid:nzgrid,ntubes,vmu_lo%llim_proc:vmu_lo%ulim_alloc)) !             if (.not.alpha_space) call transform_ky2y (g, gy) !          else !             g_mirror => g !          end if call advance_mirror_implicit ( collisions_implicit , g , apar ) fields_updated = . false . end if ! get updated fields corresponding to advanced g ! note that hyper-dissipation and mirror advances ! depended only on g and so did not need field update call advance_fields ( g , phi , apar , bpar , dist = 'g' ) ! g&#94;{**} is input ! get g&#94;{***}, with g&#94;{***}-g&#94;{**} due to parallel streaming term if (( stream_implicit . or . driftkinetic_implicit ) . and . include_parallel_streaming ) then call advance_implicit_terms ( g , phi , apar , bpar ) if ( radial_variation . or . full_flux_surface ) fields_updated = . false . end if ! update the fields if not already updated call advance_fields ( g , phi , apar , bpar , dist = 'g' ) else ! get updated fields corresponding to advanced g ! note that hyper-dissipation ! depends only on g and so does not need field update call advance_fields ( g , phi , apar , bpar , dist = 'g' ) ! g&#94;{**} is input ! get g&#94;{***}, with g&#94;{***}-g&#94;{**} due to parallel streaming term if (( stream_implicit . or . driftkinetic_implicit ) . and . include_parallel_streaming ) then call advance_implicit_terms ( g , phi , apar , bpar ) if ( radial_variation . or . full_flux_surface ) fields_updated = . false . end if if ( mirror_implicit . and . include_mirror ) then call advance_mirror_implicit ( collisions_implicit , g , apar ) fields_updated = . false . end if if ( collisions_implicit . and . include_collisions ) then call advance_fields ( g , phi , apar , bpar , dist = 'g' ) call advance_collisions_implicit ( mirror_implicit , phi , apar , bpar , g ) fields_updated = . false . end if if ( hyper_dissipation ) then call advance_hyper_dissipation ( g ) fields_updated = . false . end if if ( prp_shear_enabled ) then call advance_perp_flow_shear ( g ) fields_updated = . false . end if end if ! stop the timer for the implict part of the solve if ( proc0 ) call time_message (. false ., time_gke (:, 9 ), ' implicit' ) end subroutine advance_implicit subroutine mb_communicate ( g_in ) use mp , only : job use stella_layouts , only : vmu_lo use zgrid , only : nzgrid use multibox , only : multibox_communicate , use_dirichlet_bc , apply_radial_boundary_conditions use fields , only : fields_updated , advance_fields use fields_arrays , only : phi , apar , bpar use file_utils , only : runtype_option_switch , runtype_multibox implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: g_in if ( runtype_option_switch == runtype_multibox ) then if ( job /= 1 ) then call advance_fields ( g_in , phi , apar , bpar , dist = 'g' ) end if call multibox_communicate ( g_in ) if ( job == 1 ) then fields_updated = . false . call advance_fields ( g_in , phi , apar , bpar , dist = 'g' ) end if else if ( use_dirichlet_BC ) then call apply_radial_boundary_conditions ( g_in ) fields_updated = . false . call advance_fields ( g_in , phi , apar , bpar , dist = 'g' ) end if end subroutine mb_communicate subroutine checksum_field ( field , total ) use zgrid , only : nzgrid , ntubes use kt_grids , only : naky use extended_zgrid , only : neigen , nsegments , ikxmod use extended_zgrid , only : iz_low , iz_up implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: field real , intent ( out ) :: total integer :: it , iky , ie , iseg integer :: ikx total = 0. do iky = 1 , naky do it = 1 , ntubes do ie = 1 , neigen ( iky ) iseg = 1 ikx = ikxmod ( iseg , ie , iky ) total = total + sum ( cabs ( field ( iky , ikx , iz_low ( iseg ): iz_up ( iseg ), it ))) if ( nsegments ( ie , iky ) > 1 ) then do iseg = 2 , nsegments ( ie , iky ) ikx = ikxmod ( iseg , ie , iky ) total = total + sum ( cabs ( field ( iky , ikx , iz_low ( iseg ) + 1 : iz_up ( iseg ), it ))) end do end if end do end do end do end subroutine checksum_field subroutine checksum_dist ( dist , total , norm ) use mp , only : sum_allreduce use zgrid , only : nzgrid , ntubes use stella_layouts , only : vmu_lo , iv_idx , imu_idx , is_idx use kt_grids , only : naky , nakx use vpamu_grids , only : maxwell_vpa , maxwell_mu implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: dist real , intent ( out ) :: total logical , intent ( in ), optional :: norm integer :: ivmu , iv , imu , is integer :: iky , ikx , it real :: subtotal complex , dimension (:, :, :, :), allocatable :: dist_single total = 0. allocate ( dist_single ( naky , nakx , - nzgrid : nzgrid , ntubes )) do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc dist_single = dist (:, :, :, :, ivmu ) if ( present ( norm )) then if ( norm ) then iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) do it = 1 , ntubes do ikx = 1 , nakx do iky = 1 , naky dist_single ( iky , ikx , :, it ) = dist_single ( iky , ikx , :, it ) * maxwell_vpa ( iv , is ) * maxwell_mu ( 1 , :, imu , is ) end do end do end do else end if end if call checksum ( dist_single , subtotal ) total = total + subtotal end do deallocate ( dist_single ) call sum_allreduce ( total ) end subroutine checksum_dist subroutine finish_time_advance use stella_transforms , only : finish_transforms use physics_flags , only : full_flux_surface use extended_zgrid , only : finish_extended_zgrid use parallel_streaming , only : finish_parallel_streaming use mirror_terms , only : finish_mirror use flow_shear , only : finish_flow_shear use neoclassical_terms , only : finish_neoclassical_terms use dissipation , only : finish_dissipation implicit none if ( full_flux_surface ) call finish_transforms call finish_dissipation call finish_parallel_nonlinearity call finish_wstar call finish_wdrift call finish_parallel_streaming call finish_flow_shear call finish_mirror call finish_neoclassical_terms call deallocate_arrays time_advance_initialized = . false . readinit = . false . end subroutine finish_time_advance subroutine finish_parallel_nonlinearity implicit none if ( allocated ( par_nl_fac )) deallocate ( par_nl_fac ) if ( allocated ( par_nl_curv )) deallocate ( par_nl_curv ) if ( allocated ( par_nl_driftx )) deallocate ( par_nl_driftx ) if ( allocated ( par_nl_drifty )) deallocate ( par_nl_drifty ) parnlinit = . false . end subroutine finish_parallel_nonlinearity subroutine finish_wdrift use dist_fn_arrays , only : wdriftx_g , wdrifty_g use dist_fn_arrays , only : wdriftx_phi , wdrifty_phi use dist_fn_arrays , only : wdriftpx_g , wdriftpy_g use dist_fn_arrays , only : wdriftpx_phi , wdriftpy_phi !   use dist_fn_arrays, only: adiabatic_phi implicit none if ( allocated ( wdriftx_g )) deallocate ( wdriftx_g ) if ( allocated ( wdrifty_g )) deallocate ( wdrifty_g ) if ( allocated ( wdriftx_phi )) deallocate ( wdriftx_phi ) if ( allocated ( wdrifty_phi )) deallocate ( wdrifty_phi ) if ( allocated ( wdriftpx_g )) deallocate ( wdriftpx_g ) if ( allocated ( wdriftpy_g )) deallocate ( wdriftpy_g ) if ( allocated ( wdriftpx_phi )) deallocate ( wdriftpx_phi ) if ( allocated ( wdriftpy_phi )) deallocate ( wdriftpy_phi ) !   if (allocated(adiabatic_phi)) deallocate (adiabatic_phi) wdriftinit = . false . end subroutine finish_wdrift subroutine finish_wstar use dist_fn_arrays , only : wstar , wstarp implicit none if ( allocated ( wstar )) deallocate ( wstar ) if ( allocated ( wstarp )) deallocate ( wstarp ) wstarinit = . false . end subroutine finish_wstar subroutine deallocate_arrays use dist_fn_arrays , only : g0 , g1 , g2 , g3 implicit none if ( allocated ( g0 )) deallocate ( g0 ) if ( allocated ( g1 )) deallocate ( g1 ) if ( allocated ( g2 )) deallocate ( g2 ) if ( allocated ( g3 )) deallocate ( g3 ) end subroutine deallocate_arrays end module time_advance","tags":"","loc":"sourcefile/time_advance.f90.html"},{"title":"finite_differences.f90 – stella","text":"Source Code module finite_differences implicit none public :: first_order_upwind public :: third_order_upwind public :: fifth_order_upwind public :: third_order_upwind_zed public :: first_order_upwind_zed public :: second_order_centered public :: fourth_order_centered public :: second_order_centered_zed public :: four_point_triangle public :: fd3pt , fd5pt public :: d2_3pt public :: fd_variable_upwinding_vpa public :: fd_variable_upwinding_zed public :: fd_cell_centres_zed , cell_centres_zed interface fd3pt module procedure fd3pt_real module procedure fd3pt_real_array module procedure fd3pt_complex_array end interface interface fd5pt module procedure fd5pt_real module procedure fd5pt_array end interface interface first_order_upwind module procedure first_order_upwind_real module procedure first_order_upwind_complex end interface interface third_order_upwind module procedure third_order_upwind_complex module procedure third_order_upwind_real end interface interface fifth_order_upwind module procedure fifth_order_upwind_complex module procedure fifth_order_upwind_real end interface interface tridag module procedure tridag_real module procedure tridag_complex end interface interface second_order_centered module procedure second_order_centered_real module procedure second_order_centered_complex end interface interface four_point_triangle module procedure four_point_triangle_real module procedure four_point_triangle_complex end interface interface fourth_order_centered module procedure fourth_order_centered_real module procedure fourth_order_centered_complex end interface interface second_order_centered_zed module procedure second_order_centered_zed_real module procedure second_order_centered_zed_complex end interface interface d2_3pt module procedure d2_3pt_real module procedure d2_3pt_complex end interface contains subroutine first_order_upwind_real ( llim , f , del , sgn , df ) implicit none integer , intent ( in ) :: llim real , dimension ( llim :), intent ( in ) :: f real , intent ( in ) :: del integer , intent ( in ) :: sgn real , dimension ( llim :), intent ( out ) :: df integer :: i , n , istart , iend n = size ( f ) if ( sgn == - 1 ) then istart = llim iend = llim + n - 1 else istart = llim + n - 1 iend = llim end if ! zero BC, 1st order accurate upwind df ( istart ) = - f ( istart ) * sgn / del do i = istart - sgn , iend , - sgn df ( i ) = sgn * ( f ( i + sgn ) - f ( i )) / del end do end subroutine first_order_upwind_real subroutine first_order_upwind_complex ( llim , f , del , sgn , df ) implicit none integer , intent ( in ) :: llim complex , dimension ( llim :), intent ( in ) :: f real , intent ( in ) :: del integer , intent ( in ) :: sgn complex , dimension ( llim :), intent ( out ) :: df integer :: i , n , istart , iend n = size ( f ) if ( sgn == - 1 ) then istart = llim iend = llim + n - 1 else istart = llim + n - 1 iend = llim end if ! zero BC, 1st order accurate upwind df ( istart ) = - f ( istart ) * sgn / del do i = istart - sgn , iend , - sgn df ( i ) = sgn * ( f ( i + sgn ) - f ( i )) / del end do end subroutine first_order_upwind_complex subroutine third_order_upwind_complex ( llim , f , del , sgn , df ) implicit none integer , intent ( in ) :: llim complex , dimension ( llim :), intent ( in ) :: f real , intent ( in ) :: del integer , intent ( in ) :: sgn complex , dimension ( llim :), intent ( out ) :: df integer :: i , n , istart , iend n = size ( f ) if ( sgn == - 1 ) then istart = llim iend = llim + n - 1 else istart = llim + n - 1 iend = llim end if i = istart - sgn ! zero BC, 1st order accurate upwind df ( istart ) = - f ( istart ) * sgn / del ! zero BC, 3rd order accurate upwind df ( i ) = - sgn * ( 2. * f ( i - sgn ) + 3. * f ( i ) - 6. * f ( i + sgn )) / ( 6. * del ) ! 1st order accurate upwind df ( iend ) = sgn * ( f ( iend + sgn ) - f ( iend )) / del ! 3rd order accurate upwind do i = istart - 2 * sgn , iend + sgn , - sgn df ( i ) = - sgn * ( 2. * f ( i - sgn ) + 3 * f ( i ) - 6. * f ( i + sgn ) + f ( i + 2 * sgn )) / ( 6. * del ) end do end subroutine third_order_upwind_complex subroutine third_order_upwind_real ( llim , f , del , sgn , df ) implicit none integer , intent ( in ) :: llim real , dimension ( llim :), intent ( in ) :: f real , intent ( in ) :: del integer , intent ( in ) :: sgn real , dimension ( llim :), intent ( out ) :: df integer :: i , n , istart , iend n = size ( f ) if ( sgn == - 1 ) then istart = llim iend = llim + n - 1 else istart = llim + n - 1 iend = llim end if i = istart - sgn ! zero BC, 1st order accurate upwind df ( istart ) = - f ( istart ) * sgn / del ! zero BC, 3rd order accurate upwind df ( i ) = - sgn * ( 2. * f ( i - sgn ) + 3. * f ( i ) - 6. * f ( i + sgn )) / ( 6. * del ) ! 1st order accurate upwind df ( iend ) = sgn * ( f ( iend + sgn ) - f ( iend )) / del ! 3rd order accurate upwind do i = istart - 2 * sgn , iend + sgn , - sgn df ( i ) = - sgn * ( 2. * f ( i - sgn ) + 3 * f ( i ) - 6. * f ( i + sgn ) + f ( i + 2 * sgn )) / ( 6. * del ) end do end subroutine third_order_upwind_real subroutine fifth_order_upwind_complex ( llim , f , del , sgn , df ) implicit none integer , intent ( in ) :: llim complex , dimension ( llim :), intent ( in ) :: f real , intent ( in ) :: del integer , intent ( in ) :: sgn complex , dimension ( llim :), intent ( out ) :: df integer :: i , n , istart , iend n = size ( f ) if ( sgn == - 1 ) then istart = llim iend = llim + n - 1 else istart = llim + n - 1 iend = llim end if ! zero BC, 1st order accurate upwind df ( istart ) = - f ( istart ) * sgn / del ! zero BC, 3rd order accurate upwind i = istart - sgn df ( i ) = - sgn * ( 2. * f ( i - sgn ) + 3. * f ( i ) - 6. * f ( i + sgn )) / ( 6. * del ) ! zero BC, 5th order accurate upwind i = istart - 2 * sgn df ( i ) = - sgn * ( - 3. * f ( i - 2 * sgn ) + 3 0. * f ( i - sgn ) + 2 0. * f ( i ) - 6 0. * f ( i + sgn ) + 1 5. * f ( i + 2 * sgn )) / ( 6 0. * del ) ! 1st order accurate upwind df ( iend ) = sgn * ( f ( iend + sgn ) - f ( iend )) / del ! 3rd order accurate upwind df ( iend + sgn ) = - sgn * ( 2. * f ( iend ) + 3 * f ( iend + sgn ) - 6. * f ( iend + 2 * sgn ) + f ( iend + 3 * sgn )) / ( 6. * del ) ! 5th order accurate upwind do i = istart - 3 * sgn , iend + 2 * sgn , - sgn df ( i ) = - sgn * ( - 3. * f ( i - 2 * sgn ) + 3 0. * f ( i - sgn ) + 2 0. * f ( i ) - 6 0. * f ( i + sgn ) + 1 5. * f ( i + 2 * sgn ) - 2. * f ( i + 3 * sgn )) & / ( 6 0. * del ) end do end subroutine fifth_order_upwind_complex subroutine fifth_order_upwind_real ( llim , f , del , sgn , df ) implicit none integer , intent ( in ) :: llim real , dimension ( llim :), intent ( in ) :: f real , intent ( in ) :: del integer , intent ( in ) :: sgn real , dimension ( llim :), intent ( out ) :: df integer :: i , n , istart , iend n = size ( f ) if ( sgn == - 1 ) then istart = llim iend = llim + n - 1 else istart = llim + n - 1 iend = llim end if ! zero BC, 1st order accurate upwind df ( istart ) = - f ( istart ) * sgn / del ! zero BC, 3rd order accurate upwind i = istart - sgn df ( i ) = - sgn * ( 2. * f ( i - sgn ) + 3. * f ( i ) - 6. * f ( i + sgn )) / ( 6. * del ) ! zero BC, 5th order accurate upwind i = istart - 2 * sgn df ( i ) = - sgn * ( - 3. * f ( i - 2 * sgn ) + 3 0. * f ( i - sgn ) + 2 0. * f ( i ) - 6 0. * f ( i + sgn ) + 1 5. * f ( i + 2 * sgn )) / ( 6 0. * del ) ! 1st order accurate upwind df ( iend ) = - sgn * ( f ( iend ) - f ( iend + sgn )) / del ! 3rd order accurate upwind df ( iend + sgn ) = - sgn * ( 2. * f ( iend ) + 3 * f ( iend + sgn ) - 6. * f ( iend + 2 * sgn ) + f ( iend + 3 * sgn )) / ( 6. * del ) ! 5th order accurate upwind do i = istart - 3 * sgn , iend + 2 * sgn , - sgn df ( i ) = - sgn * ( - 3. * f ( i - 2 * sgn ) + 3 0. * f ( i - sgn ) + 2 0. * f ( i ) - 6 0. * f ( i + sgn ) + 1 5. * f ( i + 2 * sgn ) - 2. * f ( i + 3 * sgn )) & / ( 6 0. * del ) end do end subroutine fifth_order_upwind_real subroutine third_order_upwind_zed ( llim , iseg , nseg , f , del , sgn , fl , fr , periodic , df ) implicit none integer , intent ( in ) :: llim , iseg , nseg complex , dimension ( llim :), intent ( in ) :: f real , intent ( in ) :: del integer , intent ( in ) :: sgn logical , intent ( in ) :: periodic complex , dimension (:), intent ( in ) :: fl , fr complex , dimension ( llim :), intent ( out ) :: df integer :: i , istart , iend , ulim ulim = size ( f ) + llim - 1 ! if sgn > 0, then stream speed is negative ! so sweep from more positive to more negative zed if ( sgn > 0 ) then if ( iseg == nseg . and . . not . periodic ) then i = ulim df ( i ) = - f ( i ) / del i = ulim - 1 df ( i ) = - ( 2. * f ( i - 1 ) + 3. * f ( i ) - 6. * f ( i + 1 )) / ( 6. * del ) else i = ulim df ( i ) = - ( 2. * f ( i - 1 ) + 3. * f ( i ) - 6. * fr ( 1 ) + fr ( 2 )) / ( 6. * del ) i = ulim - 1 df ( i ) = - ( 2. * f ( i - 1 ) + 3. * f ( i ) - 6. * f ( i + 1 ) + fr ( 1 )) / ( 6. * del ) end if if ( iseg == 1 . and . . not . periodic ) then i = llim df ( i ) = ( f ( i + 1 ) - f ( i )) / del else i = llim df ( i ) = - ( 2. * fl ( 2 ) + 3 * f ( i ) - 6. * f ( i + 1 ) + f ( i + 2 )) / ( 6. * del ) end if istart = ulim iend = llim else if ( iseg == 1 . and . . not . periodic ) then i = llim df ( i ) = f ( i ) / del i = llim + 1 df ( i ) = ( 2. * f ( i + 1 ) + 3. * f ( i ) - 6. * f ( i - 1 )) / ( 6. * del ) else i = llim df ( i ) = ( 2. * f ( i + 1 ) + 3 * f ( i ) - 6. * fl ( 2 ) + fl ( 1 )) / ( 6. * del ) i = llim + 1 df ( i ) = ( 2. * f ( i + 1 ) + 3 * f ( i ) - 6. * f ( i - 1 ) + fl ( 2 )) / ( 6. * del ) end if if ( iseg == nseg . and . . not . periodic ) then i = ulim df ( i ) = ( f ( i ) - f ( i - 1 )) / del else i = ulim df ( i ) = ( 2. * fr ( 1 ) + 3 * f ( i ) - 6. * f ( i - 1 ) + f ( i - 2 )) / ( 6. * del ) end if istart = llim iend = ulim end if ! 3rd order accurate upwind do i = istart - 2 * sgn , iend + sgn , - sgn df ( i ) = - sgn * ( 2. * f ( i - sgn ) + 3 * f ( i ) - 6. * f ( i + sgn ) + f ( i + 2 * sgn )) / ( 6. * del ) end do end subroutine third_order_upwind_zed subroutine first_order_upwind_zed ( llim , iseg , nseg , f , del , sgn , fl , fr , periodic , df ) implicit none integer , intent ( in ) :: llim , iseg , nseg complex , dimension ( llim :), intent ( in ) :: f real , intent ( in ) :: del integer , intent ( in ) :: sgn logical , intent ( in ) :: periodic complex , dimension (:), intent ( in ) :: fl , fr complex , dimension ( llim :), intent ( out ) :: df integer :: i , istart , iend , ulim ulim = size ( f ) + llim - 1 ! if sgn > 0, then stream speed is negative ! so sweep from more positive to more negative zed if ( sgn > 0 ) then if ( iseg == nseg . and . . not . periodic ) then i = ulim df ( i ) = - f ( i ) / del i = ulim - 1 df ( i ) = ( f ( i + 1 ) - f ( i )) / del else i = ulim df ( i ) = ( fr ( 1 ) - f ( i )) / del i = ulim - 1 df ( i ) = ( f ( i + 1 ) - f ( i )) / del end if i = llim df ( i ) = ( f ( i + 1 ) - f ( i )) / del istart = ulim iend = llim else if ( iseg == 1 . and . . not . periodic ) then i = llim df ( i ) = f ( i ) / del i = llim + 1 df ( i ) = ( f ( i ) - f ( i - 1 )) / del else i = llim df ( i ) = ( f ( i ) - fl ( 2 )) / del i = llim + 1 df ( i ) = ( f ( i ) - f ( i - 1 )) / del end if i = ulim df ( i ) = ( f ( i ) - f ( i - 1 )) / del istart = llim iend = ulim end if ! 3rd order accurate upwind do i = istart - 2 * sgn , iend + sgn , - sgn df ( i ) = sgn * ( f ( i + sgn ) - f ( i )) / del end do end subroutine first_order_upwind_zed subroutine second_order_centered_real ( llim , f , del , df ) implicit none integer , intent ( in ) :: llim real , dimension ( llim :), intent ( in ) :: f real , intent ( in ) :: del real , dimension ( llim :), intent ( out ) :: df integer :: i , n , istart , iend n = size ( f ) istart = llim iend = llim + n - 1 ! zero BC df ( istart ) = f ( istart + 1 ) / ( 2. * del ) df ( iend ) = - f ( iend - 1 ) / ( 2. * del ) ! 2nd order accurate centered do i = istart + 1 , iend - 1 df ( i ) = ( f ( i + 1 ) - f ( i - 1 )) / ( 2. * del ) end do end subroutine second_order_centered_real subroutine second_order_centered_complex ( llim , f , del , df ) implicit none integer , intent ( in ) :: llim complex , dimension ( llim :), intent ( in ) :: f real , intent ( in ) :: del complex , dimension ( llim :), intent ( out ) :: df integer :: i , n , istart , iend n = size ( f ) istart = llim iend = llim + n - 1 ! zero BC df ( istart ) = f ( istart + 1 ) / ( 2. * del ) df ( iend ) = - f ( iend - 1 ) / ( 2. * del ) ! 2nd order accurate centered do i = istart + 1 , iend - 1 df ( i ) = ( f ( i + 1 ) - f ( i - 1 )) / ( 2. * del ) end do end subroutine second_order_centered_complex subroutine four_point_triangle_real ( llim , f , del , df ) implicit none integer , intent ( in ) :: llim real , dimension ( llim :), intent ( in ) :: f real , intent ( in ) :: del real , dimension ( llim :), intent ( out ) :: df integer :: i , n , istart , iend n = size ( f ) istart = llim iend = llim + n - 1 ! zero BC i = istart df ( i ) = f ( i + 1 ) / ( 2.0 * del ) i = istart + 1 df ( i ) = ( f ( i + 1 ) - f ( i - 1 )) / ( 2.0 * del ) i = istart + 2 df ( i ) = ( - 2. * f ( i + 3 ) + 9. * f ( i + 1 ) - 9. * f ( i - 1 )) / ( 1 8.0 * del ) i = iend df ( i ) = - f ( i - 1 ) / ( 2.0 * del ) i = iend - 1 df ( i ) = ( f ( i + 1 ) - f ( i - 1 )) / ( 2.0 * del ) i = iend - 2 df ( i ) = ( 9. * f ( i + 1 ) - 9. * f ( i - 1 ) + 2. * f ( i - 3 )) / ( 1 8.0 * del ) ! 2nd order accurate centered do i = istart + 3 , iend - 3 df ( i ) = ( - 2. * f ( i + 3 ) + 9. * f ( i + 1 ) - 9. * f ( i - 1 ) + 2. * f ( i - 3 )) / ( 1 8.0 * del ) end do end subroutine four_point_triangle_real subroutine four_point_triangle_complex ( llim , f , del , df ) implicit none integer , intent ( in ) :: llim complex , dimension ( llim :), intent ( in ) :: f real , intent ( in ) :: del complex , dimension ( llim :), intent ( out ) :: df integer :: i , n , istart , iend n = size ( f ) istart = llim iend = llim + n - 1 ! zero BC i = istart df ( i ) = f ( i + 1 ) / ( 2.0 * del ) i = istart + 1 df ( i ) = ( f ( i + 1 ) - f ( i - 1 )) / ( 2.0 * del ) i = istart + 2 df ( i ) = ( - 2. * f ( i + 3 ) + 9. * f ( i + 1 ) - 9. * f ( i - 1 )) / ( 1 8.0 * del ) i = iend df ( i ) = - f ( i - 1 ) / ( 2.0 * del ) i = iend - 1 df ( i ) = ( f ( i + 1 ) - f ( i - 1 )) / ( 2.0 * del ) i = iend - 2 df ( i ) = ( 9. * f ( i + 1 ) - 9. * f ( i - 1 ) + 2. * f ( i - 3 )) / ( 1 8.0 * del ) ! 2nd order accurate centered do i = istart + 3 , iend - 3 df ( i ) = ( - 2. * f ( i + 3 ) + 9. * f ( i + 1 ) - 9. * f ( i - 1 ) + 2. * f ( i - 3 )) / ( 1 8.0 * del ) end do end subroutine four_point_triangle_complex subroutine fourth_order_centered_real ( llim , f , del , df ) implicit none integer , intent ( in ) :: llim real , dimension ( llim :), intent ( in ) :: f real , intent ( in ) :: del real , dimension ( llim :), intent ( out ) :: df integer :: i , n , istart , iend n = size ( f ) istart = llim iend = llim + n - 1 ! zero BC ! 2nd order accurate centered df ( istart ) = f ( istart + 1 ) / ( 2. * del ) df ( iend ) = - f ( iend - 1 ) / ( 2. * del ) ! 4th order accurate centered df ( istart + 1 ) = ( f ( istart + 3 ) - 8. * f ( istart + 2 ) + 8. * f ( istart )) / ( 1 2. * del ) df ( iend - 1 ) = ( - 8 * f ( iend ) + 8. * f ( iend - 2 ) - f ( iend - 3 )) / ( 1 2. * del ) ! 4th order accurate centered do i = istart + 2 , iend - 2 df ( i ) = ( f ( i + 2 ) - 8. * f ( i + 1 ) + 8. * f ( i - 1 ) - f ( i - 2 )) / ( 1 2. * del ) end do end subroutine fourth_order_centered_real subroutine fourth_order_centered_complex ( llim , f , del , df ) implicit none integer , intent ( in ) :: llim complex , dimension ( llim :), intent ( in ) :: f real , intent ( in ) :: del complex , dimension ( llim :), intent ( out ) :: df integer :: i , n , istart , iend n = size ( f ) istart = llim iend = llim + n - 1 ! zero BC ! 2nd order accurate centered df ( istart ) = f ( istart + 1 ) / ( 2. * del ) df ( iend ) = - f ( iend - 1 ) / ( 2. * del ) ! 4th order accurate centered df ( istart + 1 ) = ( f ( istart + 3 ) - 8. * f ( istart + 2 ) + 8. * f ( istart )) / ( 1 2. * del ) df ( iend - 1 ) = ( - 8 * f ( iend ) + 8. * f ( iend - 2 ) - f ( iend - 3 )) / ( 1 2. * del ) ! 4th order accurate centered do i = istart + 2 , iend - 2 df ( i ) = ( f ( i + 2 ) - 8. * f ( i + 1 ) + 8. * f ( i - 1 ) - f ( i - 2 )) / ( 1 2. * del ) end do end subroutine fourth_order_centered_complex subroutine second_order_centered_zed_real ( llim , iseg , nseg , f , del , sgn , fl , fr , periodic , df ) implicit none integer , intent ( in ) :: llim , iseg , nseg real , dimension ( llim :), intent ( in ) :: f integer , intent ( in ) :: sgn real , intent ( in ) :: del real , dimension (:), intent ( in ) :: fl , fr logical , intent ( in ) :: periodic real , dimension ( llim :), intent ( out ) :: df integer :: i , ulim ulim = size ( f ) + llim - 1 i = llim if ( iseg == 1 . and . sgn > 0 . and . . not . periodic ) then ! sgn > 0 corresponds to negative advection speed ! upwind at boundary requires taking information from right df ( i ) = ( f ( i + 1 ) - f ( i )) / del else df ( i ) = 0.5 * ( f ( i + 1 ) - fl ( 2 )) / del end if i = ulim if ( iseg == nseg . and . sgn < 0 . and . . not . periodic ) then ! sgn < 0 corresponds to positive advection speed ! upwind at boundary requires taking information from left df ( i ) = ( f ( i ) - f ( i - 1 )) / del else df ( i ) = 0.5 * ( fr ( 1 ) - f ( i - 1 )) / del end if do i = llim + 1 , ulim - 1 df ( i ) = 0.5 * ( f ( i + 1 ) - f ( i - 1 )) / del end do end subroutine second_order_centered_zed_real subroutine second_order_centered_zed_complex ( llim , iseg , nseg , f , del , sgn , fl , fr , periodic , df ) implicit none integer , intent ( in ) :: llim , iseg , nseg complex , dimension ( llim :), intent ( in ) :: f integer , intent ( in ) :: sgn real , intent ( in ) :: del complex , dimension (:), intent ( in ) :: fl , fr logical , intent ( in ) :: periodic complex , dimension ( llim :), intent ( out ) :: df integer :: i , ulim ulim = size ( f ) + llim - 1 i = llim if ( iseg == 1 . and . sgn > 0 . and . . not . periodic ) then ! sgn > 0 corresponds to negative advection speed ! upwind at boundary requires taking information from right df ( i ) = ( f ( i + 1 ) - f ( i )) / del else df ( i ) = 0.5 * ( f ( i + 1 ) - fl ( 2 )) / del end if i = ulim if ( iseg == nseg . and . sgn < 0 . and . . not . periodic ) then ! sgn < 0 corresponds to positive advection speed ! upwind at boundary requires taking information from left df ( i ) = ( f ( i ) - f ( i - 1 )) / del else df ( i ) = 0.5 * ( fr ( 1 ) - f ( i - 1 )) / del end if do i = llim + 1 , ulim - 1 df ( i ) = 0.5 * ( f ( i + 1 ) - f ( i - 1 )) / del end do end subroutine second_order_centered_zed_complex subroutine second_order_centered_vpa ( llim , f , del , df ) implicit none integer , intent ( in ) :: llim complex , dimension ( llim :), intent ( in ) :: f real , intent ( in ) :: del complex , dimension ( llim :), intent ( out ) :: df integer :: i , ulim ulim = size ( f ) + llim - 1 i = llim df ( i ) = 0.5 * f ( i + 1 ) / del i = ulim df ( i ) = - 0.5 * f ( i - 1 ) / del do i = llim + 1 , ulim - 1 df ( i ) = 0.5 * ( f ( i + 1 ) - f ( i - 1 )) / del end do end subroutine second_order_centered_vpa subroutine fd_cell_centres_zed ( llim , f , del , sgn , fl , fr , df ) implicit none integer , intent ( in ) :: llim complex , dimension ( llim :), intent ( in ) :: f real , intent ( in ) :: del integer , intent ( in ) :: sgn complex , intent ( in ) :: fl , fr complex , dimension ( llim :), intent ( out ) :: df integer :: i , ulim ulim = size ( f ) + llim - 1 if ( sgn > 0 ) then ! if sgn > 0, then stream speed is negative ! so sweep from more positive to more negative zed i = ulim df ( i ) = ( fr - f ( i )) / del do i = ulim - 1 , llim , - 1 df ( i ) = ( f ( i + 1 ) - f ( i )) / del end do else ! if sgn < 0, then stream speed is positive ! so sweep from more negative to more positive zed i = llim df ( i ) = ( f ( i ) - fl ) / del do i = llim + 1 , ulim df ( i ) = ( f ( i ) - f ( i - 1 )) / del end do end if end subroutine fd_cell_centres_zed ! cell_centres_zed takes f at z grid locations ! and returns f at cell centres ! (with possible offset due to upwinding) subroutine cell_centres_zed ( llim , f , upwnd , sgn , fl , fr , fc ) implicit none integer , intent ( in ) :: llim complex , dimension ( llim :), intent ( in ) :: f real , intent ( in ) :: upwnd integer , intent ( in ) :: sgn complex , intent ( in ) :: fl , fr complex , dimension ( llim :), intent ( out ) :: fc integer :: i , ulim ulim = size ( f ) + llim - 1 if ( sgn > 0 ) then ! if sgn > 0, then stream speed is negative ! so sweep from more positive to more negative zed i = ulim fc ( i ) = 0.5 * (( 1. - upwnd ) * fr + ( 1. + upwnd ) * f ( i )) do i = ulim - 1 , llim , - 1 fc ( i ) = 0.5 * (( 1. - upwnd ) * f ( i + 1 ) + ( 1. + upwnd ) * f ( i )) end do else ! if sgn < 0, then stream speed is positive ! so sweep from more negative to more positive zed i = llim fc ( i ) = 0.5 * (( 1. + upwnd ) * f ( i ) + ( 1. - upwnd ) * fl ) do i = llim + 1 , ulim fc ( i ) = 0.5 * (( 1. + upwnd ) * f ( i ) + ( 1. - upwnd ) * f ( i - 1 )) end do end if end subroutine cell_centres_zed subroutine fd_variable_upwinding_zed ( llim , iseg , nseg , f , del , sgn , upwnd , fl , fr , periodic , df ) implicit none integer , intent ( in ) :: llim , iseg , nseg complex , dimension ( llim :), intent ( in ) :: f real , intent ( in ) :: del , upwnd integer , intent ( in ) :: sgn complex , dimension (:), intent ( in ) :: fl , fr logical , intent ( in ) :: periodic complex , dimension ( llim :), intent ( out ) :: df integer :: i , istart , iend , ulim ! if upwnd is zero or if vpa=0, then use centered differences if ( abs ( upwnd ) < epsilon ( 0. ) . or . sgn == 0 ) then call second_order_centered_zed ( llim , iseg , nseg , f , del , sgn , fl , fr , periodic , df ) else ulim = size ( f ) + llim - 1 ! if sgn > 0, then stream speed is negative ! so sweep from more positive to more negative zed if ( sgn > 0 ) then if ( iseg == nseg . and . . not . periodic ) then i = ulim df ( i ) = ( 0.5 * ( upwnd - 1. ) * f ( i - 1 ) - upwnd * f ( i )) / del else i = ulim df ( i ) = ( 0.5 * ( upwnd - 1. ) * f ( i - 1 ) - upwnd * f ( i ) + 0.5 * ( 1. + upwnd ) * fr ( 1 )) / del end if if ( iseg == 1 . and . . not . periodic ) then i = llim ! at left boundary, must upwind fully as no info for f(i-1) df ( i ) = ( f ( i + 1 ) - f ( i )) / del else i = llim df ( i ) = ( 0.5 * ( 1. + upwnd ) * f ( i + 1 ) - upwnd * f ( i ) + 0.5 * ( upwnd - 1. ) * fl ( 2 )) / del end if istart = ulim iend = llim else if ( iseg == 1 . and . . not . periodic ) then i = llim df ( i ) = ( 0.5 * ( 1. - upwnd ) * f ( i + 1 ) + upwnd * f ( i )) / del else i = llim df ( i ) = ( 0.5 * ( 1. - upwnd ) * f ( i + 1 ) + upwnd * f ( i ) - 0.5 * ( 1. + upwnd ) * fl ( 2 )) / del end if if ( iseg == nseg . and . . not . periodic ) then i = ulim ! if at rightmost zed, have no info for f(i+1) so must fully upwind df ( i ) = ( f ( i ) - f ( i - 1 )) / del else i = ulim df ( i ) = ( 0.5 * ( 1. - upwnd ) * fr ( 1 ) + upwnd * f ( i ) - 0.5 * ( 1. + upwnd ) * f ( i - 1 )) / del end if istart = llim iend = ulim end if ! mixed 2nd order centered and 1st order upwind scheme do i = istart - sgn , iend + sgn , - sgn df ( i ) = sgn * ( 0.5 * ( 1. + upwnd ) * f ( i + sgn ) - upwnd * f ( i ) + 0.5 * ( upwnd - 1. ) * f ( i - sgn )) / del end do end if end subroutine fd_variable_upwinding_zed subroutine fd_variable_upwinding_vpa ( llim , f , del , sgn , upwnd , df ) implicit none integer , intent ( in ) :: llim complex , dimension ( llim :), intent ( in ) :: f real , intent ( in ) :: del , upwnd integer , intent ( in ) :: sgn complex , dimension ( llim :), intent ( out ) :: df integer :: i , istart , iend , ulim ! if upwnd is zero or if z=0, then use centered differences if ( abs ( upwnd ) < epsilon ( 0. ) . or . sgn == 0 ) then call second_order_centered_vpa ( llim , f , del , df ) else ulim = size ( f ) + llim - 1 ! if sgn > 0, then stream speed is negative ! so sweep from more positive to more negative zed if ( sgn > 0 ) then istart = ulim iend = llim else istart = llim iend = ulim end if ! zero_bc assumes that g -> zero beyond grid ! boundaries in vpa df ( istart ) = sgn * ( 0.5 * ( 2.0 * upwnd - 1.0 ) * f ( istart - sgn ) - 2.0 * upwnd * f ( istart )) / del ! as do not have info beyond grid boundary at end of sweep ! use pure upwinding df ( iend ) = sgn * ( f ( iend + sgn ) - f ( iend )) / del ! mixed centered and 1st order upwind scheme do i = istart - sgn , iend + sgn , - sgn df ( i ) = sgn * ( 0.5 * ( 1.0 + 2.0 * upwnd ) * f ( i + sgn ) - 2.0 * upwnd * f ( i ) + 0.5 * ( 2.0 * upwnd - 1. ) * f ( i - sgn )) / del end do end if end subroutine fd_variable_upwinding_vpa ! only good for equally-spaced grid-pts subroutine fd3pt_real ( prof , profgrad , dr ) implicit none real , dimension (:), intent ( in ) :: prof real , dimension (:), intent ( out ) :: profgrad real , intent ( in ) :: dr integer :: ix , npts real , dimension (:), allocatable :: aa , bb , cc npts = size ( prof ) allocate ( aa ( npts ), bb ( npts ), cc ( npts )) aa = 1.0 ; bb = 4.0 ; cc = 1.0 aa ( 1 ) = 0.0 ; bb ( 1 ) = 0.5 ; cc ( 1 ) = 0.5 aa ( npts ) = 0.5 ; bb ( npts ) = 0.5 ; cc ( npts ) = 0.0 do ix = 2 , npts - 1 profgrad ( ix ) = 3.0 * ( prof ( ix + 1 ) - prof ( ix - 1 )) / dr end do profgrad ( 1 ) = ( prof ( 2 ) - prof ( 1 )) / dr profgrad ( npts ) = ( prof ( npts ) - prof ( npts - 1 )) / dr call tridag ( aa , bb , cc , profgrad ) deallocate ( aa , bb , cc ) end subroutine fd3pt_real subroutine fd3pt_real_array ( prof , profgrad , dr ) implicit none real , dimension (:), intent ( in ) :: prof , dr real , dimension (:), intent ( out ) :: profgrad integer :: ix , npts real :: a , b , c npts = size ( prof ) do ix = 2 , npts - 1 profgrad ( ix ) = (( prof ( ix ) - prof ( ix - 1 )) * dr ( ix ) / dr ( ix - 1 ) & + ( prof ( ix + 1 ) - prof ( ix )) * dr ( ix - 1 ) / dr ( ix )) / ( dr ( ix - 1 ) + dr ( ix )) end do ix = 1 a = - ( 2. * dr ( 1 ) + dr ( 2 )) / ( dr ( 1 ) * ( dr ( 1 ) + dr ( 2 ))) b = ( dr ( 1 ) + dr ( 2 )) / ( dr ( 1 ) * dr ( 2 )) c = - dr ( 1 ) / ( dr ( 2 ) * ( dr ( 1 ) + dr ( 2 ))) profgrad ( 1 ) = a * prof ( 1 ) + b * prof ( 2 ) + c * prof ( 3 ) ix = npts a = dr ( npts - 1 ) / ( dr ( npts - 2 ) * ( dr ( npts - 2 ) + dr ( npts - 1 ))) b = - ( dr ( npts - 1 ) + dr ( npts - 2 )) / ( dr ( npts - 2 ) * dr ( npts - 1 )) c = ( 2. * dr ( npts - 1 ) + dr ( npts - 2 )) / ( dr ( npts - 1 ) * ( dr ( npts - 1 ) + dr ( npts - 2 ))) profgrad ( npts ) = a * prof ( npts - 2 ) + b * prof ( npts - 1 ) + c * prof ( npts ) end subroutine fd3pt_real_array subroutine fd3pt_complex_array ( prof , profgrad , dr ) implicit none complex , dimension (:), intent ( in ) :: prof real , dimension (:), intent ( in ) :: dr complex , dimension (:), intent ( out ) :: profgrad integer :: ix , npts real :: a , b , c npts = size ( prof ) do ix = 2 , npts - 1 profgrad ( ix ) = (( prof ( ix ) - prof ( ix - 1 )) * dr ( ix ) / dr ( ix - 1 ) & + ( prof ( ix + 1 ) - prof ( ix )) * dr ( ix - 1 ) / dr ( ix )) / ( dr ( ix - 1 ) + dr ( ix )) end do ix = 1 a = - ( 2. * dr ( 1 ) + dr ( 2 )) / ( dr ( 1 ) * ( dr ( 1 ) + dr ( 2 ))) b = ( dr ( 1 ) + dr ( 2 )) / ( dr ( 1 ) * dr ( 2 )) c = - dr ( 1 ) / ( dr ( 2 ) * ( dr ( 1 ) + dr ( 2 ))) profgrad ( 1 ) = a * prof ( 1 ) + b * prof ( 2 ) + c * prof ( 3 ) ix = npts a = dr ( npts - 1 ) / ( dr ( npts - 2 ) * ( dr ( npts - 2 ) + dr ( npts - 1 ))) b = - ( dr ( npts - 1 ) + dr ( npts - 2 )) / ( dr ( npts - 2 ) * dr ( npts - 1 )) c = ( 2. * dr ( npts - 1 ) + dr ( npts - 2 )) / ( dr ( npts - 1 ) * ( dr ( npts - 1 ) + dr ( npts - 2 ))) profgrad ( npts ) = a * prof ( npts - 2 ) + b * prof ( npts - 1 ) + c * prof ( npts ) end subroutine fd3pt_complex_array ! boundary points are 2nd-order accurate (2-pt compact difference) ! next to boundary points are 4th-order accurate (2-pt centered compact difference) ! interior points are 6th-order accurate (4-pt centered compact difference) subroutine fd5pt_real ( prof , profgrad , dr ) implicit none real , dimension (:), intent ( in ) :: prof real , dimension (:), intent ( out ) :: profgrad real , intent ( in ) :: dr integer :: ix , npts real , dimension (:), allocatable :: aa , bb , cc npts = size ( prof ) allocate ( aa ( npts ), bb ( npts ), cc ( npts )) aa = 1.0 ; bb = 3.0 ; cc = 1.0 aa ( 1 ) = 0.0 ; bb ( 1 ) = 0.5 ; cc ( 1 ) = 0.5 aa ( 2 ) = 1.0 ; bb ( 2 ) = 4.0 ; cc ( 2 ) = 1.0 aa ( npts - 1 ) = 1.0 ; bb ( npts - 1 ) = 4.0 ; cc ( npts - 1 ) = 1.0 aa ( npts ) = 0.5 ; bb ( npts ) = 0.5 ; cc ( npts ) = 0.0 do ix = 3 , npts - 2 profgrad ( ix ) = ( 7. * ( prof ( ix + 1 ) - prof ( ix - 1 )) + 0.25 * ( prof ( ix + 2 ) - prof ( ix - 2 ))) / ( 3. * dr ) end do profgrad ( 1 ) = ( prof ( 2 ) - prof ( 1 )) / dr profgrad ( 2 ) = 3.0 * ( prof ( 3 ) - prof ( 1 )) / dr profgrad ( npts - 1 ) = 3.0 * ( prof ( npts ) - prof ( npts - 2 )) / dr profgrad ( npts ) = ( prof ( npts ) - prof ( npts - 1 )) / dr call tridag ( aa , bb , cc , profgrad ) deallocate ( aa , bb , cc ) end subroutine fd5pt_real ! boundary points are 2nd-order accurate (2-pt compact difference) ! next to boundary points are 4th-order accurate (2-pt centered compact difference) ! interior points are 6th-order accurate (4-pt centered compact difference) subroutine fd5pt_array ( prof , profgrad , dr ) implicit none real , dimension (:), intent ( in ) :: prof , dr real , dimension (:), intent ( out ) :: profgrad integer :: ix , npts real , dimension (:), allocatable :: aa , bb , cc npts = size ( prof ) allocate ( aa ( npts ), bb ( npts ), cc ( npts )) aa = 1.0 ; bb = 3.0 ; cc = 1.0 aa ( 1 ) = 0.0 ; bb ( 1 ) = 0.5 ; cc ( 1 ) = 0.5 aa ( 2 ) = 1.0 ; bb ( 2 ) = 4.0 ; cc ( 2 ) = 1.0 aa ( npts - 1 ) = 1.0 ; bb ( npts - 1 ) = 4.0 ; cc ( npts - 1 ) = 1.0 aa ( npts ) = 0.5 ; bb ( npts ) = 0.5 ; cc ( npts ) = 0.0 do ix = 3 , npts - 2 profgrad ( ix ) = ( 7. * ( prof ( ix + 1 ) - prof ( ix - 1 )) + 0.25 * ( prof ( ix + 2 ) - prof ( ix - 2 ))) / ( 3. * dr ( ix )) end do profgrad ( 1 ) = ( prof ( 2 ) - prof ( 1 )) / dr ( 1 ) profgrad ( 2 ) = 3.0 * ( prof ( 3 ) - prof ( 1 )) / dr ( 2 ) profgrad ( npts - 1 ) = 3.0 * ( prof ( npts ) - prof ( npts - 2 )) / dr ( npts - 1 ) profgrad ( npts ) = ( prof ( npts ) - prof ( npts - 1 )) / dr ( npts ) call tridag ( aa , bb , cc , profgrad ) deallocate ( aa , bb , cc ) end subroutine fd5pt_array ! second derivative using centered differences ! second order accurate subroutine d2_3pt_real ( f , d2f , dr ) implicit none real , dimension (:), intent ( in ) :: f real , dimension (:), intent ( in ) :: dr real , dimension (:), intent ( out ) :: d2f real :: a , b , c , d integer :: i , n n = size ( f ) do i = 2 , n - 1 a = 2. / ( dr ( i - 1 ) * ( dr ( i ) + dr ( i - 1 ))) b = - 2. / ( dr ( i - 1 ) * dr ( i )) c = 2. / ( dr ( i ) * ( dr ( i ) + dr ( i - 1 ))) d2f ( i ) = a * f ( i - 1 ) + b * f ( i ) + c * f ( i + 1 ) end do i = 1 a = ( 6. * dr ( 1 ) + 4. * dr ( 2 ) + 2. * dr ( 3 )) & / ( dr ( 1 ) * ( dr ( 1 ) + dr ( 2 )) * ( dr ( 1 ) + dr ( 2 ) + dr ( 3 ))) b = - ( 4. * ( dr ( 1 ) + dr ( 2 )) + 2. * dr ( 3 )) & / ( dr ( 1 ) * dr ( 2 ) * ( dr ( 2 ) + dr ( 3 ))) c = ( 4. * dr ( 1 ) + 2. * ( dr ( 2 ) + dr ( 3 ))) & / (( dr ( 2 ) + dr ( 1 )) * dr ( 2 ) * dr ( 3 )) d = - ( 4. * dr ( 1 ) + 2. * dr ( 2 )) & / (( dr ( 3 ) + dr ( 2 ) + dr ( 1 )) * ( dr ( 3 ) + dr ( 2 )) * dr ( 3 )) d2f ( i ) = a * f ( 1 ) + b * f ( 2 ) + c * f ( 3 ) + d * f ( 4 ) i = n a = - ( 4. * dr ( n - 1 ) + 2. * dr ( n - 2 )) & / ( dr ( n - 3 ) * ( dr ( n - 3 ) + dr ( n - 2 )) * ( dr ( n - 3 ) + dr ( n - 2 ) + dr ( n - 1 ))) b = ( 4. * dr ( n - 1 ) + 2. * ( dr ( n - 2 ) + dr ( n - 3 ))) & / ( dr ( n - 3 ) * dr ( n - 2 ) * ( dr ( n - 2 ) + dr ( n - 1 ))) c = - ( 4. * ( dr ( n - 1 ) + dr ( n - 2 )) + 2. * dr ( n - 3 )) & / ( dr ( n - 1 ) * dr ( n - 2 ) * ( dr ( n - 2 ) + dr ( n - 3 ))) d = ( 6. * dr ( n - 1 ) + 4. * dr ( n - 2 ) + 2. * dr ( n - 3 )) & / ( dr ( n - 1 ) * ( dr ( n - 1 ) + dr ( n - 2 )) * ( dr ( n - 1 ) + dr ( n - 2 ) + dr ( n - 3 ))) d2f ( i ) = a * f ( n - 3 ) + b * f ( n - 2 ) + c * f ( n - 1 ) + d * f ( n ) !     ! FLAG -- this is a hack !     ! do not anticipate needing 2nd derivatives !     ! at first and last grid points !     d2f(1) = d2f(2) !     d2f(n) = d2f(n-1) end subroutine d2_3pt_real subroutine d2_3pt_complex ( f , d2f , dr ) implicit none complex , dimension (:), intent ( in ) :: f real , dimension (:), intent ( in ) :: dr complex , dimension (:), intent ( out ) :: d2f real :: a , b , c , d integer :: i , n n = size ( f ) do i = 2 , n - 1 a = 2. / ( dr ( i - 1 ) * ( dr ( i ) + dr ( i - 1 ))) b = - 2. / ( dr ( i - 1 ) * dr ( i )) c = 2. / ( dr ( i ) * ( dr ( i ) + dr ( i - 1 ))) d2f ( i ) = a * f ( i - 1 ) + b * f ( i ) + c * f ( i + 1 ) end do i = 1 a = ( 6. * dr ( 1 ) + 4. * dr ( 2 ) + 2. * dr ( 3 )) & / ( dr ( 1 ) * ( dr ( 1 ) + dr ( 2 )) * ( dr ( 1 ) + dr ( 2 ) + dr ( 3 ))) b = - ( 4. * ( dr ( 1 ) + dr ( 2 )) + 2. * dr ( 3 )) & / ( dr ( 1 ) * dr ( 2 ) * ( dr ( 2 ) + dr ( 3 ))) c = ( 4. * dr ( 1 ) + 2. * ( dr ( 2 ) + dr ( 3 ))) & / (( dr ( 2 ) + dr ( 1 )) * dr ( 2 ) * dr ( 3 )) d = - ( 4. * dr ( 1 ) + 2. * dr ( 2 )) & / (( dr ( 3 ) + dr ( 2 ) + dr ( 1 )) * ( dr ( 3 ) + dr ( 2 )) * dr ( 3 )) d2f ( i ) = a * f ( 1 ) + b * f ( 2 ) + c * f ( 3 ) + d * f ( 4 ) i = n a = - ( 4. * dr ( n - 1 ) + 2. * dr ( n - 2 )) & / ( dr ( n - 3 ) * ( dr ( n - 3 ) + dr ( n - 2 )) * ( dr ( n - 3 ) + dr ( n - 2 ) + dr ( n - 1 ))) b = ( 4. * dr ( n - 1 ) + 2. * ( dr ( n - 2 ) + dr ( n - 3 ))) & / ( dr ( n - 3 ) * dr ( n - 2 ) * ( dr ( n - 2 ) + dr ( n - 1 ))) c = - ( 4. * ( dr ( n - 1 ) + dr ( n - 2 )) + 2. * dr ( n - 3 )) & / ( dr ( n - 1 ) * dr ( n - 2 ) * ( dr ( n - 2 ) + dr ( n - 3 ))) d = ( 6. * dr ( n - 1 ) + 4. * dr ( n - 2 ) + 2. * dr ( n - 3 )) & / ( dr ( n - 1 ) * ( dr ( n - 1 ) + dr ( n - 2 )) * ( dr ( n - 1 ) + dr ( n - 2 ) + dr ( n - 3 ))) d2f ( i ) = a * f ( n - 3 ) + b * f ( n - 2 ) + c * f ( n - 1 ) + d * f ( n ) end subroutine d2_3pt_complex subroutine tridag_real ( aa , bb , cc , sol ) implicit none real , dimension (:), intent ( in ) :: aa , bb , cc real , dimension (:), intent ( in out ) :: sol integer :: ix , npts real :: bet real , dimension (:), allocatable :: gam npts = size ( aa ) allocate ( gam ( npts )) bet = bb ( 1 ) sol ( 1 ) = sol ( 1 ) / bet do ix = 2 , npts gam ( ix ) = cc ( ix - 1 ) / bet bet = bb ( ix ) - aa ( ix ) * gam ( ix ) if ( bet == 0.0 ) write ( * , * ) 'tridiagonal solve failed' sol ( ix ) = ( sol ( ix ) - aa ( ix ) * sol ( ix - 1 )) / bet end do do ix = npts - 1 , 1 , - 1 sol ( ix ) = sol ( ix ) - gam ( ix + 1 ) * sol ( ix + 1 ) end do deallocate ( gam ) end subroutine tridag_real subroutine tridag_complex ( llim , aa , bb , cc , sol ) implicit none integer , intent ( in ) :: llim real , dimension ( llim :), intent ( in ) :: aa , bb , cc complex , dimension ( llim :), intent ( in out ) :: sol integer :: ix , npts real :: bet real , dimension (:), allocatable :: gam npts = size ( bb ) allocate ( gam ( llim : llim + npts - 1 )) bet = bb ( llim ) sol ( llim ) = sol ( llim ) / bet do ix = llim + 1 , llim + npts - 1 gam ( ix ) = cc ( ix - 1 ) / bet bet = bb ( ix ) - aa ( ix ) * gam ( ix ) if ( bet == 0.0 ) write ( * , * ) 'tridiagonal solve failed' sol ( ix ) = ( sol ( ix ) - aa ( ix ) * sol ( ix - 1 )) / bet end do do ix = llim + npts - 2 , llim , - 1 sol ( ix ) = sol ( ix ) - gam ( ix + 1 ) * sol ( ix + 1 ) end do deallocate ( gam ) end subroutine tridag_complex end module finite_differences","tags":"","loc":"sourcefile/finite_differences.f90.html"},{"title":"smooth_step.f90 – stella","text":"Source Code module smooth_step implicit none public :: smoothstep contains pure function smoothstep ( x , N , minV , maxV ) implicit none real :: smoothstep real , intent ( in ) :: x integer , intent ( in ) :: N real , optional , intent ( in ) :: minV real , optional , intent ( in ) :: maxV real :: minVl real :: maxVl real :: dV minVl = 0 maxVl = 1 if ( present ( minV )) minVl = minV if ( present ( maxV )) maxVl = maxV dV = maxVl - minVl if ( x <= 0 ) then smoothstep = minVl return end if if ( x >= 1 ) then smoothstep = maxVl return end if select case ( N ) case ( 0 ) smoothstep = minVl + dV * smoothstep0 ( x ) case ( 1 ) smoothstep = minVl + dV * smoothstep1 ( x ) case ( 2 ) smoothstep = minVl + dV * smoothstep2 ( x ) case default smoothstep = minVl + dV * smoothstepN ( x , N ) end select end function smoothstep pure function smoothstep0 ( x ) implicit none real :: smoothstep0 real , intent ( in ) :: x smoothstep0 = x end function smoothstep0 pure function smoothstep1 ( x ) implicit none real :: smoothstep1 real , intent ( in ) :: x smoothstep1 = x * x * ( 3 - 2 * x ) end function smoothstep1 pure function smoothstep2 ( x ) implicit none real :: smoothstep2 real , intent ( in ) :: x smoothstep2 = x * x * x * ( x * ( x * 6 - 15 ) + 10 ) end function smoothstep2 pure function smoothstepN ( x , N ) implicit none real :: smoothstepN real :: sumV real :: xp real , intent ( in ) :: x integer , intent ( in ) :: N integer :: i if ( N < 0 ) then smoothstepN = 0.5 * sin ( 3.14159265358979 * ( x - 0.5 )) + 0.5 return end if xp = x if ( x > 0.5 ) xp = 1.0 - x sumV = 0 do i = N , 0 , - 1 sumV = xp * sumV + & pascalTriangle ( - N - 1 , i ) * & pascalTriangle ( 2 * N + 1 , N - i ) end do sumV = xp ** ( N + 1 ) * sumV smoothstepN = sumV if ( x > 0.5 ) smoothstepN = 1 - sumV end function smoothstepN pure function pascalTriangle ( a , b ) implicit none integer :: pascalTriangle integer , intent ( in ) :: a , b integer i pascalTriangle = 1 do i = 0 , b - 1 pascalTriangle = pascalTriangle * ( a - i ) / ( i + 1 ) end do end function pascalTriangle end module smooth_step","tags":"","loc":"sourcefile/smooth_step.f90.html"},{"title":"euterpe_interface.f90 – stella","text":"Source Code module euterpe_interface implicit none contains subroutine read_species_euterpe ( nspec , spec ) use mp , only : mp_abort use finite_differences , only : fd3pt , d2_3pt use common_types , only : spec_type use splines , only : geo_spline use physics_parameters , only : vnew_ref , rhostar , tite , nine use stella_geometry , only : geo_surf , aref , bref implicit none integer , intent ( in ) :: nspec type ( spec_type ), dimension (:), intent ( in out ) :: spec integer , parameter :: electron_species = 2 integer :: euterpe_unit = 1099 , out_unit = 1098 integer :: nradii_euterpe integer :: is , irad character ( 1000 ) :: euterpe_infile real :: mref , tref , nref , local_loglam , vtref , omega_ref , rho_ref real :: vnew_ref_euterpe , rhostar_euterpe real , dimension (:), allocatable :: dr , rhotor , psitor real , dimension (:), allocatable :: ni , Ti real , dimension (:), allocatable :: ne , Te real , dimension (:), allocatable :: dlnneds , dlnTeds real , dimension (:), allocatable :: dlnnids , dlnTids real , dimension (:), allocatable :: neprim , Teprim real , dimension (:), allocatable :: nedbprim , Tedbprim real , dimension (:), allocatable :: niprim , Tiprim real , dimension (:), allocatable :: nidbprim , Tidbprim real , dimension (:), allocatable :: loglam call read_euterpe_parameters ( nradii_euterpe , euterpe_infile ) open ( unit = euterpe_unit , file = trim ( euterpe_infile ), status = 'old' , action = 'read' ) allocate ( dr ( nradii_euterpe )) allocate ( psitor ( nradii_euterpe )) allocate ( rhotor ( nradii_euterpe )) allocate ( Ti ( nradii_euterpe )) allocate ( ni ( nradii_euterpe )) allocate ( Te ( nradii_euterpe )) allocate ( ne ( nradii_euterpe )) allocate ( dlnTids ( nradii_euterpe )) allocate ( dlnTeds ( nradii_euterpe )) allocate ( dlnnids ( nradii_euterpe )) allocate ( dlnneds ( nradii_euterpe )) allocate ( neprim ( nradii_euterpe )) allocate ( nedbprim ( nradii_euterpe )) allocate ( niprim ( nradii_euterpe )) allocate ( nidbprim ( nradii_euterpe )) allocate ( Teprim ( nradii_euterpe )) allocate ( Tedbprim ( nradii_euterpe )) allocate ( Tiprim ( nradii_euterpe )) allocate ( Tidbprim ( nradii_euterpe )) allocate ( loglam ( nradii_euterpe )) ! column 1 is s=psitor/psitor_LCFS, 2 is dlog(Ti)/ds, 3 is Ti in eV, 4 is dlog(Te)/ds, 5 is Te in eV ! 6 is dlog(ni)/ds, 7 is ni in 1/m&#94;3, 8 is dlog(ne)/ds, 9 is ne in 1/m&#94;3 do irad = 1 , nradii_euterpe read ( euterpe_unit , * ) psitor ( irad ), dlnTids ( irad ), Ti ( irad ), dlnTeds ( irad ), & Te ( irad ), dlnnids ( irad ), ni ( irad ), dlnneds ( irad ), ne ( irad ) end do close ( euterpe_unit ) rhotor = sqrt ( psitor ) dr = rhotor ( 2 :) - rhotor (: nradii_euterpe - 1 ) ! obtain -d ln(ne) / drho call fd3pt ( ne , neprim , dr ) call d2_3pt ( ne , nedbprim , dr ) neprim = - neprim / ne nedbprim = nedbprim / ne ! obtain -d ln(Te) / drho call fd3pt ( Te , Teprim , dr ) call d2_3pt ( Te , Tedbprim , dr ) Teprim = - Teprim / Te Tedbprim = Tedbprim / Te ! obtain -d ln(ni) / drho call fd3pt ( ni , niprim , dr ) call d2_3pt ( ni , nidbprim , dr ) niprim = - niprim / ni nidbprim = nidbprim / ni ! obtain -d ln(Ti) / drho call fd3pt ( Ti , Tiprim , dr ) call d2_3pt ( Ti , Tidbprim , dr ) Tiprim = - Tiprim / Ti Tidbprim = Tidbprim / Ti ! next need to pick out the correct flux surface ! and assign various local% values ! choose first species as reference species is = 1 spec ( is )% dens = 1.0 spec ( is )% temp = 1.0 ! get reference density and temperature at local surface if ( spec ( is )% type == electron_species ) then call geo_spline ( rhotor , Te , geo_surf % rhotor , tref ) call geo_spline ( rhotor , ne , geo_surf % rhotor , nref ) else call geo_spline ( rhotor , Ti , geo_surf % rhotor , tref ) call geo_spline ( rhotor , ni , geo_surf % rhotor , nref ) end if ! next get the normalized density and temperature for all other species if ( nspec == 2 ) then do is = 2 , nspec if ( spec ( is )% type == electron_species ) then call geo_spline ( rhotor , Te / tref , geo_surf % rhotor , spec ( is )% temp ) call geo_spline ( rhotor , ne / nref , geo_surf % rhotor , spec ( is )% dens ) else call geo_spline ( rhotor , Ti / tref , geo_surf % rhotor , spec ( is )% temp ) call geo_spline ( rhotor , ni / tref , geo_surf % rhotor , spec ( is )% dens ) end if end do else if ( nspec > 2 ) then call mp_abort ( 'multiple ion species not currently supported for euterpe option. aborting.' ) end if ! assume mass in stella input file given in units of proton mass mref = spec ( 1 )% mass ! convert from eV to keV tref = tref * 0.001 ! convert from 1/m&#94;3 to 10&#94;19/m&#94;3 nref = nref * 1.e-19 ! now get the density and temperature gradients at the requested flux surface do is = 1 , nspec if ( spec ( is )% type == electron_species ) then if ( spec ( is )% tprim < - 99 9.0 ) call geo_spline ( rhotor , Teprim , geo_surf % rhotor , spec ( is )% tprim ) call geo_spline ( rhotor , Tedbprim , geo_surf % rhotor , spec ( is )% d2Tdr2 ) if ( spec ( is )% fprim < - 99 9.0 ) call geo_spline ( rhotor , neprim , geo_surf % rhotor , spec ( is )% fprim ) call geo_spline ( rhotor , nedbprim , geo_surf % rhotor , spec ( is )% d2ndr2 ) else if ( spec ( is )% tprim < - 99 9.0 ) call geo_spline ( rhotor , Tiprim , geo_surf % rhotor , spec ( is )% tprim ) call geo_spline ( rhotor , Tidbprim , geo_surf % rhotor , spec ( is )% d2Tdr2 ) if ( spec ( is )% fprim < - 99 9.0 ) call geo_spline ( rhotor , niprim , geo_surf % rhotor , spec ( is )% fprim ) call geo_spline ( rhotor , nidbprim , geo_surf % rhotor , spec ( is )% d2ndr2 ) end if end do ! get quantities needed for runs with Boltzmann electrons call geo_spline ( rhotor , Ti / Te , geo_surf % rhotor , tite ) call geo_spline ( rhotor , ni / ne , geo_surf % rhotor , nine ) ! get collisionalities for stella loglam = 2 4.0 - log ( 1e4 * sqrt ( 1.e-20 * ne ) / ( te * 0.001 )) call geo_spline ( rhotor , loglam , geo_surf % rhotor , local_loglam ) ! vtref = sqrt(2*Tref/mref), with Tref and mref in SI units ! so vtref has dimensions of meters / second ! note that tref below is T in units of keV and mref is in units of proton mass vtref = 3.09497e5 * sqrt ( 2. * tref / mref ) ! reference collision frequency for stella ! uses the mass, density and temperature of the reference species, ! along with the proton charge in the expression ! vnew_ref = (aref/vtref)*(4/3)sqrt(2pi)/(4pi*epsilon_0)**2 * nref * e**4 * loglam / sqrt(mref) / Tref**1.5 ! note that all quantities are given in SI units and epsilon_0 is permittivity of vacuum vnew_ref_euterpe = 2 8.5134 * ( aref / vtref ) * local_loglam * nref / ( sqrt ( mref ) * tref ** 1.5 ) omega_ref = 9.5791e7 * bref / mref rho_ref = vtref / omega_ref rhostar_euterpe = rho_ref / aref if ( rhostar < 0.0 ) rhostar = rhostar_euterpe if ( vnew_ref < 0.0 ) vnew_ref = vnew_ref_euterpe open ( unit = out_unit , file = 'euterpe.input' , status = 'replace' , action = 'write' ) write ( out_unit , * ) 'aref: ' , aref , 'mref: ' , mref , 'nref: ' , nref , 'tref: ' , tref write ( out_unit , * ) 'loglam: ' , local_loglam , 'vnew_ref_euterpe: ' , vnew_ref_euterpe , 'vnew_ref: ' , vnew_ref write ( out_unit , * ) 'omega_ref: ' , omega_ref , 'rho_ref: ' , rho_ref write ( out_unit , * ) 'rhostar_euterpe: ' , rhostar_euterpe , 'rhostar: ' , rhostar write ( out_unit , * ) 'nine: ' , nine , 'tite: ' , tite , 'fprim: ' , spec ( 1 )% fprim , 'tprim: ' , spec ( 1 )% tprim write ( out_unit , * ) 'd2ndr2: ' , spec ( 1 )% d2ndr2 , 'd2Tdr2: ' , spec ( 1 )% d2Tdr2 close ( out_unit ) deallocate ( dr , rhotor , psitor ) deallocate ( ni , ne , Ti , Te ) deallocate ( dlnTids , dlnTeds , dlnnids , dlnneds ) deallocate ( niprim , neprim , nidbprim , nedbprim ) deallocate ( Tiprim , Teprim , Tidbprim , Tedbprim ) deallocate ( loglam ) end subroutine read_species_euterpe subroutine read_euterpe_parameters ( nradii_out , data_file_out ) use file_utils , only : input_unit_exist implicit none integer :: in_file logical :: exist integer , intent ( out ) :: nradii_out character ( * ), intent ( out ) :: data_file_out integer :: nradii character ( 1000 ) :: data_file namelist / euterpe_parameters / nradii , data_file nradii = 1000 data_file = 'euterpe.dat' in_file = input_unit_exist ( \"euterpe_parameters\" , exist ) if ( exist ) read ( unit = in_file , nml = euterpe_parameters ) nradii_out = nradii data_file_out = data_file end subroutine read_euterpe_parameters end module euterpe_interface","tags":"","loc":"sourcefile/euterpe_interface.f90.html"},{"title":"mt19937.f90 – stella","text":"Source Code !!$ A C-program for MT19937: Real number version !!$   genrand() generates one pseudorandom real number (double) !!$ which is uniformly distributed on [0,1]-interval, for each !!$ call. sgenrand(seed) set initial values to the working area !!$ of 624 words. Before genrand(), sgenrand(seed) must be !!$ called once. (seed is any 32-bit integer except for 0). !!$ Integer generator is obtained by modifying two lines. !!$   Coded by Takuji Nishimura, considering the suggestions by !!$ Topher Cooper and Marc Rieffel in July-Aug. 1997. !!$ !!$ This library is free software; you can redistribute it and/or !!$ modify it under the terms of the GNU Library General Public !!$ License as published by the Free Software Foundation; either !!$ version 2 of the License, or (at your option) any later !!$ version. !!$ This library is distributed in the hope that it will be useful, !!$ but WITHOUT ANY WARRANTY; without even the implied warranty of !!$ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. !!$ See the GNU Library General Public License for more details. !!$ You should have received a copy of the GNU Library General !!$ Public License along with this library; if not, write to the !!$ Free Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA !!$ 02111-1307  USA !!$ !!$ Copyright (C) 1997 Makoto Matsumoto and Takuji Nishimura. !!$ When you use this, send an email to: matumoto@math.keio.ac.jp !!$ with an appropriate reference to your work. !!$ !!$*********************************************************************** !!$ Fortran translation by Hiroshi Takano.  Jan. 13, 1999. !!$ !!$ This program uses the following non-standard intrinsics. !!$   ishft(i,n): If n>0, shifts bits in i by n positions to left. !!$               If n<0, shifts bits in i by n positions to right. !!$   iand (i,j): Performs logical AND on corresponding bits of i and j. !!$   ior  (i,j): Performs inclusive OR on corresponding bits of i and j. !!$   ieor (i,j): Performs exclusive OR on corresponding bits of i and j. !!$ !!$************************************************************************ !!$ Fortran 95 translation and modularized to use in gyrokinetics project !!$ by R. Numata, June 2, 2010. !!$  * removed statement functions (TSHFTU,TSHFTS,TSHFTT,TSHFTL) !!$  * uses [0,1) interval !!$  * the above bit manipulation functions became standard. !!$  * definition of UMASK is corrected (the original value cannot be !!$    represented as a kind=4 integer. !!$*********************************************************************** module mt19937 implicit none private public :: sgrnd , grnd integer , parameter :: default_seed = 4357 ! Period parameters integer , parameter :: N = 624 integer , parameter :: M = 397 integer , parameter :: MATA = - 1727483681 ! constant vector a integer , parameter :: LMASK = 2147483647 ! least significant r bits integer , parameter :: UMASK = - LMASK - 1 ! most significant w-r bits ! Tempering parameters integer , parameter :: TMASKB = - 1658038656 integer , parameter :: TMASKC = - 272236544 integer , save :: mt ( 0 : N - 1 ) ! the array for the state vector integer , save :: mti = N + 1 ! mti==N+1 means mt[N] is not initialized integer , save :: mag01 ( 0 : 1 ) = ( / 0 , MATA / ) ! mag01(x) = x * MATA for x=0,1 contains subroutine sgrnd ( seed ) implicit none integer , intent ( in ) :: seed !!$      setting initial seeds to mt[N] using !!$      the generator Line 25 of Table 1 in !!$      [KNUTH 1981, The Art of Computer Programming !!$         Vol. 2 (2nd Ed.), pp102] mt ( 0 ) = iand ( seed , - 1 ) do mti = 1 , N - 1 mt ( mti ) = iand ( 69069 * mt ( mti - 1 ), - 1 ) end do return end subroutine sgrnd function grnd () implicit none real :: grnd real , parameter :: pow = 429496729 6.0 ! 2**32 real , parameter :: div = 1. / pow ! devided by 2**32 [0,1)-real-interval ! real, parameter :: div=1./(pow-1.)  ! devided by 2**32-1 [0,1]-real-interval integer :: y , kk if ( mti >= N ) then ! generate N words at one time if ( mti == N + 1 ) then ! if sgrnd() has not been called, call sgrnd ( default_seed ) ! a default initial seed is used end if do kk = 0 , N - M - 1 y = ior ( iand ( mt ( kk ), UMASK ), iand ( mt ( kk + 1 ), LMASK )) mt ( kk ) = ieor ( ieor ( mt ( kk + M ), ishft ( y , - 1 )), mag01 ( iand ( y , 1 ))) end do do kk = N - M , N - 2 y = ior ( iand ( mt ( kk ), UMASK ), iand ( mt ( kk + 1 ), LMASK )) mt ( kk ) = ieor ( ieor ( mt ( kk + ( M - N )), ishft ( y , - 1 )), mag01 ( iand ( y , 1 ))) end do y = ior ( iand ( mt ( N - 1 ), UMASK ), iand ( mt ( 0 ), LMASK )) mt ( N - 1 ) = ieor ( ieor ( mt ( M - 1 ), ishft ( y , - 1 )), mag01 ( iand ( y , 1 ))) mti = 0 end if y = mt ( mti ) mti = mti + 1 y = ieor ( y , ishft ( y , - 11 )) y = ieor ( y , iand ( ishft ( y , 7 ), TMASKB )) y = ieor ( y , iand ( ishft ( y , 15 ), TMASKC )) y = ieor ( y , ishft ( y , - 18 )) grnd = real ( y ) if ( grnd < 0. ) grnd = grnd + pow grnd = grnd * div return end function grnd end module mt19937 !!$ this main outputs first 1000 generated numbers !!$program main !!$  use mt19937, only: grnd !!$  ! use mt19937, only: sgrnd !!$  implicit none !!$  integer, parameter :: no=1000 !!$  real :: r(0:7) !!$  integer :: j,k !!$  ! call sgrnd(4357) ! any nonzero integer can be used as a seed !!$ !!$  do j=0,no-1 !!$     r(mod(j,8))=grnd() !!$     if(mod(j,8) == 7) then !!$        write(*,'(8(f8.6,'' ''))') (r(k),k=0,7) !!$     else if(j == no-1) then !!$        write(*,'(8(f8.6,'' ''))') (r(k),k=0,mod(no-1,8)) !!$     endif !!$  end do !!$ !!$  stop !!$end program main","tags":"","loc":"sourcefile/mt19937.f90.html"},{"title":"stella_layouts.f90 – stella","text":"Source Code module stella_layouts use common_types , only : vmu_layout_type use common_types , only : kxkyz_layout_type , kxyz_layout_type , xyz_layout_type implicit none private public :: xyzs_layout , vms_layout public :: finish_layouts public :: init_stella_layouts , init_dist_fn_layouts public :: kxkyz_lo , kxyz_lo , xyz_lo , vmu_lo public :: kxkyzidx2vmuidx , kxyzidx2vmuidx , xyzidx2vmuidx public :: iz_idx , iky_idx , ikx_idx , iv_idx , imu_idx , is_idx , iy_idx public :: it_idx public :: idx , proc_id , idx_local character ( len = 4 ) :: xyzs_layout character ( len = 3 ) :: vms_layout logical :: exist type ( kxkyz_layout_type ) :: kxkyz_lo type ( kxyz_layout_type ) :: kxyz_lo type ( xyz_layout_type ) :: xyz_lo type ( vmu_layout_type ) :: vmu_lo interface it_idx module procedure it_idx_kxkyz module procedure it_idx_kxyz module procedure it_idx_xyz end interface interface iz_idx module procedure iz_idx_kxkyz module procedure iz_idx_kxyz module procedure iz_idx_xyz end interface interface iv_idx module procedure iv_idx_vmu end interface interface iky_idx module procedure iky_idx_kxkyz end interface interface iy_idx module procedure iy_idx_kxyz module procedure iy_idx_xyz end interface interface ikx_idx module procedure ikx_idx_kxkyz module procedure ikx_idx_kxyz end interface interface ix_idx module procedure ix_idx_xyz end interface interface imu_idx module procedure imu_idx_vmu end interface interface is_idx module procedure is_idx_kxkyz module procedure is_idx_kxyz module procedure is_idx_xyz module procedure is_idx_vmu end interface interface proc_id module procedure proc_id_kxkyz module procedure proc_id_kxyz module procedure proc_id_xyz module procedure proc_id_vmu end interface interface idx module procedure idx_kxkyz module procedure idx_kxyz module procedure idx_xyz module procedure idx_vmu end interface interface idx_local module procedure idx_local_kxkyz , iz_local_kxkyz module procedure idx_local_kxyz , iz_local_kxyz module procedure idx_local_xyz , iz_local_xyz module procedure idx_local_vmu , iz_local_vmu end interface contains subroutine init_stella_layouts use mp , only : proc0 implicit none logical , save :: initialized = . false . if ( initialized ) return initialized = . true . if ( proc0 ) call read_parameters call broadcast_results end subroutine init_stella_layouts subroutine read_parameters use mp , only : mp_abort use file_utils , only : input_unit , error_unit , input_unit_exist , error_unit implicit none integer :: in_file namelist / layouts_knobs / xyzs_layout , vms_layout xyzs_layout = 'yxzs' vms_layout = 'vms' in_file = input_unit_exist ( \"layouts_knobs\" , exist ) if ( exist ) read ( unit = input_unit ( \"layouts_knobs\" ), nml = layouts_knobs ) if ( xyzs_layout /= 'xyzs' . and . & xyzs_layout /= 'xzys' . and . & xyzs_layout /= 'yxzs' . and . & xyzs_layout /= 'yzxs' . and . & xyzs_layout /= 'zxys' . and . & xyzs_layout /= 'zyxs' ) then call mp_abort ( 'stella_layouts: read_parameters finds illegal xyzs_layout. aborting' ) end if if ( vms_layout /= 'vms' . and . & vms_layout /= 'mvs' ) then call mp_abort ( 'stella_layouts: read_parameters finds illegal vms_layout. aborting' ) end if end subroutine read_parameters subroutine broadcast_results use mp , only : broadcast implicit none call broadcast ( xyzs_layout ) call broadcast ( vms_layout ) end subroutine broadcast_results !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Distribution function layouts !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine init_dist_fn_layouts ( nzgrid , ntubes , naky , nakx , nvgrid , nmu , nspec , ny , nx , nalpha ) implicit none integer , intent ( in ) :: nzgrid , ntubes , naky , nakx , nvgrid , nmu , nspec , ny , nx , nalpha call init_kxkyz_layout ( nzgrid , ntubes , naky , nakx , nvgrid , nmu , nspec ) call init_kxyz_layout ( nzgrid , ntubes , naky , nakx , nvgrid , nmu , nspec , ny ) call init_xyz_layout ( nzgrid , ntubes , naky , nakx , nvgrid , nmu , nspec , ny , nx ) call init_vmu_layout ( nzgrid , ntubes , naky , nakx , nvgrid , nmu , nspec , ny , nx , nalpha ) end subroutine init_dist_fn_layouts subroutine init_kxkyz_layout & ( nzgrid , ntubes , naky , nakx , nvgrid , nmu , nspec ) use mp , only : iproc , nproc implicit none integer , intent ( in ) :: nzgrid , ntubes , naky , nakx , nvgrid , nmu , nspec logical , save :: initialized = . false . if ( initialized ) return initialized = . true . kxkyz_lo % iproc = iproc kxkyz_lo % nzgrid = nzgrid kxkyz_lo % nzed = 2 * nzgrid + 1 kxkyz_lo % ntubes = ntubes kxkyz_lo % naky = naky kxkyz_lo % nakx = nakx kxkyz_lo % nvgrid = nvgrid kxkyz_lo % nvpa = 2 * nvgrid kxkyz_lo % nmu = nmu kxkyz_lo % nspec = nspec kxkyz_lo % llim_world = 0 kxkyz_lo % ulim_world = naky * nakx * kxkyz_lo % nzed * ntubes * nspec - 1 kxkyz_lo % blocksize = kxkyz_lo % ulim_world / nproc + 1 kxkyz_lo % llim_proc = kxkyz_lo % blocksize * iproc kxkyz_lo % ulim_proc = min ( kxkyz_lo % ulim_world , kxkyz_lo % llim_proc + kxkyz_lo % blocksize - 1 ) kxkyz_lo % ulim_alloc = max ( kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc ) end subroutine init_kxkyz_layout elemental function is_idx_kxkyz ( lo , i ) implicit none integer :: is_idx_kxkyz type ( kxkyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i is_idx_kxkyz = 1 + mod (( i - lo % llim_world ) / lo % nakx / lo % naky / lo % nzed / lo % ntubes , lo % nspec ) end function is_idx_kxkyz elemental function ikx_idx_kxkyz ( lo , i ) implicit none integer :: ikx_idx_kxkyz type ( kxkyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i select case ( xyzs_layout ) case ( 'xyzs' ) ikx_idx_kxkyz = 1 + mod (( i - lo % llim_world ), lo % nakx ) case ( 'xzys' ) ikx_idx_kxkyz = 1 + mod (( i - lo % llim_world ), lo % nakx ) case ( 'yxzs' ) ikx_idx_kxkyz = 1 + mod (( i - lo % llim_world ) / lo % naky , lo % nakx ) case ( 'zxys' ) ikx_idx_kxkyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % ntubes , lo % nakx ) case ( 'zyxs' ) ikx_idx_kxkyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % ntubes / lo % naky , lo % nakx ) case ( 'yzxs' ) ikx_idx_kxkyz = 1 + mod (( i - lo % llim_world ) / lo % naky / lo % nzed / lo % ntubes , lo % nakx ) end select end function ikx_idx_kxkyz elemental function iky_idx_kxkyz ( lo , i ) implicit none integer :: iky_idx_kxkyz type ( kxkyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i select case ( xyzs_layout ) case ( 'yxzs' ) iky_idx_kxkyz = 1 + mod ( i - lo % llim_world , lo % naky ) case ( 'yzxs' ) iky_idx_kxkyz = 1 + mod ( i - lo % llim_world , lo % naky ) case ( 'xyzs' ) iky_idx_kxkyz = 1 + mod (( i - lo % llim_world ) / lo % nakx , lo % naky ) case ( 'zyxs' ) iky_idx_kxkyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % ntubes , lo % naky ) case ( 'zxys' ) iky_idx_kxkyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % ntubes / lo % nakx , lo % naky ) case ( 'xzys' ) iky_idx_kxkyz = 1 + mod (( i - lo % llim_world ) / lo % nakx / lo % nzed / lo % ntubes , lo % naky ) end select end function iky_idx_kxkyz elemental function iz_idx_kxkyz ( lo , i ) implicit none integer :: iz_idx_kxkyz type ( kxkyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i select case ( xyzs_layout ) case ( 'zyxs' ) iz_idx_kxkyz = - lo % nzgrid + mod (( i - lo % llim_world ), lo % nzed ) case ( 'zxys' ) iz_idx_kxkyz = - lo % nzgrid + mod (( i - lo % llim_world ), lo % nzed ) case ( 'xzys' ) iz_idx_kxkyz = - lo % nzgrid + mod (( i - lo % llim_world ) / lo % nakx , lo % nzed ) case ( 'yzxs' ) iz_idx_kxkyz = - lo % nzgrid + mod (( i - lo % llim_world ) / lo % naky , lo % nzed ) case ( 'yxzs' ) iz_idx_kxkyz = - lo % nzgrid + mod (( i - lo % llim_world ) / lo % naky / lo % nakx , lo % nzed ) case ( 'xyzs' ) iz_idx_kxkyz = - lo % nzgrid + mod (( i - lo % llim_world ) / lo % nakx / lo % naky , lo % nzed ) end select end function iz_idx_kxkyz elemental function it_idx_kxkyz ( lo , i ) implicit none integer :: it_idx_kxkyz type ( kxkyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i select case ( xyzs_layout ) case ( 'zyxs' ) it_idx_kxkyz = 1 + mod (( i - lo % llim_world ) / lo % nzed , lo % ntubes ) case ( 'zxys' ) it_idx_kxkyz = 1 + mod (( i - lo % llim_world ) / lo % nzed , lo % ntubes ) case ( 'xzys' ) it_idx_kxkyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % nakx , lo % ntubes ) case ( 'yzxs' ) it_idx_kxkyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % naky , lo % ntubes ) case ( 'yxzs' ) it_idx_kxkyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % naky / lo % nakx , lo % ntubes ) case ( 'xyzs' ) it_idx_kxkyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % nakx / lo % naky , lo % ntubes ) end select end function it_idx_kxkyz elemental function proc_id_kxkyz ( lo , i ) implicit none integer :: proc_id_kxkyz type ( kxkyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i proc_id_kxkyz = i / lo % blocksize end function proc_id_kxkyz elemental function idx_kxkyz ( lo , iky , ikx , iz , it , is ) implicit none integer :: idx_kxkyz type ( kxkyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: iky , ikx , iz , it , is select case ( xyzs_layout ) case ( 'xyzs' ) idx_kxkyz = ikx - 1 + lo % nakx * ( iky - 1 + lo % naky * ( iz + lo % nzgrid + lo % nzed * ( it - 1 + lo % ntubes * ( is - 1 )))) case ( 'xzys' ) idx_kxkyz = ikx - 1 + lo % nakx * ( iz + lo % nzgrid + lo % nzed * ( it - 1 + lo % ntubes * ( iky - 1 + lo % naky * ( is - 1 )))) case ( 'yxzs' ) idx_kxkyz = iky - 1 + lo % naky * ( ikx - 1 + lo % nakx * ( iz + lo % nzgrid + lo % nzed * ( it - 1 + lo % ntubes * ( is - 1 )))) case ( 'yzxs' ) idx_kxkyz = iky - 1 + lo % naky * ( iz + lo % nzgrid + lo % nzed * ( it - 1 + lo % ntubes * ( ikx - 1 + lo % nakx * ( is - 1 )))) case ( 'zyxs' ) idx_kxkyz = iz + lo % nzgrid + lo % nzed * ( it - 1 + lo % ntubes * ( iky - 1 + lo % naky * ( ikx - 1 ))) case ( 'zxys' ) idx_kxkyz = iz + lo % nzgrid + lo % nzed * ( it - 1 + lo % ntubes * ( ikx - 1 + lo % nakx * ( iky - 1 ))) end select end function idx_kxkyz elemental function idx_local_kxkyz ( lo , iky , ikx , iz , it , is ) implicit none logical :: idx_local_kxkyz type ( kxkyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: iky , ikx , iz , it , is idx_local_kxkyz = idx_local ( lo , idx ( lo , iky , ikx , iz , it , is )) end function idx_local_kxkyz elemental function iz_local_kxkyz ( lo , iz ) implicit none logical :: iz_local_kxkyz type ( kxkyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: iz iz_local_kxkyz = lo % iproc == proc_id ( lo , iz ) end function iz_local_kxkyz subroutine init_kxyz_layout & ( nzgrid , ntubes , naky , nakx , nvgrid , nmu , nspec , ny ) use mp , only : iproc , nproc implicit none integer , intent ( in ) :: nzgrid , ntubes , ny , naky , nakx , nvgrid , nmu , nspec logical , save :: initialized = . false . if ( initialized ) return initialized = . true . kxyz_lo % iproc = iproc kxyz_lo % nzgrid = nzgrid kxyz_lo % nzed = 2 * nzgrid + 1 kxyz_lo % ntubes = ntubes kxyz_lo % ny = ny kxyz_lo % naky = naky kxyz_lo % nakx = nakx kxyz_lo % ikx_max = nakx / 2 + 1 kxyz_lo % nvgrid = nvgrid kxyz_lo % nvpa = 2 * nvgrid kxyz_lo % nmu = nmu kxyz_lo % nspec = nspec kxyz_lo % llim_world = 0 kxyz_lo % ulim_world = ny * kxyz_lo % ikx_max * kxyz_lo % nzed * ntubes * nspec - 1 kxyz_lo % blocksize = kxyz_lo % ulim_world / nproc + 1 kxyz_lo % llim_proc = kxyz_lo % blocksize * iproc kxyz_lo % ulim_proc = min ( kxyz_lo % ulim_world , kxyz_lo % llim_proc + kxyz_lo % blocksize - 1 ) kxyz_lo % ulim_alloc = max ( kxyz_lo % llim_proc , kxyz_lo % ulim_proc ) end subroutine init_kxyz_layout elemental function is_idx_kxyz ( lo , i ) implicit none integer :: is_idx_kxyz type ( kxyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i is_idx_kxyz = 1 + mod (( i - lo % llim_world ) / lo % ikx_max / lo % ny / lo % nzed / lo % ntubes , lo % nspec ) end function is_idx_kxyz elemental function ikx_idx_kxyz ( lo , i ) implicit none integer :: ikx_idx_kxyz type ( kxyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i select case ( xyzs_layout ) case ( 'xyzs' ) ikx_idx_kxyz = 1 + mod (( i - lo % llim_world ), lo % ikx_max ) case ( 'xzys' ) ikx_idx_kxyz = 1 + mod (( i - lo % llim_world ), lo % ikx_max ) case ( 'yxzs' ) ikx_idx_kxyz = 1 + mod (( i - lo % llim_world ) / lo % ny , lo % ikx_max ) case ( 'zxys' ) ikx_idx_kxyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % ntubes , lo % ikx_max ) case ( 'zyxs' ) ikx_idx_kxyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % ntubes / lo % ny , lo % ikx_max ) case ( 'yzxs' ) ikx_idx_kxyz = 1 + mod (( i - lo % llim_world ) / lo % ny / lo % nzed / lo % ntubes , lo % ikx_max ) end select end function ikx_idx_kxyz elemental function iy_idx_kxyz ( lo , i ) implicit none integer :: iy_idx_kxyz type ( kxyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i select case ( xyzs_layout ) case ( 'yxzs' ) iy_idx_kxyz = 1 + mod ( i - lo % llim_world , lo % ny ) case ( 'yzxs' ) iy_idx_kxyz = 1 + mod ( i - lo % llim_world , lo % ny ) case ( 'xyzs' ) iy_idx_kxyz = 1 + mod (( i - lo % llim_world ) / lo % ikx_max , lo % ny ) case ( 'zyxs' ) iy_idx_kxyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % ntubes , lo % ny ) case ( 'zxys' ) iy_idx_kxyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % ntubes / lo % ikx_max , lo % ny ) case ( 'xzys' ) iy_idx_kxyz = 1 + mod (( i - lo % llim_world ) / lo % ikx_max / lo % nzed / lo % ntubes , lo % ny ) end select end function iy_idx_kxyz elemental function iz_idx_kxyz ( lo , i ) implicit none integer :: iz_idx_kxyz type ( kxyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i select case ( xyzs_layout ) case ( 'zyxs' ) iz_idx_kxyz = - lo % nzgrid + mod (( i - lo % llim_world ), lo % nzed ) case ( 'zxys' ) iz_idx_kxyz = - lo % nzgrid + mod (( i - lo % llim_world ), lo % nzed ) case ( 'yzxs' ) iz_idx_kxyz = - lo % nzgrid + mod (( i - lo % llim_world ) / lo % ny , lo % nzed ) case ( 'xzys' ) iz_idx_kxyz = - lo % nzgrid + mod (( i - lo % llim_world ) / lo % ikx_max , lo % nzed ) case ( 'yxzs' ) iz_idx_kxyz = - lo % nzgrid + mod (( i - lo % llim_world ) / lo % ny / lo % ikx_max , lo % nzed ) case ( 'xyzs' ) iz_idx_kxyz = - lo % nzgrid + mod (( i - lo % llim_world ) / lo % ikx_max / lo % ny , lo % nzed ) end select end function iz_idx_kxyz elemental function it_idx_kxyz ( lo , i ) implicit none integer :: it_idx_kxyz type ( kxyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i select case ( xyzs_layout ) case ( 'zyxs' ) it_idx_kxyz = 1 + mod (( i - lo % llim_world ) / lo % nzed , lo % ntubes ) case ( 'zxys' ) it_idx_kxyz = 1 + mod (( i - lo % llim_world ) / lo % nzed , lo % ntubes ) case ( 'yzxs' ) it_idx_kxyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % ny , lo % ntubes ) case ( 'xzys' ) it_idx_kxyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % ikx_max , lo % ntubes ) case ( 'yxzs' ) it_idx_kxyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % ny / lo % ikx_max , lo % ntubes ) case ( 'xyzs' ) it_idx_kxyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % ikx_max / lo % ny , lo % ntubes ) end select end function it_idx_kxyz elemental function proc_id_kxyz ( lo , i ) implicit none integer :: proc_id_kxyz type ( kxyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i proc_id_kxyz = i / lo % blocksize end function proc_id_kxyz elemental function idx_kxyz ( lo , iy , ikx , iz , it , is ) implicit none integer :: idx_kxyz type ( kxyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: iy , ikx , iz , it , is select case ( xyzs_layout ) case ( 'xyzs' ) idx_kxyz = ikx - 1 + lo % ikx_max * ( iy - 1 + lo % ny * ( iz + lo % nzgrid + lo % nzed * ( it - 1 + lo % ntubes * ( is - 1 )))) case ( 'xzys' ) idx_kxyz = ikx - 1 + lo % ikx_max * ( iz + lo % nzgrid + lo % nzed * ( it - 1 + lo % ntubes * ( iy - 1 + lo % ny * ( is - 1 )))) case ( 'yxzs' ) idx_kxyz = iy - 1 + lo % ny * ( ikx - 1 + lo % ikx_max * ( iz + lo % nzgrid + lo % nzed * ( it - 1 + lo % ntubes * ( is - 1 )))) case ( 'yzxs' ) idx_kxyz = iy - 1 + lo % ny * ( iz + lo % nzgrid + lo % nzed * ( it - 1 + lo % ntubes * ( ikx - 1 + lo % ikx_max * ( is - 1 )))) case ( 'zyxs' ) idx_kxyz = iz + lo % nzgrid + lo % nzed * ( it - 1 + lo % ntubes * ( iy - 1 + lo % ny * ( ikx - 1 ))) case ( 'zxys' ) idx_kxyz = iz + lo % nzgrid + lo % nzed * ( it - 1 + lo % ntubes * ( ikx - 1 + lo % ikx_max * ( iy - 1 ))) end select end function idx_kxyz elemental function idx_local_kxyz ( lo , iy , ikx , iz , it , is ) implicit none logical :: idx_local_kxyz type ( kxyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: iy , ikx , iz , it , is idx_local_kxyz = idx_local ( lo , idx ( lo , iy , ikx , iz , it , is )) end function idx_local_kxyz elemental function iz_local_kxyz ( lo , iz ) implicit none logical :: iz_local_kxyz type ( kxyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: iz iz_local_kxyz = lo % iproc == proc_id ( lo , iz ) end function iz_local_kxyz subroutine init_xyz_layout & ( nzgrid , ntubes , naky , nakx , nvgrid , nmu , nspec , ny , nx ) use mp , only : iproc , nproc implicit none integer , intent ( in ) :: nzgrid , ntubes , ny , nx , naky , nakx , nvgrid , nmu , nspec logical , save :: initialized = . false . if ( initialized ) return initialized = . true . xyz_lo % iproc = iproc xyz_lo % nzgrid = nzgrid xyz_lo % nzed = 2 * nzgrid + 1 xyz_lo % ntubes = ntubes xyz_lo % ny = ny xyz_lo % nx = nx xyz_lo % naky = naky xyz_lo % nakx = nakx xyz_lo % nvgrid = nvgrid xyz_lo % nvpa = 2 * nvgrid xyz_lo % nmu = nmu xyz_lo % nspec = nspec xyz_lo % llim_world = 0 xyz_lo % ulim_world = ny * nx * xyz_lo % nzed * xyz_lo % ntubes * nspec - 1 xyz_lo % blocksize = xyz_lo % ulim_world / nproc + 1 xyz_lo % llim_proc = xyz_lo % blocksize * iproc xyz_lo % ulim_proc = min ( xyz_lo % ulim_world , xyz_lo % llim_proc + xyz_lo % blocksize - 1 ) xyz_lo % ulim_alloc = max ( xyz_lo % llim_proc , xyz_lo % ulim_proc ) end subroutine init_xyz_layout elemental function is_idx_xyz ( lo , i ) implicit none integer :: is_idx_xyz type ( xyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i is_idx_xyz = 1 + mod (( i - lo % llim_world ) / lo % nx / lo % ny / lo % nzed / lo % ntubes , lo % nspec ) end function is_idx_xyz elemental function ix_idx_xyz ( lo , i ) implicit none integer :: ix_idx_xyz type ( xyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i select case ( xyzs_layout ) case ( 'xyzs' ) ix_idx_xyz = 1 + mod (( i - lo % llim_world ), lo % nx ) case ( 'xzys' ) ix_idx_xyz = 1 + mod (( i - lo % llim_world ), lo % nx ) case ( 'yxzs' ) ix_idx_xyz = 1 + mod (( i - lo % llim_world ) / lo % ny , lo % nx ) case ( 'zxys' ) ix_idx_xyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % ntubes , lo % nx ) case ( 'zyxs' ) ix_idx_xyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % ntubes / lo % ny , lo % nx ) case ( 'yzxs' ) ix_idx_xyz = 1 + mod (( i - lo % llim_world ) / lo % ny / lo % nzed / lo % ntubes , lo % nx ) end select end function ix_idx_xyz elemental function iy_idx_xyz ( lo , i ) implicit none integer :: iy_idx_xyz type ( xyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i select case ( xyzs_layout ) case ( 'yxzs' ) iy_idx_xyz = 1 + mod ( i - lo % llim_world , lo % ny ) case ( 'yzxs' ) iy_idx_xyz = 1 + mod ( i - lo % llim_world , lo % ny ) case ( 'xyzs' ) iy_idx_xyz = 1 + mod (( i - lo % llim_world ) / lo % nx , lo % ny ) case ( 'zyxs' ) iy_idx_xyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % ntubes , lo % ny ) case ( 'zxys' ) iy_idx_xyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % ntubes / lo % nx , lo % ny ) case ( 'xzys' ) iy_idx_xyz = 1 + mod (( i - lo % llim_world ) / lo % nx / lo % nzed / lo % ntubes , lo % ny ) end select end function iy_idx_xyz elemental function iz_idx_xyz ( lo , i ) implicit none integer :: iz_idx_xyz type ( xyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i select case ( xyzs_layout ) case ( 'zyxs' ) iz_idx_xyz = - lo % nzgrid + mod (( i - lo % llim_world ), lo % nzed ) case ( 'zxys' ) iz_idx_xyz = - lo % nzgrid + mod (( i - lo % llim_world ), lo % nzed ) case ( 'yzxs' ) iz_idx_xyz = - lo % nzgrid + mod (( i - lo % llim_world ) / lo % ny , lo % nzed ) case ( 'xzys' ) iz_idx_xyz = - lo % nzgrid + mod (( i - lo % llim_world ) / lo % nx , lo % nzed ) case ( 'yxzs' ) iz_idx_xyz = - lo % nzgrid + mod (( i - lo % llim_world ) / lo % ny / lo % nx , lo % nzed ) case ( 'xyzs' ) iz_idx_xyz = - lo % nzgrid + mod (( i - lo % llim_world ) / lo % nx / lo % ny , lo % nzed ) end select end function iz_idx_xyz elemental function it_idx_xyz ( lo , i ) implicit none integer :: it_idx_xyz type ( xyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i select case ( xyzs_layout ) case ( 'zyxs' ) it_idx_xyz = 1 + mod (( i - lo % llim_world ) / lo % nzed , lo % ntubes ) case ( 'zxys' ) it_idx_xyz = 1 + mod (( i - lo % llim_world ) / lo % nzed , lo % ntubes ) case ( 'yzxs' ) it_idx_xyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % ny , lo % ntubes ) case ( 'xzys' ) it_idx_xyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % nx , lo % ntubes ) case ( 'yxzs' ) it_idx_xyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % ny / lo % nx , lo % ntubes ) case ( 'xyzs' ) it_idx_xyz = 1 + mod (( i - lo % llim_world ) / lo % nzed / lo % nx / lo % ny , lo % ntubes ) end select end function it_idx_xyz elemental function proc_id_xyz ( lo , i ) implicit none integer :: proc_id_xyz type ( xyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i proc_id_xyz = i / lo % blocksize end function proc_id_xyz elemental function idx_xyz ( lo , iy , ix , iz , it , is ) implicit none integer :: idx_xyz type ( xyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: iy , ix , iz , it , is select case ( xyzs_layout ) case ( 'xyzs' ) idx_xyz = ix - 1 + lo % nx * ( iy - 1 + lo % ny * ( iz + lo % nzgrid + lo % nzed * ( it - 1 + lo % ntubes * ( is - 1 )))) case ( 'xzys' ) idx_xyz = ix - 1 + lo % nx * ( iz + lo % nzgrid + lo % nzed * ( it - 1 + lo % ntubes * ( iy - 1 + lo % ny * ( is - 1 )))) case ( 'yxzs' ) idx_xyz = iy - 1 + lo % ny * ( ix - 1 + lo % nx * ( iz + lo % nzgrid + lo % nzed * ( it - 1 + lo % ntubes * ( is - 1 )))) case ( 'yzxs' ) idx_xyz = iy - 1 + lo % ny * ( iz + lo % nzgrid + lo % nzed * ( it - 1 + lo % ntubes * ( ix - 1 + lo % nx * ( is - 1 )))) case ( 'zyxs' ) idx_xyz = iz + lo % nzgrid + lo % nzed * ( it - 1 + lo % ntubes * ( iy - 1 + lo % ny * ( ix - 1 ))) case ( 'zxys' ) idx_xyz = iz + lo % nzgrid + lo % nzed * ( it - 1 + lo % ntubes * ( ix - 1 + lo % nx * ( iy - 1 ))) end select end function idx_xyz elemental function idx_local_xyz ( lo , iy , ix , iz , it , is ) implicit none logical :: idx_local_xyz type ( xyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: iy , ix , iz , it , is idx_local_xyz = idx_local ( lo , idx ( lo , iy , ix , iz , it , is )) end function idx_local_xyz elemental function iz_local_xyz ( lo , iz ) implicit none logical :: iz_local_xyz type ( xyz_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: iz iz_local_xyz = lo % iproc == proc_id ( lo , iz ) end function iz_local_xyz subroutine init_vmu_layout & ( nzgrid , ntubes , naky , nakx , nvgrid , nmu , nspec , ny , nx , nalpha ) use mp , only : iproc , nproc implicit none integer , intent ( in ) :: nzgrid , ntubes , naky , nakx , nvgrid , nmu , nspec , ny , nx , nalpha logical , save :: initialized = . false . if ( initialized ) return initialized = . true . vmu_lo % xyz = . true . vmu_lo % iproc = iproc vmu_lo % nzed = 2 * nzgrid + 1 vmu_lo % nzgrid = nzgrid vmu_lo % ntubes = ntubes vmu_lo % ny = ny vmu_lo % nalpha = nalpha vmu_lo % naky = naky vmu_lo % nx = nx vmu_lo % nakx = nakx vmu_lo % nvgrid = nvgrid vmu_lo % nvpa = 2 * nvgrid vmu_lo % nmu = nmu vmu_lo % nspec = nspec vmu_lo % llim_world = 0 vmu_lo % ulim_world = vmu_lo % nvpa * nmu * nspec - 1 vmu_lo % blocksize = vmu_lo % ulim_world / nproc + 1 vmu_lo % llim_proc = vmu_lo % blocksize * iproc vmu_lo % ulim_proc = min ( vmu_lo % ulim_world , vmu_lo % llim_proc + vmu_lo % blocksize - 1 ) vmu_lo % ulim_alloc = max ( vmu_lo % llim_proc , vmu_lo % ulim_proc ) end subroutine init_vmu_layout elemental function is_idx_vmu ( lo , i ) implicit none integer :: is_idx_vmu type ( vmu_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i ! the order of the division does not matter, so no need for branching is_idx_vmu = 1 + mod (( i - lo % llim_world ) / lo % nvpa / lo % nmu , lo % nspec ) end function is_idx_vmu elemental function imu_idx_vmu ( lo , i ) implicit none integer :: imu_idx_vmu type ( vmu_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i select case ( vms_layout ) case ( 'vms' ) imu_idx_vmu = 1 + mod (( i - lo % llim_world ) / lo % nvpa , lo % nmu ) case ( 'mvs' ) imu_idx_vmu = 1 + mod (( i - lo % llim_world ), lo % nmu ) end select end function imu_idx_vmu elemental function iv_idx_vmu ( lo , i ) implicit none integer :: iv_idx_vmu type ( vmu_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i select case ( vms_layout ) case ( 'vms' ) iv_idx_vmu = 1 + mod (( i - lo % llim_world ), lo % nvpa ) case ( 'mvs' ) iv_idx_vmu = 1 + mod (( i - lo % llim_world ) / lo % nmu , lo % nvpa ) end select end function iv_idx_vmu elemental function proc_id_vmu ( lo , i ) implicit none integer :: proc_id_vmu type ( vmu_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: i proc_id_vmu = i / lo % blocksize end function proc_id_vmu elemental function idx_vmu ( lo , iv , imu , is ) implicit none integer :: idx_vmu type ( vmu_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: iv , imu , is select case ( vms_layout ) case ( 'vms' ) idx_vmu = iv - 1 + lo % nvpa * ( imu - 1 + lo % nmu * ( is - 1 )) case ( 'mvs' ) idx_vmu = imu - 1 + lo % nmu * ( iv - 1 + lo % nvpa * ( is - 1 )) end select end function idx_vmu elemental function idx_local_vmu ( lo , iv , imu , is ) implicit none logical :: idx_local_vmu type ( vmu_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: iv , imu , is idx_local_vmu = idx_local ( lo , idx ( lo , iv , imu , is )) end function idx_local_vmu elemental function iz_local_vmu ( lo , iz ) implicit none logical :: iz_local_vmu type ( vmu_layout_type ), intent ( in ) :: lo integer , intent ( in ) :: iz iz_local_vmu = lo % iproc == proc_id ( lo , iz ) end function iz_local_vmu elemental subroutine kxkyzidx2vmuidx ( iv , imu , ikxkyz , kxkyz_lo , vmu_lo , iky , ikx , iz , it , ivmu ) implicit none integer , intent ( in ) :: iv , imu , ikxkyz type ( kxkyz_layout_type ), intent ( in ) :: kxkyz_lo type ( vmu_layout_type ), intent ( in ) :: vmu_lo integer , intent ( out ) :: iky , ikx , iz , it , ivmu iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) ivmu = idx ( vmu_lo , iv , imu , is_idx ( kxkyz_lo , ikxkyz )) end subroutine kxkyzidx2vmuidx elemental subroutine kxyzidx2vmuidx ( iv , imu , ikxyz , kxyz_lo , vmu_lo , iy , ikx , iz , it , ivmu ) implicit none integer , intent ( in ) :: iv , imu , ikxyz type ( kxyz_layout_type ), intent ( in ) :: kxyz_lo type ( vmu_layout_type ), intent ( in ) :: vmu_lo integer , intent ( out ) :: iy , ikx , iz , it , ivmu iy = iy_idx ( kxyz_lo , ikxyz ) ikx = ikx_idx ( kxyz_lo , ikxyz ) iz = iz_idx ( kxyz_lo , ikxyz ) it = it_idx ( kxyz_lo , ikxyz ) ivmu = idx ( vmu_lo , iv , imu , is_idx ( kxyz_lo , ikxyz )) end subroutine kxyzidx2vmuidx elemental subroutine xyzidx2vmuidx ( iv , imu , ixyz , xyz_lo , vmu_lo , iy , ix , iz , it , ivmu ) implicit none integer , intent ( in ) :: iv , imu , ixyz type ( xyz_layout_type ), intent ( in ) :: xyz_lo type ( vmu_layout_type ), intent ( in ) :: vmu_lo integer , intent ( out ) :: iy , ix , iz , it , ivmu iy = iy_idx ( xyz_lo , ixyz ) ix = ix_idx ( xyz_lo , ixyz ) iz = iz_idx ( xyz_lo , ixyz ) it = it_idx ( xyz_lo , ixyz ) ivmu = idx ( vmu_lo , iv , imu , is_idx ( xyz_lo , ixyz )) end subroutine xyzidx2vmuidx subroutine finish_layouts implicit none end subroutine finish_layouts end module stella_layouts","tags":"","loc":"sourcefile/stella_layouts.f90.html"},{"title":"inputprofiles_interface.f90 – stella","text":"Source Code module inputprofiles_interface implicit none public :: read_inputprof_geo , read_inputprof_spec private integer :: n_exp real , dimension (:), allocatable :: rhotor , rmin , rmaj_in , qinp , kappa real , dimension (:), allocatable :: delta , Te , ne , z_eff , omega0 real , dimension (:), allocatable :: ni , Ti real , dimension (:), allocatable :: dr real , dimension (:), allocatable :: rhoc , rmaj , shift real , dimension (:), allocatable :: shat , d2qdr2 real , dimension (:), allocatable :: tri , triprim real , dimension (:), allocatable :: kapprim real , dimension (:), allocatable :: neprim , Teprim real , dimension (:), allocatable :: niprim , Tiprim real , dimension (:), allocatable :: nedbprim , Tedbprim real , dimension (:), allocatable :: nidbprim , Tidbprim real , dimension (:), allocatable :: betaprim , betadbprim real , dimension (:), allocatable :: psitor real , dimension (:), allocatable :: drhotordrho , dpsitordrho , d2psitordrho2 real , dimension (:), allocatable :: pres_tot real , dimension (:), allocatable :: loglam real :: bref , omega_ref , rho_ref real :: bunit contains subroutine read_inputprof_geo ( surf ) use constants , only : pi use common_types , only : flux_surface_type use finite_differences , only : fd3pt , d2_3pt use splines , only : geo_spline use millerlocal , only : local implicit none type ( flux_surface_type ), intent ( in out ) :: surf integer :: in_unit = 101 character ( 10 ) :: dum character ( 500 ) :: line real :: bt_exp real :: arho_exp real :: aref real :: mu0 integer :: ir open ( unit = in_unit , file = 'input.profiles' , status = 'old' , action = 'read' ) ! read in header and ignore read ( in_unit , * ) line read ( in_unit , * ) line read ( in_unit , * ) line read ( in_unit , * ) line read ( in_unit , * ) line read ( in_unit , * ) dum , n_exp read ( in_unit , * ) dum , bt_exp read ( in_unit , * ) dum , arho_exp call allocate_arrays_geo ! read in more headers read ( in_unit , * ) line read ( in_unit , * ) line do ir = 1 , n_exp read ( in_unit , * ) rhotor ( ir ), rmin ( ir ), rmaj_in ( ir ), qinp ( ir ), kappa ( ir ) end do ! aref is stella reference length (device minor radius) aref = rmin ( n_exp ) rhoc = rmin / aref rmaj = rmaj_in / aref ! read in more headers read ( in_unit , * ) line read ( in_unit , * ) line do ir = 1 , n_exp read ( in_unit , * ) delta ( ir ), Te ( ir ), ne ( ir ), line end do ! stella redefines delat to be ArcSin(delta_miller) tri = asin ( delta ) ! read in more headers read ( in_unit , * ) line read ( in_unit , * ) line ! read in some stuff we don't need to use at the moment do ir = 1 , n_exp read ( in_unit , * ) line end do ! read in more headers read ( in_unit , * ) line read ( in_unit , * ) line ! read in some stuff we don't need to use at the moment do ir = 1 , n_exp read ( in_unit , * ) line end do ! read in more headers read ( in_unit , * ) line read ( in_unit , * ) line do ir = 1 , n_exp read ( in_unit , * ) ni ( ir ), line end do ! read in more headers read ( in_unit , * ) line read ( in_unit , * ) line do ir = 1 , n_exp read ( in_unit , * ) Ti ( ir ), line end do close ( in_unit ) dr = rhoc ( 2 :) - rhoc (: n_exp - 1 ) ! obtain s_hat call fd3pt ( qinp , shat , dr ) shat = rhoc * shat / qinp ! obtain d2q/dr2 call d2_3pt ( qinp , d2qdr2 , dr ) ! obtain d (kappa) / drho call fd3pt ( kappa , kapprim , dr ) ! obtain d (ArcSin(delta_miller)) / drho call fd3pt ( tri , triprim , dr ) ! obtain dR/drho call fd3pt ( rmaj , shift , dr ) pres_tot = ne * Te + ni * Ti call fd3pt ( pres_tot , betaprim , dr ) call d2_3pt ( pres_tot , betadbprim , dr ) mu0 = 4. * pi * 1.e-7 betaprim = - mu0 * betaprim * 1.6022e3 / bt_exp ** 2 betadbprim = - mu0 * betadbprim * 1.6022e3 / bt_exp ** 2 ! this is psi_toroidal/(Bref aref**2)/2pi ! assumption here is that Bref = BT_EXP psitor = 0.5 * rhotor * rhotor * ( arho_exp / aref ) ** 2 ! get drhotordr call fd3pt ( rhotor , drhotordrho , dr ) call fd3pt ( psitor , dpsitordrho , dr ) call d2_3pt ( psitor , d2psitordrho2 , dr ) ! this sets the reference B-field to be bt_exp !    dpsitordrho = rhotor*drhotordrho*(arho_exp/aref)**2 ! next need to pick out the correct flux surface ! and assign various local% values call geo_spline ( rhoc , rmaj , local % rhoc , local % rmaj ) call geo_spline ( rhoc , dpsitordrho , local % rhoc , local % dpsitordrho ) call geo_spline ( rhoc , d2psitordrho2 , local % rhoc , local % d2psitordrho2 ) call geo_spline ( rhoc , shift , local % rhoc , local % shift ) call geo_spline ( rhoc , kappa , local % rhoc , local % kappa ) call geo_spline ( rhoc , kapprim , local % rhoc , local % kapprim ) call geo_spline ( rhoc , qinp , local % rhoc , local % qinp ) call geo_spline ( rhoc , shat , local % rhoc , local % shat ) call geo_spline ( rhoc , d2qdr2 , local % rhoc , local % d2qdr2 ) call geo_spline ( rhoc , tri , local % rhoc , local % tri ) call geo_spline ( rhoc , triprim , local % rhoc , local % triprim ) call geo_spline ( rhoc , betaprim , local % rhoc , local % betaprim ) call geo_spline ( rhoc , betadbprim , local % rhoc , local % betadbprim ) call geo_spline ( rhoc , rhotor , local % rhoc , local % rhotor ) call geo_spline ( rhoc , drhotordrho , local % rhoc , local % drhotordrho ) local % psitor_lcfs = psitor ( n_exp ) local % zed0_fac = 1.0 surf = local call deallocate_arrays_geo end subroutine read_inputprof_geo subroutine read_inputprof_spec ( nspec , spec ) use mp , only : mp_abort use finite_differences , only : fd3pt , d2_3pt use splines , only : geo_spline use common_types , only : spec_type use millerlocal , only : local use physics_parameters , only : vnew_ref , rhostar implicit none integer , intent ( in ) :: nspec type ( spec_type ), dimension (:), intent ( in out ) :: spec integer , parameter :: electron_species = 2 integer :: in_unit = 102 character ( 10 ) :: dum character ( 500 ) :: line real :: bt_exp real :: arho_exp real :: aref real :: mref , nref , tref real :: vtref , local_loglam integer :: ir , is open ( unit = in_unit , file = 'input.profiles' , status = 'old' , action = 'read' ) ! read in header and ignore read ( in_unit , * ) line read ( in_unit , * ) line read ( in_unit , * ) line read ( in_unit , * ) line read ( in_unit , * ) line read ( in_unit , * ) dum , n_exp read ( in_unit , * ) dum , bt_exp read ( in_unit , * ) dum , arho_exp call allocate_arrays_spec ! read in more headers read ( in_unit , * ) line read ( in_unit , * ) line do ir = 1 , n_exp read ( in_unit , * ) rhotor ( ir ), rmin ( ir ), line end do ! aref is stella reference length (device minor radius) aref = rmin ( n_exp ) rhoc = rmin / aref ! read in more headers read ( in_unit , * ) line read ( in_unit , * ) line do ir = 1 , n_exp read ( in_unit , * ) dum , Te ( ir ), ne ( ir ), z_eff ( ir ), omega0 ( ir ) end do ! read in more headers read ( in_unit , * ) line read ( in_unit , * ) line ! read in some stuff we don't need to use at the moment do ir = 1 , n_exp read ( in_unit , * ) line end do ! read in more headers read ( in_unit , * ) line read ( in_unit , * ) line ! read in some stuff we don't need to use at the moment do ir = 1 , n_exp read ( in_unit , * ) line end do ! read in more headers read ( in_unit , * ) line read ( in_unit , * ) line do ir = 1 , n_exp read ( in_unit , * ) ni ( ir ), line end do ! read in more headers read ( in_unit , * ) line read ( in_unit , * ) line do ir = 1 , n_exp read ( in_unit , * ) Ti ( ir ), line end do close ( in_unit ) dr = rhoc ( 2 :) - rhoc (: n_exp - 1 ) ! obtain -d ln(ne) / drho call fd3pt ( ne , neprim , dr ) call d2_3pt ( ne , nedbprim , dr ) neprim = - neprim / ne nedbprim = nedbprim / ne ! obtain -d ln(Te) / drho call fd3pt ( Te , Teprim , dr ) call d2_3pt ( Te , Tedbprim , dr ) Teprim = - Teprim / Te Tedbprim = Tedbprim / Te ! obtain -d ln(ni) / drho call fd3pt ( ni , niprim , dr ) call d2_3pt ( ni , nidbprim , dr ) niprim = - niprim / ni nidbprim = nidbprim / ni ! obtain -d ln(Ti) / drho call fd3pt ( Ti , Tiprim , dr ) call d2_3pt ( Ti , Tidbprim , dr ) Tiprim = - Tiprim / Ti Tidbprim = Tidbprim / Ti ! next need to pick out the correct flux surface ! and assign various local% values ! choose first species as reference species is = 1 spec ( is )% dens = 1.0 spec ( is )% temp = 1.0 ! get reference density and temperature if ( spec ( is )% type == electron_species ) then call geo_spline ( rhoc , Te , local % rhoc , tref ) call geo_spline ( rhoc , ne , local % rhoc , nref ) ! only needed for collisions -- reference mass in units of proton mass ! and is only included for clarity -- factors of mref cancel in the end mref = 5.44625e-4 else call geo_spline ( rhoc , Ti , local % rhoc , tref ) call geo_spline ( rhoc , ni , local % rhoc , nref ) ! only needed for collisions -- reference mass in units of proton mass ! and is only included for clarity -- factors of mref cancel in the end mref = 2.0 end if ! next get the normalized density and temperature for all other species if ( nspec == 2 ) then do is = 2 , nspec if ( spec ( is )% type == electron_species ) then call geo_spline ( rhoc , Te / tref , local % rhoc , spec ( is )% temp ) call geo_spline ( rhoc , ne / nref , local % rhoc , spec ( is )% dens ) else call geo_spline ( rhoc , Ti / tref , local % rhoc , spec ( is )% temp ) call geo_spline ( rhoc , ni / tref , local % rhoc , spec ( is )% dens ) end if end do else if ( nspec > 2 ) then call mp_abort ( 'multiple ion species not currently supported for input.profiles. aborting.' ) end if ! now get the density and temperature gradients at the requested flux surface do is = 1 , nspec if ( spec ( is )% type == electron_species ) then call geo_spline ( rhoc , Teprim , local % rhoc , spec ( is )% tprim ) call geo_spline ( rhoc , Tedbprim , local % rhoc , spec ( is )% d2Tdr2 ) call geo_spline ( rhoc , neprim , local % rhoc , spec ( is )% fprim ) call geo_spline ( rhoc , nedbprim , local % rhoc , spec ( is )% d2ndr2 ) else call geo_spline ( rhoc , Tiprim , local % rhoc , spec ( is )% tprim ) call geo_spline ( rhoc , Tidbprim , local % rhoc , spec ( is )% d2Tdr2 ) call geo_spline ( rhoc , niprim , local % rhoc , spec ( is )% fprim ) call geo_spline ( rhoc , nidbprim , local % rhoc , spec ( is )% d2ndr2 ) end if end do ! get collisionalities for stella loglam = 2 4.0 - log ( 1e4 * sqrt ( 0.1 * ne ) / te ) call geo_spline ( rhoc , loglam , local % rhoc , local_loglam ) ! vtref = sqrt(2*Tref/mref), with Tref and mref in SI units ! so vtref has dimensions of meters / second ! note that tref below is T in units of keV and mref is in units of proton mass vtref = 3.09497e5 * sqrt ( 2. * tref / mref ) ! reference collision frequency for stella ! uses the mass, density and temperature of the reference species, ! along with the proton charge in the expression ! vnew_ref = (aref/vtref)*(4/3)sqrt(2pi)/(4pi*epsilon_0)**2 * nref * e**4 * loglam / sqrt(mref) / Tref**1.5 ! note that all quantities are given in SI units and epsilon_0 is permittivity of vacuum vnew_ref = 2 8.5134 * ( aref / vtref ) * local_loglam * nref / ( sqrt ( mref ) * tref ** 1.5 ) bref = bt_exp omega_ref = 9.5791e7 * bref / mref rho_ref = vtref / omega_ref rhostar = rho_ref / aref ! I think this is incorrect -- MAB bunit = ( bref * arho_exp ** 2 ) / ( local % rhotor / aref / local % rhoc ) * local % drhotordrho !    vnewki = 9.21e-5*aref*zi**4/sqrt(2.)*loglam*ni/ti**2 !    vnewke = 3.95e-3*aref*zi**2*sqrt(0.5*mi)*loglam*ne & !         /(sqrt(ti)*te**1.5) call deallocate_arrays_spec end subroutine read_inputprof_spec subroutine allocate_arrays_geo implicit none allocate ( rhotor ( n_exp )) allocate ( psitor ( n_exp )) allocate ( rmin ( n_exp )) allocate ( rmaj_in ( n_exp )) allocate ( qinp ( n_exp )) allocate ( kappa ( n_exp )) allocate ( rhoc ( n_exp )) allocate ( rmaj ( n_exp )) allocate ( delta ( n_exp )) allocate ( tri ( n_exp )) allocate ( ne ( n_exp )) allocate ( Te ( n_exp )) allocate ( ni ( n_exp )) allocate ( Ti ( n_exp )) allocate ( dr ( n_exp - 1 )) allocate ( shat ( n_exp )) allocate ( d2qdr2 ( n_exp )) allocate ( kapprim ( n_exp )) allocate ( triprim ( n_exp )) allocate ( shift ( n_exp )) allocate ( betaprim ( n_exp )) allocate ( betadbprim ( n_exp )) allocate ( pres_tot ( n_exp )) allocate ( drhotordrho ( n_exp )) allocate ( dpsitordrho ( n_exp )) allocate ( d2psitordrho2 ( n_exp )) end subroutine allocate_arrays_geo subroutine allocate_arrays_spec implicit none allocate ( rhotor ( n_exp )) allocate ( rmin ( n_exp )) allocate ( rhoc ( n_exp )) allocate ( Te ( n_exp )) allocate ( ne ( n_exp )) allocate ( z_eff ( n_exp )) allocate ( omega0 ( n_exp )) allocate ( ni ( n_exp )) allocate ( Ti ( n_exp )) allocate ( dr ( n_exp - 1 )) allocate ( neprim ( n_exp )) allocate ( nedbprim ( n_exp )) allocate ( Teprim ( n_exp )) allocate ( Tedbprim ( n_exp )) allocate ( niprim ( n_exp )) allocate ( nidbprim ( n_exp )) allocate ( Tiprim ( n_exp )) allocate ( Tidbprim ( n_exp )) allocate ( loglam ( n_exp )) !    allocate (vnewki(n_exp)) !    allocate (vnewke(n_exp)) end subroutine allocate_arrays_spec subroutine deallocate_arrays_geo implicit none deallocate ( rhotor ) deallocate ( rmin ) deallocate ( rmaj_in ) deallocate ( rmaj ) deallocate ( qinp ) deallocate ( kappa ) deallocate ( rhoc ) deallocate ( delta ) deallocate ( Te ) deallocate ( ne ) deallocate ( tri ) deallocate ( ni ) deallocate ( Ti ) deallocate ( dr ) deallocate ( shat ) deallocate ( d2qdr2 ) deallocate ( kapprim ) deallocate ( triprim ) deallocate ( shift ) deallocate ( betaprim ) deallocate ( betadbprim ) deallocate ( pres_tot ) deallocate ( drhotordrho ) deallocate ( dpsitordrho ) deallocate ( d2psitordrho2 ) end subroutine deallocate_arrays_geo subroutine deallocate_arrays_spec implicit none deallocate ( rhotor ) deallocate ( rmin ) deallocate ( rhoc ) deallocate ( Te ) deallocate ( ne ) deallocate ( z_eff ) deallocate ( omega0 ) deallocate ( ni ) deallocate ( Ti ) deallocate ( dr ) deallocate ( neprim ) deallocate ( nedbprim ) deallocate ( Teprim ) deallocate ( Tedbprim ) deallocate ( niprim ) deallocate ( nidbprim ) deallocate ( Tiprim ) deallocate ( Tidbprim ) deallocate ( loglam ) !    deallocate (vnewki) !    deallocate (vnewke) end subroutine deallocate_arrays_spec end module inputprofiles_interface","tags":"","loc":"sourcefile/inputprofiles_interface.f90.html"},{"title":"multibox.f90 – stella","text":"Source Code module multibox use fft_work , only : fft_type implicit none public :: read_multibox_parameters public :: init_multibox public :: finish_multibox public :: multibox_communicate public :: apply_radial_boundary_conditions public :: init_mb_get_phi public :: mb_get_phi public :: communicate_multibox_parameters public :: add_multibox_krook public :: bs_fullgrid public :: xL , xR public :: rhoL , rhoR public :: kx0_L , kx0_R public :: RK_step , comm_at_init public :: include_multibox_krook public :: time_multibox public :: phi_buffer0 , phi_buffer1 public :: use_dirichlet_BC private complex , dimension (:), allocatable :: g_buffer0 , g_buffer1 , phi_buffer0 , phi_buffer1 complex , dimension (:), allocatable :: fsa_x real , dimension (:), allocatable :: copy_mask_left , copy_mask_right real , dimension (:), allocatable :: krook_mask_left , krook_mask_right real , dimension (:), allocatable :: krook_fac real , dimension (:), allocatable :: b_mat real , dimension (:), allocatable :: x_mb , rho_mb , rho_mb_clamped real , dimension ( 2 , 2 ) :: time_multibox = 0. real :: dx_mb complex , dimension (:, :), allocatable :: fft_kxky , fft_xky real , dimension (:, :), allocatable :: fft_xy ! for the unpadded FFTs type ( fft_type ) :: yf_fft , yb_fft type ( fft_type ) :: xf_fft , xb_fft complex , dimension (:), allocatable :: fft_x_k , fft_x_x complex , dimension (:), allocatable :: fft_y_k real , dimension (:), allocatable :: fft_y_y logical :: mb_transforms_initialized = . false . logical :: get_phi_initialized = . false . logical :: use_multibox integer :: temp_ind = 0 integer :: bs_fullgrid integer :: mb_debug_step integer :: x_fft_size integer :: phi_bound , phi_pow integer :: ikymin real :: xL = 0. , xR = 0. real :: rhoL = 0. , rhoR = 0. real :: kx0_L , kx0_R !real :: efac_l, efacp_l real :: nu_krook_mb , krook_exponent , krook_efold logical :: smooth_ZFs , use_dirichlet_BC logical :: RK_step , include_multibox_krook , comm_at_init integer :: krook_option_switch integer , parameter :: krook_option_default = 2 , & krook_option_flat = 0 , & krook_option_linear = 1 , & krook_option_exp = 2 , & krook_option_exp_rev = 3 integer :: mb_zf_option_switch integer , parameter :: mb_zf_option_default = 0 , & mb_zf_option_skip_ky0 = 1 , & mb_zf_option_zero_ky0 = 2 , & mb_zf_option_zero_fsa = 3 integer :: LR_debug_switch integer , parameter :: LR_debug_option_default = 0 , & LR_debug_option_L = 1 , & LR_debug_option_R = 2 contains subroutine read_multibox_parameters use file_utils , only : input_unit_exist , error_unit use file_utils , only : runtype_option_switch , runtype_multibox use text_options , only : text_option , get_option_value use mp , only : broadcast , proc0 use kt_grids , only : nx , nakx , boundary_size , copy_size , krook_size use job_manage , only : njobs use mp , only : scope , crossdomprocs , subprocs , & send , receive , job implicit none integer :: in_file , ierr integer :: nakxl , nxl , nakxr , nxr , fac logical exist type ( text_option ), dimension ( 5 ), parameter :: krook_opts = & ( / text_option ( 'default' , krook_option_default ), & text_option ( 'flat' , krook_option_flat ), & text_option ( 'linear' , krook_option_linear ), & text_option ( 'exp' , krook_option_exp ), & text_option ( 'exp_reverse' , krook_option_exp_rev ) / ) type ( text_option ), dimension ( 4 ), parameter :: mb_zf_opts = & ( / text_option ( 'default' , mb_zf_option_default ), & text_option ( 'skip_ky0' , mb_zf_option_skip_ky0 ), & text_option ( 'zero_ky0' , mb_zf_option_zero_ky0 ), & text_option ( 'zero_fsa' , mb_zf_option_zero_fsa ) / ) type ( text_option ), dimension ( 3 ), parameter :: LR_db_opts = & ( / text_option ( 'default' , LR_debug_option_default ), & text_option ( 'L' , LR_debug_option_L ), & text_option ( 'R' , LR_debug_option_R ) / ) character ( 30 ) :: zf_option , krook_option , LR_debug_option namelist / multibox_parameters / boundary_size , krook_size , & smooth_ZFs , zf_option , LR_debug_option , & krook_option , RK_step , nu_krook_mb , & mb_debug_step , krook_exponent , comm_at_init , & phi_bound , phi_pow , krook_efold , use_dirichlet_BC !   if(runtype_option_switch /= runtype_multibox) then !     boundary_size = 0; krook_size = 0; copy_size = 0 !     return !   endif boundary_size = 4 krook_size = 0 phi_bound = 0 phi_pow = 0 krook_exponent = 0.0 krook_efold = 3.0 nu_krook_mb = 0.0 mb_debug_step = - 1 smooth_ZFs = . false . comm_at_init = . false . RK_step = . false . zf_option = 'default' krook_option = 'default' LR_debug_option = 'default' use_dirichlet_BC = . false . if ( proc0 ) then in_file = input_unit_exist ( \"multibox_parameters\" , exist ) if ( exist ) read ( in_file , nml = multibox_parameters ) ierr = error_unit () call get_option_value & ( krook_option , krook_opts , krook_option_switch , & ierr , \"krook_option in multibox_parameters\" ) call get_option_value & ( zf_option , mb_zf_opts , mb_zf_option_switch , & ierr , \"zf_option in multibox_parameters\" ) call get_option_value & ( LR_debug_option , LR_db_opts , LR_debug_switch , & ierr , \"LR_debug_option in multibox_parameters\" ) if ( krook_size > boundary_size ) krook_size = boundary_size end if call broadcast ( boundary_size ) call broadcast ( krook_size ) call broadcast ( nu_krook_mb ) call broadcast ( smooth_ZFs ) call broadcast ( mb_zf_option_switch ) call broadcast ( krook_option_switch ) call broadcast ( krook_exponent ) call broadcast ( krook_efold ) call broadcast ( LR_debug_switch ) call broadcast ( RK_step ) call broadcast ( mb_debug_step ) call broadcast ( comm_at_init ) call broadcast ( phi_bound ) call broadcast ( phi_pow ) call broadcast ( use_dirichlet_BC ) if ( runtype_option_switch == runtype_multibox ) then call scope ( crossdomprocs ) if ( job == 1 ) then call receive ( nakxl , 0 ) call receive ( nxl , 0 ) call receive ( nakxr , njobs - 1 ) call receive ( nxr , njobs - 1 ) ! the following assumes nx in the center domain is some ! integer multiple of nx in the left or right domain. ! Also assumes dx is the same in every domain, which should ! be the case fac = nx / nxl x_fft_size = nakxl * fac else call send ( nakx , 1 ) call send ( nx , 1 ) x_fft_size = nakx end if call scope ( subprocs ) else x_fft_size = nakx end if if (( runtype_option_switch == runtype_multibox ) . or . use_dirichlet_bc ) then use_multibox = . true . else use_multibox = . false . end if if ( abs ( nu_krook_mb ) > epsilon ( 0.0 ) . and . use_multibox ) then include_multibox_krook = . true . end if copy_size = boundary_size - krook_size end subroutine read_multibox_parameters subroutine init_multibox use constants , only : pi use stella_layouts , only : vmu_lo use stella_geometry , only : geo_surf , q_as_x , get_x_to_rho use stella_geometry , only : drhodpsi , dxdXcoord use zgrid , only : nzgrid , ntubes use kt_grids , only : nakx , naky , akx , aky , nx , x , x_d , x0 use kt_grids , only : centered_in_rho , rho_clamped , rho_d , rho_d_clamped use kt_grids , only : periodic_variation use kt_grids , only : boundary_size , krook_size use file_utils , only : runtype_option_switch , runtype_multibox use job_manage , only : njobs use physics_parameters , only : rhostar use mp , only : scope , crossdomprocs , subprocs , & send , receive , job implicit none integer :: g_buff_size integer :: phi_buff_size integer :: i , pfac real , dimension (:), allocatable :: x_clamped , x_d_clamped , x_mb_clamped real :: db , x_shift , dqdrho if (. not . use_multibox ) return bs_fullgrid = nint (( 3.0 * boundary_size ) / 2.0 ) ikymin = 1 if ( mb_zf_option_switch == mb_zf_option_skip_ky0 ) ikymin = 2 pfac = 1 if ( periodic_variation ) pfac = 2 phi_buff_size = pfac * boundary_size * naky * ntubes * ( 2 * nzgrid + 1 ) g_buff_size = phi_buff_size * ( vmu_lo % ulim_alloc - vmu_lo % llim_proc + 1 ) if (. not . allocated ( g_buffer0 )) allocate ( g_buffer0 ( g_buff_size )) if (. not . allocated ( g_buffer1 )) allocate ( g_buffer1 ( g_buff_size )) if (. not . allocated ( phi_buffer0 )) allocate ( phi_buffer0 ( phi_buff_size )) if (. not . allocated ( phi_buffer1 )) allocate ( phi_buffer1 ( phi_buff_size )) if (. not . allocated ( fsa_x ) . and . ( mb_zf_option_switch == mb_zf_option_zero_fsa )) then allocate ( fsa_x ( nakx )); fsa_x = 0.0 end if if (. not . allocated ( copy_mask_left )) allocate ( copy_mask_left ( pfac * boundary_size )); copy_mask_left = 1.0 if (. not . allocated ( copy_mask_right )) allocate ( copy_mask_right ( pfac * boundary_size )); copy_mask_right = 1.0 if (. not . allocated ( krook_mask_left )) allocate ( krook_mask_left ( pfac * boundary_size )); krook_mask_left = 0.0 if (. not . allocated ( krook_mask_right )) allocate ( krook_mask_right ( pfac * boundary_size )); krook_mask_right = 0.0 g_buffer0 = 0. g_buffer1 = 0. phi_buffer0 = 0. phi_buffer1 = 0. if ( krook_size > 0 ) then select case ( krook_option_switch ) case ( krook_option_flat ) do i = 1 , krook_size krook_mask_right ( i ) = 1.0 copy_mask_right ( i ) = 0.0 end do case ( krook_option_linear ) db = 1.0 / krook_size do i = 1 , krook_size krook_mask_right ( i ) = i * db copy_mask_right ( i ) = 0.0 end do case ( krook_option_exp ) db = krook_efold / krook_size do i = 1 , krook_size krook_mask_right ( i ) = 1.0 - ( 1.0 - exp ( - ( krook_size - i ) * db )) / ( 1.0 - exp ( - krook_efold )) copy_mask_right ( i ) = 0.0 end do case ( krook_option_exp_rev ) db = krook_efold / krook_size do i = 1 , krook_size krook_mask_right ( i ) = ( 1.0 - exp ( - i * db )) / ( 1.0 - exp ( - krook_efold )) copy_mask_right ( i ) = 0.0 end do end select end if if ( periodic_variation ) then do i = 1 , boundary_size copy_mask_right ( i + boundary_size ) = copy_mask_right ( boundary_size - i + 1 ) krook_mask_right ( i + boundary_size ) = krook_mask_right ( boundary_size - i + 1 ) end do copy_mask_left = copy_mask_right krook_mask_left = krook_mask_right else do i = 1 , boundary_size copy_mask_left ( i ) = copy_mask_right ( boundary_size - i + 1 ) krook_mask_left ( i ) = krook_mask_right ( boundary_size - i + 1 ) end do end if if (. not . allocated ( krook_fac )) allocate ( krook_fac ( naky )) krook_fac = 1.0 do i = 2 , naky krook_fac ( i ) = ( aky ( i ) / aky ( 2 )) ** krook_exponent end do call init_mb_transforms if (. not . allocated ( x_mb )) allocate ( x_mb ( x_fft_size )) if (. not . allocated ( rho_mb )) allocate ( rho_mb ( x_fft_size )) if (. not . allocated ( rho_mb_clamped )) allocate ( rho_mb_clamped ( x_fft_size )) if ( runtype_option_switch /= runtype_multibox ) then x_mb = x_d rho_mb = rho_d rho_mb_clamped = rho_d_clamped return end if call scope ( crossdomprocs ) dx_mb = ( 2 * pi * x0 ) / x_fft_size if ( job == 1 ) then x_shift = pi * x0 if ( centered_in_rho ) then if ( q_as_x ) then dqdrho = geo_surf % shat * geo_surf % qinp / geo_surf % rhoc x_shift = pi * x0 * ( 1.0 & - 0.5 * rhostar * pi * x0 * geo_surf % d2qdr2 / ( pfac * dqdrho ** 2 * dxdXcoord )) else x_shift = pi * x0 * ( 1.0 & - 0.5 * rhostar * pi * x0 * geo_surf % d2psidr2 * drhodpsi ** 2 / ( pfac * dxdXcoord )) end if end if do i = 1 , x_fft_size if ( periodic_variation ) then if ( i <= ( x_fft_size / 2 )) then x_mb ( i ) = ( i - 1 ) * dx_mb - 0.5 * x_shift else x_mb ( i ) = x_mb ( x_fft_size - i + 1 ) end if else x_mb ( i ) = ( i - 0.5 ) * dx_mb - x_shift end if end do call get_x_to_rho ( 1 , x_mb , rho_mb ) xL = x_mb ( boundary_size ) xR = x_mb ( x_fft_size / pfac - boundary_size + 1 ) rhoL = rho_mb ( boundary_size ) rhoR = rho_mb ( x_fft_size / pfac - boundary_size + 1 ) allocate ( x_clamped ( nx )) allocate ( x_d_clamped ( nakx )) allocate ( x_mb_clamped ( x_fft_size )) if ( LR_debug_switch == LR_debug_option_L ) then x_clamped = xL x_d_clamped = xL x_mb_clamped = xL else if ( LR_debug_switch == LR_debug_option_R ) then x_clamped = xR x_d_clamped = xR x_mb_clamped = xR else x_clamped = x x_d_clamped = x_d x_mb_clamped = x_mb do i = 1 , nx if ( x_clamped ( i ) < xL ) x_clamped ( i ) = xL if ( x_clamped ( i ) > xR ) x_clamped ( i ) = xR end do do i = 1 , x_fft_size if ( x_mb_clamped ( i ) < xL ) x_mb_clamped ( i ) = xL if ( x_mb_clamped ( i ) > xR ) x_mb_clamped ( i ) = xR end do do i = 1 , nakx if ( x_d_clamped ( i ) < xL ) x_d_clamped ( i ) = xL if ( x_d_clamped ( i ) > xR ) x_d_clamped ( i ) = xR end do end if call get_x_to_rho ( 1 , x_clamped , rho_clamped ) call get_x_to_rho ( 1 , x_d_clamped , rho_d_clamped ) call get_x_to_rho ( 1 , x_mb_clamped , rho_mb_clamped ) deallocate ( x_clamped , x_d_clamped ) elseif ( job == 0 ) then do i = 1 , x_fft_size x_mb ( i ) = ( i - 1 ) * dx_mb end do call receive ( xL , 1 ) call send ( akx ( 2 ), 1 ) elseif ( job == njobs - 1 ) then do i = 1 , x_fft_size x_mb ( i ) = ( i - 1 ) * dx_mb end do call receive ( xR , 1 ) call send ( akx ( 2 ), 1 ) end if call scope ( subprocs ) end subroutine init_multibox subroutine communicate_multibox_parameters use job_manage , only : njobs use mp , only : scope , crossdomprocs , subprocs , & send , receive , job implicit none if ( job == 1 ) then call scope ( crossdomprocs ) call send ( xL , 0 ) call send ( xR , njobs - 1 ) call receive ( kx0_L , 0 ) call receive ( kx0_R , njobs - 1 ) call scope ( subprocs ) end if end subroutine communicate_multibox_parameters subroutine finish_multibox implicit none if ( allocated ( g_buffer0 )) deallocate ( g_buffer0 ) if ( allocated ( g_buffer1 )) deallocate ( g_buffer1 ) if ( allocated ( phi_buffer0 )) deallocate ( phi_buffer0 ) if ( allocated ( phi_buffer1 )) deallocate ( phi_buffer1 ) if ( allocated ( fsa_x )) deallocate ( fsa_x ) if ( allocated ( copy_mask_left )) deallocate ( copy_mask_left ) if ( allocated ( copy_mask_right )) deallocate ( copy_mask_right ) if ( allocated ( krook_mask_left )) deallocate ( krook_mask_left ) if ( allocated ( krook_mask_right )) deallocate ( krook_mask_right ) if ( allocated ( krook_fac )) deallocate ( krook_fac ) if ( allocated ( fft_kxky )) deallocate ( fft_kxky ) if ( allocated ( fft_xky )) deallocate ( fft_xky ) if ( allocated ( fft_xy )) deallocate ( fft_xy ) if ( allocated ( x_mb )) deallocate ( x_mb ) if ( allocated ( rho_mb )) deallocate ( rho_mb ) if ( allocated ( rho_mb_clamped )) deallocate ( rho_mb_clamped ) call finish_mb_transforms end subroutine finish_multibox subroutine multibox_communicate ( gin ) use constants , only : zi use kt_grids , only : nakx , naky , naky_all , akx , aky , nx , ny , dx , dy , zonal_mode use kt_grids , only : periodic_variation , boundary_size use file_utils , only : runtype_option_switch , runtype_multibox use file_utils , only : get_unused_unit use fields_arrays , only : phi , phi_corr_QN , shift_state use job_manage , only : njobs , time_message use physics_flags , only : radial_variation , prp_shear_enabled , hammett_flow_shear use physics_parameters , only : g_exb , g_exbfac use stella_layouts , only : vmu_lo use stella_geometry , only : dl_over_b use zgrid , only : nzgrid use mp , only : job , scope , mp_abort , & crossdomprocs , subprocs , allprocs , & ssend , receive , proc0 implicit none integer :: num , ia , ix , iix , iky , iz , it , iv integer :: offset integer :: ii , jj , temp_unit , pfac real :: afacx , afacy character ( len = 512 ) :: filename complex , dimension (:, :), allocatable :: prefac complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( inout ) :: gin if ( runtype_option_switch /= runtype_multibox ) return if ( LR_debug_switch /= LR_debug_option_default ) return if ( njobs /= 3 ) call mp_abort ( \"Multibox only supports 3 domains at the moment.\" ) if ( proc0 ) call time_message (. false ., time_multibox (:, 1 ), ' mb_comm' ) allocate ( prefac ( naky , x_fft_size )); prefac = 1.0 pfac = 1 if ( periodic_variation ) pfac = 2 if ( prp_shear_enabled . and . hammett_flow_shear ) then prefac = exp ( - zi * g_exb * g_exbfac * spread ( x_mb , 1 , naky ) * spread ( aky * shift_state , 2 , x_fft_size )) end if if ( mb_debug_step > 0 . and . mod ( temp_ind , mb_debug_step ) == 0 . and . proc0 ) then ! call get_unused_unit(temp_unit) temp_unit = 3023 + job afacx = real ( nx ) / real ( x_fft_size ) afacy = real ( ny ) / real ( 2 * naky - 1 ) fft_kxky = phi (:, :, 0 , 1 ) if ( radial_variation ) then fft_kxky = fft_kxky + phi_corr_QN (:, :, 0 , 1 ) end if call transform_kx2x ( fft_kxky , fft_xky ) fft_xky = fft_xky * prefac call transform_ky2y ( fft_xky , fft_xy ) write ( filename , \"(A,I1,A,I0.6)\" ) \"phiout\" , job , \"_\" , temp_ind open ( unit = temp_unit , file = filename , status = \"replace\" , & action = \"write\" , form = \"unformatted\" , access = \"stream\" ) write ( temp_unit ) real ( x_fft_size , 4 ) do ii = 1 , x_fft_size write ( temp_unit ) real ( afacx * dx * ( ii - 1 ), 4 ) end do do ii = 1 , naky_all write ( temp_unit ) real ( afacy * dy * ( ii - 1 ), 4 ) do jj = 1 , x_fft_size write ( temp_unit ) real ( fft_xy ( ii , jj ), 4 ) end do end do close ( unit = temp_unit ) end if ! DSO - change communicator call scope ( crossdomprocs ) ia = 1 if ( job == 0 . or . job == ( njobs - 1 )) then if ( periodic_variation ) then offset = - boundary_size else offset = 0 ; ! DSO the next line might seem backwards, but this makes it easier to stitch together imaages ! FLAG DSO - might do something weird with magnetic shear if ( job == njobs - 1 ) offset = nakx - boundary_size end if !first g num = 1 do iv = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , vmu_lo % ntubes !this is where the FSA goes if ( zonal_mode ( 1 ) . and . mb_zf_option_switch == mb_zf_option_zero_fsa ) then do ix = 1 , nakx fsa_x ( ix ) = sum ( dl_over_b ( ia , :) * gin ( 1 , ix , :, it , iv )) end do end if do iz = - vmu_lo % nzgrid , vmu_lo % nzgrid fft_kxky = gin (:, :, iz , it , iv ) if ( zonal_mode ( 1 )) then if ( mb_zf_option_switch == mb_zf_option_zero_ky0 ) then fft_kxky ( 1 , :) = 0.0 elseif ( mb_zf_option_switch == mb_zf_option_zero_fsa ) then fft_kxky ( 1 , :) = fft_kxky ( 1 , :) - fsa_x end if end if call transform_kx2x ( fft_kxky , fft_xky ) fft_xky = fft_xky * prefac do ix = 1 , pfac * boundary_size iix = ix + offset if ( iix <= 0 ) iix = iix + nakx do iky = ikymin , naky !DSO if in the future the grids can have different naky, one will !have to divide by naky here, and multiply on the receiving end g_buffer0 ( num ) = fft_xky ( iky , iix ) num = num + 1 end do end do end do end do end do call ssend ( g_buffer0 , 1 , 43 + job ) !now phi num = 1 do it = 1 , vmu_lo % ntubes !this is where the FSA goes if ( zonal_mode ( 1 ) . and . mb_zf_option_switch == mb_zf_option_zero_fsa ) then do ix = 1 , nakx fsa_x ( ix ) = sum ( dl_over_b ( ia , :) * phi ( 1 , ix , :, it )) end do end if do iz = - vmu_lo % nzgrid , vmu_lo % nzgrid fft_kxky = spread (( zi * akx ) ** phi_pow , 1 , naky ) * phi (:, :, iz , it ) if ( zonal_mode ( 1 )) then if ( mb_zf_option_switch == mb_zf_option_zero_ky0 ) then fft_kxky ( 1 , :) = 0.0 elseif ( mb_zf_option_switch == mb_zf_option_zero_fsa ) then fft_kxky ( 1 , :) = fft_kxky ( 1 , :) - fsa_x end if end if call transform_kx2x ( fft_kxky , fft_xky ) fft_xky = fft_xky * prefac do iky = ikymin , naky do ix = 1 , pfac * boundary_size iix = ix + offset if ( iix <= 0 ) iix = iix + nakx !DSO if in the future the grids can have different naky, one will !have to divide by naky here, and multiply on the receiving end phi_buffer0 ( num ) = fft_xky ( iky , iix ) num = num + 1 end do end do end do end do ! DSO - send data call ssend ( phi_buffer0 , 1 , 143 + job ) else ! DSO - receive the data ! left call receive ( g_buffer0 , 0 , 43 ) call receive ( phi_buffer0 , 0 , 143 ) ! right call receive ( g_buffer1 , njobs - 1 , 43 + njobs - 1 ) call receive ( phi_buffer1 , njobs - 1 , 143 + njobs - 1 ) !apply the BCs call apply_radial_boundary_conditions ( gin ) end if ! DSO - change communicator call scope ( subprocs ) temp_ind = temp_ind + 1 deallocate ( prefac ) if ( proc0 ) call time_message (. false ., time_multibox (:, 1 ), ' mb_comm' ) end subroutine multibox_communicate subroutine apply_radial_boundary_conditions ( gin ) use kt_grids , only : naky , zonal_mode use kt_grids , only : periodic_variation , boundary_size use stella_layouts , only : vmu_lo use zgrid , only : nzgrid implicit none integer :: num , ix , iky , iz , it , iv , iL , iR integer :: offsetL , offsetR , pfac complex :: dzm , dzp complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( inout ) :: gin pfac = 1 if ( periodic_variation ) pfac = 2 offsetL = 0 offsetR = x_fft_size - boundary_size if ( periodic_variation ) then offsetL = - boundary_size offsetR = x_fft_size / 2 - boundary_size + 1 end if num = 1 do iv = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , vmu_lo % ntubes do iz = - vmu_lo % nzgrid , vmu_lo % nzgrid call transform_kx2x ( gin (:, :, iz , it , iv ), fft_xky ) do ix = 1 , pfac * boundary_size iL = ix + offsetL iR = ix + offsetR if ( iL <= 0 ) iL = iL + x_fft_size if ( iR <= 0 ) iR = iR + x_fft_size do iky = ikymin , naky fft_xky ( iky , iL ) = fft_xky ( iky , iL ) * ( 1 - copy_mask_left ( ix )) & + g_buffer0 ( num ) * copy_mask_left ( ix ) fft_xky ( iky , iR ) = fft_xky ( iky , iR ) * ( 1 - copy_mask_right ( ix )) & + g_buffer1 ( num ) * copy_mask_right ( ix ) num = num + 1 end do end do if ( smooth_ZFs ) then dzm = fft_xky ( 1 , boundary_size + 1 ) - fft_xky ( 1 , boundary_size ) dzp = fft_xky ( 1 , x_fft_size - boundary_size + 1 ) - fft_xky ( 1 , x_fft_size - boundary_size ) do ix = 1 , pfac * boundary_size iL = ix + offsetL iR = ix + offsetR if ( iL <= 0 ) iL = iL + x_fft_size if ( iR <= 0 ) iR = iR + x_fft_size fft_xky ( 1 , iL ) = fft_xky ( 1 , iL ) + dzm fft_xky ( 1 , iR ) = fft_xky ( 1 , iR ) - dzp end do end if if ( zonal_mode ( 1 )) fft_xky ( 1 , :) = real ( fft_xky ( 1 , :)) call transform_x2kx ( fft_xky , gin (:, :, iz , it , iv )) end do end do end do end subroutine apply_radial_boundary_conditions subroutine add_multibox_krook ( g , rhs ) use stella_time , only : code_dt use stella_layouts , only : vmu_lo use kt_grids , only : nakx , naky , periodic_variation , boundary_size use zgrid , only : nzgrid , ntubes use mp , only : job , proc0 use job_manage , only : time_message implicit none integer :: iky , ix , iL , iR , iz , it , ivmu , num , offsetL , offsetR integer :: pfac complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: rhs complex , allocatable , dimension (:, :) :: g0x , g0k if ( job /= 1 . and . . not . use_dirichlet_BC ) return if ( proc0 ) call time_message (. false ., time_multibox (:, 2 ), ' mb_krook' ) allocate ( g0k ( naky , nakx )) allocate ( g0x ( naky , x_fft_size )) if ( periodic_variation ) then offsetL = - boundary_size offsetR = x_fft_size / 2 - boundary_size + 1 else offsetL = 0 offsetR = x_fft_size - boundary_size end if pfac = 1 if ( periodic_variation ) pfac = 2 num = 1 do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid g0x = 0.0 call transform_kx2x ( g (:, :, iz , it , ivmu ), fft_xky ) do ix = 1 , pfac * boundary_size iL = ix + offsetL iR = ix + offsetR if ( iL <= 0 ) iL = iL + x_fft_size if ( iR <= 0 ) iR = iR + x_fft_size do iky = ikymin , naky g0x ( iky , iL ) = ( fft_xky ( iky , iL ) - g_buffer0 ( num )) * krook_mask_left ( ix ) g0x ( iky , iR ) = ( fft_xky ( iky , iR ) - g_buffer1 ( num )) * krook_mask_right ( ix ) num = num + 1 end do end do call transform_x2kx ( g0x , g0k ) rhs (:, :, iz , it , ivmu ) = rhs (:, :, iz , it , ivmu ) & - code_dt * nu_krook_mb * spread ( krook_fac , 2 , nakx ) * g0k end do end do end do deallocate ( g0k , g0x ) if ( proc0 ) call time_message (. false ., time_multibox (:, 2 ), ' mb_krook' ) end subroutine add_multibox_krook !! !!>DSO - The following subroutines solve for phi in the _physical_ region of space !!       It is done here because the radial grid may include an extra point subroutine init_mb_get_phi ( has_elec , adiabatic_elec , efac , efacp ) use kt_grids , only : nakx , naky , boundary_size use zgrid , only : nzgrid use physics_flags , only : radial_variation use stella_geometry , only : dl_over_b , d_dl_over_b_drho use run_parameters , only : ky_solve_radial use fields_arrays , only : phi_solve , phizf_solve , gamtot , dgamtotdr use linear_solve , only : lu_decomposition , lu_inverse implicit none logical , intent ( in ) :: has_elec , adiabatic_elec real , intent ( in ) :: efac , efacp integer :: ia , iz , iky , ikx , b_solve real :: dum complex , dimension (:, :), allocatable :: g0k , g1k , g0x , a_inv , a_fsa if (. not . radial_variation ) return !this does not depend on the timestep, so only do once if ( get_phi_initialized ) return get_phi_initialized = . true . !efac_l  = efac !efacp_l = efacp_l ia = 1 b_solve = boundary_size - phi_bound allocate ( g0k ( 1 , nakx )) allocate ( g1k ( 1 , nakx )) allocate ( g0x ( 1 , x_fft_size )) if (. not . allocated ( phi_solve )) allocate ( phi_solve ( min ( ky_solve_radial , naky ), - nzgrid : nzgrid )) do iky = 1 , min ( ky_solve_radial , naky ) do iz = - nzgrid , nzgrid if (. not . associated ( phi_solve ( iky , iz )% zloc )) & allocate ( phi_solve ( iky , iz )% zloc ( x_fft_size - 2 * b_solve , x_fft_size - 2 * b_solve )) if (. not . associated ( phi_solve ( iky , iz )% idx )) & allocate ( phi_solve ( iky , iz )% idx ( x_fft_size - 2 * b_solve )) phi_solve ( iky , iz )% zloc = 0.0 phi_solve ( iky , iz )% idx = 0 do ikx = 1 + b_solve , x_fft_size - b_solve g0x ( 1 , :) = 0.0 g0x ( 1 , ikx ) = 1.0 call transform_x2kx ( g0x , g0k ) g1k ( 1 , :) = g0k ( 1 , :) * gamtot ( iky , :, iz ) call transform_kx2x ( g1k , g0x ) !row column phi_solve ( iky , iz )% zloc (:, ikx - b_solve ) = g0x ( 1 , ( 1 + b_solve ):( x_fft_size - b_solve )) g1k ( 1 , :) = g0k ( 1 , :) * dgamtotdr ( iky , :, iz ) call transform_kx2x ( g1k , g0x ) g0x ( 1 , :) = rho_mb_clamped * g0x ( 1 , :) phi_solve ( iky , iz )% zloc (:, ikx - b_solve ) = phi_solve ( iky , iz )% zloc (:, ikx - b_solve ) & + g0x ( 1 , ( 1 + b_solve ):( x_fft_size - b_solve )) end do call lu_decomposition ( phi_solve ( iky , iz )% zloc , phi_solve ( iky , iz )% idx , dum ) !       call zgetrf(nakx,nakx,phi_solve(iky,iz)%zloc,nakx,phi_solve(iky,iz)%idx,info) end do end do if (. not . has_elec ) then if (. not . allocated ( b_mat )) allocate ( b_mat ( x_fft_size - 2 * b_solve )); b_mat = 0.0 do ikx = 1 + b_solve , x_fft_size - b_solve !row column b_mat ( ikx - b_solve ) = efac + efacp * rho_mb_clamped ( ikx ) end do end if if ( adiabatic_elec ) then allocate ( a_inv ( x_fft_size - 2 * b_solve , x_fft_size - 2 * b_solve )) allocate ( a_fsa ( x_fft_size - 2 * b_solve , x_fft_size - 2 * b_solve )); a_fsa = 0.0 if (. not . associated ( phizf_solve % zloc )) & allocate ( phizf_solve % zloc ( x_fft_size - 2 * b_solve , x_fft_size - 2 * b_solve )); phizf_solve % zloc = 0.0 if (. not . associated ( phizf_solve % idx )) allocate ( phizf_solve % idx ( x_fft_size - 2 * b_solve )); !get inverse of A do iz = - nzgrid , nzgrid call lu_inverse ( phi_solve ( 1 , iz )% zloc , phi_solve ( 1 , iz )% idx , a_inv ) !flux surface average it do ikx = 1 , x_fft_size - 2 * b_solve a_fsa (:, ikx ) = a_fsa (:, ikx ) + ( dl_over_b ( ia , iz ) + d_dl_over_b_drho ( ia , iz ) & * rho_mb_clamped (( 1 + b_solve ):( x_fft_size - b_solve ))) * a_inv (:, ikx ) end do end do ! calculate I - <A&#94;-1>B do ikx = 1 , x_fft_size - 2 * b_solve phizf_solve % zloc ( ikx , :) = - a_fsa ( ikx , :) * b_mat phizf_solve % zloc ( ikx , ikx ) = 1.0 + phizf_solve % zloc ( ikx , ikx ) end do call lu_decomposition ( phizf_solve % zloc , phizf_solve % idx , dum ) deallocate ( a_inv , a_fsa ) end if deallocate ( g0k , g1k , g0x ) end subroutine init_mb_get_phi subroutine mb_get_phi ( phi , has_elec , adiabatic_elec ) use constants , only : zi use kt_grids , only : akx , nakx , naky , zonal_mode , boundary_size use zgrid , only : nzgrid , ntubes use stella_geometry , only : dl_over_b , d_dl_over_b_drho use run_parameters , only : ky_solve_radial use fields_arrays , only : gamtot , dgamtotdr , phi_solve , phizf_solve use linear_solve , only : lu_back_substitution implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in out ) :: phi logical , intent ( in ) :: has_elec , adiabatic_elec integer :: ia , it , iz , ix , iky , ind , b_solve complex , dimension (:, :), allocatable :: g0k , g1k , g0x , g1x , g0z complex , dimension (:), allocatable :: g_fsa , pb_fsa real :: tmp ia = 1 b_solve = boundary_size - phi_bound allocate ( g0k ( 1 , nakx )) allocate ( g1k ( 1 , nakx )) allocate ( g0x ( 1 , x_fft_size )) allocate ( g1x ( 1 , x_fft_size )) if ( adiabatic_elec . and . zonal_mode ( 1 )) then allocate ( g0z ( x_fft_size , - nzgrid : nzgrid )) allocate ( g_fsa ( x_fft_size - 2 * b_solve )) allocate ( pb_fsa ( x_fft_size - 2 * b_solve )) end if do it = 1 , ntubes if ( adiabatic_elec . and . zonal_mode ( 1 )) pb_fsa = 0.0 do iz = - nzgrid , nzgrid do iky = 1 , naky if ( iky > ky_solve_radial ) then phi ( iky , :, iz , it ) = phi ( iky , :, iz , it ) / gamtot ( iky , :, iz ) else g0x = 0.0 tmp = 0 ind = boundary_size * ( iky - 1 + naky * ( iz + nzgrid + ( 2 * nzgrid + 1 ) * ( it - 1 ))) do ix = 1 , b_solve g0x ( 1 , ix ) = phi_buffer0 ( ind + ix ) g0x ( 1 , x_fft_size + 1 - ix ) = phi_buffer1 ( ind + boundary_size + 1 - ix ) end do if ( iky == 1 ) tmp = sum ( real ( g0x ( 1 , :))) call transform_x2kx ( g0x , g0k ) if ( phi_pow /= 0 ) then g0k ( 1 , :) = g0k ( 1 , :) / (( zi * akx ) ** phi_pow ) if ( iky == 1 ) g0k ( 1 , 1 ) = 0.0 end if g0x = 0.0 if (. not . has_elec . and . phi_pow /= 0 ) then g1k ( 1 , :) = g0k ( 1 , :) call transform_kx2x ( g1k , g0x ) g0x ( 1 , ( b_solve + 1 ):( x_fft_size - b_solve )) = & - g0x ( 1 , ( b_solve + 1 ):( x_fft_size - b_solve )) * b_mat if ( adiabatic_elec . and . iky == 1 ) then pb_fsa = pb_fsa + ( dl_over_b ( ia , iz ) + d_dl_over_b_drho ( ia , iz ) & * rho_mb_clamped (( 1 + b_solve ):( x_fft_size - b_solve ))) & * g0x ( 1 , ( 1 + b_solve ):( x_fft_size - b_solve )) end if end if g1k ( 1 , :) = g0k ( 1 , :) * gamtot ( iky , :, iz ) call transform_kx2x ( g1k , g1x ) g0x = g0x + g1x g1k ( 1 , :) = g0k ( 1 , :) * dgamtotdr ( iky , :, iz ) call transform_kx2x ( g1k , g1x ) g1x ( 1 , :) = rho_mb_clamped * g1x ( 1 , :) + g0x ( 1 , :) g0k ( 1 , :) = phi ( iky , :, iz , it ) call transform_kx2x ( g0k , g0x ) g0x = g0x - g1x call lu_back_substitution ( phi_solve ( iky , iz )% zloc , phi_solve ( iky , iz )% idx , & g0x ( 1 , ( b_solve + 1 ):( x_fft_size - b_solve ))) if ( iky == 1 ) then tmp = ( tmp + & sum ( real ( g0x ( 1 , ( b_solve + 1 ):( x_fft_size - b_solve ))))) & / ( 2 * b_solve ) end if if ( phi_pow /= 0 ) then do ix = 1 , b_solve g0x ( 1 , ix ) = 0.0 g0x ( 1 , x_fft_size + 1 - ix ) = 0.0 end do call transform_x2kx ( g0x , g0k ) g0k ( 1 , :) = g0k ( 1 , :) * ( zi * akx ) ** phi_pow call transform_kx2x ( g0k , g0x ) end if do ix = 1 , b_solve g0x ( 1 , ix ) = phi_buffer0 ( ind + ix ) !- tmp g0x ( 1 , x_fft_size + 1 - ix ) = phi_buffer1 ( ind + boundary_size + 1 - ix ) !- tmp end do call transform_x2kx ( g0x , g0k ) if ( phi_pow /= 0 ) then g0k ( 1 , :) = g0k ( 1 , :) / ( zi * akx ) ** phi_pow if ( iky == 1 ) g0k ( 1 , 1 ) = 0. end if phi ( iky , :, iz , it ) = g0k ( 1 , :) end if end do end do if ( ky_solve_radial == 0 . and . any ( gamtot ( 1 , 1 , :) < epsilon ( 0. ))) phi ( 1 , 1 , :, it ) = 0.0 if ( adiabatic_elec . and . zonal_mode ( 1 )) then !get A_p&#94;-1.(g - A_b.phi_b) in real space do iz = - nzgrid , nzgrid g0k ( 1 , :) = phi ( 1 , :, iz , it ) call transform_kx2x ( g0k , g0x ) g0z (:, iz ) = g0x ( 1 , :) if ( phi_pow /= 0 ) then call lu_back_substitution ( phi_solve ( 1 , iz )% zloc , phi_solve ( 1 , iz )% idx , pb_fsa ) g0z (( 1 + b_solve ):( x_fft_size - b_solve ), iz ) = & g0z (( 1 + b_solve ):( x_fft_size - b_solve ), iz ) + pb_fsa end if end do ! get <A_p&#94;-1.(g- - A_b.phi_b)>_psi g_fsa = 0.0 do iz = - nzgrid , nzgrid g_fsa = g_fsa + ( dl_over_b ( ia , iz ) + d_dl_over_b_drho ( ia , iz ) & * rho_mb_clamped (( 1 + b_solve ):( x_fft_size - b_solve ))) & * g0z (( 1 + b_solve ):( x_fft_size - b_solve ), iz ) end do call lu_back_substitution ( phizf_solve % zloc , phizf_solve % idx , g_fsa ) g1x ( 1 , ( 1 + b_solve ):( x_fft_size - b_solve )) = b_mat * g_fsa do iz = - nzgrid , nzgrid g_fsa = g1x ( 1 , ( 1 + b_solve ):( x_fft_size - b_solve )) call lu_back_substitution ( phi_solve ( 1 , iz )% zloc , phi_solve ( 1 , iz )% idx , g_fsa ) g0z (( 1 + b_solve ):( x_fft_size - b_solve ), iz ) = & g0z (( 1 + b_solve ):( x_fft_size - b_solve ), iz ) + g_fsa g0x ( 1 , :) = g0z (:, iz ) call transform_x2kx ( g0x , g0k ) phi ( 1 , :, iz , it ) = g0k ( 1 , :) end do end if end do deallocate ( g0k , g1k , g0x , g1x ) if ( allocated ( g0z )) deallocate ( g0z ) if ( allocated ( g_fsa )) deallocate ( g_fsa ) if ( allocated ( pb_fsa )) deallocate ( pb_fsa ) end subroutine mb_get_phi !!>DSO - The following subroutines are the _ analogues of the ones found in ! stella_transforms.f90. ! The ones uses here ensure that the grid spacing in real space is consistent between ! domains (since we do not keep the checkboard mode) subroutine init_mb_transforms use stella_layouts , only : init_stella_layouts use kt_grids , only : nakx , naky , naky_all implicit none if ( mb_transforms_initialized ) return mb_transforms_initialized = . true . if (. not . allocated ( fft_kxky )) allocate ( fft_kxky ( naky , nakx )) if (. not . allocated ( fft_xky )) allocate ( fft_xky ( naky , x_fft_size )) if (. not . allocated ( fft_xy )) allocate ( fft_xy ( naky_all , x_fft_size )) call init_x_fft call init_y_fft end subroutine init_mb_transforms subroutine init_x_fft use fft_work , only : init_ccfftw , FFT_BACKWARD , FFT_FORWARD implicit none if (. not . allocated ( fft_x_k )) allocate ( fft_x_k ( x_fft_size )) if (. not . allocated ( fft_x_x )) allocate ( fft_x_x ( x_fft_size )) call init_ccfftw ( xf_fft , FFT_BACKWARD , x_fft_size , fft_x_k , fft_x_x ) call init_ccfftw ( xb_fft , FFT_FORWARD , x_fft_size , fft_x_x , fft_x_k ) end subroutine init_x_fft subroutine init_y_fft use kt_grids , only : naky , naky_all use fft_work , only : init_crfftw , init_rcfftw , FFT_BACKWARD , FFT_FORWARD implicit none if (. not . allocated ( fft_y_k )) allocate ( fft_y_k ( naky )) if (. not . allocated ( fft_y_y )) allocate ( fft_y_y ( naky_all )) call init_crfftw ( yf_fft , FFT_BACKWARD , naky_all , fft_y_k , fft_y_y ) call init_rcfftw ( yb_fft , FFT_FORWARD , naky_all , fft_y_y , fft_y_k ) end subroutine init_y_fft ! !> transform routines start here ! subroutine transform_kx2x ( gkx , gx ) use kt_grids , only : ikx_max implicit none complex , dimension (:, :), intent ( in ) :: gkx complex , dimension (:, :), intent ( out ) :: gx integer :: iy do iy = 1 , size ( gkx , 1 ) fft_x_k = 0. fft_x_k (: ikx_max ) = gkx ( iy , : ikx_max ) fft_x_k (( x_fft_size - ikx_max + 2 ):) = gkx ( iy , ikx_max + 1 :) call dfftw_execute_dft ( xf_fft % plan , fft_x_k , fft_x_x ) gx ( iy , :) = fft_x_x * xf_fft % scale end do end subroutine transform_kx2x subroutine transform_x2kx ( gx , gkx ) use kt_grids , only : ikx_max implicit none complex , dimension (:, :), intent ( in ) :: gx complex , dimension (:, :), intent ( out ) :: gkx integer :: iy do iy = 1 , size ( gx , 1 ) fft_x_x = gx ( iy , :) call dfftw_execute_dft ( xb_fft % plan , fft_x_x , fft_x_k ) gkx ( iy , : ikx_max ) = fft_x_k (: ikx_max ) * xb_fft % scale gkx ( iy , ikx_max + 1 :) = fft_x_k (( x_fft_size - ikx_max + 2 ):) * xb_fft % scale end do end subroutine transform_x2kx subroutine transform_ky2y ( gky , gy ) implicit none complex , dimension (:, :), intent ( in ) :: gky real , dimension (:, :), intent ( out ) :: gy integer :: ikx do ikx = 1 , size ( gky , 2 ) fft_y_k = gky (:, ikx ) call dfftw_execute_dft_c2r ( yf_fft % plan , fft_y_k , fft_y_y ) gy (:, ikx ) = fft_y_y * yf_fft % scale end do end subroutine transform_ky2y !   subroutine transform_y2ky (gy, gky) ! !    implicit none ! !    real, dimension (:,:), intent (in out) :: gy !    complex, dimension (:,:), intent (out) :: gky ! !    integer :: ikx ! !    do ikx = 1, size(gy,2) !       fft_y_k = gy(:,ikx) !       call dfftw_execute_dft_r2c(yb_fft%plan, fft_y_y, fft_y_k) !       gky(:,ikx) = fft_y_y*yb_fft%scale !    end do ! !  end subroutine transform_y2ky subroutine finish_mb_transforms implicit none if (. not . use_multibox ) return call dfftw_destroy_plan ( yf_fft % plan ) call dfftw_destroy_plan ( yb_fft % plan ) call dfftw_destroy_plan ( xf_fft % plan ) call dfftw_destroy_plan ( xb_fft % plan ) if ( allocated ( fft_y_k )) deallocate ( fft_y_k ) if ( allocated ( fft_y_y )) deallocate ( fft_y_y ) if ( allocated ( fft_x_k )) deallocate ( fft_x_k ) if ( allocated ( fft_x_x )) deallocate ( fft_x_x ) if ( allocated ( fft_xky )) deallocate ( fft_xky ) if ( allocated ( fft_xy )) deallocate ( fft_xy ) mb_transforms_initialized = . false . end subroutine finish_mb_transforms end module multibox","tags":"","loc":"sourcefile/multibox.f90.html"},{"title":"mp.fpp – stella","text":"Source Code # include \"define.inc\" module mp ! ! <doc> Easier Fortran90 interface to the MPI Message Passing Library. </doc> ! !     (c) Copyright 1991 to 1998 by Michael A. Beer, William D. Dorland, !     P. B. Snyder, Q. P. Liu, and Gregory W. Hammett. ALL RIGHTS RESERVED. ! ! Note: mp_mpi_r8.f90 is a version of mp_mpi.f90 to use when compiling ! with -r8 (where the default real type is taken to be 8 bytes).  Just ! replaced all occurances of MPI_REAL with MPI_DOUBLE_PRECISION and ! MPI_COMPLEX with MPI_DOUBLE_COMPLEX. ! # ifndef MPIINC use mpi #endif ! TT: I experienced a problem on Ranger with mvapich-devel. ! TT: Compiler complained an inconsistent variable type for reorder below. ! TT: In this case, the problem was solved by commenting out the above line ! TT: and use mpif.h below.  (4/16/08) implicit none private public :: init_mp , finish_mp public :: broadcast , sum_reduce , sum_allreduce public :: broadcast_with_comm public :: max_reduce , max_allreduce public :: min_reduce , min_allreduce public :: comm_split , comm_free public :: nproc , iproc , proc0 , job , min_proc public :: send , ssend , receive public :: numnodes , inode public :: barrier public :: waitany public :: split_n_tasks public :: mp_abort public :: mpireal , mpicmplx , real_size , nbytes_real public :: sgproc0 ! MAB> needed by Trinity public :: scope , allprocs , sharedprocs , subprocs , crossdomprocs , sharedsubprocs , scrossdomprocs public :: comm_group , comm_sgroup public :: all_to_group , group_to_all public :: trin_flag ! <MAB public :: init_job_topology public :: mp_comm , curr_focus public :: mp_info public :: mp_gather #ifdef ISO_C_BINDING public :: create_shared_memory_window #endif # ifdef MPIINC ! CMR: defined MPIINC for machines where need to include mpif.h include 'mpif.h' #endif !comm_all      - every processor !comm_shared   - every processor on a node (shared memory) !comm_group    - every processor on a given job !comm_sgroup   - every processor on a node on a given job (shared memory) !comm_node     - communicator that links procs of same rank across comm_shared !comm_cross    - communicator that links procs of same rank across comm_group !comm_scross   - communicator that links procs of same rank across comm_sgroup integer , pointer :: nproc integer , target :: ntot_proc , nshared_proc , ngroup_proc , ndomain_proc integer , target :: nsgroup_proc , nscross_proc integer :: numnodes , inode integer , pointer :: iproc integer , target :: aproc , sproc , gproc , cproc , sgproc , scproc logical , pointer :: proc0 logical , target :: aproc0 , sproc0 , gproc0 , sgproc0 integer :: mpi_comm_world_private integer , pointer :: mp_comm integer , target :: comm_all , comm_shared , comm_node , comm_group , comm_cross integer , target :: comm_sgroup , comm_scross integer :: curr_focus integer , parameter :: mp_info = MPI_INFO_NULL integer :: job = 0 , min_proc integer ( kind ( MPI_REAL )) :: mpireal , mpicmplx integer ( kind = MPI_ADDRESS_KIND ) :: real_size integer , parameter :: allprocs = 0 , & sharedprocs = 1 , & subprocs = 2 , & crossdomprocs = 3 , & sharedsubprocs = 4 , & scrossdomprocs = 5 integer :: nbytes_real ! needed for Trinity -- MAB integer , dimension (:), allocatable :: grp0 logical :: trin_flag = . false . interface broadcast module procedure broadcast_integer module procedure broadcast_integer_array module procedure broadcast_real module procedure broadcast_real_array module procedure broadcast_real_2array module procedure broadcast_real_3array module procedure broadcast_real_4array module procedure broadcast_real_5array module procedure broadcast_complex module procedure broadcast_complex_array module procedure broadcast_complex_2array module procedure broadcast_complex_3array module procedure broadcast_complex_4array module procedure broadcast_logical module procedure broadcast_logical_array module procedure bcastfrom_integer module procedure bcastfrom_integer_array module procedure bcastfrom_real module procedure bcastfrom_real_array module procedure bcastfrom_complex module procedure bcastfrom_complex_array module procedure bcastfrom_complex_2array module procedure bcastfrom_logical module procedure bcastfrom_logical_array module procedure broadcast_character module procedure bcastfrom_character end interface interface sum_reduce module procedure sum_reduce_integer module procedure sum_reduce_integer_array module procedure sum_reduce_real module procedure sum_reduce_real_array module procedure sum_reduce_real_2array module procedure sum_reduce_real_3array module procedure sum_reduce_real_4array module procedure sum_reduce_real_5array module procedure sum_reduce_complex module procedure sum_reduce_complex_array module procedure sum_reduce_complex_2array module procedure sum_reduce_complex_3array module procedure sum_reduce_complex_4array module procedure sum_reduce_complex_5array end interface !KDN 100526: Allows summing into alternate variable !rather than overwriting local data !  interface sum_reduce_alt !     module procedure sum_reduce_alt_complex_3array !  end interface interface sum_allreduce module procedure sum_allreduce_integer module procedure sum_allreduce_integer_array module procedure sum_allreduce_integer_2array module procedure sum_allreduce_real module procedure sum_allreduce_real_array module procedure sum_allreduce_real_2array module procedure sum_allreduce_real_3array module procedure sum_allreduce_real_4array module procedure sum_allreduce_real_5array module procedure sum_allreduce_complex module procedure sum_allreduce_complex_array module procedure sum_allreduce_complex_2array module procedure sum_allreduce_complex_3array module procedure sum_allreduce_complex_4array module procedure sum_allreduce_complex_5array end interface interface max_reduce module procedure max_reduce_integer module procedure max_reduce_integer_array module procedure max_reduce_real module procedure max_reduce_real_array end interface interface max_allreduce module procedure max_allreduce_integer module procedure max_allreduce_integer_array module procedure max_allreduce_real module procedure max_allreduce_real_array end interface interface min_reduce module procedure min_reduce_integer module procedure min_reduce_integer_array module procedure min_reduce_real module procedure min_reduce_real_array end interface interface min_allreduce module procedure min_allreduce_integer module procedure min_allreduce_integer_array module procedure min_allreduce_real module procedure min_allreduce_real_array end interface interface send module procedure send_integer module procedure send_integer_array module procedure send_real module procedure send_real_array module procedure send_real_array_2d module procedure send_complex module procedure send_complex_array module procedure nonblocking_send_complex_array module procedure send_logical module procedure send_logical_array module procedure send_character end interface interface receive module procedure receive_integer module procedure receive_integer_array module procedure receive_real module procedure receive_real_array module procedure receive_real_array_2d module procedure receive_complex module procedure receive_complex_array module procedure receive_complex_2array module procedure nonblocking_receive_complex_array module procedure receive_logical module procedure receive_logical_array module procedure receive_character end interface ! MAB> needed for Trinity ! synchronous sends interface ssend module procedure ssend_integer module procedure ssend_integer_array module procedure ssend_real module procedure ssend_real_array module procedure ssend_complex module procedure ssend_complex_array module procedure ssend_complex_2array module procedure ssend_logical module procedure ssend_logical_array end interface ! send stuff from global proc0 to group proc0s interface all_to_group module procedure all_to_group_real module procedure all_to_group_real_array end interface ! send stuff from group proc0s to global proc0 interface group_to_all module procedure group_to_all_real module procedure group_to_all_real_array end interface ! <MAB contains subroutine init_mp ( comm_in ) use constants , only : pi , kind_rs , kind_rd use file_utils , only : error_unit implicit none integer , intent ( in ), optional :: comm_in integer :: ierror logical :: init call mpi_initialized ( init , ierror ) if (. not . init ) call mpi_init ( ierror ) call mpi_comm_dup ( mpi_comm_world , mpi_comm_world_private , ierror ) if ( present ( comm_in )) then comm_all = comm_in else comm_all = mpi_comm_world_private end if call mpi_comm_size ( comm_all , ntot_proc , ierror ) call mpi_comm_rank ( comm_all , aproc , ierror ) aproc0 = aproc == 0 !the next communicator is between all cores on a given node (i.e. shared memory) call mpi_comm_split_type ( comm_all , mpi_comm_type_shared , aproc , mp_info , comm_shared , ierror ) call mpi_comm_size ( comm_shared , nshared_proc , ierror ) call mpi_comm_rank ( comm_shared , sproc , ierror ) sproc0 = sproc == 0 call mpi_comm_split ( comm_all , sproc , aproc , comm_node , ierror ) call mpi_comm_size ( comm_node , numnodes , ierror ) call mpi_comm_rank ( comm_node , inode , ierror ) !group communicator is global communicator unless changed by job fork comm_group = comm_all ngroup_proc = ntot_proc gproc = aproc gproc0 = aproc0 comm_sgroup = comm_shared nsgroup_proc = nshared_proc sgproc = sproc sgproc0 = sproc0 comm_scross = comm_node nscross_proc = numnodes scproc = inode call scope ( sharedprocs ) call broadcast ( inode ) call scope ( allprocs ) min_proc = nshared_proc call min_allreduce ( min_proc ) if (( kind ( pi ) == kind_rs ) . and . ( kind_rs /= kind_rd )) then mpireal = MPI_REAL mpicmplx = MPI_COMPLEX real_size = 4_MPI_ADDRESS_KIND nbytes_real = 4 else if ( kind ( pi ) == kind_rd ) then mpireal = MPI_DOUBLE_PRECISION mpicmplx = MPI_DOUBLE_COMPLEX real_size = 8_MPI_ADDRESS_KIND nbytes_real = 8 else write ( error_unit (), * ) 'ERROR: precision mismatch in mpi' end if end subroutine init_mp subroutine scope ( focus ) integer , intent ( in ) :: focus if ( focus == allprocs ) then curr_focus = allprocs mp_comm => comm_all nproc => ntot_proc iproc => aproc proc0 => aproc0 else if ( focus == sharedprocs ) then curr_focus = sharedprocs mp_comm => comm_shared nproc => nshared_proc iproc => sproc proc0 => sproc0 else if ( focus == subprocs ) then curr_focus = subprocs mp_comm => comm_group nproc => ngroup_proc iproc => gproc proc0 => gproc0 else if ( focus == crossdomprocs ) then curr_focus = crossdomprocs mp_comm => comm_cross nproc => ndomain_proc iproc => cproc !DSO - 'proc0' in this subgroup is meaningless... be careful proc0 => null () else if ( focus == sharedsubprocs ) then curr_focus = sharedsubprocs mp_comm => comm_sgroup nproc => nsgroup_proc iproc => sgproc proc0 => sgproc0 else if ( focus == scrossdomprocs ) then curr_focus = scrossdomprocs mp_comm => comm_scross nproc => nscross_proc iproc => scproc proc0 => null () end if end subroutine scope subroutine init_job_topology ( ncolumns , group0 , ierr ) implicit none !    integer, parameter :: reorder=1 ! TT: I changed variable definition by assuming integer 1 corresponds to ! TT: logical .true. but I am not sure if reorder is needed. ! TT: In any case this subroutine is only called when you use job fork. logical , parameter :: reorder = . true . integer :: ip , j , comm2d , id2d , ierr , nrows integer , intent ( in ) :: ncolumns integer , dimension ( 0 :), intent ( out ) :: group0 integer , parameter :: ndim = 2 integer , dimension ( ndim ) :: dims integer , dimension ( 0 : ndim - 1 ) :: coords1d , coords2d logical , dimension ( 0 : ndim - 1 ) :: belongs logical , dimension ( ndim ) :: period logical :: isroot if (. not . allocated ( grp0 )) allocate ( grp0 ( 0 : size ( group0 ) - 1 )) ! calculate dimensions  mpi processor grid will have and check that ! ncolumns*nrows = number of processes ! nrows is # of processors per job (or group) nrows = ntot_proc / ncolumns dims = ( / ncolumns , nrows / ) if ( ntot_proc /= ncolumns * nrows ) then ierr = 1 if ( aproc0 ) write ( * , * ) 'Number of processes must be divisible by number of groups' return end if ngroup_proc = nrows ndomain_proc = ncolumns ! create 2d cartesian topology for processes period = ( / . false ., . false . / ) !! no circular shift call mpi_cart_create ( comm_all , ndim , dims , period , reorder , comm2d , ierr ) call mpi_comm_rank ( comm2d , id2d , ierr ) call mpi_cart_coords ( comm2d , id2d , ndim , coords2d , ierr ) ! each processor knows which subgrid it is in from variable mpi_group job = coords2d ( 0 ) ! create 1d subgrids from 2d processor grid, variable belongs denotes ! whether processor grid is split by column or row ! this group denotes processors on a single flux tube in a multi-tube ! simulation (e.g. for Trinity) belongs ( 1 ) = . true . ! this dimension belongs to subgrid belongs ( 0 ) = . false . call mpi_cart_sub ( comm2d , belongs , comm_group , ierr ) call mpi_comm_rank ( comm_group , gproc , ierr ) call mpi_cart_coords ( comm_group , gproc , 1 , coords1d , ierr ) gproc0 = ( gproc == 0 ) ! this group denotes processor with different domains at shared ! vpa_mu_s coordinates, with the intended purpose to couple separate ! flux tubes radially belongs ( 1 ) = . false . ! this dimension belongs to subgrid belongs ( 0 ) = . true . call mpi_cart_sub ( comm2d , belongs , comm_cross , ierr ) call mpi_comm_rank ( comm_cross , cproc , ierr ) !call mpi_cart_coords(comm_cross, cproc, 1, crosscoords1d, ierr) if ( job /= cproc ) call mp_abort ( \"topology coordinates\" ) ! find root process of each 1d subgrid and place in array group0 indexed ! from 0 to subgrids-1 ! MAB> following two lines were incorrect !    j=1 !    group0(0) = 0 ! replace with j = 0 if ( proc0 . and . gproc0 ) then group0 ( 0 ) = 0 j = 1 end if ! <MAB do ip = 1 , ntot_proc - 1 if ( proc0 ) then call receive ( isroot , ip ) if ( isroot ) then group0 ( j ) = ip j = j + 1 end if else if ( ip == aproc ) then call send ( gproc0 , 0 ) end if call barrier end do !the next communicator is between all cores on a given node for a given job(i.e. shared memory) call mpi_comm_split_type ( comm_group , mpi_comm_type_shared , aproc , mp_info , comm_sgroup , ierr ) call mpi_comm_size ( comm_sgroup , nsgroup_proc , ierr ) call mpi_comm_rank ( comm_sgroup , sgproc , ierr ) sgproc0 = sgproc == 0 call mpi_comm_split ( comm_group , sgproc , gproc , comm_scross , ierr ) call mpi_comm_size ( comm_scross , nscross_proc , ierr ) call mpi_comm_rank ( comm_scross , scproc , ierr ) !let all processors have the group0 array call broadcast ( group0 ) grp0 = group0 ! TT> brought down here from init_job_name in file_utils.fpp call scope ( subprocs ) ! <TT !get the minimum number of procs on a node for a given job min_proc = nsgroup_proc call min_allreduce ( min_proc ) end subroutine init_job_topology #ifdef ISO_C_BINDING !> creates a shared memory window of the specific size !> Returns the MPI window, as well as the pointer to the specific !> address in memory to be used with c_f_pointer subroutine create_shared_memory_window ( win_size , window , cur_pos ) use , intrinsic :: iso_c_binding , only : c_ptr , c_f_pointer , c_intptr_t use mpi implicit none integer ( kind = MPI_ADDRESS_KIND ), intent ( inout ) :: win_size integer , intent ( out ) :: window integer ( c_intptr_t ), optional , intent ( out ) :: cur_pos integer :: disp_unit = 1 integer :: prior_focus , ierr integer ( kind = MPI_ADDRESS_KIND ) :: memory_model logical :: flag type ( c_ptr ) :: cptr prior_focus = curr_focus call scope ( sharedsubprocs ) call mpi_win_allocate_shared ( win_size , disp_unit , MPI_INFO_NULL , mp_comm , & cptr , window , ierr ) if (. not . sgproc0 ) then !make sure all the procs have the right memory address call mpi_win_shared_query ( window , 0 , win_size , disp_unit , cptr , ierr ) end if call mpi_win_fence ( 0 , window , ierr ) call mpi_win_get_attr ( window , MPI_WIN_MODEL , memory_model , flag , ierr ) if ( flag ) then if ( memory_model /= MPI_WIN_UNIFIED ) then call mp_abort ( 'MPI_WIN_MODEL is not MPI_WIN_UNIFIED. Compile withou HAS_ISO_C_BINDING' ) end if else call mp_abort ( 'MPI_WIN_MODEL not found. Compile withou HAS_ISO_C_BINDING' ) end if !the following is a hack that allows us to perform pointer arithmetic in Fortran if ( present ( cur_pos )) cur_pos = transfer ( cptr , cur_pos ) call scope ( prior_focus ) end subroutine create_shared_memory_window #endif !> split n tasks over current communicator. Returns the low and high !> indices for a given processor. Assumes indices start at 1 subroutine split_n_tasks ( n , lo , hi ) implicit none integer , intent ( in ) :: n integer , intent ( out ) :: lo , hi integer :: n_div , n_mod n_div = n / nproc n_mod = mod ( n , nproc ) lo = iproc * n_div + 1 + min ( iproc , n_mod ) hi = lo + n_div - 1 if ( iproc < n_mod ) hi = hi + 1 end subroutine split_n_tasks subroutine finish_mp implicit none integer :: ierror call mpi_finalize ( ierror ) end subroutine finish_mp ! ************** broadcasts ***************************** subroutine broadcast_character ( char ) implicit none character ( * ), intent ( in out ) :: char integer :: ierror call mpi_bcast ( char , len ( char ), MPI_CHARACTER , 0 , mp_comm , ierror ) end subroutine broadcast_character subroutine broadcast_integer ( i ) implicit none integer , intent ( in out ) :: i integer :: ierror call mpi_bcast ( i , 1 , MPI_INTEGER , 0 , mp_comm , ierror ) end subroutine broadcast_integer subroutine broadcast_integer_array ( i ) implicit none integer , dimension (:), intent ( in out ) :: i integer :: ierror call mpi_bcast ( i , size ( i ), MPI_INTEGER , 0 , mp_comm , ierror ) end subroutine broadcast_integer_array subroutine broadcast_real ( x ) implicit none real , intent ( in out ) :: x integer :: ierror call mpi_bcast ( x , 1 , mpireal , 0 , mp_comm , ierror ) end subroutine broadcast_real subroutine broadcast_real_array ( x ) implicit none real , dimension (:), intent ( in out ) :: x integer :: ierror call mpi_bcast ( x , size ( x ), mpireal , 0 , mp_comm , ierror ) end subroutine broadcast_real_array subroutine broadcast_real_2array ( x ) implicit none real , dimension (:, :), intent ( in out ) :: x integer :: ierror call mpi_bcast ( x , size ( x ), mpireal , 0 , mp_comm , ierror ) end subroutine broadcast_real_2array subroutine broadcast_real_3array ( x ) implicit none real , dimension (:, :, :), intent ( in out ) :: x integer :: ierror call mpi_bcast ( x , size ( x ), mpireal , 0 , mp_comm , ierror ) end subroutine broadcast_real_3array subroutine broadcast_real_4array ( x ) implicit none real , dimension (:, :, :, :), intent ( in out ) :: x integer :: ierror call mpi_bcast ( x , size ( x ), mpireal , 0 , mp_comm , ierror ) end subroutine broadcast_real_4array subroutine broadcast_real_5array ( x ) implicit none real , dimension (:, :, :, :, :), intent ( in out ) :: x integer :: ierror call mpi_bcast ( x , size ( x ), mpireal , 0 , mp_comm , ierror ) end subroutine broadcast_real_5array subroutine broadcast_complex ( z ) implicit none complex , intent ( in out ) :: z integer :: ierror call mpi_bcast ( z , 1 , mpicmplx , 0 , mp_comm , ierror ) end subroutine broadcast_complex subroutine broadcast_complex_array ( z ) implicit none complex , dimension (:), intent ( in out ) :: z integer :: ierror call mpi_bcast ( z , size ( z ), mpicmplx , 0 , mp_comm , ierror ) end subroutine broadcast_complex_array subroutine broadcast_complex_2array ( z ) implicit none complex , dimension (:, :), intent ( in out ) :: z integer :: ierror call mpi_bcast ( z , size ( z ), mpicmplx , 0 , mp_comm , ierror ) end subroutine broadcast_complex_2array subroutine broadcast_complex_3array ( z ) implicit none complex , dimension (:, :, :), intent ( in out ) :: z integer :: ierror call mpi_bcast ( z , size ( z ), mpicmplx , 0 , mp_comm , ierror ) end subroutine broadcast_complex_3array subroutine broadcast_complex_4array ( z ) implicit none complex , dimension (:, :, :, :), intent ( in out ) :: z integer :: ierror call mpi_bcast ( z , size ( z ), mpicmplx , 0 , mp_comm , ierror ) end subroutine broadcast_complex_4array subroutine broadcast_logical ( f ) implicit none logical , intent ( in out ) :: f integer :: ierror call mpi_bcast ( f , 1 , MPI_LOGICAL , 0 , mp_comm , ierror ) end subroutine broadcast_logical subroutine broadcast_logical_array ( f ) implicit none logical , dimension (:), intent ( in out ) :: f integer :: ierror call mpi_bcast ( f , size ( f ), MPI_LOGICAL , 0 , mp_comm , ierror ) end subroutine broadcast_logical_array subroutine bcastfrom_logical ( f , src ) implicit none logical , intent ( in out ) :: f integer , intent ( in ) :: src integer :: ierror call mpi_bcast ( f , 1 , MPI_LOGICAL , src , mp_comm , ierror ) end subroutine bcastfrom_logical subroutine bcastfrom_logical_array ( f , src ) implicit none logical , dimension (:), intent ( in out ) :: f integer , intent ( in ) :: src integer :: ierror call mpi_bcast ( f , size ( f ), MPI_LOGICAL , src , mp_comm , ierror ) end subroutine bcastfrom_logical_array subroutine bcastfrom_character ( c , src ) implicit none character ( * ), intent ( in out ) :: c integer , intent ( in ) :: src integer :: ierror call mpi_bcast ( c , len ( c ), MPI_CHARACTER , src , mp_comm , ierror ) end subroutine bcastfrom_character subroutine bcastfrom_integer ( i , src ) implicit none integer , intent ( in out ) :: i integer , intent ( in ) :: src integer :: ierror call mpi_bcast ( i , 1 , MPI_INTEGER , src , mp_comm , ierror ) end subroutine bcastfrom_integer subroutine bcastfrom_integer_array ( i , src ) implicit none integer , dimension (:), intent ( in out ) :: i integer , intent ( in ) :: src integer :: ierror call mpi_bcast ( i , size ( i ), MPI_INTEGER , src , mp_comm , ierror ) end subroutine bcastfrom_integer_array subroutine bcastfrom_real ( x , src ) implicit none real , intent ( in out ) :: x integer , intent ( in ) :: src integer :: ierror call mpi_bcast ( x , 1 , mpireal , src , mp_comm , ierror ) end subroutine bcastfrom_real subroutine bcastfrom_real_array ( x , src ) implicit none real , dimension (:), intent ( in out ) :: x integer , intent ( in ) :: src integer :: ierror call mpi_bcast ( x , size ( x ), mpireal , src , mp_comm , ierror ) end subroutine bcastfrom_real_array subroutine bcastfrom_complex ( z , src ) implicit none complex , intent ( in out ) :: z integer , intent ( in ) :: src integer :: ierror call mpi_bcast ( z , 1 , mpicmplx , src , mp_comm , ierror ) end subroutine bcastfrom_complex subroutine bcastfrom_complex_array ( z , src ) implicit none complex , dimension (:), intent ( in out ) :: z integer , intent ( in ) :: src integer :: ierror call mpi_bcast ( z , size ( z ), mpicmplx , src , mp_comm , ierror ) end subroutine bcastfrom_complex_array subroutine bcastfrom_complex_2array ( z , src ) implicit none complex , dimension (:, :), intent ( in out ) :: z integer , intent ( in ) :: src integer :: ierror call mpi_bcast ( z , size ( z ), mpicmplx , src , mp_comm , ierror ) end subroutine bcastfrom_complex_2array ! ************** reductions *********************** subroutine sum_reduce_integer ( i , dest ) implicit none integer , intent ( in out ) :: i integer , intent ( in ) :: dest integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , i , 1 , MPI_INTEGER , MPI_SUM , dest , mp_comm , ierror ) else call mpi_reduce & ( i , i , 1 , MPI_INTEGER , MPI_SUM , dest , mp_comm , ierror ) end if end subroutine sum_reduce_integer subroutine sum_reduce_integer_array ( i , dest ) implicit none integer , dimension (:), intent ( in out ) :: i integer , intent ( in ) :: dest integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , i , size ( i ), MPI_INTEGER , MPI_SUM , dest , mp_comm , ierror ) else call mpi_reduce & ( i , i , size ( i ), MPI_INTEGER , MPI_SUM , dest , mp_comm , ierror ) end if end subroutine sum_reduce_integer_array !   subroutine sum_reduce_logical (a, dest) !     implicit none !     logical, intent (in out) :: a !     integer, intent (in) :: dest !     integer :: ierror !     if(iproc.eq.dest)then !        call mpi_reduce & !             (MPI_IN_PLACE, a, 1, MPI_LOGICAL, MPI_LOR, dest, mp_comm, ierror) !     else !        call mpi_reduce & !             (a, a, 1, MPI_LOGICAL, MPI_LOR, dest, mp_comm, ierror) !     endif !   end subroutine sum_reduce_logical subroutine sum_reduce_real ( a , dest ) implicit none real , intent ( in out ) :: a integer , intent ( in ) :: dest integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , a , 1 , mpireal , MPI_SUM , dest , mp_comm , ierror ) else call mpi_reduce & ( a , a , 1 , mpireal , MPI_SUM , dest , mp_comm , ierror ) end if end subroutine sum_reduce_real subroutine sum_reduce_real_array ( a , dest ) implicit none real , dimension (:), intent ( in out ) :: a integer , intent ( in ) :: dest integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , a , size ( a ), mpireal , MPI_SUM , dest , mp_comm , ierror ) else call mpi_reduce & ( a , a , size ( a ), mpireal , MPI_SUM , dest , mp_comm , ierror ) end if end subroutine sum_reduce_real_array subroutine sum_reduce_real_2array ( a , dest ) implicit none real , dimension (:, :), intent ( in out ) :: a integer , intent ( in ) :: dest integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , a , size ( a ), mpireal , MPI_SUM , dest , mp_comm , ierror ) else call mpi_reduce & ( a , a , size ( a ), mpireal , MPI_SUM , dest , mp_comm , ierror ) end if end subroutine sum_reduce_real_2array subroutine sum_reduce_real_3array ( a , dest ) implicit none real , dimension (:, :, :), intent ( in out ) :: a integer , intent ( in ) :: dest integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , a , size ( a ), mpireal , MPI_SUM , dest , mp_comm , ierror ) else call mpi_reduce & ( a , a , size ( a ), mpireal , MPI_SUM , dest , mp_comm , ierror ) end if end subroutine sum_reduce_real_3array subroutine sum_reduce_real_4array ( a , dest ) implicit none real , dimension (:, :, :, :), intent ( in out ) :: a integer , intent ( in ) :: dest integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , a , size ( a ), mpireal , MPI_SUM , dest , mp_comm , ierror ) else call mpi_reduce & ( a , a , size ( a ), mpireal , MPI_SUM , dest , mp_comm , ierror ) end if end subroutine sum_reduce_real_4array subroutine sum_reduce_real_5array ( a , dest ) implicit none real , dimension (:, :, :, :, :), intent ( in out ) :: a integer , intent ( in ) :: dest integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , a , size ( a ), mpireal , MPI_SUM , dest , mp_comm , ierror ) else call mpi_reduce & ( a , a , size ( a ), mpireal , MPI_SUM , dest , mp_comm , ierror ) end if end subroutine sum_reduce_real_5array subroutine sum_reduce_complex ( z , dest ) implicit none complex , intent ( in out ) :: z integer , intent ( in ) :: dest integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , z , 1 , mpicmplx , MPI_SUM , dest , mp_comm , ierror ) else call mpi_reduce & ( z , z , 1 , mpicmplx , MPI_SUM , dest , mp_comm , ierror ) end if end subroutine sum_reduce_complex subroutine sum_reduce_complex_array ( z , dest ) implicit none complex , dimension (:), intent ( in out ) :: z integer , intent ( in ) :: dest integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , z , size ( z ), mpicmplx , MPI_SUM , dest , mp_comm , ierror ) else call mpi_reduce & ( z , z , size ( z ), mpicmplx , MPI_SUM , dest , mp_comm , ierror ) end if end subroutine sum_reduce_complex_array subroutine sum_reduce_complex_2array ( z , dest ) implicit none complex , dimension (:, :), intent ( in out ) :: z integer , intent ( in ) :: dest integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , z , size ( z ), mpicmplx , MPI_SUM , dest , mp_comm , ierror ) else call mpi_reduce & ( z , z , size ( z ), mpicmplx , MPI_SUM , dest , mp_comm , ierror ) end if end subroutine sum_reduce_complex_2array subroutine sum_reduce_complex_3array ( z , dest ) implicit none complex , dimension (:, :, :), intent ( in out ) :: z integer , intent ( in ) :: dest integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , z , size ( z ), mpicmplx , MPI_SUM , dest , mp_comm , ierror ) else call mpi_reduce & ( z , z , size ( z ), mpicmplx , MPI_SUM , dest , mp_comm , ierror ) end if end subroutine sum_reduce_complex_3array subroutine sum_reduce_complex_4array ( z , dest ) implicit none complex , dimension (:, :, :, :), intent ( in out ) :: z integer , intent ( in ) :: dest integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , z , size ( z ), mpicmplx , MPI_SUM , dest , mp_comm , ierror ) else call mpi_reduce & ( z , z , size ( z ), mpicmplx , MPI_SUM , dest , mp_comm , ierror ) end if end subroutine sum_reduce_complex_4array subroutine sum_reduce_complex_5array ( z , dest ) implicit none complex , dimension (:, :, :, :, :), intent ( in out ) :: z integer , intent ( in ) :: dest integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , z , size ( z ), mpicmplx , MPI_SUM , dest , mp_comm , ierror ) else call mpi_reduce & ( z , z , size ( z ), mpicmplx , MPI_SUM , dest , mp_comm , ierror ) end if end subroutine sum_reduce_complex_5array ! Sum all z1 values into z2 at dest !   subroutine sum_reduce_alt_complex_3array (z1,z2,dest) !     implicit none !     complex, dimension (:,:,:), intent (in out) :: z1 !     complex, dimension (:,:,:), intent (in out) :: z2 !     integer, intent (in) :: dest !     integer :: ierror !     call mpi_reduce & !          (z1, z2, size(z1), mpicmplx, MPI_SUM, dest, mp_comm, ierror) !   end subroutine sum_reduce_alt_complex_3array subroutine sum_allreduce_integer ( i ) implicit none integer , intent ( in out ) :: i integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , i , 1 , MPI_INTEGER , MPI_SUM , mp_comm , ierror ) end subroutine sum_allreduce_integer subroutine sum_allreduce_integer_array ( i ) implicit none integer , dimension (:), intent ( in out ) :: i integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , i , size ( i ), MPI_INTEGER , MPI_SUM , mp_comm , ierror ) end subroutine sum_allreduce_integer_array subroutine sum_allreduce_integer_2array ( i ) implicit none integer , dimension (:, :), intent ( in out ) :: i integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , i , size ( i ), MPI_INTEGER , MPI_SUM , mp_comm , ierror ) end subroutine sum_allreduce_integer_2array subroutine sum_allreduce_real ( a ) implicit none real , intent ( in out ) :: a integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , a , 1 , mpireal , MPI_SUM , mp_comm , ierror ) end subroutine sum_allreduce_real subroutine sum_allreduce_real_array ( a ) implicit none real , dimension (:), intent ( in out ) :: a integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , a , size ( a ), mpireal , MPI_SUM , mp_comm , ierror ) end subroutine sum_allreduce_real_array subroutine sum_allreduce_real_2array ( a ) implicit none real , dimension (:, :), intent ( in out ) :: a integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , a , size ( a ), mpireal , MPI_SUM , mp_comm , ierror ) end subroutine sum_allreduce_real_2array subroutine sum_allreduce_real_3array ( a ) implicit none real , dimension (:, :, :), intent ( in out ) :: a integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , a , size ( a ), mpireal , MPI_SUM , mp_comm , ierror ) end subroutine sum_allreduce_real_3array subroutine sum_allreduce_real_4array ( a ) implicit none real , dimension (:, :, :, :), intent ( in out ) :: a integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , a , size ( a ), mpireal , MPI_SUM , mp_comm , ierror ) end subroutine sum_allreduce_real_4array subroutine sum_allreduce_real_5array ( a ) implicit none real , dimension (:, :, :, :, :), intent ( in out ) :: a integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , a , size ( a ), mpireal , MPI_SUM , mp_comm , ierror ) end subroutine sum_allreduce_real_5array subroutine sum_allreduce_complex ( z ) implicit none complex , intent ( in out ) :: z integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , z , 1 , mpicmplx , MPI_SUM , mp_comm , ierror ) end subroutine sum_allreduce_complex subroutine sum_allreduce_complex_array ( z ) implicit none complex , dimension (:), intent ( in out ) :: z integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , z , size ( z ), mpicmplx , MPI_SUM , mp_comm , ierror ) end subroutine sum_allreduce_complex_array subroutine sum_allreduce_complex_2array ( z ) implicit none complex , dimension (:, :), intent ( in out ) :: z integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , z , size ( z ), mpicmplx , MPI_SUM , mp_comm , ierror ) end subroutine sum_allreduce_complex_2array subroutine sum_allreduce_complex_3array ( z ) implicit none complex , dimension (:, :, :), intent ( in out ) :: z integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , z , size ( z ), mpicmplx , MPI_SUM , mp_comm , ierror ) end subroutine sum_allreduce_complex_3array subroutine sum_allreduce_complex_4array ( z ) implicit none complex , dimension (:, :, :, :), intent ( in out ) :: z integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , z , size ( z ), mpicmplx , MPI_SUM , mp_comm , ierror ) end subroutine sum_allreduce_complex_4array subroutine sum_allreduce_complex_5array ( z ) implicit none complex , dimension (:, :, :, :, :), intent ( in out ) :: z integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , z , size ( z ), mpicmplx , MPI_SUM , mp_comm , ierror ) end subroutine sum_allreduce_complex_5array subroutine max_reduce_integer ( i , dest ) implicit none integer , intent ( in out ) :: i integer , intent ( in ) :: dest integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , i , 1 , MPI_INTEGER , MPI_MAX , dest , mp_comm , ierror ) else call mpi_reduce & ( i , i , 1 , MPI_INTEGER , MPI_MAX , dest , mp_comm , ierror ) end if end subroutine max_reduce_integer subroutine max_reduce_integer_array ( i , dest ) implicit none integer , dimension (:), intent ( in out ) :: i integer , intent ( in ) :: dest integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , i , size ( i ), MPI_INTEGER , MPI_MAX , dest , mp_comm , ierror ) else call mpi_reduce & ( i , i , size ( i ), MPI_INTEGER , MPI_MAX , dest , mp_comm , ierror ) end if end subroutine max_reduce_integer_array subroutine max_reduce_real ( a , dest ) implicit none real , intent ( in out ) :: a integer , intent ( in ) :: dest integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , a , 1 , mpireal , MPI_MAX , dest , mp_comm , ierror ) else call mpi_reduce & ( a , a , 1 , mpireal , MPI_MAX , dest , mp_comm , ierror ) end if end subroutine max_reduce_real subroutine max_reduce_real_array ( a , dest ) implicit none real , dimension (:), intent ( in out ) :: a integer , intent ( in ) :: dest integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , a , size ( a ), mpireal , MPI_MAX , dest , mp_comm , ierror ) else call mpi_reduce & ( a , a , size ( a ), mpireal , MPI_MAX , dest , mp_comm , ierror ) end if end subroutine max_reduce_real_array subroutine max_allreduce_integer ( i ) implicit none integer , intent ( in out ) :: i integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , i , 1 , MPI_INTEGER , MPI_MAX , mp_comm , ierror ) end subroutine max_allreduce_integer subroutine max_allreduce_integer_array ( i ) implicit none integer , dimension (:), intent ( in out ) :: i integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , i , size ( i ), MPI_INTEGER , MPI_MAX , mp_comm , ierror ) end subroutine max_allreduce_integer_array subroutine max_allreduce_real ( a ) implicit none real , intent ( in out ) :: a integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , a , 1 , mpireal , MPI_MAX , mp_comm , ierror ) end subroutine max_allreduce_real subroutine max_allreduce_real_array ( a ) implicit none real , dimension (:), intent ( in out ) :: a integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , a , size ( a ), mpireal , MPI_MAX , mp_comm , ierror ) end subroutine max_allreduce_real_array subroutine min_reduce_integer ( i , dest ) implicit none integer , intent ( in out ) :: i integer , intent ( in ) :: dest integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , i , 1 , MPI_INTEGER , MPI_MIN , dest , mp_comm , ierror ) else call mpi_reduce & ( i , i , 1 , MPI_INTEGER , MPI_MIN , dest , mp_comm , ierror ) end if end subroutine min_reduce_integer subroutine min_reduce_integer_array ( i , dest ) implicit none integer , dimension (:), intent ( in out ) :: i integer , intent ( in ) :: dest integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , i , size ( i ), MPI_INTEGER , MPI_MIN , dest , mp_comm , ierror ) else call mpi_reduce & ( i , i , size ( i ), MPI_INTEGER , MPI_MIN , dest , mp_comm , ierror ) end if end subroutine min_reduce_integer_array subroutine min_reduce_real ( a , dest ) implicit none real , intent ( in out ) :: a integer , intent ( in ) :: dest integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , a , 1 , mpireal , MPI_MIN , dest , mp_comm , ierror ) else call mpi_reduce & ( a , a , 1 , mpireal , MPI_MIN , dest , mp_comm , ierror ) end if end subroutine min_reduce_real subroutine min_reduce_real_array ( a , dest ) implicit none real , dimension (:), intent ( in out ) :: a integer , intent ( in ) :: dest integer :: ierror if ( iproc == dest ) then call mpi_reduce & ( MPI_IN_PLACE , a , size ( a ), mpireal , MPI_MIN , dest , mp_comm , ierror ) else call mpi_reduce & ( a , a , size ( a ), mpireal , MPI_MIN , dest , mp_comm , ierror ) end if end subroutine min_reduce_real_array subroutine min_allreduce_integer ( i ) implicit none integer , intent ( in out ) :: i integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , i , 1 , MPI_INTEGER , MPI_MIN , mp_comm , ierror ) end subroutine min_allreduce_integer subroutine min_allreduce_integer_array ( i ) implicit none integer , dimension (:), intent ( in out ) :: i integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , i , size ( i ), MPI_INTEGER , MPI_MIN , mp_comm , ierror ) end subroutine min_allreduce_integer_array subroutine min_allreduce_real ( a ) implicit none real , intent ( in out ) :: a integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , a , 1 , mpireal , MPI_MIN , mp_comm , ierror ) end subroutine min_allreduce_real subroutine min_allreduce_real_array ( a ) implicit none real , dimension (:), intent ( in out ) :: a integer :: ierror call mpi_allreduce & ( MPI_IN_PLACE , a , size ( a ), mpireal , MPI_MIN , mp_comm , ierror ) end subroutine min_allreduce_real_array subroutine comm_split ( color , comm_out , ierr ) implicit none integer , intent ( in ) :: color integer , intent ( out ) :: comm_out , ierr call mpi_comm_split ( mp_comm , color , iproc , comm_out , ierr ) end subroutine comm_split subroutine comm_free ( comm_in , ierr ) implicit none integer , intent ( in ) :: comm_in integer , intent ( out ) :: ierr ! this seemingly unnecessary complication appears to be needed ! for compiling with open-mpi and gfortran on macosx integer , pointer :: comm_local integer , target :: comm_target comm_target = comm_in comm_local => comm_target call mpi_comm_free ( comm_local , ierr ) end subroutine comm_free ! ********************* barrier ********************** subroutine barrier implicit none integer :: ierror call mpi_barrier ( mp_comm , ierror ) end subroutine barrier ! ********************* sends ********************** subroutine send_integer ( i , dest , tag ) implicit none integer , intent ( in ) :: i integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_send ( i , 1 , MPI_INTEGER , dest , tagp , mp_comm , ierror ) end subroutine send_integer subroutine send_integer_array ( i , dest , tag ) implicit none integer , dimension (:), intent ( in ) :: i integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_send ( i , size ( i ), MPI_INTEGER , dest , tagp , mp_comm , ierror ) end subroutine send_integer_array subroutine send_real ( a , dest , tag ) implicit none real , intent ( in ) :: a integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_send ( a , 1 , mpireal , dest , tagp , mp_comm , ierror ) end subroutine send_real subroutine send_real_array ( a , dest , tag ) implicit none real , dimension (:), intent ( in ) :: a integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_send ( a , size ( a ), mpireal , dest , tagp , mp_comm , ierror ) end subroutine send_real_array subroutine send_real_array_2d ( a , dest , tag ) implicit none real , dimension (:, :), intent ( in ) :: a integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_send ( a , size ( a ), mpireal , dest , tagp , mp_comm , ierror ) end subroutine send_real_array_2d subroutine send_complex ( z , dest , tag ) implicit none complex , intent ( in ) :: z integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_send ( z , 1 , mpicmplx , dest , tagp , mp_comm , ierror ) end subroutine send_complex subroutine send_complex_array ( z , dest , tag ) implicit none complex , dimension (:), intent ( in ) :: z integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_send ( z , size ( z ), mpicmplx , dest , tagp , mp_comm , ierror ) end subroutine send_complex_array subroutine nonblocking_send_complex_array ( z , dest , tag , request ) implicit none complex , dimension (:), intent ( in ) :: z integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag integer , intent ( out ) :: request integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_isend ( z , size ( z ), mpicmplx , dest , tagp , mp_comm , request , ierror ) end subroutine nonblocking_send_complex_array subroutine send_logical ( f , dest , tag ) implicit none logical , intent ( in ) :: f integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_send ( f , 1 , MPI_LOGICAL , dest , tagp , mp_comm , ierror ) end subroutine send_logical subroutine send_logical_array ( f , dest , tag ) implicit none logical , dimension (:), intent ( in ) :: f integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_send ( f , size ( f ), MPI_LOGICAL , dest , tagp , mp_comm , ierror ) end subroutine send_logical_array subroutine send_character ( s , dest , tag ) implicit none character ( * ), intent ( in ) :: s integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_send & ( s , len ( s ), MPI_CHARACTER , dest , tagp , mp_comm , ierror ) end subroutine send_character ! MAB> needed for Trinity ! ********************* synchronous sends ********************** subroutine ssend_integer ( i , dest , tag ) implicit none integer , intent ( in ) :: i integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_ssend ( i , 1 , MPI_INTEGER , dest , tagp , mp_comm , ierror ) end subroutine ssend_integer subroutine ssend_integer_array ( i , dest , tag ) implicit none integer , dimension (:), intent ( in ) :: i integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_ssend ( i , size ( i ), MPI_INTEGER , dest , tagp , mp_comm , ierror ) end subroutine ssend_integer_array subroutine ssend_real ( a , dest , tag ) implicit none real , intent ( in ) :: a integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_ssend ( a , 1 , MPI_DOUBLE_PRECISION , dest , tagp , mp_comm , ierror ) end subroutine ssend_real subroutine ssend_real_array ( a , dest , tag ) implicit none real , dimension (:), intent ( in ) :: a integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_ssend ( a , size ( a ), MPI_DOUBLE_PRECISION , dest , tagp , mp_comm , ierror ) end subroutine ssend_real_array subroutine ssend_complex ( z , dest , tag ) implicit none complex , intent ( in ) :: z integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_ssend ( z , 1 , MPI_DOUBLE_COMPLEX , dest , tagp , mp_comm , ierror ) end subroutine ssend_complex subroutine ssend_complex_array ( z , dest , tag ) implicit none complex , dimension (:), intent ( in ) :: z integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_ssend ( z , size ( z ), MPI_DOUBLE_COMPLEX , dest , tagp , mp_comm , ierror ) end subroutine ssend_complex_array subroutine ssend_complex_2array ( z , dest , tag ) implicit none complex , dimension (:, :), intent ( in ) :: z integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_ssend ( z , size ( z ), MPI_DOUBLE_COMPLEX , dest , tagp , mp_comm , ierror ) end subroutine ssend_complex_2array subroutine ssend_logical ( f , dest , tag ) implicit none logical , intent ( in ) :: f integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_ssend ( f , 1 , MPI_LOGICAL , dest , tagp , mp_comm , ierror ) end subroutine ssend_logical subroutine ssend_logical_array ( f , dest , tag ) implicit none logical , dimension (:), intent ( in ) :: f integer , intent ( in ) :: dest integer , intent ( in ), optional :: tag integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_ssend ( f , size ( f ), MPI_LOGICAL , dest , tagp , mp_comm , ierror ) end subroutine ssend_logical_array !   subroutine ssend_character (s, dest, tag) !     implicit none !     character(*), intent (in) :: s !     integer, intent (in) :: dest !     integer, intent (in), optional :: tag !     integer :: ierror !     integer :: tagp !     tagp = 0 !     if (present(tag)) tagp = tag !     call mpi_ssend & !          (s, len(s), MPI_CHARACTER, dest, tagp, mp_comm, ierror) !   end subroutine ssend_character ! <MAB ! ********************* receives  ********************** subroutine receive_integer ( i , src , tag ) implicit none integer , intent ( out ) :: i integer , intent ( in ) :: src integer , intent ( in ), optional :: tag integer :: ierror integer :: tagp integer , dimension ( MPI_STATUS_SIZE ) :: status tagp = 0 if ( present ( tag )) tagp = tag call mpi_recv ( i , 1 , MPI_INTEGER , src , tagp , mp_comm , & status , ierror ) end subroutine receive_integer subroutine receive_integer_array ( i , src , tag ) implicit none integer , dimension (:), intent ( out ) :: i integer , intent ( in ) :: src integer , intent ( in ), optional :: tag integer :: ierror integer :: tagp integer , dimension ( MPI_STATUS_SIZE ) :: status tagp = 0 if ( present ( tag )) tagp = tag call mpi_recv ( i , size ( i ), MPI_INTEGER , src , tagp , mp_comm , & status , ierror ) end subroutine receive_integer_array subroutine receive_real ( a , src , tag ) implicit none real , intent ( out ) :: a integer , intent ( in ) :: src integer , intent ( in ), optional :: tag integer :: ierror integer :: tagp integer , dimension ( MPI_STATUS_SIZE ) :: status tagp = 0 if ( present ( tag )) tagp = tag call mpi_recv ( a , 1 , mpireal , src , tagp , mp_comm , & status , ierror ) end subroutine receive_real subroutine receive_real_array ( a , src , tag ) implicit none real , dimension (:), intent ( out ) :: a integer , intent ( in ) :: src integer , intent ( in ), optional :: tag integer :: ierror integer :: tagp integer , dimension ( MPI_STATUS_SIZE ) :: status tagp = 0 if ( present ( tag )) tagp = tag call mpi_recv ( a , size ( a ), mpireal , src , tagp , mp_comm , & status , ierror ) end subroutine receive_real_array subroutine receive_real_array_2d ( a , src , tag ) implicit none real , dimension (:, :), intent ( out ) :: a integer , intent ( in ) :: src integer , intent ( in ), optional :: tag integer :: ierror integer :: tagp integer , dimension ( MPI_STATUS_SIZE ) :: status tagp = 0 if ( present ( tag )) tagp = tag call mpi_recv ( a , size ( a ), mpireal , src , tagp , mp_comm , & status , ierror ) end subroutine receive_real_array_2d subroutine receive_complex ( z , src , tag ) implicit none complex , intent ( out ) :: z integer , intent ( in ) :: src integer , intent ( in ), optional :: tag integer :: ierror integer :: tagp integer , dimension ( MPI_STATUS_SIZE ) :: status tagp = 0 if ( present ( tag )) tagp = tag call mpi_recv ( z , 1 , mpicmplx , src , tagp , mp_comm , & status , ierror ) end subroutine receive_complex subroutine receive_complex_array ( z , src , tag ) implicit none complex , dimension (:), intent ( out ) :: z integer , intent ( in ) :: src integer , intent ( in ), optional :: tag integer :: ierror integer :: tagp integer , dimension ( MPI_STATUS_SIZE ) :: status tagp = 0 if ( present ( tag )) tagp = tag call mpi_recv ( z , size ( z ), mpicmplx , src , tagp , mp_comm , & status , ierror ) end subroutine receive_complex_array subroutine receive_complex_2array ( z , src , tag ) implicit none complex , dimension (:, :), intent ( out ) :: z integer , intent ( in ) :: src integer , intent ( in ), optional :: tag integer :: ierror integer :: tagp integer , dimension ( MPI_STATUS_SIZE ) :: status tagp = 0 if ( present ( tag )) tagp = tag call mpi_recv ( z , size ( z ), mpicmplx , src , tagp , mp_comm , & status , ierror ) end subroutine receive_complex_2array subroutine nonblocking_receive_complex_array ( z , src , tag , request ) implicit none complex , dimension (:), intent ( inout ) :: z integer , intent ( in ) :: src integer , intent ( in ), optional :: tag integer , intent ( out ) :: request integer :: ierror integer :: tagp tagp = 0 if ( present ( tag )) tagp = tag call mpi_irecv ( z , size ( z ), mpicmplx , src , tagp , mp_comm , & request , ierror ) end subroutine nonblocking_receive_complex_array subroutine receive_logical ( f , src , tag ) implicit none logical , intent ( out ) :: f integer , intent ( in ) :: src integer , intent ( in ), optional :: tag integer :: ierror integer :: tagp integer , dimension ( MPI_STATUS_SIZE ) :: status tagp = 0 if ( present ( tag )) tagp = tag call mpi_recv ( f , 1 , MPI_LOGICAL , src , tagp , mp_comm , & status , ierror ) end subroutine receive_logical subroutine receive_logical_array ( f , src , tag ) implicit none logical , dimension (:), intent ( out ) :: f integer , intent ( in ) :: src integer , intent ( in ), optional :: tag integer :: ierror integer :: tagp integer , dimension ( MPI_STATUS_SIZE ) :: status tagp = 0 if ( present ( tag )) tagp = tag call mpi_recv ( f , size ( f ), MPI_LOGICAL , src , tagp , mp_comm , & status , ierror ) end subroutine receive_logical_array subroutine receive_character ( s , src , tag ) implicit none character ( * ), intent ( out ) :: s integer , intent ( in ) :: src integer , intent ( in ), optional :: tag integer :: ierror integer :: tagp integer , dimension ( MPI_STATUS_SIZE ) :: status tagp = 0 if ( present ( tag )) tagp = tag call mpi_recv ( s , len ( s ), MPI_CHARACTER , src , tagp , mp_comm , & status , ierror ) end subroutine receive_character subroutine waitany ( count , requests , requestindex , status ) implicit none integer , intent ( in ) :: count integer , dimension (:), intent ( inout ) :: requests integer , intent ( out ) :: requestindex integer , dimension ( MPI_STATUS_SIZE ), intent ( out ) :: status integer :: ierror call mpi_waitany ( count , requests , requestindex , status , ierror ) end subroutine waitany subroutine all_to_group_real ( all , group , njobs ) implicit none real , dimension (:), intent ( in ) :: all real , intent ( out ) :: group integer , intent ( in ) :: njobs integer :: ik , tag , idx tag = 1000 !    do ik = 0, njobs-1 !       if (proc0) then !          if (iproc == grp0(ik)) then !             group = all(ik+1) !          else !             call ssend (all(ik+1), grp0(ik), tag) !          end if !       else if (iproc == grp0(ik)) then !          call receive (group, 0, tag) !       end if !!       call barrier !    end do do ik = 0 , njobs - 1 if ( proc0 ) then idx = mod ( ik , size ( all )) if ( iproc == grp0 ( ik )) then group = all ( idx + 1 ) else call ssend ( all ( idx + 1 ), grp0 ( ik ), tag ) end if else if ( iproc == grp0 ( ik )) then call receive ( group , 0 , tag ) end if !       call barrier end do end subroutine all_to_group_real subroutine all_to_group_real_array ( all , group , njobs ) implicit none real , dimension (:, :), intent ( in ) :: all real , dimension (:), intent ( out ) :: group integer , intent ( in ) :: njobs integer :: ik , tag , idx tag = 1001 !    do ik = 0, njobs-1 !       if (proc0) then !          if (iproc == grp0(ik)) then !             group = all(ik+1,:) !          else !             call ssend (all(ik+1,:), grp0(ik), tag) !          end if !       else if (iproc == grp0(ik)) then !          call receive (group, 0, tag) !       end if !!       call barrier !    end do do ik = 0 , njobs - 1 if ( proc0 ) then idx = mod ( ik , size ( all , dim = 1 )) if ( iproc == grp0 ( ik )) then group = all ( idx + 1 , :) else call ssend ( all ( idx + 1 , :), grp0 ( ik ), tag ) end if else if ( iproc == grp0 ( ik )) then call receive ( group , 0 , tag ) end if !       call barrier end do end subroutine all_to_group_real_array subroutine group_to_all_real ( group , all , njobs ) implicit none real , intent ( in ) :: group real , dimension (:), intent ( out ) :: all integer , intent ( in ) :: njobs integer :: ik , tag , idx tag = 1002 do ik = 0 , njobs - 1 if ( iproc == grp0 ( ik )) then if (. not . proc0 ) then call ssend ( group , 0 , tag ) else idx = mod ( ik , size ( all )) all ( idx + 1 ) = group end if else if ( proc0 ) then idx = mod ( ik , size ( all )) call receive ( all ( idx + 1 ), grp0 ( ik ), tag ) end if !       call barrier end do end subroutine group_to_all_real subroutine group_to_all_real_array ( group , all , njobs ) implicit none real , dimension (:), intent ( in ) :: group real , dimension (:, :), intent ( out ) :: all integer , intent ( in ) :: njobs integer :: ik , tag , idx tag = 1003 do ik = 0 , njobs - 1 if ( iproc == grp0 ( ik )) then if (. not . proc0 ) then call ssend ( group , 0 , tag ) else idx = mod ( ik , size ( all )) all ( idx + 1 , :) = group end if else if ( proc0 ) then idx = mod ( ik , size ( all )) call receive ( all ( idx + 1 , :), grp0 ( ik ), tag ) end if !       call barrier end do end subroutine group_to_all_real_array subroutine mp_abort ( msg ) use file_utils , only : error_unit , flush_output_file implicit none character ( len =* ), intent ( in ) :: msg integer :: ierror integer , parameter :: error_code = MPI_ERR_UNKNOWN if ( proc0 ) then write ( error_unit (), * ) \"Error: \" // msg call flush_output_file ( error_unit ()) end if call mpi_abort ( comm_all , error_code , ierror ) end subroutine mp_abort ! this gathers a single integer from each processor into an array on proc0 subroutine mp_gather ( senddata , recvarray ) implicit none integer , intent ( in ) :: senddata integer , dimension (:), intent ( out ) :: recvarray integer :: ierr call mpi_gather ( senddata , 1 , mpi_integer , recvarray , & 1 , mpi_integer , 0 , mp_comm , ierr ) end subroutine mp_gather subroutine broadcast_with_comm ( x , comm ) implicit none real , dimension (:), intent ( in out ) :: x integer , intent ( in ) :: comm integer :: ierror call mpi_bcast ( x , size ( x ), mpireal , 0 , comm , ierror ) end subroutine broadcast_with_comm end module mp","tags":"","loc":"sourcefile/mp.fpp.html"},{"title":"fields_arrays.f90 – stella","text":"Source Code module fields_arrays use mpi use common_types , only : response_matrix_type , eigen_type implicit none complex , dimension (:, :, :, :), allocatable :: phi , phi_old complex , dimension (:, :, :, :), allocatable :: apar , apar_old complex , dimension (:, :, :, :), allocatable :: bpar , bpar_old ! (naky, nakx, -nzgrid:nzgrid, ntubes) ! DSO 0 the following is a band-aid for radially global simulations until ! we more fully incorporate shared memory complex , dimension (:, :, :, :), pointer :: phi_shared ! (naky, nakx, -nzgrid:nzgrid, ntubes) ! radial corrections to phi and apar from quasineutrality/whatever controls apar complex , dimension (:, :, :, :), allocatable :: phi_corr_QN , apar_corr_QN ! (naky, nakx, -nzgrid:nzgrid, ntubes) ! needed to implement time-delayed source when using projection method complex , dimension (:, :, :), allocatable :: phi_proj , phi_proj_stage ! (nakx, -nzgrid:nzgrid, ntubes) ! radial corrections to phi and apar from gyroaveraging ! may result in tight space constraints however complex , dimension (:, :, :, :, :), allocatable :: phi_corr_GA , apar_corr_GA ! (naky, nakx, -nzgrid:nzgrid, ntubes, -vmu-layout-) type ( response_matrix_type ), dimension (:), allocatable :: response_matrix integer :: response_window = MPI_WIN_NULL real , dimension (:), allocatable :: shift_state real , dimension (:, :, :), allocatable :: gamtot , dgamtotdr real , dimension (:, :, :), allocatable :: gamtot13 , gamtot31 , gamtot33 real , dimension (:, :, :), allocatable :: gamtotinv11 , gamtotinv13 , gamtotinv31 , gamtotinv33 real , dimension (:, :), allocatable :: gamtot3 !real :: gamtot_h, gamtot3_h, efac, efacp complex , dimension (:, :, :), allocatable :: theta ! (nakx, nakx, -nzgrid:nzgrid) complex , dimension (:, :), allocatable :: c_mat ! (nakx, nakx) complex , dimension (:), pointer :: phi_ext => null () ! (nakx*nztot) type ( eigen_type ), dimension (:, :), allocatable :: phi_solve type ( eigen_type ) :: phizf_solve !variables needed for the source logical :: exclude_boundary_regions_qn real :: tcorr_source_qn , exp_fac_qn integer :: qn_window = MPI_WIN_NULL , qn_zf_window = MPI_WIN_NULL end module fields_arrays","tags":"","loc":"sourcefile/fields_arrays.f90.html"},{"title":"gauss_quad.f90 – stella","text":"Source Code module gauss_quad ! <doc> !  Utilities for Gaussian quadrature. !  This module provides subroutines to obtain zeros and weights of !  Gauss-Legendre and Gauss-Laguerre quadrature rules. ! </doc> implicit none public :: get_legendre_grids_from_cheb public :: get_laguerre_grids private logical :: debug = . false . logical :: weight_roundoff_correction = . false . integer , parameter :: qp = selected_real_kind ( 33 , 4931 ) contains subroutine get_legendre_grids_from_cheb ( x1 , x2 , zero , wgt ) ! <doc> !  returns Legendre zeros and weights in the given interval [x1,x2]. !  The order is determined from the size of the array 'zero'. ! </doc> use constants , only : pi => dpi real , intent ( in ) :: x1 , x2 real , dimension (:), intent ( out ) :: zero , wgt integer :: i , nn , nh double precision :: xold , xnew , pold , pnew double precision , dimension (:), allocatable :: zz , ww nn = size ( zero ) nh = ( nn + 1 ) / 2 allocate ( zz ( nh )) allocate ( ww ( nh )) ! search zero from 1 to 0 using chebyshev grid points ! this is O(nn&#94;2) operations xold = cos ( pi / ( 2 * ( nn + 1 ))) pold = legendre_p ( nn , xold ) do i = 1 , nh xnew = cos ( pi * ( 2 * i + 1 ) / ( 2 * ( nn + 1 ))) pnew = legendre_p ( nn , xnew ) call find_zero_bisect_newton ( nn , xold , xnew , pold , pnew , zz ( i )) xold = xnew pold = pnew end do ! invert them to give zeros in (-1,0] zz ( 1 : nn / 2 ) = - zz ( 1 : nn / 2 ) ! weight from formula !    ww = dble(2.0) / (dble(1.0) - zz**2) / legendre_pp(nn,zz,dble(0.0))**2 ww = dble ( 2.0 ) / ( dble ( 1.0 ) - zz ** 2 ) / legendre_pp ( nn , zz ) ** 2 ! rescale (x2 may be smaller than x1) zero ( 1 : nh ) = real ( zz * ( x2 - x1 ) + ( x1 + x2 )) / 2.0 zero ( nh + 1 : nn ) = real ( zz ( nn / 2 : 1 : - 1 ) * ( x1 - x2 ) + ( x1 + x2 )) / 2.0 wgt ( 1 : nh ) = real ( ww * abs ( x2 - x1 ) / 2.0 ) wgt ( nh + 1 : nn ) = wgt ( nn / 2 : 1 : - 1 ) deallocate ( zz ) deallocate ( ww ) ! roundoff correction !!$    if (abs(sum(wgt)/abs(x2-x1)) - 1.0 > epsilon(wgt)) then !!$       print *, 'roundoff correction occurred' if ( weight_roundoff_correction ) then if ( mod ( nn , 2 ) == 0 ) then wgt ( nh ) = abs ( x2 - x1 ) / 2.0 - sum ( wgt ( 1 : nh - 1 )) wgt ( nh + 1 ) = wgt ( nh ) else wgt ( nh ) = abs ( x2 - x1 ) - sum ( wgt ( 1 : nh - 1 )) * 2.0 end if end if call check_legendre_zero ( x1 , x2 , zero ) call check_legendre_weights ( abs ( x2 - x1 ), wgt ) if ( debug ) then print * , 'get_legendre_grids_from_cheb: sum of weights = ' , sum ( wgt ) print * , 'get_legendre_grids_from_cheb: section length = ' , abs ( x2 - x1 ) end if end subroutine get_legendre_grids_from_cheb subroutine find_zero_bisect_newton ( n , xold , xnew , pold , pnew , zz ) use file_utils , only : error_unit integer , intent ( in ) :: n double precision , intent ( in ) :: xold , xnew , pold , pnew !    real, intent (in) :: eps double precision , intent ( out ) :: zz integer :: i , maxit = 100 real :: eps double precision :: x1 , x2 , p1 , p2 , pz ! <doc> !  eps is declared as real on purpose. !  We don't require higher order precision for convergence test !  because of a performance reason. The following definition means !  eps is a geometric mean of the machine-epsilons in real and double !  precisions. !  (note that real/double are promoted to double/double or double/quad !  depending on the compiler.) ! !  [same applies to eps in find_zero below.] ! </doc> eps = sqrt ( epsilon ( eps ) * epsilon ( x1 )) * 2.0 i = 0 x1 = xold x2 = xnew p1 = pold p2 = pnew if ( debug ) write ( * , '(4f10.5)' ) x1 , p1 , x2 , p2 ! bisection do i = 1 , 5 zz = ( x1 + x2 ) * dble (. 5 ) pz = legendre_p ( n , zz ) if ( abs ( pz ) <= epsilon ( pz )) return if ( pz * p1 < 0.0 ) then p2 = pz ; x2 = zz else p1 = pz ; x1 = zz end if if ( debug ) write ( * , '(4f10.5)' ) x1 , p1 , x2 , p2 end do if ( debug ) print * , 'finished bisection' ! newton-raphson if ( zz == x1 ) x1 = x2 !    do while (abs(zz/x1-1.0) > eps) do i = 1 , maxit x1 = zz p1 = legendre_p ( n , x1 ) !       zz = x1 - p1 / legendre_pp(n,x1,p1) zz = x1 - p1 / legendre_pp ( n , x1 ) pz = legendre_p ( n , zz ) if ( debug ) write ( * , '(4f10.5)' ) zz , pz , x1 , p1 if ( min ( abs ( zz / x1 - 1.0 ), abs ( pz )) < eps ) exit end do if ( i == maxit + 1 ) write ( error_unit (), * ) & & 'WARNING: too many iterations in get_legendre_grids' if ( debug ) stop end subroutine find_zero_bisect_newton elemental function legendre_p ( n , x ) integer , intent ( in ) :: n double precision , intent ( in ) :: x integer :: k double precision :: p , p1 , p2 , legendre_p select case ( n ) case ( 0 ) legendre_p = dble ( 1.0 ) case ( 1 ) legendre_p = x case default p1 = x p2 = dble ( 1.0 ) do k = 2 , n p = (( 2 * k - 1 ) * x * p1 - ( k - 1 ) * p2 ) / k p2 = p1 p1 = p end do legendre_p = p end select end function legendre_p !  elemental function legendre_pp (n, x, p1) elemental function legendre_pp ( n , x ) integer , intent ( in ) :: n double precision , intent ( in ) :: x !    double precision, intent (in), optional :: p1 double precision :: legendre_pp !    if (present(p1)) then !       legendre_pp = n * ( x * p1 - legendre_p(n-1,x) ) & !            / (x**2 - dble(1.0)) !    else legendre_pp = n * ( x * legendre_p ( n , x ) - legendre_p ( n - 1 , x )) & / ( x ** 2 - dble ( 1.0 )) !    end if end function legendre_pp subroutine check_legendre_zero ( x0 , x1 , zero ) use mp , only : mp_abort use file_utils , only : error_unit real , intent ( in ) :: x0 , x1 real , dimension (:), intent ( in ) :: zero logical :: error = . false . integer :: nn , nh real :: xx , xmin , xmax real , dimension (:), allocatable :: zz nn = size ( zero ) nh = ( nn + 1 ) / 2 error = . false . xmin = min ( x0 , x1 ) xmax = max ( x0 , x1 ) allocate ( zz ( nn )) zz = zero if ( zz ( 1 ) > zz ( nn )) zz ( 1 : nn ) = zero ( nn : 1 : - 1 ) if ( zz ( 1 ) < xmin . or . zz ( nn ) > xmax ) then write ( error_unit (), * ) 'ERROR in legendre: grid out of range' error = . true . end if if ( nn == 1 ) then if ( abs ( 2.0 * zz ( 1 ) / ( xmin + xmax ) - 1.0 ) > epsilon ( 0.0 )) then write ( error_unit (), '(\"ERROR in legendre: zz(1)= \", f20.15)' ) zz ( 1 ) error = . true . end if else ! check if distances at the edge: This suffices for nn<=3 if ( zz ( 2 ) - zz ( 1 ) <= zz ( 1 ) - xmin . or . zz ( nn ) - zz ( nn - 1 ) <= xmax - zz ( nn )) then write ( error_unit (), * ) 'ERROR in legendre: wrong distance at edge' error = . true . end if ! check distances at the center: The above and this suffices for nn=4 if ( mod ( nn , 2 ) == 0 . and . nn >= 4 ) then if ( zz ( nh + 1 ) - zz ( nh ) <= zz ( nh ) - zz ( nh - 1 ) . or . & zz ( nh + 1 ) - zz ( nh ) <= zz ( nh + 2 ) - zz ( nh + 1 )) then write ( error_unit (), * ) & & 'ERROR in legendre: wrong distance at center' error = . true . end if end if if ( nn >= 5 ) then ! check if distances are increasing toward center ! lower half if ( any ( zz ( 3 : nh ) - zz ( 2 : nh - 1 ) <= zz ( 2 : nh - 1 ) - zz ( 1 : nh - 2 ))) then write ( error_unit (), * ) 'ERROR in legendre: distance decreasing toward center' error = . true . end if ! upper half ! The separate use of nh and nn/2 are intentionally so that they ! both work for even and odd cases if ( any ( zz ( nn / 2 + 2 : nn - 1 ) - zz ( nn / 2 + 1 : nn - 2 ) & & <= zz ( nn / 2 + 3 : nn ) - zz ( nn / 2 + 2 : nn - 1 ))) then write ( error_unit (), * ) 'ERROR in legendre: distance decreasing toward center' error = . true . end if end if end if ! check if legendre_p(n, zero(i)) are close enough to zero if ( debug ) then xx = maxval ( abs ( real ( legendre_p ( nn , & dble (( zz (:) - xmin ) / ( xmax - xmin ) * 2.0 - 1.0 ))))) if ( xx / nn ** 2 > epsilon ( xx )) then write ( error_unit (), * ) 'WARNING in legendre: maxval(n,zz(:))= ' , xx ! Do not stop as it is mostly a minor issue end if end if if ( error ) call mp_abort ( 'STOP in check_legendre_zero' ) end subroutine check_legendre_zero !  subroutine check_legendre_weights (norm, wgt, eps) subroutine check_legendre_weights ( norm , wgt ) use mp , only : mp_abort use file_utils , only : error_unit real , intent ( in ) :: norm !, eps real , dimension (:), intent ( in ) :: wgt logical :: error = . false . integer :: n , nh real :: s n = size ( wgt ) error = . false . nh = ( n + 1 ) / 2 ! check if weights are all positive if ( any ( wgt < 0. )) then write ( error_unit (), * ) 'ERROR in legendre: weights got negative' error = . true . end if if ( n >= 2 ) then ! check symmetry of weights if ( any ( abs ( wgt ( n : n + 1 - n / 2 : - 1 ) / wgt ( 1 : n / 2 ) - 1.0 ) > epsilon ( wgt ))) then write ( error_unit (), * ) 'WARNING in legendre: symmetry of weights broken' error = . true . end if ! check if weights are increasing toward center if ( n >= 3 ) then if ( any ( wgt ( 2 : nh ) <= wgt ( 1 : nh - 1 ))) then write ( error_unit (), * ) 'ERROR in legendre: weights decreasing toward center' error = . true . end if end if end if ! check if their sum is close enough to normalized value if ( debug ) then !       s = sum(wgt) s = sum ( dble ( wgt )) ! ignore roundoff error arising from 8-byte summation if ( abs ( norm / s - 1.0 ) > epsilon ( s )) then write ( error_unit (), * ) 'WARNING in legendre: weights summation incorrect:' , & & size ( wgt ), s / norm - 1.0 ! Do not stop as it is mostly a minor issue end if end if if ( error ) call mp_abort ( 'STOP in check_legendre_weights' ) end subroutine check_legendre_weights subroutine get_laguerre_grids ( zero , wgt ) ! <doc> !  returns Laguerre zeros and weights. !  The order is determined from the size of the array 'zero'. ! </doc> use mp , only : mp_abort use file_utils , only : error_unit real , dimension (:), intent ( out ) :: zero real , dimension (:), intent ( out ) :: wgt logical :: error = . false . integer :: i , j , n , nzero real ( kind = qp ) :: x , delx , pold , pnew !double precision, dimension (:), allocatable :: zz real ( kind = qp ), dimension (:), allocatable :: zz double precision :: eps n = size ( zero ) allocate ( zz ( n )) zz = 0.0 eps = epsilon ( zero ( 1 )) * dble ( 4.0 ) if ( n > 180 ) then write ( error_unit (), * ) 'ERROR: can''t get so many laguerre grid points' write ( error_unit (), * ) 'ERROR: size(zero)= ' , n error = . true . end if ! search zero from 0 to xmax using evenly spaced grid points if ( n == 1 ) then zero ( 1 ) = 1.0 wgt ( 1 ) = 1.0 return else nzero = 0 pold = real ( laguerre_l ( n , real ( 0.0 , qp )), qp ) delx = 0.001 do i = 1 , 1000 ! up to x=1 x = delx * i !          print*, x pnew = real ( laguerre_l ( n , x ), qp ) !          if (pold*pnew < epsilon(0.0)) then if ( pold * pnew < 0.0 ) then nzero = nzero + 1 call find_zero ( n , eps , x - delx , x , pold , pnew , zz ( nzero )) end if pold = pnew end do do j = 0 , 3 delx = delx * 1 0. do i = 1 , 900 x = delx * ( i + 100 ) !             print*, x pnew = laguerre_l ( n , x ) if ( pold * pnew < 0.0 ) then nzero = nzero + 1 call find_zero ( n , eps , x - delx , x , pold , pnew , zz ( nzero )) end if if ( nzero == n ) exit pold = pnew end do if ( nzero == n ) exit end do end if zero = real ( zz , kind ( zero ( 1 ))) wgt = real ( zz / ( n + 1 ) ** 2 / laguerre_l ( n + 1 , zz ) ** 2 , kind ( wgt ( 1 ))) deallocate ( zz ) ! roundoff correction if ( weight_roundoff_correction ) then i = sum ( maxloc ( wgt )) wgt ( i ) = 1.0 - sum ( wgt ( 1 : i - 1 )) - sum ( wgt ( i + 1 : n )) end if ! check number of found zeros if ( nzero < n ) then write ( error_unit (), * ) 'ERROR in laguerre: didn''t find all zeros' do i = 1 , n write ( error_unit (), * ) i , zero ( i ) end do stop end if call check_laguerre_zeros ( zero ) call check_laguerre_weights ( wgt , eps = 1.0e-7 ) if ( error ) call mp_abort ( 'STOP in get_laguerre_grids' ) end subroutine get_laguerre_grids subroutine find_zero ( n , eps , xold , xnew , pold , pnew , zz ) use file_utils , only : error_unit integer , intent ( in ) :: n double precision , intent ( in ) :: eps real ( kind = qp ), intent ( in ) :: xold , xnew , pold , pnew !double precision, intent (out) :: zz real ( kind = qp ), intent ( out ) :: zz integer :: i , maxit = 100 real ( kind = qp ) :: x1 , x2 , p1 , p2 , pz ! <doc> !  eps is declared as real on purpose. !  [see comment in find_zero_bisect_newton above.] ! </doc> x1 = xold x2 = xnew p1 = pold p2 = pnew if ( debug ) write ( * , '(a,4es15.5e3)' ) 'initial ' , x1 , p1 , x2 , p2 ! bisection do i = 1 , maxit zz = ( x1 + x2 ) * 0.5 pz = laguerre_l ( n , zz ) if ( abs ( pz ) <= eps ) return if ( pz * p1 < 0. ) then p2 = pz ; x2 = zz else p1 = pz ; x1 = zz end if if ( debug ) write ( * , '(a,6es25.15e3)' ) 'bisection ' , x1 , p1 , x2 , p2 , pz , eps end do if ( i == maxit + 1 ) then ! newton-raphson if ( zz == x1 ) x1 = x2 do i = 1 , maxit x1 = zz p1 = dble ( laguerre_l ( n , x1 )) zz = x1 - p1 / dble ( laguerre_lp ( n , x1 )) pz = dble ( laguerre_l ( n , zz )) if ( debug ) write ( * , '(a,5es25.15e3)' ) & 'newton ' , zz , pz , x1 , p1 , eps if ( min ( abs ( zz / x1 - dble ( 1.0 )), abs ( pz )) < eps ) exit end do if ( i == maxit + 1 ) then write ( error_unit (), * ) & & 'WARNING: too many iterations in get_laguerre_grids' stop 11 end if end if end subroutine find_zero elemental function laguerre_l ( n , x ) integer , intent ( in ) :: n real ( kind = qp ), intent ( in ) :: x integer :: k !    double precision :: laguerre_l, p, p1, p2 real ( kind = qp ) :: laguerre_l , p , p1 , p2 p1 = dble ( 1.0 ) - x p2 = dble ( 1.0 ) if ( n == 0 ) then laguerre_l = p2 return else if ( n == 1 ) then laguerre_l = p1 return end if do k = 2 , n p = (( dble ( 2.0 ) * k - dble ( 1.0 ) - x ) * p1 - ( k - dble ( 1.0 )) * p2 ) / k p2 = p1 p1 = p end do laguerre_l = p end function laguerre_l elemental function laguerre_lp ( n , x ) integer , intent ( in ) :: n real ( kind = qp ), intent ( in ) :: x real ( kind = qp ) :: laguerre_lp laguerre_lp = n * ( laguerre_l ( n , x ) - laguerre_l ( n - 1 , x )) / x end function laguerre_lp subroutine check_laguerre_zeros ( zero ) use file_utils , only : error_unit use mp , only : mp_abort real , dimension (:), intent ( in ) :: zero logical :: error = . false . integer :: i , n n = size ( zero ) ! check positiveness if ( any ( zero <= 0.0 )) then write ( error_unit (), * ) 'ERROR in laguerre: grid not positive' error = . true . end if ! check alignment if ( any ( zero ( 2 : n ) - zero ( 1 : n - 1 ) < 0.0 )) then write ( error_unit (), * ) 'ERROR in laguerre: wrong alignment' error = . true . end if ! check distances are increasing do i = 1 , n - 2 if ( zero ( i + 1 ) - zero ( i ) > zero ( i + 2 ) - zero ( i + 1 )) then write ( error_unit (), * ) 'ERROR in laguerre: distances are decreasing at i= ' , i error = . true . end if end do if ( error ) call mp_abort ( 'STOP in check_laguerre_zeros' ) end subroutine check_laguerre_zeros subroutine check_laguerre_weights ( wgt , eps ) use file_utils , only : error_unit use mp , only : mp_abort real , intent ( in ) :: eps real , dimension (:), intent ( in ) :: wgt logical :: error = . false . integer :: imax , n real :: s n = size ( wgt ) ! check if weights are all positive if ( any ( wgt <= 0.0 )) then write ( error_unit (), * ) 'ERROR in laguerre: weights are not positive at n =' , n error = . true . end if ! check if there is a single maximum imax = sum ( maxloc ( wgt )) if ( any ( wgt ( 1 : imax - 1 ) > wgt ( 2 : imax ))) then write ( error_unit (), * ) 'ERROR in laguerre: weights decreasing before maximum' error = . true . end if if ( any ( wgt ( imax : n - 1 ) < wgt ( imax + 1 : n ))) then write ( error_unit (), * ) 'ERROR in laguerre: weights increasing after maximum' error = . true . end if ! check if their sum is close enough to normalized value if ( debug ) then s = sum ( dble ( wgt )) if ( abs ( s - 1.0 ) > eps ) then write ( error_unit (), * ) 'WARNING in laguerre: weights summation incorrect:' , & size ( wgt ), s ! Do not stop as it is mostly a minor issue end if end if if ( error ) call mp_abort ( 'STOP error in check_laguerre_weights' ) end subroutine check_laguerre_weights end module gauss_quad","tags":"","loc":"sourcefile/gauss_quad.f90.html"},{"title":"stel_kinds.f – stella","text":"Source Code MODULE stel_kinds !---------------------------------------------------------------------- !  Kind specifications !---------------------------------------------------------------------- INTEGER , PARAMETER :: rprec = SELECTED_REAL_KIND ( 12 , 100 ) !      INTEGER, PARAMETER :: rprec = SELECTED_REAL_KIND(15,307) INTEGER , PARAMETER :: iprec = SELECTED_INT_KIND ( 8 ) INTEGER , PARAMETER :: cprec = KIND (( 1.0_rprec , 1.0_rprec )) INTEGER , PARAMETER :: dp = rprec END MODULE stel_kinds","tags":"","loc":"sourcefile/stel_kinds.f.html"},{"title":"common_types.f90 – stella","text":"Source Code module common_types implicit none type :: kxkyz_layout_type sequence integer :: iproc integer :: nzgrid , nzed , ntubes , naky , nakx , nvgrid , nvpa , nmu , nspec integer :: llim_world , ulim_world , llim_proc , ulim_proc , ulim_alloc , blocksize end type kxkyz_layout_type type :: kxyz_layout_type sequence integer :: iproc integer :: nzgrid , nzed , ntubes , ny , naky , nakx , ikx_max , nvgrid , nvpa , nmu , nspec integer :: llim_world , ulim_world , llim_proc , ulim_proc , ulim_alloc , blocksize end type kxyz_layout_type type :: xyz_layout_type sequence integer :: iproc integer :: nzgrid , nzed , ntubes , ny , naky , nx , nakx , nvgrid , nvpa , nmu , nspec integer :: llim_world , ulim_world , llim_proc , ulim_proc , ulim_alloc , blocksize end type xyz_layout_type type :: vmu_layout_type sequence logical :: xyz integer :: iproc integer :: nzgrid , nzed , ntubes , nalpha , ny , naky , nx , nakx , nvgrid , nvpa , nmu , nspec integer :: llim_world , ulim_world , llim_proc , ulim_proc , ulim_alloc , blocksize end type vmu_layout_type type :: flux_surface_type real :: rmaj real :: rgeo real :: kappa real :: kapprim real :: tri real :: triprim real :: rhoc real :: dr real :: shift real :: qinp real :: shat real :: betaprim real :: betadbprim real :: d2qdr2 real :: d2psidr2 real :: dpsitordrho real :: d2psitordrho2 real :: rhotor real :: drhotordrho real :: psitor_lcfs real :: zed0_fac real :: rhoc_psi0 real :: qinp_psi0 real :: shat_psi0 end type flux_surface_type type spec_type integer :: nspec real :: z real :: mass real :: dens , temp real :: tprim , fprim real :: vnew_ref real :: stm , zstm , tz , smz , zt real :: d2ndr2 , d2Tdr2 real :: bess_fac ! 0 for argument of Bessel Functions equal to 0 ! pre-2003 Fortran does not support ! allocatable arrays within derived types ! so set size large enough that it should be a problem ! should be nspec large real , dimension ( 10 ) :: vnew integer :: type !the next few variables are for multibox simulations real :: dens_psi0 , temp_psi0 real :: stm_psi0 , zstm_psi0 , tz_psi0 , smz_psi0 , zt_psi0 end type spec_type type :: eigen_type complex , dimension (:, :), pointer :: zloc => null () integer , dimension (:), pointer :: idx => null () end type eigen_type type :: response_matrix_type type ( eigen_type ), dimension (:), pointer :: eigen => null () end type response_matrix_type type coupled_alpha_type integer :: max_idx complex , dimension (:), pointer :: fourier => null () end type coupled_alpha_type type gam0_ffs_type integer , dimension (:), pointer :: pivot_index => null () complex , dimension (:, :), pointer :: matrix => null () end type gam0_ffs_type end module common_types","tags":"","loc":"sourcefile/common_types.f90.html"},{"title":"dist_redistribute.f90 – stella","text":"Source Code module dist_redistribute use redistribute , only : redist_type implicit none public :: init_redistribute , finish_redistribute public :: kxkyz2vmu public :: kxyz2vmu public :: xyz2vmu private type ( redist_type ) :: kxkyz2vmu type ( redist_type ) :: kxyz2vmu type ( redist_type ) :: xyz2vmu logical :: redistribute_initialized = . false . contains subroutine init_redistribute use physics_flags , only : full_flux_surface use physics_flags , only : include_parallel_nonlinearity implicit none if ( redistribute_initialized ) return redistribute_initialized = . true . call init_kxkyz_to_vmu_redistribute if ( full_flux_surface ) call init_kxyz_to_vmu_redistribute if ( include_parallel_nonlinearity ) call init_xyz_to_vmu_redistribute end subroutine init_redistribute subroutine init_kxkyz_to_vmu_redistribute use mp , only : nproc use stella_layouts , only : kxkyz_lo , vmu_lo use stella_layouts , only : kxkyzidx2vmuidx use stella_layouts , only : idx_local , proc_id use redistribute , only : index_list_type , init_redist use redistribute , only : delete_list , set_redist_character_type use vpamu_grids , only : nvpa , nmu use zgrid , only : nzgrid implicit none type ( index_list_type ), dimension ( 0 : nproc - 1 ) :: to_list , from_list integer , dimension ( 0 : nproc - 1 ) :: nn_to , nn_from integer , dimension ( 3 ) :: from_low , from_high integer , dimension ( 5 ) :: to_high , to_low integer :: ikxkyz , ivmu integer :: iv , imu , iky , ikx , iz , it integer :: ip , n logical :: initialized = . false . if ( initialized ) return initialized = . true . ! count number of elements to be redistributed to/from each processor nn_to = 0 nn_from = 0 do ikxkyz = kxkyz_lo % llim_world , kxkyz_lo % ulim_world do imu = 1 , nmu do iv = 1 , nvpa call kxkyzidx2vmuidx ( iv , imu , ikxkyz , kxkyz_lo , vmu_lo , iky , ikx , iz , it , ivmu ) if ( idx_local ( kxkyz_lo , ikxkyz )) & nn_from ( proc_id ( vmu_lo , ivmu )) = nn_from ( proc_id ( vmu_lo , ivmu )) + 1 if ( idx_local ( vmu_lo , ivmu )) & nn_to ( proc_id ( kxkyz_lo , ikxkyz )) = nn_to ( proc_id ( kxkyz_lo , ikxkyz )) + 1 end do end do end do do ip = 0 , nproc - 1 if ( nn_from ( ip ) > 0 ) then allocate ( from_list ( ip )% first ( nn_from ( ip ))) allocate ( from_list ( ip )% second ( nn_from ( ip ))) allocate ( from_list ( ip )% third ( nn_from ( ip ))) end if if ( nn_to ( ip ) > 0 ) then allocate ( to_list ( ip )% first ( nn_to ( ip ))) allocate ( to_list ( ip )% second ( nn_to ( ip ))) allocate ( to_list ( ip )% third ( nn_to ( ip ))) allocate ( to_list ( ip )% fourth ( nn_to ( ip ))) allocate ( to_list ( ip )% fifth ( nn_to ( ip ))) end if end do ! get local indices of elements distributed to/from other processors nn_to = 0 nn_from = 0 ! loop over all vmu indices, find corresponding y indices do ikxkyz = kxkyz_lo % llim_world , kxkyz_lo % ulim_world do imu = 1 , nmu do iv = 1 , nvpa ! obtain corresponding y indices call kxkyzidx2vmuidx ( iv , imu , ikxkyz , kxkyz_lo , vmu_lo , iky , ikx , iz , it , ivmu ) ! if vmu index local, set: ! ip = corresponding y processor ! from_list%first-third arrays = iv,imu,ikxkyz  (ie vmu indices) ! later will send from_list to proc ip if ( idx_local ( kxkyz_lo , ikxkyz )) then ip = proc_id ( vmu_lo , ivmu ) n = nn_from ( ip ) + 1 nn_from ( ip ) = n from_list ( ip )% first ( n ) = iv from_list ( ip )% second ( n ) = imu from_list ( ip )% third ( n ) = ikxkyz end if ! if y index local, set ip to corresponding vmu processor ! set to_list%first,second arrays = iky,iy  (ie y indices) ! will receive to_list from ip if ( idx_local ( vmu_lo , ivmu )) then ip = proc_id ( kxkyz_lo , ikxkyz ) n = nn_to ( ip ) + 1 nn_to ( ip ) = n to_list ( ip )% first ( n ) = iky to_list ( ip )% second ( n ) = ikx to_list ( ip )% third ( n ) = iz to_list ( ip )% fourth ( n ) = it to_list ( ip )% fifth ( n ) = ivmu end if end do end do end do from_low ( 1 ) = 1 from_low ( 2 ) = 1 from_low ( 3 ) = kxkyz_lo % llim_proc from_high ( 1 ) = nvpa from_high ( 2 ) = nmu from_high ( 3 ) = kxkyz_lo % ulim_alloc to_low ( 1 ) = 1 to_low ( 2 ) = 1 to_low ( 3 ) = - nzgrid to_low ( 4 ) = 1 to_low ( 5 ) = vmu_lo % llim_proc to_high ( 1 ) = vmu_lo % naky to_high ( 2 ) = vmu_lo % nakx to_high ( 3 ) = vmu_lo % nzed to_high ( 4 ) = vmu_lo % ntubes to_high ( 5 ) = vmu_lo % ulim_alloc call set_redist_character_type ( kxkyz2vmu , 'kxkyz2vmu' ) call init_redist ( kxkyz2vmu , 'c' , to_low , to_high , to_list , & from_low , from_high , from_list ) call delete_list ( to_list ) call delete_list ( from_list ) end subroutine init_kxkyz_to_vmu_redistribute subroutine init_kxyz_to_vmu_redistribute use mp , only : nproc use stella_layouts , only : kxyz_lo , vmu_lo use stella_layouts , only : kxyzidx2vmuidx use stella_layouts , only : idx_local , proc_id use redistribute , only : index_list_type , init_redist use redistribute , only : delete_list , set_redist_character_type use vpamu_grids , only : nvpa , nmu use zgrid , only : nzgrid implicit none type ( index_list_type ), dimension ( 0 : nproc - 1 ) :: to_list , from_list integer , dimension ( 0 : nproc - 1 ) :: nn_to , nn_from integer , dimension ( 3 ) :: from_low , from_high integer , dimension ( 5 ) :: to_high , to_low integer :: ikxyz , ivmu integer :: iv , imu , iy , ikx , iz , it integer :: ip , n logical :: initialized = . false . if ( initialized ) return initialized = . true . ! count number of elements to be redistributed to/from each processor nn_to = 0 nn_from = 0 do ikxyz = kxyz_lo % llim_world , kxyz_lo % ulim_world do imu = 1 , nmu do iv = 1 , nvpa call kxyzidx2vmuidx ( iv , imu , ikxyz , kxyz_lo , vmu_lo , iy , ikx , iz , it , ivmu ) if ( idx_local ( kxyz_lo , ikxyz )) & nn_from ( proc_id ( vmu_lo , ivmu )) = nn_from ( proc_id ( vmu_lo , ivmu )) + 1 if ( idx_local ( vmu_lo , ivmu )) & nn_to ( proc_id ( kxyz_lo , ikxyz )) = nn_to ( proc_id ( kxyz_lo , ikxyz )) + 1 end do end do end do do ip = 0 , nproc - 1 if ( nn_from ( ip ) > 0 ) then allocate ( from_list ( ip )% first ( nn_from ( ip ))) allocate ( from_list ( ip )% second ( nn_from ( ip ))) allocate ( from_list ( ip )% third ( nn_from ( ip ))) end if if ( nn_to ( ip ) > 0 ) then allocate ( to_list ( ip )% first ( nn_to ( ip ))) allocate ( to_list ( ip )% second ( nn_to ( ip ))) allocate ( to_list ( ip )% third ( nn_to ( ip ))) allocate ( to_list ( ip )% fourth ( nn_to ( ip ))) allocate ( to_list ( ip )% fifth ( nn_to ( ip ))) end if end do ! get local indices of elements distributed to/from other processors nn_to = 0 nn_from = 0 ! loop over all vmu indices, find corresponding y indices do ikxyz = kxyz_lo % llim_world , kxyz_lo % ulim_world do imu = 1 , nmu do iv = 1 , nvpa ! obtain corresponding y indices call kxyzidx2vmuidx ( iv , imu , ikxyz , kxyz_lo , vmu_lo , iy , ikx , iz , it , ivmu ) ! if vmu index local, set: ! ip = corresponding y processor ! from_list%first-third arrays = iv,imu,ikxyz  (ie vmu indices) ! later will send from_list to proc ip if ( idx_local ( kxyz_lo , ikxyz )) then ip = proc_id ( vmu_lo , ivmu ) n = nn_from ( ip ) + 1 nn_from ( ip ) = n from_list ( ip )% first ( n ) = iv from_list ( ip )% second ( n ) = imu from_list ( ip )% third ( n ) = ikxyz end if ! if y index local, set ip to corresponding vmu processor ! set to_list%first,second arrays = iy,iy  (ie y indices) ! will receive to_list from ip if ( idx_local ( vmu_lo , ivmu )) then ip = proc_id ( kxyz_lo , ikxyz ) n = nn_to ( ip ) + 1 nn_to ( ip ) = n to_list ( ip )% first ( n ) = iy to_list ( ip )% second ( n ) = ikx to_list ( ip )% third ( n ) = iz to_list ( ip )% fourth ( n ) = it to_list ( ip )% fifth ( n ) = ivmu end if end do end do end do from_low ( 1 ) = 1 from_low ( 2 ) = 1 from_low ( 3 ) = kxyz_lo % llim_proc from_high ( 1 ) = nvpa from_high ( 2 ) = nmu from_high ( 3 ) = kxyz_lo % ulim_alloc to_low ( 1 ) = 1 to_low ( 2 ) = 1 to_low ( 3 ) = - nzgrid to_low ( 4 ) = 1 to_low ( 5 ) = vmu_lo % llim_proc to_high ( 1 ) = vmu_lo % ny to_high ( 2 ) = vmu_lo % nakx / 2 + 1 to_high ( 3 ) = vmu_lo % nzed to_high ( 4 ) = vmu_lo % ntubes to_high ( 5 ) = vmu_lo % ulim_alloc call set_redist_character_type ( kxyz2vmu , 'kxyz2vmu' ) call init_redist ( kxyz2vmu , 'c' , to_low , to_high , to_list , & from_low , from_high , from_list ) call delete_list ( to_list ) call delete_list ( from_list ) end subroutine init_kxyz_to_vmu_redistribute subroutine init_xyz_to_vmu_redistribute use mp , only : nproc use stella_layouts , only : xyz_lo , vmu_lo use stella_layouts , only : xyzidx2vmuidx use stella_layouts , only : idx_local , proc_id use redistribute , only : index_list_type , init_redist use redistribute , only : delete_list , set_redist_character_type use vpamu_grids , only : nvpa , nmu use zgrid , only : nzgrid implicit none type ( index_list_type ), dimension ( 0 : nproc - 1 ) :: to_list , from_list integer , dimension ( 0 : nproc - 1 ) :: nn_to , nn_from integer , dimension ( 3 ) :: from_low , from_high integer , dimension ( 5 ) :: to_high , to_low integer :: ixyz , ivmu integer :: iv , imu , iy , ix , iz , it integer :: ip , n logical :: initialized = . false . if ( initialized ) return initialized = . true . ! count number of elements to be redistributed to/from each processor nn_to = 0 nn_from = 0 do ixyz = xyz_lo % llim_world , xyz_lo % ulim_world do imu = 1 , nmu do iv = 1 , nvpa call xyzidx2vmuidx ( iv , imu , ixyz , xyz_lo , vmu_lo , iy , ix , iz , it , ivmu ) if ( idx_local ( xyz_lo , ixyz )) & nn_from ( proc_id ( vmu_lo , ivmu )) = nn_from ( proc_id ( vmu_lo , ivmu )) + 1 if ( idx_local ( vmu_lo , ivmu )) & nn_to ( proc_id ( xyz_lo , ixyz )) = nn_to ( proc_id ( xyz_lo , ixyz )) + 1 end do end do end do do ip = 0 , nproc - 1 if ( nn_from ( ip ) > 0 ) then allocate ( from_list ( ip )% first ( nn_from ( ip ))) allocate ( from_list ( ip )% second ( nn_from ( ip ))) allocate ( from_list ( ip )% third ( nn_from ( ip ))) end if if ( nn_to ( ip ) > 0 ) then allocate ( to_list ( ip )% first ( nn_to ( ip ))) allocate ( to_list ( ip )% second ( nn_to ( ip ))) allocate ( to_list ( ip )% third ( nn_to ( ip ))) allocate ( to_list ( ip )% fourth ( nn_to ( ip ))) allocate ( to_list ( ip )% fifth ( nn_to ( ip ))) end if end do ! get local indices of elements distributed to/from other processors nn_to = 0 nn_from = 0 ! loop over all vmu indices, find corresponding y indices do ixyz = xyz_lo % llim_world , xyz_lo % ulim_world do imu = 1 , nmu do iv = 1 , nvpa ! obtain corresponding y indices call xyzidx2vmuidx ( iv , imu , ixyz , xyz_lo , vmu_lo , iy , ix , iz , it , ivmu ) ! if vmu index local, set: ! ip = corresponding y processor ! from_list%first-third arrays = iv,imu,ixyz  (ie vmu indices) ! later will send from_list to proc ip if ( idx_local ( xyz_lo , ixyz )) then ip = proc_id ( vmu_lo , ivmu ) n = nn_from ( ip ) + 1 nn_from ( ip ) = n from_list ( ip )% first ( n ) = iv from_list ( ip )% second ( n ) = imu from_list ( ip )% third ( n ) = ixyz end if ! if y index local, set ip to corresponding vmu processor ! set to_list%first,second arrays = iy,iy  (ie y indices) ! will receive to_list from ip if ( idx_local ( vmu_lo , ivmu )) then ip = proc_id ( xyz_lo , ixyz ) n = nn_to ( ip ) + 1 nn_to ( ip ) = n to_list ( ip )% first ( n ) = iy to_list ( ip )% second ( n ) = ix to_list ( ip )% third ( n ) = iz to_list ( ip )% fourth ( n ) = it to_list ( ip )% fifth ( n ) = ivmu end if end do end do end do from_low ( 1 ) = 1 from_low ( 2 ) = 1 from_low ( 3 ) = xyz_lo % llim_proc from_high ( 1 ) = nvpa from_high ( 2 ) = nmu from_high ( 3 ) = xyz_lo % ulim_alloc to_low ( 1 ) = 1 to_low ( 2 ) = 1 to_low ( 3 ) = - nzgrid to_low ( 4 ) = 1 to_low ( 5 ) = vmu_lo % llim_proc to_high ( 1 ) = vmu_lo % ny to_high ( 2 ) = vmu_lo % nx to_high ( 3 ) = vmu_lo % nzed to_high ( 4 ) = vmu_lo % ntubes to_high ( 5 ) = vmu_lo % ulim_alloc call set_redist_character_type ( xyz2vmu , 'xyz2vmu' ) call init_redist ( xyz2vmu , 'r' , to_low , to_high , to_list , & from_low , from_high , from_list ) call delete_list ( to_list ) call delete_list ( from_list ) end subroutine init_xyz_to_vmu_redistribute subroutine finish_redistribute implicit none redistribute_initialized = . false . end subroutine finish_redistribute end module dist_redistribute","tags":"","loc":"sourcefile/dist_redistribute.f90.html"},{"title":"parallel_streaming.f90 – stella","text":"Source Code module parallel_streaming implicit none public :: init_parallel_streaming , finish_parallel_streaming public :: advance_parallel_streaming_explicit public :: add_parallel_streaming_radial_variation public :: stream_tridiagonal_solve public :: parallel_streaming_initialized public :: stream , stream_c , stream_sign , gradpar_c public :: time_parallel_streaming public :: stream_rad_var1 public :: stream_rad_var2 public :: center_zed , get_dzed public :: get_zed_derivative_extended_domain private interface center_zed module procedure center_zed_segment_real module procedure center_zed_segment_complex module procedure center_zed_extended end interface center_zed logical :: parallel_streaming_initialized = . false . integer , dimension (:), allocatable :: stream_sign real , dimension (:, :, :, :), allocatable :: stream real , dimension (:, :, :), allocatable :: stream_c real , dimension (:, :, :), allocatable :: stream_rad_var1 real , dimension (:, :, :), allocatable :: stream_rad_var2 real , dimension (:, :), allocatable :: stream_tri_a1 , stream_tri_a2 real , dimension (:, :), allocatable :: stream_tri_b1 , stream_tri_b2 real , dimension (:, :), allocatable :: stream_tri_c1 , stream_tri_c2 real , dimension (:, :), allocatable :: gradpar_c real , dimension ( 2 , 3 ) :: time_parallel_streaming = 0. contains subroutine init_parallel_streaming use finite_differences , only : fd3pt use stella_time , only : code_dt use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx , imu_idx , is_idx use species , only : spec , nspec , pfac use vpamu_grids , only : nvpa , nvpa use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use vpamu_grids , only : vperp2 , vpa , mu use kt_grids , only : nalpha use zgrid , only : nzgrid , nztot use stella_geometry , only : gradpar , dgradpardrho , dBdrho , gfac , b_dot_grad_z use run_parameters , only : stream_implicit , driftkinetic_implicit use physics_flags , only : include_parallel_streaming , radial_variation implicit none integer :: iv , imu , is , ivmu integer :: ia , iz real , dimension (:), allocatable :: energy if ( parallel_streaming_initialized ) return parallel_streaming_initialized = . true . if (. not . allocated ( stream )) allocate ( stream ( nalpha , - nzgrid : nzgrid , nvpa , nspec )); stream = 0. if (. not . allocated ( stream_sign )) allocate ( stream_sign ( nvpa )); stream_sign = 0 ! sign of stream corresponds to appearing on RHS of GK equation ! i.e., this is the factor multiplying dg/dz on RHS of equation if ( include_parallel_streaming ) then do iv = 1 , nvpa do iz = - nzgrid , nzgrid do ia = 1 , nalpha stream ( ia , iz , iv , :) = - code_dt * b_dot_grad_z ( ia , iz ) * vpa ( iv ) * spec % stm_psi0 end do end do end do else stream = 0.0 end if if ( radial_variation ) then allocate ( energy ( - nzgrid : nzgrid )) if (. not . allocated ( stream_rad_var1 )) then allocate ( stream_rad_var1 ( - nzgrid : nzgrid , nvpa , nspec )) end if if (. not . allocated ( stream_rad_var2 )) then allocate ( stream_rad_var2 ( nalpha , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) stream_rad_var2 = 0.0 end if ia = 1 stream_rad_var1 = - code_dt * spread ( spread ( spec % stm_psi0 , 1 , nztot ), 2 , nvpa ) & * gfac * spread ( spread ( vpa , 1 , nztot ) * spread ( dgradpardrho , 2 , nvpa ), 3 , nspec ) do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) iv = iv_idx ( vmu_lo , ivmu ) energy = ( vpa ( iv ) ** 2 + vperp2 ( ia , :, imu )) * ( spec ( is )% temp_psi0 / spec ( is )% temp ) stream_rad_var2 ( ia , :, ivmu ) = & + code_dt * spec ( is )% stm_psi0 * vpa ( iv ) * gradpar & * spec ( is )% zt * maxwell_vpa ( iv , is ) * maxwell_mu ( ia , :, imu , is ) * maxwell_fac ( is ) & * ( pfac * ( spec ( is )% fprim + spec ( is )% tprim * ( energy - 2.5 )) & + gfac * 2 * mu ( imu ) * dBdrho ) end do deallocate ( energy ) end if !> stream_sign set to +/- 1 depending on the sign of the parallel streaming term. !> NB: stream_sign = -1 corresponds to positive advection velocity !> only need to consider ia=1, iz=0 and is=1 because alpha, z and species dependences !> do not lead to change in sign of the streaming pre-factor do iv = 1 , nvpa stream_sign ( iv ) = int ( sign ( 1.0 , stream ( 1 , 0 , iv , 1 ))) end do if ( stream_implicit . or . driftkinetic_implicit ) then call init_invert_stream_operator if (. not . allocated ( stream_c )) allocate ( stream_c ( - nzgrid : nzgrid , nvpa , nspec )) stream_c = stream ( 1 , :, :, :) do is = 1 , nspec do iv = 1 , nvpa call center_zed ( iv , stream_c (:, iv , is ), - nzgrid ) end do end do if (. not . allocated ( gradpar_c )) allocate ( gradpar_c ( - nzgrid : nzgrid , - 1 : 1 )) gradpar_c = spread ( gradpar , 2 , 3 ) !> get gradpar centred in zed for negative vpa (affects upwinding) call center_zed ( 1 , gradpar_c (:, - stream_sign ( 1 )), - nzgrid ) !> get gradpar centred in zed for positive vpa (affects upwinding) call center_zed ( nvpa , gradpar_c (:, - stream_sign ( nvpa )), - nzgrid ) stream = spread ( stream_c , 1 , nalpha ) end if end subroutine init_parallel_streaming subroutine init_invert_stream_operator use zgrid , only : delzed use extended_zgrid , only : iz_low , iz_up use extended_zgrid , only : nsegments use run_parameters , only : zed_upwind_plus , zed_upwind_minus , time_upwind_plus implicit none integer :: nz , nseg_max nz = maxval ( iz_up - iz_low ) nseg_max = maxval ( nsegments ) if (. not . allocated ( stream_tri_a1 )) then allocate ( stream_tri_a1 ( nz * nseg_max + 1 , - 1 : 1 )); stream_tri_a1 = 0. allocate ( stream_tri_a2 ( nz * nseg_max + 1 , - 1 : 1 )); stream_tri_a2 = 0. allocate ( stream_tri_b1 ( nz * nseg_max + 1 , - 1 : 1 )); stream_tri_b1 = 1. allocate ( stream_tri_b2 ( nz * nseg_max + 1 , - 1 : 1 )); stream_tri_b2 = 0. allocate ( stream_tri_c1 ( nz * nseg_max + 1 , - 1 : 1 )); stream_tri_c1 = 0. allocate ( stream_tri_c2 ( nz * nseg_max + 1 , - 1 : 1 )); stream_tri_c2 = 0. end if ! corresponds to sign of stream term positive on RHS of equation ! i.e., negative parallel advection speed ! NB: assumes equal spacing in zed stream_tri_b1 (:, 1 ) = zed_upwind_plus stream_tri_b2 (:, 1 ) = - 1.0 / delzed ( 0 ) stream_tri_c1 (: nz * nseg_max , 1 ) = zed_upwind_minus stream_tri_c2 (: nz * nseg_max , 1 ) = 1.0 / delzed ( 0 ) ! corresponds to sign of stream term negative on RHS of equation ! NB: assumes equal spacing in zed stream_tri_b1 (:, - 1 ) = zed_upwind_plus stream_tri_b2 (:, - 1 ) = 1.0 / delzed ( 0 ) stream_tri_a1 ( 2 :, - 1 ) = zed_upwind_minus stream_tri_a2 ( 2 :, - 1 ) = - 1.0 / delzed ( 0 ) stream_tri_a2 = time_upwind_plus * stream_tri_a2 stream_tri_b2 = time_upwind_plus * stream_tri_b2 stream_tri_c2 = time_upwind_plus * stream_tri_c2 end subroutine init_invert_stream_operator subroutine advance_parallel_streaming_explicit ( g , phi , bpar , gout ) use mp , only : proc0 use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx , imu_idx , is_idx use job_manage , only : time_message use stella_transforms , only : transform_ky2y use zgrid , only : nzgrid , ntubes use kt_grids , only : naky , naky_all , nakx , ikx_max , ny use kt_grids , only : swap_kxky use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use vpamu_grids , only : mu use species , only : spec use physics_flags , only : full_flux_surface , include_bpar use gyro_averages , only : gyro_average , gyro_average_j1 use run_parameters , only : driftkinetic_implicit , maxwellian_normalization implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: phi , bpar complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: gout integer :: ivmu , iv , imu , is , ia , iz , it complex , dimension (:, :, :, :), allocatable :: g0 , dgphi_dz , dgbpar_dz complex , dimension (:, :, :, :), allocatable :: g0y , g1y complex , dimension (:, :), allocatable :: g0_swap !> if flux tube simulation parallel streaming stays in ky,kx,z space with ky,kx,z local !> if full flux surface (flux annulus), will need to calculate in y space !> start the timer for the parallel streaming part of the time advance if ( proc0 ) call time_message (. false ., time_parallel_streaming (:, 1 ), ' Stream advance' ) !> allocate arrays needed for intermmediate calculations allocate ( g0 ( naky , nakx , - nzgrid : nzgrid , ntubes )) allocate ( dgphi_dz ( naky , nakx , - nzgrid : nzgrid , ntubes )) allocate ( dgbpar_dz ( naky , nakx , - nzgrid : nzgrid , ntubes )) !> if simulating a full flux surface, will also need version of the above arrays !> that is Fourier transformed to y-space if ( full_flux_surface ) then allocate ( g0_swap ( naky_all , ikx_max )) allocate ( g0y ( ny , ikx_max , - nzgrid : nzgrid , ntubes )) allocate ( g1y ( ny , ikx_max , - nzgrid : nzgrid , ntubes )) end if do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc !> get (iv,imu,is) indices corresponding to ivmu super-index iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) !> obtain <phi> (or <phi>-phi if driftkinetic_implicit=T) call gyro_average ( phi , ivmu , g0 (:, :, :, :)) if ( driftkinetic_implicit ) g0 (:, :, :, :) = g0 (:, :, :, :) - phi !> get d<phi>/dz, with z the parallel coordinate and store in dgphi_dz !> note that this should be a centered difference to avoid numerical !> unpleasantness to do with inexact cancellations in later velocity integration !> see appendix of the stella JCP 2019 for details call get_dgdz_centered ( g0 , ivmu , dgphi_dz ) if ( include_bpar ) then call gyro_average_j1 ( bpar , ivmu , g0 (:, :, :, :)) call get_dgdz_centered ( g0 , ivmu , dgbpar_dz ) else dgbpar_dz = 0. end if !> if driftkinetic_implicit=T, then only want to treat vpar . grad (<phi>-phi)*F0 term explicitly; !> in this case, zero out dg/dz term (or d(g/F)/dz for full-flux-surface) if ( driftkinetic_implicit ) then g0 = 0. else !> compute dg/dz in k-space and store in g0 call get_dgdz ( g (:, :, :, :, ivmu ), ivmu , g0 ) !> if simulating a full flux surface, need to obtain the contribution from parallel streaming !> in y-space, so FFT d(g/F)/dz from ky to y if ( full_flux_surface ) then do it = 1 , ntubes do iz = - nzgrid , nzgrid call swap_kxky ( g0 (:, :, iz , it ), g0_swap ) call transform_ky2y ( g0_swap , g0y (:, :, iz , it )) end do end do end if ! ! if simulating a full flux surface, must calculate F * d/dz (g/F) rather than dg/dz ! ! since F=F(y) in this case, avoid multiple Fourier transforms by applying chain rule ! ! to z derivative: F * d/dz (g/F) = dg/dz - g * d ln F / dz = dg/dz + g * mu/T * dB/dz ! if (full_flux_surface) then !    ! transform g and dg/dz from ky to y space and store in g0y and g1y, respectively !    g1y = g(:,:,:,:,ivmu) !    do it = 1, ntubes !       do iz = -nzgrid, nzgrid !          call transform_ky2y (g1y(:,:,iz,it), g0y(:,:,iz,it)) !          ! no longer need g1y so re-use as FFT of dg/dz (g0) !          call transform_ky2y (g0(:,:,iz,it), g1y(:,:,iz,it)) !       end do !    end do !    ! overwrite g0y with dg/dz + g * mu/T * dB/dz !    g0y = g1y + 2.0*mu(imu)*spread(spread(dBdzed,2,nakx),4,ntubes) * g0y !    ! g1y no longer needed so can over-write with d<phi>/dz below ! end if end if if ( full_flux_surface ) then !> transform d<phi>/dz (fully explicit) or d(<phi>-phi)/dz (if driftkinetic_implicit) !> from kalpha (ky) to alpha (y) space and store in g1y do it = 1 , ntubes do iz = - nzgrid , nzgrid call swap_kxky ( dgphi_dz (:, :, iz , it ), g0_swap ) call transform_ky2y ( g0_swap , g1y (:, :, iz , it )) end do end do !> over-write g0y with d/dz (g/F) + Ze/T * d<phi>/dz (or <phi>-phi for driftkinetic_implicit). g0y (:, :, :, :) = g0y (:, :, :, :) + g1y (:, :, :, :) * spec ( is )% zt ! ! over-write g0y with F * d/dz (g/F) + ZeF/T * d<phi>/dz (or <phi>-phi for driftkinetic_implicit). ! g0y(:,:,:,:) = g0y(:,:,:,:) + g1y(:,:,:,:)*spec(is)%zt*maxwell_fac(is) & !      * maxwell_vpa(iv,is)*spread(spread(maxwell_mu(:,:,imu,is),2,nakx),4,ntubes)*maxwell_fac(is) !> multiply d(g/F)/dz and d<phi>/dz terms with vpa*(b . grad z) and add to source (RHS of GK equation) call add_stream_term_ffs ( g0y , ivmu , gout (:, :, :, :, ivmu )) else !> bpar term is zero unless include_bpar = T, see if statement above. ia = 1 if ( maxwellian_normalization ) then g0 (:, :, :, :) = g0 (:, :, :, :) + dgphi_dz (:, :, :, :) * spec ( is )% zt & + 4. * mu ( imu ) * dgbpar_dz (:, :, :, :) else g0 (:, :, :, :) = g0 (:, :, :, :) + ( dgphi_dz (:, :, :, :) * spec ( is )% zt & + 4. * mu ( imu ) * dgbpar_dz (:, :, :, :)) & * maxwell_fac ( is ) * maxwell_vpa ( iv , is ) & * spread ( spread ( spread ( maxwell_mu ( ia , :, imu , is ), 1 , naky ), 2 , nakx ), 4 , ntubes ) end if ! multiply dg/dz with vpa*(b . grad z) and add to source (RHS of GK equation) call add_stream_term ( g0 , ivmu , gout (:, :, :, :, ivmu )) end if end do !> deallocate intermediate arrays used in this subroutine deallocate ( g0 , dgphi_dz , dgbpar_dz ) if ( full_flux_surface ) deallocate ( g0y , g1y , g0_swap ) !> finish timing the subroutine if ( proc0 ) call time_message (. false ., time_parallel_streaming (:, 1 ), ' Stream advance' ) end subroutine advance_parallel_streaming_explicit subroutine add_parallel_streaming_radial_variation ( g , gout , rhs ) use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx , imu_idx , is_idx use job_manage , only : time_message use zgrid , only : nzgrid , ntubes use kt_grids , only : naky , nakx use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use species , only : spec use gyro_averages , only : gyro_average , gyro_average_j1 use fields_arrays , only : phi , phi_corr_QN , phi_corr_GA implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: gout !the next input/output is for quasineutrality and gyroaveraging corrections !that go directly in the RHS (since they don't require further FFTs) complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: rhs integer :: ivmu , iv , imu , is , it , ia , iz complex , dimension (:, :, :, :), allocatable :: g0 , g1 , g2 , g3 complex , dimension (:, :), allocatable :: g0k allocate ( g0 ( naky , nakx , - nzgrid : nzgrid , ntubes )) allocate ( g1 ( naky , nakx , - nzgrid : nzgrid , ntubes )) allocate ( g2 ( naky , nakx , - nzgrid : nzgrid , ntubes )) allocate ( g3 ( naky , nakx , - nzgrid : nzgrid , ntubes )) allocate ( g0k ( naky , nakx )); g0k = 0 ! parallel streaming stays in ky,kx,z space with ky,kx,z local ia = 1 do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc ! obtain <phi> ! get d<phi>/dz, with z the parallel coordinate and store in g1 call gyro_average ( phi , ivmu , g0 ) call get_dgdz_centered ( g0 , ivmu , g1 ) ! get variation in gyroaveraging and store in g2 call get_dgdz_centered ( phi_corr_GA (:, :, :, :, ivmu ), ivmu , g2 ) ! get variation in quasineutrality and store in g3 call gyro_average ( phi_corr_QN , ivmu , g0 ) call get_dgdz_centered ( g0 , ivmu , g3 ) call get_dgdz ( g (:, :, :, :, ivmu ), ivmu , g0 ) iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) do it = 1 , ntubes do iz = - nzgrid , nzgrid !!#1 - variation in gradpar g0k = g0 (:, :, iz , it ) & + g1 (:, :, iz , it ) * spec ( is )% zt * maxwell_vpa ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) * maxwell_fac ( is ) g0k = g0k * stream_rad_var1 ( iz , iv , is ) !!#2 - variation in F_s/T_s g0k = g0k + g1 (:, :, iz , it ) * stream_rad_var2 ( ia , iz , ivmu ) gout (:, :, iz , it , ivmu ) = gout (:, :, iz , it , ivmu ) + g0k !!#3 - variation in the gyroaveraging and quasineutrality of phi !!     These variations already have the linear part calculated, so !!     ad it into the rhs directly g0k = spec ( is )% zt * stream ( 1 , iz , iv , is ) * maxwell_vpa ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) * maxwell_fac ( is ) & * ( g2 (:, :, iz , it ) + g3 (:, :, iz , it )) rhs (:, :, iz , it , ivmu ) = rhs (:, :, iz , it , ivmu ) + g0k end do end do end do deallocate ( g0 , g1 , g2 , g3 , g0k ) end subroutine add_parallel_streaming_radial_variation subroutine get_dgdz ( g , ivmu , dgdz ) use finite_differences , only : third_order_upwind_zed use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx use zgrid , only : nzgrid , delzed , ntubes use extended_zgrid , only : neigen , nsegments use extended_zgrid , only : iz_low , iz_up use extended_zgrid , only : ikxmod use extended_zgrid , only : fill_zed_ghost_zones use extended_zgrid , only : periodic use kt_grids , only : naky implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( out ) :: dgdz integer , intent ( in ) :: ivmu integer :: iseg , ie , it , iky , iv complex , dimension ( 2 ) :: gleft , gright ! FLAG -- assuming delta zed is equally spaced below! iv = iv_idx ( vmu_lo , ivmu ) do iky = 1 , naky do it = 1 , ntubes do ie = 1 , neigen ( iky ) do iseg = 1 , nsegments ( ie , iky ) ! first fill in ghost zones at boundaries in g(z) call fill_zed_ghost_zones ( it , iseg , ie , iky , g (:, :, :, :), gleft , gright ) ! now get dg/dz call third_order_upwind_zed ( iz_low ( iseg ), iseg , nsegments ( ie , iky ), & g ( iky , ikxmod ( iseg , ie , iky ), iz_low ( iseg ): iz_up ( iseg ), it ), & delzed ( 0 ), stream_sign ( iv ), gleft , gright , periodic ( iky ), & dgdz ( iky , ikxmod ( iseg , ie , iky ), iz_low ( iseg ): iz_up ( iseg ), it )) end do end do end do end do end subroutine get_dgdz subroutine get_dgdz_centered ( g , ivmu , dgdz ) use finite_differences , only : second_order_centered_zed use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx use zgrid , only : nzgrid , delzed , ntubes use extended_zgrid , only : neigen , nsegments use extended_zgrid , only : iz_low , iz_up use extended_zgrid , only : ikxmod use extended_zgrid , only : fill_zed_ghost_zones use extended_zgrid , only : periodic use kt_grids , only : naky implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( out ) :: dgdz integer , intent ( in ) :: ivmu integer :: iseg , ie , iky , iv , it complex , dimension ( 2 ) :: gleft , gright ! FLAG -- assuming delta zed is equally spaced below! iv = iv_idx ( vmu_lo , ivmu ) do iky = 1 , naky do it = 1 , ntubes do ie = 1 , neigen ( iky ) do iseg = 1 , nsegments ( ie , iky ) ! first fill in ghost zones at boundaries in g(z) call fill_zed_ghost_zones ( it , iseg , ie , iky , g (:, :, :, :), gleft , gright ) ! now get dg/dz call second_order_centered_zed ( iz_low ( iseg ), iseg , nsegments ( ie , iky ), & g ( iky , ikxmod ( iseg , ie , iky ), iz_low ( iseg ): iz_up ( iseg ), it ), & delzed ( 0 ), stream_sign ( iv ), gleft , gright , periodic ( iky ), & dgdz ( iky , ikxmod ( iseg , ie , iky ), iz_low ( iseg ): iz_up ( iseg ), it )) end do end do end do end do end subroutine get_dgdz_centered ! subroutine get_dgdz_variable (g, ivmu, dgdz) !    use finite_differences, only: fd_variable_upwinding_zed !    use stella_layouts, only: vmu_lo !    use stella_layouts, only: iv_idx !    use zgrid, only: nzgrid, delzed, ntubes !    use extended_zgrid, only: neigen, nsegments !    use extended_zgrid, only: iz_low, iz_up !    use extended_zgrid, only: ikxmod !    use extended_zgrid, only: fill_zed_ghost_zones !    use extended_zgrid, only: periodic !    use run_parameters, only: zed_upwind !    use kt_grids, only: naky !    implicit none !    complex, dimension (:,:,-nzgrid:,:), intent (in) :: g !    complex, dimension (:,:,-nzgrid:,:), intent (out) :: dgdz !    integer, intent (in) :: ivmu !    integer :: iseg, ie, iky, iv, it !    complex, dimension (2) :: gleft, gright !    ! FLAG -- assuming delta zed is equally spaced below! !     iv = iv_idx(vmu_lo,ivmu) !     do iky = 1, naky !       do it = 1, ntubes !         do ie = 1, neigen(iky) !           do iseg = 1, nsegments(ie,iky) !              ! first fill in ghost zones at boundaries in g(z) !              call fill_zed_ghost_zones (it, iseg, ie, iky, g(:,:,:,:), gleft, gright) ! now get dg/dz !              call fd_variable_upwinding_zed (iz_low(iseg), iseg, nsegments(ie,iky), & !                   g(iky,ikxmod(iseg,ie,iky),iz_low(iseg):iz_up(iseg),it), & !                   delzed(0), stream_sign(iv), zed_upwind,gleft, gright, periodic(iky), & !                   dgdz(iky,ikxmod(iseg,ie,iky),iz_low(iseg):iz_up(iseg),it)) !           end do !         end do !       enddo !     end do ! end subroutine get_dgdz_variable subroutine add_stream_term ( g , ivmu , src ) use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx , is_idx use zgrid , only : nzgrid implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( in out ) :: src integer , intent ( in ) :: ivmu integer :: iz , iv , is iv = iv_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) do iz = - nzgrid , nzgrid src (:, :, iz , :) = src (:, :, iz , :) + stream ( 1 , iz , iv , is ) * g (:, :, iz , :) end do end subroutine add_stream_term subroutine add_stream_term_ffs ( g , ivmu , src ) use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx , is_idx use zgrid , only : nzgrid use kt_grids , only : ny implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( in out ) :: src integer , intent ( in ) :: ivmu integer :: iz , iy , iv , is iv = iv_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) do iz = - nzgrid , nzgrid do iy = 1 , ny src ( iy , :, iz , :) = src ( iy , :, iz , :) + stream ( iy , iz , iv , is ) * g ( iy , :, iz , :) end do end do end subroutine add_stream_term_ffs subroutine stream_tridiagonal_solve ( iky , ie , iv , is , g ) use finite_differences , only : tridag use extended_zgrid , only : iz_low , iz_up use extended_zgrid , only : nsegments use extended_zgrid , only : nzed_segment implicit none integer , intent ( in ) :: iky , ie , iv , is complex , dimension (:), intent ( in out ) :: g integer :: iseg , llim , ulim , n integer :: nz , nseg_max , sgn , n_ext integer :: ia real , dimension (:), allocatable :: a , b , c ia = 1 ! avoid double-counting at boundaries between 2pi segments nz = nzed_segment nseg_max = nsegments ( ie , iky ) sgn = stream_sign ( iv ) n_ext = nseg_max * nz + 1 allocate ( a ( n_ext )) allocate ( b ( n_ext )) allocate ( c ( n_ext )) iseg = 1 llim = 1 ; ulim = nz + 1 a ( llim : ulim ) = stream_tri_a1 ( llim : ulim , sgn ) & - stream ( ia , iz_low ( iseg ): iz_up ( iseg ), iv , is ) * stream_tri_a2 ( llim : ulim , sgn ) b ( llim : ulim ) = stream_tri_b1 ( llim : ulim , sgn ) & - stream ( ia , iz_low ( iseg ): iz_up ( iseg ), iv , is ) * stream_tri_b2 ( llim : ulim , sgn ) c ( llim : ulim ) = stream_tri_c1 ( llim : ulim , sgn ) & - stream ( ia , iz_low ( iseg ): iz_up ( iseg ), iv , is ) * stream_tri_c2 ( llim : ulim , sgn ) if ( nsegments ( ie , iky ) > 1 ) then do iseg = 2 , nsegments ( ie , iky ) llim = ulim + 1 ulim = llim + nz - 1 a ( llim : ulim ) = stream_tri_a1 ( llim : ulim , sgn ) & - stream ( ia , iz_low ( iseg ) + 1 : iz_up ( iseg ), iv , is ) * stream_tri_a2 ( llim : ulim , sgn ) b ( llim : ulim ) = stream_tri_b1 ( llim : ulim , sgn ) & - stream ( ia , iz_low ( iseg ) + 1 : iz_up ( iseg ), iv , is ) * stream_tri_b2 ( llim : ulim , sgn ) c ( llim : ulim ) = stream_tri_c1 ( llim : ulim , sgn ) & - stream ( ia , iz_low ( iseg ) + 1 : iz_up ( iseg ), iv , is ) * stream_tri_c2 ( llim : ulim , sgn ) end do end if n = size ( stream_tri_a1 , 1 ) a ( ulim ) = stream_tri_a1 ( n , sgn ) - stream ( ia , iz_up ( nsegments ( ie , iky )), iv , is ) * stream_tri_a2 ( n , sgn ) b ( ulim ) = stream_tri_b1 ( n , sgn ) - stream ( ia , iz_up ( nsegments ( ie , iky )), iv , is ) * stream_tri_b2 ( n , sgn ) c ( ulim ) = 0. ! this line should not be necessary, as c(ulim) should not be accessed by tridag call tridag ( 1 , a (: ulim ), b (: ulim ), c (: ulim ), g ) deallocate ( a , b , c ) end subroutine stream_tridiagonal_solve subroutine get_dzed ( iv , g , dgdz ) use finite_differences , only : fd_cell_centres_zed use kt_grids , only : naky use zgrid , only : nzgrid , delzed , ntubes use extended_zgrid , only : neigen , nsegments use extended_zgrid , only : iz_low , iz_up use extended_zgrid , only : ikxmod use extended_zgrid , only : fill_zed_ghost_zones implicit none integer , intent ( in ) :: iv complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: g complex , dimension (:, :, - nzgrid :, :), intent ( out ) :: dgdz integer :: iky , ie , iseg , it complex , dimension ( 2 ) :: gleft , gright do it = 1 , ntubes do iky = 1 , naky do ie = 1 , neigen ( iky ) do iseg = 1 , nsegments ( ie , iky ) ! first fill in ghost zones at boundaries in g(z) call fill_zed_ghost_zones ( it , iseg , ie , iky , g , gleft , gright ) ! get finite difference approximation for dg/dz at cell centres ! iv > nvgrid corresponds to positive vpa, iv <= nvgrid to negative vpa call fd_cell_centres_zed ( iz_low ( iseg ), & g ( iky , ikxmod ( iseg , ie , iky ), iz_low ( iseg ): iz_up ( iseg ), it ), & delzed ( 0 ), stream_sign ( iv ), gleft ( 2 ), gright ( 1 ), & dgdz ( iky , ikxmod ( iseg , ie , iky ), iz_low ( iseg ): iz_up ( iseg ), it )) end do end do end do end do end subroutine get_dzed subroutine get_zed_derivative_extended_domain ( iv , f , f_left , f_right , df_dz ) use zgrid , only : delzed use finite_differences , only : fd_cell_centres_zed implicit none integer , intent ( in ) :: iv complex , dimension (:), intent ( in ) :: f complex , intent ( in ) :: f_left , f_right complex , dimension (:), intent ( out ) :: df_dz call fd_cell_centres_zed ( 1 , f , delzed ( 0 ), stream_sign ( iv ), f_left , f_right , df_dz ) end subroutine get_zed_derivative_extended_domain subroutine center_zed_extended ( iv , g ) use finite_differences , only : cell_centres_zed use kt_grids , only : naky , nakx use zgrid , only : nzgrid , ntubes use extended_zgrid , only : neigen , nsegments use extended_zgrid , only : iz_low , iz_up use extended_zgrid , only : ikxmod use extended_zgrid , only : fill_zed_ghost_zones use run_parameters , only : zed_upwind implicit none integer , intent ( in ) :: iv complex , dimension (:, :, - nzgrid :, :), intent ( in out ) :: g integer :: iky , ie , iseg , it complex , dimension ( 2 ) :: gleft , gright complex , dimension (:, :, :), allocatable :: gc allocate ( gc ( nakx , - nzgrid : nzgrid , ntubes )) do iky = 1 , naky do it = 1 , ntubes do ie = 1 , neigen ( iky ) do iseg = 1 , nsegments ( ie , iky ) ! first fill in ghost zones at boundaries in g(z) call fill_zed_ghost_zones ( it , iseg , ie , iky , g , gleft , gright ) ! get cell centres values call cell_centres_zed ( iz_low ( iseg ), & g ( iky , ikxmod ( iseg , ie , iky ), iz_low ( iseg ): iz_up ( iseg ), it ), & zed_upwind , stream_sign ( iv ), gleft ( 2 ), gright ( 1 ), & gc ( ikxmod ( iseg , ie , iky ), iz_low ( iseg ): iz_up ( iseg ), it )) end do end do end do g ( iky , :, :, :) = gc end do deallocate ( gc ) end subroutine center_zed_extended !> center_zed_segment_real takes as arguments the vpa index (iv) !> the z-depenendent real function f, and the starting iz index for the array f (llim), !> and overwrites f with the cell-centered version ! it is assumed that any function passed to this subroutine is periodic subroutine center_zed_segment_real ( iv , f , llim ) use run_parameters , only : zed_upwind_plus , zed_upwind_minus integer , intent ( in ) :: iv , llim real , dimension ( llim :), intent ( in out ) :: f integer :: ulim ulim = llim + size ( f ) - 1 if ( stream_sign ( iv ) > 0 ) then f (: ulim - 1 ) = zed_upwind_plus * f (: ulim - 1 ) + zed_upwind_minus * f ( llim + 1 :) f ( ulim ) = f ( llim ) else f ( llim + 1 :) = zed_upwind_minus * f (: ulim - 1 ) + zed_upwind_plus * f ( llim + 1 :) f ( llim ) = f ( ulim ) end if end subroutine center_zed_segment_real !> center_zed_segment_complex takes as arguments the vpa index (iv) !> the z-depenendent conplex function f, and the starting iz index for the array f (llim), !> and overwrites f with the cell-centered version; subroutine center_zed_segment_complex ( iv , f , llim , periodic ) use run_parameters , only : zupwnd_p => zed_upwind_plus use run_parameters , only : zupwnd_m => zed_upwind_minus integer , intent ( in ) :: iv , llim complex , dimension ( llim :), intent ( in out ) :: f logical , intent ( in ) :: periodic integer :: ulim ulim = llim + size ( f ) - 1 ! stream_sign > 0 means negative advection velocity if ( stream_sign ( iv ) > 0 ) then f (: ulim - 1 ) = zupwnd_p * f (: ulim - 1 ) + zupwnd_m * f ( llim + 1 :) if ( periodic ) then f ( ulim ) = f ( llim ) else f ( ulim ) = zupwnd_p * f ( ulim ) end if else f ( llim + 1 :) = zupwnd_m * f (: ulim - 1 ) + zupwnd_p * f ( llim + 1 :) if ( periodic ) then f ( llim ) = f ( ulim ) else f ( llim ) = zupwnd_p * f ( llim ) end if end if end subroutine center_zed_segment_complex ! subroutine center_zed_midpoint(iv, g) !    use zgrid, only: nzgrid !    integer, intent(in) :: iv !    real, dimension(-nzgrid:), intent(in out) :: g !    if (stream_sign(iv) > 0) then !       g(:nzgrid - 1) = 0.5 * (g(:nzgrid - 1) + g(-nzgrid + 1:)) !       g(nzgrid) = g(-nzgrid) !    else !       g(-nzgrid + 1:) = 0.5 * (g(:nzgrid - 1) + g(-nzgrid + 1:)) !       g(-nzgrid) = g(nzgrid) !    end if ! end subroutine center_zed_midpoint subroutine finish_parallel_streaming use run_parameters , only : stream_implicit , driftkinetic_implicit implicit none if ( allocated ( stream )) deallocate ( stream ) if ( allocated ( stream_c )) deallocate ( stream_c ) if ( allocated ( stream_sign )) deallocate ( stream_sign ) if ( allocated ( gradpar_c )) deallocate ( gradpar_c ) if ( allocated ( stream_rad_var1 )) deallocate ( stream_rad_var1 ) if ( allocated ( stream_rad_var2 )) deallocate ( stream_rad_var2 ) if ( stream_implicit . or . driftkinetic_implicit ) call finish_invert_stream_operator parallel_streaming_initialized = . false . end subroutine finish_parallel_streaming subroutine finish_invert_stream_operator implicit none if ( allocated ( stream_tri_a1 )) then deallocate ( stream_tri_a1 ) deallocate ( stream_tri_a2 ) deallocate ( stream_tri_b1 ) deallocate ( stream_tri_b2 ) deallocate ( stream_tri_c1 ) deallocate ( stream_tri_c2 ) end if end subroutine finish_invert_stream_operator end module parallel_streaming","tags":"","loc":"sourcefile/parallel_streaming.f90.html"},{"title":"constants.fpp – stella","text":"Source Code # include \"define.inc\" module constants ! ! This module must not be compiled with a padding option ! such as -qautodbl=dbl of xlf which makes type conversion ! of variables even with explicit kind statements. ! implicit none !  public :: size_of public :: kind_is , kind_id , kind_rs , kind_rd public :: zi , pi , twopi , dpi , dtwopi # ifdef NAG_PREC public :: nag_kind # endif private ! Symbolic names for kind type of single and double-precision reals: ! (with at least 6 and 12 digits of accuracy) integer , parameter :: kind_i1 = selected_int_kind ( 2 ) integer , parameter :: kind_ih = selected_int_kind ( 4 ) integer , parameter :: kind_is = selected_int_kind ( 8 ) integer , parameter :: kind_id = selected_int_kind ( 15 ) integer , parameter :: kind_rs = selected_real_kind ( p = 6 ) integer , parameter :: kind_rd = selected_real_kind ( p = 12 ) ! There is a selected_real_kind bug in xlf and the following does not work integer , parameter :: kind_rq = selected_real_kind ( p = 24 ) !   integer, parameter :: sizeof_i1 = 1 !   integer, parameter :: sizeof_ih = 2 !   integer, parameter :: sizeof_is = 4 !   integer, parameter :: sizeof_id = 8 !   integer, parameter :: sizeof_rs = 4 !   integer, parameter :: sizeof_rd = 8 !   integer, parameter :: sizeof_rq = 16 !   integer, parameter :: sizeof_cs = 8 !   integer, parameter :: sizeof_cd = 16 !   integer, parameter :: sizeof_cq = 32 # if NAG_PREC == _NAGDBLE_ integer , parameter :: nag_kind = kind_rd # elif NAG_PREC == _NAGSNGL_ integer , parameter :: nag_kind = kind_rs # endif ! Symbolic names for kind type of single and double-precision complex: !  integer, parameter :: spc = kind((1.0_sp,1.0_sp)) !  integer, parameter :: dpc = kind((1.0_dp,1.0_dp)) !  complex(dp), parameter :: ii = (0._dp, 1._dp) !  real(dp), parameter :: pi=3.141592653589793238_dp complex , parameter :: zi = ( 0.0 , 1.0 ) !  real, parameter :: pi = 3.1415926535897931 !  real, parameter :: pi = 3.14159265358979323846, twopi=2.*pi ! this is actually quad precision double precision , parameter :: dpi = & 3.14159265358979323846264338327950288419716939938 , dtwopi = 2. * dpi real , parameter :: pi = dpi , twopi = dtwopi ! Note: we will use dp=\"double precision\" for almost everything. ! ! The fortran-90 \"kind\" types is kind of awkward.  But the old trick of ! using a \"-r8\" compiler switch to promote all real variables to 64 bits ! does not work on some fortran 90 compilers, and so the above use of ! the standard fortran-90 routine selected_real_kind is more portable. ! ! It may not be a good idea to mimic \"-r8\" by making sp to be identical ! to dp, or to write single and double-precision versions of ! generic subroutines, since on the Cray computers both single and ! \"double\" precision are 64 bits, and the compiler will complain that ! it cannot distinguish the two specific subroutines.  In some cases, ! the cray compiler may be able to distinguish between two real \"kinds\" ! for the purposes of distinguishing overloaded procedure names, ! even though the two real kinds map to the same precision (64 bits). ! ! If this ever does become a problem, then you may be able to get around it by ! commenting out the double precision function names from the list of ! overloaded procedures (i.e., the \"module procedure\" statements). ! !   interface size_of !      module procedure size_of_i1, size_of_ih, size_of_is, size_of_id !      module procedure size_of_rs, size_of_rd !      module procedure size_of_cs, size_of_cd ! !!$# ifdef QUAD ! !!$     module procedure size_of_rq, size_of_cq ! !!$# endif !   end interface contains !   integer function size_of_i1 (arg) !     integer (kind_i1) :: arg !     size_of_i1 = sizeof_i1 !   end function size_of_i1 !   integer function size_of_ih (arg) !     integer (kind_ih) :: arg !     size_of_ih = sizeof_ih !   end function size_of_ih !   integer function size_of_is (arg) !     integer (kind_is) :: arg !     size_of_is = sizeof_is !   end function size_of_is !   integer function size_of_id (arg) !     integer (kind_id) :: arg !     size_of_id = sizeof_id !   end function size_of_id !   integer function size_of_rs (arg) !     real (kind_rs) :: arg !     size_of_rs = sizeof_rs !   end function size_of_rs !   integer function size_of_rd (arg) !     real (kind_rd) :: arg !     size_of_rd = sizeof_rd !   end function size_of_rd ! !!$# ifdef QUAD ! !!$  integer function size_of_rq (arg) ! !!$    real (kind_rq) :: arg ! !!$    size_of_rq = sizeof_rq ! !!$  end function size_of_rq ! !!$# endif !   integer function size_of_cs (arg) !     complex (kind_rs) :: arg !     size_of_cs = sizeof_cs !   end function size_of_cs !   integer function size_of_cd (arg) !     complex (kind_rd) :: arg !     size_of_cd = sizeof_cd !   end function size_of_cd !!$# ifdef QUAD !!$  integer function size_of_cq (arg) !!$    complex (kind_rq) :: arg !!$    size_of_cq = sizeof_cq !!$  end function size_of_cq !!$# endif end module constants","tags":"","loc":"sourcefile/constants.fpp.html"},{"title":"neoclassical_terms.f90 – stella","text":"Source Code module neoclassical_terms implicit none public :: init_neoclassical_terms public :: finish_neoclassical_terms public :: include_neoclassical_terms public :: dfneo_dzed , dfneo_dvpa , dfneo_drho , dfneo_dalpha public :: dphineo_dzed , dphineo_drho , dphineo_dalpha private logical :: include_neoclassical_terms integer :: nradii real :: drho integer :: neo_option_switch integer , parameter :: neo_option_sfincs = 1 real , dimension (:, :, :), allocatable :: dfneo_dzed , dfneo_dvpa , dfneo_drho , dfneo_dalpha real , dimension (:, :), allocatable :: dphineo_dzed , dphineo_drho , dphineo_dalpha logical :: neoinit = . false . logical :: debug = . false . contains subroutine init_neoclassical_terms use zgrid , only : nzgrid use kt_grids , only : nalpha use vpamu_grids , only : nvpa , nmu use species , only : nspec use stella_layouts , only : vmu_lo use sfincs_interface , only : get_neo_from_sfincs implicit none real , dimension (:, :, :, :, :, :), allocatable :: f_neoclassical real , dimension (:, :, :), allocatable :: phi_neoclassical real , dimension (:, :, :, :, :), allocatable :: dfneo_dalpha_local integer :: iz , ialpha if ( neoinit ) return neoinit = . true . call read_parameters if ( include_neoclassical_terms ) then allocate ( f_neoclassical ( nalpha , - nzgrid : nzgrid , nvpa , nmu , nspec , - nradii / 2 : nradii / 2 )) allocate ( phi_neoclassical ( nalpha , - nzgrid : nzgrid , - nradii / 2 : nradii / 2 )) allocate ( dfneo_dalpha_local ( nalpha , - nzgrid : nzgrid , nvpa , nmu , nspec )) if (. not . allocated ( dfneo_dvpa )) & allocate ( dfneo_dvpa ( nalpha , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) if (. not . allocated ( dfneo_drho )) & allocate ( dfneo_drho ( nalpha , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) if (. not . allocated ( dfneo_dzed )) & allocate ( dfneo_dzed ( nalpha , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) if (. not . allocated ( dfneo_dalpha )) & allocate ( dfneo_dalpha ( nalpha , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) if (. not . allocated ( dphineo_dzed )) & allocate ( dphineo_dzed ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( dphineo_drho )) & allocate ( dphineo_drho ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( dphineo_dalpha )) & allocate ( dphineo_dalpha ( nalpha , - nzgrid : nzgrid )) select case ( neo_option_switch ) case ( neo_option_sfincs ) call get_neo_from_sfincs ( nradii , drho , f_neoclassical , phi_neoclassical , dfneo_dalpha_local , dphineo_dalpha ) end select if ( debug ) write ( 6 , * ) 'neoclassical_terms::init_neoclassical_terms::get_dfneo_dzed' call get_dfneo_dzed ( f_neoclassical (:, :, :, :, :, 0 ), dfneo_dzed ) if ( debug ) write ( 6 , * ) 'neoclassical_terms::init_neoclassical_terms::get_dfneo_dvpa' call get_dfneo_dvpa ( f_neoclassical (:, :, :, :, :, 0 ), dfneo_dvpa ) if ( debug ) write ( 6 , * ) 'neoclassical_terms::init_neoclassical_terms::get_dfneo_drho' call get_dfneo_drho ( f_neoclassical , dfneo_drho ) if ( debug ) write ( 6 , * ) 'neoclassical_terms::init_neoclassical_terms::get_dphineo_dzed' call get_dphineo_dzed ( phi_neoclassical (:, :, 0 ), dphineo_dzed ) if ( debug ) write ( 6 , * ) 'neoclassical_terms::init_neoclassical_terms::get_dphineo_drho' call get_dphineo_drho ( phi_neoclassical , dphineo_drho ) do iz = - nzgrid , nzgrid do ialpha = 1 , nalpha call distribute_vmus_over_procs ( dfneo_dalpha_local ( ialpha , iz , :, :, :), dfneo_dalpha ( ialpha , iz , :)) end do end do if ( debug ) write ( 6 , * ) 'neoclassical_terms::init_neoclassical_terms::write_neoclassical' call write_neoclassical ( f_neoclassical , phi_neoclassical ) deallocate ( f_neoclassical , phi_neoclassical , dfneo_dalpha_local ) end if end subroutine init_neoclassical_terms subroutine read_parameters use mp , only : proc0 , broadcast use file_utils , only : error_unit , input_unit_exist use text_options , only : text_option , get_option_value implicit none type ( text_option ), dimension ( 2 ), parameter :: neoopts = ( / & text_option ( 'default' , neo_option_sfincs ), & text_option ( 'sfincs' , neo_option_sfincs ) / ) character ( 10 ) :: neo_option namelist / neoclassical_input / include_neoclassical_terms , & neo_option , nradii , drho logical :: exist integer :: ierr , in_file if ( proc0 ) then ! set to .true. to include neoclassical terms in GK equation include_neoclassical_terms = . false . ! number of radial points used for radial derivatives ! of neoclassical quantities nradii = 5 ! spacing in rhoc between points used for radial derivatives drho = 0.01 ! option for obtaining neoclassical distribution function and potential neo_option = 'sfincs' in_file = input_unit_exist ( \"neoclassical_input\" , exist ) if ( exist ) read ( unit = in_file , nml = neoclassical_input ) ierr = error_unit () call get_option_value & ( neo_option , neoopts , neo_option_switch , & ierr , \"neo_option in neoclassical_input\" ) if ( nradii /= 3 . and . nradii /= 5 ) then write ( * , * ) 'WARNING: only nradii of 3 or 5 is currently supported in neoclassical_input namelist' write ( * , * ) 'WARNING: forcing nradii=5' nradii = 5 end if end if call broadcast ( include_neoclassical_terms ) call broadcast ( neo_option_switch ) call broadcast ( nradii ) call broadcast ( drho ) end subroutine read_parameters subroutine distribute_vmus_over_procs ( local , distributed ) use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx , imu_idx , is_idx implicit none real , dimension (:, :, :), intent ( in ) :: local real , dimension ( vmu_lo % llim_proc :), intent ( out ) :: distributed integer :: ivmu , iv , imu , is do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) distributed ( ivmu ) = local ( iv , imu , is ) end do end subroutine distribute_vmus_over_procs subroutine get_dfneo_dvpa ( fneo , dfneo ) use finite_differences , only : fd5pt use stella_layouts , only : vmu_lo use zgrid , only : nzgrid use vpamu_grids , only : nvpa , nmu use vpamu_grids , only : dvpa use species , only : nspec use kt_grids , only : nalpha implicit none real , dimension (:, - nzgrid :, :, :, :), intent ( in ) :: fneo real , dimension (:, - nzgrid :, vmu_lo % llim_proc :), intent ( out ) :: dfneo integer :: ia , iz , imu , is real , dimension (:), allocatable :: tmp1 , tmp2 real , dimension (:, :, :, :, :), allocatable :: dfneo_local allocate ( tmp1 ( nvpa ), tmp2 ( nvpa )) allocate ( dfneo_local ( nalpha , - nzgrid : nzgrid , nvpa , nmu , nspec )) do is = 1 , nspec do imu = 1 , nmu do iz = - nzgrid , nzgrid do ia = 1 , nalpha ! hack to avoid dealing with negative indices in fd5pt tmp1 = fneo ( ia , iz , :, imu , is ) call fd5pt ( tmp1 , tmp2 , dvpa ) dfneo_local ( ia , iz , :, imu , is ) = tmp2 end do end do end do end do do iz = - nzgrid , nzgrid do ia = 1 , nalpha call distribute_vmus_over_procs ( dfneo_local ( ia , iz , :, :, :), dfneo ( ia , iz , :)) end do end do deallocate ( dfneo_local ) deallocate ( tmp1 , tmp2 ) end subroutine get_dfneo_dvpa subroutine get_dfneo_dzed ( fneo , dfneo ) use finite_differences , only : fd5pt use zgrid , only : nztot , nzgrid , delzed use vpamu_grids , only : nvpa , nmu use species , only : nspec use stella_layouts , only : vmu_lo use kt_grids , only : nalpha implicit none real , dimension (:, - nzgrid :, :, :, :), intent ( in ) :: fneo real , dimension (:, - nzgrid :, vmu_lo % llim_proc :), intent ( out ) :: dfneo integer :: iv , imu , is , iz , ia real , dimension (:), allocatable :: tmp1 , tmp2 real , dimension (:), allocatable :: dfneo_local (:, :, :, :, :) allocate ( tmp1 ( nztot ), tmp2 ( nztot )) allocate ( dfneo_local ( nalpha , - nzgrid : nzgrid , nvpa , nmu , nspec )) do is = 1 , nspec do imu = 1 , nmu do iv = 1 , nvpa do ia = 1 , nalpha ! hack to avoid dealing with negative indices in fd5pt tmp1 = fneo ( ia , :, iv , imu , is ) call fd5pt ( tmp1 , tmp2 , delzed ( 0 )) dfneo_local ( ia , :, iv , imu , is ) = tmp2 end do end do end do end do do iz = - nzgrid , nzgrid do ia = 1 , nalpha call distribute_vmus_over_procs ( dfneo_local ( ia , iz , :, :, :), dfneo ( ia , iz , :)) end do end do deallocate ( dfneo_local ) deallocate ( tmp1 , tmp2 ) end subroutine get_dfneo_dzed subroutine get_dfneo_drho ( fneo , dfneo ) use finite_differences , only : fd3pt , fd5pt use zgrid , only : nzgrid use vpamu_grids , only : nvpa , nmu use species , only : nspec use stella_layouts , only : vmu_lo use kt_grids , only : nalpha implicit none real , dimension (:, - nzgrid :, :, :, :, - nradii / 2 :), intent ( in ) :: fneo real , dimension (:, - nzgrid :, vmu_lo % llim_proc :), intent ( out ) :: dfneo integer :: ia , iz , iv , imu , is real , dimension (:), allocatable :: tmp1 , tmp2 real , dimension (:, :, :, :, :), allocatable :: dfneo_local allocate ( tmp1 ( nradii ), tmp2 ( nradii )) allocate ( dfneo_local ( nalpha , - nzgrid : nzgrid , nvpa , nmu , nspec )) do is = 1 , nspec do imu = 1 , nmu do iv = 1 , nvpa do iz = - nzgrid , nzgrid do ia = 1 , nalpha ! hack to avoid dealing with negative indices in fd5pt tmp1 = fneo ( ia , iz , iv , imu , is , :) if ( nradii == 5 ) then call fd5pt ( tmp1 , tmp2 , drho ) else call fd3pt ( tmp1 , tmp2 , drho ) end if dfneo_local ( ia , iz , iv , imu , is ) = tmp2 ( nradii / 2 + 1 ) end do end do end do end do end do do iz = - nzgrid , nzgrid do ia = 1 , nalpha call distribute_vmus_over_procs ( dfneo_local ( ia , iz , :, :, :), dfneo ( ia , iz , :)) end do end do deallocate ( dfneo_local ) deallocate ( tmp1 , tmp2 ) end subroutine get_dfneo_drho subroutine get_dphineo_dzed ( phineo , dphineo ) use finite_differences , only : fd5pt use zgrid , only : nztot , nzgrid , delzed use kt_grids , only : nalpha implicit none real , dimension (:, - nzgrid :), intent ( in ) :: phineo real , dimension (:, - nzgrid :), intent ( out ) :: dphineo integer :: ia real , dimension (:), allocatable :: tmp1 , tmp2 allocate ( tmp1 ( nztot ), tmp2 ( nztot )) do ia = 1 , nalpha ! hack to avoid dealing with negative indices in fd5pt tmp1 = phineo ( ia , :) call fd5pt ( tmp1 , tmp2 , delzed ( 0 )) dphineo ( ia , :) = tmp2 end do deallocate ( tmp1 , tmp2 ) end subroutine get_dphineo_dzed subroutine get_dphineo_drho ( phineo , dphineo ) use finite_differences , only : fd3pt , fd5pt use zgrid , only : nzgrid use kt_grids , only : nalpha implicit none real , dimension (:, - nzgrid :, - nradii / 2 :), intent ( in ) :: phineo real , dimension (:, - nzgrid :), intent ( out ) :: dphineo integer :: iz , ia real , dimension (:), allocatable :: tmp1 , tmp2 allocate ( tmp1 ( nradii ), tmp2 ( nradii )) do iz = - nzgrid , nzgrid do ia = 1 , nalpha ! hack to avoid dealing with negative indices in fd5pt tmp1 = phineo ( ia , iz , :) if ( nradii == 5 ) then call fd5pt ( tmp1 , tmp2 , drho ) else call fd3pt ( tmp1 , tmp2 , drho ) end if dphineo ( ia , iz ) = tmp2 ( nradii / 2 + 1 ) end do end do deallocate ( tmp1 , tmp2 ) end subroutine get_dphineo_drho subroutine write_neoclassical ( fnc , phinc ) use mp , only : proc0 use mp , only : send , receive use file_utils , only : open_output_file , close_output_file use zgrid , only : nzgrid , zed use vpamu_grids , only : vpa , mu use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx , imu_idx , is_idx use stella_layouts , only : idx_local , proc_id use kt_grids , only : nalpha implicit none real , dimension (:, - nzgrid :, :, :, :, - nradii / 2 :), intent ( in ) :: fnc real , dimension (:, - nzgrid :, - nradii / 2 :), intent ( in ) :: phinc integer :: neo_unit integer :: irad , iz , ivmu , iv , imu , is , ia real , dimension (:, :), allocatable :: dfdv_local , dfdr_local , dfdz_local allocate ( dfdv_local ( nalpha , - nzgrid : nzgrid )) allocate ( dfdr_local ( nalpha , - nzgrid : nzgrid )) allocate ( dfdz_local ( nalpha , - nzgrid : nzgrid )) if ( proc0 ) then call open_output_file ( neo_unit , '.neoclassical' ) write ( neo_unit , '(3a8,10a13)' ) '#1.rad' , '2.spec' , '3.alpha' , '4.zed' , '5.mu' , & '6.vpa' , '7.f_neo' , '8.dfdvpa_neo' , '9.dfdrho_neo' , '10.dfdzed_neo' , '11.phi_neo' , & '12.dphidrho' , '13.dphidzed' end if do irad = - nradii / 2 , nradii / 2 do ivmu = vmu_lo % llim_world , vmu_lo % ulim_world iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) if ( idx_local ( vmu_lo , iv , imu , is )) then if ( proc0 ) then dfdv_local = dfneo_dvpa (:, :, ivmu ) dfdr_local = dfneo_drho (:, :, ivmu ) dfdz_local = dfneo_dzed (:, :, ivmu ) else call send ( dfneo_dvpa (:, :, ivmu ), 0 ) call send ( dfneo_drho (:, :, ivmu ), 0 ) call send ( dfneo_dzed (:, :, ivmu ), 0 ) end if else if ( proc0 ) then call receive ( dfdv_local , proc_id ( vmu_lo , ivmu )) call receive ( dfdr_local , proc_id ( vmu_lo , ivmu )) call receive ( dfdz_local , proc_id ( vmu_lo , ivmu )) end if if ( proc0 ) then do iz = - nzgrid , nzgrid do ia = 1 , nalpha write ( neo_unit , '(3i8,10e13.5)' ) irad , is , ia , zed ( iz ), mu ( imu ), vpa ( iv ), & fnc ( ia , iz , iv , imu , is , irad ), & dfdv_local ( ia , iz ), & dfdr_local ( ia , iz ), & dfdz_local ( ia , iz ), & phinc ( ia , iz , irad ), dphineo_drho ( ia , iz ), dphineo_dzed ( ia , iz ) end do end do end if end do if ( proc0 ) write ( neo_unit , * ) end do if ( proc0 ) call close_output_file ( neo_unit ) deallocate ( dfdv_local , dfdr_local , dfdz_local ) end subroutine write_neoclassical subroutine finish_neoclassical_terms implicit none if ( allocated ( dfneo_dvpa )) deallocate ( dfneo_dvpa ) if ( allocated ( dfneo_drho )) deallocate ( dfneo_drho ) if ( allocated ( dfneo_dzed )) deallocate ( dfneo_dzed ) if ( allocated ( dfneo_dalpha )) deallocate ( dfneo_dalpha ) if ( allocated ( dphineo_dzed )) deallocate ( dphineo_dzed ) if ( allocated ( dphineo_drho )) deallocate ( dphineo_drho ) if ( allocated ( dphineo_dalpha )) deallocate ( dphineo_dalpha ) neoinit = . false . end subroutine finish_neoclassical_terms end module neoclassical_terms","tags":"","loc":"sourcefile/neoclassical_terms.f90.html"},{"title":"run_parameters.f90 – stella","text":"Source Code !> This module is basically a store for the input parameters that are specified in the namelists \\a knobs and \\a parameters. In general, the names of the public variables in this module are the same as the name of the input parameter they correspond to. module run_parameters implicit none public :: init_run_parameters , finish_run_parameters public :: fphi , fapar , fbpar public :: nstep , tend , delt public :: cfl_cushion_upper , cfl_cushion_middle , cfl_cushion_lower public :: delt_max , delt_min public :: avail_cpu_time public :: stream_implicit , mirror_implicit public :: drifts_implicit public :: driftkinetic_implicit public :: fully_explicit , fully_implicit public :: ky_solve_radial , ky_solve_real public :: maxwellian_inside_zed_derivative public :: stream_matrix_inversion public :: mirror_semi_lagrange , mirror_linear_interp public :: zed_upwind , vpa_upwind , time_upwind public :: fields_kxkyz , mat_gen , mat_read public :: rng_seed public :: use_deltaphi_for_response_matrix public :: maxwellian_normalization public :: time_upwind_plus , time_upwind_minus public :: zed_upwind_plus , zed_upwind_minus private real :: cfl_cushion_upper , cfl_cushion_middle , cfl_cushion_lower real :: fphi , fapar , fbpar real :: delt , tend , delt_max , delt_min real :: vpa_upwind real :: time_upwind , time_upwind_plus , time_upwind_minus real :: zed_upwind , zed_upwind_plus , zed_upwind_minus logical :: stream_implicit , mirror_implicit , drifts_implicit logical :: driftkinetic_implicit logical :: fully_explicit , fully_implicit logical :: maxwellian_inside_zed_derivative logical :: stream_matrix_inversion logical :: mirror_semi_lagrange , mirror_linear_interp logical :: fields_kxkyz , mat_gen , mat_read logical :: ky_solve_real logical :: use_deltaphi_for_response_matrix logical :: maxwellian_normalization real :: avail_cpu_time integer :: nstep , ky_solve_radial integer :: rng_seed integer , public :: delt_option_switch , lu_option_switch integer , public , parameter :: delt_option_hand = 1 , delt_option_auto = 2 integer , public , parameter :: lu_option_none = 1 , & lu_option_local = 2 , & lu_option_global = 3 logical :: initialized = . false . logical :: knexist contains subroutine init_run_parameters implicit none if ( initialized ) return initialized = . true . call read_parameters end subroutine init_run_parameters subroutine read_parameters use file_utils , only : input_unit , error_unit , input_unit_exist use mp , only : mp_abort , proc0 , broadcast use text_options , only : text_option , get_option_value use physics_flags , only : include_mirror , full_flux_surface , radial_variation use physics_flags , only : nonlinear , include_apar , include_parallel_streaming use physics_parameters , only : rhostar implicit none type ( text_option ), dimension ( 3 ), parameter :: deltopts = & ( / text_option ( 'default' , delt_option_auto ), & text_option ( 'set_by_hand' , delt_option_hand ), & text_option ( 'check_restart' , delt_option_auto ) / ) type ( text_option ), dimension ( 4 ), parameter :: lu_opts = & ( / text_option ( 'default' , lu_option_none ), & text_option ( 'none' , lu_option_none ), & text_option ( 'local' , lu_option_local ), & text_option ( 'global' , lu_option_global ) / ) character ( 20 ) :: delt_option , lu_option logical :: error = . false . integer :: ierr , in_file namelist / knobs / fphi , fapar , fbpar , delt , nstep , tend , & delt_option , lu_option , & avail_cpu_time , delt_max , delt_min , & cfl_cushion_upper , cfl_cushion_middle , cfl_cushion_lower , & stream_implicit , mirror_implicit , driftkinetic_implicit , & drifts_implicit , use_deltaphi_for_response_matrix , & maxwellian_normalization , & stream_matrix_inversion , maxwellian_inside_zed_derivative , & mirror_semi_lagrange , mirror_linear_interp , & zed_upwind , vpa_upwind , time_upwind , & fields_kxkyz , mat_gen , mat_read , rng_seed , & ky_solve_radial , ky_solve_real if ( proc0 ) then ! Default parameters in namelist <knobs> fphi = 1.0 fapar = - 1.0 ! fapar deprecated; keeping for now for backward compatibility fbpar = - 1.0 ! fbpar deprecated; keeping for now for backward compatibility fields_kxkyz = . false . stream_implicit = . true . mirror_implicit = . true . drifts_implicit = . false . driftkinetic_implicit = . false . maxwellian_inside_zed_derivative = . false . mirror_semi_lagrange = . true . mirror_linear_interp = . false . stream_matrix_inversion = . false . use_deltaphi_for_response_matrix = . false . maxwellian_normalization = . false . delt_option = 'default' zed_upwind = 0.02 vpa_upwind = 0.02 time_upwind = 0.02 rng_seed = - 1 !negative values use current time as seed ky_solve_radial = 0 ky_solve_real = . false . mat_gen = . false . mat_read = . false . ! Stella runs until t*v_{th,i}/a=tend or until istep=nstep tend = - 1.0 nstep = - 1 ! Set the available wall time in seconds, 5 minutes before the wall, stella will make a clean exit avail_cpu_time = 1.e10 ! code_dt needs to stay within [cfl_dt*cfl_cushion_upper, cfl_dt*cfl_cushion_lower] ! code_dt can be increased if cfl_dt increases, however, never increase above delt_max (=delt by default) ! Exit stella if code_dt < delt_min (e.g. when the code blows up) cfl_cushion_upper = 0.5 ! Stay a factor of 2 under the CFL condition, otherwise it might run out of control cfl_cushion_middle = 0.25 ! If code_dt>cfl_dt/2 or code_dt<cfl_dt/100000, set code_dt to cfl_dt/4 cfl_cushion_lower = 0.00001 ! Default is very low to not trigger it. delt_max = - 1 delt_min = 1.e-10 ! The response matrix is solved with a none, local or global scheme, local seems to be the most efficient lu_option = 'default' ! Overwrite the default input parameters by those specified in the input file in_file = input_unit_exist ( \"knobs\" , knexist ) if ( knexist ) read ( unit = in_file , nml = knobs ) ierr = error_unit () call get_option_value & ( delt_option , deltopts , delt_option_switch , ierr , & \"delt_option in knobs\" ) call get_option_value & ( lu_option , lu_opts , lu_option_switch , ierr , & \"lu_option in knobs\" ) ! Abort if neither tend nor nstep are set if ( tend < 0 . and . nstep < 0 ) then ierr = error_unit () write ( ierr , * ) '' write ( ierr , * ) 'Please specify either <nstep> or <tend> in the <knobs> namelist.' write ( ierr , * ) 'Aborting.' write ( * , * ) '' write ( * , * ) 'Please specify either <nstep> or <tend> in the <knobs> namelist.' write ( * , * ) 'Aborting.' error = . true . end if ! Abort if cfl_cushion_lower>cfl_cushion_upper or if cfl_cushion_lower==cfl_cushion_upper if (( cfl_cushion_lower > cfl_cushion_upper - 0.001 ) & . or . ( cfl_cushion_middle > cfl_cushion_upper - 0.001 ) & . or . ( cfl_cushion_middle < cfl_cushion_lower + 0.001 )) then ierr = error_unit () write ( ierr , * ) '' write ( ierr , * ) 'Please make sure that <cfl_cushion_upper> is bigger than <cfl_cushion_lower>,' write ( ierr , * ) 'and that <cfl_cushion_middle> lies in between <cfl_cushion_upper> and <cfl_cushion_lower>.' write ( ierr , * ) 'Aborting.' write ( * , * ) '' write ( * , * ) 'Please make sure that <cfl_cushion_upper> is bigger than <cfl_cushion_lower>,' write ( * , * ) 'and that <cfl_cushion_middle> lies in between <cfl_cushion_upper> and <cfl_cushion_lower>.' write ( * , * ) 'Aborting.' error = . true . end if if ( radial_variation . and . maxwellian_normalization ) then write ( * , * ) '!!!WARNING!!!' write ( * , * ) 'maxwellian_normalization is not currently supported for use with radial_variation.' write ( * , * ) 'forcing maxwellian_normalization = F.' write ( * , * ) '!!!WARNING!!!' maxwellian_normalization = . false . end if if ( maxwellian_normalization . and . mirror_semi_lagrange ) then write ( * , * ) '!!!WARNING!!!' write ( * , * ) 'maxwellian_normalization is not consistent with mirror_semi_lagrange = T.' write ( * , * ) 'forcing mirror_semi_lagrange = F.' write ( * , * ) '!!!WARNING!!!' mirror_semi_lagrange = . false . end if if ( fapar > - 1.0 . or . fbpar > - 1.0 ) then write ( * , * ) '!!!WARNING!!!' write ( * , * ) 'fapar and fbpar are deprecated:' write ( * , * ) 'use include_apar and include_bpar instead in namelist physics_flags.' if ( fapar > epsilon ( 0.0 )) then write ( * , * ) 'to include apar, set include_apar = .true.' end if if ( fbpar > epsilon ( 0.0 )) then write ( * , * ) 'to include bpar, set include_bpar = .true.' end if write ( * , * ) 'Aborting simulation.' write ( * , * ) '!!!WARNING!!!' error = . true . end if ! semi-lagrange advance of mirror term is not supported for EM simulations if ( include_apar . and . mirror_semi_lagrange ) then write ( * , * ) '!!!WARNING!!!' write ( * , * ) 'mirror_semi_lagrange = .true. is not supported for electromagnetic simulations.' write ( * , * ) 'forcing mirror_semi_lagrange = .false.' write ( * , * ) '!!!WARNING!!!' mirror_semi_lagrange = . false . end if if ( drifts_implicit ) then if (. not . stream_implicit ) then write ( * , * ) '!!!WARNING!!!' write ( * , * ) 'drifts_implicit = T requires stream_implicit = T.' write ( * , * ) 'forcing drifts_implicit = F.' write ( * , * ) '!!!WARNING!!!' drifts_implicit = . false . else if (. not . include_parallel_streaming ) then write ( * , * ) '!!!WARNING!!!' write ( * , * ) 'drifts_implicit = T requires include_parallel_streaming = T.' write ( * , * ) 'forcing drifts_implicit = F.' write ( * , * ) '!!!WARNING!!!' drifts_implicit = . false . end if if ( rhostar > epsilon ( 0.0 )) then write ( * , * ) '!!!WARNING!!!' write ( * , * ) 'drifts_implicit = T, coupled with rhostar > 0, has been observed' write ( * , * ) 'to lead to numerical instability.  unless you know what you are doing,' write ( * , * ) 'it is suggested that you set drifts_implicit = F or rhostar = 0.' write ( * , * ) '!!!WARNING!!!' end if end if end if ! Exit stella if we ran into an error call broadcast ( error ) if ( error ) call mp_abort ( 'Aborting in run_parameters.f90' ) call broadcast ( fields_kxkyz ) call broadcast ( delt_option_switch ) call broadcast ( delt ) call broadcast ( lu_option_switch ) call broadcast ( cfl_cushion_upper ) call broadcast ( cfl_cushion_middle ) call broadcast ( cfl_cushion_lower ) call broadcast ( delt_max ) call broadcast ( delt_min ) call broadcast ( fphi ) call broadcast ( stream_implicit ) call broadcast ( mirror_implicit ) call broadcast ( drifts_implicit ) call broadcast ( driftkinetic_implicit ) call broadcast ( maxwellian_inside_zed_derivative ) call broadcast ( mirror_semi_lagrange ) call broadcast ( mirror_linear_interp ) call broadcast ( stream_matrix_inversion ) call broadcast ( use_deltaphi_for_response_matrix ) call broadcast ( maxwellian_normalization ) call broadcast ( zed_upwind ) call broadcast ( vpa_upwind ) call broadcast ( time_upwind ) call broadcast ( nstep ) call broadcast ( tend ) call broadcast ( avail_cpu_time ) call broadcast ( rng_seed ) call broadcast ( ky_solve_radial ) call broadcast ( ky_solve_real ) call broadcast ( mat_gen ) call broadcast ( mat_read ) ! include_apar broadcast in case it is reset according to specification of ! (deprecated) fapar variable ! call broadcast(include_apar) ! calculate some useful derived quantities that are used repeatedly across modules time_upwind_plus = 0.5 * ( 1.0 + time_upwind ) time_upwind_minus = 0.5 * ( 1.0 - time_upwind ) zed_upwind_plus = 0.5 * ( 1.0 + zed_upwind ) zed_upwind_minus = 0.5 * ( 1.0 - zed_upwind ) if (. not . include_mirror ) mirror_implicit = . false . if ( driftkinetic_implicit ) then stream_implicit = . false . else if ( stream_implicit . and . full_flux_surface ) then stream_implicit = . false . write ( * , * ) write ( * , * ) \"!!!WARNING!!!\" write ( * , * ) \"The option stream_implicit=T is not supported for full_flux_surface=T.\" write ( * , * ) \"Setting driftkinetic_implicit=T instead.\" write ( * , * ) \"!!!WARNING!!!\" write ( * , * ) driftkinetic_implicit = . true . end if if ( mirror_implicit . or . stream_implicit . or . driftkinetic_implicit . or . drifts_implicit ) then fully_explicit = . false . else fully_explicit = . true . end if if ( mirror_implicit . and . stream_implicit . and . drifts_implicit . and . . not . nonlinear ) then fully_implicit = . true . else fully_implicit = . false . end if !> print warning messages and override inconsistent or unsupported options for full_flux_surface = T if ( full_flux_surface ) then if ( fields_kxkyz ) then write ( * , * ) write ( * , * ) '!!!WARNING!!!' write ( * , * ) 'The option fields_kxkyz=T is not currently supported for full_flux_surface=T.' write ( * , * ) 'Forcing fields_kxkyz=F.' write ( * , * ) '!!!WARNING!!!' write ( * , * ) fields_kxkyz = . false . end if if ( mirror_semi_lagrange ) then write ( * , * ) write ( * , * ) '!!!WARNING!!!' write ( * , * ) 'The option mirror_semi_lagrange=T is not consistent with full_flux_surface=T.' write ( * , * ) 'Forcing mirror_semi_lagrange=F.' write ( * , * ) '!!!WARNING!!!' mirror_semi_lagrange = . false . end if ! the full flux surface implementation relies on the use of gnorm = g / F_Maxwellian ! as the evolved pdf if ( full_flux_surface ) then maxwellian_normalization = . true . end if end if end subroutine read_parameters subroutine finish_run_parameters implicit none initialized = . false . end subroutine finish_run_parameters end module run_parameters","tags":"","loc":"sourcefile/run_parameters.f90.html"},{"title":"vpamu_grids.f90 – stella","text":"Source Code module vpamu_grids implicit none public :: init_vpamu_grids , finish_vpamu_grids public :: read_vpamu_grids_parameters public :: calculate_velocity_integrals public :: integrate_vmu , integrate_species public :: integrate_species_ffs , integrate_vmu_ffs public :: integrate_mu public :: vpa , nvgrid , nvpa public :: wgts_vpa , dvpa public :: mu , nmu , wgts_mu , wgts_mu_bare , dmu public :: dmu_ghost , dmu_cell , mu_cell public :: maxwell_vpa , maxwell_mu , ztmax public :: maxwell_fac public :: int_unit , int_vpa2 , int_vperp2 , int_vfrth public :: vperp2 public :: equally_spaced_mu_grid public :: set_vpa_weights logical :: vpamu_initialized = . false . integer :: nvgrid , nvpa integer :: nmu real :: vpa_max , vperp_max ! arrays that are filled in vpamu_grids real , dimension (:), allocatable :: vpa , wgts_vpa , wgts_vpa_default , wgts_mu_bare real , dimension (:), allocatable :: mu , maxwell_fac real , dimension (:, :), allocatable :: maxwell_vpa real , dimension (:, :, :), allocatable :: int_unit , int_vpa2 , int_vperp2 , int_vfrth real , dimension (:, :, :), allocatable :: wgts_mu real , dimension (:, :, :, :), allocatable :: maxwell_mu real , dimension (:, :), allocatable :: ztmax real :: dvpa real , dimension (:), allocatable :: dmu real , dimension (:), allocatable :: dmu_ghost , dmu_cell , mu_cell complex , dimension (:), allocatable :: rbuffer logical :: equally_spaced_mu_grid , conservative_wgts_vpa ! vpa-mu related arrays that are declared here ! but allocated and filled elsewhere because they depend on z, etc. real , dimension (:, :, :), allocatable :: vperp2 interface integrate_species module procedure integrate_species_vmu module procedure integrate_species_vmu_single module procedure integrate_species_vmu_single_real module procedure integrate_species_vmu_block_complex module procedure integrate_species_vmu_block_real end interface interface integrate_vmu module procedure integrate_vmu_local_real module procedure integrate_vmu_local_complex module procedure integrate_vmu_vmulo_complex module procedure integrate_vmu_vmulo_ivmu_only_real end interface interface integrate_mu module procedure integrate_mu_local module procedure integrate_mu_nonlocal end interface contains subroutine read_vpamu_grids_parameters use file_utils , only : input_unit_exist use mp , only : proc0 , broadcast implicit none namelist / vpamu_grids_parameters / nvgrid , nmu , vpa_max , vperp_max , & equally_spaced_mu_grid , conservative_wgts_vpa integer :: in_file logical :: exist if ( proc0 ) then nvgrid = 24 vpa_max = 3.0 nmu = 12 vperp_max = 3.0 equally_spaced_mu_grid = . false . conservative_wgts_vpa = . false . in_file = input_unit_exist ( \"vpamu_grids_parameters\" , exist ) if ( exist ) read ( unit = in_file , nml = vpamu_grids_parameters ) end if call broadcast ( nvgrid ) call broadcast ( vpa_max ) call broadcast ( nmu ) call broadcast ( vperp_max ) call broadcast ( equally_spaced_mu_grid ) call broadcast ( conservative_wgts_vpa ) nvpa = 2 * nvgrid end subroutine read_vpamu_grids_parameters subroutine init_vpamu_grids use species , only : spec , nspec implicit none if ( vpamu_initialized ) return vpamu_initialized = . true . !> set up the vpa grid points and integration weights call init_vpa_grid !> set up the mu grid points and integration weights call init_mu_grid if (. not . allocated ( maxwell_fac )) then allocate ( maxwell_fac ( nspec )); maxwell_fac = 1.0 end if !> maxwell_fac = 1 unless radially global maxwell_fac = spec % dens / spec % dens_psi0 * ( spec % temp_psi0 / spec % temp ) ** 1.5 end subroutine init_vpamu_grids subroutine init_vpa_grid use mp , only : mp_abort use constants , only : pi use species , only : spec , nspec use run_parameters , only : maxwellian_normalization implicit none integer :: iv , idx , iseg , nvpa_seg real :: del if (. not . allocated ( vpa )) then !> vpa is the parallel velocity at grid points allocate ( vpa ( nvpa )); vpa = 0.0 !> wgts_vpa are the integration weights assigned !> to the parallel velocity grid points allocate ( wgts_vpa ( nvpa )); wgts_vpa = 0.0 allocate ( wgts_vpa_default ( nvpa )); wgts_vpa_default = 0.0 !> this is the Maxwellian in vpa allocate ( maxwell_vpa ( nvpa , nspec )); maxwell_vpa = 0.0 allocate ( ztmax ( nvpa , nspec )); ztmax = 0.0 end if !> parallel velocity grid goes from -vpa_max to vpa_max, !> with no point at vpa = 0; !> the lack of a point at vpa=0 avoids treating !> the vpa=z=0 phase space location, which !> is isolated from all other phase space points !> in the absence of collisions !> equal grid spacing in vpa dvpa = 2. * vpa_max / ( nvpa - 1 ) !> obtain vpa grid for vpa > 0 do iv = nvgrid + 1 , nvpa vpa ( iv ) = real ( iv - nvgrid - 0.5 ) * dvpa end do !> fill in vpa grid for vpa < 0 vpa (: nvgrid ) = - vpa ( nvpa : nvgrid + 1 : - 1 ) !> maxwell_vpa is the equilibrium Maxwellian in vpa maxwell_vpa = exp ( - spread ( vpa * vpa , 2 , nspec ) * spread ( spec % temp_psi0 / spec % temp , 1 , nvpa )) !> ztmax is the Maxwellian in vpa, multipliedd by charge number over normalized temperature ztmax = spread ( spec % zt , 1 , nvpa ) * maxwell_vpa !> get integration weights corresponding to vpa grid points !> for now use Simpson's rule; !> i.e. subdivide grid into 3-point segments, with each segment spanning vpa_low to vpa_up !> then the contribution of each segment to the integral is !> (vpa_up - vpa_low) * (f1 + 4*f2 + f3) / 6 !> inner boundary points are used in two segments, so they get double the weight if ( nvpa < 6 ) & call mp_abort ( 'stella does not currently support nvgrid < 3.  aborting.' ) !> use simpson 3/8 rule at lower boundary and composite Simpson elsewhere del = 0.375 * dvpa wgts_vpa ( 1 ) = del wgts_vpa ( 2 : 3 ) = 3. * del wgts_vpa ( 4 ) = del !> composite simpson nvpa_seg = ( nvpa - 4 ) / 2 del = dvpa / 3. do iseg = 1 , nvpa_seg idx = 2 * ( iseg - 1 ) + 4 wgts_vpa ( idx ) = wgts_vpa ( idx ) + del wgts_vpa ( idx + 1 ) = wgts_vpa ( idx + 1 ) + 4. * del wgts_vpa ( idx + 2 ) = wgts_vpa ( idx + 2 ) + del end do !> for the sake of symmetry, do the same thing with 3/8 rule at upper boundary !> and composite elsewhere. del = 0.375 * dvpa wgts_vpa ( nvpa - 3 ) = wgts_vpa ( nvpa - 3 ) + del wgts_vpa ( nvpa - 2 : nvpa - 1 ) = wgts_vpa ( nvpa - 2 : nvpa - 1 ) + 3. * del wgts_vpa ( nvpa ) = wgts_vpa ( nvpa ) + del nvpa_seg = ( nvpa - 4 ) / 2 del = dvpa / 3. do iseg = 1 , nvpa_seg idx = 2 * ( iseg - 1 ) + 1 wgts_vpa ( idx ) = wgts_vpa ( idx ) + del wgts_vpa ( idx + 1 ) = wgts_vpa ( idx + 1 ) + 4. * del wgts_vpa ( idx + 2 ) = wgts_vpa ( idx + 2 ) + del end do !> divide by 2 to account for double-counting wgts_vpa = 0.5 * wgts_vpa / sqrt ( pi ) !> if maxwellian_normalization = .true., then the evolved pdf !> is normalized by a Maxwellian; this normalization must be accounted !> for in the velocity space integrals, so include exp(-vpa&#94;2) factor !> in the vpa weights. ! NB: the species index of maxwell_vpa is not needed for the radially local ! version of the code and would otherwise add a species index to wgts_vpa, ! so currently maxwellian_normalization is not supported for the radially global ! version of the code. if ( maxwellian_normalization ) wgts_vpa = wgts_vpa * maxwell_vpa (:, 1 ) wgts_vpa_default = wgts_vpa end subroutine init_vpa_grid subroutine set_vpa_weights ( conservative ) use constants , only : pi implicit none logical , intent ( in ) :: conservative if ( conservative ) then wgts_vpa = dvpa / sqrt ( pi ) else if ( conservative_wgts_vpa ) then ! AVB: added option for density conserving form of collision operator wgts_vpa = dvpa / sqrt ( pi ) else if ((. not . conservative_wgts_vpa ) . and . (. not . conservative )) then wgts_vpa = wgts_vpa_default end if end subroutine set_vpa_weights subroutine integrate_mu_local ( iz , g , total ) use species , only : nspec implicit none integer , intent ( in ) :: iz real , dimension (:, :), intent ( in ) :: g real , dimension (:), intent ( out ) :: total integer :: is , imu , ia total = 0. ia = 1 do is = 1 , nspec ! sum over mu do imu = 1 , nmu total ( is ) = total ( is ) + wgts_mu ( ia , iz , imu ) * g ( imu , is ) end do end do end subroutine integrate_mu_local subroutine integrate_mu_nonlocal ( iz , g , total ) use mp , only : nproc , sum_reduce use stella_layouts , only : vmu_lo use stella_layouts , only : is_idx , imu_idx , iv_idx implicit none integer , intent ( in ) :: iz real , dimension ( vmu_lo % llim_proc :), intent ( in ) :: g real , dimension (:, :), intent ( out ) :: total integer :: is , imu , iv , ivmu , ia total = 0. ia = 1 do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) iv = iv_idx ( vmu_lo , ivmu ) total ( iv , is ) = total ( iv , is ) + wgts_mu ( ia , iz , imu ) * g ( ivmu ) end do if ( nproc > 1 ) call sum_reduce ( total , 0 ) end subroutine integrate_mu_nonlocal subroutine integrate_vmu_local_real ( g , iz , total ) implicit none real , dimension (:, :), intent ( in ) :: g integer , intent ( in ) :: iz real , intent ( out ) :: total integer :: iv , imu , ia total = 0. ia = 1 do imu = 1 , nmu do iv = 1 , nvpa total = total + wgts_mu ( ia , iz , imu ) * wgts_vpa ( iv ) * g ( iv , imu ) end do end do end subroutine integrate_vmu_local_real subroutine integrate_vmu_local_complex ( g , iz , total ) implicit none complex , dimension (:, :), intent ( in ) :: g integer , intent ( in ) :: iz complex , intent ( out ) :: total integer :: iv , imu , ia total = 0. ia = 1 do imu = 1 , nmu do iv = 1 , nvpa total = total + wgts_mu ( ia , iz , imu ) * wgts_vpa ( iv ) * g ( iv , imu ) end do end do end subroutine integrate_vmu_local_complex ! integrave over v-space in vmu_lo subroutine integrate_vmu_vmulo_complex ( g , weights , total ) use mp , only : sum_allreduce use stella_layouts , only : vmu_lo , iv_idx , imu_idx , is_idx use zgrid , only : nzgrid implicit none integer :: ivmu , iv , iz , is , imu , ia complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g real , dimension (:), intent ( in ) :: weights complex , dimension (:, :, - nzgrid :, :, :), intent ( out ) :: total total = 0. ia = 1 do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) do iz = - nzgrid , nzgrid total (:, :, iz , :, is ) = total (:, :, iz , :, is ) + & wgts_mu ( ia , iz , imu ) * wgts_vpa ( iv ) * g (:, :, iz , :, ivmu ) * weights ( is ) end do end do call sum_allreduce ( total ) end subroutine integrate_vmu_vmulo_complex ! integrave over v-space in vmu_lo subroutine integrate_vmu_vmulo_ivmu_only_real ( g , ia , iz , total ) use mp , only : sum_allreduce use stella_layouts , only : vmu_lo , iv_idx , imu_idx , is_idx implicit none integer :: ivmu , iv , is , imu real , dimension ( vmu_lo % llim_proc :), intent ( in ) :: g integer , intent ( in ) :: ia , iz real , dimension (:), intent ( out ) :: total total = 0. do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) total ( is ) = total ( is ) + & wgts_mu ( ia , iz , imu ) * wgts_vpa ( iv ) * g ( ivmu ) end do call sum_allreduce ( total ) end subroutine integrate_vmu_vmulo_ivmu_only_real ! integrave over v-space and sum over species subroutine integrate_species_vmu ( g , weights , total , ia_in ) use mp , only : sum_allreduce use stella_layouts , only : vmu_lo , iv_idx , imu_idx , is_idx use zgrid , only : nzgrid , ntubes implicit none integer :: ivmu , iv , it , iz , is , imu , ia complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: g real , dimension (:), intent ( in ) :: weights integer , intent ( in ), optional :: ia_in complex , dimension (:, :, - nzgrid :, :), intent ( out ) :: total if ( present ( ia_in )) then ia = ia_in else ia = 1 end if total = 0. do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) do it = 1 , ntubes do iz = - nzgrid , nzgrid total (:, :, iz , it ) = total (:, :, iz , it ) + & wgts_mu ( ia , iz , imu ) * wgts_vpa ( iv ) * g (:, :, iz , it , ivmu ) * weights ( is ) end do end do end do call sum_allreduce ( total ) end subroutine integrate_species_vmu ! integrave over v-space and sum over species for given (ky,kx,z) point subroutine integrate_species_vmu_single ( g , iz , weights , total , ia_in , reduce_in ) use mp , only : sum_allreduce use stella_layouts , only : vmu_lo , iv_idx , imu_idx , is_idx implicit none integer :: ivmu , iv , is , imu , ia logical :: reduce complex , dimension ( vmu_lo % llim_proc :), intent ( in ) :: g integer , intent ( in ) :: iz real , dimension (:), intent ( in ) :: weights complex , intent ( out ) :: total integer , intent ( in ), optional :: ia_in logical , intent ( in ), optional :: reduce_in total = 0. if ( present ( ia_in )) then ia = ia_in else ia = 1 end if if ( present ( reduce_in )) then reduce = reduce_in else reduce = . true . end if do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) total = total + & wgts_mu ( ia , iz , imu ) * wgts_vpa ( iv ) * g ( ivmu ) * weights ( is ) end do if ( reduce ) call sum_allreduce ( total ) end subroutine integrate_species_vmu_single ! integrave over v-space and sum over species for given (ky,kx,z) point subroutine integrate_species_vmu_single_real ( g , iz , weights , total , ia_in , reduce_in ) use mp , only : sum_allreduce use stella_layouts , only : vmu_lo , iv_idx , imu_idx , is_idx implicit none integer :: ivmu , iv , is , imu , ia logical :: reduce real , dimension ( vmu_lo % llim_proc :), intent ( in ) :: g integer , intent ( in ) :: iz real , dimension (:), intent ( in ) :: weights real , intent ( out ) :: total integer , intent ( in ), optional :: ia_in logical , intent ( in ), optional :: reduce_in total = 0. if ( present ( ia_in )) then ia = ia_in else ia = 1 end if if ( present ( reduce_in )) then reduce = reduce_in else reduce = . true . end if do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) total = total + & wgts_mu ( ia , iz , imu ) * wgts_vpa ( iv ) * g ( ivmu ) * weights ( is ) end do if ( reduce ) call sum_allreduce ( total ) end subroutine integrate_species_vmu_single_real subroutine integrate_species_vmu_block_complex ( g , iz , weights , pout , ia_in , reduce_in ) use mp , only : sum_allreduce use stella_layouts , only : vmu_lo , iv_idx , imu_idx , is_idx implicit none integer :: ivmu , iv , is , imu , ia logical :: reduce complex , dimension (:, :, vmu_lo % llim_proc :), intent ( in ) :: g integer , intent ( in ) :: iz integer , intent ( in ), optional :: ia_in logical , intent ( in ), optional :: reduce_in real , dimension (:), intent ( in ) :: weights complex , dimension (:, :), intent ( out ) :: pout pout = 0. if ( present ( ia_in )) then ia = ia_in else ia = 1 end if if ( present ( reduce_in )) then reduce = reduce_in else reduce = . true . end if do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) pout = pout + wgts_mu ( ia , iz , imu ) * wgts_vpa ( iv ) * g (:, :, ivmu ) * weights ( is ) end do if ( reduce ) call sum_allreduce ( pout ) end subroutine integrate_species_vmu_block_complex subroutine integrate_species_vmu_block_real ( g , iz , weights , pout , ia_in , reduce_in ) use mp , only : sum_allreduce use stella_layouts , only : vmu_lo , iv_idx , imu_idx , is_idx implicit none integer :: ivmu , iv , is , imu , ia logical :: reduce real , dimension (:, :, vmu_lo % llim_proc :), intent ( in ) :: g integer , intent ( in ) :: iz integer , intent ( in ), optional :: ia_in logical , intent ( in ), optional :: reduce_in real , dimension (:), intent ( in ) :: weights real , dimension (:, :), intent ( out ) :: pout pout = 0. if ( present ( ia_in )) then ia = ia_in else ia = 1 end if if ( present ( reduce_in )) then reduce = reduce_in else reduce = . true . end if do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) pout = pout + wgts_mu ( ia , iz , imu ) * wgts_vpa ( iv ) * g (:, :, ivmu ) * weights ( is ) end do if ( reduce ) call sum_allreduce ( pout ) end subroutine integrate_species_vmu_block_real subroutine integrate_species_ffs ( g , weights , pout , reduce_in ) use mp , only : sum_allreduce use stella_layouts , only : vmu_lo , iv_idx , imu_idx , is_idx implicit none integer :: ivmu , iv , is , imu logical :: reduce complex , dimension (:, :, vmu_lo % llim_proc :), intent ( in ) :: g logical , intent ( in ), optional :: reduce_in real , dimension (:), intent ( in ) :: weights complex , dimension (:, :), intent ( out ) :: pout pout = 0. if ( present ( reduce_in )) then reduce = reduce_in else reduce = . true . end if do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) pout = pout + 2.0 * wgts_mu_bare ( imu ) * ( wgts_vpa ( iv ) / maxwell_vpa ( iv , is )) * g (:, :, ivmu ) * weights ( is ) end do if ( reduce ) call sum_allreduce ( pout ) end subroutine integrate_species_ffs subroutine integrate_vmu_ffs ( g , weights , ia , iz , pout , reduce_in ) use mp , only : sum_allreduce use stella_layouts , only : vmu_lo , iv_idx , imu_idx , is_idx implicit none complex , dimension ( vmu_lo % llim_proc :), intent ( in ) :: g real , dimension (:), intent ( in ) :: weights integer , intent ( in ) :: ia , iz complex , dimension (:), intent ( out ) :: pout logical , intent ( in ), optional :: reduce_in integer :: ivmu , iv , is , imu logical :: reduce pout = 0. if ( present ( reduce_in )) then reduce = reduce_in else reduce = . true . end if !> NB: for FFS, assume that there is only one flux annulus !> the inclusion of the Maxwellian term below is due to the fact that !> g/F is evolved for FFS do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) is = is_idx ( vmu_lo , ivmu ) pout ( is ) = pout ( is ) + wgts_mu ( ia , iz , imu ) * wgts_vpa ( iv ) * g ( ivmu ) * weights ( is ) end do if ( reduce ) call sum_allreduce ( pout ) end subroutine integrate_vmu_ffs subroutine finish_vpa_grid implicit none if ( allocated ( vpa )) deallocate ( vpa ) if ( allocated ( wgts_vpa )) deallocate ( wgts_vpa ) if ( allocated ( wgts_vpa_default )) deallocate ( wgts_vpa_default ) if ( allocated ( maxwell_vpa )) deallocate ( maxwell_vpa ) if ( allocated ( ztmax )) deallocate ( ztmax ) end subroutine finish_vpa_grid subroutine init_mu_grid use gauss_quad , only : get_laguerre_grids use zgrid , only : nzgrid , nztot use kt_grids , only : nalpha use species , only : spec , nspec use stella_geometry , only : bmag , bmag_psi0 use run_parameters , only : maxwellian_normalization implicit none integer :: imu real :: mu_max !> allocate arrays and initialize to zero if (. not . allocated ( mu )) then allocate ( mu ( nmu )); mu = 0.0 allocate ( wgts_mu ( nalpha , - nzgrid : nzgrid , nmu )); wgts_mu = 0.0 allocate ( wgts_mu_bare ( nmu )); wgts_mu_bare = 0.0 allocate ( maxwell_mu ( nalpha , - nzgrid : nzgrid , nmu , nspec )); maxwell_mu = 0.0 allocate ( dmu ( nmu - 1 )) allocate ( dmu_ghost ( nmu )) allocate ( mu_cell ( nmu )) allocate ( dmu_cell ( nmu )) end if !> dvpe * vpe = d(2*mu*B0) * B/2B0 if ( equally_spaced_mu_grid ) then !> first get equally spaced grid in mu with max value !> mu_max = vperp_max**2/(2*max(bmag)) mu_max = vperp_max ** 2 / ( 2. * maxval ( bmag_psi0 )) !> want first grid point at dmu/2 to avoid mu=0 special point !> dmu/2 + (nmu-1)*dmu = mu_max !> so dmu = mu_max/(nmu-1/2) dmu = mu_max / ( nmu - 0.5 ) mu ( 1 ) = 0.5 * dmu ( 1 ) do imu = 2 , nmu mu ( imu ) = mu ( 1 ) + ( imu - 1 ) * dmu ( 1 ) end do !> do simplest thing to start wgts_mu_bare = dmu ( 1 ) else !    ! use Gauss-Laguerre quadrature in 2*mu*bmag(z=0) ! use Gauss-Laguerre quadrature in 2*mu*min(bmag)*max( call get_laguerre_grids ( mu , wgts_mu_bare ) if ( vperp_max < 0 ) vperp_max = sqrt ( mu ( nmu )) wgts_mu_bare = wgts_mu_bare * exp ( mu ) / ( 2. * minval ( bmag_psi0 ) * mu ( nmu ) / vperp_max ** 2 ) !    mu = mu/(2.*bmag(1,0)) mu = mu / ( 2. * minval ( bmag_psi0 ) * mu ( nmu ) / vperp_max ** 2 ) dmu (: nmu - 1 ) = mu ( 2 :) - mu (: nmu - 1 ) !> leave dmu(nmu) uninitialized. should never be used, so want !> valgrind or similar to return error if it is end if !> maxwell_mu is the mu part of the v-space Maxwellian maxwell_mu = exp ( - 2. * spread ( spread ( spread ( mu , 1 , nalpha ), 2 , nztot ) * spread ( bmag , 3 , nmu ), 4 , nspec ) & * spread ( spread ( spread ( spec % temp_psi0 / spec % temp , 1 , nalpha ), 2 , nztot ), 3 , nmu )) !> factor of 2. necessary to account for 2pi from !> integration over gyro-angle and 1/pi&#94;(3/2) normalization !> of velocity space Jacobian wgts_mu = 2. * spread ( spread ( wgts_mu_bare , 1 , nalpha ), 2 , nztot ) * spread ( bmag , 3 , nmu ) !> if maxwellian_normalization, the evolved pdf is normalized by a Maxwwellian; !> in this case, the velocity integration must account for the Maxwellian. ! NB: the species index on maxwell_mu is only needed for radially global simulations, ! which are not currently supported for maxwellian_normalization = .true. if ( maxwellian_normalization ) wgts_mu = wgts_mu * maxwell_mu (:, :, :, 1 ) !> add ghost cell at mu=0 and beyond mu_max for purposes of differentiation !> note assuming here that grid spacing for ghost cell is equal to !> grid spacing for last non-ghost cell dmu_ghost (: nmu - 1 ) = dmu ; dmu_ghost ( nmu ) = dmu ( nmu - 1 ) !> this is mu at cell centres (including to left and right of mu grid boundary points) mu_cell (: nmu - 1 ) = 0.5 * ( mu (: nmu - 1 ) + mu ( 2 :)) mu_cell ( nmu ) = mu ( nmu ) + 0.5 * dmu ( nmu - 1 ) !> this is mu_{j+1/2} - mu_{j-1/2} dmu_cell ( 1 ) = mu_cell ( 1 ) dmu_cell ( 2 :) = mu_cell ( 2 :) - mu_cell (: nmu - 1 ) end subroutine init_mu_grid subroutine finish_mu_grid implicit none if ( allocated ( mu )) deallocate ( mu ) if ( allocated ( mu_cell )) deallocate ( mu_cell ) if ( allocated ( wgts_mu )) deallocate ( wgts_mu ) if ( allocated ( wgts_mu_bare )) deallocate ( wgts_mu_bare ) if ( allocated ( maxwell_mu )) deallocate ( maxwell_mu ) if ( allocated ( dmu )) deallocate ( dmu ) if ( allocated ( dmu_cell )) deallocate ( dmu_cell ) if ( allocated ( dmu_ghost )) deallocate ( dmu_ghost ) if ( allocated ( rbuffer )) deallocate ( rbuffer ) end subroutine finish_mu_grid subroutine calculate_velocity_integrals use zgrid , only : nzgrid use species , only : nspec implicit none real , dimension ( nvpa , nmu ) :: moment integer :: ia , is , iz ia = 1 is = 1 if (. not . allocated ( int_unit )) allocate ( int_unit ( 1 , - nzgrid : nzgrid , nspec )) if (. not . allocated ( int_vpa2 )) allocate ( int_vpa2 ( 1 , - nzgrid : nzgrid , nspec )) if (. not . allocated ( int_vperp2 )) allocate ( int_vperp2 ( 1 , - nzgrid : nzgrid , nspec )) if (. not . allocated ( int_vfrth )) allocate ( int_vfrth ( 1 , - nzgrid : nzgrid , nspec )) do is = 1 , nspec do iz = - nzgrid , nzgrid moment = spread ( maxwell_mu ( ia , iz , :, is ), 1 , nvpa ) * spread ( maxwell_vpa (:, is ), 2 , nmu ) call integrate_vmu ( moment , iz , int_unit ( ia , iz , is )) moment = spread ( maxwell_mu ( ia , iz , :, is ), 1 , nvpa ) * spread ( vpa (:) ** 2 * maxwell_vpa (:, is ), 2 , nmu ) call integrate_vmu ( moment , iz , int_vpa2 ( ia , iz , is )) moment = spread ( vperp2 ( ia , iz , :) * maxwell_mu ( ia , iz , :, is ), 1 , nvpa ) * spread ( maxwell_vpa (:, is ), 2 , nmu ) call integrate_vmu ( moment , iz , int_vperp2 ( ia , iz , is )) moment = spread ( maxwell_mu ( ia , iz , :, is ), 1 , nvpa ) * spread ( maxwell_vpa (:, is ), 2 , nmu ) moment = moment * ( spread ( vpa ** 2 , 2 , nmu ) + spread ( vperp2 ( ia , iz , :), 1 , nvpa )) ** 2 call integrate_vmu ( moment , iz , int_vfrth ( ia , iz , is )) end do end do end subroutine calculate_velocity_integrals subroutine finish_vpamu_grids implicit none call finish_vpa_grid call finish_mu_grid if ( allocated ( maxwell_fac )) deallocate ( maxwell_fac ) if ( allocated ( int_unit )) deallocate ( int_unit ) if ( allocated ( int_vpa2 )) deallocate ( int_vpa2 ) if ( allocated ( int_vperp2 )) deallocate ( int_vperp2 ) if ( allocated ( int_vfrth )) deallocate ( int_vfrth ) vpamu_initialized = . false . end subroutine finish_vpamu_grids end module vpamu_grids","tags":"","loc":"sourcefile/vpamu_grids.f90.html"},{"title":"system_fortran.fpp – stella","text":"Source Code # include \"define.inc\" module system_fortran implicit none private public :: systemf #ifdef ISO_C_BINDING interface subroutine call_system_c ( command ) bind ( C , name = 'system' ) use , intrinsic :: iso_c_binding , only : c_char , c_int character ( kind = c_char ), intent ( in ) :: command ( * ) end subroutine call_system_c end interface #endif contains subroutine systemf ( command ) #ifdef ISO_C_BINDING use , intrinsic :: iso_c_binding , only : c_null_char implicit none character ( * ), intent ( in ) :: command call call_system_c ( command // c_null_char ) #else # if FCOMPILER == _INTEL_ !   for system call with intel compiler use ifport , only : system # endif implicit none character ( * ), intent ( in ) :: command # if FCOMPILER == _CRAY_ integer :: ierr ierr = system ( command ) #endif #endif /* ISO_C_BINDING */ end subroutine systemf end module system_fortran","tags":"","loc":"sourcefile/system_fortran.fpp.html"},{"title":"linear_solve.f90 – stella","text":"Source Code module linear_solve implicit none public :: lu_decomposition public :: lu_back_substitution public :: lu_inverse public :: imaxloc interface lu_decomposition module procedure lu_decomposition_real module procedure lu_decomposition_complex end interface interface lu_back_substitution module procedure lu_back_substitution_real module procedure lu_back_substitution_real_complex module procedure lu_back_substitution_complex module procedure lu_back_substitution_matrix_real module procedure lu_back_substitution_matrix_complex end interface interface lu_inverse module procedure lu_inverse_real module procedure lu_inverse_complex end interface contains subroutine lu_decomposition_real ( lu , idx , d ) implicit none real , dimension (:, :), intent ( in out ) :: lu integer , dimension (:), intent ( out ) :: idx real , intent ( out ) :: d real , parameter :: zero = 1.0e-20 real , dimension ( size ( lu , 1 )) :: vv real , dimension ( size ( lu , 2 )) :: dum integer :: j , n , imax n = size ( lu , 1 ) d = 1.0 vv = maxval ( abs ( lu ), dim = 2 ) if ( any ( vv == 0.0 )) & write ( * , * ) 'singular matrix in lu_decomposition' vv = 1.0 / vv do j = 1 , n imax = ( j - 1 ) + imaxloc ( vv ( j : n ) * abs ( lu ( j : n , j ))) if ( j /= imax ) then dum = lu ( imax , :) lu ( imax , :) = lu ( j , :) lu ( j , :) = dum d = - d vv ( imax ) = vv ( j ) end if idx ( j ) = imax if ( lu ( j , j ) == 0.0 ) lu ( j , j ) = zero lu ( j + 1 : n , j ) = lu ( j + 1 : n , j ) / lu ( j , j ) lu ( j + 1 : n , j + 1 : n ) = lu ( j + 1 : n , j + 1 : n ) - spread ( lu ( j + 1 : n , j ), 2 , n - j ) & * spread ( lu ( j , j + 1 : n ), 1 , n - j ) end do end subroutine lu_decomposition_real subroutine lu_decomposition_complex ( lu , idx , d ) implicit none complex , dimension (:, :), intent ( in out ) :: lu integer , dimension (:), intent ( out ) :: idx real , intent ( out ) :: d real , parameter :: zero = 1.0e-20 real , dimension ( size ( lu , 1 )) :: vv complex , dimension ( size ( lu , 2 )) :: dum integer :: j , n , imax n = size ( lu , 1 ) d = 1.0 vv = maxval ( cabs ( lu ), dim = 2 ) if ( any ( vv == 0.0 )) & write ( * , * ) 'singular matrix in lu_decomposition' vv = 1.0 / vv do j = 1 , n imax = ( j - 1 ) + imaxloc ( vv ( j : n ) * cabs ( lu ( j : n , j ))) if ( j /= imax ) then dum = lu ( imax , :) lu ( imax , :) = lu ( j , :) lu ( j , :) = dum d = - d vv ( imax ) = vv ( j ) end if idx ( j ) = imax if ( lu ( j , j ) == 0.0 ) lu ( j , j ) = zero lu ( j + 1 : n , j ) = lu ( j + 1 : n , j ) / lu ( j , j ) lu ( j + 1 : n , j + 1 : n ) = lu ( j + 1 : n , j + 1 : n ) - spread ( lu ( j + 1 : n , j ), 2 , n - j ) & * spread ( lu ( j , j + 1 : n ), 1 , n - j ) end do end subroutine lu_decomposition_complex subroutine lu_back_substitution_real ( lu , idx , b ) implicit none real , dimension (:, :), intent ( in ) :: lu integer , dimension (:), intent ( in ) :: idx real , dimension (:), intent ( in out ) :: b integer :: i , n , ii , ll real :: summ n = size ( lu , 1 ) ii = 0 do i = 1 , n ll = idx ( i ) summ = b ( ll ) b ( ll ) = b ( i ) if ( ii /= 0 ) then summ = summ - dot_product ( lu ( i , ii : i - 1 ), b ( ii : i - 1 )) else if ( summ /= 0.0 ) then ii = i end if b ( i ) = summ end do do i = n , 1 , - 1 b ( i ) = ( b ( i ) - dot_product ( lu ( i , i + 1 : n ), b ( i + 1 : n ))) / lu ( i , i ) end do end subroutine lu_back_substitution_real subroutine lu_back_substitution_real_complex ( lu , idx , b ) implicit none real , dimension (:, :), intent ( in ) :: lu integer , dimension (:), intent ( in ) :: idx complex , dimension (:), intent ( in out ) :: b integer :: i , n , ii , ll complex :: summ !! The dot products we use below automatically take the complex conjugate of its !! first argument, which we do not want here. Hence the use of conjg to undo this n = size ( lu , 1 ) ii = 0 do i = 1 , n ll = idx ( i ) summ = b ( ll ) b ( ll ) = b ( i ) if ( ii /= 0 ) then summ = summ - dot_product ( lu ( i , ii : i - 1 ), b ( ii : i - 1 )) else if ( summ /= 0.0 ) then ii = i end if b ( i ) = summ end do do i = n , 1 , - 1 b ( i ) = ( b ( i ) - dot_product ( lu ( i , i + 1 : n ), b ( i + 1 : n ))) / lu ( i , i ) end do end subroutine lu_back_substitution_real_complex subroutine lu_back_substitution_complex ( lu , idx , b ) implicit none complex , dimension (:, :), intent ( in ) :: lu integer , dimension (:), intent ( in ) :: idx complex , dimension (:), intent ( in out ) :: b integer :: i , n , ii , ll complex :: summ !! The dot products we use below automatically take the complex conjugate of its !! first argument, which we do not want here. Hence the use of conjg to undo this n = size ( lu , 1 ) ii = 0 do i = 1 , n ll = idx ( i ) summ = b ( ll ) b ( ll ) = b ( i ) if ( ii /= 0 ) then summ = summ - dot_product ( conjg ( lu ( i , ii : i - 1 )), b ( ii : i - 1 )) else if ( summ /= 0.0 ) then ii = i end if b ( i ) = summ end do do i = n , 1 , - 1 b ( i ) = ( b ( i ) - dot_product ( conjg ( lu ( i , i + 1 : n )), b ( i + 1 : n ))) / lu ( i , i ) end do end subroutine lu_back_substitution_complex subroutine lu_back_substitution_matrix_real ( lu , idx , b ) implicit none real , dimension (:, :), intent ( in ) :: lu integer , dimension (:), intent ( in ) :: idx real , dimension (:, :), intent ( in out ) :: b integer :: i , j , n , ii , ll real :: summ n = size ( lu , 1 ) ii = 0 do j = 1 , n do i = 1 , n ll = idx ( i ) summ = b ( ll , j ) b ( ll , j ) = b ( i , j ) if ( ii /= 0 ) then summ = summ - dot_product ( lu ( i , ii : i - 1 ), b ( ii : i - 1 , j )) else if ( summ /= 0.0 ) then ii = i end if b ( i , j ) = summ end do do i = n , 1 , - 1 b ( i , j ) = ( b ( i , j ) - dot_product ( lu ( i , i + 1 : n ), b ( i + 1 : n , j ))) / lu ( i , i ) end do end do end subroutine lu_back_substitution_matrix_real subroutine lu_back_substitution_matrix_complex ( lu , idx , b ) implicit none complex , dimension (:, :), intent ( in ) :: lu integer , dimension (:), intent ( in ) :: idx complex , dimension (:, :), intent ( in out ) :: b integer :: i , j , n , ii , ll complex :: summ !! The dot products we use below automatically take the complex conjugate of its !! first argument, which we do not want here. Hence the use of conjg to undo this n = size ( lu , 1 ) ii = 0 do j = 1 , n do i = 1 , n ll = idx ( i ) summ = b ( ll , j ) b ( ll , j ) = b ( i , j ) if ( ii /= 0 ) then summ = summ - dot_product ( conjg ( lu ( i , ii : i - 1 )), b ( ii : i - 1 , j )) else if ( summ /= 0.0 ) then ii = i end if b ( i , j ) = summ end do do i = n , 1 , - 1 b ( i , j ) = ( b ( i , j ) - dot_product ( conjg ( lu ( i , i + 1 : n )), b ( i + 1 : n , j ))) / lu ( i , i ) end do end do end subroutine lu_back_substitution_matrix_complex !! !! One shouldn't need to compute the inverse of a matrix if solving the linear equation A.x = y; !! a simple back substitution should suffice. !! !! Only compute the inverse of A when absolutely necessary! !! subroutine lu_inverse_real ( lu , idx , inverse ) implicit none real , dimension (:, :), intent ( in ) :: lu integer , dimension (:), intent ( in ) :: idx real , dimension (:, :), intent ( out ) :: inverse integer :: i , n n = size ( lu , 1 ) inverse = 0.0 do i = 1 , n inverse ( i , i ) = 1.0 end do do i = 1 , n call lu_back_substitution ( lu , idx , inverse (:, i )) end do end subroutine lu_inverse_real subroutine lu_inverse_complex ( lu , idx , inverse ) implicit none complex , dimension (:, :), intent ( in ) :: lu integer , dimension (:), intent ( in ) :: idx complex , dimension (:, :), intent ( out ) :: inverse integer :: i , n n = size ( lu , 1 ) inverse = 0.0 do i = 1 , n inverse ( i , i ) = 1.0 end do do i = 1 , n call lu_back_substitution ( lu , idx , inverse (:, i )) end do end subroutine lu_inverse_complex function imaxloc ( array ) real , dimension (:), intent ( in ) :: array integer :: imaxloc integer , dimension ( 1 ) :: imax imax = maxloc ( array ) imaxloc = imax ( 1 ) end function imaxloc end module linear_solve","tags":"","loc":"sourcefile/linear_solve.f90.html"},{"title":"millerlocal.f90 – stella","text":"Source Code module millerlocal use common_types , only : flux_surface_type implicit none public :: init_local_defaults public :: read_local_parameters public :: communicate_parameters_multibox public :: get_local_geo public :: finish_local_geo public :: local private integer :: nzed_local real :: rhoc , rmaj , shift real :: kappa , kapprim real :: tri , triprim real :: betaprim , betadbprim real :: qinp , shat , d2qdr2 real :: rgeo real :: dpsidrho , d2psidr2 , dpsidrho_psi0 real :: psitor_lcfs real :: rhotor , drhotordrho , dIdrho , dI real :: rhoc0 logical :: write_profile_variation , read_profile_variation logical :: load_psi0_variables integer :: nz , nz2pi real :: bi , dqdr , d2Idr2 real , dimension (:), allocatable :: grho , bmag , grho_psi0 , bmag_psi0 , gradpar real , dimension (:), allocatable :: gradpararc , arc real , dimension (:), allocatable :: gds2 , gds21 , gds22 real , dimension (:), allocatable :: gds23 , gds24 real , dimension (:), allocatable :: gbdrift0 , gbdrift real , dimension (:), allocatable :: cvdrift0 , cvdrift real , dimension (:), allocatable :: d2Rdth2 , d2Zdth2 , d2Rdrdth , d2Zdrdth real , dimension (:), allocatable :: gpsi , dBdrho , d2Bdrdth real , dimension (:), allocatable :: dgradpardrho , dgradparBdrho , dBdth , gradparb real , dimension (:), allocatable :: dcvdrift0drho , dgbdrift0drho , theta real , dimension (:), allocatable :: varthet , dvarthdr , gradrho_gradthet , cross , d2varthdr2 real , dimension (:), allocatable :: gradthet2 , gradalph_gradthet , gradrho_gradalph , gradalph2 real , dimension (:), allocatable :: d2Bdr2 , d2Rdr2 , d2Zdr2 , drz , drzdth real , dimension (:), allocatable :: d2Rdr2dth , d2Zdr2dth , d2gpsidr2 , dcrossdr real , dimension (:), allocatable :: dcvdriftdrho , dgbdriftdrho real , dimension (:), allocatable :: dgds2dr , dgds21dr , dgds22dr real , dimension (:), allocatable :: dgr2dr , dgpsi2dr real , dimension (:), allocatable :: dgrgt , dgt2 , dgagr , dgagt , dga2 real , dimension (:, :), allocatable :: Rr , Zr real , dimension (:), allocatable :: jacrho , delthet , djacdrho , djacrdrho real , dimension (:), allocatable :: d2jacdr2 , dRdrho , dZdrho , dRdth , dZdth real , dimension (:), allocatable :: d2R , d2Z type ( flux_surface_type ) :: local logical :: defaults_initialized = . false . contains subroutine init_local_defaults implicit none if ( defaults_initialized ) return defaults_initialized = . true . nzed_local = 128 rhoc = 0.5 rhoc0 = 0.5 rmaj = 3.0 rgeo = 3.0 qinp = 1.4 shat = 0.8 shift = 0.0 kappa = 0.0 kapprim = 0.0 tri = 0.0 triprim = 0.0 ! betaprim = -(4pi/Bref&#94;2)*d(ptot)/drho betaprim = 0.0 ! betadbprim = -(4pi/Bref&#94;2)*d&#94;2ptot/drho&#94;2 betadbprim = 0.0 d2qdr2 = 0.0 d2psidr2 = 0.0 read_profile_variation = . false . write_profile_variation = . false . load_psi0_variables = . true . ! only needed for sfincs when not using ! geo info from file rhotor = rhoc psitor_lcfs = 1.0 drhotordrho = 1.0 end subroutine init_local_defaults subroutine read_local_parameters ( nzed , nzgrid , local_out ) use file_utils , only : input_unit_exist use common_types , only : flux_surface_type implicit none type ( flux_surface_type ), intent ( out ) :: local_out integer , intent ( in ) :: nzed , nzgrid real :: dum integer :: in_file , np , j logical :: exist namelist / millergeo_parameters / rhoc , rmaj , shift , qinp , shat , & kappa , kapprim , tri , triprim , rgeo , betaprim , & betadbprim , d2qdr2 , d2psidr2 , & nzed_local , read_profile_variation , write_profile_variation call init_local_defaults in_file = input_unit_exist ( \"millergeo_parameters\" , exist ) if ( exist ) read ( unit = in_file , nml = millergeo_parameters ) local % rhoc = rhoc local % rmaj = rmaj local % rgeo = rgeo local % shift = shift local % kappa = kappa local % kapprim = kapprim local % qinp = qinp local % shat = shat local % tri = tri local % triprim = triprim local % betaprim = betaprim local % betadbprim = betadbprim local % d2qdr2 = d2qdr2 local % d2psidr2 = d2psidr2 local % zed0_fac = 1.0 ! following two variables are not inputs local % dr = 1.e-3 * ( rhoc / rmaj ) local % rhotor = rhotor local % psitor_lcfs = psitor_lcfs local % drhotordrho = drhotordrho local % dpsitordrho = 0.0 local % d2psitordrho2 = 0.0 ! the next three variablaes are for multibox simulations ! with radial variation local % rhoc_psi0 = rhoc local % qinp_psi0 = qinp local % shat_psi0 = shat ! first get nperiod corresponding to input number of grid points nz2pi = nzed / 2 np = ( nzgrid - nz2pi ) / nzed + 1 ! now switch to using (possible higher resolution) local grid nz2pi = nzed_local / 2 ! this is the equivalent of nzgrid on the local grid nz = nz2pi + nzed_local * ( np - 1 ) ! initialize to zero ! will be overwritten if reading in from file ! only relevant for profile variation tests ! these needs to be deallocated somewhere allocate ( d2R ( - nz : nz )) allocate ( d2Z ( - nz : nz )) allocate ( bmag_psi0 ( - nz : nz )) allocate ( grho_psi0 ( - nz : nz )) d2R = 0. ; d2Z = 0. ; dI = 0. if ( read_profile_variation ) then open ( 1002 , file = 'RZ.in' , status = 'old' ) read ( 1002 , '(12e13.5)' ) rhoc0 , dI , qinp , shat , d2qdr2 , kappa , kapprim , tri , triprim , & betaprim , betadbprim , dpsidrho_psi0 do j = - nz , nz read ( 1002 , '(5e13.5)' ) dum , d2R ( j ), d2Z ( j ), bmag_psi0 ( j ), grho_psi0 ( j ) end do close ( 1002 ) local % qinp = qinp + shat * qinp / rhoc0 * ( local % rhoc - rhoc0 ) & + 0.5 * ( local % rhoc - rhoc0 ) ** 2 * d2qdr2 local % shat = ( local % rhoc / local % qinp ) & * ( shat * qinp / rhoc0 + ( local % rhoc - rhoc0 ) * d2qdr2 ) local % kappa = kappa + kapprim * ( local % rhoc - rhoc0 ) local % tri = tri + triprim * ( local % rhoc - rhoc0 ) local % betaprim = betaprim + betadbprim * ( local % rhoc - rhoc0 ) local % rhoc_psi0 = rhoc0 local % qinp_psi0 = qinp local % shat_psi0 = shat load_psi0_variables = . false . end if local_out = local end subroutine read_local_parameters subroutine communicate_parameters_multibox ( surf , drl , drr ) use mp , only : job , scope , mp_abort , & crossdomprocs , subprocs , & send , receive use job_manage , only : njobs use common_types , only : flux_surface_type implicit none real , optional , intent ( in ) :: drl , drr type ( flux_surface_type ), intent ( inout ) :: surf real :: lrhoc , lqinp , lshat , lkappa , ltri , lbetaprim real :: rrhoc , rqinp , rshat , rkappa , rtri , rbetaprim real :: dqdr real :: rhoc_psi0 , qinp_psi0 , shat_psi0 !FLAG DSO -  I think d2psidrho2 needs to be communicated, but !            I'm unsure what quantity needs to be updated if ( job == 1 ) then dqdr = local % shat * local % qinp / local % rhoc lrhoc = local % rhoc + drl lqinp = local % qinp + drl * dqdr + 0.5 * drl ** 2 * local % d2qdr2 lshat = ( lrhoc / lqinp ) * ( dqdr + drl * local % d2qdr2 ) lkappa = kappa + drl * kapprim ltri = tri + drl * triprim lbetaprim = betaprim + drl * betadbprim rrhoc = local % rhoc + drr rqinp = local % qinp + drr * dqdr + 0.5 * drr ** 2 * local % d2qdr2 rshat = ( rrhoc / rqinp ) * ( dqdr + drr * local % d2qdr2 ) rkappa = kappa + drr * kapprim rtri = tri + drr * triprim rbetaprim = betaprim + drr * betadbprim end if call scope ( crossdomprocs ) if ( job == 1 ) then call send ( lrhoc , 0 , 120 ) call send ( lqinp , 0 , 121 ) call send ( lshat , 0 , 122 ) call send ( lkappa , 0 , 123 ) call send ( ltri , 0 , 124 ) call send ( lbetaprim , 0 , 125 ) call send ( local % rhoc , 0 , 126 ) call send ( d2R , 0 , 127 ) call send ( d2Z , 0 , 128 ) call send ( dIdrho , 0 , 129 ) call send ( rhoc , 0 , 130 ) call send ( qinp , 0 , 131 ) call send ( shat , 0 , 132 ) call send ( dpsidrho , 0 , 133 ) call send ( bmag , 0 , 134 ) call send ( grho , 0 , 135 ) call send ( rrhoc , njobs - 1 , 220 ) call send ( rqinp , njobs - 1 , 221 ) call send ( rshat , njobs - 1 , 222 ) call send ( rkappa , njobs - 1 , 223 ) call send ( rtri , njobs - 1 , 224 ) call send ( rbetaprim , njobs - 1 , 225 ) call send ( local % rhoc , njobs - 1 , 226 ) call send ( d2R , njobs - 1 , 227 ) call send ( d2Z , njobs - 1 , 228 ) call send ( dIdrho , njobs - 1 , 229 ) call send ( rhoc , njobs - 1 , 230 ) call send ( qinp , njobs - 1 , 231 ) call send ( shat , njobs - 1 , 232 ) call send ( dpsidrho , njobs - 1 , 233 ) call send ( bmag , njobs - 1 , 234 ) call send ( grho , njobs - 1 , 235 ) rhoc_psi0 = rhoc qinp_psi0 = qinp shat_psi0 = shat local % rhoc_psi0 = rhoc_psi0 local % qinp_psi0 = qinp_psi0 local % shat_psi0 = shat_psi0 elseif ( job == 0 ) then call receive ( rhoc , 1 , 120 ) call receive ( qinp , 1 , 121 ) call receive ( shat , 1 , 122 ) call receive ( kappa , 1 , 123 ) call receive ( tri , 1 , 124 ) call receive ( betaprim , 1 , 125 ) call receive ( rhoc0 , 1 , 126 ) call receive ( d2R , 1 , 127 ) call receive ( d2Z , 1 , 128 ) call receive ( dI , 1 , 129 ) call receive ( rhoc_psi0 , 1 , 130 ) call receive ( qinp_psi0 , 1 , 131 ) call receive ( shat_psi0 , 1 , 132 ) call receive ( dpsidrho_psi0 , 1 , 133 ) call receive ( bmag_psi0 , 1 , 134 ) call receive ( grho_psi0 , 1 , 135 ) local % rhoc = rhoc local % qinp = qinp local % shat = shat local % kappa = kappa local % tri = tri local % betaprim = betaprim local % rhoc_psi0 = rhoc_psi0 local % qinp_psi0 = qinp_psi0 local % shat_psi0 = shat_psi0 load_psi0_variables = . false . elseif ( job == njobs - 1 ) then call receive ( rhoc , 1 , 220 ) call receive ( qinp , 1 , 221 ) call receive ( shat , 1 , 222 ) call receive ( kappa , 1 , 223 ) call receive ( tri , 1 , 224 ) call receive ( betaprim , 1 , 225 ) call receive ( rhoc0 , 1 , 226 ) call receive ( d2R , 1 , 227 ) call receive ( d2Z , 1 , 228 ) call receive ( dI , 1 , 229 ) call receive ( rhoc_psi0 , 1 , 230 ) call receive ( qinp_psi0 , 1 , 231 ) call receive ( shat_psi0 , 1 , 232 ) call receive ( dpsidrho_psi0 , 1 , 233 ) call receive ( bmag_psi0 , 1 , 234 ) call receive ( grho_psi0 , 1 , 235 ) local % rhoc = rhoc local % qinp = qinp local % shat = shat local % kappa = kappa local % tri = tri local % betaprim = betaprim local % rhoc_psi0 = rhoc_psi0 local % qinp_psi0 = qinp_psi0 local % shat_psi0 = shat_psi0 load_psi0_variables = . false . end if surf % rhoc = local % rhoc surf % qinp = local % qinp surf % shat = local % shat surf % kappa = local % kappa surf % tri = local % tri surf % betaprim = local % betaprim surf % rhoc_psi0 = rhoc_psi0 surf % qinp_psi0 = qinp_psi0 surf % shat_psi0 = shat_psi0 call scope ( subprocs ) end subroutine communicate_parameters_multibox subroutine get_local_geo ( nzed , nzgrid , zed_in , zed_equal_arc , & dpsidrho_out , dpsidrho_psi0_out , dIdrho_out , grho_out , & bmag_out , bmag_psi0_out , & gds2_out , gds21_out , gds22_out , gds23_out , gds24_out , gradpar_out , & gbdrift0_out , gbdrift_out , cvdrift0_out , cvdrift_out , & dBdrho_out , d2Bdrdth_out , dgradpardrho_out , & btor_out , rmajor_out , & dcvdrift0drho_out , dcvdriftdrho_out , & dgbdrift0drho_out , dgbdriftdrho_out , & dgds2dr_out , dgds21dr_out , & dgds22dr_out , djacdrho_out ) use constants , only : pi use splines , only : geo_spline use file_utils , only : run_name implicit none integer , intent ( in ) :: nzed , nzgrid real , dimension ( - nzgrid :), intent ( in ) :: zed_in logical , intent ( in ) :: zed_equal_arc real , intent ( out ) :: dpsidrho_out , dpsidrho_psi0_out , dIdrho_out real , dimension ( - nzgrid :), intent ( out ) :: grho_out , & bmag_out , bmag_psi0_out , & gds2_out , gds21_out , gds22_out , gds23_out , gds24_out , & gradpar_out , gbdrift0_out , & gbdrift_out , cvdrift0_out , cvdrift_out , & dBdrho_out , d2Bdrdth_out , dgradpardrho_out , & btor_out , rmajor_out , & dcvdrift0drho_out , dcvdriftdrho_out , & dgbdrift0drho_out , dgbdriftdrho_out , & dgds2dr_out , dgds21dr_out , & dgds22dr_out , & djacdrho_out integer :: nr , np integer :: i , j real :: rmin , dum real , dimension ( 3 ) :: dr real , allocatable , dimension (:) :: zed_arc character ( len = 512 ) :: filename ! number of grid points used for radial derivatives nr = 3 ! first get nperiod corresponding to input number of grid points nz2pi = nzed / 2 np = ( nzgrid - nz2pi ) / nzed + 1 ! now switch to using (possible higher resolution) local grid nz2pi = nzed_local / 2 ! this is the equivalent of nzgrid on the local grid nz = nz2pi + nzed_local * ( np - 1 ) call allocate_arrays ( nr , nz ) dqdr = local % shat * local % qinp / local % rhoc dr ( 1 ) = - local % dr dr ( 2 ) = 0. dr ( 3 ) = local % dr do j = - nz , nz theta ( j ) = j * ( 2 * np - 1 ) * pi / real ( nz ) do i = 1 , 3 rmin = local % rhoc + dr ( i ) Rr ( i , j ) = Rpos ( rmin , theta ( j ), j ) Zr ( i , j ) = Zpos ( rmin , theta ( j ), j ) end do end do if (. not . allocated ( delthet )) allocate ( delthet ( - nz : nz - 1 )) ! get delta theta as a function of theta delthet = theta ( - nz + 1 :) - theta (: nz - 1 ) ! get dR/drho and dZ/drho call get_drho ( Rr , dRdrho ) call get_drho ( Zr , dZdrho ) ! get dR/dtheta and dZ/dtheta call get_dthet ( Rr ( 2 , :), dRdth ) call get_dthet ( Zr ( 2 , :), dZdth ) ! get second derivatives of R and Z with respect to theta call get_d2dthet2 ( Rr ( 2 , :), d2Rdth2 ) call get_d2dthet2 ( Zr ( 2 , :), d2Zdth2 ) ! get mixed theta and rho derivatives of R and Z call get_dthet ( dRdrho , d2Rdrdth ) call get_dthet ( dZdrho , d2Zdrdth ) ! get the Jacobian of the transformation from (rho,theta,zeta) to (R,Z,zeta) ! this is what I call jacr or jacrho in following comments ! as opposed to jacobian, which is for tranformation from (psi,theta,zeta) to (R,Z,zeta) call get_jacrho ! theta_integrate returns integral from 0 -> 2*pi ! note that dpsidrho here is an intermediary ! that requires manipulation to get final dpsidrho call theta_integrate ( jacrho ( - nz2pi : nz2pi ) / Rr ( 2 , - nz2pi : nz2pi ) ** 2 , dpsidrho ) dpsidrho = dpsidrho / ( 2. * pi ) ! get dpsinorm/drho = (I/2*pi*q)*int_0&#94;{2*pi} dthet jacrho/R**2 ! if using input.profiles, we are given ! dpsitordrho and must use it to compute rgeo if ( abs ( local % dpsitordrho ) > epsilon ( 0. )) then local % rgeo = local % dpsitordrho / dpsidrho dpsidrho = local % dpsitordrho / local % qinp local % d2psidr2 = ( local % d2psitordrho2 - local % dpsitordrho * local % shat / local % rhoc ) & / local % qinp ! I=Btor*R is a flux function ! bi = I/(Btor(psi,theta of Rgeo)*a) = Rgeo/a bi = local % rgeo else ! otherwise, we are given rgeo ! and must use it to compute dpsidrho ! I=Btor*R is a flux function ! bi = I/(Btor(psi,theta of Rgeo)*a) = Rgeo/a bi = local % rgeo + dI * ( rhoc - rhoc0 ) dpsidrho = dpsidrho * bi / local % qinp end if !    ! get dpsinorm/drho !    call get_dpsidrho (dpsidrho) ! get |grad rho| and |grad psi| call get_gradrho ( dpsidrho , grho ) ! quantity needed in calculation of dI/drho and djacrho/drho drz = ( dRdrho * dRdth + dZdrho * dZdth ) / jacrho call get_dthet ( drz , drzdth ) ! get dI/drho call get_dIdrho ( dpsidrho , grho , dIdrho ) dIdrho_out = dIdrho ! get djacobian/drho*dpsi/drho and djacr/drho call get_djacdrho ( dpsidrho , dIdrho , grho ) ! get d2R/drho2 and d2Z/drho2 call get_d2RZdr2 d2R = d2Rdr2 d2Z = d2Zdr2 ! get theta derivative of d2R/drho2 and d2Z/drho2 call get_dthet ( d2Rdr2 , d2Rdr2dth ) call get_dthet ( d2Zdr2 , d2Zdr2dth ) ! calculate the magnitude of B (normalized by B(psi,theta corresponding to Rgeo)) ! B/B0 = sqrt(I**2 + |grad psi|**2)/R bmag = sqrt ( bi ** 2 + gpsi ** 2 ) / Rr ( 2 , :) ! the next line is for multibox runs if ( load_psi0_variables ) then dpsidrho_psi0 = dpsidrho bmag_psi0 = bmag grho_psi0 = grho end if if ( write_profile_variation ) then open ( 1002 , file = 'RZ.out' , status = 'unknown' ) write ( 1002 , '(12e13.5)' ) local % rhoc , dIdrho , local % qinp , local % shat , local % d2qdr2 , & local % kappa , local % kapprim , & local % tri , local % triprim , & local % betaprim , local % betadbprim , dpsidrho do j = - nz , nz write ( 1002 , '(5e13.5)' ) theta ( j ), d2Rdr2 ( j ), d2Zdr2 ( j ), bmag ( j ), grho ( j ) end do close ( 1002 ) end if ! get dB/dtheta call get_dthet ( bmag , dbdth ) ! calculate b . grad theta gradpar = dpsidrho / ( bmag * jacrho ) ! b . grad B gradparb = gradpar * dBdth ! get d|grad rho|&#94;2/drho and d|grad psi|&#94;2/drho call get_dgr2dr ( dpsidrho , grho ) ! get dB/drho and d2B/drho2 call get_dBdrho ( bmag , dIdrho ) ! d (b . grad theta) / drho dgradpardrho = - gradpar * ( dBdrho / bmag + djacdrho / jacrho ) ! get d/dtheta (dB/drho) call get_dthet ( dBdrho , d2Bdrdth ) ! d(b . grad B)/drho dgradparBdrho = dgradpardrho * dBdth + gradpar * d2Bdrdth ! obtain varthet = (I/(q*(dpsi/dr)) * int_0&#94;theta dtheta' jacrho/R&#94;2 call get_varthet ( dpsidrho ) ! obtain dvarthet/drho call get_dvarthdr ( dpsidrho , dIdrho ) ! get |grad theta|&#94;2, grad r . grad theta, grad alpha . grad theta, etc. call get_graddotgrad ( dpsidrho , grho ) call get_gds ( gds2 , gds21 , gds22 , gds23 , gds24 ) ! this is (grad alpha x B) . grad theta cross = dpsidrho * ( gradrho_gradalph * gradalph_gradthet - gradalph2 * gradrho_gradthet ) ! note that the definitions of gbdrift, gbdrift0, dgbdriftdr and dgbdrift0dr ! are such that it gets multiplied by vperp2, not mu.  This is in contrast to ! Michael's GS3 notes ! this is bhat/B x (grad B/B) . grad alpha * 2 * dpsiN/drho gbdrift = 2.0 * ( - dBdrho + cross * dBdth * dpsidrho / bmag ** 2 ) / bmag ! this is bhat/B x (bhat . grad bhat) . grad alpha * 2 * dpsiN/drho ! this is assuming betaprim = 4*pi*ptot/B0&#94;2 * (-d ln ptot / drho) cvdrift = ( gbdrift + 2.0 * local % betaprim / bmag ** 2 ) ! this is 2 *(bhat/B x grad B / B) . (grad q) * dpsiN/drho / (bhat . grad B) ! same as usual GS2 definition once bhat . grad B is added in below cvdrift0 = - 2. * bi * dqdr / bmag ** 2 ! this is 2*dpsiN/drho times the rho derivative (bhat/B x grad B / B) . (grad q) dcvdrift0drho = cvdrift0 * ( dgradparbdrho + gradparb * ( dIdrho / bi - 2. * dBdrho / bmag - local % d2psidr2 / dpsidrho )) & - 2. * bi * gradparb * local % d2qdr2 / bmag ** 2 ! this is 2*dpsiN/drho/B times the rho derivative of (bhat x gradB/B) . (grad q) ! note that there's an extra factor of 1/B that's not expanded due to v_perp -> mu dgbdrift0drho = cvdrift0 * ( dgradparbdrho + gradparb * ( dIdrho / bi - dBdrho / bmag - local % d2psidr2 / dpsidrho )) & - 2. * bi * gradparb * local % d2qdr2 / bmag ** 2 cvdrift0 = cvdrift0 * gradparb ! this is 2 * dpsiN/drho * (bhat/B x gradB/B) . (grad q) gbdrift0 = cvdrift0 ! get d&#94;2I/drho&#94;2 and d&#94;2 Jac / dr&#94;2 call get_d2Idr2_d2jacdr2 ( grho , dIdrho ) ! get d&#94;2varhteta/drho&#94;2 call get_d2varthdr2 ( dpsidrho , dIdrho ) ! get d2B/drho&#94;2 call get_d2Bdr2 ( bmag , dIdrho ) ! get d/dr [(grad alpha x B) . grad theta] call get_dcrossdr ( dpsidrho , dIdrho , grho ) ! dgbdriftdrho is d/drho [(bhat/B x (grad B) . grad alpha) * 2 * dpsiN/drho] / B ! note that there's an extra factor of 1/B that's not expanded due to v_perp -> mu dgbdriftdrho = 2.0 * ( local % d2psidr2 * dBdrho / dpsidrho - d2Bdr2 & + dpsidrho * ( dcrossdr * dBdth + cross * ( d2Bdrdth - 2. * dBdth * dBdrho / bmag )) / bmag ** 2 ) / bmag ! dcvdriftdrho is d/drho (bhat/B x [bhat . grad bhat] . grad alpha) * 2 * dpsiN/drho dcvdriftdrho = dgbdriftdrho - gbdrift * dBdrho / bmag & + 2.0 * local % betadbprim / bmag ** 2 - 4.0 * local % betaprim * dBdrho / bmag ** 3 & - 2.0 * local % betaprim * local % d2psidr2 / dpsidrho !the next two sets of lines are corrections needed for the side boxes in a multibox simulation !gbdrift  = gbdrift *(dpsidrho_psi0/dpsidrho)*(bmag/bmag_psi0) !gbdrift0 = gbdrift0*(dpsidrho_psi0/dpsidrho)*(bmag/bmag_psi0) gbdrift = gbdrift * ( dpsidrho_psi0 / dpsidrho ) gbdrift0 = gbdrift0 * ( dpsidrho_psi0 / dpsidrho ) cvdrift = cvdrift * ( dpsidrho_psi0 / dpsidrho ) cvdrift0 = cvdrift0 * ( dpsidrho_psi0 / dpsidrho ) !dgbdriftdrho  = dgbdriftdrho *(dpsidrho_psi0/dpsidrho)*(bmag/bmag_psi0) !dgbdrift0drho = dgbdrift0drho*(dpsidrho_psi0/dpsidrho)*(bmag/bmag_psi0) dgbdriftdrho = dgbdriftdrho * ( dpsidrho_psi0 / dpsidrho ) dgbdrift0drho = dgbdrift0drho * ( dpsidrho_psi0 / dpsidrho ) dcvdriftdrho = dcvdriftdrho * ( dpsidrho_psi0 / dpsidrho ) dcvdrift0drho = dcvdrift0drho * ( dpsidrho_psi0 / dpsidrho ) ! interpolate here if ( zed_equal_arc ) then call theta_integrate ( 1. / gradpar , dum ) gradpararc = ( theta ( nz ) - theta ( - nz )) / (( 2 * np - 1 ) * dum ) call theta_integrate_indef ( gradpararc / gradpar , arc ) allocate ( zed_arc ( - nzgrid : nzgrid )) call geo_spline ( arc , theta , zed_in , zed_arc ) call geo_spline ( theta , grho_psi0 , zed_arc , grho_out ) !grho is used to normalize fluxes call geo_spline ( theta , bmag , zed_arc , bmag_out ) call geo_spline ( theta , bmag_psi0 , zed_arc , bmag_psi0_out ) call geo_spline ( theta , gds2 , zed_arc , gds2_out ) call geo_spline ( theta , gds21 , zed_arc , gds21_out ) call geo_spline ( theta , gds22 , zed_arc , gds22_out ) call geo_spline ( theta , gds21 , zed_arc , gds23_out ) call geo_spline ( theta , gds21 , zed_arc , gds24_out ) call geo_spline ( theta , gradpararc , zed_arc , gradpar_out ) call geo_spline ( theta , gbdrift , zed_arc , gbdrift_out ) call geo_spline ( theta , gbdrift0 , zed_arc , gbdrift0_out ) call geo_spline ( theta , cvdrift , zed_arc , cvdrift_out ) call geo_spline ( theta , cvdrift0 , zed_arc , cvdrift0_out ) call geo_spline ( theta , dBdrho , zed_arc , dBdrho_out ) call geo_spline ( theta , d2Bdrdth , zed_arc , d2Bdrdth_out ) call geo_spline ( theta , dgradpardrho , zed_arc , dgradpardrho_out ) call geo_spline ( theta , Rr ( 2 , :), zed_arc , rmajor_out ) call geo_spline ( theta , dcvdriftdrho , zed_arc , dcvdriftdrho_out ) call geo_spline ( theta , dgbdriftdrho , zed_arc , dgbdriftdrho_out ) call geo_spline ( theta , dcvdrift0drho , zed_arc , dcvdrift0drho_out ) call geo_spline ( theta , dgbdrift0drho , zed_arc , dgbdrift0drho_out ) call geo_spline ( theta , dgds2dr , zed_arc , dgds2dr_out ) call geo_spline ( theta , dgds21dr , zed_arc , dgds21dr_out ) call geo_spline ( theta , dgds22dr , zed_arc , dgds22dr_out ) call geo_spline ( theta , djacdrho / dpsidrho , zed_arc , djacdrho_out ) deallocate ( zed_arc ) else call geo_spline ( theta , grho_psi0 , zed_in , grho_out ) !grho is used to normalize fluxes call geo_spline ( theta , bmag , zed_in , bmag_out ) call geo_spline ( theta , bmag_psi0 , zed_in , bmag_psi0_out ) call geo_spline ( theta , gds2 , zed_in , gds2_out ) call geo_spline ( theta , gds21 , zed_in , gds21_out ) call geo_spline ( theta , gds22 , zed_in , gds22_out ) call geo_spline ( theta , gds21 , zed_in , gds23_out ) call geo_spline ( theta , gds21 , zed_in , gds24_out ) call geo_spline ( theta , gradpar , zed_in , gradpar_out ) call geo_spline ( theta , gbdrift , zed_in , gbdrift_out ) call geo_spline ( theta , gbdrift0 , zed_in , gbdrift0_out ) call geo_spline ( theta , cvdrift , zed_in , cvdrift_out ) call geo_spline ( theta , cvdrift0 , zed_in , cvdrift0_out ) call geo_spline ( theta , dBdrho , zed_in , dBdrho_out ) call geo_spline ( theta , d2Bdrdth , zed_in , d2Bdrdth_out ) call geo_spline ( theta , dgradpardrho , zed_in , dgradpardrho_out ) call geo_spline ( theta , Rr ( 2 , :), zed_in , rmajor_out ) call geo_spline ( theta , dcvdriftdrho , zed_in , dcvdriftdrho_out ) call geo_spline ( theta , dgbdriftdrho , zed_in , dgbdriftdrho_out ) call geo_spline ( theta , dcvdrift0drho , zed_in , dcvdrift0drho_out ) call geo_spline ( theta , dgbdrift0drho , zed_in , dgbdrift0drho_out ) call geo_spline ( theta , dgds2dr , zed_in , dgds2dr_out ) call geo_spline ( theta , dgds21dr , zed_in , dgds21dr_out ) call geo_spline ( theta , dgds22dr , zed_in , dgds22dr_out ) call geo_spline ( theta , djacdrho / dpsidrho , zed_in , djacdrho_out ) end if ! get the toroidal component of the magnetic field ! btor = B_toroidal/Bref = I/R Bref = rgeo * a/R btor_out = bi / rmajor_out dpsidrho_out = dpsidrho dpsidrho_psi0_out = dpsidrho_psi0 filename = \"millerlocal.\" // trim ( run_name ) // \".input\" open ( 1002 , file = trim ( filename ), status = 'unknown' ) write ( 1002 , '(5a16)' ) '#1.rhoc' , '2.rmaj' , '3.rgeo' , '4.shift' , '5.qinp' write ( 1002 , '(5e16.8)' ) local % rhoc , local % rmaj , local % rgeo , local % shift , local % qinp write ( 1002 , * ) write ( 1002 , '(5a16)' ) '#6.shat' , '7.kappa' , '8.kapprim' , '9.tri' , '10.triprim' write ( 1002 , '(5e16.8)' ) local % shat , local % kappa , local % kapprim , local % tri , local % triprim write ( 1002 , * ) write ( 1002 , '(5a16)' ) '11.betaprim' , '12.dpsitordrho' , '13.rhotor' , & '14.drhotordrho' , '15.d2qdr2' write ( 1002 , '(5e16.8)' ) local % betaprim , local % dpsitordrho , local % rhotor , & local % drhotordrho , local % d2qdr2 write ( 1002 , * ) write ( 1002 , '(3a16)' ) '16.d2psidr2' , '17.betadbprim' , '18.psitor_lcfs' write ( 1002 , '(3e16.8)' ) local % d2psidr2 , local % betadbprim , local % psitor_lcfs close ( 1002 ) filename = \"millerlocal.\" // trim ( run_name ) // \".output\" open ( 1001 , file = trim ( filename ), status = 'unknown' ) write ( 1001 , '(a9,e18.9,a11,e18.9,a11,e18.9)' ) '#dI/dr: ' , dIdrho , 'd2I/dr2: ' , d2Idr2 , 'dpsi/dr: ' , dpsidrho write ( 1001 , '(58a15)' ) '#1.theta' , '2.R' , '3.dR/dr' , '4.d2Rdr2' , '5.dR/dth' , & '6.d2Rdrdth' , '7.dZ/dr' , '8.d2Zdr2' , '9.dZ/dth' , '10.d2Zdrdth' , & '11.bmag' , '12.dBdr' , '13.d2Bdr2' , '14.dB/dth' , '15.d2Bdrdth' , & '16.varthet' , '17.dvarthdr' , '18.d2varthdr2' , '19.jacr' , '20.djacrdr' , & '21.djacdrho' , '22.d2jacdr2' , '23.grho2' , '24.dgr2dr' , '25.gthet2' , & '26.dgt2' , '27.grgthet' , '28.dgrgt' , '29.galphgth' , '30.dgagt' , & '31.grgalph' , '32.dgagr' , '33.galph2' , '34.dga2' , '35.cross' , & '36.dcrossdr' , '37.gbdrift0' , '38.dgbdrift0' , '39.cvdrift0' , '40.dcvdrift0' , & '41.gbdrift' , '42.dgbdrift' , '43.cvdrift' , '44.dcvdrift' , '45.drzdth' , & '46.gradpar' , '47.dgpardr' , '48.gradparB' , '49.dgparBdr' , '50.gds2' , & '51.dgds2dr' , '52.gds21' , '53.dgds21dr' , '54.gds22' , '55.dgds22dr' , & '56.gds23' , '57.gds24' , '58.Zr' do i = - nz , nz write ( 1001 , '(59e18.9)' ) theta ( i ), Rr ( 2 , i ), dRdrho ( i ), d2Rdr2 ( i ), dRdth ( i ), & d2Rdrdth ( i ), dZdrho ( i ), d2Zdr2 ( i ), dZdth ( i ), d2Zdrdth ( i ), & bmag ( i ), dBdrho ( i ), d2Bdr2 ( i ), dBdth ( i ), d2Bdrdth ( i ), & varthet ( i ), dvarthdr ( i ), d2varthdr2 ( i ), jacrho ( i ), djacrdrho ( i ), & djacdrho ( i ), d2jacdr2 ( i ), grho ( i ) ** 2 , dgr2dr ( i ), gradthet2 ( i ), & dgt2 ( i ), gradrho_gradthet ( i ), dgrgt ( i ), gradalph_gradthet ( i ), dgagt ( i ), & gradrho_gradalph ( i ), dgagr ( i ), gradalph2 ( i ), dga2 ( i ), cross ( i ), & dcrossdr ( i ), gbdrift0 ( i ), dgbdrift0drho ( i ), cvdrift0 ( i ), dcvdrift0drho ( i ), & gbdrift ( i ), dgbdriftdrho ( i ), cvdrift ( i ), dcvdriftdrho ( i ), drzdth ( i ), & gradpar ( i ), dgradpardrho ( i ), gradparB ( i ), dgradparBdrho ( i ), gds2 ( i ), & dgds2dr ( i ), gds21 ( i ), dgds21dr ( i ), gds22 ( i ), dgds22dr ( i ), gds23 ( i ), gds24 ( i ), & Zr ( 2 , i ) end do close ( 1001 ) defaults_initialized = . false . end subroutine get_local_geo subroutine allocate_arrays ( nr , nz ) implicit none integer , intent ( in ) :: nr , nz ! periodic quantities can be computed on 2*pi grid and replicated allocate ( grho ( - nz : nz ), bmag ( - nz : nz ), gradpar ( - nz : nz )) allocate ( gds2 ( - nz : nz ), gds21 ( - nz : nz ), gds22 ( - nz : nz ), gds23 ( - nz : nz ), gds24 ( - nz : nz )) allocate ( gbdrift0 ( - nz : nz ), gbdrift ( - nz : nz )) allocate ( cvdrift0 ( - nz : nz ), cvdrift ( - nz : nz )) allocate ( Rr ( nr , - nz : nz ), Zr ( nr , - nz : nz )) allocate ( jacrho ( - nz : nz ), djacdrho ( - nz : nz ), djacrdrho ( - nz : nz ), d2jacdr2 ( - nz : nz )) allocate ( d2Rdrdth ( - nz : nz ), d2Zdrdth ( - nz : nz ), gpsi ( - nz : nz )) allocate ( dBdrho ( - nz : nz ), dgradpardrho ( - nz : nz )) allocate ( d2Bdrdth ( - nz : nz ), dgradparBdrho ( - nz : nz ), dBdth ( - nz : nz ), gradparb ( - nz : nz )) allocate ( dcvdrift0drho ( - nz : nz ), dgbdrift0drho ( - nz : nz )) allocate ( theta ( - nz : nz )) allocate ( gradpararc ( - nz : nz )) allocate ( arc ( - nz : nz )) allocate ( dRdrho ( - nz : nz ), dZdrho ( - nz : nz ), dRdth ( - nz : nz ), dZdth ( - nz : nz )) allocate ( gradrho_gradthet ( - nz : nz ), gradthet2 ( - nz : nz ), dgr2dr ( - nz : nz ), dgpsi2dr ( - nz : nz )) allocate ( dgrgt ( - nz : nz ), dgt2 ( - nz : nz ), dgagr ( - nz : nz ), dgagt ( - nz : nz ), dga2 ( - nz : nz )) allocate ( d2Rdr2 ( - nz : nz ), d2Zdr2 ( - nz : nz ), d2Bdr2 ( - nz : nz )) allocate ( drz ( - nz : nz ), drzdth ( - nz : nz ), d2Rdr2dth ( - nz : nz ), d2Zdr2dth ( - nz : nz )) allocate ( d2Rdth2 ( - nz : nz ), d2Zdth2 ( - nz : nz )) allocate ( d2gpsidr2 ( - nz : nz )) allocate ( gradalph_gradthet ( - nz : nz ), gradalph2 ( - nz : nz ), gradrho_gradalph ( - nz : nz )) allocate ( dgds2dr ( - nz : nz ), dgds21dr ( - nz : nz )) allocate ( dgds22dr ( - nz : nz )) allocate ( dcvdriftdrho ( - nz : nz ), dgbdriftdrho ( - nz : nz )) allocate ( varthet ( - nz : nz ), dvarthdr ( - nz : nz ), d2varthdr2 ( - nz : nz )) allocate ( cross ( - nz : nz )) allocate ( dcrossdr ( - nz : nz )) end subroutine allocate_arrays subroutine deallocate_arrays implicit none deallocate ( grho ) deallocate ( bmag ) deallocate ( gradpar ) deallocate ( gds2 ) deallocate ( gds21 ) deallocate ( gds22 ) deallocate ( gds23 ) deallocate ( gds24 ) deallocate ( gbdrift0 ) deallocate ( gbdrift ) deallocate ( cvdrift0 ) deallocate ( cvdrift ) deallocate ( Rr , Zr ) deallocate ( jacrho , djacdrho , djacrdrho , d2jacdr2 ) deallocate ( d2Rdrdth , d2Zdrdth , gpsi ) deallocate ( dBdrho , dgradpardrho ) deallocate ( d2Bdrdth , dgradparBdrho , dBdth , gradparb ) deallocate ( dcvdrift0drho , dgbdrift0drho ) deallocate ( theta ) deallocate ( gradpararc ) deallocate ( arc ) deallocate ( dRdrho , dZdrho , dRdth , dZdth ) deallocate ( gradrho_gradthet , gradthet2 , dgr2dr , dgpsi2dr ) deallocate ( dgrgt , dgt2 , dgagr , dgagt , dga2 ) deallocate ( d2Rdr2 , d2Zdr2 , d2Bdr2 ) deallocate ( drz , drzdth , d2Rdr2dth , d2Zdr2dth ) deallocate ( d2Rdth2 , d2Zdth2 ) deallocate ( d2gpsidr2 ) deallocate ( gradalph_gradthet , gradalph2 , gradrho_gradalph ) deallocate ( dgds2dr , dgds21dr ) deallocate ( dgds22dr ) deallocate ( dcvdriftdrho , dgbdriftdrho ) deallocate ( varthet , dvarthdr , d2varthdr2 ) deallocate ( cross ) deallocate ( dcrossdr ) deallocate ( d2R , d2Z ) if ( allocated ( delthet )) deallocate ( delthet ) if ( allocated ( bmag_psi0 )) deallocate ( bmag_psi0 ) if ( allocated ( grho_psi0 )) deallocate ( grho_psi0 ) end subroutine deallocate_arrays subroutine finish_local_geo implicit none call deallocate_arrays end subroutine finish_local_geo ! takes in f(r), with r given at three radial locations ! and returns df = df/dr at the middle radius subroutine get_drho ( f , df ) implicit none real , dimension (:, - nz :), intent ( in ) :: f real , dimension ( - nz :), intent ( out ) :: df df = 0.5 * ( f ( 3 , :) - f ( 1 , :)) / local % dr end subroutine get_drho ! given function f(theta), calculate second derivative ! of f with respect to theta ! second order accurate, with equal grid spacing assumed subroutine get_d2dthet2 ( f , d2f ) implicit none real , dimension ( - nz :), intent ( in ) :: f real , dimension ( - nz :), intent ( out ) :: d2f ! assuming equal grid spacing in theta here d2f ( - nz + 1 : nz - 1 ) = ( f (: nz - 2 ) - 2. * f ( - nz + 1 : nz - 1 ) + f ( - nz + 2 :)) / delthet ( - nz + 1 : nz - 1 ) ** 2 ! use periodicity at boundary d2f ( - nz ) = ( f ( nz - 1 ) - 2. * f ( - nz ) + f ( - nz + 1 )) / delthet ( - nz + 1 ) ** 2 d2f ( nz ) = d2f ( - nz ) end subroutine get_d2dthet2 ! given function f(theta:-pi->pi), calculate theta derivative ! second order accurate, with equal grid spacing assumed ! assumes periodic in theta -- may need to change this in future subroutine get_dthet ( f , df ) implicit none real , dimension ( - nz :), intent ( in ) :: f real , dimension ( - nz :), intent ( out ) :: df ! assuming equal grid spacing in theta here df ( - nz + 1 : nz - 1 ) = ( f ( - nz + 2 :) - f (: nz - 2 )) / ( delthet (: nz - 2 ) + delthet ( - nz + 1 :)) ! use periodicity at boundary df ( - nz ) = ( f ( - nz + 1 ) - f ( nz - 1 )) / ( delthet ( - nz ) + delthet ( nz - 1 )) df ( nz ) = df ( - nz ) end subroutine get_dthet subroutine get_jacrho implicit none ! jacrho = R*(dR/drho * dZ/dtheta - dR/dtheta * dZ/drho) jacrho = Rr ( 2 , :) * ( dRdrho * dZdth - dRdth * dZdrho ) end subroutine get_jacrho !   ! get dpsinorm/drho = (I/2*pi*q)*int_0&#94;{2*pi} dthet jacrho/R**2 !   subroutine get_dpsidrho (dpsidrho) !     use constants, only: pi !     implicit none !     real, intent (out) :: dpsidrho !     ! theta_integrate returns integral from 0 -> 2*pi !     call theta_integrate (jacrho(-nz2pi:nz2pi)/Rr(2,-nz2pi:nz2pi)**2, dpsidrho) !     ! integration done using trapezoidal rule !     dpsidrho = dpsidrho*bi/(2.*pi*local%qinp) !   end subroutine get_dpsidrho subroutine get_gradrho ( dpsidrho , grho ) implicit none real , intent ( in ) :: dpsidrho real , dimension ( - nz :), intent ( out ) :: grho grho = Rr ( 2 , :) * sqrt ( dRdth ** 2 + dZdth ** 2 ) / jacrho gpsi = grho * dpsidrho end subroutine get_gradrho subroutine get_dIdrho ( dpsidrho , grho , dIdrho ) use constants , only : pi implicit none real , intent ( in ) :: dpsidrho real , dimension ( - nz :), intent ( in ) :: grho real , intent ( out ) :: dIdrho real :: num1 , num2 , denom real , dimension (:), allocatable :: dum allocate ( dum ( - nz : nz )); dum = 0. dum = jacrho * ( 1.0 + ( bi / gpsi ) ** 2 ) / Rr ( 2 , :) ** 2 call theta_integrate ( dum ( - nz2pi : nz2pi ), denom ) dum = jacrho * ( 2. * dRdrho / Rr ( 2 , :) + dqdr / local % qinp ) / Rr ( 2 , :) ** 2 call theta_integrate ( dum ( - nz2pi : nz2pi ), num1 ) ! betaprim below is (4*pi*ptot/B0&#94;2)*(-d ln ptot / drho) dum = ( - 2. * ( dRdth * d2Rdrdth + dZdth * d2Zdrdth ) / jacrho & + drzdth + local % betaprim * jacrho / dpsidrho ** 2 ) / grho ** 2 call theta_integrate ( dum ( - nz2pi : nz2pi ), num2 ) dIdrho = bi * ( num1 + num2 ) / denom deallocate ( dum ) end subroutine get_dIdrho subroutine get_djacdrho ( dpsidrho , dIdrho , grho ) implicit none real , intent ( in ) :: dpsidrho , dIdrho real , dimension ( - nz :), intent ( in ) :: grho ! this is dpsi/dr * d/dr (jacobian) ! betaprim below is (4*pi*ptot/B0&#94;2)*(-d ln ptot / drho) djacdrho = ( Rr ( 2 , :) / grho ) ** 2 * ( 2. * ( dRdth * d2Rdrdth + dZdth * d2Zdrdth ) / jacrho & - drzdth + jacrho * ( bi * dIdrho / Rr ( 2 , :) ** 2 - local % betaprim ) / dpsidrho ** 2 ) ! this is d/dr (jacobian_r) djacrdrho = djacdrho + jacrho * local % d2psidr2 / dpsidrho end subroutine get_djacdrho subroutine get_d2RZdr2 implicit none ! get factor common to both d2R/drho2 and d2Z/drho2 d2Rdr2 = (( djacrdrho - jacrho * dRdrho / Rr ( 2 , :)) / Rr ( 2 , :) & - dRdrho * d2Zdrdth + dZdrho * d2Rdrdth ) / ( dRdth ** 2 + dZdth ** 2 ) d2Zdr2 = - d2Rdr2 * dRdth d2Rdr2 = d2Rdr2 * dZdth end subroutine get_d2RZdr2 subroutine get_dgr2dr ( dpsidrho , grho ) implicit none real , intent ( in ) :: dpsidrho real , dimension ( - nz :), intent ( in ) :: grho dgr2dr = 2. * ( grho ** 2 * ( dRdrho / Rr ( 2 , :) - djacrdrho / jacrho ) & + ( Rr ( 2 , :) / jacrho ) ** 2 * ( dRdth * d2Rdrdth + d2Zdrdth * dZdth )) dgpsi2dr = 2. * ( gpsi ** 2 * ( dRdrho / Rr ( 2 , :) - djacdrho / jacrho ) & + ( Rr ( 2 , :) / jacrho ) ** 2 * ( dRdth * d2Rdrdth + d2Zdrdth * dZdth ) * dpsidrho ** 2 ) end subroutine get_dgr2dr subroutine get_graddotgrad ( dpsidrho , grho ) implicit none real , intent ( in ) :: dpsidrho real , dimension ( - nz :), intent ( in ) :: grho ! grad theta . grad theta gradthet2 = ( Rr ( 2 , :) / jacrho ) ** 2 * ( dRdrho ** 2 + dZdrho ** 2 ) ! grad rho . grad theta gradrho_gradthet = - ( Rr ( 2 , :) / jacrho ) ** 2 * ( dRdrho * dRdth + dZdrho * dZdth ) ! grad alpha . grad theta gradalph_gradthet = - ( varthet * dqdr + local % qinp * dvarthdr ) * gradrho_gradthet & - bi * jacrho / ( dpsidrho * Rr ( 2 , :) ** 2 ) * gradthet2 ! grad rho . grad alpha gradrho_gradalph = - ( varthet * dqdr + local % qinp * dvarthdr ) * grho ** 2 & - bi * jacrho / ( dpsidrho * Rr ( 2 , :) ** 2 ) * gradrho_gradthet ! grad alpha . grad alpha gradalph2 = ( 1. / Rr ( 2 , :) ** 2 ) + (( varthet * dqdr + local % qinp * dvarthdr ) * grho ) ** 2 & + 2. * bi * jacrho * ( varthet * dqdr + local % qinp * dvarthdr ) * gradrho_gradthet / ( dpsidrho * Rr ( 2 , :) ** 2 ) & + ( bi * jacrho / ( dpsidrho * Rr ( 2 , :) ** 2 )) ** 2 * gradthet2 end subroutine get_graddotgrad subroutine get_gds ( gds2 , gds21 , gds22 , gds23 , gds24 ) implicit none real , dimension ( - nz :), intent ( out ) :: gds2 , gds21 , gds22 , gds23 , gds24 ! |grad alpha|&#94;2 * (dpsiN/drho)&#94;2 (dpsiN/drho factor accounts for ky normalization) gds2 = gradalph2 * dpsidrho_psi0 ** 2 ! (grad q . grad alpha) * (dpsiN/drho)&#94;2 gds21 = gradrho_gradalph * dqdr * dpsidrho_psi0 ** 2 ! |grad q|&#94;2 * (dpsiN/drho)&#94;2 gds22 = ( grho * dpsidrho_psi0 * dqdr ) ** 2 ! (grad rho . grad theta * |grad alpha|&#94;2 - grad alpha . grad theta * grad rho . grad alpha) * (dpsiN/drho)&#94;2 / B&#94;2 gds23 = ( gradrho_gradthet * gradalph2 - gradalph_gradthet * gradrho_gradalph ) * ( dpsidrho_psi0 / bmag ) ** 2 ! (grad rho . grad theta * grad rho . grad alpha - grad alpha . grad theta * |grad rho|&#94;2) * (dpsiN/drho)&#94;2 / B&#94;2 * q/rho gds24 = ( gradrho_gradthet * gradrho_gradalph - gradalph_gradthet * grho ** 2 ) & * ( dpsidrho_psi0 / bmag ) ** 2 * ( local % qinp_psi0 / local % rhoc_psi0 ) ! note that kperp2 = (n0/a)&#94;2*(drho/dpsiN)&#94;2*(gds2 + 2*theta0*gds21 + theta0&#94;2*gds22) ! theta0 = kx/(ky*shat) end subroutine get_gds subroutine get_dBdrho ( bmag , dIdrho ) implicit none real , dimension ( - nz :), intent ( in ) :: bmag real , intent ( in ) :: dIdrho ! dB/drho dBdrho = ( bi * dIdrho + 0.5 * dgpsi2dr ) / ( bmag * Rr ( 2 , :) ** 2 ) & - bmag * dRdrho / Rr ( 2 , :) end subroutine get_dBdrho subroutine get_varthet ( dpsidrho ) implicit none real , intent ( in ) :: dpsidrho call theta_integrate_indef ( jacrho / Rr ( 2 , :) ** 2 , varthet ) varthet = bi * varthet / ( dpsidrho * local % qinp ) end subroutine get_varthet subroutine get_dvarthdr ( dpsidrho , dIdrho ) implicit none real , intent ( in ) :: dpsidrho , dIdrho real , dimension ( - nz : nz ) :: dum dum = bi * jacrho * ( dIdrho / bi - dqdr / local % qinp + djacdrho / jacrho & - 2. * dRdrho / Rr ( 2 , :)) / Rr ( 2 , :) ** 2 call theta_integrate_indef ( dum , dvarthdr ) dvarthdr = dvarthdr / ( dpsidrho * local % qinp ) end subroutine get_dvarthdr subroutine get_d2Idr2_d2jacdr2 ( grho , dIdrho ) use constants , only : pi implicit none real , dimension ( - nz :), intent ( in ) :: grho real , intent ( in ) :: dIdrho real :: denom , num1 , num2 , num3 , num4 real , dimension ( - nz : nz ) :: tmp , tmp2 ! denom is the denominator in the expression for d&#94;2 I / dr&#94;2 tmp = jacrho / Rr ( 2 , :) ** 2 * ( 1.0 + ( bi / gpsi ) ** 2 ) call theta_integrate ( tmp ( - nz2pi : nz2pi ), denom ) denom = denom / bi d2jacdr2 = dIdrho * bi * jacrho / gpsi ** 2 & * ( dIdrho / bi + djacrdrho / jacrho - dgpsi2dr / gpsi ** 2 & - 2. * dRdrho / Rr ( 2 , :)) tmp = - d2jacdr2 / Rr ( 2 , :) ** 2 - dIdrho * jacrho / ( bi * Rr ( 2 , :) ** 2 ) & * ( djacrdrho / jacrho - dIdrho / bi - 2. * dRdrho / Rr ( 2 , :)) call theta_integrate ( tmp ( - nz2pi : nz2pi ), num1 ) ! tmp = -jacrho/(dpsidrho*Rr(2,:)**2)*(djacdrho/jacrho - 2.*dRdrho/Rr(2,:)) ! call theta_integrate (tmp(-nz2pi:nz2pi), num2) ! d2jacdr2 = d2jacdr2 - tmp*Rr(2,:)**2*local%d2psidr2 ! num2 = local%d2psidr2 * (2*pi*local%qinp/bi*(dqdr/local%qinp - dIdrho/bi) + num2) tmp = ( d2Rdr2 * dRdth + dRdrho * d2Rdrdth + d2Zdr2 * dZdth + dZdrho * d2Zdrdth ) / jacrho & - djacrdrho * ( dRdrho * dRdth + dZdrho * dZdth ) / jacrho ** 2 call get_dthet ( tmp , tmp2 ) tmp = ( tmp2 - 2. / jacrho * ( - djacrdrho / jacrho * ( dRdth * d2Rdrdth + dZdth * d2Zdrdth ) & + d2Rdrdth ** 2 + dRdth * d2Rdr2dth + d2Zdrdth ** 2 + dZdth * d2Zdr2dth )) / grho ** 2 & - dgr2dr * ( drzdth - 2. / jacrho * ( dRdth * d2Rdrdth + dZdth * d2Zdrdth )) / grho ** 4 call theta_integrate ( tmp ( - nz2pi : nz2pi ), num2 ) d2jacdr2 = d2jacdr2 - tmp * Rr ( 2 , :) ** 2 tmp = jacrho * ( local % betadbprim + local % betaprim * ( djacrdrho / jacrho - dgpsi2dr / gpsi ** 2 )) / gpsi ** 2 call theta_integrate ( tmp ( - nz2pi : nz2pi ), num3 ) !FLAG - next negative sign? d2jacdr2 = d2jacdr2 - tmp * Rr ( 2 , :) ** 2 tmp = jacrho / Rr ( 2 , :) ** 2 * ( 2. * d2Rdr2 / Rr ( 2 , :) - 2. * ( dRdrho / Rr ( 2 , :)) ** 2 & + local % d2qdr2 / local % qinp - ( dqdr / local % qinp ) ** 2 + ( 2 * dRdrho / Rr ( 2 , :) + dqdr / local % qinp ) & * ( djacrdrho / jacrho - 2. * dRdrho / Rr ( 2 , :))) call theta_integrate ( tmp ( - nz2pi : nz2pi ), num4 ) d2Idr2 = ( num1 + num2 + num3 + num4 ) / denom !    d2jacdr2 = d2jacdr2 + bi*jacrho/(gpsi*Rr(2,:))**2*d2Idr2 + 2.*djacdrho*dRdrho/Rr(2,:)**3 d2jacdr2 = d2jacdr2 + bi * jacrho / gpsi ** 2 * d2Idr2 + 2. * djacdrho * dRdrho / Rr ( 2 , :) end subroutine get_d2Idr2_d2jacdr2 subroutine get_d2varthdr2 ( dpsidrho , dIdrho ) implicit none real , intent ( in ) :: dpsidrho , dIdrho real , dimension ( - nz : nz ) :: dum dum = bi * jacrho / ( local % qinp * dpsidrho * Rr ( 2 , :) ** 2 ) * (( dIdrho / bi - dqdr / local % qinp & !    dum = bi*jacrho/(local%qinp*Rr(2,:)**2)*( (dIdrho/bi - dqdr/local%qinp & + djacdrho / jacrho - 2. * dRdrho / Rr ( 2 , :)) ** 2 & + d2Idr2 / bi - ( dIdrho / bi ) ** 2 - local % d2qdr2 / local % qinp & + ( dqdr / local % qinp ) ** 2 + d2jacdr2 / jacrho - ( djacdrho / jacrho ) ** 2 & - djacdrho * local % d2psidr2 / ( dpsidrho * jacrho ) & - 2. * d2Rdr2 / Rr ( 2 , :) + 2. * ( dRdrho / Rr ( 2 , :)) ** 2 ) call theta_integrate_indef ( dum , d2varthdr2 ) end subroutine get_d2varthdr2 subroutine get_d2Bdr2 ( bmag , dIdrho ) implicit none real , dimension ( - nz :), intent ( in ) :: bmag real , intent ( in ) :: dIdrho ! d2gpsidr2 = 2.*( dgr2dr*(dRdrho/Rr(2,:) - djacdrho/jacrho) & !      + grho**2*(d2Rdr2/Rr(2,:) - (dRdrho/Rr(2,:))**2 - d2jacdr2/jacrho & !      + djacdrho*djacrdrho/jacrho**2) + (Rr(2,:)/jacrho)**2 & !      * (dRdth**2 + dRdth*d2Rdr2dth + dZdth**2 + dZdth*d2Zdr2dth & !      + 2.*(dRdrho/Rr(2,:) - djacrdrho/jacrho)*(dRdth*d2Rdrdth+dZdth*d2Zdrdth)) ) d2gpsidr2 = 2. * ( dRdrho / Rr ( 2 , :) - djacdrho / jacrho ) * dgpsi2dr & + 2. * gpsi ** 2 * ( d2Rdr2 / Rr ( 2 , :) - ( dRdrho / Rr ( 2 , :)) ** 2 - d2jacdr2 / jacrho + djacdrho * djacrdrho / jacrho ** 2 ) & + 2. * ( Rr ( 2 , :) * gpsi / jacrho ) ** 2 * ( d2Rdrdth ** 2 + dRdth * d2Rdr2dth + d2Zdrdth ** 2 + dZdth * d2Zdr2dth & + 2. * ( dRdth * d2Rdrdth + dZdth * d2Zdrdth ) * ( dRdrho / Rr ( 2 , :) - djacdrho / jacrho )) ! d2gpsidr2 = 2.*(dpsidrho*Rr(2,:)/jacrho)**2 & !      * (2.*(dRdrho/Rr(2,:)-djacdrho/jacrho) & !      * ((dRdrho/Rr(2,:)-djacdrho/jacrho)*(dRdth**2+dZdth**2) & !      + 2.*(dRdth*d2Rdrdth+dZdth*d2Zdrdth)) & !      + (dRdth**2+dZdth**2)*(d2rdr2/Rr(2,:) - (dRdrho/Rr(2,:))**2 & !      - d2jacdr2/jacrho + (djacdrho/jacrho)**2) & !      + d2Rdrdth**2 + dRdth*d2Rdr2dth + d2Zdrdth**2 + dZdth*d2Zdr2dth) & !      + 4.*dpsidrho*local%d2psidr2*dgr2dr & !      + 2.*grho**2*(local%d2psidr2**2 + dpsidrho*local%d3psidr3) ! get d/drho (dB/drho) d2Bdr2 = - dBdrho * dRdrho / Rr ( 2 , :) + bmag * ( dRdrho / Rr ( 2 , :)) ** 2 & - bmag * d2Rdr2 / Rr ( 2 , :) + 0.5 * ( 2. * ( dIdrho ** 2 + bi * d2Idr2 ) & + d2gpsidr2 ) / ( bmag * Rr ( 2 , :) ** 2 ) & - ( dBdrho + bmag * dRdrho / Rr ( 2 , :)) * ( 2. * dRdrho / Rr ( 2 , :) + dBdrho / bmag ) end subroutine get_d2Bdr2 subroutine get_dcrossdr ( dpsidrho , dIdrho , grho ) implicit none real , intent ( in ) :: dpsidrho , dIdrho real , dimension ( - nz :), intent ( in ) :: grho ! dgr2 = d/drho (|grad rho|&#94;2) ! dgr2 = 2.*(Rr(2,:)/jacrho)**2*((dRdrho/Rr(2,:)-djacdrho/jacrho)*(dRdth**2+dZdth**2) & !      + dRdth*d2Rdrdth + dZdth*d2Zdrdth) ! dgrgt = d/drho (grad rho . grad theta) !    dgrgt = -(Rr(2,:)/jacrho)**2*(2.*(dRdrho/Rr(2,:)-djacdrho/jacrho)*(dRdrho*dRdth+dZdrho*dZdth) & !         + d2Rdr2*dRdth+dRdrho*d2Rdrdth+d2Zdr2*dZdth+dZdrho*d2Zdrdth) dgrgt = 2. * gradrho_gradthet * ( dRdrho / Rr ( 2 , :) - djacrdrho / jacrho ) & - ( Rr ( 2 , :) / jacrho ) ** 2 * ( d2Rdr2 * dRdth + dRdrho * d2Rdrdth + d2Zdr2 * dZdth + dZdrho * d2Zdrdth ) ! dgt2 = d/drho (|grad theta|&#94;2) dgt2 = 2. * ( Rr ( 2 , :) / jacrho ) ** 2 * (( dRdrho / Rr ( 2 , :) - djacrdrho / jacrho ) * ( dRdrho ** 2 + dZdrho ** 2 ) & + dRdrho * d2Rdr2 + dZdrho * d2Zdr2 ) ! this is d/drho (|grad alph|&#94;2) ! will later multiply it by 0.5*dpsidrho**2 dga2 = - 2 * dRdrho / Rr ( 2 , :) ** 3 + dgr2dr * ( varthet * dqdr + local % qinp * dvarthdr ) ** 2 & + ( 2.0 * grho ** 2 * ( varthet * dqdr + local % qinp * dvarthdr ) & + 2. * bi * jacrho * gradrho_gradthet / ( dpsidrho * Rr ( 2 , :) ** 2 )) & * ( local % d2qdr2 * varthet + 2. * dqdr * dvarthdr + local % qinp * d2varthdr2 ) & + 2. * ( varthet * dqdr + local % qinp * dvarthdr ) * bi * jacrho / ( dpsidrho * Rr ( 2 , :) ** 2 ) & * ( dgrgt + gradrho_gradthet * ( dIdrho / bi + djacdrho / jacrho - 2. * dRdrho / Rr ( 2 , :))) & + ( bi * jacrho / ( dpsidrho * Rr ( 2 , :) ** 2 )) ** 2 * ( dgt2 + 2. * gradthet2 * ( dIdrho / bi + djacdrho / jacrho & - 2. * dRdrho / Rr ( 2 , :))) ! dgagr = d/drho (grad alpha . grad rho) dgagr = - grho ** 2 * ( 2. * dvarthdr * dqdr + varthet * local % d2qdr2 + local % qinp * d2varthdr2 ) & - dgr2dr * ( varthet * dqdr + local % qinp * dvarthdr ) - bi * jacrho / ( dpsidrho * Rr ( 2 , :) ** 2 ) & * ( dgrgt + gradrho_gradthet * ( dIdrho / bi + djacdrho / jacrho - 2. * dRdrho / Rr ( 2 , :))) ! dgagt = d/drho (grad alpha . grad theta) dgagt = - gradrho_gradthet * ( 2. * dvarthdr * dqdr + varthet * local % d2qdr2 + local % qinp * d2varthdr2 ) & - dgrgt * ( varthet * dqdr + local % qinp * dvarthdr ) - bi * jacrho / ( dpsidrho * Rr ( 2 , :) ** 2 ) & * ( dgt2 + gradthet2 * ( dIdrho / bi + djacdrho / jacrho - 2. * dRdrho / Rr ( 2 , :))) ! dcrossdr = d/drho [(grad alpha x B) . grad theta)] dcrossdr = dpsidrho * ( dgagr * gradalph_gradthet + gradrho_gradalph * dgagt & - dga2 * gradrho_gradthet - gradalph2 * dgrgt ) + local % d2psidr2 * cross / dpsidrho ! this is (dpsi/drho)&#94;2*d|grad alpha|&#94;2/dr dgds2dr = dga2 * dpsidrho_psi0 ** 2 ! this is (dpsi/drho)&#94;2*d(grad alpha . grad q)/dr ! note that there will be multiplication by 2 in dist_fn.fpp dgds21dr = ( dgagr * dqdr + local % d2qdr2 * gradrho_gradalph ) * dpsidrho_psi0 ** 2 ! this is (dpsi/drho)&#94;2*d(|grad q|&#94;2)/dr dgds22dr = ( dqdr ** 2 * dgr2dr + 2. * grho ** 2 * dqdr * local % d2qdr2 ) * dpsidrho_psi0 ** 2 ! note that dkperp2/dr = (n0/a)&#94;2*(drho/dpsiN)&#94;2*(dgds2dr + 2*theta0*dgds21dr + theta0&#94;2*dgds22dr) end subroutine get_dcrossdr subroutine theta_integrate ( integrand , integral ) implicit none real , dimension ( - nz2pi :), intent ( in ) :: integrand real , intent ( out ) :: integral ! use trapezoidal rule to integrate in theta integral = 0.5 * sum ( delthet ( - nz2pi : nz2pi - 1 ) * ( integrand ( - nz2pi : nz2pi - 1 ) + integrand ( - nz2pi + 1 : nz2pi ))) end subroutine theta_integrate ! get indefinite integral of integrand subroutine theta_integrate_indef ( integrand , integral ) implicit none real , dimension ( - nz :), intent ( in ) :: integrand real , dimension ( - nz :), intent ( out ) :: integral integer :: i ! use trapezoidal rule to integrate in theta integral ( 0 ) = 0.0 do i = 1 , nz integral ( i ) = integral ( i - 1 ) + 0.5 * delthet ( i - 1 ) * ( integrand ( i - 1 ) + integrand ( i )) end do do i = - 1 , - nz , - 1 integral ( i ) = integral ( i + 1 ) - 0.5 * delthet ( i ) * ( integrand ( i + 1 ) + integrand ( i )) end do end subroutine theta_integrate_indef function Rpos ( r , theta , j ) use constants , only : pi integer , intent ( in ) :: j real , intent ( in ) :: r , theta real :: Rpos real :: g , gp , dr integer :: i dr = r - local % rhoc ! For Y Xiao: !    g = local%delp/local%rhoc + local%d * sin(theta)**2 !    Rpos = local%rmaj*(1.+r*(cos(theta)-g)-g*dr) g = cos ( theta + local % tri * sin ( theta )) gp = - sin ( theta + local % tri * sin ( theta )) & * local % triprim * sin ( theta ) ! allow for strange specification of R_psi if ( j == nz + 1 ) then i = - nz else i = j end if ! second line here is (1/2)*(r-r0)**2*d2R/dr|_r0 ! note that d2R=0 unless read_profile_variation = T in input file Rpos = local % rmaj + local % shift * dr + g * local % rhoc + ( g + local % rhoc * gp ) * dr & + 0.5 * ( r - rhoc0 ) ** 2 * d2R ( i ) end function Rpos function Zpos ( r , theta , j ) integer , intent ( in ) :: j real , intent ( in ) :: r , theta real :: Zpos , dr integer :: i ! allow for strange specification of Z_psi if ( j == nz + 1 ) then i = - nz else i = j end if dr = r - local % rhoc ! note that d2Z=0 unless read_profile_variation=T in input file Zpos = local % kappa * sin ( theta ) * local % rhoc + ( local % rhoc * local % kapprim + local % kappa ) * sin ( theta ) * dr & + 0.5 * ( r - rhoc0 ) ** 2 * d2Z ( i ) end function Zpos function mod2pi ( theta ) real , intent ( in ) :: theta real :: pi , th , mod2pi real , parameter :: theta_tol = 1.e-6 logical :: out pi = 2. * acos ( 0. ) if ( theta <= pi . and . theta >= - pi ) then mod2pi = theta return end if if ( theta - theta_tol <= pi . and . theta >= - pi ) then mod2pi = pi return end if if ( theta <= pi . and . theta + theta_tol >= - pi ) then mod2pi = - pi return end if th = theta out = . true . do while ( out ) if ( th > pi ) th = th - 2. * pi if ( th < - pi ) th = th + 2. * pi if ( th <= pi . and . th >= - pi ) out = . false . end do mod2pi = th end function mod2pi end module millerlocal","tags":"","loc":"sourcefile/millerlocal.f90.html"},{"title":"volume_averages.f90 – stella","text":"Source Code module volume_averages public :: init_volume_averages , finish_volume_averages public :: fieldline_average public :: volume_average public :: flux_surface_average_ffs public :: mode_fac private interface fieldline_average module procedure fieldline_average_real module procedure fieldline_average_complex end interface real , dimension (:), allocatable :: mode_fac !> Fourier coefficients in y of the Jacobian; !> needed for full flux surface simulations complex , dimension (:, :), allocatable :: jacobian_ky contains subroutine init_volume_averages use zgrid , only : nzgrid , nztot , delzed use kt_grids , only : nalpha , aky , nakx , naky , rho_d_clamped use stella_geometry , only : geo_surf , drhodpsi use stella_geometry , only : geo_surf , jacob , djacdrho , q_as_x , dVolume use physics_flags , only : full_flux_surface , radial_variation implicit none real :: dqdrho if (. not . allocated ( mode_fac )) then allocate ( mode_fac ( naky )); mode_fac = 2.0 if ( aky ( 1 ) < epsilon ( 0. )) mode_fac ( 1 ) = 1.0 end if if ( full_flux_surface ) then call init_flux_surface_average_ffs end if dqdrho = geo_surf % shat * geo_surf % qinp / geo_surf % rhoc if (. not . allocated ( dVolume )) allocate ( dVolume ( nalpha , nakx , - nzgrid : nzgrid )) !dVolume contains the volume element jacob, which may vary with x or alpha ! NB: dVolume does not contain the factor dx, as this should always be uniform dVolume = spread ( jacob * spread ( delzed , 1 , nalpha ), 2 , nakx ) if ( q_as_x ) then dVolume = dVolume / ( dqdrho * drhodpsi ) end if if ( radial_variation ) then if ( q_as_x ) then dVolume = dVolume * ( 1. + spread ( spread ( rho_d_clamped , 1 , nalpha ), 3 , nztot ) & * ( spread ( djacdrho / jacob , 2 , nakx ) - geo_surf % d2qdr2 / dqdrho & + geo_surf % d2psidr2 * drhodpsi )) else dVolume = dVolume * ( 1. + spread ( spread ( rho_d_clamped , 1 , nalpha ), 3 , nztot ) & * spread ( djacdrho / jacob , 2 , nakx )) end if end if if ( full_flux_surface ) then !something should go here end if !avoid the double counting at the zed boundaries dVolume (:, :, - nzgrid ) = 0.5 * dVolume (:, :, - nzgrid ) dVolume (:, :, nzgrid ) = 0.5 * dVolume (:, :, nzgrid ) end subroutine init_volume_averages subroutine finish_volume_averages use stella_geometry , only : dVolume use physics_flags , only : full_flux_surface implicit none if ( allocated ( mode_fac )) deallocate ( mode_fac ) if ( allocated ( dVolume )) deallocate ( dVolume ) if ( full_flux_surface ) then if ( allocated ( jacobian_ky )) deallocate ( jacobian_ky ) end if end subroutine finish_volume_averages !============================================== !============ FIELD LINE AVERAGE ============== !============================================== subroutine fieldline_average_real ( unavg , avg ) use zgrid , only : nzgrid , ntubes use kt_grids , only : nakx , naky use stella_geometry , only : dl_over_b implicit none real , dimension (:, :, - nzgrid :, :), intent ( in ) :: unavg real , dimension (:, :), intent ( out ) :: avg integer :: it , ia ia = 1 avg = 0.0 do it = 1 , ntubes avg = avg + sum ( spread ( spread ( dl_over_b ( ia , :), 1 , naky ), 2 , nakx ) * unavg (:, :, :, it ), dim = 3 ) end do avg = avg / real ( ntubes ) end subroutine fieldline_average_real subroutine fieldline_average_complex ( unavg , avg ) use zgrid , only : nzgrid , ntubes use kt_grids , only : nakx , naky use stella_geometry , only : dl_over_b implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: unavg complex , dimension (:, :), intent ( out ) :: avg integer :: it , ia ia = 1 avg = 0.0 do it = 1 , ntubes avg = avg + sum ( spread ( spread ( dl_over_b ( ia , :), 1 , naky ), 2 , nakx ) * unavg (:, :, :, it ), dim = 3 ) end do avg = avg / real ( ntubes ) end subroutine fieldline_average_complex !============================================== !============== VOLUME AVERAGE ================ !============================================== subroutine volume_average ( unavg , avg ) use zgrid , only : nzgrid , ntubes use kt_grids , only : naky , nakx use stella_geometry , only : dl_over_b implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: unavg real , intent ( out ) :: avg integer :: iky , ikx , iz , it , ia ia = 1 avg = 0. do it = 1 , ntubes do iz = - nzgrid , nzgrid do ikx = 1 , nakx do iky = 1 , naky avg = avg + real ( unavg ( iky , ikx , iz , it ) * conjg ( unavg ( iky , ikx , iz , it ))) * mode_fac ( iky ) * dl_over_b ( ia , iz ) end do end do end do end do avg = avg / real ( ntubes ) end subroutine volume_average subroutine init_flux_surface_average_ffs use zgrid , only : nzgrid use kt_grids , only : naky use stella_geometry , only : jacob use stella_transforms , only : transform_alpha2kalpha implicit none integer :: iz if (. not . allocated ( jacobian_ky )) allocate ( jacobian_ky ( naky , - nzgrid : nzgrid )) !> calculate the Fourier coefficients in y of the Jacobian !> this is needed in the computation of the flux surface average of phi do iz = - nzgrid , nzgrid call transform_alpha2kalpha ( jacob (:, iz ), jacobian_ky (:, iz )) end do end subroutine init_flux_surface_average_ffs subroutine flux_surface_average_ffs ( no_fsa , fsa ) use zgrid , only : nzgrid , delzed use stella_geometry , only : jacob use kt_grids , only : naky , naky_all , nalpha use kt_grids , only : dy implicit none complex , dimension (:, - nzgrid :), intent ( in ) :: no_fsa complex , intent ( out ) :: fsa integer :: iky , ikymod real :: area ! the normalising factor int dy dz Jacobian area = sum ( spread ( delzed * dy , 1 , nalpha ) * jacob ) fsa = 0.0 ! get contribution from negative ky values ! for no_fsa, iky=1 corresponds to -kymax, and iky=naky-1 to -dky do iky = 1 , naky - 1 ! jacobian_ky only defined for positive ky values ! use reality of the jacobian to fill in negative ky values ! i.e., jacobian_ky(-ky) = conjg(jacobian_ky(ky)) ! ikymod runs from naky down to 2, which corresponds ! to ky values in jacobian_ky from kymax down to dky ikymod = naky - iky + 1 ! for each ky, add the integral over zed fsa = fsa + sum ( delzed * no_fsa ( iky , :) * jacobian_ky ( ikymod , :)) end do ! get contribution from zero and positive ky values ! iky = naky correspond to ky=0 for no_fsa and iky=naky_all to ky=kymax do iky = naky , naky_all ! ikymod runs from 1 to naky ! ikymod = 1 corresponds to ky=0 for jacobian_ky and ikymod=naky to ky=kymax ikymod = iky - naky + 1 ! for each ky, add the integral over zed fsa = fsa + sum ( delzed * no_fsa ( iky , :) * conjg ( jacobian_ky ( ikymod , :))) end do ! normalise by the flux surface area fsa = fsa / area end subroutine flux_surface_average_ffs end module volume_averages","tags":"","loc":"sourcefile/volume_averages.f90.html"},{"title":"job_manage.fpp – stella","text":"Source Code # include \"define.inc\" module job_manage implicit none private public :: timer_local public :: time_message public :: job_fork public :: checkstop public :: checktime public :: njobs integer :: njobs = 1 contains !!! returns CPU time in second function timer_local () # ifndef MPIINC use mpi , only : mpi_wtime # else include \"mpif.h\" ! CMR following Michele Weiland's advice # endif real :: timer_local timer_local = 0. timer_local = mpi_wtime () end function timer_local subroutine time_message ( lprint , targ , chmessage ) ! ! this routine counts elapse time between two calls ! character ( len =* ), intent ( in ) :: chmessage logical , intent ( in ) :: lprint real , intent ( in out ) :: targ ( 2 ) ! tsum and told real :: tnew tnew = timer_local () if ( abs ( targ ( 2 )) < epsilon ( 0. )) then targ ( 2 ) = tnew else targ ( 1 ) = targ ( 1 ) + tnew - targ ( 2 ) if ( lprint ) write ( * , '(A24,F7.2,A8)' ) chmessage , tnew - targ ( 2 ), ' seconds' targ ( 2 ) = 0. end if end subroutine time_message subroutine job_fork ( n_ensembles ) use file_utils , only : get_unused_unit , list_name , run_name , init_job_name ! MAB> -- moved init_error_unit and init_input_unit calls here from file_utils ! because they were being called there on all procs when they should be called ! only on proc0 use file_utils , only : init_error_unit , init_input_unit , list_name ! <MAB use mp , only : job , scope , min_proc use mp , only : proc0 , nproc use mp , only : init_job_topology , broadcast , finish_mp implicit none integer , intent ( in ), optional :: n_ensembles integer , dimension (:), allocatable :: group0 integer :: i , l character ( 10 ) :: ext character ( len = 500 ), dimension (:), allocatable :: job_list integer :: list_unit , ierr logical :: err = . true ., inp = . true . ! open file containing list of input files to run and read total ! number of input files from first line if (. not . present ( n_ensembles )) then if ( proc0 ) then call get_unused_unit ( list_unit ) open ( unit = list_unit , file = trim ( list_name )) read ( list_unit , * ) njobs end if else njobs = n_ensembles end if call broadcast ( njobs ) if ( nproc < njobs ) then if ( proc0 ) then write ( * , * ) write ( * , * ) 'Number of jobs = ' , njobs , ' and number of processors = ' , nproc write ( * , * ) 'Number of processors must not be less than the number of jobs' write ( * , * ) 'Stopping' write ( * , * ) end if call finish_mp stop end if if ( mod ( nproc , njobs ) /= 0 ) then if ( proc0 ) then write ( * , * ) write ( * , * ) 'Number of jobs = ' , njobs , ' and number of processors = ' , nproc write ( * , * ) 'Number of jobs must evenly divide the number of processors.' write ( * , * ) 'Stopping' write ( * , * ) end if call finish_mp stop end if allocate ( job_list ( 0 : njobs - 1 )) if ( proc0 ) then if (. not . present ( n_ensembles )) then do i = 0 , njobs - 1 read ( list_unit , fmt = \"(a)\" ) job_list ( i ) end do close ( list_unit ) else l = len_trim ( list_name ) do i = 0 , njobs - 1 write ( ext , '(i9)' ) i + 1 ext = adjustl ( ext ) job_list ( i ) = trim ( list_name ( 1 : l - 3 )) // \"_\" // trim ( ext ) end do end if end if do i = 0 , njobs - 1 call broadcast ( job_list ( i )) end do allocate ( group0 ( 0 : njobs - 1 )) call init_job_topology ( njobs , group0 , ierr ) ! TT> brought up one line [call scope(subprocs)] from file_utils.fpp !     to init_jobs !    call init_job_name (njobs, group0, job_list) call init_job_name ( job_list ( job )) ! <TT ! MAB> moved from file_utils because had to be within proc0, ! which is undefined there if ( proc0 ) then call init_error_unit ( err ) call init_input_unit ( inp ) end if ! <MAB if ( nproc > 1 . and . proc0 ) & & write ( * , * ) 'Job ' , job , ' is called ' , trim ( run_name ),& & ' and is running on ' , nproc , ' processors with a minimum of' , & & min_proc , ' processors on a node' if ( nproc == 1 ) write ( * , * ) 'Job ' , job , ' is called ' , trim ( run_name ),& & ' and is running on ' , nproc , ' processors with a minimum of' , & & min_proc , ' processors on a node' deallocate ( group0 , job_list ) ! MAB end subroutine job_fork subroutine checkstop ( exit , list ) use mp , only : proc0 , broadcast use file_utils , only : run_name , list_name logical , intent ( in ), optional :: list logical , intent ( in out ) :: exit character ( len = 300 ) :: filename logical :: exit_local ! If .stop file has appeared, set exit flag filename = trim ( run_name ) // \".stop\" if ( present ( list )) then if ( list ) filename = list_name (: len_trim ( list_name ) - 5 ) // \".stop\" end if if ( proc0 ) then inquire ( file = filename , exist = exit_local ) exit = exit . or . exit_local end if call broadcast ( exit ) end subroutine checkstop subroutine checktime ( avail_time , exit ) use mp , only : proc0 , broadcast use file_utils , only : error_unit ! available time in second real , intent ( in ) :: avail_time ! true if elapse time exceed available time logical , intent ( in out ) :: exit logical , save :: initialized = . false . real :: elapse_time = 0. real :: initial_time = 0. real :: margin = 30 0. ! 5 minutes if (. not . initialized ) then initial_time = timer_local () ! timer_local() returns #seconds from fixed time in past initialized = . true . return end if elapse_time = timer_local () - initial_time if ( proc0 ) then if ( elapse_time >= avail_time - margin ) then write ( error_unit (), '(a,f12.4,a,f12.4)' ) & & 'Elapse time ' , elapse_time , & & ' exceeds available time' , avail_time - margin write ( error_unit (), '(a,f12.4,a,f12.4,a)' ) & & '  (Given CPU time: ' , avail_time , & & '  Margin: ' , margin , ')' exit = . true . end if end if call broadcast ( exit ) end subroutine checktime end module job_manage","tags":"","loc":"sourcefile/job_manage.fpp.html"},{"title":"stel_constants.f – stella","text":"Source Code MODULE stel_constants USE stel_kinds , ONLY : rprec , dp !---------------------------------------------------------------------- !  Mathematical constants !---------------------------------------------------------------------- REAL ( dp ), PARAMETER :: pi = 3.14159265358979323846264338328_dp REAL ( dp ), PARAMETER :: pio2 = pi / 2 REAL ( dp ), PARAMETER :: twopi = 2 * pi REAL ( dp ), PARAMETER :: sqrt2 = 1.41421356237309504880168872_dp REAL ( dp ), PARAMETER :: degree = twopi / 360 REAL ( dp ), PARAMETER :: one = 1 REAL ( dp ), PARAMETER :: zero = 0 !---------------------------------------------------------------------- !  Physical constants !------------------------------------------------------------------ REAL ( dp ), PARAMETER :: mu0 = 2 * twopi * 1.0e-7_dp END MODULE stel_constants","tags":"","loc":"sourcefile/stel_constants.f.html"},{"title":"vsvd0.f – stella","text":"Source Code MODULE vsvd0 USE stel_kinds IMPLICIT NONE REAL ( rprec ), PARAMETER :: fturnon_axis = 3.e-9_dp REAL ( rprec ), PARAMETER :: fopt_axis = 3.e-2_dp * fturnon_axis INTEGER , PARAMETER :: isamecoil = - 2 INTEGER , PARAMETER :: needit = - 1 INTEGER , PARAMETER :: idontneed = 0 INTEGER , PARAMETER :: isymcoil = 1 INTEGER , PARAMETER :: ithom0 = 1 INTEGER , PARAMETER :: istark0 = 2 INTEGER , PARAMETER :: islope0 = 3 INTEGER , PARAMETER :: icurr0 = 4 INTEGER , PARAMETER :: idiam0 = 5 INTEGER , PARAMETER :: iflxs0 = 6 INTEGER , PARAMETER :: ibrzfld = 7 INTEGER , PARAMETER :: natur = 0 INTEGER , PARAMETER :: ideriv = 1 INTEGER , PARAMETER :: intder = 1 INTEGER , PARAMETER :: intfun = 2 INTEGER , PARAMETER :: nmse = 100 !number of mse measurements INTEGER , PARAMETER :: ntse = 100 !number of thompson scattering measurements INTEGER , PARAMETER :: nfloops = 100 !number of external poloidal flux loops INTEGER , PARAMETER :: nbsetsp = 5 !number of external b-field loop sets allowed INTEGER , PARAMETER :: nbcoilsp = 100 !number of external b-field coils per set INTEGER , PARAMETER :: nbctotp = nbsetsp * nbcoilsp INTEGER , PARAMETER :: jngrn = 1001 !number of \"Greens Function\" points INTEGER , PARAMETER :: jchix = 7 !number of data types contributing to rms error match INTEGER , PARAMETER :: mstp = 100 !number of time steps to store chisq error INTEGER , PARAMETER :: jchix1 = jchix + 1 INTEGER , PARAMETER :: nparts = 4 !number of items needed to specify pf coils INTEGER , PARAMETER :: npfcoil = 40 !number of filaments in pf coil pack (for plotting) INTEGER , PARAMETER :: nigroup = 100 !number of external current groups INTEGER , PARAMETER :: ipedsvd = 8 END MODULE vsvd0","tags":"","loc":"sourcefile/vsvd0.f.html"},{"title":"flow_shear.f90 – stella","text":"Source Code module flow_shear implicit none public :: flow_shear_initialized public :: init_flow_shear , finish_flow_shear public :: prl_shear , prl_shear_p , prp_shear public :: advance_parallel_flow_shear , advance_perp_flow_shear public :: v_edge , v_shift public :: shift_times private logical :: flow_shear_initialized = . false . complex , dimension (:, :), allocatable :: upwind_advect real , dimension (:, :, :), allocatable :: prl_shear , prl_shear_p real , dimension (:), allocatable :: prp_shear , shift_times integer :: shift_sign , shift_start real :: v_edge , v_shift = 0. contains subroutine init_flow_shear use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx , imu_idx , is_idx use stella_time , only : code_dt use species , only : spec use constants , only : zi , pi use zgrid , only : nzgrid use kt_grids , only : x , x_d , nalpha , nx , nakx , naky , akx , aky , ikx_max , zonal_mode , box use fields_arrays , only : shift_state use stella_geometry , only : q_as_x , geo_surf , bmag , btor , rmajor , dBdrho , dIdrho use stella_geometry , only : dydalpha , drhodpsi use physics_parameters , only : g_exb , g_exbfac , omprimfac use vpamu_grids , only : vperp2 , vpa , mu use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use physics_flags , only : radial_variation , prp_shear_enabled , hammett_flow_shear use file_utils , only : runtype_option_switch , runtype_multibox use job_manage , only : njobs use mp , only : job , send , receive , crossdomprocs , subprocs , scope use run_parameters , only : maxwellian_normalization implicit none integer :: is , imu , iv , ivmu , iz , ia real , dimension (:, :), allocatable :: energy if ( flow_shear_initialized ) return flow_shear_initialized = . true . if ( abs ( g_exb * g_exbfac ) > epsilon ( 0. )) prp_shear_enabled = . true . if ( runtype_option_switch == runtype_multibox . and . job == 1 ) then hammett_flow_shear = . false . end if if ( runtype_option_switch == runtype_multibox ) then call scope ( crossdomprocs ) if ( job == 1 ) then call send ( g_exbfac * g_exb * x ( 1 ), 0 , 120 ) call send ( g_exbfac * g_exb * x ( nx ), njobs - 1 , 121 ) v_shift = 0.0 elseif ( job == 0 ) then call receive ( v_edge , 1 , 120 ) v_shift = v_edge - g_exbfac * g_exb * x ( 1 ) elseif ( job == njobs - 1 ) then call receive ( v_edge , 1 , 121 ) v_shift = v_edge - g_exbfac * g_exb * x ( nx ) end if call scope ( subprocs ) end if ia = 1 !parallel flow shear allocate ( energy ( nalpha , - nzgrid : nzgrid )) if (. not . allocated ( prl_shear )) then allocate ( prl_shear ( nalpha , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) prl_shear = 0.0 end if if ( radial_variation . and . . not . allocated ( prl_shear_p )) & allocate ( prl_shear_p ( nalpha , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) do iz = - nzgrid , nzgrid prl_shear ( ia , iz , ivmu ) = - omprimfac * g_exb * code_dt * vpa ( iv ) * spec ( is )% stm_psi0 & * dydalpha * drhodpsi & * ( geo_surf % qinp_psi0 / geo_surf % rhoc_psi0 ) & * ( btor ( iz ) * rmajor ( iz ) / bmag ( ia , iz )) * ( spec ( is )% mass / spec ( is )% temp ) end do if (. not . maxwellian_normalization ) then do iz = - nzgrid , nzgrid prl_shear ( ia , iz , ivmu ) = prl_shear ( ia , iz , ivmu ) & * maxwell_vpa ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) * maxwell_fac ( is ) end do end if if ( radial_variation ) then energy = ( vpa ( iv ) ** 2 + vperp2 (:, :, imu )) * ( spec ( is )% temp_psi0 / spec ( is )% temp ) prl_shear_p (:, :, ivmu ) = prl_shear (:, :, ivmu ) * ( dIdrho / spread ( rmajor * btor , 1 , nalpha ) & - spread ( dBdrho , 1 , nalpha ) / bmag & - spec ( is )% fprim - spec ( is )% tprim * ( energy - 2.5 ) & - 2. * mu ( imu ) * spread ( dBdrho , 1 , nalpha )) end if end do if ( q_as_x ) prl_shear = prl_shear / geo_surf % shat_psi0 deallocate ( energy ) !perpendicular flow shear if (. not . allocated ( shift_times )) allocate ( shift_times ( naky )) if (. not . allocated ( upwind_advect )) allocate ( upwind_advect ( naky , nakx )) if (. not . allocated ( shift_state )) then allocate ( shift_state ( naky )) shift_state = 0. end if if ( nakx > 1 . and . abs ( g_exb * g_exbfac ) > 0 ) then shift_times = abs ( akx ( 2 ) / ( aky * g_exb * g_exbfac )) end if if ( zonal_mode ( 1 )) shift_times ( 1 ) = huge ( 0. ) if ( g_exb * g_exbfac > 0. ) then shift_sign = - 1 shift_start = ikx_max else shift_sign = 1 shift_start = ikx_max + 1 end if if ( box ) upwind_advect = exp ( - zi * g_exbfac * g_exb * code_dt * spread ( aky , 2 , nakx ) * spread ( x_d , 1 , naky )) end subroutine init_flow_shear subroutine advance_parallel_flow_shear ( gout ) use mp , only : proc0 , mp_abort use physics_flags , only : full_flux_surface use stella_layouts , only : vmu_lo use zgrid , only : nzgrid , ntubes use kt_grids , only : nakx , naky use fields , only : get_dchidy use fields_arrays , only : phi , apar , bpar implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: gout complex , dimension (:, :), allocatable :: g0k integer :: ivmu , iz , it , ia ia = 1 allocate ( g0k ( naky , nakx )) if ( full_flux_surface ) then if ( proc0 ) write ( * , * ) '!!!WARNING: flow shear not currently supported for full_flux_surface=T!!!' call mp_abort ( \"flow shear not currently supported for full_flux_surface=T.\" ) end if do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid call get_dchidy ( iz , ivmu , phi (:, :, iz , it ), apar (:, :, iz , it ), bpar (:, :, iz , it ), g0k ) !parallel flow shear gout (:, :, iz , it , ivmu ) = gout (:, :, iz , it , ivmu ) + prl_shear ( ia , iz , ivmu ) * g0k end do end do end do deallocate ( g0k ) end subroutine advance_parallel_flow_shear subroutine advance_perp_flow_shear ( g ) use stella_layouts , only : vmu_lo use constants , only : zi use physics_flags , only : prp_shear_enabled , hammett_flow_shear use stella_transforms , only : transform_kx2x_unpadded , transform_x2kx_unpadded use zgrid , only : nzgrid , ntubes use fields_arrays , only : shift_state use kt_grids , only : aky , nakx , naky , ikx_max , zonal_mode use file_utils , only : runtype_option_switch , runtype_multibox use stella_time , only : code_dt implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in out ) :: g complex , dimension (:, :), allocatable :: g0k , g0x real :: shift_fac integer :: ivmu , iz , it , iky if (. not . prp_shear_enabled ) return allocate ( g0k ( naky , nakx )) allocate ( g0x ( naky , nakx )) if ( hammett_flow_shear ) then !TODO (DSO) - This assumes the timestep is small enough so that a shift is never !             more than a single cell do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid do iky = 1 , naky if ( zonal_mode ( iky )) cycle if ( shift_state ( iky ) > 0.5 * shift_times ( iky )) then if ( shift_sign < 0 ) then !shift everything left by one g ( iky , ( ikx_max + 1 ):( nakx - 1 ), iz , it , ivmu ) = g ( iky , ikx_max + 2 :, iz , it , ivmu ) g ( iky , nakx , iz , it , ivmu ) = g ( iky , 1 , iz , it , ivmu ) g ( iky , : ikx_max - 1 , iz , it , ivmu ) = g ( iky , 2 : ikx_max , iz , it , ivmu ) else !shift everything right by one g ( iky , 2 : ikx_max , iz , it , ivmu ) = g ( iky , 1 :( ikx_max - 1 ), iz , it , ivmu ) g ( iky , 1 , iz , it , ivmu ) = g ( iky , nakx , iz , it , ivmu ) g ( iky , ikx_max + 2 :, iz , it , ivmu ) = g ( iky , ( ikx_max + 1 ):( nakx - 1 ), iz , it , ivmu ) end if g ( iky , shift_start , iz , it , ivmu ) = 0. end if end do end do end do end do else do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid g0k = g (:, :, iz , it , ivmu ) call transform_kx2x_unpadded ( g0k , g0x ) g0x = upwind_advect * g0x call transform_x2kx_unpadded ( g0x , g0k ) do iky = 1 , naky if ( zonal_mode ( iky )) cycle if ( shift_state ( iky ) > shift_times ( iky )) then g0k ( iky , shift_start ) = 0.0 end if end do g (:, :, iz , it , ivmu ) = g0k end do end do end do end if shift_fac = 1.0 if ( hammett_flow_shear ) shift_fac = 0.5 do iky = 1 , naky if ( zonal_mode ( iky )) cycle if ( shift_state ( iky ) > shift_fac * shift_times ( iky )) then shift_state ( iky ) = shift_state ( iky ) - shift_times ( iky ) end if end do shift_state = shift_state + code_dt if ( zonal_mode ( 1 )) shift_state ( 1 ) = 0. if ( runtype_option_switch == runtype_multibox ) then do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc do it = 1 , ntubes do iz = - nzgrid , nzgrid g (:, :, iz , it , ivmu ) = g (:, :, iz , it , ivmu ) * exp ( - code_dt * zi * spread ( aky , 2 , nakx ) * v_shift ) end do end do end do end if deallocate ( g0k , g0x ) end subroutine advance_perp_flow_shear subroutine finish_flow_shear use fields_arrays , only : shift_state implicit none if ( allocated ( prl_shear )) deallocate ( prl_shear ) if ( allocated ( prl_shear_p )) deallocate ( prl_shear_p ) if ( allocated ( shift_times )) deallocate ( shift_times ) if ( allocated ( shift_state )) deallocate ( shift_state ) if ( allocated ( upwind_advect )) deallocate ( upwind_advect ) flow_shear_initialized = . false . end subroutine finish_flow_shear end module flow_shear","tags":"","loc":"sourcefile/flow_shear.f90.html"},{"title":"sfincs_interface.fpp – stella","text":"Source Code module sfincs_interface implicit none public :: get_neo_from_sfincs private # ifdef USE_SFINCS integer :: nproc_sfincs integer :: irad_min , irad_max real :: Er_window logical :: includeXDotTerm logical :: includeElectricFieldTermInXiDot !  logical :: includeRadialExBDrive integer :: magneticDriftScheme logical :: includePhi1 logical :: includePhi1InKineticEquation !  logical :: includePhi1InCollisionOperator integer :: geometryScheme integer :: VMECRadialOption integer :: coordinateSystem integer :: inputRadialCoordinate integer :: inputRadialCoordinateForGradients character ( 200 ) :: equilibriumFile real :: aHat , psiAHat , Delta real :: nu_n , dPhiHatdrN integer :: nxi , nx , ntheta , nzeta logical :: calculate_radial_electric_field logical :: read_sfincs_output_from_file logical :: sfincs_finished = . true . real , dimension (:), allocatable :: fprim_local , tprim_local # endif contains subroutine get_neo_from_sfincs ( nradii , drho , f_neoclassical , phi_neoclassical , & dfneo_dalpha , dphineo_dalpha ) # ifdef USE_SFINCS use mp , only : proc0 , iproc use mp , only : comm_split , comm_free use stella_geometry , only : geo_surf use species , only : spec , nspec # endif use mp , only : mp_abort use zgrid , only : nzgrid implicit none integer , intent ( in ) :: nradii real , intent ( in ) :: drho real , dimension (:, - nzgrid :, :, :, :, - nradii / 2 :), intent ( out ) :: f_neoclassical real , dimension (:, - nzgrid :, - nradii / 2 :), intent ( out ) :: phi_neoclassical real , dimension (:, - nzgrid :, :, :, :), intent ( out ) :: dfneo_dalpha real , dimension (:, - nzgrid :), intent ( out ) :: dphineo_dalpha # ifdef USE_SFINCS integer :: sfincs_comm integer :: color , ierr integer :: irad real :: dPhiHatdrN_best_guess logical :: Er_converged integer :: nsfincs_calls if (. not . allocated ( fprim_local )) allocate ( fprim_local ( nspec )) if (. not . allocated ( tprim_local )) allocate ( tprim_local ( nspec )) if ( proc0 ) call read_sfincs_parameters ( nradii ) call broadcast_sfincs_parameters if ( iproc < nproc_sfincs ) then color = 0 else color = 1 end if call comm_split ( color , sfincs_comm , ierr ) if ( iproc < nproc_sfincs ) then do irad = irad_min , irad_max ! get local values of -dlog(ns)/drho and -dlog(Ts)/drho ! using dlog(n)/drho = dlog(n0)/drho + delrho*d/drho(dlog(n)/drho) fprim_local = 1.0 / geo_surf % drhotordrho * ( spec % fprim & + irad * drho * ( spec % fprim ** 2 - spec % d2ndr2 ) / geo_surf % drhotordrho ) tprim_local = 1.0 / geo_surf % drhotordrho * ( spec % tprim & + irad * drho * ( spec % tprim ** 2 - spec % d2Tdr2 ) / geo_surf % drhotordrho ) !          fprim_local = 1.0/geo_surf%drhotordrho*(spec%fprim - irad*drho*spec%d2ndr2) !          tprim_local = 1.0/geo_surf%drhotordrho*(spec%tprim - irad*drho*spec%d2Tdr2) if ( calculate_radial_electric_field ) then ! get best guess at radial electric field ! using force balance with radial pressure gradient if ( dPhiHatdrN > - 999 9.0 ) then dPhiHatdrN_best_guess = dPhiHatdrN else dPhiHatdrN_best_guess = fprim_local ( 1 ) + tprim_local ( 1 ) end if call iterate_sfincs_until_electric_field_converged ( sfincs_comm , & irad , drho , irad_max , dPhiHatdrN_best_guess , & Er_converged , nsfincs_calls ) if ( proc0 ) then write ( * , * ) write ( * , * ) 'At irad= ' , irad , 'Er_converged= ' , Er_converged , & 'nsfincs_calls_required= ' , nsfincs_calls , 'dPhiHatdrN= ' , dPhiHatdrN write ( * , * ) end if ! write_and_finish_sfincs manipulates sfincs output ! to get the neoclassical distribution function and potential ! on the stella (zed,alpha,vpa,mu) grid; it then ! deallocates sfincs arrays, etc. to make it ready ! for running again if need be call write_and_finish_sfincs ( f_neoclassical (:, :, :, :, :, irad ), & phi_neoclassical (:, :, irad ), dfneo_dalpha , dphineo_dalpha , irad ) else ! init_and_run_sfincs initializes sfincs, ! including passing geometry info if necessary; ! and runs sfincs (if requested) call init_and_run_sfincs ( sfincs_comm , irad , drho , irad_max ) ! write_and_finish_sfincs manipulates sfincs output ! to get the neoclassical distribution function and potential ! on the stella (zed,alpha,vpa,mu) grid; it then ! deallocates sfincs arrays, etc. to make it ready ! for running again if need be call write_and_finish_sfincs ( f_neoclassical (:, :, :, :, :, irad ), & phi_neoclassical (:, :, irad ), dfneo_dalpha , dphineo_dalpha , irad ) end if end do end if call comm_free ( sfincs_comm , ierr ) ! NB: NEED TO CHECK THIS BROADCAST OF SFINCS RESULTS do irad = irad_min , irad_max call broadcast_sfincs_output & ( f_neoclassical (:, :, :, :, :, irad ), phi_neoclassical (:, :, irad )) end do call broadcast_sfincs_output ( dfneo_dalpha , dphineo_dalpha ) deallocate ( fprim_local , tprim_local ) if ( proc0 ) then write ( * , * ) write ( * , * ) 'maxval(fneo): ' , maxval ( f_neoclassical (:, :, :, :, :, irad_min : irad_max )), & 'maxval(phineo): ' , maxval ( phi_neoclassical (:, :, irad_min : irad_max )) write ( * , * ) end if if (( irad_min /= - nradii / 2 ) . or . ( irad_max /= nradii / 2 )) & call mp_abort ( 'WARNING: irad_min must equal -nradii/2 and irad_max must equal & & nradii/2 to proceed to stella calculation.  aborting.' ) # else real :: dum ! this pointless dum assignment only here to avoid ! annoying warning messages during compilation ! about unused variable drho dum = drho f_neoclassical = 0. ; phi_neoclassical = 0. dfneo_dalpha = 0. ; dphineo_dalpha = 0. call mp_abort ( \"to run with include_neoclassical_terms=.true., & & USE_SFINCS must be defined at compilation time.  Aborting.\" ) # endif end subroutine get_neo_from_sfincs # ifdef USE_SFINCS subroutine iterate_sfincs_until_electric_field_converged ( & sfincs_comm , irad , drho , nrad_max , dPhiHatdrN_best_guess , & dphiHatdrN_is_converged , number_of_sfincs_calls_for_convergence ) use mp , only : proc0 , iproc implicit none integer , intent ( in ) :: sfincs_comm , irad , nrad_max real , intent ( in ) :: drho , dPhiHatdrN_best_guess logical , intent ( out ) :: dPhiHatdrN_is_converged integer , intent ( out ) :: number_of_sfincs_calls_for_convergence integer :: itmax_bracket = 10 integer :: itmax_root = 10 real :: window = 0.3 real :: tol = 0.1 integer :: it real :: a , b , c , d , e , fa , fb , fc , p , q , r , s , tol1 , xm , eps real :: converged_dPhiHatdrN dPhiHatdrN_is_converged = . false . a = dPhiHatdrN_best_guess * ( 1.0 - Er_window ) b = dPhiHatdrN_best_guess * ( 1.0 + Er_window ) ! initialize sfincs, run it, and return the total charge flux as fa call get_total_charge_flux ( sfincs_comm , irad , drho , nrad_max , a , fa ) call get_total_charge_flux ( sfincs_comm , irad , drho , nrad_max , b , fb ) number_of_sfincs_calls_for_convergence = 2 do it = 1 , itmax_bracket eps = epsilon ( a ) if (( fa > 0.0 . and . fb > 0.0 ) . or . ( fa < 0.0 . and . fb < 0.0 )) then if ( proc0 ) then write ( * , * ) write ( * , * ) 'dPhiHatdrN values ' , a , ' and ' , b , ' do not bracket root.' write ( * , * ) 'flux at ' , a , ' is ' , fa , '.' write ( * , * ) 'flux at ' , b , ' is ' , fb , '.' end if a = a * ( 1.0 - Er_window ) b = b * ( 1.0 + Er_window ) if ( proc0 ) then write ( * , * ) 'Trying again with values ' , a , ' and ' , b , ' .' write ( * , * ) end if call get_total_charge_flux ( sfincs_comm , irad , drho , nrad_max , a , fa ) call get_total_charge_flux ( sfincs_comm , irad , drho , nrad_max , b , fb ) number_of_sfincs_calls_for_convergence = number_of_sfincs_calls_for_convergence + 2 !           ! eliminate the endpoint corresonding to the flux that is furthest from zero in magnitude !           if (abs(fa) > abs(fb)) then !              ! keep b as an endpoint and eliminate a !              a = b ; fa = fb !              b = a*(1.0+window) !              if (proc0) then !                 write (*,*) 'Trying again with values ', a, ' and ', b, ' .' !                 write (*,*) !              end if !              call get_total_charge_flux (sfincs_comm, irad, drho, nrad_max, b, fb) !           else !              ! keep a as an endpoint and eliminate b !              b = a ; fb = fa !              a = b*(1.0-window) !              if (proc0) then !                 write (*,*) 'Trying again with values ', a, ' and ', b, ' .' !                 write (*,*) !              end if !              call get_total_charge_flux (sfincs_comm, irad, drho, nrad_max, a, fa) !           end if else exit end if end do c = b fc = fb do it = 1 , itmax_root if (( fb > 0.0 . and . fc > 0.0 ) . or . ( fb < 0.0 . and . fc < 0.0 )) then c = a fc = fa d = b - a e = d end if if ( abs ( fc ) < abs ( fb )) then a = b b = c c = a fa = fb fb = fc fc = fa end if tol1 = 2.0 * eps * abs ( b ) + 0.5 * tol xm = 0.5 * ( c - b ) if ( abs ( xm ) <= tol1 . or . fb == 0.0 ) then converged_dPhiHatdrN = b dPhiHatdrN_is_converged = . true . !          number_of_sfincs_calls_for_convergence = it+1 exit end if if ( abs ( e ) >= tol1 . and . abs ( fa ) > abs ( fb )) then s = fb / fa if ( a == c ) then p = 2.0 * xm * s q = 1.0 - s else q = fa / fc r = fb / fc p = s * ( 2.0 * xm * q * ( q - r ) - ( b - a ) * ( r - 1.0 )) q = ( q - 1.0 ) * ( r - 1.0 ) * ( s - 1.0 ) end if if ( p > 0.0 ) q = - q p = abs ( p ) if ( 2.0 * p < min ( 3.0 * xm * q - abs ( tol1 * q ), abs ( e * q ))) then e = d d = p / q else d = xm e = d end if else d = xm e = d end if a = b fa = fb b = b + merge ( d , sign ( tol1 , xm ), abs ( d ) > tol1 ) call get_total_charge_flux ( sfincs_comm , irad , drho , nrad_max , b , fb ) number_of_sfincs_calls_for_convergence = number_of_sfincs_calls_for_convergence + 1 end do end subroutine iterate_sfincs_until_electric_field_converged subroutine get_total_charge_flux ( sfincs_comm , irad , drho , nrad_max , & dPhiHatdrN_in , total_charge_flux ) use mp , only : iproc , broadcast_with_comm use sfincs_main , only : finish_sfincs use globalVariables , only : Zs , particleFlux_vd_psiHat use species , only : nspec implicit none integer , intent ( in ) :: sfincs_comm , irad , nrad_max real , intent ( in ) :: drho real , intent ( in ) :: dPhiHatdrN_in real , intent ( out ) :: total_charge_flux dPhiHatdrN = dPhiHatdrN_in call init_and_run_sfincs ( sfincs_comm , irad , drho , nrad_max ) call broadcast_with_comm ( Zs , sfincs_comm ) call broadcast_with_comm ( particleFlux_vd_psiHat , sfincs_comm ) total_charge_flux = sum ( Zs (: nspec ) * particleFlux_vd_psiHat (: nspec )) end subroutine get_total_charge_flux subroutine init_and_run_sfincs ( sfincs_comm , irad , drho , nrad_max ) use mp , only : proc0 , iproc use sfincs_main , only : init_sfincs , prepare_sfincs , run_sfincs , finish_sfincs use globalVariables , only : Zs , particleFlux_vd_psiHat use species , only : nspec implicit none integer , intent ( in ) :: sfincs_comm , irad , nrad_max real , intent ( in ) :: drho if (. not . sfincs_finished ) then call finish_sfincs sfincs_finished = . true . end if call init_sfincs ( sfincs_comm ) call pass_inputoptions_to_sfincs ( irad * drho ) call pass_outputoptions_to_sfincs call prepare_sfincs ! if geometryScheme = 5, then sfincs will read in equilibrium ! parameters from vmec file separately ! otherwise, assume system is axisymmetric and pass geometry ! from stella (miller local equilibrium or similar) if ( geometryScheme /= 5 ) call pass_geometry_to_sfincs ( irad * drho ) if ( read_sfincs_output_from_file ) then if ( proc0 ) call read_sfincs_output ( irad , nrad_max ) else if ( proc0 ) then write ( * , * ) write ( * , * ) 'Running sfincs at irad= ' , irad , ', with dPhiHatdrN= ' , dPhiHatdrN end if call run_sfincs if ( proc0 ) then write ( * , * ) 'sfincs finished running.  total charge flux= ' , sum ( Zs (: nspec ) * particleFlux_vd_psiHat (: nspec )) write ( * , * ) end if ! write Phi1Hat and delta_f to file ! so we have the option of using it ! again without re-running sfincs if ( proc0 ) call write_sfincs ( irad , nrad_max ) end if sfincs_finished = . false . end subroutine init_and_run_sfincs subroutine write_and_finish_sfincs ( fneo , phineo , dfneo , dphineo , irad ) use mp , only : proc0 use sfincs_main , only : finish_sfincs use zgrid , only : nzgrid implicit none real , dimension (:, - nzgrid :, :, :, :), intent ( out ) :: fneo real , dimension (:, - nzgrid :), intent ( out ) :: phineo real , dimension (:, - nzgrid :, :, :, :), intent ( in out ) :: dfneo real , dimension (:, - nzgrid :), intent ( in out ) :: dphineo integer , intent ( in ) :: irad if ( proc0 ) then ! only need to compute dfneo_dalpha and dphineo_dalpha ! for central radius and for stellarator calculation if ( irad == 0 . and . geometryScheme == 5 ) then call get_sfincs_output ( fneo , phineo , dfneo , dphineo ) else call get_sfincs_output ( fneo , phineo ) end if end if call finish_sfincs end subroutine write_and_finish_sfincs subroutine read_sfincs_parameters ( nradii ) use constants , only : pi use mp , only : nproc use file_utils , only : input_unit_exist use species , only : nspec use physics_parameters , only : rhostar , vnew_ref use stella_geometry , only : geo_surf , aref , bref implicit none integer , intent ( in ) :: nradii namelist / sfincs_input / nproc_sfincs , & calculate_radial_electric_field , & includeXDotTerm , & includeElectricFieldTermInXiDot , & irad_min , irad_max , & magneticDriftScheme , & includePhi1 , & includePhi1InKineticEquation , & !         includePhi1InCollisionOperator, & geometryScheme , & VMECRadialOption , & equilibriumFile , & coordinateSystem , & inputRadialCoordinate , & inputRadialCoordinateForGradients , & aHat , psiAHat , nu_N , nxi , nx , Delta , & dPhiHatdrN , & ntheta , nzeta , & read_sfincs_output_from_file , Er_window logical :: exist integer :: in_file ! if read_sfincs_output_from_file=.true., ! will try to read in Phi1Hat and delta_f ! from pre-saved file named sfincs.output ! otherwise, run sfincs to compute these ! quantities on the fly read_sfincs_output_from_file = . false . ! number of processors to use for sfincs calculation nproc_sfincs = 1 ! minimum and maximum radial index (irad=0 corresponds to central radius) irad_min = - nradii / 2 ; irad_max = nradii / 2 ! if calculate_radial_electric_field, then ! will scan in radial electric field to find value ! for which ambipolarity is satisfied, and then ! use this value to obtain neoclassical fluxes, ! distribution function, and potential calculate_radial_electric_field = . true . ! do not include radial electric field term if set to .false. includeXDotTerm = . true . includeElectricFieldTermInXiDot = . true . ! include v_E . grad r term !    includeRadialExBDrive = .true. ! no poloidal or toroidal magnetic drifts magneticDriftScheme = 0 ! combo of next two variables means ! phi1 will be calculated via quasineutrality includePhi1 = . true . includePhi1InKineticEquation = . false . !    includePhi1InCollisionOperator = .false. ! will be overridden by direct input of geometric quantities ! unless geometryScheme = 5 (vmec equilibrium) geometryScheme = 1 ! only relevant if geometryScheme = 5 ! radial option to use for vmec equilibrium ! 0 corresponds to using radial interpolation to get desired surface ! 1 corresponds to using nearest surface on VMEC HALF grid ! 2 corresponds to using nearest surface on VMEC FULL grid ! should not change this unless self-consistently change in the ! vmec input namelist VMECRadialOption = 0 ! path of vmec equilibrium file equilibriumFile = 'wout_161s1.nc' ! seems to be a nonsensical option coordinateSystem = 3 ! option 3 corresponds to using sqrt of toroidal flux ! normalized by toroidal flux enclosed by the LCFS inputRadialCoordinate = 3 ! option 3 corresponds to same choice ! when calculating gradients of density, temperature, and potential inputRadialCoordinateForGradients = 3 ! corresponds to r_LCFS as reference length in sfincs ! only used in sfincs when geometryScheme=1 aHat = 1.0 ! psitor_LCFS / (B_ref * a_ref&#94;2) psiAHat = geo_surf % psitor_lcfs ! Delta is rho* = mref*vt_ref/(e*Bref*aref), with reference ! quantities given in SI units ! unless geometryScheme = 5, in which case Bref=1T ! and aref = 1m (these are hardwired in sfincs) ! set negative to allow check later to see if any value given in input file Delta = - 1.0 ! nu_n = nu_ref * aref/vt_ref ! nu_ref = 4*sqrt(2*pi)*nref*e**4*loglam/(3*sqrt(mref)*Tref**3/2) ! (with nref, Tref, and mref in Gaussian units) ! set negative to allow check later to see if any value given in input file nu_n = - 1.0 ! radial derivative of normalized phi dPhiHatdrN = - 999 9.9 Er_window = 0.3 ! number of spectral coefficients in pitch angle nxi = 48 ! number of speeds nx = 12 ! number of poloidal angles Ntheta = 65 ! number of toroidal angles, 1 is appropriate for tokamak Nzeta = 1 in_file = input_unit_exist ( \"sfincs_input\" , exist ) if ( exist ) read ( unit = in_file , nml = sfincs_input ) if ( nproc_sfincs > nproc ) then write ( * , * ) 'requested number of processors for sfincs is greater & & than total processor count.' write ( * , * ) 'allocating ' , nproc , ' processors for sfincs.' end if if ( Delta < 0.0 ) then Delta = rhostar ! if geometryScheme=5, Bref=1T and aref=1m are hard-wired in sfincs ! but these are not the values used in stella to define rhostar if ( geometryScheme == 5 ) Delta = rhostar * bref * aref end if if ( nu_n < 0.0 ) then nu_n = vnew_ref * ( 4. / ( 3. * sqrt ( pi ))) ! if geometryScheme=5, aref=1m is hard-wired in sfincs ! but this is not the value used in stella if ( geometryScheme == 5 ) nu_n = nu_n / aref end if ! FLAG -- NOT YET SURE IF THIS SHOULD BE HERE !    if (nspec == 1 .and. includePhi1) then !       write (*,*) 'includePhi1 = .true. is incompatible with a single-species run.' !       write (*,*) 'forcing includePhi1 = .false.' !       includePhi1 = .false. !    end if ! ensure that ntheta and nzeta are odd for SFINCS ntheta = 2 * ( ntheta / 2 ) + 1 nzeta = 2 * ( nzeta / 2 ) + 1 end subroutine read_sfincs_parameters subroutine broadcast_sfincs_parameters use mp , only : broadcast use physics_parameters , only : rhostar implicit none call broadcast ( read_sfincs_output_from_file ) call broadcast ( nproc_sfincs ) call broadcast ( irad_min ) call broadcast ( irad_max ) call broadcast ( calculate_radial_electric_field ) call broadcast ( includeXDotTerm ) call broadcast ( includeElectricFieldTermInXiDot ) !    call broadcast (includeRadialExBDrive) call broadcast ( magneticDriftScheme ) call broadcast ( includePhi1 ) call broadcast ( includePhi1InKineticEquation ) !    call broadcast (includePhi1InCollisionOperator) call broadcast ( geometryScheme ) call broadcast ( VMECRadialOption ) call broadcast ( equilibriumFile ) call broadcast ( coordinateSystem ) call broadcast ( inputRadialCoordinate ) call broadcast ( inputRadialCoordinateForGradients ) call broadcast ( aHat ) call broadcast ( psiAHat ) call broadcast ( Delta ) call broadcast ( nu_N ) call broadcast ( dPhiHatdrN ) call broadcast ( Er_window ) call broadcast ( nxi ) call broadcast ( nx ) call broadcast ( ntheta ) call broadcast ( nzeta ) write ( * , * ) 'Delta stella' , Delta , rhostar end subroutine broadcast_sfincs_parameters subroutine pass_inputoptions_to_sfincs ( delrho ) use mp , only : mp_abort use stella_geometry , only : geo_surf use species , only : spec , nspec use zgrid , only : nzed use physics_parameters , only : nine , tite use globalVariables , only : includeXDotTerm_sfincs => includeXDotTerm use globalVariables , only : includeElectricFieldTermInXiDot_sfincs => includeElectricFieldTermInXiDot !    use globalVariables, only: includeRadialExBDrive_sfincs => includeRadialExBDrive use globalVariables , only : magneticDriftScheme_sfincs => magneticDriftScheme use globalVariables , only : includePhi1_sfincs => includePhi1 use globalVariables , only : includePhi1InKineticEquation_sfincs => includePhi1InKineticEquation !    use globalVariables, only: includePhi1InCollisionOperator_sfincs => includePhi1InCollisionOperator use globalVariables , only : geometryScheme_sfincs => geometryScheme use globalVariables , only : equilibriumFile_sfincs => equilibriumFile use globalVariables , only : VMECRadialOption_sfincs => VMECRadialOption use globalVariables , only : coordinateSystem_sfincs => coordinateSystem use globalVariables , only : RadialCoordinate => inputRadialCoordinate use globalVariables , only : RadialCoordinateForGradients => inputRadialCoordinateForGradients use globalVariables , only : rN_wish use globalVariables , only : Nspecies , nHats , THats , MHats , Zs use globalVariables , only : adiabaticNHat , adiabaticTHat , adiabaticZ use globalVariables , only : nxi_sfincs => Nxi use globalVariables , only : nx_sfincs => Nx use globalVariables , only : ntheta_sfincs => Ntheta use globalVariables , only : nzeta_sfincs => Nzeta use globalVariables , only : dnHatdrNs , dTHatdrNs use globalVariables , only : aHat_sfincs => aHat use globalVariables , only : psiAHat_sfincs => psiAHat use globalVariables , only : Delta_sfincs => Delta use globalVariables , only : nu_n_sfincs => nu_n use globalVariables , only : dPhiHatdrN_sfincs => dPhiHatdrN use globalVariables , only : withAdiabatic implicit none real , intent ( in ) :: delrho includeXDotTerm_sfincs = includeXDotTerm includeElectricFieldTermInXiDot_sfincs = includeElectricFieldTermInXiDot !    includeRadialExBDrive_sfincs = includeRadialExBDrive magneticDriftScheme_sfincs = magneticDriftScheme includePhi1_sfincs = includePhi1 includePhi1InKineticEquation_sfincs = includePhi1InKineticEquation !    includePhi1InCollisionOperator_sfincs = includePhi1InCollisionOperator geometryScheme_sfincs = geometryScheme VMECRadialOption_sfincs = VMECRadialOption equilibriumFile_sfincs = trim ( equilibriumFile ) coordinateSystem_sfincs = coordinateSystem RadialCoordinate = inputRadialCoordinate RadialCoordinateForGradients = inputRadialCoordinateForGradients Nspecies = nspec nHats (: nspec ) = spec % dens * ( 1.0 - delrho * spec % fprim ) THats (: nspec ) = spec % temp * ( 1.0 - delrho * spec % tprim ) mHats (: nspec ) = spec % mass Zs (: nspec ) = spec % z nzeta_sfincs = nzeta ntheta_sfincs = ntheta nx_sfincs = nx nxi_sfincs = nxi aHat_sfincs = aHat psiAHat_sfincs = psiAHat Delta_sfincs = Delta nu_n_sfincs = nu_n dPhiHatdrN_sfincs = dPhiHatdrN if ( nspec == 1 ) then withAdiabatic = . true . adiabaticNHat = nHats ( 1 ) / nine adiabaticTHat = THats ( 1 ) / tite adiabaticZ = - 1 end if if ( inputRadialCoordinate == 3 ) then rN_wish = geo_surf % rhotor + delrho * geo_surf % drhotordrho else call mp_abort ( 'only inputRadialCoordinate=3 currently supported. aborting.' ) end if if ( inputRadialCoordinateForGradients == 3 ) then ! radial density gradient with respect to rhotor = sqrt(psitor/psitor_LCFS) ! normalized by reference density (not species density) dnHatdrNs (: nspec ) = - spec % dens * fprim_local ! radial temperature gradient with respect to rhotor = sqrt(psitor/psitor_LCFS) ! normalized by reference tmperatures (not species temperature) dTHatdrNs (: nspec ) = - spec % temp * tprim_local else call mp_abort ( 'only inputRadialCoordinateForGradients=3 currently supported. aborting.' ) end if end subroutine pass_inputoptions_to_sfincs subroutine pass_outputoptions_to_sfincs use export_f , only : export_f_theta_option use export_f , only : export_f_zeta_option use export_f , only : export_f_xi_option use export_f , only : export_f_x_option use export_f , only : export_delta_f , export_full_f use export_f , only : export_f_stella implicit none export_f_theta_option = 0 export_f_zeta_option = 0 export_f_xi_option = 0 export_f_x_option = 0 export_delta_f = . true . export_full_f = . false . export_f_stella = . true . end subroutine pass_outputoptions_to_sfincs ! if this subroutine is being called, then ! using sfincs in tokamak geometry ! so zed in stella is theta subroutine pass_geometry_to_sfincs ( delrho ) use constants , only : pi use splines , only : linear_interp_periodic use zgrid , only : nz2pi , zed use stella_geometry , only : bmag , dbdzed , gradpar use stella_geometry , only : dBdrho , d2Bdrdth , dgradpardrho , dIdrho use stella_geometry , only : geo_surf use globalVariables , only : BHat use globalVariables , only : dBHatdtheta use globalVariables , only : iota use globalVariables , only : DHat use globalVariables , only : BHat_sup_theta use globalVariables , only : BHat_sub_zeta use export_f , only : export_f_theta implicit none real , intent ( in ) :: delrho integer :: nzeta = 1 integer :: nzpi real :: q_local real , dimension (:), allocatable :: B_local , dBdz_local , gradpar_local real , dimension (:), allocatable :: zed_stella real , dimension (:), allocatable :: theta_sfincs nzpi = nz2pi / 2 allocate ( B_local ( - nzpi : nzpi )) allocate ( dBdz_local ( - nzpi : nzpi )) allocate ( gradpar_local ( - nzpi : nzpi )) allocate ( theta_sfincs ( ntheta )) allocate ( zed_stella ( - nzpi : nzpi )) call init_zero_arrays ! first get some geometric quantities at this radius ! for theta from -pi to pi q_local = geo_surf % qinp * ( 1.0 + delrho * geo_surf % shat / geo_surf % rhoc ) B_local = bmag ( 1 , - nzpi : nzpi ) + delrho * dBdrho ( - nzpi : nzpi ) dBdz_local = dbdzed ( 1 , - nzpi : nzpi ) + delrho * d2Bdrdth ( - nzpi : nzpi ) gradpar_local = gradpar ( - nzpi : nzpi ) + delrho * dgradpardrho ( - nzpi : nzpi ) zed_stella = zed ( - nzpi : nzpi ) + pi theta_sfincs = export_f_theta (: ntheta ) iota = 1. / q_local ! interpolate from stella zed-grid to sfincs theta grid ! point at -pi (stella) is same as point at 0 (sfincs) BHat ( 1 , 1 ) = B_local ( - nzpi ) call linear_interp_periodic ( zed_stella , B_local , theta_sfincs ( 2 :), BHat ( 2 :, 1 )) ! FLAG -- needs to be changed for stellarator runs BHat = spread ( BHat (:, 1 ), 2 , nzeta ) dBHatdtheta ( 1 , 1 ) = dBdz_local ( - nzpi ) call linear_interp_periodic ( zed_stella , dBdz_local , theta_sfincs ( 2 :), dBHatdtheta ( 2 :, 1 )) dBHatdtheta = spread ( dBHatdtheta (:, 1 ), 2 , nzeta ) ! this is bhat . grad theta BHat_sup_theta ( 1 , 1 ) = B_local ( - nzpi ) * gradpar_local ( - nzpi ) call linear_interp_periodic ( zed_stella , B_local * gradpar_local , theta_sfincs ( 2 :), BHat_sup_theta ( 2 :, 1 )) BHat_sup_theta = spread ( BHat_sup_theta (:, 1 ), 2 , nzeta ) ! this is I(psi) / (aref*Bref) BHat_sub_zeta = geo_surf % rgeo + delrho * dIdrho ! this is grad psitor . (grad theta x grad zeta) ! note that + sign below relies on B = I grad zeta + grad zeta x grad psi DHat = q_local * BHat_sup_theta deallocate ( B_local , dBdz_local , gradpar_local ) deallocate ( theta_sfincs , zed_stella ) end subroutine pass_geometry_to_sfincs subroutine init_zero_arrays use globalVariables , only : dBHatdzeta use globalVariables , only : dBHatdpsiHat use globalVariables , only : BHat_sup_zeta use globalVariables , only : BHat_sub_psi use globalVariables , only : BHat_sub_theta use globalVariables , only : dBHat_sub_psi_dtheta use globalVariables , only : dBHat_sub_psi_dzeta use globalVariables , only : dBHat_sub_theta_dpsiHat use globalVariables , only : dBHat_sub_theta_dzeta use globalVariables , only : dBHat_sub_zeta_dpsiHat use globalVariables , only : dBHat_sub_zeta_dtheta use globalVariables , only : dBHat_sup_theta_dpsiHat use globalVariables , only : dBHat_sup_theta_dzeta use globalVariables , only : dBHat_sup_zeta_dpsiHat use globalVariables , only : dBHat_sup_zeta_dtheta implicit none dBHatdzeta = 0. dBHatdpsiHat = 0. BHat_sup_zeta = 0. BHat_sub_psi = 0. BHat_sub_theta = 0. dBHat_sub_psi_dtheta = 0. dBHat_sub_psi_dzeta = 0. dBHat_sub_theta_dpsiHat = 0. dBHat_sub_theta_dzeta = 0. dBHat_sub_zeta_dpsiHat = 0. dBHat_sub_zeta_dtheta = 0. dBHat_sup_theta_dpsiHat = 0. dBHat_sup_theta_dzeta = 0. dBHat_sup_zeta_dpsiHat = 0. dBHat_sup_zeta_dtheta = 0. end subroutine init_zero_arrays subroutine get_sfincs_output ( f_neoclassical , phi_neoclassical , & dfneo_dalpha , dphineo_dalpha ) use constants , only : pi use sort , only : sort_array_ascending , unsort_array_ascending use species , only : nspec use zgrid , only : nzgrid , nz2pi use export_f , only : h_sfincs => delta_f use globalVariables , only : Phi1Hat use kt_grids , only : nalpha implicit none real , dimension (:, - nzgrid :, :, :, :), intent ( out ) :: f_neoclassical real , dimension (:, - nzgrid :), intent ( out ) :: phi_neoclassical real , dimension (:, - nzgrid :, :, :, :), intent ( out ), optional :: dfneo_dalpha real , dimension (:, - nzgrid :), intent ( out ), optional :: dphineo_dalpha integer :: i , j integer :: ialpha , iz , is real , dimension (:), allocatable :: zed_stella integer :: nfp , nfp_stella integer , dimension (:), allocatable :: nzed_per_field_period real , dimension (:, :), allocatable :: zed_stella_by_field_period real , dimension (:, :), allocatable :: alpha_like_stella integer , dimension (:, :), allocatable :: alpha_sort_map integer :: nzed_sfincs , nalpha_sfincs real , dimension (:), allocatable :: zed_sfincs , alpha_like_sfincs real , dimension (:, :), allocatable :: phi_sfincs real , dimension (:, :), allocatable :: phi_stella_zgrid , phi_stella real , dimension (:, :), allocatable :: dphi_dalpha_stella_zgrid real , dimension (:, :), allocatable :: tmp_sfincs , tmp_stella_zgrid , tmp_stella real , dimension (:, :), allocatable :: dh_stella_zgrid real , dimension (:, :, :, :), allocatable :: h_stella , dh_stella ! zed coordinate in stella is zeta when simulating stellarators (using vmec) ! and theta otherwise.  this leads to some complications, treated below allocate ( zed_stella ( nz2pi )) allocate ( alpha_like_stella ( nalpha , nz2pi )) allocate ( alpha_sort_map ( nalpha , nz2pi )) ! obtain theta and zeta grids used in stella, and assign them ! to the zed and alpha-like coordinates. ! for stellarator, zed=zeta and alpha_like=theta. ! for tokamak, zed=theta and alpha_like = zeta. call get_stella_theta_zeta_grids ( alpha_like_stella , zed_stella ) !    do iz = 1, nz2pi !       do ialpha = 1, size(alpha_like_stella,1) !          write (*,*) 'unsorted_alpha_like_stella', alpha_like_stella(ialpha,iz) !       end do !       write (*,*) !    end do ! rearrange alpha_like_stella to be in ascending order and store map ! so that sorting can be undone later do iz = 1 , nz2pi call sort_array_ascending ( alpha_like_stella (:, iz ), alpha_sort_map (:, iz )) end do !    do iz = 1, nz2pi !       do ialpha = 1, size(alpha_like_stella,1) !          write (*,*) 'sorted_alpha_like_stella', alpha_like_stella(ialpha,iz) !       end do !       write (*,*) !    end do ! obtain the number of alpha-like and zed grid points to use in sfincs theta-zeta grid ! also obtain the number of field periods per 2*pi segment in zed call get_sfincs_theta_zeta_grid_sizes ( nalpha_sfincs , nzed_sfincs , nfp ) ! obtain the alpha-like and zed coordinate grids ! note that additional points are added at periodic points ! that are not sampled in sfincs allocate ( zed_sfincs ( nzed_sfincs )) allocate ( alpha_like_sfincs ( nalpha_sfincs )) call get_sfincs_theta_zeta_grids ( alpha_like_sfincs , zed_sfincs ) allocate ( phi_sfincs ( nalpha_sfincs , nzed_sfincs )) call get_sfincs_field_theta_zeta ( Phi1Hat , phi_sfincs ) ! this is the number of field periods included in stella ! simulation domain nfp_stella = int (( zed_stella ( nz2pi ) * nfp - 10 0. * epsilon ( 0. )) / ( 2. * pi )) + 1 ! obtain the number of zed grid points in each field period within the zed domain allocate ( nzed_per_field_period ( nfp_stella )) call get_nzed_per_field_period ( zed_stella , nfp , nzed_per_field_period ) ! obtain the zed grid within each field period allocate ( zed_stella_by_field_period ( maxval ( nzed_per_field_period ), nfp_stella )) call sort_zed_by_field_period ( zed_stella , nzed_per_field_period , nfp , zed_stella_by_field_period ) ! interpolate phi from sfincs zed grid to stella zed grid allocate ( phi_stella_zgrid ( nalpha_sfincs , nz2pi )) call get_field_on_stella_zed_grid ( phi_sfincs , nfp_stella , nfp , nzed_per_field_period , & nalpha_sfincs , zed_sfincs , zed_stella_by_field_period , phi_stella_zgrid ) allocate ( phi_stella ( nalpha , nz2pi )) ! interpolate onto stella (sorted) alpha grid call get_field_stella ( phi_stella_zgrid , alpha_like_sfincs , alpha_like_stella , phi_stella ) ! need to remap from ascending (sorted) alpha grid to original ordering do iz = 1 , nz2pi call unsort_array_ascending ( phi_stella (:, iz ), alpha_sort_map (:, iz )) end do call get_field_on_extended_zed ( phi_stella , phi_neoclassical ) if ( present ( dphineo_dalpha )) then allocate ( dphi_dalpha_stella_zgrid ( nalpha_sfincs , nz2pi )) call get_dfield_dalpha ( phi_stella_zgrid , alpha_like_sfincs , dphi_dalpha_stella_zgrid ) call get_field_stella ( dphi_dalpha_stella_zgrid , alpha_like_sfincs , alpha_like_stella , phi_stella ) do iz = 1 , nz2pi call unsort_array_ascending ( phi_stella (:, iz ), alpha_sort_map (:, iz )) end do call get_field_on_extended_zed ( phi_stella , dphineo_dalpha ) deallocate ( dphi_dalpha_stella_zgrid ) end if deallocate ( phi_stella , phi_stella_zgrid , phi_sfincs ) allocate ( tmp_sfincs ( nalpha_sfincs , nzed_sfincs )) allocate ( tmp_stella_zgrid ( nalpha_sfincs , nz2pi )) allocate ( tmp_stella ( nalpha , nz2pi )) allocate ( h_stella ( nalpha , nz2pi , size ( h_sfincs , 4 ), size ( h_sfincs , 5 ))) if ( present ( dfneo_dalpha )) then allocate ( dh_stella_zgrid ( nalpha_sfincs , nz2pi )) allocate ( dh_stella ( nalpha , nz2pi , size ( h_sfincs , 4 ), size ( h_sfincs , 5 ))) end if do is = 1 , nspec do i = 1 , size ( h_sfincs , 5 ) do j = 1 , size ( h_sfincs , 4 ) ! re-order theta and zeta indices for sfincs h to ensure alpha-like coordinate ! appears before zed coordinate call get_sfincs_field_theta_zeta ( h_sfincs ( is , :, :, j , i ), tmp_sfincs ) ! interpolate onto stella zed grid call get_field_on_stella_zed_grid ( tmp_sfincs , nfp_stella , nfp , nzed_per_field_period , & nalpha_sfincs , zed_sfincs , zed_stella_by_field_period , tmp_stella_zgrid ) ! interpolate onto (sorted) stella alpha-like coordinate call get_field_stella ( tmp_stella_zgrid , alpha_like_sfincs , alpha_like_stella , tmp_stella ) do iz = 1 , nz2pi call unsort_array_ascending ( tmp_stella (:, iz ), alpha_sort_map (:, iz )) end do ! use periodicity to copy onto extended zed grid if nperiod > 1 call get_field_on_extended_zed ( tmp_stella , h_stella (:, :, j , i )) if ( present ( dfneo_dalpha )) then call get_dfield_dalpha ( tmp_stella_zgrid , alpha_like_sfincs , dh_stella_zgrid ) call get_field_stella ( dh_stella_zgrid , alpha_like_sfincs , & alpha_like_stella , tmp_stella ) do iz = 1 , nz2pi call unsort_array_ascending ( tmp_stella (:, iz ), alpha_sort_map (:, iz )) end do call get_field_on_extended_zed ( tmp_stella , dh_stella (:, :, j , i )) end if end do end do do ialpha = 1 , nalpha do iz = - nzgrid , nzgrid call sfincs_vspace_to_stella_vspace ( ialpha , iz , is , h_stella ( ialpha , iz + nzgrid + 1 , :, :), & phi_neoclassical ( ialpha , iz ), f_neoclassical ( ialpha , iz , :, :, is )) if ( present ( dfneo_dalpha )) & call sfincs_vspace_to_stella_vspace ( ialpha , iz , is , & dh_stella ( ialpha , iz + nzgrid + 1 , :, :), dphineo_dalpha ( ialpha , iz ), & dfneo_dalpha ( ialpha , iz , :, :, is )) end do end do end do deallocate ( tmp_sfincs , tmp_stella_zgrid , tmp_stella ) deallocate ( zed_stella , alpha_like_stella ) deallocate ( alpha_sort_map ) deallocate ( zed_sfincs , alpha_like_sfincs ) deallocate ( nzed_per_field_period , zed_stella_by_field_period ) deallocate ( h_stella ) if ( present ( dfneo_dalpha )) deallocate ( dh_stella , dh_stella_zgrid ) end subroutine get_sfincs_output subroutine get_stella_theta_zeta_grids ( alpha_like_stella , zed_stella ) use constants , only : pi use zgrid , only : nz2pi , zed use stella_geometry , only : zed_scalefac use stella_geometry , only : alpha use kt_grids , only : nalpha use globalVariables , only : iota implicit none real , dimension (:, :), intent ( out ) :: alpha_like_stella real , dimension (:), intent ( out ) :: zed_stella integer :: nzpi nzpi = nz2pi / 2 ! convert from scaled zed grid on [-pi,pi] ! to un-scaled grid with lower bound of zero ! note that zed_scalefac=1 unless geometryScheme=5 (VMEC) ! for geometryScheme=5, this will get extended zeta domain ! with lower bound of 0 zed_stella = ( zed ( - nzpi : nzpi ) + pi ) / zed_scalefac ! if geometryScheme is 5, then using vmec geo ! and thus zed in stella is scaled zeta ! otherwise zed in stella is theta if ( geometryScheme == 5 ) then ! alpha_like coordinate is theta = alpha + iota*zeta alpha_like_stella = spread ( alpha , 2 , nz2pi ) + spread ( iota * zed_stella , 1 , nalpha ) else ! alpha_like coordinate is zeta = (theta-alpha)/iota alpha_like_stella = ( spread ( zed_stella , 1 , nalpha ) - spread ( alpha , 2 , nz2pi )) / iota end if ! restrict alpha to [0,2*pi] alpha_like_stella = modulo ( alpha_like_stella , 2. * pi ) end subroutine get_stella_theta_zeta_grids subroutine get_nzed_per_field_period ( zed_stella , nfp , nzed_per_field_period ) use constants , only : pi use zgrid , only : nz2pi implicit none real , dimension (:), intent ( in ) :: zed_stella integer , intent ( in ) :: nfp integer , dimension (:), intent ( out ) :: nzed_per_field_period integer :: ifp , iz nzed_per_field_period = 0 ifp = 1 ; iz = 1 do while ( iz <= nz2pi ) if ( zed_stella ( iz ) <= ifp * 2. * pi / nfp ) then nzed_per_field_period ( ifp ) = nzed_per_field_period ( ifp ) + 1 iz = iz + 1 else ifp = ifp + 1 end if end do end subroutine get_nzed_per_field_period subroutine sort_zed_by_field_period ( zed_ext , nzed_per_fp , nfp , zed_by_fp ) use constants , only : pi implicit none real , dimension (:), intent ( in ) :: zed_ext integer , dimension (:), intent ( in ) :: nzed_per_fp integer , intent ( in ) :: nfp real , dimension (:, :), intent ( out ) :: zed_by_fp integer :: ifp , llim , ulim ulim = 0 do ifp = 1 , size ( zed_by_fp , 2 ) llim = ulim + 1 ulim = llim + nzed_per_fp ( ifp ) - 1 zed_by_fp (: nzed_per_fp ( ifp ), ifp ) = modulo ( zed_ext ( llim : ulim ) - 10 0. * epsilon ( 0. ), 2. * pi / nfp ) end do ! avoid special case of setting zed = 0 to zed=2*pi/nfp zed_by_fp ( 1 , 1 ) = 0.0 end subroutine sort_zed_by_field_period subroutine get_sfincs_theta_zeta_grid_sizes ( nalpha_sfincs , nzed_sfincs , nfp ) use constants , only : pi use export_f , only : export_f_zeta implicit none integer , intent ( out ) :: nalpha_sfincs , nzed_sfincs , nfp ! if geometryScheme is 5, then using vmec geo ! and thus zed in stella is scaled zeta ! otherwise zed in stella is theta if ( geometryScheme == 5 ) then ! note that zeta grid in sfincs only covers one field period of the stellarator ! get the number of field periods from the sfincs zeta grid nfp = nint ( 2. * pi / ( export_f_zeta ( nzeta ) + export_f_zeta ( 2 ))) ! zed coordinate is zeta nzed_sfincs = nzeta + 1 ! alpha_like coordinate is theta = alpha + iota*zeta nalpha_sfincs = ntheta + 1 else nfp = 1 ! zed coordinate is theta nzed_sfincs = ntheta + 1 ! alpha_like coordinate is zeta = (theta-alpha)*q nalpha_sfincs = nzeta end if end subroutine get_sfincs_theta_zeta_grid_sizes subroutine get_sfincs_theta_zeta_grids ( alpha_like_sfincs , zed_sfincs ) use export_f , only : export_f_theta , export_f_zeta implicit none real , dimension (:), intent ( out ) :: zed_sfincs , alpha_like_sfincs if ( geometryScheme == 5 ) then ! zed is zeta.  it goes from 0 to 2*pi/nfp - dzeta in sfincs, ! where nfp is the number of field periods zed_sfincs (: nzeta ) = export_f_zeta (: nzeta ) ! add in point at 2*pi/nfp using periodicity zed_sfincs ( nzeta + 1 ) = zed_sfincs ( nzeta ) + zed_sfincs ( 2 ) ! alpha-like coordinate is theta.  it goes from 0 to 2*pi-dtheta in sfincs alpha_like_sfincs (: ntheta ) = export_f_theta (: ntheta ) ! add in point at 2*pi using periodicity alpha_like_sfincs ( ntheta + 1 ) = export_f_theta ( ntheta ) + export_f_theta ( 2 ) else ! zed is theta.  it goes from 0 to 2*pi-dtheta in sfincs zed_sfincs (: ntheta ) = export_f_theta (: ntheta ) ! add in point at 2*pi using periodicity zed_sfincs ( ntheta + 1 ) = export_f_theta ( ntheta ) + export_f_theta ( 2 ) ! alpha-like coordinate is zeta.  there should only be 1 zeta for tokamak calculation alpha_like_sfincs (: nzeta ) = export_f_zeta (: nzeta ) end if end subroutine get_sfincs_theta_zeta_grids subroutine get_sfincs_field_theta_zeta ( field_in , field_out ) implicit none real , dimension (:, :), intent ( in ) :: field_in real , dimension (:, :), intent ( out ) :: field_out integer :: itheta , izeta ! want phi from sfincs such that alpha-like coordinate ! appears in first index and zed coordinate in second index if ( geometryScheme == 5 ) then ! get phi on sfincs (theta,zeta) grid field_out (: ntheta , : nzeta ) = field_in ! use periodicity in theta to add point at theta=2*pi field_out ( ntheta + 1 , : nzeta ) = field_out ( 1 , : nzeta ) ! use periodicity in zeta to add point at zeta = 2*pi/nfp field_out (:, nzeta + 1 ) = field_out (:, 1 ) else ! get phi on sfincs (zeta,theta) grid do izeta = 1 , nzeta do itheta = 1 , ntheta field_out ( izeta , itheta ) = field_in ( itheta , izeta ) end do end do ! use periodicity in theta to add point at 2*pi field_out (:, ntheta + 1 ) = field_out (:, 1 ) end if end subroutine get_sfincs_field_theta_zeta subroutine get_field_on_stella_zed_grid ( field_sfincs , nfp_stella , nfp , nzed_per_field_period , & nalpha_sfincs , zed_sfincs , zed_stella_by_field_period , field_stella_zgrid ) use constants , only : pi use splines , only : linear_interp_periodic implicit none real , dimension (:, :), intent ( in ) :: field_sfincs integer , intent ( in ) :: nfp_stella , nfp , nalpha_sfincs integer , dimension (:), intent ( in ) :: nzed_per_field_period real , dimension (:), intent ( in ) :: zed_sfincs real , dimension (:, :), intent ( in ) :: zed_stella_by_field_period real , dimension (:, :), intent ( out ) :: field_stella_zgrid integer :: ialpha , ifp integer :: llim , ulim do ialpha = 1 , nalpha_sfincs ulim = 0 do ifp = 1 , nfp_stella llim = ulim + 1 ulim = llim + nzed_per_field_period ( ifp ) - 1 call linear_interp_periodic ( zed_sfincs , field_sfincs ( ialpha , :), & zed_stella_by_field_period (: nzed_per_field_period ( ifp ), ifp ), & field_stella_zgrid ( ialpha , llim : ulim ), 2. * pi / nfp ) end do end do end subroutine get_field_on_stella_zed_grid subroutine get_field_stella ( field_stella_zgrid , alpha_like_sfincs , alpha_like_stella , field_stella ) use splines , only : linear_interp_periodic use zgrid , only : nz2pi implicit none real , dimension (:, :), intent ( in ) :: field_stella_zgrid real , dimension (:), intent ( in ) :: alpha_like_sfincs real , dimension (:, :), intent ( in ) :: alpha_like_stella real , dimension (:, :), intent ( out ) :: field_stella integer :: iz do iz = 1 , nz2pi call linear_interp_periodic ( alpha_like_sfincs , field_stella_zgrid (:, iz ), & alpha_like_stella (:, iz ), field_stella (:, iz )) end do end subroutine get_field_stella subroutine get_field_on_extended_zed ( field_stella , field_neoclassical ) use zgrid , only : nzgrid , nz2pi , nperiod use kt_grids , only : nalpha implicit none real , dimension (:, :), intent ( in ) :: field_stella real , dimension (:, - nzgrid :), intent ( out ) :: field_neoclassical integer :: ialpha integer :: iz_low , iz_up integer :: ip ! need to account for cases with nperiod > 1 do ialpha = 1 , nalpha iz_low = - nzgrid iz_up = - nzgrid + nz2pi - 1 field_neoclassical ( ialpha , iz_low : iz_up ) = field_stella ( ialpha , :) ! if nperiod > 1 need to make copies of ! neoclassical potential for other 2pi segments if ( nperiod > 1 ) then do ip = 2 , 2 * nperiod - 1 iz_low = iz_up + 1 iz_up = iz_low + nz2pi - 2 field_neoclassical ( ialpha , iz_low : iz_up ) = field_stella ( ialpha , 2 :) end do end if end do end subroutine get_field_on_extended_zed subroutine sfincs_vspace_to_stella_vspace ( ialpha , iz , is , h_stella , phi_neoclassical , f_neoclassical ) use constants , only : pi use species , only : spec use vpamu_grids , only : nvpa , nvgrid , nmu use vpamu_grids , only : vpa , vperp2 use vpamu_grids , only : maxwell_mu , maxwell_vpa use globalVariables , only : nxi_sfincs => nxi use globalVariables , only : nx_sfincs => nx use globalVariables , only : x_sfincs => x use xGrid , only : xGrid_k implicit none integer , intent ( in ) :: ialpha , iz , is real , dimension (:, :), intent ( in ) :: h_stella real , intent ( in ) :: phi_neoclassical real , dimension (:, :), intent ( out ) :: f_neoclassical integer :: iv , imu , ixi real , dimension ( 1 ) :: x_stella integer , dimension ( 2 ) :: sgnvpa integer :: nxi_stella real , dimension (:), allocatable :: xi_stella , hstella real , dimension (:, :), allocatable :: xsfincs_to_xstella , legpoly real , dimension (:), allocatable :: htmp ! each (vpa,mu) pair in stella specifies a speed ! on each speed arc, there are two (vpa,mu) pairs: ! one each corresponding to a given +/- vpa nxi_stella = 2 allocate ( xi_stella ( nxi_stella )) allocate ( hstella ( nxi_stella )) allocate ( legpoly ( nxi_stella , 0 : nxi_sfincs - 1 )) allocate ( htmp ( nxi_sfincs )) allocate ( xsfincs_to_xstella ( 1 , nx_sfincs )) sgnvpa ( 1 ) = 1 ; sgnvpa ( 2 ) = - 1 ! h_stella is on the sfincs energy grid ! but is spectral in pitch-angle do imu = 1 , nmu ! loop over positive vpa values ! negative vpa values will be treated inside loop using symmetry do iv = nvgrid + 1 , nvpa ! x_stella is the speed ! corresponding to this (vpa,mu) grid point x_stella = sqrt ( vpa ( iv ) ** 2 + vperp2 ( ialpha , iz , imu )) ! xi_stella contains the two pitch angles (+/-)vpa/v ! corresponding to this (vpa,mu) grid point xi_stella = sgnvpa * vpa ( iv ) / x_stella ( 1 ) ! set up matrix that interpolates from sfincs speed grid ! to the speed corresponding to this (vpa,mu) grid point call polynomialInterpolationMatrix ( nx_sfincs , 1 , & x_sfincs , x_stella , exp ( - x_sfincs * x_sfincs ) * ( x_sfincs ** xGrid_k ), & exp ( - x_stella * x_stella ) * ( x_stella ** xGrid_k ), xsfincs_to_xstella ) ! do the interpolation do ixi = 1 , nxi_sfincs htmp ( ixi ) = sum ( h_stella ( ixi , :) * xsfincs_to_xstella ( 1 , :)) end do ! next need to Legendre transform in pitch-angle ! first evaluate Legendre polynomials at requested pitch angles call legendre ( xi_stella , legpoly ) ! then do the transforms call legendre_transform ( legpoly , htmp , hstella ) f_neoclassical ( nvpa - iv + 1 , imu ) = hstella ( 2 ) f_neoclassical ( iv , imu ) = hstella ( 1 ) end do ! h_sfincs is H_nc / (nref/vt_ref&#94;3), with H_nc the non-Boltzmann part of F_nc ! NB: n_ref, etc. is fixed in stella to be the reference density ! at the central sfincs simulation; i.e., it does not vary with radius ! to be consistent with stella distribution functions, ! want H_nc / (n_s / vt_s&#94;3 * pi&#94;(3/2)) / exp(-v&#94;2/vts&#94;2) f_neoclassical (:, imu ) = f_neoclassical (:, imu ) & * pi ** 1.5 * spec ( is )% stm ** 3 / spec ( is )% dens ! phi_sfincs is e phi / Tref as long as alpha=1 (default) ! need to multiply by Z_s * Tref/T_s f_neoclassical (:, imu ) = f_neoclassical (:, imu ) & - phi_neoclassical * spec ( is )% zt * maxwell_vpa * maxwell_mu ( ialpha , iz , imu ) end do deallocate ( xi_stella , hstella , legpoly ) deallocate ( xsfincs_to_xstella ) deallocate ( htmp ) end subroutine sfincs_vspace_to_stella_vspace subroutine get_dfield_dalpha ( field , alpha_like_sfincs , dfield_dalpha ) use zgrid , only : nz2pi implicit none real , dimension (:, :), intent ( in ) :: field real , dimension (:), intent ( in ) :: alpha_like_sfincs real , dimension (:, :), intent ( out ) :: dfield_dalpha integer :: iz do iz = 1 , nz2pi call get_periodic_derivative ( field (:, iz ), alpha_like_sfincs , dfield_dalpha (:, iz )) end do end subroutine get_dfield_dalpha ! 4th order accurate, centered differences, assumes ! first and last elements of f are equal (periodic) subroutine get_periodic_derivative ( f , x , dfdx ) implicit none real , dimension (:), intent ( in ) :: f , x real , dimension (:), intent ( out ) :: dfdx integer :: i , n real , dimension (:), allocatable :: fp n = size ( x ) allocate ( fp ( - 1 : n + 2 )) ! extend f using periodicity, as these additional points ! required near boundaries for finite differences fp ( 1 : n ) = f fp ( - 1 : 0 ) = f ( n - 1 : n ) fp ( n + 1 : n + 2 ) = f ( 1 : 2 ) do i = 1 , n dfdx ( i ) = ( 0.25 * ( fp ( i - 2 ) - fp ( i + 2 )) + 2.0 * ( fp ( i + 1 ) - fp ( i - 1 ))) / 3.0 end do deallocate ( fp ) end subroutine get_periodic_derivative !   subroutine bilinear_interpolation (alpha_in, zed_in, phi_in, alpha_out, zed_out, phi_out) !     use zgrid, only: nz2pi !     implicit none !     real, dimension (:,:), intent (in) :: alpha_sfincs, phi_sfincs !     real, dimension (:), intent (in) :: zed_sfincs !     real, dimension (:), intent (in) :: alpha_stella, zed_stella !     real, dimension (:,:), intent (out) :: phi_stella !     integer :: ialpha, iz !     do ialpha = 1, nalpha !        do iz = 1, nz2pi !           call find_sfincs_cell (alpha_stella(ialpha), zed_stella(iz), alpha_sfincs, zed_sfincs, & !                alpha_grids, zed_grids) !        end do !     end do !   contains !     subroutine find_sfincs_cell (alpha_target, zed_target, alpha, zed, ialpha_out, ized_out) !       use zgrid, only: nz2pi !       implicit none !       real, intent (in) :: alpha_target, zed_target !       real, dimension (:,:), intent (in) :: alpha !       real, dimension (:), intent (in) :: zed !       integer, dimension (2), intent (out) :: ialpha_out, ized_out !       integer :: iz, ia !       do iz = 1, nz2pi !          do ia = 1, size(alpha,1) !             if ( !          end do !       end do !     end subroutine find_sfincs_cell !   end subroutine bilinear_interpolation ! returns the Legendre polynomials (legp) ! on requested grid (x) subroutine legendre ( x , legp ) implicit none real , dimension (:), intent ( in ) :: x real , dimension (:, 0 :), intent ( out ) :: legp integer :: n , idx n = size ( legp , 2 ) - 1 legp (:, 0 ) = 1.0 legp (:, 1 ) = x do idx = 2 , n legp (:, idx ) = (( 2. * idx - 1. ) * x * legp (:, idx - 1 ) + ( 1. - idx ) * legp (:, idx - 2 )) / idx end do end subroutine legendre subroutine legendre_transform ( legp , coefs , func ) implicit none real , dimension (:, 0 :), intent ( in ) :: legp real , dimension (:), intent ( in ) :: coefs real , dimension (:), intent ( out ) :: func integer :: i func = 0. do i = 1 , size ( coefs ) func = func + legp (:, i - 1 ) * coefs ( i ) end do end subroutine legendre_transform subroutine broadcast_sfincs_output ( fneo , phineo ) use mp , only : broadcast use zgrid , only : nzgrid implicit none real , dimension ( - nzgrid :, :, :, :, :), intent ( in out ) :: fneo real , dimension ( - nzgrid :, :), intent ( in out ) :: phineo call broadcast ( fneo ) call broadcast ( phineo ) end subroutine broadcast_sfincs_output subroutine write_sfincs ( irad , nrad_max ) use species , only : nspec use globalVariables , only : Phi1Hat use export_f , only : export_f_zeta , export_f_theta use export_f , only : delta_f implicit none integer , intent ( in ) :: irad , nrad_max integer :: unit = 999 integer :: izeta , itheta , is , i , j character ( 1 ) :: irad_str write ( irad_str , '(i0)' ) irad + min ( nrad_max , 1 ) open ( unit = unit , file = 'sfincs.output.rad' // irad_str , status = 'replace' , action = 'write' ) do izeta = 1 , nzeta do itheta = 1 , ntheta write ( unit , '(a8,3e13.5,i3)' ) 'Phi1Hat' , export_f_theta ( itheta ), export_f_zeta ( izeta ), Phi1Hat ( itheta , izeta ), irad end do write ( unit , * ) end do write ( unit , * ) do is = 1 , nspec do i = 1 , size ( delta_f , 5 ) do j = 1 , size ( delta_f , 4 ) do izeta = 1 , nzeta do itheta = 1 , ntheta write ( unit , '(a8,3e13.5,4i5)' ) 'delta_f' , export_f_theta ( itheta ), export_f_zeta ( izeta ), & delta_f ( is , itheta , izeta , j , i ), i , j , is , irad end do write ( unit , * ) end do end do end do end do write ( unit , * ) close ( unit ) end subroutine write_sfincs subroutine read_sfincs_output ( irad , nrad_max ) use species , only : nspec use globalVariables , only : Phi1Hat use export_f , only : export_f_zeta , export_f_theta use export_f , only : delta_f implicit none integer , intent ( in ) :: irad , nrad_max integer :: unit = 999 integer :: izeta , itheta , is , i , j character ( 8 ) :: dum character ( 1 ) :: irad_str write ( irad_str , '(i0)' ) irad + nrad_max open ( unit = unit , file = 'sfincs.output.rad' // irad_str , status = 'old' , action = 'read' ) do izeta = 1 , nzeta do itheta = 1 , ntheta read ( unit , * ) dum , export_f_theta ( itheta ), export_f_zeta ( izeta ), Phi1Hat ( itheta , izeta ), dum end do read ( unit , * ) end do read ( unit , * ) do is = 1 , nspec do i = 1 , size ( delta_f , 5 ) do j = 1 , size ( delta_f , 4 ) do izeta = 1 , nzeta do itheta = 1 , ntheta read ( unit , * ) dum , export_f_theta ( itheta ), export_f_zeta ( izeta ), & delta_f ( is , itheta , izeta , j , i ), dum , dum , dum , dum end do read ( unit , * ) end do end do end do end do read ( unit , * ) close ( unit ) end subroutine read_sfincs_output # endif end module sfincs_interface","tags":"","loc":"sourcefile/sfincs_interface.fpp.html"},{"title":"ezcdf_opncls.f90 – stella","text":"Source Code MODULE ezcdf_opncls !DEC$ IF DEFINED (NETCDF) INTERFACE cdfOpn MODULE PROCEDURE ezcdf_open END INTERFACE INTERFACE cdf_open MODULE PROCEDURE ezcdf_open END INTERFACE INTERFACE cdfCls MODULE PROCEDURE ezcdf_close END INTERFACE INTERFACE cdf_close MODULE PROCEDURE ezcdf_close END INTERFACE CONTAINS subroutine ezcdf_open ( ncid , filename , opt , ier ) ! Create/open cdf file ! 03/09/99 C.Ludescher ! !  opt values: !    \"R\" -- readonly, existing file !    \"W\" -- write new file !    \"M\" -- \"Modify\" -- read/write data in existing file !                       (but structure of file does not change) !    \"A\" -- \"Append\" -- add new structure (define new data items) !                       in existing file.  Existing items can also !                       be read/written, but only after *new* items !                       are first defined and then written. ! !  for both \"W\" and \"A\" modes, the file is opened in \"define data mode\". ! include \"netcdf.inc\" INTEGER , intent ( out ) :: ncid character * ( * ), intent ( in ) :: filename character * 1 , intent ( in ) :: opt integer , optional , intent ( out ) :: ier integer :: status if ( opt == 'w' . or . opt == 'W' ) then ! New file... start in \"define mode\". status = nf_create ( filename , IOR ( NF_CLOBBER , NF_64BIT_OFFSET ), ncid ) call handle_err ( status , filename , 'cdfcrt' , 'nf_create' ) else if ( opt == 'm' . or . opt == 'M' ) then ! Open existing file for read/write modifications... status = nf_open ( filename , nf_write , ncid ) call handle_err ( status , filename , 'cdfopn' , 'nf_open' ) else if ( opt == 'a' . or . opt == 'A' ) then ! Open existing file for read/write modifications... status = nf_open ( filename , nf_write , ncid ) call handle_err ( status , filename , 'cdfopn' , 'nf_open' ) if ( status == NF_NOERR ) then status = nf_redef ( ncid ) ! start in \"define mode\". call handle_err ( status , filename , 'cdfopn' , 'nf_redef' ) end if else ! Open for readonly status = nf_open ( filename , nf_nowrite , ncid ) call handle_err ( status , filename , 'cdfopn' , 'nf_open' ) end if if ( PRESENT ( ier )) then if ( status /= NF_NOERR ) then ier = 1 else ier = 0 end if end if return end subroutine ezcdf_open subroutine ezcdf_close ( ncid , ier ) include \"netcdf.inc\" INTEGER , INTENT ( in ) :: ncid integer , optional , intent ( out ) :: ier INTEGER status status = nf_close ( ncid ) call handle_err ( status , ' ' , 'cdfcls' , 'nf_close' ) if ( PRESENT ( ier )) ier = status end subroutine ezcdf_close !DEC$ ENDIF END MODULE ezcdf_opncls","tags":"","loc":"sourcefile/ezcdf_opncls.f90.html"},{"title":"gyro_averages.f90 – stella","text":"Source Code module gyro_averages use common_types , only : coupled_alpha_type public :: aj0x , aj0v , aj1x , aj1v public :: init_bessel , finish_bessel public :: gyro_average public :: gyro_average_j1 public :: j0_B_maxwell_ffs , j0_ffs public :: band_lu_solve_ffs , band_lu_factorisation_ffs private interface gyro_average module procedure gyro_average_local module procedure gyro_average_kxky_local module procedure gyro_average_kxkyz_local module procedure gyro_average_kxkyzv_local module procedure gyro_average_v_local module procedure gyro_average_vmu_local module procedure gyro_average_vmus_nonlocal module procedure gyro_average_ffs_kxky_local module procedure gyro_average_ffs_kxkyz_local module procedure gyro_average_ffs end interface gyro_average interface gyro_average_j1 module procedure gyro_average_j1_vmus_nonlocal module procedure gyro_average_j1_local module procedure gyro_average_j1_kxky_local module procedure gyro_average_j1_kxkyz_local module procedure gyro_average_j1_v_local module procedure gyro_average_j1_vmu_local module procedure gyro_average_j1_kxkyzv_local end interface real , dimension (:, :, :, :), allocatable :: aj0x , aj1x ! (naky, nakx, nalpha, -nzgrid:nzgrid, -vmu-layout-) real , dimension (:, :), allocatable :: aj0v , aj1v ! (nmu, -kxkyz-layout-) type ( coupled_alpha_type ), dimension (:, :, :, :), allocatable :: j0_ffs , j0_B_maxwell_ffs logical :: bessinit = . false . logical :: debug = . false . contains subroutine init_bessel use dist_fn_arrays , only : kperp2 use physics_flags , only : full_flux_surface use species , only : spec use stella_geometry , only : bmag use zgrid , only : nzgrid use vpamu_grids , only : vperp2 , nmu use kt_grids , only : naky , nakx use stella_layouts , only : kxkyz_lo , vmu_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , is_idx , imu_idx use spfunc , only : j0 , j1 implicit none integer :: iz , iky , ikx , imu , is , ia integer :: ikxkyz , ivmu real :: arg if ( bessinit ) return bessinit = . true . if ( debug ) write ( * , * ) 'gyro_averages::init_bessel::allocate_aj0v_aj1v' if (. not . allocated ( aj0v )) then allocate ( aj0v ( nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) aj0v = 0. end if if (. not . allocated ( aj1v )) then allocate ( aj1v ( nmu , kxkyz_lo % llim_proc : kxkyz_lo % ulim_alloc )) aj1v = 0. end if if ( debug ) write ( * , * ) 'gyro_averages::init_bessel::calculate_aj0v_aj1v' ia = 1 do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) do imu = 1 , nmu arg = spec ( is )% bess_fac * spec ( is )% smz_psi0 * sqrt ( vperp2 ( ia , iz , imu ) * kperp2 ( iky , ikx , ia , iz )) / bmag ( ia , iz ) aj0v ( imu , ikxkyz ) = j0 ( arg ) ! note that j1 returns and aj1 stores J_1(x)/x (NOT J_1(x)), aj1v ( imu , ikxkyz ) = j1 ( arg ) end do end do if ( debug ) write ( * , * ) 'gyro_averages::init_bessel::full_flux_surface' if ( full_flux_surface ) then call init_bessel_ffs else if (. not . allocated ( aj0x )) then allocate ( aj0x ( naky , nakx , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) aj0x = 0. end if if (. not . allocated ( aj1x )) then allocate ( aj1x ( naky , nakx , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) aj1x = 0. end if ia = 1 do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) do iz = - nzgrid , nzgrid do ikx = 1 , nakx do iky = 1 , naky arg = spec ( is )% bess_fac * spec ( is )% smz_psi0 * sqrt ( vperp2 ( ia , iz , imu ) * kperp2 ( iky , ikx , ia , iz )) / bmag ( ia , iz ) aj0x ( iky , ikx , iz , ivmu ) = j0 ( arg ) ! note that j1 returns and aj1 stores J_1(x)/x (NOT J_1(x)), aj1x ( iky , ikx , iz , ivmu ) = j1 ( arg ) end do end do end do end do end if if ( debug ) write ( * , * ) 'gyro_averages::init_bessel::test_gyro_average' !    call test_gyro_average contains !     ! set up field that varies as x&#94;2 = rho&#94;2 * cos(angle)&#94;2, !     ! with rho the distance from the origin, and 'angle' is the angle made with the horizontal !     ! if considering a particle at x=0, then rho is thee gyro-radius and angle is the gyro-angle !     ! the gyro-average should theen be 1/(2pi) * int_0&#94;2pi dangle rho&#94;2 * cos(angle)&#94;2 = rho&#94;2/2 !     subroutine test_gyro_average !       use constants, only: pi !       use kt_grids, only: ny, nx, x, x0, y, y0 !       use kt_grids, only: nakx, ikx_max, naky, naky_all !       use kt_grids, only: swap_kxky, swap_kxky_back !       use stella_transforms, only: transform_x2kx, transform_y2ky !       use stella_transforms, only: transform_kx2x, transform_ky2y !       use stella_layouts, only: vmu_lo, iv_idx, imu_idx, is_idx !       use vpamu_grids, only: nmu !       use species, only: nspec, spec !       use stella_geometry, only: alpha, bmag, x_displacement_fac !       use spfunc, only: bessi0 !       implicit none !       real, dimension (:,:), allocatable :: fld_yx !       complex, dimension (:,:), allocatable :: fld_ykx !       complex, dimension (:,:), allocatable :: fld_kykx_swapped !       complex, dimension (:,:), allocatable :: fld_kykx, gyro_fld !       real, dimension (:,:,:,:), allocatable :: gyro_fld_yx !       real :: gyroradius !       integer :: iy, ix, ivmu, iv, imu, is !       integer, parameter :: iz = 0 !       allocate (fld_yx(ny,nx)) !       allocate (fld_ykx(ny,ikx_max)) !       allocate (fld_kykx_swapped(naky_all,ikx_max)) !       allocate (fld_kykx(naky,nakx)) !       allocate (gyro_fld(naky,nakx)) !       allocate (gyro_fld_yx(ny,nx,nmu,nspec)) !       if (debug) write (*,*) 'gyro_averages::init_bessel::test_gyro_averages::fld_yx' !       ! set up field that varies as x&#94;2 = rho&#94;2 * cos(angle)&#94;2 and is constant in y ! !      fld_yx = spread(0.1*(x-pi*x0),1,ny)**2 !       fld_yx = spread(cos(50.0*(x/x0-pi)),1,ny) ! !      fld_yx = spread(exp(-0.1*(x-pi*x0)**2),1,ny) !       if (debug) write (*,*) 'gyro_averages::init_bessel::test_gyro_averages::transform_x2kx' !       ! transform from (y,x) to (y,kx), with kx going from 0 to kxmax !       call transform_x2kx (fld_yx, fld_ykx) !       if (debug) write (*,*) 'gyro_averages::init_bessel::test_gyro_averages::transform_y2ky' !       ! transform from (y,kx) to (ky,kx), with ky going from (0,...,kymax,-kymax,...,-dky) !       ! and kx going from 0 to kxmax !       call transform_y2ky (fld_ykx, fld_kykx_swapped) !       if (debug) write (*,*) 'gyro_averages::init_bessel::test_gyro_averages::swap_kxky_back' !       ! use reality condition to re-arrange array so that ky goes from 0 to kymax !       ! and kx goes from (0,...,kxmax,-kxmax,...,-dkx) !       call swap_kxky_back (fld_kykx_swapped, fld_kykx) !       ! gyro-average the field at z=0 for different values of mu !       do ivmu = vmu_lo%llim_proc, vmu_lo%ulim_proc !          ! get the vpa index !          iv = iv_idx(vmu_lo,ivmu) !          ! as J0 independent of vpa, pick only one vpa to test !          if (iv /= 1) cycle !          ! get the species index !          is = is_idx(vmu_lo,ivmu) !          ! get the mu index !          imu = imu_idx(vmu_lo,ivmu) ! !         if (debug) write (*,*) 'gyro_averages::init_bessel::test_gyro_averages::gyro_average' !          if (full_flux_surface) then !             call gyro_average (fld_kykx, gyro_fld, j0_ffs(:,:,iz,ivmu)) !          else !             call gyro_average (fld_kykx, iz, ivmu, gyro_fld) !          end if !          ! use reality to re-arrange array entries so that ky goes from (0,...,kymax,-kymax,...,-dky) !          ! and kx goes from 0 to kxmax !          call swap_kxky (gyro_fld, fld_kykx_swapped) !          ! transform from (ky,kx) to (y,kx) !          call transform_ky2y (fld_kykx_swapped, fld_ykx) !          ! transform from (y,kx) to (y,x) !          call transform_kx2x (fld_ykx, gyro_fld_yx(:,:,imu,is)) !       end do !       if (debug) write (*,*) 'gyro_averages::init_bessel::test_gyro_averages::write_to_screen' !       ! NB: this is only set up to work on a single processor at the moment !       ! NB: to extend, must move information about gyro_fld onto proc0 !       do is = 1, nspec !          do imu = 1, nmu !             do ix = 1, nx !                do iy = 1, ny !                   ! gyro-radius/reference gyro-radius is v_perp/Omega/rho_ref = (v_perp/vths)*(rho_s/rho_ref) !                   ! = vperp * sqrt(T_s/T_ref*m_s/m_ref)(B_ref/Z*B) = vperp / (spec%zstm*bmag) !                   gyroradius = sqrt(vperp2(iy,iz,imu))/(spec(is)%zstm*bmag(iy,iz)) ! !                  gyroradius = sqrt(vperp2(1,iz,imu))/(spec(is)%zstm*bmag(1,iz)) !                   write (42,*) 'y: ', y(iy), 'x: ', x(ix)-x0*pi, 'gyro_fld: ', gyro_fld_yx(iy,ix,imu,is), 'gyroradius: ', gyroradius, 'spec: ', is, & !                        'alpha: ', alpha(iy), 'x_displacement_fac: ', x_displacement_fac(iy,iz) !                end do !                write (42,*) !             end do !             write (42,*) !          end do !          write (42,*) !       end do !       do iy = 1, 1000 !          gyroradius = (iy-1)*15.0/999. !          !         write (43,*) 'gyroradius: ', gyroradius, 'bes: ', bessi0(0.1*0.5*(gyroradius/x_displacement_fac(1,iz))**2)*exp(-0.1*0.5*(gyroradius/x_displacement_fac(1,iz))**2) !          !         write (43,*) 'gyroradius: ', gyroradius, 'analytical: ', 0.5*(0.1*gyroradius/x_displacement_fac(1,iz))**2 !          write (43,*) 'gyroradius: ', gyroradius, 'analytical: ', j0(50.*gyroradius/(x0*x_displacement_fac(1,iz))) !       end do !       ! TMP FOR TESTING ! !      stop !       deallocate (fld_yx, fld_ykx) !       deallocate (fld_kykx_swapped, fld_kykx) !       deallocate (gyro_fld, gyro_fld_yx) !     end subroutine test_gyro_average end subroutine init_bessel subroutine init_bessel_ffs use mp , only : sum_allreduce , proc0 use spfunc , only : j0 use stella_layouts , only : vmu_lo use stella_layouts , only : iv_idx , imu_idx , is_idx use stella_transforms , only : transform_alpha2kalpha use species , only : nspec , spec use stella_geometry , only : bmag use zgrid , only : nzgrid , nztot use vpamu_grids , only : nmu , nvpa use vpamu_grids , only : vperp2 , maxwell_vpa , maxwell_mu use kt_grids , only : nalpha , naky , naky_all , ikx_max use kt_grids , only : swap_kxky_ordered use dist_fn_arrays , only : kperp2 implicit none !    integer :: j0_ffs_unit, j0_B_maxwell_ffs_unit integer :: iky , ikx , ia , iz integer :: ivmu , iv , imu , is integer :: ia_max_j0_count , ia_max_j0_B_maxwell_count real :: arg , rtmp real :: ia_max_j0_reduction_factor , ia_max_j0_B_maxwell_reduction_factor real , dimension (:), allocatable :: wgts real , dimension (:), allocatable :: aj0_alpha , j0_B_maxwell real , dimension (:, :, :), allocatable :: kperp2_swap complex , dimension (:), allocatable :: aj0_kalpha , j0_B_maxwell_kalpha !       call open_output_file (j0_ffs_unit, '.j0_ffs') !       call open_output_file (j0_B_maxwell_ffs_unit, '.j0_over_B_ffs') ! wgts are species-dependent factors appearing in Gamma0 factor allocate ( wgts ( nspec )) wgts = spec % dens * spec % z ** 2 / spec % temp if ( debug ) write ( * , * ) 'gyro_averages::init_bessel::full_flux_surface::allocate_arrays' !> aj0_alpha will contain J_0 as a function of k_alpha and alpha allocate ( aj0_alpha ( nalpha )) allocate ( aj0_kalpha ( naky )) !> j0_B_maxwell will contain J_0*B*exp(-v&#94;2) as a function of k_alpha and alpha allocate ( j0_B_maxwell ( nalpha )) allocate ( j0_B_maxwell_kalpha ( naky )) allocate ( kperp2_swap ( naky_all , ikx_max , nalpha )) if (. not . allocated ( j0_ffs )) then allocate ( j0_ffs ( naky_all , ikx_max , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) end if if (. not . allocated ( j0_B_maxwell_ffs )) then allocate ( j0_B_maxwell_ffs ( naky_all , ikx_max , - nzgrid : nzgrid , vmu_lo % llim_proc : vmu_lo % ulim_alloc )) end if ia_max_j0_count = 0 ; ia_max_j0_B_maxwell_count = 0 do iz = - nzgrid , nzgrid if ( proc0 ) write ( * , * ) 'calculating Fourier coefficients needed for gyro-averaging with alpha variation; zed index: ' , iz !> for each value of alpha, take kperp&#94;2 calculated on domain kx = [-kx_max, kx_max] and ky = [0, ky_max] !> and use symmetry to obtain kperp&#94;2 on domain kx = [0, kx_max] and ky = [-ky_max, ky_max] !> this makes later convolutions involving sums over all ky more straightforward if ( debug ) write ( * , * ) 'gyro_averages::init_bessel::full_flux_surface::swap_kxky' do ia = 1 , nalpha call swap_kxky_ordered ( kperp2 (:, :, ia , iz ), kperp2_swap (:, :, ia )) end do if ( debug ) write ( * , * ) 'gyro_averages::init_bessel::full_flux_surface::j0_loop' do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc is = is_idx ( vmu_lo , ivmu ) iv = iv_idx ( vmu_lo , ivmu ) imu = imu_idx ( vmu_lo , ivmu ) do ikx = 1 , ikx_max do iky = 1 , naky_all do ia = 1 , nalpha !> calculate the argument of the Bessel function, which depends on both alpha and k_alpha arg = spec ( is )% bess_fac * spec ( is )% smz_psi0 * sqrt ( vperp2 ( ia , iz , imu ) * kperp2_swap ( iky , ikx , ia )) / bmag ( ia , iz ) ! compute the value of the Bessel function J0 corresponding to argument arg aj0_alpha ( ia ) = j0 ( arg ) !> compute J_0*B*exp(-v&#94;2), needed when integrating g over v-space in Maxwell's equations, !> due to B in v-space Jacobian and Maxwellian factor hidden in normalisation of g j0_B_maxwell ( ia ) = aj0_alpha ( ia ) * bmag ( ia , iz ) * maxwell_vpa ( iv , is ) * maxwell_mu ( ia , iz , imu , is ) end do !> fourier transform aj0_alpha and j0_B_maxwell. !> note that fourier coefficients aj0_kalpha and j0_B_maxwell_kalpha have !> been filtered to avoid aliasing call transform_alpha2kalpha ( aj0_alpha , aj0_kalpha ) call transform_alpha2kalpha ( j0_B_maxwell , j0_B_maxwell_kalpha ) !> given the Fourier coefficients aj0_kalpha, calculate the minimum number of coefficients needed, !> called j0_ffs%max_idx, to ensure that the relative error in the total spectral energy is below a specified tolerance !if (debug) write (*,*) 'gyro_averages::init_bessel::full_flux_surface::find_max_required_kalpha_index' !                ! TMP FOR TESTING !                j0_ffs(iky,ikx,iz,ivmu)%max_idx = naky call find_max_required_kalpha_index ( aj0_kalpha , j0_ffs ( iky , ikx , iz , ivmu )% max_idx , imu , iz , is ) !> given the Fourier coefficients j0_B_maxwell_kalpha, calculate the minimum number of coefficients needed, !> called j0_B_maxwell_ffs%max_idx, to ensure that the relative error in the total spectral energy is below a specified tolerance call find_max_required_kalpha_index ( j0_B_maxwell_kalpha , j0_B_maxwell_ffs ( iky , ikx , iz , ivmu )% max_idx , imu , iz , is ) !> keep track of the total number of coefficients that must be retained across different phase space points ia_max_j0_count = ia_max_j0_count + j0_ffs ( iky , ikx , iz , ivmu )% max_idx !> keep track of the total number of coefficients that must be retained across different phase space points ia_max_j0_B_maxwell_count = ia_max_j0_B_maxwell_count + j0_B_maxwell_ffs ( iky , ikx , iz , ivmu )% max_idx !> allocate array to hold the reduced number of Fourier coefficients if (. not . associated ( j0_ffs ( iky , ikx , iz , ivmu )% fourier )) & allocate ( j0_ffs ( iky , ikx , iz , ivmu )% fourier ( j0_ffs ( iky , ikx , iz , ivmu )% max_idx )) !> fill the array with the requisite coefficients j0_ffs ( iky , ikx , iz , ivmu )% fourier = aj0_kalpha (: j0_ffs ( iky , ikx , iz , ivmu )% max_idx ) !                   call test_ffs_bessel_coefs (j0_ffs(iky,ikx,iz,ivmu)%fourier, aj0_alpha, iky, ikx, iz, j0_ffs_unit, ivmu) if (. not . associated ( j0_B_maxwell_ffs ( iky , ikx , iz , ivmu )% fourier )) & allocate ( j0_B_maxwell_ffs ( iky , ikx , iz , ivmu )% fourier ( j0_B_maxwell_ffs ( iky , ikx , iz , ivmu )% max_idx )) !> fill the array with the requisite coefficients j0_B_maxwell_ffs ( iky , ikx , iz , ivmu )% fourier = j0_B_maxwell_kalpha (: j0_B_maxwell_ffs ( iky , ikx , iz , ivmu )% max_idx ) !                   call test_ffs_bessel_coefs (j0_B_maxwell_ffs(iky,ikx,iz,ivmu)%fourier, j0_B_maxwell, iky, ikx, iz, j0_B_maxwell_ffs_unit, ivmu) end do end do end do end do deallocate ( aj0_alpha , j0_B_maxwell , j0_B_maxwell_kalpha ) !> calculate the reduction factor of Fourier modes !> used to represent J0 !> avoid overflow by converting integers to reals before multiplying rtmp = real ( naky ) * real ( naky_all ) * real ( ikx_max ) * real ( nztot ) * real ( nmu ) * real ( nvpa ) * real ( nspec ) call sum_allreduce ( ia_max_j0_count ) ia_max_j0_reduction_factor = real ( ia_max_j0_count ) / rtmp call sum_allreduce ( ia_max_j0_B_maxwell_count ) ia_max_j0_B_maxwell_reduction_factor = real ( ia_max_j0_B_maxwell_count ) / rtmp if ( proc0 ) then write ( * , * ) 'average number of k-alphas needed to represent J0(kperp(alpha))=' , ia_max_j0_reduction_factor * naky , 'out of ' , naky write ( * , * ) 'average number of k-alphas needed to represent J0(kperp(alpha))*B(alpha)*exp(-v&#94;2)=' , & ia_max_j0_B_maxwell_reduction_factor * naky , 'out of ' , naky write ( * , * ) end if deallocate ( wgts ) deallocate ( aj0_kalpha ) deallocate ( kperp2_swap ) !       call close_output_file (j0_ffs_unit) !       call close_output_file (j0_B_maxwell_ffs_unit) contains !> inverse fourier transform coefs%fourier for several phase space points and compare with !> unfiltered version in alpha-space ! subroutine test_ffs_bessel_coefs (coefs, f_alpha, iky, ikx, iz, unit, ivmu) !   use stella_layouts, only: vmu_lo, iv_idx, is_idx, imu_idx !   implicit none !   complex, dimension (:), intent (in) :: coefs !   real, dimension (:), intent (in) :: f_alpha !   integer, intent (in) :: iky, ikx, iz !   integer, intent (in) :: unit !   integer, intent (in), optional :: ivmu !   integer :: iv, imu, is !   if (present(ivmu)) then !      !> coefficients should all be independent of vpa, so only do comparison for one vpa point !      iv = iv_idx(vmu_lo,ivmu) !      if (iv == 1) then !         !> only sample subset of mu locations !         imu = imu_idx(vmu_lo,ivmu) !         if (mod(imu-1,nmu/2-1)==0) then !            is = is_idx(vmu_lo,ivmu) !            call test_ffs_bessel_coefs_subset (coefs, f_alpha, iky, ikx, iz, unit, iv, imu, is) !         end if !      end if !   else !      call test_ffs_bessel_coefs_subset (coefs, f_alpha, iky, ikx, iz, unit) !   end if ! end subroutine test_ffs_bessel_coefs ! subroutine test_ffs_bessel_coefs_subset (coefs, f_alpha, iky, ikx, iz, unit, iv, imu, is) !   use constants, only: pi !   use zgrid, only: nzgrid, zed !   use kt_grids, only: naky, nalpha, aky_all_ordered !   use vpamu_grids, only: mu !   use stella_transforms, only: transform_kalpha2alpha !   use stella_geometry, only: alpha !   implicit none !   complex, dimension (:), intent (in) :: coefs !   real, dimension (:), intent (in) :: f_alpha !   integer, intent (in) :: iky, ikx, iz !   integer, intent (in) :: unit !   integer, intent (in), optional :: iv, imu, is !   complex, dimension (:), allocatable :: coefs_padded !   real, dimension (:), allocatable :: f_alpha_approx !   integer :: ia !   integer :: max_idx !   real :: relative_error !   real, parameter :: minval = 1.0e-3 !   ! only sample a subset of z locations !   if (mod(iz,nzgrid/2)==0) then !      ! consider only kx = 0 !      if (ikx == 1) then !         allocate (coefs_padded(naky)) !         allocate (f_alpha_approx(nalpha)) !         ! initialize the padded coefficient array to zero !         coefs_padded = 0.0 !         ! fill in non-zero entries with truncated Fourier coefficients !         max_idx = size(coefs) !         coefs_padded(:max_idx) = coefs !         ! inverse Fourier transform to get alpha-dependent function !         call transform_kalpha2alpha (coefs_padded, f_alpha_approx) !         if (present(iv)) then !            do ia = 1, nalpha !               relative_error = 2.0*abs(f_alpha(ia)-f_alpha_approx(ia))/(abs(f_alpha(ia)) + abs(f_alpha_approx(ia))) !               write (unit,*) alpha(ia), f_alpha(ia), f_alpha_approx(ia), & !                    relative_error, aky_all_ordered(iky), ikx, iz, zed(iz), iv, imu, mu(imu), is !            end do !            ! user 2*pi periodicity in alpha to fill in final point (for visualization purposes) !            ia = 1 !            relative_error = 2.0*abs(f_alpha(ia)-f_alpha_approx(ia))/(abs(f_alpha(ia)) + abs(f_alpha_approx(ia))) !            write (unit,*) 2.0*pi, f_alpha(1), f_alpha_approx(1), & !                 relative_error, aky_all_ordered(iky), ikx, iz, zed(iz), iv, imu, mu(imu), is !         else !            do ia = 1, nalpha !               relative_error = 2.0*abs(f_alpha(ia)-f_alpha_approx(ia))/(abs(f_alpha(ia)) + abs(f_alpha_approx(ia))) !               write (unit,*) alpha(ia), f_alpha(ia), f_alpha_approx(ia), & !                    relative_error, aky_all_ordered(iky), ikx, iz, zed(iz) !            end do !            ! user 2*pi periodicity in alpha to fill in final point (for visualization purposes) !            ia = 1 !            relative_error = 2.0*abs(f_alpha(ia)-f_alpha_approx(ia))/(abs(f_alpha(ia)) + abs(f_alpha_approx(ia))) !            write (unit,*) 2.0*pi, f_alpha(1), f_alpha_approx(1), & !                 relative_error, aky_all_ordered(iky), ikx, iz, zed(iz) !         end if !         write (unit,*) !         deallocate (coefs_padded, f_alpha_approx) !      end if !   end if ! end subroutine test_ffs_bessel_coefs_subset end subroutine init_bessel_ffs !> subroutine takes a set of Fourier coefficients (ft) !> and returns the minimum number of coeffients that must be retained (idx) !> to ensure that the relative error in the total spectral energy is !> below a specified tolerance (tol_floor) subroutine find_max_required_kalpha_index ( ft , idx , imu , iz , is ) use vpamu_grids , only : maxwell_mu implicit none complex , dimension (:), intent ( in ) :: ft integer , intent ( out ) :: idx integer , intent ( in ), optional :: imu , iz , is real , parameter :: tol_floor = 1.0e-8 integer :: i , n real :: subtotal , total real :: tol real , dimension (:), allocatable :: ftmod2 n = size ( ft ) ! use conservative estimate ! when deciding number of modes to retain if ( present ( imu ) . and . present ( iz ) . and . present ( is )) then !       tol = min(0.1,tol_floor/maxval(maxwell_mu(:,iz,imu,is))) tol = min ( 1.0e-6 , tol_floor / maxval ( maxwell_mu (:, iz , imu , is ))) else tol = tol_floor end if allocate ( ftmod2 ( n )) ! get spectral energy associated with each mode ftmod2 = sqrt ( real ( ft * conjg ( ft ))) ! get total spectral energy total = sqrt ( sum ( ftmod2 )) subtotal = 0. ! find minimum spectral index for which ! desired percentage of spectral energy contained ! in modes with indices at or below it if ( total > 0. ) then i = 1 do while ( subtotal < total * ( 1.0 - tol )) idx = i subtotal = sqrt ( sum ( ftmod2 (: i ))) i = i + 1 end do else idx = 1 end if deallocate ( ftmod2 ) end subroutine find_max_required_kalpha_index subroutine finish_bessel implicit none if ( allocated ( aj0v )) deallocate ( aj0v ) if ( allocated ( aj1v )) deallocate ( aj1v ) if ( allocated ( aj0x )) deallocate ( aj0x ) if ( allocated ( aj1x )) deallocate ( aj1x ) if ( allocated ( j0_ffs )) deallocate ( j0_ffs ) if ( allocated ( j0_B_maxwell_ffs )) deallocate ( j0_B_maxwell_ffs ) bessinit = . false . end subroutine finish_bessel !> gyro_average_local takes a field at a given ky, kx, z and (vpa, mu, s) value !> and returns the gyro-average of that field; ! this should never be called for a full flux surface simulation, so no need ! to check if flux tube or full flux surface subroutine gyro_average_local ( field , iky , ikx , iz , ivmu , gyro_field ) implicit none complex , intent ( in ) :: field integer , intent ( in ) :: iky , ikx , iz , ivmu complex , intent ( out ) :: gyro_field gyro_field = aj0x ( iky , ikx , iz , ivmu ) * field end subroutine gyro_average_local subroutine gyro_average_kxky_local ( field , iz , ivmu , gyro_field ) use physics_flags , only : full_flux_surface implicit none complex , dimension (:, :), intent ( in ) :: field integer , intent ( in ) :: iz , ivmu complex , dimension (:, :), intent ( out ) :: gyro_field if ( full_flux_surface ) then !> if simulating a full flux surface, the alpha dependence present !> in kperp makes gyro-averaging non-local in k-space call gyro_average ( field , gyro_field , j0_ffs (:, :, iz , ivmu )) else !> if simulating a flux tube, a gyro-average is local in k-space gyro_field = aj0x (:, :, iz , ivmu ) * field end if end subroutine gyro_average_kxky_local subroutine gyro_average_kxkyz_local ( field , ivmu , gyro_field ) use physics_flags , only : full_flux_surface use zgrid , only : nzgrid , ntubes implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: field integer , intent ( in ) :: ivmu complex , dimension (:, :, - nzgrid :, :), intent ( out ) :: gyro_field if ( full_flux_surface ) then !> if simulating a full flux surface, the alpha dependence present !> in kperp makes gyro-averaging non-local in k-space call gyro_average ( field , gyro_field , j0_ffs (:, :, :, ivmu )) else !> if simulating a flux tube, a gyro-average is local in k-space gyro_field = spread ( aj0x (:, :, :, ivmu ), 4 , ntubes ) * field end if end subroutine gyro_average_kxkyz_local subroutine gyro_average_kxkyzv_local ( field , gyro_field ) use physics_flags , only : full_flux_surface use zgrid , only : nzgrid use stella_layouts , only : vmu_lo implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: field complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( out ) :: gyro_field integer :: ivmu if ( full_flux_surface ) then !> if simulating a full flux surface, the alpha dependence present !> in kperp makes gyro-averaging non-local in k-space call gyro_average ( field , gyro_field , j0_ffs ) else !> if simulating a flux tube, a gyro-average is local in k-space do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc call gyro_average ( field (:, :, :, :, ivmu ), ivmu , gyro_field (:, :, :, :, ivmu )) end do end if end subroutine gyro_average_kxkyzv_local subroutine gyro_average_ffs_kxky_local ( field , gyro_field , coefs ) use kt_grids , only : naky use kt_grids , only : naky_all , ikx_max use kt_grids , only : swap_kxky_ordered , swap_kxky_back_ordered implicit none complex , dimension (:, :), intent ( in ) :: field complex , dimension (:, :), intent ( out ) :: gyro_field type ( coupled_alpha_type ), dimension (:, :), intent ( in ) :: coefs integer :: iky , ikx , ikyp integer :: idx complex , dimension (:, :), allocatable :: field_kyall , gyro_field_kyall ! need to switch from ky>=0 and all kx ! to kx>=0 and all ky (using reality condition) allocate ( field_kyall ( naky_all , ikx_max )) allocate ( gyro_field_kyall ( naky_all , ikx_max )); gyro_field_kyall = 0. call swap_kxky_ordered ( field , field_kyall ) ! NB: J0(kx,ky) = J0(-kx,-ky) and Gamma0(kx,ky) = Gamma0(-kx,-ky) do ikx = 1 , ikx_max do iky = 1 , naky_all ! account for contributions from less positive ky values (and this ky itself) do ikyp = 1 , min ( naky , iky ) ! idx is the index corresponding to k_alpha - k_alpha' ! runs from iky down to 1 idx = iky - ikyp + 1 ! if the Fourier coefficient corresponding to this value of (k_alpha-k_alpha',k_alpha') ! is sufficiently small, then it will not have been included in the truncated version ! of the coefficients; in this case, it makes no contribution to the gyro-average sum if ( coefs ( idx , ikx )% max_idx >= ikyp ) then gyro_field_kyall ( iky , ikx ) = gyro_field_kyall ( iky , ikx ) & + coefs ( idx , ikx )% fourier ( ikyp ) * field_kyall ( idx , ikx ) end if end do ! if iky = naky_all, then already at max positive ky, so no contributions ! from more positive ky value possible if ( iky == naky_all ) cycle ! account for contributions from more positive ky values (but not this ky itself, ! as already accounted for above do ikyp = 2 , min ( naky , naky_all - iky + 1 ) ! idx is the index corresponding to k_alpha - k_alpha' ! runs from iky + 1 up to iky + naky (or until naky_all, if it is reached first) idx = iky + ikyp - 1 ! if the Fourier coefficient corresponding to this value of (k_alpha-k_alpha',k_alpha') ! is sufficiently small, then it will not have been included in the truncated version ! of the coefficients; in this case, it makes no contribution to the gyro-average sum if ( coefs ( idx , ikx )% max_idx >= ikyp ) then ! the k_alpha' values considered in this loop are negative, but only have ! Fourier coefficients for positive ky values; ! must use the reality condition to convert this to the equivalent coefficients for negative ky gyro_field_kyall ( iky , ikx ) = gyro_field_kyall ( iky , ikx ) & + conjg ( coefs ( idx , ikx )% fourier ( ikyp )) * field_kyall ( idx , ikx ) end if end do end do end do call swap_kxky_back_ordered ( gyro_field_kyall , gyro_field ) deallocate ( field_kyall , gyro_field_kyall ) end subroutine gyro_average_ffs_kxky_local subroutine gyro_average_ffs_kxkyz_local ( field , gyro_field , coefs ) use zgrid , only : nzgrid , ntubes implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: field complex , dimension (:, :, - nzgrid :, :), intent ( out ) :: gyro_field type ( coupled_alpha_type ), dimension (:, :, - nzgrid :), intent ( in ) :: coefs integer :: iz , it do it = 1 , ntubes do iz = - nzgrid , nzgrid call gyro_average ( field (:, :, iz , it ), gyro_field (:, :, iz , it ), coefs (:, :, iz )) end do end do end subroutine gyro_average_ffs_kxkyz_local subroutine gyro_average_ffs ( dist , gyro_dist , coefs ) use common_types , only : coupled_alpha_type use stella_layouts , only : vmu_lo use zgrid , only : nzgrid implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: dist complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( out ) :: gyro_dist type ( coupled_alpha_type ), dimension (:, :, - nzgrid :, vmu_lo % llim_proc :), intent ( in ) :: coefs integer :: ivmu do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc call gyro_average ( dist (:, :, :, :, ivmu ), gyro_dist (:, :, :, :, ivmu ), coefs (:, :, :, ivmu )) end do end subroutine gyro_average_ffs subroutine gyro_average_v_local ( distfn , imu , ikxkyz , gyro_distfn ) implicit none complex , dimension (:), intent ( in ) :: distfn integer , intent ( in ) :: imu , ikxkyz complex , dimension (:), intent ( out ) :: gyro_distfn gyro_distfn = aj0v ( imu , ikxkyz ) * distfn end subroutine gyro_average_v_local subroutine gyro_average_vmu_local ( distfn , ikxkyz , gyro_distfn ) use vpamu_grids , only : nvpa implicit none complex , dimension (:, :), intent ( in ) :: distfn integer , intent ( in ) :: ikxkyz complex , dimension (:, :), intent ( out ) :: gyro_distfn gyro_distfn = spread ( aj0v (:, ikxkyz ), 1 , nvpa ) * distfn end subroutine gyro_average_vmu_local subroutine gyro_average_vmus_nonlocal ( field , iky , ikx , iz , gyro_field ) use stella_layouts , only : vmu_lo implicit none complex , dimension ( vmu_lo % llim_proc :), intent ( in ) :: field integer , intent ( in ) :: iky , ikx , iz complex , dimension ( vmu_lo % llim_proc :), intent ( out ) :: gyro_field gyro_field = aj0x ( iky , ikx , iz , :) * field end subroutine gyro_average_vmus_nonlocal subroutine gyro_average_j1_vmus_nonlocal ( field , iky , ikx , iz , gyro_field ) use stella_layouts , only : vmu_lo implicit none complex , dimension ( vmu_lo % llim_proc :), intent ( in ) :: field integer , intent ( in ) :: iky , ikx , iz complex , dimension ( vmu_lo % llim_proc :), intent ( out ) :: gyro_field gyro_field = aj1x ( iky , ikx , iz , :) * field end subroutine gyro_average_j1_vmus_nonlocal subroutine gyro_average_j1_local ( field , iky , ikx , iz , ivmu , gyro_field ) implicit none complex , intent ( in ) :: field integer , intent ( in ) :: iky , ikx , iz , ivmu complex , intent ( out ) :: gyro_field gyro_field = aj1x ( iky , ikx , iz , ivmu ) * field end subroutine gyro_average_j1_local subroutine gyro_average_j1_kxky_local ( field , iz , ivmu , gyro_field ) implicit none complex , dimension (:, :), intent ( in ) :: field integer , intent ( in ) :: iz , ivmu complex , dimension (:, :), intent ( out ) :: gyro_field gyro_field = aj1x (:, :, iz , ivmu ) * field end subroutine gyro_average_j1_kxky_local subroutine gyro_average_j1_kxkyz_local ( field , ivmu , gyro_field ) use zgrid , only : nzgrid , ntubes implicit none complex , dimension (:, :, - nzgrid :, :), intent ( in ) :: field integer , intent ( in ) :: ivmu complex , dimension (:, :, - nzgrid :, :), intent ( out ) :: gyro_field integer :: iz , it do it = 1 , ntubes do iz = - nzgrid , nzgrid gyro_field (:, :, iz , it ) = aj1x (:, :, iz , ivmu ) * field (:, :, iz , it ) end do end do end subroutine gyro_average_j1_kxkyz_local subroutine gyro_average_j1_vmu_local ( distfn , ikxkyz , gyro_distfn ) use vpamu_grids , only : nvpa implicit none complex , dimension (:, :), intent ( in ) :: distfn integer , intent ( in ) :: ikxkyz complex , dimension (:, :), intent ( out ) :: gyro_distfn gyro_distfn = spread ( aj1v (:, ikxkyz ), 1 , nvpa ) * distfn end subroutine gyro_average_j1_vmu_local subroutine gyro_average_j1_v_local ( distfn , imu , ikxkyz , gyro_distfn ) implicit none complex , dimension (:), intent ( in ) :: distfn integer , intent ( in ) :: imu , ikxkyz complex , dimension (:), intent ( out ) :: gyro_distfn gyro_distfn = aj1v ( imu , ikxkyz ) * distfn end subroutine gyro_average_j1_v_local subroutine gyro_average_j1_kxkyzv_local ( field , gyro_field ) use mp , only : proc0 , mp_abort use zgrid , only : nzgrid use stella_layouts , only : vmu_lo use physics_flags , only : full_flux_surface implicit none complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( in ) :: field complex , dimension (:, :, - nzgrid :, :, vmu_lo % llim_proc :), intent ( out ) :: gyro_field integer :: ivmu if ( full_flux_surface ) then if ( proc0 ) write ( * , * ) 'gyro_average_j1_kxkyzv_local does not support full_flux_surface' call mp_abort ( 'gyro_average_j1_kxkyzv_local does not support full_flux_surface. aborting' ) return !> if simulating a full flux surface, the alpha dependence present !> in kperp makes gyro-averaging non-local in k-space ! call gyro_average(field, gyro_field, j0_ffs) else !> if simulating a flux tube, a gyro-average is local in k-space do ivmu = vmu_lo % llim_proc , vmu_lo % ulim_proc call gyro_average_j1 ( field (:, :, :, :, ivmu ), ivmu , gyro_field (:, :, :, :, ivmu )) end do end if end subroutine subroutine band_lu_solve_ffs ( lu , solvec ) use common_types , only : gam0_ffs_type use zgrid , only : nzgrid use kt_grids , only : ikx_max implicit none type ( gam0_ffs_type ), dimension (:, - nzgrid :), intent ( in ) :: lu complex , dimension (:, :, - nzgrid :), intent ( in out ) :: solvec integer :: ikx , iz do iz = - nzgrid , nzgrid do ikx = 1 , ikx_max call band_lu_solve_ffs_single ( lu ( ikx , iz ), solvec (:, ikx , iz )) end do end do end subroutine band_lu_solve_ffs subroutine band_lu_solve_ffs_single ( lu , solvec ) use common_types , only : gam0_ffs_type use kt_grids , only : naky implicit none type ( gam0_ffs_type ), intent ( in ) :: lu complex , dimension (:), intent ( in out ) :: solvec integer :: n , nsubdiag , nsupdiag , nrhs integer :: info complex , dimension (:, :), allocatable :: solmat ! n is the order of the matrix for which we have the LU factorisation n = size ( lu % pivot_index ) ! nsubdiag and nsupdiag are the number of sub- and super-diagonals within the band of the matrix to be decomposed nsubdiag = naky - 1 ; nsupdiag = naky - 1 ! nrhs is the number of right-hand sides of the matrix equation lu%matrix * solvec = rhs for which to solve nrhs = 1 ! initialise solmat = rhs, as it will be overwritten by zgbtrs below allocate ( solmat ( size ( solvec ), 1 )) solmat (:, 1 ) = solvec call zgbtrs ( 'N' , n , nsubdiag , nsupdiag , nrhs , lu % matrix , size ( lu % matrix , 1 ), lu % pivot_index , solmat , size ( solmat , 1 ), info ) solvec = solmat (:, 1 ) deallocate ( solmat ) end subroutine band_lu_solve_ffs_single subroutine band_lu_factorisation_ffs ( gam0 , lu_gam0 ) use common_types , only : coupled_alpha_type , gam0_ffs_type use zgrid , only : nzgrid use kt_grids , only : ikx_max , naky_all , naky implicit none type ( coupled_alpha_type ), dimension (:, :, - nzgrid :), intent ( in ) :: gam0 type ( gam0_ffs_type ), dimension (:, - nzgrid :), intent ( out ) :: lu_gam0 integer :: iky , ikx , iz complex , dimension (:, :), allocatable :: gam0tmp allocate ( gam0tmp ( naky , naky_all )) do ikx = 1 , ikx_max do iz = - nzgrid , nzgrid ! create array from Fourier coefficients of Gamma_0(ky,y) do iky = 1 , naky_all gam0tmp (:, iky ) = gam0 ( iky , ikx , iz )% fourier end do call band_lu_factorisation_single ( gam0tmp , lu_gam0 ( ikx , iz )) end do end do deallocate ( gam0tmp ) end subroutine band_lu_factorisation_ffs subroutine band_lu_factorisation_single ( gam0 , lu_gam0 ) use common_types , only : gam0_ffs_type use kt_grids , only : naky , naky_all implicit none complex , dimension (:, :), intent ( in ) :: gam0 type ( gam0_ffs_type ), intent ( out ) :: lu_gam0 integer :: nrows , ncols , nsubdiag , nsupdiag , leading_dim integer :: info integer :: i , imod ! nrows and ncols are the number of rows and columns of the matrix to be LU-decomposed (variant of gam0) ! this matrix is naky_all x naky_all nrows = naky_all ; ncols = naky_all ! nsubdiag and nsupdiag are the number of sub- and super-diagonals within the band of the matrix to be decomposed nsubdiag = naky - 1 ; nsupdiag = naky - 1 ! leading_dim is the 'leading dimension' of the lu_gam0 array leading_dim = 2 * nsubdiag + nsupdiag + 1 ! lu_gam0 is a re-arranged version of gam0 on entry, and on exit contains details of LU factorisation ! that can be used by zgbtrs to solve the linear system gam0 * phi = rhs if (. not . associated ( lu_gam0 % matrix )) then allocate ( lu_gam0 % matrix ( leading_dim , ncols )) ! initialise first nsubdiag rows to zero, as they are unused lu_gam0 % matrix (: nsubdiag , :) = 0.0 ! fill next supdiag rows using elements from super-diagonals ! using reality of gam0 to set fourier(ky < 0) = conjg(fourier(ky > 0)) do i = 1 , nsupdiag imod = naky - i + 1 lu_gam0 % matrix ( nsubdiag + i , imod :) = conjg ( gam0 ( imod , imod :)) ! fill unused entries with zero lu_gam0 % matrix ( nsubdiag + i , : imod - 1 ) = 0.0 end do ! fill next row using main diagonal entries lu_gam0 % matrix ( nsubdiag + nsupdiag + 1 , :) = gam0 ( 1 , :) ! fill remaining nsubdiag rows using elements from sub-diagonals do i = 1 , nsubdiag imod = naky + i - 1 lu_gam0 % matrix ( leading_dim - i + 1 , : imod ) = gam0 ( naky - i + 1 , : imod ) ! fill unused entries with zeroes lu_gam0 % matrix ( leading_dim - i + 1 , imod + 1 :) = 0.0 end do end if if (. not . associated ( lu_gam0 % pivot_index )) allocate ( lu_gam0 % pivot_index ( min ( nrows , ncols ))) ! overwrites lu_gam0%matrix with information needed to solve the linear system gam0 * phi = rhs; ! also returns pivot_index, with pivot_index(i) giving the row of the matrix interchanged with the ith row, ! and info, which should be zero if the LU factorisation is successful call zgbtrf ( nrows , ncols , nsubdiag , nsupdiag , lu_gam0 % matrix , leading_dim , lu_gam0 % pivot_index , info ) end subroutine band_lu_factorisation_single ! subroutine test_band_lu_factorisation (gam0, lu_gam0) !   use common_types, only: coupled_alpha_type, gam0_ffs_type !   use zgrid, only: nzgrid !   use kt_grids, only: naky_all, naky !   implicit none !   type (coupled_alpha_type), dimension (:,:,-nzgrid:), intent (in) :: gam0 !   type (gam0_ffs_type), dimension (:,-nzgrid:), intent (out) :: lu_gam0 !   integer :: iky, ikx, ikyp, iz !   complex, dimension (naky_all) :: solvec !   ikx = 1 ; iz = -nzgrid !   do iky = 1, naky_all !      do ikyp = 1, naky !         gam0(iky,ikx,iz)%fourier(ikyp) = iky-naky + ikyp-1 !      end do !   end do !   call band_lu_factorisation_ffs (gam0, lu_gam0) !   do iky = 1, naky_all !      solvec(iky) = iky !   end do !   call band_lu_solve_ffs_single (lu_gam0(ikx,iz), solvec) !   do iky = 1, naky_all !      write (*,*) 'iky: ', iky, 'solution: ', solvec(iky) !   end do !   stop ! end subroutine test_band_lu_factorisation end module gyro_averages","tags":"","loc":"sourcefile/gyro_averages.f90.html"},{"title":"file_utils.fpp – stella","text":"Source Code # include \"define.inc\" module file_utils implicit none private public :: init_file_utils ! subroutine init_file_utils (list, input, error, trin_run, name) ! logical, intent (out) :: list ! logical, intent (in), optional :: input, error, trin_run ! character(*), intent (in), optional :: name !   default: INPUT=.true., ERROR=.true., TRIN_RUN=.false., NAME=\"unknown\" !   Set up run_name(s) and list_name for output files !   Open input file and strip comments, unless disabled with INPUT=.false. !   Open error output file, unless disabled with ERROR=.false. public :: init_job_name ! subroutine ... public :: finish_file_utils ! subroutine finish_file_utils !   Clean up files opened in init public :: run_name ! character(500) :: run_name !    Label for the run, taken from the command line public :: list_name ! character(500) :: list_name !    Label for the list, taken from the command line public :: input_unit ! function input_unit (nml) ! character(*), intent (in) :: nml ! integer :: input_unit !    Rewind the input file to start of namelist NML, !    and return its unit number public :: input_unit_exist ! function input_unit_exist (nml,exist) ! character(*), intent (in) :: nml ! integer :: input_unit !    Rewind the input file to start of namelist NML, !    and return its unit number, setexist=.true. !    If the namelist NML is not found, set exist=.false. public :: init_error_unit public :: init_input_unit public :: error_unit ! function error_unit () ! integer :: error_unit !    Return the error unit number public :: get_input_unit public :: open_output_file ! subroutine open_output_file (unit, ext) ! integer, intent (out) :: unit ! character (*), intent (in) :: ext !    Open a file with name made from the run_name with the EXT appended !    and return its unit number in UNIT public :: close_output_file ! subroutine close_output_file (unit) ! integer, intent (in) :: unit !    Close the file associated with UNIT from open_output_file public :: flush_output_file ! subroutine flush_output_file (unit) ! integer, intent (in) :: unit !    Close/open-append the file associated with UNIT from open_output_file public :: get_unused_unit ! subroutine get_unused_unit (unit) ! integer, intent (out) :: unit !    Return a unit number not associated with any file public :: get_indexed_namelist_unit ! subroutine get_indexed_namelist_unit (unit, nml, index) ! integer, intent (out) :: unit ! character (*), intent (in) :: nml ! integer, intent (in) :: index !    Copy namelist, NML // '_' // INDEX, from the input file to !    namelist, NML, in a temporary file, UNIT !  public :: num_input_lines public :: stdout_unit public :: runtype_option_switch public :: runtype_standalone public :: runtype_trinity public :: runtype_list public :: runtype_multibox character ( 500 ), pointer :: run_name character ( 500 ), target :: arun_name , job_name character ( 500 ) :: list_name integer , parameter :: stdout_unit = 6 integer :: runtype_option_switch integer , parameter :: runtype_standalone = 0 , & runtype_list = 1 , & runtype_trinity = 2 , & runtype_multibox = 3 integer , save :: input_unit_no , error_unit_no = stdout_unit ! TT> integer , save , public :: num_input_lines ! <TT contains subroutine init_file_utils ( list , input , error , trin_run , name , n_ensembles ) ! Find out the [[run_name]], and use the run name to determine whether ! this is a [[list]] run (i.e. a list of runs has been given) or a [[Trinity]] run. ! If not, open the error file and call init_input_unit implicit none logical , intent ( out ) :: list logical , intent ( in ), optional :: input , error , trin_run character ( * ), intent ( in ), optional :: name integer , intent ( in ), optional :: n_ensembles logical :: inp , err if ( present ( input )) then inp = input else inp = . true . end if if ( present ( error )) then err = error else err = . true . end if if ( present ( name )) then !# if FCOMPILER == _XL_ !       arun_name = name !# else arun_name = trim ( name ) !# endif else arun_name = \"unknown\" end if ! TT> changed for slice_g !    call run_type (list) if ( inp . and . . not . present ( trin_run )) then ! get runname from command line and ! set list=T if input ends in \".list\" call run_type ( list ) else if ( present ( trin_run )) then if ( trin_run ) runtype_option_switch = runtype_trinity list = . false . end if ! <TT if ( list ) then list_name = arun_name else if ( present ( n_ensembles )) then if ( n_ensembles > 1 ) then list_name = arun_name else call init_run_name call init_error_unit ( err ) call init_input_unit ( inp ) end if else call init_run_name call init_error_unit ( err ) call init_input_unit ( inp ) end if end subroutine init_file_utils subroutine run_type ( list ) ! This determines the type of run, by reading the name of the input file ! on the command line into [[arun_name]], and then looking at the extension. If ! the extension is .list, then [[list]] is set to .true.). use command_line , only : cl_getarg , cl_iargc implicit none logical , intent ( out ) :: list integer :: l , ierr list = . false . ! get argument from command line and put in arun_name if ( cl_iargc () /= 0 ) then call cl_getarg ( 1 , arun_name , l , ierr ) if ( ierr /= 0 ) then print * , \"Error getting run name.\" end if end if if ( l > 5 . and . arun_name ( l - 4 : l ) == \".list\" ) then list = . true . runtype_option_switch = runtype_list end if if ( l > 6 . and . arun_name ( l - 5 : l ) == \".multi\" ) then list = . true . runtype_option_switch = runtype_multibox end if end subroutine run_type subroutine init_run_name ! This is called for a non [[Trinity]] or [[list]] run - ! it checks that the input file name ends in \".in\", chops ! the extension off and stores it in [[arun_name]]. It ! also assigns the pointer [[run_name]] to [[arun_name]]. implicit none integer :: l l = len_trim ( arun_name ) if ( l > 3 . and . arun_name ( l - 2 : l ) == \".in\" ) then arun_name = arun_name ( 1 : l - 3 ) end if run_name => arun_name end subroutine init_run_name subroutine init_job_name ( jobname ) implicit none character ( len = 500 ), intent ( in ) :: jobname job_name = trim ( jobname ) run_name => job_name end subroutine init_job_name subroutine get_unused_unit ( unit ) ! Get an unused unit number for I/O. implicit none integer , intent ( out ) :: unit logical :: od unit = 50 do inquire ( unit = unit , opened = od ) if (. not . od ) return unit = unit + 1 end do end subroutine get_unused_unit !============================================== !============= OPEN OUTPUT FILE =============== !============================================== ! Open an output file to write data (replacing or appending any existing) ! The name is [[run_name]] + [[ext]], and set [[unit]] to the ! unit number of that output file. subroutine open_output_file ( unit , ext , overwrite_in ) implicit none integer , intent ( out ) :: unit logical , intent ( in ), optional :: overwrite_in logical :: overwrite character ( * ), intent ( in ) :: ext character ( 500 ) :: hack ! Initiate the optional argument if ( present ( overwrite_in )) then overwrite = overwrite_in else overwrite = . true . end if ! Get a unit for the output file that is not currently in use call get_unused_unit ( unit ) ! Create the name of the output file hack = trim ( run_name ) // ext ! If overwrite==True: Create a new output file or replace the existing file ! If overwrite==False: Append data to the already existing output file if ( overwrite ) then open ( unit = unit , file = trim ( hack ), status = \"replace\" , action = \"write\" ) else open ( unit = unit , file = trim ( hack ), status = \"unknown\" , action = \"write\" , position = \"append\" ) end if end subroutine open_output_file !============================================== !============= CLOSE OUTPUT FILE ============== !============================================== ! Close the output file identified by [[unit]]. subroutine close_output_file ( unit ) implicit none integer , intent ( in ) :: unit close ( unit = unit ) end subroutine close_output_file subroutine flush_output_file ( unit ) implicit none integer , intent ( in ) :: unit character ( len = 500 ) :: fname inquire ( unit , name = fname ) # if FCOMPILER == _XL_ call flush_ ( unit ) # elif FCOMPILER == _NAG_ close ( unit = unit ) open ( unit = unit , file = trim ( fname ), status = \"old\" , action = \"write\" , position = \"append\" ) # else call flush ( unit ) # endif end subroutine flush_output_file subroutine init_error_unit ( open_it ) implicit none logical , intent ( in ) :: open_it ! TT> changed for slice_g !    error_unit_no = 6 error_unit_no = 0 ! <TT if ( run_name /= \"unknown\" . and . open_it ) then call open_output_file ( error_unit_no , \".error\" ) ! TT: error_unit_no is overwritten for .error file end if end subroutine init_error_unit subroutine strip_comments ( line ) implicit none character ( * ), intent ( in out ) :: line logical :: in_single_quotes , in_double_quotes integer :: i , length length = len_trim ( line ) i = 1 in_single_quotes = . false . in_double_quotes = . false . loop : do if ( in_single_quotes ) then if ( line ( i : i ) == \"'\" ) in_single_quotes = . false . else if ( in_double_quotes ) then if ( line ( i : i ) == '\"' ) in_double_quotes = . false . else select case ( line ( i : i )) case ( \"'\" ) in_single_quotes = . true . case ( '\"' ) in_double_quotes = . true . case ( \"!\" ) i = i - 1 exit loop end select end if if ( i >= length ) exit loop i = i + 1 end do loop line = line ( 1 : i ) end subroutine strip_comments subroutine init_input_unit ( open_it ) ! open the input file, strip out any comments and !  write them into the file \".run_name.in\". Check ! for includes, read any lines from the includes, strip ! any comments from them and add them to the same file. implicit none logical , intent ( in ) :: open_it integer :: in_unit , out_unit , iostat character ( 500 ) :: line integer :: ind_slash !To hold position of slash in run_name ! for includes integer , parameter :: stack_size = 10 integer , dimension ( stack_size ) :: stack integer :: stack_ptr if (. not . open_it ) then input_unit_no = - 1 return end if call get_unused_unit ( in_unit ) open ( unit = in_unit , file = trim ( run_name ) // \".in\" , status = \"old\" , & action = \"read\" , iostat = iostat ) if ( iostat /= 0 ) then print \"(a)\" , \"Could not open input file: \" // trim ( run_name ) // \".in\" end if call get_unused_unit ( out_unit ) !    open (unit=out_unit, status=\"scratch\", action=\"readwrite\") !Determine if '/' is in input name and if so what position !in the string is the last one (i.e. split run_name into path_to_file and file) ind_slash = index ( run_name , \"/\" , . True .) if ( ind_slash == 0 ) then !No slash in name !Original behaviour open ( unit = out_unit , file = \".\" // trim ( run_name ) // \".in\" ) else !General behaviour open ( unit = out_unit , file = trim ( run_name ( 1 : ind_slash )) // \".\" // trim ( run_name ( ind_slash + 1 :)) // \".in\" ) end if iostat = 0 stack_ptr = 0 num_input_lines = 0 do read ( unit = in_unit , fmt = \"(a)\" , iostat = iostat ) line if ( iostat /= 0 ) then if ( stack_ptr <= 0 ) exit close ( unit = in_unit ) iostat = 0 in_unit = stack ( stack_ptr ) stack_ptr = stack_ptr - 1 cycle end if if ( line ( 1 : 9 ) == \"!include \" ) then if ( stack_ptr >= stack_size ) then print \"(a)\" , \"!include ignored: nesting too deep: \" // trim ( line ) cycle end if stack_ptr = stack_ptr + 1 stack ( stack_ptr ) = in_unit call get_unused_unit ( in_unit ) open ( unit = in_unit , file = trim ( line ( 10 :)), status = \"old\" , & action = \"read\" , iostat = iostat ) if ( iostat /= 0 ) then print \"(a)\" , \"!include ignored: file unreadable: \" // trim ( line ) in_unit = stack ( stack_ptr ) stack_ptr = stack_ptr - 1 cycle end if cycle end if call strip_comments ( line ) write ( unit = out_unit , fmt = \"(a)\" ) trim ( line ) num_input_lines = num_input_lines + 1 end do close ( unit = in_unit ) input_unit_no = out_unit end subroutine init_input_unit subroutine finish_file_utils implicit none if ( input_unit_no > 0 ) then close ( unit = input_unit_no ) input_unit_no = - 1 end if if ( error_unit_no > 0 . and . error_unit_no /= 6 ) then close ( unit = error_unit_no ) error_unit_no = - 1 end if end subroutine finish_file_utils function input_unit ( nml ) implicit none character ( * ), intent ( in ) :: nml integer :: input_unit , iostat character ( 500 ) :: line intrinsic adjustl , trim input_unit = input_unit_no if ( input_unit_no > 0 ) then rewind ( unit = input_unit_no ) do read ( unit = input_unit_no , fmt = \"(a)\" , iostat = iostat ) line if ( iostat /= 0 ) then rewind ( unit = input_unit_no ) exit end if if ( trim ( adjustl ( line )) == \"&\" // nml ) then backspace ( unit = input_unit_no ) return end if end do end if write ( unit = error_unit_no , fmt = \"('Could not find namelist: ',a)\" ) nml write ( unit =* , fmt = \"('Could not find namelist: ',a)\" ) nml end function input_unit function input_unit_exist ( nml , exist ) implicit none character ( * ), intent ( in ) :: nml logical , intent ( out ) :: exist integer :: input_unit_exist , iostat character ( 500 ) :: line intrinsic adjustl , trim input_unit_exist = input_unit_no exist = . true . if ( input_unit_no > 0 ) then rewind ( unit = input_unit_no ) do read ( unit = input_unit_no , fmt = \"(a)\" , iostat = iostat ) line if ( iostat /= 0 ) then rewind ( unit = input_unit_no ) exit end if if ( trim ( adjustl ( line )) == \"&\" // nml ) then backspace ( unit = input_unit_no ) return end if end do end if exist = . false . end function input_unit_exist function error_unit () implicit none integer :: error_unit error_unit = error_unit_no end function error_unit subroutine get_input_unit ( unit ) implicit none integer , intent ( out ) :: unit unit = input_unit_no end subroutine get_input_unit subroutine get_indexed_namelist_unit ( unit , nml , index_in ) implicit none integer , intent ( out ) :: unit character ( * ), intent ( in ) :: nml integer , intent ( in ) :: index_in character ( 500 ) :: line integer :: iunit , iostat , in_file integer :: ind_slash logical :: exist call get_unused_unit ( unit ) !    open (unit=unit, status=\"scratch\", action=\"readwrite\") !Determine if '/' is in input name and if so what position !in the string is the last one (i.e. split run_name into path_to_file and file) ind_slash = index ( run_name , \"/\" , . True .) if ( ind_slash == 0 ) then !No slash in name !Original behaviour open ( unit = unit , file = \".\" // trim ( run_name ) // \".scratch\" ) else !General behaviour open ( unit = unit , file = trim ( run_name ( 1 : ind_slash )) // \".\" // trim ( run_name ( ind_slash + 1 :)) // \".scratch\" ) end if write ( line , * ) index_in line = nml // \"_\" // trim ( adjustl ( line )) in_file = input_unit_exist ( trim ( line ), exist ) if ( exist ) then iunit = input_unit ( trim ( line )) else write ( 6 , * ) \"get_indexed_namelist: following namelist not found \" , trim ( line ) return end if read ( unit = iunit , fmt = \"(a)\" ) line write ( unit = unit , fmt = \"('&',a)\" ) nml do read ( unit = iunit , fmt = \"(a)\" , iostat = iostat ) line if ( iostat /= 0 . or . trim ( adjustl ( line )) == \"/\" ) exit write ( unit = unit , fmt = \"(a)\" ) trim ( line ) end do write ( unit = unit , fmt = \"('/')\" ) rewind ( unit = unit ) end subroutine get_indexed_namelist_unit end module file_utils","tags":"","loc":"sourcefile/file_utils.fpp.html"},{"title":"command_line.fpp – stella","text":"Source Code # include \"define.inc\" module command_line ! (c) Copyright 1991 to 1998 by Michael A. Beer, William D. Dorland, ! P. B. Snyder, Q. P. Liu, and Gregory W. Hammett. ALL RIGHTS RESERVED. ! ! <doc> !  A wrapper module for handling command line arguments. !  This module provides subroutine cl_getarg and integer function cl_iargc. !  Most of the compilers have getarg and iargc as their extensions. !  If not, one can use POSIX pxfgetarg and ipxfargc. ! !  Note that Fortran 2003 includes get_command_argument and !  command_argument_count which will replace getarg and iargc. ! </doc> implicit none private public :: cl_getarg , cl_iargc contains function cl_iargc () ! <doc> !  returns the number of arguments !  using intrinsic iargc or POSIX ipxfargc ! </doc> # ifdef POSIX # if FCOMPILER == _INTEL_ use ifposix , only : iargc => ipxfargc # endif # else # if FCOMPILER == _NAG_ use f90_unix , only : iargc # endif # endif implicit none integer :: cl_iargc # if ( POSIX == _NONE_ && FCOMPILER != _NAG_ ) integer :: iargc # endif cl_iargc = iargc () end function cl_iargc subroutine cl_getarg ( k , arg , len , ierr ) ! <doc> !  gets k-th argument string and its length !  using intrinsic getarg or POSIX pxfgetarg ! </doc> # ifdef POSIX use ifposix , only : pxfgetarg # else # if FCOMPILER == _NAG_ use f90_unix , only : getarg # endif # endif implicit none integer , intent ( in ) :: k character ( len =* ), intent ( out ) :: arg integer , intent ( out ) :: len integer , intent ( out ) :: ierr # ifdef POSIX call pxfgetarg ( k , arg , len , ierr ) # else call getarg ( k , arg ) len = len_trim ( arg ) ierr = 0 # endif end subroutine cl_getarg end module command_line","tags":"","loc":"sourcefile/command_line.fpp.html"},{"title":"fluxes.f90 – stella","text":"Source Code program fluxes ! takes argument 1 as .fluxes output file path ! argument 2 as number of time steps in .fluxes file ! argument 3 as number of species in simulation ! argument 4 as starting time for time average ! writes the time average of the fluxes to screen implicit none integer :: iargc integer :: flxunit = 101 integer :: it , nstep , nspec integer :: target_it real :: tstart = 0.0 logical :: tstart_flag character ( 500 ) :: line character ( 500 ) :: flxfile real , dimension (:), allocatable :: time real , dimension (:, :), allocatable :: pflx , vflx , qflx real , dimension (:), allocatable :: pflxavg , vflxavg , qflxavg , pi_over_q call getarg ( 1 , flxfile ) call getarg ( 2 , line ) read ( line , * ) nstep call getarg ( 3 , line ) read ( line , * ) nspec if ( iargc () > 3 ) then call getarg ( 4 , line ) read ( line , * ) tstart end if write ( * , * ) nstep , tstart , nspec , trim ( flxfile ) allocate ( time ( nstep )) allocate ( pflx ( nspec , nstep )) allocate ( vflx ( nspec , nstep )) allocate ( qflx ( nspec , nstep )) allocate ( pflxavg ( nspec )) allocate ( vflxavg ( nspec )) allocate ( qflxavg ( nspec )) allocate ( pi_over_q ( nspec )) target_it = 1 tstart_flag = . true . open ( unit = flxunit , file = trim ( flxfile ) // \".fluxes\" ) read ( flxunit , * ) line do it = 1 , nstep read ( flxunit , * ) time ( it ), pflx (:, it ), vflx (:, it ), qflx (:, it ) ! find the time index corresponding to the requested start time if ( tstart_flag . and . time ( it ) > tstart ) then target_it = it tstart_flag = . false . end if end do call time_average ( time , target_it , pflx , pflxavg ) call time_average ( time , target_it , vflx , vflxavg ) call time_average ( time , target_it , qflx , qflxavg ) call time_average ( time , target_it , vflx / qflx , pi_over_q ) close ( flxunit ) open ( flxunit , file = trim ( flxfile ) // \".fluxes_tavg\" ) write ( flxunit , * ) 'pflx: ' , pflxavg , 'vflx: ' , vflxavg , 'qflx: ' , qflxavg , 'vflx/qflx: ' , pi_over_q , vflxavg / qflxavg close ( flxunit ) deallocate ( time ) deallocate ( pflx , vflx , qflx ) deallocate ( pflxavg , vflxavg , qflxavg , pi_over_q ) contains subroutine time_average ( t , it , flx , flxavg ) implicit none real , dimension (:), intent ( in ) :: t integer , intent ( in ) :: it real , dimension (:, :), intent ( in ) :: flx real , dimension (:), intent ( out ) :: flxavg integer :: i , nt nt = size ( t ) flxavg = 0.5 * ( t ( it + 1 ) - t ( it )) * flx (:, it ) do i = it + 1 , nt - 1 flxavg = flxavg + ( t ( i + 1 ) - t ( i )) * flx (:, i ) end do flxavg = flxavg + 0.5 * ( t ( nt ) - t ( nt - 1 )) * flx (:, nt ) flxavg = flxavg / ( t ( nt ) - t ( it )) end subroutine time_average end program fluxes","tags":"","loc":"sourcefile/fluxes.f90.html"},{"title":"init_g.f90 – stella","text":"Source Code !> This module contains the subroutines which set the initial value of the !! fields and the distribution function. module init_g implicit none public :: ginit public :: init_init_g , finish_init_g public :: width0 public :: scale_to_phiinit , phiinit public :: tstart public :: reset_init private ! knobs integer :: ginitopt_switch integer , parameter :: ginitopt_default = 1 , & ginitopt_noise = 2 , ginitopt_restart_many = 3 , & ginitopt_kpar = 4 , ginitopt_nltest = 5 , & ginitopt_kxtest = 6 , ginitopt_rh = 7 , & ginitopt_remap = 8 real :: width0 , phiinit , imfac , refac , zf_init real :: den0 , upar0 , tpar0 , tperp0 real :: den1 , upar1 , tpar1 , tperp1 real :: den2 , upar2 , tpar2 , tperp2 real :: tstart , scale , kxmax , kxmin logical :: chop_side , left , scale_to_phiinit , oddparity character ( 300 ), public :: restart_file character ( len = 150 ) :: restart_dir logical :: initialized = . false . logical :: exist contains subroutine init_init_g use stella_save , only : init_save , read_many use stella_layouts , only : init_stella_layouts use system_fortran , only : systemf use mp , only : proc0 , broadcast implicit none integer :: ind_slash if ( initialized ) return initialized = . true . call init_stella_layouts if ( proc0 ) call read_parameters ! prepend restart_dir to restart_file ! append trailing slash if not exists if ( restart_dir ( len_trim ( restart_dir ):) /= \"/\" ) & restart_dir = trim ( restart_dir ) // \"/\" if ( proc0 ) call systemf ( 'mkdir -p ' // trim ( restart_dir )) !Determine if restart file contains \"/\" if so split on this point to give DIR//FILE !so restart files are created in DIR//restart_dir//FILE ind_slash = index ( restart_file , \"/\" , . true .) if ( ind_slash == 0 ) then !No slash present restart_file = trim ( restart_dir ) // trim ( restart_file ) else !Slash present restart_file = trim ( restart_file ( 1 : ind_slash )) // trim ( restart_dir ) // trim ( restart_file ( ind_slash + 1 :)) end if call broadcast ( ginitopt_switch ) call broadcast ( width0 ) call broadcast ( refac ) call broadcast ( imfac ) call broadcast ( den0 ) call broadcast ( upar0 ) call broadcast ( tpar0 ) call broadcast ( tperp0 ) call broadcast ( den1 ) call broadcast ( upar1 ) call broadcast ( tpar1 ) call broadcast ( tperp1 ) call broadcast ( den2 ) call broadcast ( upar2 ) call broadcast ( tpar2 ) call broadcast ( tperp2 ) call broadcast ( phiinit ) call broadcast ( zf_init ) call broadcast ( kxmax ) call broadcast ( kxmin ) call broadcast ( tstart ) call broadcast ( chop_side ) call broadcast ( left ) call broadcast ( restart_file ) call broadcast ( read_many ) call broadcast ( scale_to_phiinit ) call broadcast ( scale ) call broadcast ( oddparity ) call init_save ( restart_file ) end subroutine init_init_g subroutine ginit ( restarted , istep0 ) use stella_save , only : init_tstart use run_parameters , only : maxwellian_normalization logical , intent ( out ) :: restarted integer , intent ( out ) :: istep0 integer :: istatus restarted = . false . istep0 = 0 select case ( ginitopt_switch ) case ( ginitopt_default ) call ginit_default case ( ginitopt_noise ) call ginit_noise case ( ginitopt_kpar ) call ginit_kpar case ( ginitopt_rh ) call ginit_rh case ( ginitopt_remap ) call ginit_remap case ( ginitopt_restart_many ) call ginit_restart_many call init_tstart ( tstart , istep0 , istatus ) restarted = . true . scale = 1. !    case (ginitopt_nltest) !       call ginit_nltest !    case (ginitopt_kxtest) !       call ginit_kxtest end select !> if maxwwellian_normalization = .true., the pdf is normalized by F0 (which is not the case otherwise) !> unless reading in g from a restart file, normalise g by F0 for a full flux surface simulation if ( maxwellian_normalization . and . ginitopt_switch /= ginitopt_restart_many ) then call normalize_by_maxwellian end if end subroutine ginit subroutine read_parameters use file_utils , only : input_unit , error_unit , run_name , input_unit_exist use text_options , only : text_option , get_option_value use stella_save , only : read_many implicit none type ( text_option ), dimension ( 8 ), parameter :: ginitopts = & ( / text_option ( 'default' , ginitopt_default ), & text_option ( 'noise' , ginitopt_noise ), & text_option ( 'many' , ginitopt_restart_many ), & text_option ( 'nltest' , ginitopt_nltest ), & text_option ( 'kxtest' , ginitopt_kxtest ), & text_option ( 'kpar' , ginitopt_kpar ), & text_option ( 'rh' , ginitopt_rh ), & text_option ( 'remap' , ginitopt_remap ) & / ) character ( 20 ) :: ginit_option namelist / init_g_knobs / ginit_option , width0 , phiinit , chop_side , & restart_file , restart_dir , read_many , left , scale , tstart , zf_init , & den0 , upar0 , tpar0 , tperp0 , imfac , refac , & den1 , upar1 , tpar1 , tperp1 , & den2 , upar2 , tpar2 , tperp2 , & kxmax , kxmin , scale_to_phiinit , & oddparity integer :: ierr , in_file tstart = 0. scale = 1.0 ginit_option = \"default\" width0 = - 3.5 refac = 1. imfac = 0. den0 = 1. upar0 = 0. tpar0 = 0. tperp0 = 0. den1 = 0. upar1 = 0. tpar1 = 0. tperp1 = 0. den2 = 0. upar2 = 0. tpar2 = 0. tperp2 = 0. phiinit = 1.0 zf_init = 1.0 kxmax = 1.e100 kxmin = 0. chop_side = . false . scale_to_phiinit = . false . left = . true . oddparity = . false . restart_file = trim ( run_name ) // \".nc\" restart_dir = \"./\" in_file = input_unit_exist ( \"init_g_knobs\" , exist ) !    if (exist) read (unit=input_unit(\"init_g_knobs\"), nml=init_g_knobs) if ( exist ) read ( unit = in_file , nml = init_g_knobs ) ierr = error_unit () call get_option_value & ( ginit_option , ginitopts , ginitopt_switch , & ierr , \"ginit_option in ginit_knobs\" , stop_on_error = . true .) end subroutine read_parameters subroutine ginit_default use constants , only : zi use species , only : spec use zgrid , only : nzgrid , zed use kt_grids , only : naky , nakx use kt_grids , only : theta0 use kt_grids , only : reality , zonal_mode use vpamu_grids , only : nvpa , nmu use vpamu_grids , only : vpa use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use dist_fn_arrays , only : gvmu use stella_layouts , only : kxkyz_lo , iz_idx , ikx_idx , iky_idx , is_idx use ran , only : ranf implicit none complex , dimension ( naky , nakx , - nzgrid : nzgrid ) :: phi logical :: right integer :: ikxkyz integer :: iz , iky , ikx , is , ia right = . not . left do iz = - nzgrid , nzgrid phi (:, :, iz ) = exp ( - (( zed ( iz ) - theta0 ) / width0 ) ** 2 ) * cmplx ( 1.0 , 1.0 ) end do ! this is a messy way of doing things ! could tidy it up a bit if ( sum ( cabs ( phi )) < epsilon ( 0. )) then do iz = - nzgrid , nzgrid phi (:, :, iz ) = exp ( - ( zed ( iz ) / width0 ) ** 2 ) * cmplx ( 1.0 , 1.0 ) end do end if if ( oddparity ) then ! make phi an odd function of zed do iz = - nzgrid , nzgrid phi (:, :, iz ) = zed ( iz ) * phi (:, :, iz ) end do end if if ( chop_side ) then if ( left ) phi (:, :, : - 1 ) = 0.0 if ( right ) phi (:, :, 1 :) = 0.0 end if if ( reality . and . zonal_mode ( 1 )) phi ( 1 , :, :) = 0.0 ia = 1 gvmu = 0. do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iz = iz_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iky = iky_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) gvmu (:, :, ikxkyz ) = phiinit * phi ( iky , ikx , iz ) / abs ( spec ( is )% z ) & * ( den0 + 2.0 * zi * spread ( vpa , 2 , nmu ) * upar0 ) & * spread ( maxwell_mu ( ia , iz , :, is ), 1 , nvpa ) * spread ( maxwell_vpa (:, is ), 2 , nmu ) * maxwell_fac ( is ) end do end subroutine ginit_default ! initialize two kys and kx=0 !   subroutine ginit_nltest !     use mp, only: proc0 !     use species, only: spec !     use zgrid, only: nzgrid, bmag !     use kt_grids, only: naky, ntheta0 !     use vpamu_grids, only: nvgrid, vpa, mu !     use dist_fn_arrays, only: gnew, gold !     use stella_layouts, only: gxyz_lo, iv_idx, is_idx, imu_idx !     implicit none !     complex, dimension (-nzgrid:nzgrid,ntheta0,naky) :: phi !     logical :: right !     integer :: iglo !     integer :: ig, ik, it, is, iv, imu !     right = .not. left !     if (naky < 4 .or. ntheta0 < 2) then !        if (proc0) write (*,*) 'must have at least 2 kxs and 4 kys to use nltest init option. aborting.' !        stop !     end if !     phi = 0.0 !     do ig = -nzgrid, nzgrid !        phi(ig,2,2) = 1.0!exp(-((theta(ig)-theta0(2,2))/width0)**2)*cmplx(1.0,1.0) !     end do !     gnew = 0.0 !     do iglo = gxyz_lo%llim_proc, gxyz_lo%ulim_proc !        iv = iv_idx(gxyz_lo,iglo) !        is = is_idx(gxyz_lo,iglo) !        imu = imu_idx(gxyz_lo,iglo) !        it = 1 !        do ik = 2, 3 !           gnew(:,it,ik,iglo) = exp(-2.0*mu(imu)*bmag)*phi(:,it,ik) & !                *spec(is)%z*phiinit*exp(-vpa(iv)**2) !        end do !     end do !     gold = gnew !   end subroutine ginit_nltest !   subroutine ginit_kxtest !     use constants, only: zi !     use species, only: spec !     use zgrid, only: itor_over_b !     use kt_grids, only: ntheta0, akx, naky !     use vpamu_grids, only: nvgrid, energy, vpa !     use dist_fn_arrays, only: gnew, gold !     use stella_layouts, only: gxyz_lo, iv_idx, is_idx, imu_idx !     implicit none !     integer :: iglo !     integer :: ik, it, is, imu, iv !     do iglo = gxyz_lo%llim_proc, gxyz_lo%ulim_proc !        iv = iv_idx(gxyz_lo,iglo) !        is = is_idx(gxyz_lo,iglo) !        imu = imu_idx(gxyz_lo,iglo) !        do it = 1, ntheta0 !           do ik = 1, naky !              gnew(:,it,ik,iglo) = exp(-zi*akx(it)*itor_over_B*vpa(iv)/spec(is)%zstm) & !                   *exp(-energy(:,iv,imu))*spec(is)%z*phiinit !           end do !        end do !     end do !     gold = gnew !   end subroutine ginit_kxtest !   !> Initialise with only the kparallel = 0 mode. !   subroutine single_initial_kx(phi) !     use zgrid, only: nzgrid !     use kt_grids, only: naky, ntheta0 !     use mp, only: mp_abort !     implicit none !     complex, dimension (-nzgrid:nzgrid,ntheta0,naky), intent(inout) :: phi !     real :: a, b !     integer :: ig, ik, it !     if (ikx_init  < 2 .or. ikx_init > (ntheta0+1)/2) then !       call mp_abort(\"The subroutine single_initial_kx should only be called when 1 < ikx_init < (ntheta0+1)/2\") !     end if !     do it = 1, ntheta0 !       if (it .ne. ikx_init) then !          do ik = 1, naky !             do ig = -nzgrid, nzgrid !                a = 0.0 !                b = 0.0 !                phi(ig,it,ik) = cmplx(a,b) !              end do !          end do !        end if !     end do !   end subroutine single_initial_kx !> Initialise the distribution function with random noise. This is the default !! initialisation option. Each different mode is given a random amplitude !! between zero and one. subroutine ginit_noise use mp , only : proc0 , broadcast use dist_fn_arrays , only : kperp2 use species , only : spec use zgrid , only : nzgrid , ntubes use extended_zgrid , only : ikxmod , nsegments , neigen use extended_zgrid , only : it_right use extended_zgrid , only : periodic , phase_shift use kt_grids , only : naky , nakx , reality , zonal_mode use vpamu_grids , only : nvpa , nmu use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use dist_fn_arrays , only : gvmu use stella_layouts , only : kxkyz_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , it_idx , is_idx use mp , only : proc0 , broadcast , max_allreduce use mp , only : scope , crossdomprocs , subprocs use file_utils , only : runtype_option_switch , runtype_multibox use physics_flags , only : nonlinear use stella_geometry , only : sign_torflux use ran implicit none complex , dimension ( naky , nakx , - nzgrid : nzgrid , ntubes ) :: phi real :: a , b , kmin integer :: ikxkyz , iz , it , iky , ikx , is , ie , iseg , ia integer :: itmod if (( naky == 1 . and . nakx == 1 ) . or . (. not . nonlinear )) then if ( proc0 ) then write ( * , * ) 'Noise initialization option is not suited for single mode simulations,' write ( * , * ) 'or linear simulations, using default initialization option instead.' write ( * , * ) end if call ginit_default return else ! zero out ky=kx=0 mode phi ( 1 , 1 , :, :) = 0.0 end if ia = 1 if ( proc0 ) then phi ( 1 , 1 , :, :) = 0.0 kmin = 1.e6 if ( naky > 1 ) kmin = minval ( kperp2 ( 2 , 1 , ia , :)) if ( nakx > 1 ) kmin = min ( kmin , minval ( kperp2 ( 1 , 2 , ia , :))) if ( runtype_option_switch == runtype_multibox ) then call scope ( crossdomprocs ) call max_allreduce ( kmin ) call scope ( subprocs ) end if ! keep old (ikx, iky) loop order to get old results exactly: !Fill phi with random (complex) numbers between -0.5 and 0.5 do ikx = 1 , nakx do iky = 1 , naky do it = 1 , ntubes do iz = - nzgrid , nzgrid ! For the same rng-seed, the <-sign_torflux> will make the time trace of CCW and CW more similar a = ranf () - 0.5 b = - sign_torflux * ( ranf () - 0.5 ) ! do not populate high k modes with large amplitudes if (( ikx > 1 . or . iky > 1 ) . and . ( kperp2 ( iky , ikx , ia , iz ) >= kmin )) then !the following as an extra factor of kmin to offset the Gamma-1 in quasineutrality phi ( iky , ikx , iz , it ) = cmplx ( a , b ) * kmin * kmin / kperp2 ( iky , ikx , ia , iz ) else phi ( iky , ikx , iz , it ) = 0.0 end if end do if ( chop_side ) then if ( left ) then phi ( iky , ikx , : - 1 , it ) = 0.0 else phi ( iky , ikx , 1 :, it ) = 0.0 end if end if end do end do end do ! enforce periodicity where required do iky = 1 , naky if ( periodic ( iky )) then phi ( iky , :, nzgrid , :) = phi ( iky , :, - nzgrid , :) / phase_shift ( iky ) end if end do ! zero out the kx=ky=0 mode and apply optional ! scaliing factor to all zonal modes if ( zonal_mode ( 1 )) then !Apply scaling factor phi ( 1 , :, :, :) = phi ( 1 , :, :, :) * zf_init !Set ky=kx=0.0 mode to zero in amplitude phi ( 1 , 1 , :, :) = 0.0 end if !Apply reality condition (i.e. -kx mode is conjugate of +kx mode) if ( reality ) then do ikx = nakx / 2 + 2 , nakx phi ( 1 , ikx , :, :) = conjg ( phi ( 1 , nakx - ikx + 2 , :, :)) end do end if end if do iky = 1 , naky do ie = 1 , neigen ( iky ) ! enforce zero BC at ends of domain, unless periodic if (. not . periodic ( iky )) then phi ( iky , ikxmod ( 1 , ie , iky ), - nzgrid , :) = 0.0 phi ( iky , ikxmod ( nsegments ( ie , iky ), ie , iky ), nzgrid , :) = 0.0 end if ! enforce equality of g values at duplicate zed points if ( nsegments ( ie , iky ) > 1 ) then do it = 1 , ntubes itmod = it do iseg = 2 , nsegments ( ie , iky ) phi ( iky , ikxmod ( iseg , ie , iky ), - nzgrid , it_right ( itmod )) = phi ( iky , ikxmod ( iseg - 1 , ie , iky ), nzgrid , itmod ) itmod = it_right ( itmod ) end do end do end if end do end do call broadcast ( phi ) !Now set g using data in phi do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iz = iz_idx ( kxkyz_lo , ikxkyz ) it = it_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iky = iky_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) gvmu (:, :, ikxkyz ) = spec ( is )% z * phiinit * phi ( iky , ikx , iz , it ) & * spread ( maxwell_vpa (:, is ), 2 , nmu ) * spread ( maxwell_mu ( ia , iz , :, is ), 1 , nvpa ) * maxwell_fac ( is ) end do end subroutine ginit_noise subroutine ginit_kpar !    use species, only: spec, has_electron_species use zgrid , only : nzgrid , zed use kt_grids , only : naky , nakx , theta0 use vpamu_grids , only : nvpa , nmu use vpamu_grids , only : vpa , vperp2 use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use dist_fn_arrays , only : gvmu use stella_layouts , only : kxkyz_lo , iky_idx , ikx_idx , iz_idx , is_idx use constants , only : zi implicit none complex , dimension ( naky , nakx , - nzgrid : nzgrid ) :: phi , odd real , dimension ( - nzgrid : nzgrid ) :: dfac , ufac , tparfac , tperpfac integer :: ikxkyz integer :: iz , iky , ikx , imu , iv , ia , is phi = 0. odd = 0. if ( width0 > 0. ) then do iz = - nzgrid , nzgrid phi (:, :, iz ) = exp ( - (( zed ( iz ) - theta0 ) / width0 ) ** 2 ) * cmplx ( refac , imfac ) end do else do iz = - nzgrid , nzgrid phi (:, :, iz ) = cmplx ( refac , imfac ) end do end if if ( chop_side ) then if ( left ) then phi (:, :, : - 1 ) = 0.0 else phi (:, :, 1 :) = 0.0 end if end if odd = zi * phi dfac = den0 + den1 * cos ( zed ) + den2 * cos ( 2. * zed ) ufac = upar0 + upar1 * sin ( zed ) + upar2 * sin ( 2. * zed ) tparfac = tpar0 + tpar1 * cos ( zed ) + tpar2 * cos ( 2. * zed ) tperpfac = tperp0 + tperp1 * cos ( zed ) + tperp2 * cos ( 2. * zed ) ia = 1 ! charge dependence keeps initial Phi from being too small do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) do imu = 1 , nmu do iv = 1 , nvpa gvmu ( iv , imu , ikxkyz ) = phiinit & * ( dfac ( iz ) * phi ( iky , ikx , iz ) & + 2.0 * vpa ( iv ) * ufac ( iz ) * odd ( iky , ikx , iz ) & + ( vpa ( iv ) ** 2 - 0.5 ) * tparfac ( iz ) * phi ( iky , ikx , iz ) & + tperpfac ( iz ) * ( vperp2 ( ia , iz , imu ) - 1. ) * phi ( iky , ikx , iz )) end do end do gvmu (:, :, ikxkyz ) = gvmu (:, :, ikxkyz ) & * spread ( maxwell_vpa (:, is ), 2 , nmu ) * spread ( maxwell_mu ( ia , iz , :, is ), 1 , nvpa ) * maxwell_fac ( is ) end do ! FLAG -- should be uncommented, which means I need to fix flae !    if (has_electron_species(spec)) then !       call flae (gold, gnew) !       gold = gold - gnew !    end if !    gnew = gold end subroutine ginit_kpar subroutine ginit_rh use species , only : spec use dist_fn_arrays , only : gvmu , kperp2 use stella_layouts , only : kxkyz_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , is_idx use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use vpamu_grids , only : nvpa , nmu use kt_grids , only : akx implicit none integer :: ikxkyz , iky , ikx , iz , is , ia ! initialize g to be a Maxwellian with a constant density perturbation gvmu = 0. ia = 1 do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc ! only set the first ky mode to be non-zero ! this is because this is meant to test the damping of zonal flow (ky=0) iky = iky_idx ( kxkyz_lo , ikxkyz ); if ( iky /= 1 ) cycle ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) if ( abs ( akx ( ikx )) < kxmax . and . abs ( akx ( ikx )) > kxmin ) then gvmu (:, :, ikxkyz ) = spec ( is )% z * 0.5 * phiinit * kperp2 ( iky , ikx , ia , iz ) & * spread ( maxwell_vpa (:, is ), 2 , nmu ) * spread ( maxwell_mu ( ia , iz , :, is ), 1 , nvpa ) * maxwell_fac ( is ) end if end do end subroutine ginit_rh subroutine ginit_remap use species , only : spec use dist_fn_arrays , only : gvmu use stella_layouts , only : kxkyz_lo use stella_layouts , only : iky_idx , ikx_idx , iz_idx , is_idx use vpamu_grids , only : maxwell_vpa , maxwell_mu , maxwell_fac use vpamu_grids , only : nvpa , nmu implicit none integer :: ikxkyz , iky , ikx , iz , is , ia ! initialize g to be a Maxwellian with a constant density perturbation gvmu = 0. ia = 1 do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iky = iky_idx ( kxkyz_lo , ikxkyz ) ikx = ikx_idx ( kxkyz_lo , ikxkyz ) iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) !if((ikx.eq.15.and.iky.eq.5).or.((ikx-nakx).eq.-12.and.iky.eq.3)) then if (( ikx == 1 . and . iky == 2 )) then gvmu (:, :, ikxkyz ) = spec ( is )% z * phiinit & * spread ( maxwell_vpa (:, is ), 2 , nmu ) * spread ( maxwell_mu ( ia , iz , :, is ), 1 , nvpa ) * maxwell_fac ( is ) end if end do end subroutine ginit_remap subroutine ginit_restart_many use dist_fn_arrays , only : gvmu use stella_save , only : stella_restore use mp , only : proc0 use file_utils , only : error_unit implicit none integer :: istatus , ierr ! should really check if profile_variation=T here but need ! to move profile_variation to module that is accessible here call stella_restore ( gvmu , scale , istatus ) if ( istatus /= 0 ) then ierr = error_unit () if ( proc0 ) write ( ierr , * ) \"Error reading file: \" , trim ( restart_file ) gvmu = 0. end if end subroutine ginit_restart_many subroutine normalize_by_maxwellian use stella_layouts , only : kxkyz_lo , is_idx , iz_idx use dist_fn_arrays , only : gvmu use vpamu_grids , only : nmu use vpamu_grids , only : maxwell_mu , maxwell_vpa , maxwell_fac implicit none integer :: ia , imu integer :: ikxkyz , iz , is !> gvmu is initialised with a Maxwellian weighting for flux tube simulations, !> with the Maxwellian evaluated at ia = 1 !> we are undoing that weighting here, so also need to use ia = 1 ia = 1 do ikxkyz = kxkyz_lo % llim_proc , kxkyz_lo % ulim_proc iz = iz_idx ( kxkyz_lo , ikxkyz ) is = is_idx ( kxkyz_lo , ikxkyz ) do imu = 1 , nmu gvmu (:, imu , ikxkyz ) = gvmu (:, imu , ikxkyz ) / ( maxwell_mu ( ia , iz , imu , is ) * maxwell_vpa (:, is ) * maxwell_fac ( is )) end do end do end subroutine normalize_by_maxwellian subroutine reset_init ginitopt_switch = ginitopt_restart_many end subroutine reset_init !   subroutine flae (g, gavg) !     use species, only: spec, electron_species !     use zgrid, only: nzgrid, delthet, jacob !     use kt_grids, only: aky, ntheta0 !     use vpamu_grids, only: nvgrid !     use stella_layouts, only: gxyz_lo, is_idx !     complex, dimension (-nzgrid:,:,:,gxyz_lo%llim_proc:), intent (in) :: g !     complex, dimension (-nzgrid:,:,:,gxyz_lo%llim_proc:), intent (out) :: gavg !     real :: wgt !     integer :: iglo, it, ik !     gavg = 0. !     wgt = 1./sum(delthet*jacob) !     do iglo = gxyz_lo%llim_proc, gxyz_lo%ulim_proc !        if (spec(is_idx(gxyz_lo, iglo))%type /= electron_species) cycle !        ik = 1 !        if (aky(ik) > epsilon(0.)) cycle !        do it = 1, ntheta0 !           gavg(:,it,ik,iglo) = sum(g(:,it,ik,iglo)*delthet*jacob)*wgt !        end do !     end do !   end subroutine flae subroutine finish_init_g use stella_save , only : finish_save implicit none initialized = . false . call finish_save end subroutine finish_init_g end module init_g","tags":"","loc":"sourcefile/init_g.f90.html"},{"title":"physics_parameters.f90 – stella","text":"Source Code module physics_parameters implicit none public :: init_physics_parameters public :: finish_physics_parameters public :: beta , zeff , tite , nine , rhostar , vnew_ref public :: g_exb , g_exbfac , omprimfac private real :: beta , zeff , tite , nine , rhostar , irhostar , vnew_ref real :: g_exb , g_exbfac , omprimfac logical :: initialized = . false . contains subroutine init_physics_parameters implicit none if ( initialized ) return initialized = . true . call read_parameters end subroutine init_physics_parameters subroutine read_parameters use file_utils , only : input_unit_exist use mp , only : proc0 , broadcast implicit none integer :: in_file logical :: rpexist namelist / parameters / beta , zeff , tite , nine , rhostar , vnew_ref , & g_exb , g_exbfac , omprimfac , irhostar if ( proc0 ) then beta = 0.0 ! beta = 8 * pi * p_ref / B_ref&#94;2 vnew_ref = - 1.0 ! various input options will override this value if it is negative rhostar = - 1.0 ! = m_ref * vt_ref / (e * B_ref * a_ref), with refs in SI irhostar = - 1.0 zeff = 1.0 tite = 1.0 nine = 1.0 g_exb = 0.0 g_exbfac = 1.0 omprimfac = 1.0 in_file = input_unit_exist ( \"parameters\" , rpexist ) if ( rpexist ) read ( unit = in_file , nml = parameters ) if ( irhostar > 0 ) rhostar = 1. / irhostar end if call broadcast ( beta ) call broadcast ( vnew_ref ) call broadcast ( zeff ) call broadcast ( rhostar ) call broadcast ( tite ) call broadcast ( nine ) call broadcast ( g_exb ) call broadcast ( g_exbfac ) call broadcast ( omprimfac ) end subroutine read_parameters subroutine finish_physics_parameters implicit none initialized = . false . end subroutine finish_physics_parameters end module physics_parameters","tags":"","loc":"sourcefile/physics_parameters.f90.html"},{"title":"Manual – stella","text":"The manual is split into two parts: User manual : this covers documentation and information useful for\n   people who want to run stella Developer manual : this covers documentation and\n   important information for people interested in modifying and developing stella If you're new to stella, start here !","tags":"","loc":"page/index.html"},{"title":"Developer guide – stella","text":"","tags":"","loc":"page/developer_manual/index.html"},{"title":"CMake in stella – stella","text":"Stella now has (experimental) support for building with CMake. Developing the stella CMake build system One important consideration when developing stella is that any new\nfiles must be listed in the STELLA_SOURCES_* variables: either STELLA_SOURCES_f90 or STELLA_SOURCES_fpp as appropriate. If you\nadd a new file and do not add it to exactly one of these variables,\nyou will get a build error.","tags":"","loc":"page/developer_manual/CMake.html"},{"title":"Writing Documentation – stella","text":"In-source documentation Out-of-source documentation Add a new page Converting LaTeX to Markdown Linking to sections Linking to source documentation Building the documentation locally Cheat sheet stella uses FORD to automatically build this online documentation. There are two\nsorts of documentation that get built: in-source and out-of-source. This page describes\nhow to write both sorts. The website will get built automatically when your changes are\nmerged into master . In-source documentation Special Fortran comments of the form !> are used to document procedures, variables and\nprograms using FORD . These comments are sometimes called \"docstrings\". FORD can\nunderstand these comments before, after or in-line with the thing to be documented, but\nthe preferred style in stella is to put the comment before the entity, like in this example: !> This is module-level documentation, describing the overall purpose of this module. !> Documentation comments can be over several lines. module my_module implicit none !> Docstrings can go on derived types type :: my_type !> Docstrings can include in-line LaTeX like this: R real :: R_major !> Or as a displayed equation: !>   \\frac{\\partial R}{\\partial \\psi} real :: R_major_prime !> Code-formatting uses `backticks` integer :: n_R end type my_type contains !> We can document functions/subroutines real function gradient ( R , psi ) !> In order to separate the docstring for each argument... real , intent ( in ) :: R !> ...it's best to have each argument on its own line real , intent ( in ) :: psi end function gradient end module my_module The FORD wiki has more documentation on how to write these docstrings. Please\nnote that while FORD accepts !< comments after or in-line with the thing to be\ndocumented, the stella style is to stick to !> before and on a separate line. Out-of-source documentation As well as the code documentation, we also have some extra documentation. The source for\nthese pages in still kept in the stella git repository, and are built into the website at the\nsame time. These extra pages are written in Markdown , with some\nextensions (see the Python markdown implementation ). There's a short cheat sheet at the bottom of this page. Add a new page All the out-of-source documentation is under docs/pages . FORD converts the directory\nhierarchy in to a hierarchy of HTML pages. To add a new page, simply create a new file\nunder docs/pages , and use the file extension .md . Your file must contain the\nfollowing at the very top : --- title: Page title --- Without this metadata section, FORD will not parse the file as part of the documentation. In this metadata section, you can also have author and date items. Another useful feature, is put [TOC] on its own line after the metadata section. This\nproduces a hyperlinked table of contents. See the FORD wiki for a more detailed description. Converting LaTeX to Markdown The easiest way to convert LaTeX to Markdown is to use Pandoc . This nifty tool\nunderstands tons of text formats and can convert between them easily, and will get the\nvast majority of the heavy lifting done for you. Due to the complexities of LaTeX and the\nsimplicity of Markdown, it may require some manual tidying up after the initial\nconversion. To get started, run Pandoc: $ pandoc --standalone --from = latex --to = gfm my_docs.tex --output docs/pages/my_docs.md FORD is a bit fussier about the metadata section at the top, compared to what Pandoc\nproduces, so you may need to manually adjust it. Acceptable: ---\ntitle: On the Electrodynamics of Moving Bodies author: A. Einstein --- Unacceptable: ---\ntitle: Does the Inertia of a Body Depend upon its Energy Content?\nauthor: - 'A. Einstein' --- which is a possible output from Pandoc. FORD can render LaTeX included in the markdown, with just a couple of gotchas. The most\nimportant one is that in-line maths must use ... rather than $...$ . Displayed\nequations can be written between ... , but note that this does not number the\nresulting equation. Normal \\begin{equation} ... \\end{equation} environments can be used to get numbered\nequations, along with \\label{eq:something} and \\eqref{eq:something} to refer to them. This example: To obtain the distribution function at the next time step , \\ ( g &#94; { n + 1 } \\ ), we could combine these equations  A g &#94; { n + 1 } + B g &#94; { n } = DF &#94; { - 1 } Gg &#94; { n + 1 } + E \\ phi &#94; { n }, is rendered as: To obtain the distribution function at the next time step, , we could combine\nthese equations while \\ begin { equation } F \\ phi &#94; { n + 1 } = G g &#94; { n + 1 }\n\\ label { eq : QN }\n\\ end { equation }\n\n\\ eqref { eq : QN } is the quasi - neutrality equation is rendered as \\eqref{eq:QN} is the quasi-neutrality equation Linking to sections Section titles within a page get converted into HTML \"anchors\" which can be linked to. The\nsection names are first converted to lowercase and spaces replaced with hyphens. To link\nto a section, use the usual link syntax and add # in front of the converted section\nname. This: Link to [ this section ]( #linking-to-sections ) becomes: Link to this section Linking to source documentation Linking directly to the code documentation is possible using FORD's syntax, which is\ndescribed here : This: The two linear steps L are performed by the function [[dist_fn:invert_rhs]] in [[dist_fn.fpp(file)]] is rendered as: The two linear steps are performed by the function dist_fn in dist_fn.fpp Building the documentation locally FORD can be easily installed with pip : $ pip3 install --user ford After installing FORD, simply run make doc . This will build the documentation under docs/html : $ make doc Then open docs/html/index.html in your favourite browser. Cheat sheet See here for a comprehensive guide to Markdown. Here's a quick little cheat sheet: Syntax Description Heading # Top-level ## Section ### Sub-section Bold **bold text** Italic *italicised text* Code `code` Blockquote > Block quote Ordered lists 1. First item 2. Second item 3. Third item Unordered lists - First item - Second item - Third item Link [title](www.example.com) Image ![alt text](image.jpg)","tags":"","loc":"page/developer_manual/writing_documentation.html"},{"title":"User Guide – stella","text":"The user manual is divided into several helpful sections that cover various topics in depth. These sections can be seen on the index to the left. To get started, start here to get stella up and running. .","tags":"","loc":"page/user_manual/index.html"},{"title":"Downloading and Compiling – stella","text":"Getting stella Stella is hosted on the stella github repository . The simplest way of obtaining tstella on your system is to simply use the command line: git clone stella This will download stella from git into a new directory. From there, one needs to compile before running. Stella now has (experimental) support for building with CMake. Using Make Using CMake CMake options All CMake options can be set on the command line with the syntax: -D<variable>=value . Boolean flags can use on/yes/true/1 or off/no/false/0 to turn them on/off -- these options are\ncase-insensitive. Optimisation vs debugging CMake has a built-in option for setting optimisation or debugging\nflags: CMAKE_BUILD_TYPE . If this is not set, by default stella will\nuse RelWithDebInfo , which is the equivalent of -O2 -g : moderate\noptimisation with debug symbols. This doesn't turn on any runtime\nchecking, it only keeps names of functions, variables, etc. for error\nmessages and backtraces in the event of a crash. Set -DCMAKE_BUILD_TYPE=Release to turn on full optimisations. Use -DCMAKE_BUILD_TYPE=Debug to turn off optimisations and turn on\nvarious compile- and run-time checks (depending on the compiler). Dependencies Stella has several optional dependencies, the location of which can be\nspecified by using the <package>_ROOT variables. The list of\ndependencies and their location variables are as follows: MPI: This is the odd-one-out, in that the best way to control which\n  MPI implementation is found is via MPIEXEC_EXECUTABLE . This is\n  already automatically set to the current mpirun/mpiexec in your PATH , so this shouldn't need to be set. LAPACK: LAPACK_ROOT . On Cray systems that use the Cray Programming\n  Environment, this is automatically handled by the Cray Compiler\n  Environment and so is not user-controllable. FFTW: FFTW_ROOT . Stella also searches for the fftw-wisdom executable in your PATH as a first guess NetCDF: netCDF_ROOT for the C library, and netCDFFortran_ROOT for the Fortran API. Stella searches for nc-config and nf-config in your PATH and uses those to query the netCDF configuration All of these dependencies, with the exception of MPI, can be turned on\nor off with the STELLA_ENABLE_<name> variable.","tags":"","loc":"page/user_manual/download_and_compiling.html"},{"title":"Running stella – stella","text":"","tags":"","loc":"page/user_manual/running_stella.html"},{"title":"Input files – stella","text":"Input files used by stella Stella uses three different input files, denoted by the following extensions: `.in` These are the standard input files that stella uses `.list` A list of input files that stella can run in parallel, provided enough cores. `.multi` A list of three input files for use with the multiple-flux-tube radial boundary condition. The .in input file !include directive in .in files When stella processes .in files, it recognizes an include directive that takes the form !include NEW_FILE.in Using this directive, Note that the included files can have their own include directive, and so stella handles these directives recursively. In practice, the !include directive is useful for parameters scans where only one parameter The .list input file The .multi input file","tags":"","loc":"page/user_manual/input_files.html"},{"title":"Namelist parameters – stella","text":"namelist geo_knobs Variable Type Default Description geo_option string 'local' Selects the geometry module. Should be one of local Miller equilibrium. vmec VMEC stellarator equilibrium. Requires VMEC netcdf input file. input.profiles Reads in General Atomics input.gacode file. This may need to be updated for newer gacode files. miller same as local default same as miller geo_file string 'input.geometry' input file used to overwrite selected geometric coefficients below. File uses the same formatting as .geometry output. q_as_x boolean radial_variation Uses the safety factor  q  as the radial coordinate, rather than  \\psi . Used for radially global simulations. set_bmag_const boolean false Sets  B  uniformly to its value at the outboard midplane overwrite_bmag boolean false overwrite  B . overwrite_gradpar boolean false overwrite  \\boldsymbol{ b \\cdot \\nabla z} . overwrite_gds2 boolean false overwrite   \\lvert \\nabla \\alpha \\rvert&#94;2 (\\textrm{d}\\psi / \\textrm{d}r)&#94;2 . overwrite_gds21 boolean false overwrite  \\lvert \\nabla q \\cdot \\nabla \\alpha \\rvert (\\textrm{d}\\psi / \\textrm{d}r)&#94;2 . overwrite_gds22 boolean false overwrite  \\lvert \\nabla q \\rvert&#94;2 (\\textrm{d}\\psi / \\textrm{d}r)&#94;2 . overwrite_gds23 boolean false overwrite   \\nabla \\theta \\cdot [\\nabla \\alpha \\times (\\nabla r \\times \\nabla \\alpha)] (\\textrm{d}\\psi / \\textrm{d}r)&#94;2 / B&#94;2 . overwrite_gds24 boolean false overwrite  \\nabla \\theta \\cdot [\\nabla r \\times (\\nabla r \\times \\nabla \\alpha)] (\\textrm{d}\\psi / \\textrm{d}r)&#94;2 (q/r) / B&#94;2. overwrite_gbdrift boolean false overwrite  2 (\\boldsymbol{b} \\times \\nabla B \\cdot \\nabla \\alpha) (\\textrm{d}\\psi / \\textrm{d}r) /B&#94;2 . overwrite_gbdrift0 boolean false overwrite  2 (\\boldsymbol{b} \\times \\nabla B \\cdot \\nabla q) (\\textrm{d}\\psi / \\textrm{d}r) /B&#94;2  . overwrite_cvdrift boolean false overwrite  2(\\textrm{d}\\psi / \\textrm{d}r)[\\boldsymbol{b} \\times (\\boldsymbol{b \\cdot \\nabla b})]\\cdot \\nabla \\alpha / B  namelist millergeo_parameters Variable Type Default Description rhoc real 0.5 radial position of fluxtube  r  rmaj real 3.0 device major radius  R_0  shift real 0.0 Shafranov shift qinp real 1.4 magnetic safety factor  q  shat real 0.8 magnetic shear  \\hat{s} = (r/q) \\textrm{d}q/\\textrm{d}r  kappa real 0.0 elongation tri real 0.0 triangularity rgeo real 3.0 geometric center-point of the flux-tube betaprim real 0.0 Normalized pressure gradient  \\beta'  kapprim real 0.0 radial derivative of elongation (for radially global simulation) triprim real 0.0 radial derivative of triangularity (for radially global simulation) betadbprim real 0.0 radial derivative of  \\beta'  (for radially global simulation) d2qdr2 real 0.0 second derivative of  q'  (for radially global simulation) d2psidr2 real 0.0 second derivative of  \\psi  (for radially global simulation) nzed_local integer 128 resolution of  z  on which to calculate geometric coefficients. Splines are then used to interpolate onto the grid used during simulation. read_profile_variation boolean false Save information necessary for recalculating Miller equilibrium away from  r . Used for performing local simulations at different radial locations in order to compare to global simulation. write_profile_variation boolean false Recomputes the Miller equilibrium using geometry stored in a file, originally calculated at some  r_\\mathrm{file} , at new  r . namelist vmec_parameters Variable Type Default Description alpha0 real 0.0 zeta_center real 0.0 nfields_periods real -1.0 torflux real 0.6354167 zgrid_scalefac real 1.0 zgrid_refinement_factor real 4 if zed_equal_arc , 1 otherwise surface_option integer 0 verbose boolean true vmec_filename string 'equilibria/wout_w7x_standardConfig.nc' gradpar_zeta_prefac real 1.0 n_tolerated_test_arrays_inconsistencies integer 0 Non-negative integer. Ignores a this number of test_arrays inconsistencies. Useful when running with low-resolution VMEC files, which can be useful for optimization. 0 or 1 are recommended values. namelist zgrid_parameters Used to control the resolution and boundary condition of the parallel coordinate. Variable Type Default Description nzed integer 24 description nperiod integer 1 Controls number of poloidal turns in the flux tube, which is given by n_\\mathrm{pol} = 2 n_\\mathrm{period} -1 ntubes integer 1 Number of cars in the flux tube train boundary_option string 'default' Parallel boundary condition, should be one of default zero incoming, no radial connections, suitable for linear simuatlions linked zero incoming with twist-and-shift boundary condition, suitable for nonlinear simulations stellarator Martin's twist-and-shift boundary for stellarators with local shear periodic periodic for all modes, with option of a phase shift across the parallel boundary zero same as default unconnected same as default self-periodic same as periodic Note that for all of these options, zonal modes are treated as periodic. zed_equal_arc boolean false Arc length is used as the parallel coordinate, so that   \\boldsymbol{\\hat{b} \\cdot \\nabla} \\theta  is constant. shat_zero real 10&#94;{-5} The minimum value of magnetic shear (\\hat{s}) needed to employ the linked boundary condition. Otherwise, periodic boundary conditions are used grad_x_grad_y_zero real 10&#94;{-5} minimum \\nabla x \\cdot \\nabla y  value at the end of the flux-tube which we assume periodic boundary conditions instead of the stellarator symmetric ones when using stellarator boundary condition dkx_over_dky real -1 Set the desired ratio of \\Delta k_x/\\Delta k_y for j_\\mathrm{twist} when using the stellarator boundary condition. namelist vpamu_grid_parameters Variable Type Default Description nvgrid integer 24 Number of positive points in  v_\\parallel . Actual grid will be twice as large. Note that  v_\\parallel = 0 is not included. nmu integer 12 Number of points in the magnetic moment  \\mu . vpa_max real 3.0 Maximum  v_\\parallel  on the grid in terms of thermal velocity. vperp_max real 3.0 Maximum  v_\\perp  on the grid in terms of thermal velocity. equally_spaced_mu_grid boolean false If false, use Gaussian quadrature points for  \\mu  grid (recommended). Otherwise, use equally spaced grid. Both options exclude  \\mu = 0 . conservative_wgts_vpa boolean false Use density-conserving weights for  v_\\parallel . Used primarily by Fokker-Planck collision operator. namelist kt_grids_knobs Variable Type Default Description grid_option string 'default' Sets the layout of the perpendicular grid. Should be one of range use a set range of wavenumbers. Suitable for linear simulation. box use a physical box in coordinate space, i.e., a wavenumber grid that satisfies A_\\boldsymbol{k} = A&#94;\\ast_{-\\boldsymbol{k}} . Required for nonlinear simulation. default same as range annulus same as box nonlinear same as box namelist kt_grids_range_parameters Variable Type Default Description naky integer 1 Number of points along the binormal mode grid direction. nakx integer 1 Number of points along the radial mode grid direction. aky_min real 0.0 Minimum binormal wavenumber, or binormal wavenumber if naky is 1. aky_max real 0.0 Maximum binormal wavenumber if naky larger than 1. akx_min real 0.0 Minimum radial wavenumber. Unused if  \\theta_0  is properly specified. akx_max real -1.0 Maximum radial waveumner. theta0_min real 0.0 Minimum  \\theta_0 = k_x / \\hat{s} k_y . Unused if  \\theta_{0,\\textrm{ min}} > \\theta_{0,\\textrm{ max}} . theta0_max real -1.0 Maximum  \\theta_0 . kyspacing_option string 'default' Sets the spacing between a k_y grid points, available options are : default same as linear linear linear spacing in a k_y exponential linear spacing in \\log{(a k_y)} namelist kt_grids_box_parameters Variable Type Default Description nx integer 1 Real space radial resolution.  Resolved number of modes is 2/3 after dealiasing. Note: checkerboard mode is always excluded. ny integer 1 Real space binormal resolution.  Resolved number of modes is 2/3 after dealiasing. Note: checkerboard mode is always excluded. jtwist integer  \\mathrm{round}(2 \\pi \\hat{s})  Number of independent ballooning modes at  k_{y0} . jtwist_fac real 1.0 Sets jtwist to jtwist_fac times the default value if jtwist is not specified. phase_shift_angle real 0.0 Binormal phase shift when crossing the parallel boundary. For use with purely periodic boundary conditions, and should have no statistical effect for local simulations employing twist-and-shift boundaries. Overwritten for radially global simulations. randomize_phase_shift boolean false Randomize the binormal phase shift. Unused for radially global simulation. x0 real y0 Radial extent of the simulation domain. Ignored when using twist-and-shift (linked) boundary conditions. y0 real -1.0 Binormal extent of the simulation domain. Overwritten if full-flux-surface is used; otherwise, must be set. nalpha real 1 Number of global  \\alpha  grid points. For full-flux-surface simulations. centered_in_rho boolean true Ensure domain radially centered around  r_0 . For use with radially global simulations. periodic_variation boolean false Utilize periodic triangle wave radial variation. For use with radially global simulation. namelist layouts_knobs These options control the ordering of the coordinate and velocity variables when the domain is decomposed. At the moment, there is no reason to use anything other than the default options. Variable Type Default Description xyzs_layout string \"yxzs\" Order of the coordinate variables when decomposed for multicore simulations. vms_layout string \"vms\" Order of the velocity variables when decomposed for multicore simulations. namelist physics_flags Variable Type Default Description full_flux_surface boolean false Enables full-flux-surface simulation. Should use finite  \\rho_\\ast . radial_variation boolean false Enables radially global simulation. Should use finite  \\rho_\\ast . include_parallel_nonlinearity boolean false Include the parallel nonlinearity. Should use finite  \\rho_\\ast . include_parallel_streaming boolean true Include parallel streaming. include_mirror boolean true Include the mirror term. nonlinear boolean false Include the  \\boldsymbol{E \\times B}  nonlinear term. Requires box grid. adiabatic_option boolean false Controls how the adiabatic species is treated in quasineutrality. Should be one of no-field-line-average-term ion adiabatic species, i.e.,  \\delta n_\\mathrm{i}/ n = (Z e/T_\\mathrm{i}) \\varphi . field-line-average-term electron adiabatic species, i.e.,  \\delta n_\\mathrm{e}/ n = (e/T_\\mathrm{e}) (\\varphi - \\langle \\varphi \\rangle_\\psi) . default same as no-field-line-average-term iphi00=0 same as no-field-line-average-term iphi00=1 same as no-field-line-average-term iphi00=2 same as field-line-average-term const_alpha_geo boolean false include_pressure_variation boolean true Include kinetic profile variation when running radially global simulations. Setting this to false does not currently turn everything off. include_geometric_variation boolean true Include magnetic geomety profile variation when running radially global simulations. Setting this to false does not currently turn everything off. namelist parameters Variable Type Default Description beta float 0.0 Plasma  \\beta . Currently has no effect. zeff float 1.0 Effective charge number for use with effective electron-ion and electron-impurity collisions in the Fokker-Planck collision operator (see ecoll_zeff ). tite float 1.0 Ratio of ion to electron temperature,  T_\\mathrm{i}/T_\\mathrm{e} . Used in quasineutrality when adiabatic species is used. nine float 1.0 Ratio of ion to electron density,  n_\\mathrm{i}/n_\\mathrm{e} . Used in quasineutrality when adiabatic species is used. rhostar real -1.0 The gyrokinetic expansion parameter  \\rho_\\mathrm{th,ref}/a_\\mathrm{ref} . For effects beyond the flux-tube limit (full-flux-surface, radially global, neoclassical terms, etc...). Overwritten if irhostar is positive. irhostar real -1.0 Sets rhostar = 1.0 / irhostar if positive. vnew_ref real -1.0 Reference collision frequency. Various input options will overwrite this if it is negative. g_exb real 1.0 Equilibrium  \\boldsymbol{E \\times B}  shear rate. More specifically,  \\gamma_\\boldsymbol{ E \\times B} = (r/q) (\\textrm{d}\\omega / \\textrm{d}r) R_0/\\sqrt{2}v_\\mathrm{th,ref}. Uses the Hammett wavenumber shift method, with nonlinear corrections proposed by McMillan. g_exbfac real 1.0 Prefactor for perpendicular component of equilibrium  \\boldsymbol{E \\times B}  flow shear. Setting to 0.0 turns this component off. omprimfac real 1.0 Prefactor for parallel component of equilibrium  \\boldsymbol{E \\times B}  flow shear. Setting to 0.0 turns this component off. namelist knobs Variable Type Default Description fphi real 1.0 Prefactor for electrostatic potential  \\varphi  wherever it appears. fapar real 1.0 Prefactor for fluctuating vector potential  A_\\parallel  wherever it appears. Currently has no effect . fbpar real -1.0 Prefactor for fluctuating parallel magnetic field  B_\\parallel  wherever it appears. Currently has no effect . delt real 0.0 Initial simulation timestep. CFL constraints may change this throughout the simulation. nstep integer -1 Number of simulation timesteps. tend real -1.0 End-time of the simulation. If not set, then not used. delt_option string ' check_restart ' How to handle setting the timestep on restart. Should be one of check_restart automatically checks the restart file for last saved time step. set_by_hand use delt from input file. default same as check_restart . lu_option string default Parallelization of the LU decomposition. Should be one of none no parallelization. none same as default local Parallelized locally on a core using shared memory. Best case speed-up is j_\\mathrm{twist}\\times (\\textrm{cores per node}). . global parallelized over all cores. Currently only works on experimental branch development/pLU_scalapack which uses ScaLAPACK. If compiled with HAS_ISO_C_BINDING , then it is strongly recommended to run with lu_option='local' . avail_cpu_time real  10&#94;{10}  Available CPU time in seconds . Useful for cleanly ending a run before allocated time runs out. cfl_cushion_upper real 0.5 Safety margin for the CFL condition. cfl_cushion_middle real 0.25 Safety margin used for setting a new smaller timestep when the timestep exceeds cfl_cushion_upper * CLF_dt, or for setting a new \"larger\" timestep when the timesetps is smaller than cfl_cushion_lower * CFL_dt. cfl_cushion_lower real 0.00001 Lowest time-step based on CFL condition. delt_max real -1 If positive, then set the maximum timestep to delt_max ; otherwise, the maximum time step will be the initial one. stream_implicit boolean true Calculate parallel streaming implicitly using the response matrix approach. mirror_implicit boolean true Calculate the mirror term implicitly. driftkinetic_implicit boolean false When calculating parallel streaming, only include the non-gyroaveraged electrostatic potential  \\varphi  in the implicit calculation, and calculate the portion resulting from  \\varphi - \\langle \\varphi \\rangle_\\boldsymbol{R}  explicitly. drifts_implicit boolean false Calculate the magnetic and  \\omega_\\ast  drifts implicitly as an extra term to the operator splitting. stream_matrix_inversion boolean false Use a different tri-diagional solver for parallel streaming. maxwellian_inside_zed_derivative boolean false Experimental - Evaluate the parallel streaming term with the Maxwellian background inside the parallel derivative, and also include the extra term proportional to  \\partial_z B that results from the product rule. mirror_semi_lagrange boolean true Use semi-Lagrange solve for mirror term. Otherwise, use tri-diagonal matrix solve. mirror_linear_interp boolean false Use linear, rather than fourth-order, interpolation when using semi-Lagrange approach for mirror term. zed_upwind real 0.02 Amount of spatial upwinding in  z  when implicit solve is used. Recommended values: 0.02–0.05. vpa_upwind real 0.02 Amount of upwinding in  v_\\parallel  when implicit mirror term is used with the matrix solve. Recommended values: 0.02–0.05. No effect when semi-Lagrange is used. time_upwind real 0.02 Amount of temporal in  t  when implicit solve is used. Recommended values: 0.02–0.05. fields_kxkyz boolean false Calculate electromagnetic fields with a local velocity grid. Requires MPI all-to-all redistrution, and so not recommended. mat_gen boolean false Write out response matrices. lu_option='local' makes this obsolete in most cases . mat_read boolean false Read in response matrices. lu_option='local' makes this obsolete in most cases . rng_seed integer -1 Seeds the random number generator used for the noise initial condition. If negative, then a seed is generated from the current time. ky_solve_radial integer 0 How many  k_y  modes, starting from the zonal mode, for which quasineutrality is to be calculated exactly, rather than perturbatively, for radially global simulation. It is recommended to calculate quasineutrality for all modes exactly, so set this to naky when running radially global. ky_solve_real boolean false Experimental - solve quasineutrality in real space excluding the boundary region when performing a radially global simulation. namelist init_g_knobs Variable Type Default Description ginit_option string 'default' Distribution function initialization option. Should be one of default Gaussian pulse along the zed dimension for every wavenumber. Suitable for linear simulation. noise white noise for every wavenumber. Suitable for nonlinear simulation. many Read from (multiple) restart netcdf files. nltest Not implemented. kxtest Not implemented. kpar Distribution function with particular moments and parallel shapes set by options below. rh Rosenbluth-Hinton initialization of  k_y = 0 zonal mode. Useful for testing linear parallel streaming and magnetic drift physics. remap Initalizates one or two single eigenmodes with finite amplitude. Used for testing wavenumber remapping implementation of equilibrium  \\boldsymbol{E \\times B}  flow shear and, in particular, its nonlinear corrections. width0 real -3.5 If using ginit_option='default' , sets the width of the Gaussian pulse. phiinit real 1.0 Rough size of the resulting root-mean-square electrostatic potential  \\varphi from initialization. Actual size will vary depending on species options, ginit_option , etc... See also scale_to_phiinit . scale_to_phiinit boolean false If true, then upon initialization (not restart!) rescale the distribution function so that the root-mean-squared electrostatic potential  \\varphi  is precisely phiinit , regardless of any other option. restart_file string RUN_NAME.nc Name of the restart file. Note that RUN_NAME derives from RUN_NAME.input , the input file used to run stella. restart_dir string ./ Restart directory. Tip to users: using ./nc/ is often very convenient. read_many boolean true If false, then use MPI_IO to write to one restart file. Otherwise, every core writes to a separate restart file ( recommended ). chop_side boolean false Zero out the distribution function on one side of the z grid. See left . left boolean true If chop_side is true, then zero out the distribution on the left size ( z < 0) of the zed domain. Otherwise, chop it on the right side ( z > 0 ). scale real 1.0 Rescale the distribution function by scale upon restart. tstart real 0.0 Start time of the simulation. Overwritten when restarting. zf_init real 1.0 Prefactor for the  k_y = 0  zonal modes. Setting to 0.0 zeros them out upon initialization. den0 real 1.0 Constant density perturbation component when using ginit_option='kpar' . upar0 real 0.0 Constant parallel velocity perturbation component when using ginit_option='kpar' . tpar0 real 0.0 Constant parallel temperature perturbation component when using ginit_option='kpar' . tperp0 real 0.0 Constant perpendicular temperature perturbation component when using ginit_option='kpar' . den1 real 0.0  \\cos(\\theta)  density perturbation component when using ginit_option='kpar' . upar1 real 0.0  \\cos(\\theta)  parallel velocity perturbation component when using ginit_option='kpar' . tpar1 real 0.0  \\cos(\\theta)  parallel temperature perturbation component when using ginit_option='kpar' . tperp1 real 0.0  \\cos(\\theta)  perpendicular component perturbation component when using ginit_option='kpar' . den2 real 0.0  \\cos(2\\theta)  density perturbation component when using ginit_option='kpar' . upar2 real 0.0  \\cos(2\\theta)  parallel velocity perturbation component when using ginit_option='kpar' . tpar2 real 0.0  \\cos(2\\theta)  parallel temperature perturbation component when using ginit_option='kpar' . tperp2 real 0.0  \\cos(2\\theta)  perpendicular temperature perturbation component when using ginit_option='kpar' . refac real 1.0 Controls the real part of the distribution function when using ginit_option='kpar' . imfac real 0.0 Controls the imaginary part of the distribution function when using ginit_option='kpar' . kxmax real  10&#94;{100}  The maximum radial wavenumber up to which modes are initialized when using ginit_option='rh' . kxmin real 0.0 The maximum minimum wavenumber up fro, which modes are initialized when using ginit_option='rh' . namelist species_knobs Variable Type Default Description nspec integer 2 Number of species. species_option string 'stella' How to read in species data. Should be one of stella Read from stella input file. euterpe Read form euterpe file. input.profiles Reads in General Atomics input.gacode file. This may need to be updated for newer gacode files. default same as stella read_profile_variation boolean false Save information necessary for recalculating kinetic profile quantities away from  r . Used for performing local simulations at different radial locations in order to compare to global simulation. write_profile_variation boolean false Recomputes the kinetic profile information using kinetic profile quantities stored in a file, originally calculated at some  r_\\mathrm{file} , at new  r . ecoll_zeff boolean false If true, use an effective intra-species electron-ion collision rate using zeff . namelist species_parameters Variable Type Default Description z integer 1 charge number. mass real 1.0 particle mass, normalized to  m_\\mathrm{ref} . dens real 1.0 species density, normalized to  n_\\mathrm{ref} . temp real 1.0 species temperature, normalized to  T_\\mathrm{ref} . fprim real -999.9 Density gradient scale length a_\\mathrm{ref}L_{n_s}&#94;{-1} = - a_\\mathrm{ref} \\textrm{d} \\ln n_s/ \\textrm{d}r ). Note the negative sign. tprim real -999.9 Temperature gradient scale length a_\\mathrm{ref}L_{T_s}&#94;{-1} = - a_\\mathrm{ref} \\textrm{d} \\ln T_s/ \\textrm{d}r ). Note the negative sign. d2ndr2 real 0.0 Second derivative of density, normalized to  a_\\mathrm{ref}&#94;2/n_\\mathrm{ref}. For use with radially global simulation. d2Tdr2 real 0.0 Second derivative of temperature, normalized to  a_\\mathrm{ref}&#94;2/T_\\mathrm{ref}. For use with radially global simulation. bess_fac real 1.0 Perfactor for Bessel function argument. Setting to 0.0 renders particle drift-kinetic. type string 'default' Particle type. Should be one of ion ion species. default same as ion . electron electron species. e same as electron beam slowing down species. fast same as beam . alpha same as beam . slowing-down same as beam . trace tracer species. namelist time_advance_knobs Variable Type Default Description xdriftknob real 1.0 Prefactor for radial magnetic drift. Setting to 0.0 turns the term off. ydriftknob real 1.0 Prefactor for the binormal magnetic drift. Setting to 0.0 turns the term off. wstarknob real 1.0 Prefactor for the  \\omega_\\ast  term. Setting to 0.0 turns the term off. explicit_option string 'default' Chooses the Runge-Kutta scheme for the explicit integration. Should be one of rk2 second-order Runge-Kutta. rk3 third-order strong-stability-preserving Runge-Kutta (recommended). rk4 fourth-order Runge-Kutta. default same as rk3 . Note that higher-order Runge-Kutta schemes can increase memory usage. flip_flop boolean false Utilize the flip-flopping approach that flips the integration order every time-step. Should increase time accuracy, at least linearly. Does sometimes lead to spurious oscillations. namelist stella_diagnostics_knobs These options control which diagnostics are output by stella. NOTE: stella safely appends to both ASCII and netCDF files upon restart, so there is no need to copy files and move them around. Also note that radial fluxes are always written to an ASCII file named RUN_NAME.fluxes . Variable Type Default Description nwrite integer 50 Output cadence (i.e. number of iterations) between output diagnostics. navg integer 50 Number of timesteps over which to average the real and imaginary mode frequencies. nsave integer -1 Output cadence of restart dumps. If negative, no restart dumps are written. save_for_restart boolean false Write restart dumps. If true , then nsave should also be positive. write_phi_vs_time boolean false Write the full electrostatic potential  \\varphi  to the output netCDF file. write_gvmus boolean false Writes \\sum_\\boldsymbol{k}L_z&#94;{-1}\\int \\textrm{d}z \\lvert g_\\boldsymbol{k} \\rvert&#94;2  to the netCDF file. Resulting quantity varies over v_\\parallel,  \\mu_s  and the species index  s. write_gzvs boolean false Writes \\sum_\\boldsymbol{k}L_z&#94;{-1}\\int \\textrm{d} \\mu_s \\lvert g_\\boldsymbol{k} \\rvert&#94;2  to the netCDF file. Resulting quantity varies over v_\\parallel,  z  and the species index  s. write_omega boolean false Write the real and imaginary mode frequencies to both ASCII formats ( RUN_NAME.omega ) and the netCDF file. write_kspectra boolean false Writes \\langle \\lvert \\varphi(k_x, k_y, z)\\rvert&#94;2 \\rangle_\\psi  to the netCDF file. write_moments boolean false Write the moments of the distribution function (density, parallel velocity and temperature for each species) to the netCDF file. write_radial_fluxes boolean false Write the flux-surface-averaged radial fluxes to the netCDF file. write_radial_moments boolean false Write the flux-surface-averaged fluctuation moments to the netCDF file. write_fluxes_kxkyz boolean false Write the mode-by-mode radial fluxes as a function of  z  to the netCDF file. flux_norm boolean true If true, then scale radial fluxes by  \\langle\\lvert \\nabla r\\rvert \\rangle_\\psi , otherwise perform no rescaling. nc_mult integer 1 Multiplication factor of the output cadence for netCDF files, which tend to take up more storage space than the ASCII output files. namelist multibox_parameters Variable Type Default Description boundary_size integer 4 Number of collocation points in the boundary region. krook_size integer 0 Number of collocation points in the Krook region. Will automatically max out at boundary_size . zf_option string 'default' Experimental - Set how the zonal mode is handled during the communication of the multiple-flux-tube boundary condition. Should be one of default Do not treat the  k_y = 0 mode specially. skip_ky0 Do not communicate any information for the   k_y = 0 mode, i.e., let it evolve without any input from auxilliary simulations. zero_ky0 Zero the  k_y = 0 mode in the boundary region. zero_fsa Zero only the flux-surface-averaged component of the k_y = 0 mode (keeping  v_{\\parallel}  and  \\mu_s  constant) in the boundary region. Note that this is not equivalent to zeroing the transit/bounce-averaged component, which would be the physically correct approach. krook_option string 'exp' Shape of the Krook operator in the Krook region. Should be one of flat constant shape linear linearly decreasing towards physical region exp decreasing exponentially fast to the physical region, recommended exp_rev decreasing exponentially slowly to the physical region. default same as exp RK_step boolean false Communicate the multiple-flux-tube boundary condition at every implicit and Runge-Kutta substep, rather than one per timestep. nu_krook_mb real 0.0 Strength (i.e. damping rate) of the Krook operator in the boundary region. mb_debug_step integer -1 If positive, print out gnuplot-readable binary dump of the real-space electrostatic potential  \\varphi )) at the outboard midplane at every mb_debug_step steps. krook_exponent real 0.0 Add a (k_y/k_{y0})&#94;{\\texttt{krook_exponent}} prefactor to the multibox Krook operator. comm_at_init boolean false Communicate the boundary condition at the beginning of the simulation before time_advance is initialized. phi_bound integer 0 How many points into the boundary region on which to solve for the electrostatic potential  \\varphi  when ky_solve_real is true. phi_pow real 0.0 Experimental - Which derivative of the electrostatic potential  \\varphi  to solve for when ky_solve_real is true. krook_efold real 3.0 How many e-folds to use when krook_option is exp or exp_rev . use_dirichlet_BC boolean false Apply the Dirichlet boundary condition when performing a single flux-tube simulation, i.e., utilize the machinery in the multibox module, but use zeros in the communication instead of data generated from additional local simulations. LR_debug_option string 'default' Left/Right debug option. Should be one of default Do not use this debug option. L set  x  uniformly to  x_\\mathrm{L} , the leftmost point in the physical region. R set  x  uniformly to  x_\\mathrm{R} , the rightmost point in the physical region. Useful for comparing the center domain to left/right domains in radially global simulation. smooth_ZFs boolean false Experimental - Try smoothing the zonal flows across the interface between boundary and physical region. Never really worked properly. namelist sources Variable Type Default Description source_option string 'none' Type of source used for radially global simulation. Should be one of none no source used. default same as none . Krook Krook operator based source. projection Projection operator based source. conserve_momentum boolean false Enforce momentum conservation in the source. conserve_density boolean false Enforce density conservation in the source. tcorr_source real 0.02 Time correlation of the source. Should be a longer timescale than any of interest in the problem. nu_krook real 0.05 Strength (i.e. damping rate) of the Krook source. ikxmax_source integer 2 for periodic_variation , 1 otherwise Maximum radial wavenumber on which the source acts. krook_odd boolean true Experimental - Only act on the modes that can affect the profiles. exclude_boundary_regions boolean radial_variation and not periodic_variation Ensure that source only acts on the physical region of the radial domain. tcorr_source_qn real 0.0 Experimental - Time correlation of the source in quasineutrality. exclude_boundary_regions_qn boolean exclude_boundary_regions Exclude boundary regions when applying the source in quasineutrality. from_zero boolean true Time correlated source starts from zero, rather than value of the distribution function at  t = 0 . namelist dissipation Variable Type Default Description include_collisions boolean true Include particle collisions. collisions_implicit boolean true Evaluate the collision operator implicitly. collision_model string 'dougherty' Which collision operator to use. Options are 'dougherty' (simplified operator) or 'fokker-planck' (physical operator). hyper_dissipation boolean false Include hyper-dissipation. Strongly recommended for nonlinear simulations. namelist collisions_dougherty Variable Type Default Description momentum_conservation boolean true Enforce momentum conservation. energy_conservation boolean true Enforce energy conservation. vpa_operator boolean true Include  \\partial_{v_\\parallel}  components of collision operator. mu_operator boolean true Include  \\partial_\\mu  components of collision operator. namelist collisions_fp Variable Type Default Description testpart boolean true test particle component of Fokker-Planck operator. Must be true. fieldpart boolean false enable the field particle component (FPO) of the Fokker-Planck operator. interspec boolean true inter-species collisions in the Fokker-Planck operator. intraspec boolean true intra-species collisions in the Fokker-Planck operator. lmax integer 1 maximum l in spherical harmonic expansion of the field particle operator jmax integer 1 maximum j in Hirshman-Sigmar expansion of the field particle operator iiknob real 1.0 control the ion-ion collision frequency in Fokker-Planck operator ieknob real 1.0 control the ion-electron collision frequency in Fokker-Planck operator. eiknob real 1.0 control the electron-ion collision frequency in Fokker-Planck operator. eeknob real 1.0 control the electron-electron collision frequency in Fokker-Planck operator. eiediffknob real 1.0 control the electron-ion energy diffusion in Fokker-Planck operator. eideflknob real 1.0 control the electron-ion pitch angle scattering in Fokker-Planck operator. deflknob real 1.0 control pitch angle scattering in Fokker-Planck operator, must be 1 or 0. eimassr_approx boolean false use mass ratio approxfimation for test particle operator, beta . advfield_coll boolean true disable electrostatic potential terms in the field particle operator, beta . spitzer_problem boolean false Solve the Spitzer problem for tests of the collision operator density_conservation boolean false if True and equally_spaced_mu_grid=True and conservative_wgts_vpa=True , then test-particle operator conserves density to machine precision. density_conservation_field boolean false if True and jmax , lmax < 2 , then field-particle operator conserves density to machine precision. density_conservation_tp boolean false if True add term to field particle operator to ensure density conservation, also on non-uniform grids. exact_conservation boolean false if True and fieldpart=True and lmax=jmax=1 then momentum and energy conserved to machine precision - in beta . Works only if nux = 0 , need to correct the discretisation of nux terms in test-particle operator. exact_conservation_tp boolean false if True and lmax=jmax=1 then momentum and energy conserved to machine precision, by using the test particle operator  to compute field particle terms; this is slower than exact_conservation. vpa_operator boolean true Include  \\partial_{v_\\parallel}  components of collision operator. mu_operator boolean true Include  \\partial_\\mu  components of collision operator. cfac real 1.0 scale gyrodiffusive term in test particle component of Fokker-Planck operator. cfac2 real 1.0 scale gyrodiffusive terms in field particle component of Fokker-Planck operator - in beta . nuxfac real 1.0 scale nux (mixed derivative) terms in test particle component of Fokker-Planck operator. i1fac real 1.0 for Spitzer problem i2fac real 0.0 for Spitzer problem no_j1l1 boolean true disable j1l1 term in the field particle component of Fokker-Planck operator no_j1l2 boolean false disable j1l2 term no_j0l2 boolean false disable j0l2 term nvel_local integer 512 Size of velocity grid used for debugging. Currently, this option has no effect. namelist hyper Variable Type Default Description D_hyper real 0.05 Maximal hyperdissipation damping rate. use_physical_ksqr boolean true if global, false otherwise If true, use actual  k&#94;2_\\perp = k_x&#94;2 \\lvert \\nabla x \\rvert&#94;2 + 2 k_xk_y (\\nabla x \\cdot \\nabla y) + k_y&#94;2 \\lvert\\nabla y \\rvert&#94;2 . Otherwise, use  k_\\perp&#94;2 = k_y&#94;2[1 + (\\theta - \\theta_0)&#94;2]. scale_to_outboard boolean false If true, scale maximal damping rate to maximum  k_\\perp&#94;2  at outboard midplane. Otherwise, scale maximal damping to maximum  k_\\perp&#94;2  over the entire domain. namelist neoclassical_input Variable Type Default Description include_neoclassical_terms boolean false Include neoclassical terms. Need to use sfincs for input. neo_option string 'sfincs' Option for obtaining neoclassical distribution function and potential. Currently, only 'sfincs' is supported. nradii integer 5 Number of radial points used for radial derivatives of neoclassical quantities. drho real 0.01 spacing in rhoc between points used for radial derivatives. namelist sfincs_input Variable Type Default Description read_sfincs_output_from_file boolean false if true, will try to read in Phi1Hat and delta_f from pre-saved file named sfincs.output . Otherwise, run sfincs to compute these quantities on the fly. nproc_sfincs integer 1 Number of processors to use for sfincs calculations. calculate_radial_electric_field boolean true If true, then scan in radial electric field to find value for which ambipolarity is satisfied, and then use this value to obtain neoclassical fluxes, distribution function, and potential. includeXDotTerm boolean true include radial electric field term includeElectricFieldTermInXiDot boolean true irad_min integer -nardii / 2 minimum radial index ( irad=0 corresponds to central radius). irad_max integer nradii / 2 maximum radial index. magneticDriftScheme integer 0 ??? includePhi1 boolean true If true , then Phi1 will be calculated using quasineutrality. includePhi1InKineticEquation boolean false geometryScheme integer 1 will be overridden by direct input of geometric quantities unless geometryScheme = 5 (VMEC equilibrium) VMECRadialOption integer 0 only relevant if geometryScheme = 5 . Radial option to use for VMEC equilibrium. Must be one of equilibriumFile string 'wout_161s1.nc' path of VMEC equilibrium file. coordinateSystem integer 3 ??? inputRadialCoordinate integer 3 option 3 corresponds to using square root of toroidal flux normalized by toroidal flux enclose by the LCFS. inputRadialCoordinateForGradients integer 3 option 3 corresponds to same choise when calculating gradients of density, temperature, and potential ahat real 1.0 corresponds to  r_\\mathrm{LCFS}  as reference length in sfincs. Only used in sfincs when geometryScheme = 1 . psiAHat real geo_surf%psitor_lcfs  \\psi_\\mathrm{LCFS} / B_\\mathrm{ref}a&#94;2_\\mathrm{ref} . Delta real -1.0  \\Delta = \\rho_\\ast m_\\mathrm{ref}v_\\mathrm{th,ref}/(eB_\\mathrm{ref}a_\\mathrm{ref}) , with reference quantities given in SI units unless geometryScheme = 5, in which case B_\\mathrm{ref} = 1  Tesla and a_\\mathrm{ref}  = 1  meter (these are hardwired in sfincs). Set negative to allow check later to see if any value given in input file. dPhiHatdrN real -9999.9 radial derivative of normalized  \\phi . nu_N real -1.0 \\nu_n = \\nu_\\mathrm{ref} a_\\mathrm{ref}/ v_\\mathrm{th,ref}. Note that  \\nu_\\mathrm{ref} = 4 \\sqrt{2 \\pi} n_\\mathrm{ref}e&#94;4 \\ln \\Lambda / (3m&#94;{1/2} \\mathrm{ref}T \\mathrm{ref}&#94;{3/2}). Set negative to allow check later to see if any value given in input file. nxi integer 48 number of spectral coefficients in pitch angle nx integer 12 number of speeds ntheta integer 65 number of poloidal angles. nzeta integer 1 number of toroidal angles. 1 is approriate for tokamaks. Er_window real 0.3 ???","tags":"","loc":"page/user_manual/namelists.html"},{"title":"Output in stella – stella","text":"","tags":"","loc":"page/user_manual/output.html"},{"title":"stella's algorithm – stella","text":"","tags":"","loc":"page/user_manual/algorithm.html"},{"title":"Parallelism in stella – stella","text":"","tags":"","loc":"page/user_manual/parallelization.html"},{"title":"Coordinate system – stella","text":"","tags":"","loc":"page/user_manual/coordinates.html"},{"title":"Radially global stella – stella","text":"","tags":"","loc":"page/user_manual/radial_stella.html"},{"title":"Full-flux-surface stella – stella","text":"","tags":"","loc":"page/user_manual/ffs_stella.html"}]}